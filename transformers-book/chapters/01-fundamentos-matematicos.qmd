# Fundamentos Matemáticos {#sec-fundamentos}

Neste capítulo, a curiosa leitora irá enfrentar os *Transformers*. Nenhuma relação com o Optimus Prime. Se for estes *Transformers* que está procurando, **o Google falhou com você!**

Neste texto vamos discutir os **Transformers** modelos de aprendizado de máquina que revolucionaram o processamento de linguagem natural (**NLP**). Estas técnicas foram apresentados ao mundo em um artigo intitulado *Attention is All You Need* (Atenção é Tudo que Você Precisa), publicado em 2017 na conferência *Advances in Neural Information Processing Systems (NeurIPS)*. Observe, atenta leitora que isso se deu há quase 10 anos. No ritmo atual, uma eternidade.

O entendimento da linguagem natural por máquinas é, ou era, um desafio importante que beirava o impossível. Este problema parece estar resolvido. Se isso for verdade, terá sido graças as técnicas e algoritmos, criados em torno de aprendizado de máquinas e estatísticas. Ou se preferir, podemos dizer que Usamos algoritmos determinísticos para aplicar técnicas estocásticas em bases de dados gigantescas e assim, romper os limites que haviam sido impostos pela linguística matemática e computacional determinísticas.

Veremos como esses modelos, inicialmente projetados para tradução automática, se tornaram a base para tarefas como geração de texto, como no GPT-3, compreensão de linguagem e até mesmo processamento de áudio.

Começaremos com as técnicas de representação mais simples e os conceitos matemáticos fundamentais: produtos escalares e multiplicação de matrizes. E, gradualmente, construiremos nosso entendimento. O que suporta todo este esforço é a esperança que a esforçada leitora possa acompanhar o raciocínio e entender como os *Transformers* funcionam a partir do seu cerne.

Finalmente, os exemplos. O combinado será o seguinte: aqui eu faço em C++ 20. Depois, a leitora faz em Python, C, C++ ou qualquer linguagem que desejar. Se estiver de acordo continuamos.

Para que os computadores processem e compreendam a linguagem humana, é essencial converter texto em representações numéricas. Esse treco burro só entende binário. Dito isso, vamos ter que, de alguma forma, mapear o conjunto dos termos que formam uma linguagem natural no conjunto dos binários que o computador entende. Ou, em outras palavras, temos que representar textos em uma forma matemática que os computadores possam manipular. Essa representação é o que chamamos de vetorização.

## Vetores, os compassos de tudo que há e haverá

Um vetor é uma entidade matemática que possui tanto magnitude, ou comprimento, quanto direção. Um vetor pode ser definido como um segmento de reta direcionado na geometria, ou uma sequência ordenada de números, chamados de componentes, na álgebra. A representação depende do contexto. Aqui, vamos nos concentrar na representação algébrica, que é mais comum em programação e computação.

Na geometria, um vetor pode ser visualizado como uma seta em um espaço, por exemplo, em um plano $2D$ ou em um espaço $3D$. O comprimento da seta representa a magnitude, e a direção da seta indica a direção do vetor. Imagine uma seta apontando para cima e para a direita em um plano. Essa seta é um vetor com uma certa magnitude (o comprimento da seta) e uma direção ($45$ graus em relação ao eixo horizontal, por exemplo).

![uma seta vermelha representando um vetor](/assets/images/vector1.webp){#fig-vector1}

Em um sistema algébrico de coordenadas, um vetor pode ser representado como uma tupla. Por exemplo, em um espaço tridimensional, um vetor pode ser escrito como $(x, y, z)$, onde $x$, $y$ e $z$ são as componentes do vetor ao longo dos eixos $x$, $y$ e $z$, respectivamente. Assim, se nos limitarmos a $2D$, o vetor $(2, 3)$ representa um deslocamento de $2$ unidades na direção $x$ e $3$ unidades na direção $y$. Na @fig-vector1 podemos ver um vetor $V$ partindo da origem $O$ e terminando no ponto $P(V_1, V_2)$.

### Espaço Vetorial

Para compreender vetores e suas operações, precisamos primeiro entender um conceito algébrico, o conceito de espaço vetorial.

>Um espaço vetorial é uma estrutura matemática que formaliza a noção de operações geométricas como adição de vetores e multiplicação por escalares.

Formalmente, um espaço vetorial sobre um corpo $F$ é um conjunto $V$ no qual há adição de vetores e multiplicação por escalares em $F$, obedecendo axiomas que garantem associatividade, comutatividade, existência de neutro e inverso aditivo, além de compatibilidade entre multiplicação por escalar e estrutura do corpo.

Em processamento de linguagem natural, trabalharemos principalmente com o espaço vetorial real $\mathbb{R}^n$, onde $n$ representa a dimensão do espaço vetorial. Ou, em nosso caso, quantos itens teremos no nosso vetor. Logo, $\mathbb{R}^n$ representa o espaço vetorial que contém todas as $n$-tuplas ordenadas de números reais. Formalmente, definimos $\mathbb{R}^n$ como:

$$
\mathbb{R}^n = \{(x_1, \ldots, x_n) : x_i \in \mathbb{R} \text{ para } i = 1, \ldots, n\}
$$

Quando representarmos palavras (termos), ou documentos, como vetores, estaremos mapeando elementos linguísticos para pontos em um espaço dado por $\mathbb{R}^n$. Neste caso, a dimensão $n$ será determinada pelo método específico de vetorização que escolhermos.

Ao converter textos e elementos linguísticos em representações vetoriais, criamos *word embeddings*. Técnicas que mapeiam palavras ou frases para vetores de números reais. Esta representação tenta capturar tanto o significado semântico quanto as relações contextuais entre palavras em um espaço vetorial contínuo. 

>Embeddings são representações vetoriais densas de palavras ou frases, onde cada dimensão captura uma característica semântica ou gramatical.

Um desenvolvimento importante no campo do processamento de linguagem natural está sintetizado nos Mecanismos de Atenção, que utilizam vetores de consulta (*query*), chave (*key*) e valor (*value*) como componentes essenciais. Estes mecanismos constituem o núcleo da arquitetura dos *Transformers*, permitindo que o modelo pondere a importância relativa de diferentes elementos em uma sequência, melhorando significativamente a capacidade de processamento de dependências de longo alcance em textos. Para entender isso, precisamos entender como fazer operações algébricas com vetores.

### Operações com Vetores

Dado que estejam em um espaço vetorial, os vetores podem ser somados, subtraídos, multiplicados entre si e por escalares. Neste caso, a curiosa leitora deve saber que *escalares são entidades sem direção*. As operações sobre vetores têm interpretações geométricas e algébricas. Focando apenas nas interpretações algébricas, temos:

1. **Soma**: somamos vetores componente a componente. Exemplo: se tivermos $\vec{a}= (1, 2)$ e $\vec{b}= (3, -1)$ então $\vec{a} + \vec {b}$ será dado por $(1, 2) + (3, -1) = (4, 1)$;

2. **Oposto**: Dado um vetor $\vec{v} = (v_1, v_2, \ldots, v_n)$ no espaço $\mathbb{R}^n$, seu oposto será dado por $-\vec{v} = (-v_1, -v_2, \ldots, -v_n)$. Ou seja, o vetor oposto é o vetor que aponta na direção oposta e tem a mesma magnitude. Exemplo: se $\vec{a}= (1, 2)$ o oposto de $\vec{a}$ será dado por $-\vec{a} = (-1, -2)$;

3. **Multiplicação por escalar**: multiplicar um vetor por um escalar altera a sua magnitude, mas não a sua direção, a menos que o escalar seja negativo, caso em que a direção é invertida. Exemplo: dado $\vec{a} = (1, 2)$ o dobro de $\vec{a}$ será dado por $2 * (1, 2) = (2, 4)$;

### Exemplo Operações com Vetores em C++ 20

```cpp
#include <iostream>         ///< Para entrada e saída padrão (std::cout, std::cerr).
#include <vector>          ///< Para contêiner std::vector usado no armazenamento de componentes.
#include <numeric>         ///< Para std::inner_product, usado no cálculo do produto escalar.
#include <cmath>           ///< Para std::sqrt e std::abs, usados em cálculos de magnitude.
#include <concepts>        ///< Para std::is_arithmetic_v, usado no conceito Arithmetic.
#include <stdexcept>       ///< Para exceções padrão como std::out_of_range e std::invalid_argument.
#include <string>          ///< Para std::string e std::to_string, usados na conversão para string.
#include <sstream>         ///< Para std::stringstream, usado na formatação de números de ponto flutuante.
#include <iomanip>         ///< Para std::fixed e std::setprecision, usados na formatação de saída.
#include <initializer_list> ///< Para suporte a inicialização de vetores com listas inicializadoras.
#include <algorithm>       ///< Para std::abs, usado em cálculos de magnitude.

/**
 * @concept Arithmetic
 * @brief Conceito para garantir que um tipo é aritmético (integral ou de ponto flutuante).
 *
 * Restringe os parâmetros de template a tipos aritméticos (por exemplo, int, double, float).
 */
template<typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

/**
 * @class MathVector
 * @brief Uma classe genérica para representar e manipular vetores matemáticos.
 *
 * Fornece operações como adição, subtração, multiplicação por escalar, produto escalar,
 * cálculo de magnitude e normalização. Suporta vetores de qualquer tipo aritmético.
 *
 * @tparam T O tipo aritmético dos componentes do vetor (por exemplo, int, double).
 */
template<Arithmetic T>
class MathVector {
private:
    std::vector<T> components; ///< Armazenamento interno para os componentes do vetor.
    static constexpr T epsilon = 1e-9; ///< Constante pequena para comparações de ponto flutuante.

public:
    /**
     * @brief Construtor padrão que cria um vetor vazio.
     */
    MathVector() = default;

    /**
     * @brief Constrói um vetor a partir de uma lista inicializadora.
     * @param init Lista inicializadora contendo os componentes do vetor.
     */
    MathVector(std::initializer_list<T> init) : components(init) {}

    /**
     * @brief Constrói um vetor a partir de um std::vector.
     * @param vec O vetor de entrada contendo os componentes.
     */
    explicit MathVector(const std::vector<T>& vec) : components(vec) {}

    /**
     * @brief Constrói um vetor de tamanho especificado com todos os componentes inicializados com um valor.
     * @param n O número de componentes.
     * @param val O valor inicial para todos os componentes (padrão é T{}).
     */
    explicit MathVector(size_t n, T val = T{}) : components(n, val) {}

    /**
     * @brief Retorna o número de dimensões (componentes) do vetor.
     * @return O tamanho do vetor.
     */
    size_t dimensions() const {
        return components.size();
    }

    /**
     * @brief Fornece acesso não constante a um componente do vetor.
     * @param index O índice do componente a acessar.
     * @return Referência ao componente no índice especificado.
     * @throws std::out_of_range Se o índice estiver fora dos limites.
     */
    T& operator[](size_t index) {
        if (index >= dimensions()) {
            throw std::out_of_range("Índice fora dos limites do vetor");
        }
        return components[index];
    }

    /**
     * @brief Fornece acesso constante a um componente do vetor.
     * @param index O índice do componente a acessar.
     * @return Referência constante ao componente no índice especificado.
     * @throws std::out_of_range Se o índice estiver fora dos limites.
     */
    const T& operator[](size_t index) const {
        if (index >= dimensions()) {
            throw std::out_of_range("Índice fora dos limites do vetor");
        }
        return components[index];
    }

    /**
     * @brief Soma dois vetores componente a componente.
     * @param other O vetor a ser somado a este vetor.
     * @return Um novo vetor representando a soma.
     * @throws std::invalid_argument Se os vetores tiverem dimensões diferentes.
     */
    MathVector<T> operator+(const MathVector<T>& other) const {
        if (dimensions() != other.dimensions()) {
            throw std::invalid_argument("Não é possível somar vetores de dimensões diferentes");
        }
        MathVector<T> result(dimensions());
        for (size_t i = 0; i < dimensions(); ++i) {
            result[i] = components[i] + other[i];
        }
        return result;
    }

    /**
     * @brief Subtrai um vetor de outro componente a componente.
     * @param other O vetor a ser subtraído deste vetor.
     * @return Um novo vetor representando a diferença.
     * @throws std::invalid_argument Se os vetores tiverem dimensões diferentes.
     */
    MathVector<T> operator-(const MathVector<T>& other) const {
        if (dimensions() != other.dimensions()) {
            throw std::invalid_argument("Não é possível subtrair vetores de dimensões diferentes");
        }
        MathVector<T> result(dimensions());
        for (size_t i = 0; i < dimensions(); ++i) {
            result[i] = components[i] - other[i];
        }
        return result;
    }

    /**
     * @brief Multiplica o vetor por um escalar.
     * @param scalar O valor escalar para multiplicação.
     * @return Um novo vetor com componentes escalados.
     */
    MathVector<T> operator*(T scalar) const {
        MathVector<T> result(dimensions());
        for (size_t i = 0; i < dimensions(); ++i) {
            result[i] = components[i] * scalar;
        }
        return result;
    }

    /**
     * @brief Retorna o vetor oposto (negado).
     * @return Um novo vetor com todos os componentes negados.
     */
    MathVector<T> operator-() const {
        MathVector<T> result(dimensions());
        for (size_t i = 0; i < dimensions(); ++i) {
            result[i] = -components[i];
        }
        return result;
    }

    /**
     * @brief Calcula o produto escalar deste vetor com outro.
     * @param other O outro vetor para o produto escalar.
     * @return O resultado escalar do produto escalar.
     * @throws std::invalid_argument Se os vetores tiverem dimensões diferentes.
     */
    T dot(const MathVector<T>& other) const {
        if (dimensions() != other.dimensions()) {
            throw std::invalid_argument("Não é possível calcular o produto escalar de vetores de dimensões diferentes");
        }
        return std::inner_product(components.begin(), components.end(), other.components.begin(), T(0));
    }

    /**
     * @brief Calcula a magnitude euclidiana (norma L2) do vetor.
     * @return A magnitude do vetor.
     * @note Para tipos integrais, converte para double para sqrt e converte de volta.
     */
    T magnitude() const {
        T sum_of_squares = this->dot(*this);
        if constexpr (std::is_integral_v<T>) {
            return static_cast<T>(std::sqrt(static_cast<double>(sum_of_squares)));
        } else {
            return std::sqrt(sum_of_squares);
        }
    }

    /**
     * @brief Normaliza o vetor para ter comprimento unitário.
     * @return Um novo vetor normalizado.
     * @throws std::domain_error Se a magnitude do vetor for zero ou próxima de zero.
     */
    MathVector<T> normalize() const {
        T mag = magnitude();
        if (std::abs(mag) < epsilon) {
            throw std::domain_error("Não é possível normalizar um vetor de magnitude zero (ou muito próxima de zero)");
        }
        MathVector<T> result(dimensions());
        for (size_t i = 0; i < dimensions(); ++i) {
            result[i] = components[i] / mag;
        }
        return result;
    }

    /**
     * @brief Converte o vetor para uma representação em string.
     * @return Uma string representando o vetor (por exemplo, "[1.0000, 2.0000]").
     * @note Para tipos de ponto flutuante, usa precisão fixa de 4 casas decimais.
     */
    std::string to_string() const {
        std::string result = "[";
        for (size_t i = 0; i < dimensions(); ++i) {
            if constexpr (std::is_floating_point_v<T>) {
                std::stringstream ss;
                ss << std::fixed << std::setprecision(4) << components[i];
                result += ss.str();
            } else {
                result += std::to_string(components[i]);
            }
            if (i < dimensions() - 1) {
                result += ", ";
            }
        }
        result += "]";
        return result;
    }

    /**
     * @brief Fornece iterador para o início dos componentes do vetor.
     * @return Iterador para o primeiro componente.
     */
    auto begin() const {
        return components.begin();
    }

    /**
     * @brief Fornece iterador para o fim dos componentes do vetor.
     * @return Iterador após o último componente.
     */
    auto end() const {
        return components.end();
    }

    /**
     * @brief Fornece iterador não constante para o início dos componentes do vetor.
     * @return Iterador para o primeiro componente.
     */
    auto begin() {
        return components.begin();
    }

    /**
     * @brief Fornece iterador não constante para o fim dos componentes do vetor.
     * @return Iterador após o último componente.
     */
    auto end() {
        return components.end();
    }

    /**
     * @brief Retorna o vetor de componentes subjacente.
     * @return Referência constante ao std::vector interno de componentes.
     */
    const std::vector<T>& get_components() const {
        return components;
    }
};

/**
 * @brief Multiplica um escalar por um vetor (escalar * vetor).
 * @tparam T O tipo aritmético dos componentes do vetor.
 * @param scalar O valor escalar.
 * @param vec O vetor a ser multiplicado.
 * @return Um novo vetor com componentes escalados.
 */
template<Arithmetic T>
MathVector<T> operator*(T scalar, const MathVector<T>& vec) {
    return vec * scalar;
}

/**
 * @brief Imprime um MathVector com um nome especificado.
 * @tparam T O tipo aritmético dos componentes do vetor.
 * @param vec O vetor a ser impresso.
 * @param name O nome a ser exibido ao lado do vetor.
 */
template<Arithmetic T>
void print_mathvector(const MathVector<T>& vec, const std::string& name) {
    std::cout << name << " = " << vec.to_string() << "\n";
}

/**
 * @brief Função principal que demonstra operações com a classe MathVector.
 *
 * Este programa ilustra o uso da classe MathVector para realizar operações como adição,
 * subtração, multiplicação por escalar, cálculo do vetor oposto, produto escalar,
 * magnitude e normalização de vetores, com tratamento de erros robusto.
 *
 * @return 0 em caso de execução bem-sucedida.
 */
int main() {
    std::cout << std::fixed << std::setprecision(4);
    std::cout << "Demonstração de Operações com MathVector\n";
    std::cout << "---------------------------------------\n\n";

    // Inicialização dos vetores
    MathVector<double> a = {2.0, 5.0, 1.0}; ///< Primeiro vetor para demonstração.
    MathVector<double> b = {3.0, 1.0, 4.0}; ///< Segundo vetor para demonstração.

    // Exemplo 1: Operações básicas
    std::cout << "Exemplo 1: Operações básicas\n";
    try {
        print_mathvector(a, "Vetor a");
        print_mathvector(b, "Vetor b");

        // Adição
        MathVector<double> sum = a + b;
        print_mathvector(sum, "a + b");

        // Subtração
        MathVector<double> diff = a - b;
        print_mathvector(diff, "a - b");

        // Multiplicação por escalar
        MathVector<double> scaled = 2.0 * a;
        print_mathvector(scaled, "2 * a");

        // Vetor oposto
        MathVector<double> opposite = -a;
        print_mathvector(opposite, "-a");
    } catch (const std::exception& e) {
        std::cerr << "Erro nas operações básicas: " << e.what() << "\n";
    }

    // Exemplo 2: Produto escalar
    std::cout << "\nExemplo 2: Produto escalar\n";
    try {
        double dot_product = a.dot(b);
        std::cout << "a · b = " << dot_product << "\n";
    } catch (const std::exception& e) {
        std::cerr << "Erro no cálculo do produto escalar: " << e.what() << "\n";
    }

    // Exemplo 3: Magnitude e normalização
    std::cout << "\nExemplo 3: Magnitude e normalização\n";
    try {
        double mag_a = a.magnitude();
        std::cout << "Magnitude de a = " << mag_a << "\n";

        MathVector<double> a_normalized = a.normalize();
        print_mathvector(a_normalized, "Vetor a normalizado");
        std::cout << "Magnitude de a normalizado = " << a_normalized.magnitude() << "\n";
    } catch (const std::exception& e) {
        std::cerr << "Erro no cálculo de magnitude ou normalização: " << e.what() << "\n";
    }

    return 0;
}
```

## Produto Escalar

Entre as operações entre vetores vamos começar com os produtos escalares, também conhecidos como produto interno. Neste caso, temos uma técnica para multiplicar vetores de forma que o resultado seja um escalar, um número sem dimensão. Para obter o produto escalar, representado por $\cdot$, de dois vetores, multiplicamos seus elementos correspondentes e, em seguida, somamos os resultados das multiplicações. Matematicamente temos:

$$
\text{Se } \vec{a} = [a_1, a_2, ..., a_n] \text{ e } \vec{b} = [b_1, b_2, ..., b_n], \text{ então:}
$$

$$
\vec{a} \cdot \vec{b} = \sum_{i=1}^{n} a_i b_i = a_1b_1 + a_2b_2 + ... + a_nb_n
$$

![dois vetores representados por duas tabelas de uma linha separados por um ponto e um terceiro vetor mostrando as parcelas do produto escalar](/assets/images/dotProd1.webp){#fig-dotprod1}

**Exemplo 1**: Considerando os vetores  $\vec{a} = [2, 5, 1]$ e $\vec{b} = [3, 1, 4]$. O produto escalar será dado por:

$$
\vec{a} \cdot \vec{b} = (2 * 3) + (5 * 1) + (1 * 4) = 6 + 5 + 4 = 15
$$

O produto escalar também pode ser representado na forma matricial. Se considerarmos os vetores como matrizes, o produto escalar será obtido multiplicando a transposta do primeiro vetor pelo segundo vetor:

$$
\vec{a} \cdot \vec{b} = \vec{a}^T\vec{b} = \begin{bmatrix} a_1 & a_2 & \cdots & a_n \end{bmatrix} \begin{bmatrix} b_1 \\ b_2 \\ \vdots \\ b_n \end{bmatrix} = \sum_{i=1}^{n} a_i b_i
$$

>A transposta de um vetor é uma operação da álgebra linear que altera a orientação do vetor, convertendo um vetor coluna em um vetor linha ou vice-versa. Formalmente:
>
>- Se $\vec{v}$ é um vetor coluna $\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{pmatrix}$, sua transposta $\vec{v}^T$ é um vetor linha $\vec{v}^T = \begin{pmatrix} v_1 & v_2 & \cdots & v_n \end{pmatrix}$
>
>- Se $\vec{v}$ é um vetor linha $\vec{v} = \begin{pmatrix} v_1 & v_2 & \cdots & v_n \end{pmatrix}$, sua transposta $\vec{v}^T$ é um vetor coluna $\vec{v}^T = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{pmatrix}$
>
>Em notação matricial, se representarmos um vetor coluna $\vec{v} \in \mathbb{R}^n$ como uma matriz $n \times 1$, sua transposta $\vec{v}^T$ será uma matriz $1 \times n$. A operação de transposição é indicada pelo sobrescrito $T$.
>
>Em sistemas de processamento de linguagem natural, a transposição de vetores é frequentemente utilizada em operações de atenção e em cálculos de similaridade entre vetores de **embedding**.

Para ilustrar, considere os vetores $\vec{a} = [2, 5, 1]$ e $\vec{b} = [3, 1, 4]$. Na forma matricial, temos:

$$
\vec{a}^T\vec{b} = \begin{bmatrix} 2 & 5 & 1 \end{bmatrix} \begin{bmatrix} 3 \\ 1 \\ 4 \end{bmatrix} = (2 \times 3) + (5 \times 1) + (1 \times 4) = 15
$$

### O Produto Escalar e a Similaridade

O produto escalar oferece uma medida quantitativa da similaridade direcional entre dois vetores. Embora não constitua uma métrica de similaridade completa em todos os contextos, fornece informações valiosas sobre o alinhamento vetorial. Em termos gerais, a interpretação do produto escalar $\vec{u} \cdot \vec{v}$ segue estas propriedades:

$$
\vec{u} \cdot \vec{v} = \vert \vec{u} \vert \vert \vec{v} \vert  \cdot \cos(\theta)
$$

Onde $\theta$ representa o ângulo entre os vetores, e podemos observar que:

- $\vec{u} \cdot \vec{v} > 0$: Os vetores apontam em direções geralmente similares (ângulo agudo). Quanto maior o valor positivo, maior a similaridade em termos de direção e magnitude das componentes que se alinham.
- $\vec{u} \cdot \vec{v} = 0$: Os vetores são ortogonais (perpendiculares). Não há similaridade direcional linear entre eles.
- $\vec{u} \cdot \vec{v} < 0$: Os vetores apontam em direções geralmente opostas (ângulo obtuso). Quanto mais negativo, maior a dissimilaridade direcional.

![imagem mostrando três vetores exemplificando os resultados do produto escalar](/assets/images/produto-escalar1.webp){#fig-produto-escalar1}

*Para vetores normalizados (de magnitude unitária), o produto escalar se reduz diretamente ao cosseno do ângulo entre eles, fornecendo uma medida de similaridade no intervalo $[-1, 1]$, frequentemente utilizada em sistemas de recuperação de informação e processamento de linguagem natural.*

**Exemplo 2**: considerando os vetores $\vec{a} = [0, 1, 0]$ e $\vec{b} = [0.2, 0.7, 0.1]$, o produto escalar será:

$$
\vec{a} \cdot \vec{b} = (0 \times 0.2) + (1 \times 0.7) + (0 \times 0.1)
$$

$$
\vec{a} \cdot \vec{b} = 0 + 0.7 + 0 = 0.7
$$

No exemplo 2, o vetor $\vec{a} = [0, 1, 0]$ pode ser visto como um vetor que *ativa*, ou dá peso máximo, apenas à segunda dimensão, e peso zero às demais. Ao calcular o produto escalar com $\vec{b} = [0.2, 0.7, 0.1]$, estamos essencialmente *extraindo ou medindo* o valor da segunda componente de $b$ (que é $0.7$), ponderado pela *importância, ou peso* que o vetor $a$ atribui a essa dimensão.

Com um pouco mais de formalidade: se temos dois vetores $\vec{u}$ e $\vec{v}$, e você calcula $\vec{u} \cdot \vec{v} = c$, o valor escalar $c$ pode ser interpretado como uma medida de:

- Quanto de $\vec{v}$ "existe" na direção de $\vec{u}$ (e vice-versa);
- O grau de alinhamento ou sobreposição entre os vetores;
- A similaridade entre os padrões representados pelos vetores, no sentido de que componentes importantes em um vetor também são relevantes no outro, com pesos proporcionais aos valores das componentes.

A criativa leitora deve notar que o produto escalar é influenciado tanto pela direção quanto pela magnitude dos vetores.

>*A magnitude de um vetor é dada pela raiz quadrada da soma dos quadrados dos seus componentes*. Isso é equivalente a tirar a raiz quadrada do resultado do produto escalar do vetor com ele mesmo. Para um vetor
>
>$$\vec{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix}$$
>
>em um espaço $n$-dimensional, a magnitude, eventualmente chamada de *Norma Euclidiana*, representada por $ \vert  \vec{v} \vert $ será definida por:
>
>$$
 \vert  \vec{v} \vert = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2} = \sqrt{\sum_{i=1}^{n} v_i^2}
$$

**Exemplo 3**: dado o vetor $\vec{b} = \begin{bmatrix} 0.2 \\ 0.7 \\ 0.1 \end{bmatrix}$, vamos calcular sua magnitude $ \vert  \vec{b} \vert $:

Podemos resolver este problema em dois passos:

1. **Calcular o produto escalar de $\vec{b}$ consigo mesmo:**

   $$
   \vec{b} \cdot \vec{b} = (0.2 \times 0.2) + (0.7 \times 0.7) + (0.1 \times 0.1)
   $$

   $$
   \vec{b} \cdot \vec{b} = 0.04 + 0.49 + 0.01 = 0.54
   $$

2. **Extrair a raiz quadrada do resultado:**

   $$
   \vert  \vec{b} \vert = \sqrt{\vec{b} \cdot \vec{b}} = \sqrt{0.54} \approx 0.7348
   $$

Portanto, a magnitude do vetor $\vec{b} = \begin{bmatrix} 0.2 \\ 0.7 \\ 0.1 \end{bmatrix}$ é aproximadamente 0.7348.

## Multiplicação de Matrizes

A multiplicação de matrizes é uma operação fundamental na álgebra linear que aparece constantemente nos modelos de **transformers**. Esta operação irá permitir a combinação de diferentes fontes de textos e transformar representações vetoriais, formando a base de diversas operações nos modelos de processamento de linguagem natural.

A multiplicação de matrizes é uma operação que combina duas matrizes para produzir uma nova matriz. É importante notar que *a multiplicação de matrizes não é comutativa, ou seja, a ordem das matrizes importa*. A multiplicação de matrizes é definida como o produto escalar entre as linhas da primeira matriz e as colunas da segunda matriz.

Formalmente dizemos: sejam $A$ uma matriz de dimensão $m \times n$ e $B$ uma matriz de dimensão $n \times p$. O produto $A \times B$ resultará em uma matriz $C$ de dimensão $m \times p$, onde cada elemento $c_{ij}$ é determinado pelo produto escalar da $i$-ésima linha de $A$ com a $j$-ésima coluna de $B$:

$$
c_{ij} = \sum_{k=1}^{n} a_{ik} \cdot b_{kj}
$$

Observe, atenta leitora, que para que a multiplicação de matrizes seja possível, *o número de colunas da primeira matriz deve ser igual ao número de linhas da segunda matriz*. Esta restrição não é arbitrária - ela garante que os produtos escalares entre linhas e colunas sejam bem definidos.

![matriz A multiplicada por matriz B resultando em matriz C](/assets/images/matrix_mult1.webp){#fig-matrix-mult1}

Cada elemento $c_{ij}$ da matriz resultante é obtido pelo produto escalar da linha $i$ da matriz $A$ com a coluna $j$ da matriz $B$.

Nos modelos **transformer**, a multiplicação de matrizes ocorre com frequência em várias etapas, como:

1. **Atenção**: O mecanismo de atenção utiliza multiplicações de matrizes para calcular as representações de query, key e value;
2. **Embedding de Tokens**: Transformação de tokens discretos em vetores contínuos de alta dimensão;
3. **Projeções Lineares**: Transformações dos vetores de query, key e value no mecanismo de atenção;
4. **Feed-Forward Networks**: Camadas densas que aplicam transformações não-lineares às representações;
5. **Projeções de Saída**: Mapeamento das representações finais para o espaço de saída desejado.

A eficiência dos modelos **transformers** deve-se, em parte, à capacidade de paralelizar estas multiplicações de matrizes em hardware especializado, como GPUs e TPUs.

### Propriedades Importantes

A multiplicação de matrizes possui algumas propriedades notáveis que a diferenciam da multiplicação de números reais:

1. **Não comutativa**: em geral, $A \times B \neq B \times A$. A ordem das operações importa.
2. **Associativa**: $(A \times B) \times C = A \times (B \times C)$. Podemos calcular multiplicações sucessivas em qualquer ordem.
3. **Distributiva sobre a adição**: $A \times (B + C) = A \times B + A \times C$.
4. **Elemento neutro**: $A \times I = I \times A = A$, onde $I$ é a matriz identidade de dimensão apropriada.

### Interpretação Geométrica

Geometricamente, a multiplicação por uma matriz pode ser vista como uma transformação linear no espaço vetorial. Estas transformações podem incluir: rotações, mudança de escala, reflexões, cisalhamentos e projeções. Dependendo da matriz, a transformação pode alterar a posição, a forma ou a orientação dos vetores no espaço.

Nos **transformers**, estas transformações são aplicadas para mapear representações vetoriais de um espaço para outro, permitindo que a rede aprenda relações complexas entre os elementos da sequência de entrada.

### Exemplo Numérico

Nada como um exemplo numérico para fazer a esforçada leitora balançar a poeira. Vamos consider as duas matrizes, $A$ e $B$:

$$
A = \begin{bmatrix} 2 & 3 \\ 4 & 1 \end{bmatrix} \quad \text{e} \quad B = \begin{bmatrix} 1 & 5 \\ 2 & 3 \end{bmatrix}
$$

O produto $C = A \times B$ será:

$$
\begin{align}
c_{11} &= a_{11} \cdot b_{11} + a_{12} \cdot b_{21} = 2 \times 1 + 3 \times 2 = 2 + 6 = 8 \\
c_{12} &= a_{11} \cdot b_{12} + a_{12} \cdot b_{22} = 2 \times 5 + 3 \times 3 = 10 + 9 = 19 \\
c_{21} &= a_{21} \cdot b_{11} + a_{22} \cdot b_{21} = 4 \times 1 + 1 \times 2 = 4 + 2 = 6 \\
c_{22} &= a_{21} \cdot b_{12} + a_{22} \cdot b_{22} = 4 \times 5 + 1 \times 3 = 20 + 3 = 23
\end{align}
$$

Portanto:

$$
C = A \times B = \begin{bmatrix} 8 & 19 \\ 6 & 23 \end{bmatrix}
$$

### Multiplicação Matriz-Vetor

Um caso especial e extremamente importante, para nossos objetivos, é a multiplicação de uma matriz por um vetor. A perceptiva leitora há de considerar que *um vetor que pode ser visto como uma matriz com apenas uma coluna*. Esta operação é recorrente em praticamente todas as camadas de um modelo **transformer**.

Seja $A$ uma matriz $m \times n$ e $\vec{v}$ um vetor coluna de dimensão $n$. O produto $A\vec{v}$ resulta em um vetor coluna $\vec{w}$ de dimensão $m$:

$$
\vec{w} = A\vec{v} = \begin{bmatrix} 
a_{11} & a_{12} & \cdots & a_{1n} \\ 
a_{21} & a_{22} & \cdots & a_{2n} \\ 
\vdots & \vdots & \ddots & \vdots \\ 
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
\begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix} = 
\begin{bmatrix} 
\sum_{j=1}^{n} a_{1j}v_j \\ 
\sum_{j=1}^{n} a_{2j}v_j \\ 
\vdots \\ 
\sum_{j=1}^{n} a_{mj}v_j
\end{bmatrix}
$$

Cada componente $w_i$ do vetor resultante é o produto escalar da $i$-ésima linha da matriz $A$ com o vetor $\vec{v}$. Este padrão de operação repete-se continuamente no mecanismo de atenção dos *transformers*.

**Exemplo**: Considerando a matriz $A$ definida acima e o vetor $\vec{v} = \begin{bmatrix} 3 \\ 2 \end{bmatrix}$, temos:

$$
A\vec{v} = \begin{bmatrix} 2 & 3 \\ 4 & 1 \end{bmatrix} \begin{bmatrix} 3 \\ 2 \end{bmatrix} = \begin{bmatrix} (2 \times 3) + (3 \times 2) \\ (4 \times 3) + (1 \times 2) \end{bmatrix} = \begin{bmatrix} 6 + 6 \\ 12 + 2 \end{bmatrix} = \begin{bmatrix} 12 \\ 14 \end{bmatrix}
$$

### Exemplo de Operações de Multiplicação de Matrizes em C++ 20

```cpp
#include <iostream>    ///< Para entrada e saída padrão (std::cout, std::cerr).
#include <vector>      ///< Para contêiner std::vector usado no armazenamento de elementos da matriz.
#include <iomanip>     ///< Para std::fixed e std::setprecision, usados na formatação de saída.
#include <stdexcept>   ///< Para exceções padrão como std::out_of_range e std::invalid_argument.

/**
 * @class Matrix
 * @brief Uma classe genérica para representar e manipular matrizes.
 *
 * Suporta operações como multiplicação de matrizes, multiplicação por vetor e impressão formatada.
 * A matriz é armazenada como um vetor de vetores de tipo T.
 *
 * @tparam T O tipo dos elementos da matriz (deve suportar operações aritméticas).
 */
template<typename T>
class Matrix {
private:
    std::vector<std::vector<T>> data; ///< Armazenamento interno para os elementos da matriz.
    size_t rows; ///< Número de linhas da matriz.
    size_t cols; ///< Número de colunas da matriz.

public:
    /**
     * @brief Construtor para criar uma matriz de dimensões m x n com valor inicial.
     * @param m Número de linhas.
     * @param n Número de colunas.
     * @param initial_value Valor inicial para todos os elementos (padrão é T{}).
     */
    Matrix(size_t m, size_t n, T initial_value = T{}) 
        : rows(m), cols(n), data(m, std::vector<T>(n, initial_value)) {}

    /**
     * @brief Construtor a partir de um vetor de vetores.
     * @param values Os dados de entrada como um vetor de vetores.
     * @throws std::invalid_argument Se as linhas tiverem tamanhos inconsistentes.
     */
    Matrix(const std::vector<std::vector<T>>& values) {
        if (values.empty()) {
            rows = 0;
            cols = 0;
            return;
        }

        rows = values.size();
        cols = values[0].size();

        // Verifica se todas as linhas têm o mesmo tamanho
        for (const auto& row : values) {
            if (row.size() != cols) {
                throw std::invalid_argument("Todas as linhas devem ter o mesmo número de colunas");
            }
        }

        data = values; // Copia os dados
    }

    /**
     * @brief Fornece acesso não constante a um elemento da matriz.
     * @param i Índice da linha.
     * @param j Índice da coluna.
     * @return Referência ao elemento na posição (i, j).
     * @throws std::out_of_range Se os índices estiverem fora dos limites.
     */
    T& at(size_t i, size_t j) {
        if (i >= rows || j >= cols) {
            throw std::out_of_range("Índices fora dos limites da matriz");
        }
        return data[i][j];
    }

    /**
     * @brief Fornece acesso constante a um elemento da matriz.
     * @param i Índice da linha.
     * @param j Índice da coluna.
     * @return Referência constante ao elemento na posição (i, j).
     * @throws std::out_of_range Se os índices estiverem fora dos limites.
     */
    const T& at(size_t i, size_t j) const {
        if (i >= rows || j >= cols) {
            throw std::out_of_range("Índices fora dos limites da matriz");
        }
        return data[i][j];
    }

    /**
     * @brief Retorna o número de linhas da matriz.
     * @return O número de linhas.
     */
    size_t num_rows() const { return rows; }

    /**
     * @brief Retorna o número de colunas da matriz.
     * @return O número de colunas.
     */
    size_t num_cols() const { return cols; }

    /**
     * @brief Multiplica esta matriz por outra.
     * @param other A matriz a ser multiplicada.
     * @return A matriz resultante.
     * @throws std::invalid_argument Se as dimensões forem incompatíveis.
     */
    Matrix<T> operator*(const Matrix<T>& other) const {
        if (cols != other.rows) {
            throw std::invalid_argument("Dimensões incompatíveis para multiplicação de matrizes");
        }

        Matrix<T> result(rows, other.cols, T{});

        for (size_t i = 0; i < rows; ++i) {
            for (size_t j = 0; j < other.cols; ++j) {
                for (size_t k = 0; k < cols; ++k) {
                    result.data[i][j] += data[i][k] * other.data[k][j];
                }
            }
        }

        return result;
    }

    /**
     * @brief Multiplica a matriz por um vetor (representado como matriz coluna).
     * @param vec O vetor de entrada.
     * @return O vetor resultante da multiplicação.
     * @throws std::invalid_argument Se as dimensões forem incompatíveis.
     */
    std::vector<T> multiply_vector(const std::vector<T>& vec) const {
        if (cols != vec.size()) {
            throw std::invalid_argument("Dimensões incompatíveis para multiplicação matriz-vetor");
        }

        std::vector<T> result(rows, T{});

        for (size_t i = 0; i < rows; ++i) {
            for (size_t j = 0; j < cols; ++j) {
                result[i] += data[i][j] * vec[j];
            }
        }

        return result;
    }

    /**
     * @brief Imprime a matriz formatada com um nome opcional.
     * @param name Nome opcional a ser exibido antes da matriz.
     */
    void print(const std::string& name = "") const {
        if (!name.empty()) {
            std::cout << name << " =\n";
        }

        for (size_t i = 0; i < rows; ++i) {
            std::cout << "[";
            for (size_t j = 0; j < cols; ++j) {
                std::cout << std::fixed << std::setprecision(2) << data[i][j];
                if (j < cols - 1) std::cout << ", ";
            }
            std::cout << "]\n";
        }
    }
};

/**
 * @brief Função principal que demonstra operações de multiplicação de matrizes.
 *
 * Este programa ilustra a multiplicação de matrizes, a multiplicação de matriz por vetor
 * e o tratamento de erros para dimensões incompatíveis usando a classe Matrix.
 *
 * @return 0 em caso de execução bem-sucedida.
 */
int main() {
    std::cout << std::fixed << std::setprecision(2);
    std::cout << "Demonstração de Multiplicação de Matrizes\n";
    std::cout << "----------------------------------------\n\n";

    // Exemplo 1: Multiplicação de duas matrizes
    Matrix<double> A({
        {2.0, 3.0},
        {4.0, 1.0}
    }); ///< Matriz A (2x2) para demonstração.

    Matrix<double> B({
        {1.0, 5.0},
        {2.0, 3.0}
    }); ///< Matriz B (2x2) para demonstração.

    std::cout << "Exemplo 1: Multiplicação de duas matrizes\n";
    A.print("Matriz A");
    B.print("Matriz B");

    try {
        Matrix<double> C = A * B;
        C.print("A * B");
    } catch (const std::exception& e) {
        std::cerr << "Erro: " << e.what() << '\n';
    }

    // Exemplo 2: Multiplicação matriz-vetor
    std::vector<double> v = {3.0, 2.0}; ///< Vetor v (2x1) para demonstração.

    std::cout << "\nExemplo 2: Multiplicação matriz-vetor\n";
    A.print("Matriz A");
    std::cout << "Vetor v = [" << v[0] << ", " << v[1] << "]\n";

    try {
        std::vector<double> result = A.multiply_vector(v);
        std::cout << "A * v = [";
        for (size_t i = 0; i < result.size(); ++i) {
            std::cout << result[i];
            if (i < result.size() - 1) std::cout << ", ";
        }
        std::cout << "]\n";
    } catch (const std::exception& e) {
        std::cerr << "Erro: " << e.what() << '\n';
    }

    // Exemplo 3: Demonstração de erro (dimensões incompatíveis)
    Matrix<double> D({
        {1.0, 2.0, 3.0},
        {4.0, 5.0, 6.0}
    }); ///< Matriz D (2x3) para demonstração de erro.

    std::cout << "\nExemplo 3: Tentativa de multiplicação com dimensões incompatíveis\n";
    A.print("Matriz A (2x2)");
    D.print("Matriz D (2x3)");

    try {
        Matrix<double> E = D * A; // Isso deve falhar (3 colunas × 2 linhas)
        E.print("D * A");
    } catch (const std::exception& e) {
        std::cout << "Erro (esperado): " << e.what() << '\n';
    }

    return 0;
}
```

Agora que vimos o básico da matemática, a vetorização de textos será o tema do próximo capítulo.
