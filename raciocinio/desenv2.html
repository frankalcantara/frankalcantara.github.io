<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Virando o Jogo da Imitação - 7&nbsp; Módulo 2: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 1em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./desenv3.html" rel="next">
<link href="./desenv1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./desen.html">Disciplina Raciocínio Algorítmico</a></li><li class="breadcrumb-item"><a href="./desenv2.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title"><strong>Módulo 2</strong>: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Virando o Jogo da Imitação</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linefollower" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Contextualização e Pesquisa</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./inte.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Analisando Currículos Internacionais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./def.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Definição e Princípios da Metodologia DAAD</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Disciplina Raciocínio Algorítmico</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Projeto de Disciplina de Raciocínio Algorítmico</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title"><strong>Módulo 1</strong>: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title"><strong>Módulo 2</strong>: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title"><strong>Módulo 3</strong>: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title"><strong>Módulo 4</strong>: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#abstração-reutilização" id="toc-abstração-reutilização" class="nav-link active" data-scroll-target="#abstração-reutilização"><span class="header-section-number">7.1</span> Abstração: Reutilização</a>
  <ul class="collapse">
  <li><a href="#reconhecimento-de-padrões-função" id="toc-reconhecimento-de-padrões-função" class="nav-link" data-scroll-target="#reconhecimento-de-padrões-função"><span class="header-section-number">7.1.1</span> Reconhecimento de Padrões: Função</a></li>
  <li><a href="#usando-funções-da-biblioteca-padrão" id="toc-usando-funções-da-biblioteca-padrão" class="nav-link" data-scroll-target="#usando-funções-da-biblioteca-padrão"><span class="header-section-number">7.1.2</span> Usando funções da biblioteca padrão</a></li>
  </ul></li>
  <li><a href="#decomposição-e-abstração-estruturas-de-dados-compostas" id="toc-decomposição-e-abstração-estruturas-de-dados-compostas" class="nav-link" data-scroll-target="#decomposição-e-abstração-estruturas-de-dados-compostas"><span class="header-section-number">7.2</span> Decomposição e Abstração: Estruturas de Dados Compostas</a>
  <ul class="collapse">
  <li><a href="#h2" id="toc-h2" class="nav-link" data-scroll-target="#h2"><span class="header-section-number">7.2.1</span> <strong>H2</strong></a></li>
  <li><a href="#i2" id="toc-i2" class="nav-link" data-scroll-target="#i2"><span class="header-section-number">7.2.2</span> I2</a></li>
  <li><a href="#j2" id="toc-j2" class="nav-link" data-scroll-target="#j2"><span class="header-section-number">7.2.3</span> J2</a></li>
  <li><a href="#k2" id="toc-k2" class="nav-link" data-scroll-target="#k2"><span class="header-section-number">7.2.4</span> K2</a></li>
  <li><a href="#l2" id="toc-l2" class="nav-link" data-scroll-target="#l2"><span class="header-section-number">7.2.5</span> L2</a></li>
  <li><a href="#m2" id="toc-m2" class="nav-link" data-scroll-target="#m2"><span class="header-section-number">7.2.6</span> M2</a></li>
  <li><a href="#n2" id="toc-n2" class="nav-link" data-scroll-target="#n2"><span class="header-section-number">7.2.7</span> N2</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linefollower/edit/main/desenv2.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linefollower/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./desen.html">Disciplina Raciocínio Algorítmico</a></li><li class="breadcrumb-item"><a href="./desenv2.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title"><strong>Módulo 2</strong>: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title"><strong>Módulo 2</strong>: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\expresso\desenv2-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>No módulo 2, os alunos aprofundam-se na <strong>Abstração</strong> e no <strong>Reconhecimento de Padrões</strong>, dois pilares fundamentais do <strong>Raciocínio Algoritmico</strong>. Este módulo é estruturado em torno da Metodologia <strong>DAAD</strong>, que inclui as etapas de <strong>D</strong>ecomposição, <strong>A</strong>bstração, <strong>A</strong>lgoritmização e <strong>D</strong>epuração. Neste módulo devem ser abordados os seguintes tópicos:</p>
<ul>
<li>Princípios de abstração: identificação de informações essenciais e criação de modelos simplificados;</li>
<li>Reconhecimento de padrões: identificação de similaridades, tendências e generalizações;</li>
<li>Abstração na programação: componentes reutilizáveis, funções e estruturas de controle;</li>
<li>Estruturas de dados simples: vectors, arrays e structs;</li>
<li>Exercícios avançados de interpretação, visualização de dados e simulação de sistemas;</li>
<li>Identificação de padrões de código recorrentes para refatoração.</li>
</ul>
<p>Além disso, a partir do exercício <strong>H2</strong>, os alunos devem ser incentivados a dividir o trabalho em partes para facilitar a implementação e a depuração. A divisão do trabalho é uma habilidade essencial para o desenvolvimento de software, pois permite que os alunos se concentrem em partes específicas do problema, facilitando a identificação de erros e a implementação de soluções. Neste módulo, não usaremos nenhum sistema de controle de versão, propositalmente, para que os alunos possam aprender a importância de dividir o trabalho em partes e como isso pode facilitar a implementação e a depuração. Em cada um destes exercícios existe uma proposta de divisão que serve de orientação para o professor.</p>
<p>Embora o reconhecimento de padrões não esteja explicitado no acrônimo <strong>DAAD</strong>, esta competência é um elemento essencial do <strong>Raciocínio Algorítmico</strong> e da resolução de problemas. Exercícios de <strong>Algoritmização</strong> mais complexos serão propostos para induzir a criatividade, além de fomentar a capacidade de reconhecimento de padrões. Neste contexto, o reconhecimento de padrões é visto como uma habilidade que permite aos alunos identificar e aplicar soluções previamente aprendidas a novos problemas, facilitando a abstração e a decomposição de problemas complexos.</p>
<p>Neste módulo, o professor deve decidir qual linguagem de programação será utilizada durantes os Módulos 2 e 3. A linguagem escolhida deve ser adequada para o nível dos alunos e a familiaridade do professor, e permitir a implementação dos conceitos de abstração e reconhecimento de padrões. A Python <span class="citation" data-cites="PythonDocs">(<a href="referencias.html#ref-PythonDocs" role="doc-biblioref">1</a>)</span> é uma escolha comum, mas outras linguagens como C++ <span class="citation" data-cites="ISO_CPP20">(<a href="referencias.html#ref-ISO_CPP20" role="doc-biblioref">2</a>)</span> podem ser utilizadas. Neste documento será utilizada a linguagem C++ como exemplo, mas os conceitos são aplicáveis a qualquer linguagem de programação. Se o professor optar por continuar com o C++ 23, é importante observar que a partir deste módulo, os exemplos usarão artefatos modernos desta linguagem, como o uso de <code>auto</code> e <code>ranges</code> para dedução de tipos e a biblioteca padrão C++ (STL) para manipulação de dados.</p>
<section id="abstração-reutilização" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="abstração-reutilização"><span class="header-section-number">7.1</span> Abstração: Reutilização</h2>
<p>Aplicação da abstração na programação: criação de componentes reutilizáveis, funções, laços de repetição e estruturas de dados. Utilizando a Linguagem C++ com as abstrações de função, <code>for</code>, <code>while</code>, <code>do while</code>.</p>
<p>Antes de ofertar os novos exercícios, o professor pode revisar os conceitos de abstração que foram introduzidos no Módulo 1. Como por exemplo, o professor pode considerar usar os exercícios <span class="math inline">\(4\)</span> exercícios a seguir para revisar os conceitos de abstração e controle de fluxo. Observe que os exercícios são complexos e demandam tempo de implementação, por isso o professor deve escolher os exercícios de acordo com o tamanho e o resultado da turma, mas deve se manter na Técnica da Sequência de Fibonacci. Vimos a Técnica da Sequência de Fibonacci na <a href="desenv1.html#sec-modulo1-unplugged" class="quarto-xref"><span>Section 6.1.1</span></a> nesta técnica além de tempos e quantidades, o professor precisa se preocupar que a devolutiva deve ser feita no quadro, com o professor explicando cada passo do algoritmo, enfatizando a importância da decomposição e controle de fluxo. A seguir está uma lista de problemas que podem ser usados para esta atividade:</p>
<p><strong>Revisão 1</strong>: dado um número inteiro positivo <span class="math inline">\(N\)</span> (<span class="math inline">\(1 \leq N \leq 10^9\)</span>), encontre o maior e o menor dígito que compõem este número. Você só pode usar operações aritméticas básicas e laços de repetição, e não pode armazenar os dígitos do número em estruturas de dados compostas como arrays.</p>
<p>Em qualquer número, cada dígito está entre <span class="math inline">\(0\)</span> e <span class="math inline">\(9\)</span>. O objetivo é percorrer todos os dígitos do número e manter registro do maior e menor encontrados. Por exemplo, para <span class="math inline">\(N = 49327\)</span>, os dígitos são <span class="math inline">\(4\)</span>, <span class="math inline">\(9\)</span>, <span class="math inline">\(3\)</span>, <span class="math inline">\(2\)</span>, <span class="math inline">\(7\)</span>. O maior dígito é <span class="math inline">\(9\)</span> e o menor é <span class="math inline">\(2\)</span>. Este problema treina a capacidade de manter estado (maior e menor) durante a iteração pelos dígitos.</p>
<p><strong>Algoritmização</strong>:</p>
<pre class="shell"><code>ALGORITMO EncontraMaiorMenorDigitoConciso

ENTRADA:
    N: inteiro

SAÍDA:
    maiorDigito, menorDigito: inteiro

INÍCIO
    LER N
    numeroOriginal ← N
    maiorDigito ← 0
    menorDigito ← 9
    
ETIQUETA PROCESSAR_DIGITOS:
    SE N = 0 ENTÃO IR PARA RESULTADO
    
    digito ← N % 10
    N ← N / 10
    
    SE digito &gt; maiorDigito ENTÃO
        maiorDigito ← digito
    
    SE digito &lt; menorDigito ENTÃO
        menorDigito ← digito
    
    IR PARA PROCESSAR_DIGITOS

ETIQUETA RESULTADO:
    ESCREVER "Número original:", numeroOriginal
    ESCREVER "Maior dígito:", maiorDigito
    ESCREVER "Menor dígito:", menorDigito
    ESCREVER "Diferença:", (maiorDigito - menorDigito)
    
    RETORNAR maiorDigito, menorDigito
FIM</code></pre>
<p>O código <a href="#lst-mod2-1" class="quarto-xref">Listing&nbsp;<span>7.1</span></a> apresenta o código em C++23 que implementa o algoritmo acima.</p>
<div id="lst-mod2-1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-mod2-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;7.1
</figcaption>
<div aria-describedby="lst-mod2-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-mod2-1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-mod2-1-1"><a href="#lst-mod2-1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="lst-mod2-1-2"><a href="#lst-mod2-1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-mod2-1-3"><a href="#lst-mod2-1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-mod2-1-4"><a href="#lst-mod2-1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N<span class="op">;</span></span>
<span id="lst-mod2-1-5"><a href="#lst-mod2-1-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Digite um número: "</span><span class="op">;</span></span>
<span id="lst-mod2-1-6"><a href="#lst-mod2-1-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> N<span class="op">;</span></span>
<span id="lst-mod2-1-7"><a href="#lst-mod2-1-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-8"><a href="#lst-mod2-1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numeroOriginal <span class="op">=</span> N<span class="op">;</span></span>
<span id="lst-mod2-1-9"><a href="#lst-mod2-1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maiorDigito <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-mod2-1-10"><a href="#lst-mod2-1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> menorDigito <span class="op">=</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="lst-mod2-1-11"><a href="#lst-mod2-1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-12"><a href="#lst-mod2-1-12" aria-hidden="true" tabindex="-1"></a>    PROCESSAR_DIGITOS<span class="op">:</span></span>
<span id="lst-mod2-1-13"><a href="#lst-mod2-1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">goto</span> RESULTADO<span class="op">;</span></span>
<span id="lst-mod2-1-14"><a href="#lst-mod2-1-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-15"><a href="#lst-mod2-1-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> digito <span class="op">=</span> N <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="lst-mod2-1-16"><a href="#lst-mod2-1-16" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> N <span class="op">/</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="lst-mod2-1-17"><a href="#lst-mod2-1-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-18"><a href="#lst-mod2-1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>digito <span class="op">&gt;</span> maiorDigito<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-mod2-1-19"><a href="#lst-mod2-1-19" aria-hidden="true" tabindex="-1"></a>        maiorDigito <span class="op">=</span> digito<span class="op">;</span></span>
<span id="lst-mod2-1-20"><a href="#lst-mod2-1-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-mod2-1-21"><a href="#lst-mod2-1-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-22"><a href="#lst-mod2-1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>digito <span class="op">&lt;</span> menorDigito<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-mod2-1-23"><a href="#lst-mod2-1-23" aria-hidden="true" tabindex="-1"></a>        menorDigito <span class="op">=</span> digito<span class="op">;</span></span>
<span id="lst-mod2-1-24"><a href="#lst-mod2-1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-mod2-1-25"><a href="#lst-mod2-1-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-26"><a href="#lst-mod2-1-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> PROCESSAR_DIGITOS<span class="op">;</span></span>
<span id="lst-mod2-1-27"><a href="#lst-mod2-1-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-28"><a href="#lst-mod2-1-28" aria-hidden="true" tabindex="-1"></a>    RESULTADO<span class="op">:</span></span>
<span id="lst-mod2-1-29"><a href="#lst-mod2-1-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Número original: "</span> <span class="op">&lt;&lt;</span> numeroOriginal <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-1-30"><a href="#lst-mod2-1-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Maior dígito: "</span> <span class="op">&lt;&lt;</span> maiorDigito <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-1-31"><a href="#lst-mod2-1-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Menor dígito: "</span> <span class="op">&lt;&lt;</span> menorDigito <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-1-32"><a href="#lst-mod2-1-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Diferença: "</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>maiorDigito <span class="op">-</span> menorDigito<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-1-33"><a href="#lst-mod2-1-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-1-34"><a href="#lst-mod2-1-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-mod2-1-35"><a href="#lst-mod2-1-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p>Mas, como os alunos já devem estar familiarizados com as estruturas de repetição, o professor pode propor uma versão mais concisa do algoritmo, utilizando a abstração de função. O código <a href="#lst-mod2-2" class="quarto-xref">Listing&nbsp;<span>7.2</span></a>, apresenta o código em C++23 que implementa o algoritmo acima, mas com a abstração de função.</p>
<div id="lst-mod2-2" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-mod2-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;7.2
</figcaption>
<div aria-describedby="lst-mod2-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-mod2-2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-mod2-2-1"><a href="#lst-mod2-2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="lst-mod2-2-2"><a href="#lst-mod2-2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-mod2-2-3"><a href="#lst-mod2-2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-mod2-2-4"><a href="#lst-mod2-2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> N <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-mod2-2-5"><a href="#lst-mod2-2-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Digite um número: "</span><span class="op">;</span></span>
<span id="lst-mod2-2-6"><a href="#lst-mod2-2-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> N<span class="op">;</span></span>
<span id="lst-mod2-2-7"><a href="#lst-mod2-2-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-2-8"><a href="#lst-mod2-2-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> numeroOriginal <span class="op">=</span> N<span class="op">;</span></span>
<span id="lst-mod2-2-9"><a href="#lst-mod2-2-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> maiorDigito <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-mod2-2-10"><a href="#lst-mod2-2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> menorDigito <span class="op">=</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="lst-mod2-2-11"><a href="#lst-mod2-2-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-2-12"><a href="#lst-mod2-2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>N <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-mod2-2-13"><a href="#lst-mod2-2-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> digito <span class="op">=</span> N <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="lst-mod2-2-14"><a href="#lst-mod2-2-14" aria-hidden="true" tabindex="-1"></a>        N <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="lst-mod2-2-15"><a href="#lst-mod2-2-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-mod2-2-16"><a href="#lst-mod2-2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>digito <span class="op">&gt;</span> maiorDigito<span class="op">)</span> maiorDigito <span class="op">=</span> digito<span class="op">;</span></span>
<span id="lst-mod2-2-17"><a href="#lst-mod2-2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>digito <span class="op">&lt;</span> menorDigito<span class="op">)</span> menorDigito <span class="op">=</span> digito<span class="op">;</span></span>
<span id="lst-mod2-2-18"><a href="#lst-mod2-2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-mod2-2-19"><a href="#lst-mod2-2-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-2-20"><a href="#lst-mod2-2-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Número original: "</span> <span class="op">&lt;&lt;</span> numeroOriginal <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-2-21"><a href="#lst-mod2-2-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Maior dígito: "</span> <span class="op">&lt;&lt;</span> maiorDigito <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-2-22"><a href="#lst-mod2-2-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Menor dígito: "</span> <span class="op">&lt;&lt;</span> menorDigito <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-2-23"><a href="#lst-mod2-2-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Diferença: "</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>maiorDigito <span class="op">-</span> menorDigito<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-mod2-2-24"><a href="#lst-mod2-2-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-mod2-2-25"><a href="#lst-mod2-2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-mod2-2-26"><a href="#lst-mod2-2-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p><strong>Revisão 2</strong>: no Laboratório de Engenharia, o professor Carlos precisa implementar uma calculadora científica que calcule o seno de ângulos com alta precisão. Como as funções trigonométricas padrão podem ter limitações de precisão, ele decide usar a série de Taylor para sen(x). A série é definida como:</p>
<p><span class="math display">\[\sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \frac{x^9}{9!} - \cdots = \sum_{n=0}^{\infty} \frac{(-1)^n \cdot x^{2n+1}}{(2n+1)!}\]</span></p>
<p>O sistema deve receber um <code>angulo</code> em radianos e a <code>precisao</code> desejada, número de termos da série, calcular o seno usando a série de Taylor e comparar com o resultado obtido na sua calculadora. Desenvolva um algoritmo que implemente este cálculo, mostrando cada termo da série e o erro absoluto em relação ao valor da biblioteca padrão.</p>
<p><strong>Solução</strong>:</p>
<p>Neste caso, o pseudocódigo pode ser representado como:</p>
<p><strong>Pseudocódigo</strong>:</p>
<pre class="shell"><code>ALGORITMO CalculadoraSeno

ENTRADA:
    precisao: inteiro

SAÍDA:
    senoCalculado: real
    senoReferencia: real
    erroAbsoluto: real

INÍCIO
    // Valor de teste pré-definido: π/6 (30°)
    angulo ← 0.523599
    senoReferencia ← 0.5
    
    ESCREVER "Calculando sen(π/6) = sen(30°) = sen(0.523599 rad)"
    ESCREVER "Valor de referência: 0.5"
    ESCREVER "Digite o número de termos da série:"
    LER precisao
    
    senoCalculado ← 0
    termo ← angulo
    
    PARA i DE 0 ATÉ (precisao - 1) FAÇA
        SE (i % 2 == 0) ENTÃO
            senoCalculado ← senoCalculado + termo
            ESCREVER "Termo ", i+1, ": +", termo, " | Soma parcial: ", senoCalculado
        SENÃO
            senoCalculado ← senoCalculado - termo
            ESCREVER "Termo ", i+1, ": -", termo, " | Soma parcial: ", senoCalculado
        FIM SE
        
        // Calcular próximo termo: x^(2n+3) / (2n+3)!
        termo ← termo * angulo * angulo / ((2*i + 2) * (2*i + 3))
    FIM PARA
    
    erroAbsoluto ← ABS(senoCalculado - senoReferencia)
    
    ESCREVER "Ângulo: ", angulo, " radianos (π/6 ou 30°)"
    ESCREVER "Seno calculado: ", senoCalculado
    ESCREVER "Seno de referência: ", senoReferencia
    ESCREVER "Erro absoluto: ", erroAbsoluto
    
    RETORNAR senoCalculado, senoReferencia, erroAbsoluto
FIM</code></pre>
<p>O código em C++23 que implementa o algoritmo acima, utilizando a biblioteca padrão C++ (STL) e ranges, pode ser representado visto na <a href="#lst-rev2-1" class="quarto-xref">Listing&nbsp;<span>7.3</span></a>:</p>
<div id="lst-rev2-1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-rev2-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;7.3
</figcaption>
<div aria-describedby="lst-rev2-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-rev2-1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-rev2-1-1"><a href="#lst-rev2-1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="lst-rev2-1-2"><a href="#lst-rev2-1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="lst-rev2-1-3"><a href="#lst-rev2-1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev2-1-4"><a href="#lst-rev2-1-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Função para valor absoluto sem usar cmath</span></span>
<span id="lst-rev2-1-5"><a href="#lst-rev2-1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> abs_manual<span class="op">(</span><span class="kw">auto</span> valor<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev2-1-6"><a href="#lst-rev2-1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>valor <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="op">-</span>valor <span class="op">:</span> valor<span class="op">;</span></span>
<span id="lst-rev2-1-7"><a href="#lst-rev2-1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="lst-rev2-1-8"><a href="#lst-rev2-1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev2-1-9"><a href="#lst-rev2-1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-rev2-1-10"><a href="#lst-rev2-1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Valor de teste pré-definido: π/6 (30°)</span></span>
<span id="lst-rev2-1-11"><a href="#lst-rev2-1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> angulo <span class="op">=</span> <span class="fl">0.523599</span><span class="op">;</span>      <span class="co">// π/6 radianos</span></span>
<span id="lst-rev2-1-12"><a href="#lst-rev2-1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> senoReferencia <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span>   <span class="co">// sen(π/6) = 0.5</span></span>
<span id="lst-rev2-1-13"><a href="#lst-rev2-1-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev2-1-14"><a href="#lst-rev2-1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> precisao <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-rev2-1-15"><a href="#lst-rev2-1-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev2-1-16"><a href="#lst-rev2-1-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Calculando sen(π/6) = sen(30°) = sen(0.523599 rad)"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-17"><a href="#lst-rev2-1-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Valor de referência: 0.5"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-18"><a href="#lst-rev2-1-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Digite o número de termos da série: "</span><span class="op">;</span></span>
<span id="lst-rev2-1-19"><a href="#lst-rev2-1-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> precisao<span class="op">;</span></span>
<span id="lst-rev2-1-20"><a href="#lst-rev2-1-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev2-1-21"><a href="#lst-rev2-1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> senoCalculado <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="lst-rev2-1-22"><a href="#lst-rev2-1-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> termo <span class="op">=</span> angulo<span class="op">;</span></span>
<span id="lst-rev2-1-23"><a href="#lst-rev2-1-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev2-1-24"><a href="#lst-rev2-1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> <span class="bu">std::</span>views::iota<span class="op">(</span><span class="dv">0</span><span class="op">,</span> precisao<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-rev2-1-25"><a href="#lst-rev2-1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev2-1-26"><a href="#lst-rev2-1-26" aria-hidden="true" tabindex="-1"></a>            senoCalculado <span class="op">+=</span> termo<span class="op">;</span></span>
<span id="lst-rev2-1-27"><a href="#lst-rev2-1-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Termo "</span> <span class="op">&lt;&lt;</span> i<span class="op">+</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="st">": +"</span> <span class="op">&lt;&lt;</span> termo </span>
<span id="lst-rev2-1-28"><a href="#lst-rev2-1-28" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;&lt;</span> <span class="st">" | Soma parcial: "</span> <span class="op">&lt;&lt;</span> senoCalculado <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-29"><a href="#lst-rev2-1-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="lst-rev2-1-30"><a href="#lst-rev2-1-30" aria-hidden="true" tabindex="-1"></a>            senoCalculado <span class="op">-=</span> termo<span class="op">;</span></span>
<span id="lst-rev2-1-31"><a href="#lst-rev2-1-31" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Termo "</span> <span class="op">&lt;&lt;</span> i<span class="op">+</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="st">": -"</span> <span class="op">&lt;&lt;</span> termo </span>
<span id="lst-rev2-1-32"><a href="#lst-rev2-1-32" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;&lt;</span> <span class="st">" | Soma parcial: "</span> <span class="op">&lt;&lt;</span> senoCalculado <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-33"><a href="#lst-rev2-1-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-rev2-1-34"><a href="#lst-rev2-1-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-rev2-1-35"><a href="#lst-rev2-1-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Próximo termo: x^(2n+3) / (2n+3)!</span></span>
<span id="lst-rev2-1-36"><a href="#lst-rev2-1-36" aria-hidden="true" tabindex="-1"></a>        termo <span class="op">=</span> termo <span class="op">*</span> angulo <span class="op">*</span> angulo <span class="op">/</span> <span class="op">((</span><span class="dv">2</span><span class="op">*</span>i <span class="op">+</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="dv">2</span><span class="op">*</span>i <span class="op">+</span> <span class="dv">3</span><span class="op">));</span></span>
<span id="lst-rev2-1-37"><a href="#lst-rev2-1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-rev2-1-38"><a href="#lst-rev2-1-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev2-1-39"><a href="#lst-rev2-1-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> erroAbsoluto <span class="op">=</span> abs_manual<span class="op">(</span>senoCalculado <span class="op">-</span> senoReferencia<span class="op">);</span></span>
<span id="lst-rev2-1-40"><a href="#lst-rev2-1-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev2-1-41"><a href="#lst-rev2-1-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-42"><a href="#lst-rev2-1-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Ângulo: "</span> <span class="op">&lt;&lt;</span> angulo <span class="op">&lt;&lt;</span> <span class="st">" radianos (π/6 ou 30°)"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-43"><a href="#lst-rev2-1-43" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Seno calculado: "</span> <span class="op">&lt;&lt;</span> senoCalculado <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-44"><a href="#lst-rev2-1-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Seno de referência: "</span> <span class="op">&lt;&lt;</span> senoReferencia <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-45"><a href="#lst-rev2-1-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Erro absoluto: "</span> <span class="op">&lt;&lt;</span> erroAbsoluto <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev2-1-46"><a href="#lst-rev2-1-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev2-1-47"><a href="#lst-rev2-1-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-rev2-1-48"><a href="#lst-rev2-1-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p>O código da <a href="#lst-rev2-1" class="quarto-xref">Listing&nbsp;<span>7.3</span></a> implementa a série de Taylor para calcular o seno de um ângulo em radianos, mostrando cada termo da série e o erro absoluto em relação ao valor de referência. O professor pode propor diferentes valores de <code>angulo</code> e <code>senoReferencia</code> para testar a precisão do cálculo a <a href="#tbl-valores-teste-seno" class="quarto-xref">Table&nbsp;<span>7.1</span></a> contém algumas sugestões.</p>
<div id="tbl-valores-teste-seno" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-valores-teste-seno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7.1: Valores de teste para diferentes ângulos na série de Taylor do seno
</figcaption>
<div aria-describedby="tbl-valores-teste-seno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 13%">
<col style="width: 11%">
<col style="width: 16%">
<col style="width: 31%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>Teste</th>
<th>Ângulo</th>
<th>Graus</th>
<th>Radianos</th>
<th>Seno de Referência</th>
<th>Código</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>π/4</td>
<td>45°</td>
<td>0.785398</td>
<td>0.707107</td>
<td><code>auto angulo = 0.785398; auto senoReferencia = 0.707107;</code></td>
</tr>
<tr class="even">
<td>2</td>
<td>π/3</td>
<td>60°</td>
<td>1.047198</td>
<td>0.866025</td>
<td><code>auto angulo = 1.047198; auto senoReferencia = 0.866025;</code></td>
</tr>
<tr class="odd">
<td>3</td>
<td>π/2</td>
<td>90°</td>
<td>1.570796</td>
<td>1.0</td>
<td><code>auto angulo = 1.570796; auto senoReferencia = 1.0;</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p><strong>Revisão 3</strong>. na empresa de software “Algoritmos Precisos”, a matemática Dra. Marina está desenvolvendo um módulo para calcular o valor de pi com diferentes níveis de precisão. Ela escolheu usar a série de Leibniz, também conhecida como série de Gregory-Leibniz e dada por:</p>
<p><span class="math display">\[\frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \cdots = \sum_{n=0}^{\infty} \frac{(-1)^n}{2n+1}\]</span></p>
<p>O sistema deve receber o <code>numero_termos</code> desejado, calcular pi usando a série, mostrar a convergência a cada 1000 iterações e comparar com o valor de pi digitado manualmente. Além disso, deve calcular quantos termos são necessários para atingir uma precisão de pelo menos 6 casas decimais. Crie um algoritmo que implemente este cálculo de pi.</p>
<p><strong>Solução</strong>:</p>
<p>Este exercício envolve a aproximação do fatorial usando a fórmula de Stirling e uma série de correção. O pseudocódigo para este exercício pode ser representado como:</p>
<pre class="shell"><code>ALGORITMO CalculadoraPi

ENTRADA:
    numeroTermos: inteiro

SAÍDA:
    piCalculado: real
    piReferencia: real
    termosParaPrecisao: inteiro

INÍCIO
    ESCREVER "Digite o número de termos:"
    LER numeroTermos
    
    somaLeibniz ← 0
    precisaoAtingida ← FALSO
    termosParaPrecisao ← 0
    piReferencia ← 3.141592653589793
    
    PARA i DE 0 ATÉ (numeroTermos - 1) FAÇA
        SE (i % 2 == 0) ENTÃO
            somaLeibniz ← somaLeibniz + (1.0 / (2*i + 1))
        SENÃO
            somaLeibniz ← somaLeibniz - (1.0 / (2*i + 1))
        FIM SE
        
        piCalculado ← 4 * somaLeibniz
        
        // Mostrar progresso a cada 1000 termos
        SE ((i + 1) % 1000 == 0) ENTÃO
            ESCREVER "Termos: ", i+1, " | Pi aproximado: ", piCalculado
        FIM SE
        
        // Verificar precisão de 6 casas decimais
        SE (ABS(piCalculado - piReferencia) &lt; 0.000001) E (precisaoAtingida == FALSO) ENTÃO
            termosParaPrecisao ← i + 1
            precisaoAtingida ← VERDADEIRO
        FIM SE
    FIM PARA
    
    ESCREVER "Pi calculado: ", piCalculado
    ESCREVER "Pi de referência: ", piReferencia
    ESCREVER "Erro absoluto: ", ABS(piCalculado - piReferencia)
    SE (precisaoAtingida) ENTÃO
        ESCREVER "Precisão de 6 casas atingida com ", termosParaPrecisao, " termos"
    SENÃO
        ESCREVER "Precisão de 6 casas não atingida com ", numeroTermos, " termos"
    FIM SE
    
    RETORNAR piCalculado, termosParaPrecisao
FIM</code></pre>
<p>Neste caso, o código <a href="#lst-rev3-1" class="quarto-xref">Listing&nbsp;<span>7.4</span></a>, em C++23 mostra como pseudocódigo pode ser representado com C++23, utilizando a biblioteca padrão C++ (STL) e ranges. O uso de <code>std::views::iota</code> permite iterar facilmente sobre uma sequência de números, e o uso de <code>auto</code> simplifica a dedução de tipos, fazendo com que o código da <a href="#lst-rev3-1" class="quarto-xref">Listing&nbsp;<span>7.4</span></a> seja mais conciso e legível.</p>
<div id="lst-rev3-1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-rev3-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;7.4
</figcaption>
<div aria-describedby="lst-rev3-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-rev3-1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-rev3-1-1"><a href="#lst-rev3-1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="lst-rev3-1-2"><a href="#lst-rev3-1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="lst-rev3-1-3"><a href="#lst-rev3-1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="lst-rev3-1-4"><a href="#lst-rev3-1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev3-1-5"><a href="#lst-rev3-1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-rev3-1-6"><a href="#lst-rev3-1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> numeroTermos <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-rev3-1-7"><a href="#lst-rev3-1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> somaLeibniz <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="lst-rev3-1-8"><a href="#lst-rev3-1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> piCalculado <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="lst-rev3-1-9"><a href="#lst-rev3-1-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> precisaoAtingida <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="lst-rev3-1-10"><a href="#lst-rev3-1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> termosParaPrecisao <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-rev3-1-11"><a href="#lst-rev3-1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev3-1-12"><a href="#lst-rev3-1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> piReferencia <span class="op">=</span> <span class="fl">3.1415926535897932</span><span class="op">;</span></span>
<span id="lst-rev3-1-13"><a href="#lst-rev3-1-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev3-1-14"><a href="#lst-rev3-1-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Digite o número de termos: "</span><span class="op">;</span></span>
<span id="lst-rev3-1-15"><a href="#lst-rev3-1-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> numeroTermos<span class="op">;</span></span>
<span id="lst-rev3-1-16"><a href="#lst-rev3-1-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev3-1-17"><a href="#lst-rev3-1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> <span class="bu">std::</span>views::iota<span class="op">(</span><span class="dv">0</span><span class="op">,</span> numeroTermos<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-rev3-1-18"><a href="#lst-rev3-1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev3-1-19"><a href="#lst-rev3-1-19" aria-hidden="true" tabindex="-1"></a>            somaLeibniz <span class="op">+=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="op">(</span><span class="dv">2</span><span class="op">*</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="lst-rev3-1-20"><a href="#lst-rev3-1-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="lst-rev3-1-21"><a href="#lst-rev3-1-21" aria-hidden="true" tabindex="-1"></a>            somaLeibniz <span class="op">-=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="op">(</span><span class="dv">2</span><span class="op">*</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="lst-rev3-1-22"><a href="#lst-rev3-1-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-rev3-1-23"><a href="#lst-rev3-1-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-rev3-1-24"><a href="#lst-rev3-1-24" aria-hidden="true" tabindex="-1"></a>        piCalculado <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> somaLeibniz<span class="op">;</span></span>
<span id="lst-rev3-1-25"><a href="#lst-rev3-1-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-rev3-1-26"><a href="#lst-rev3-1-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Mostrar progresso a cada 1000 termos</span></span>
<span id="lst-rev3-1-27"><a href="#lst-rev3-1-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="dv">1000</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev3-1-28"><a href="#lst-rev3-1-28" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Termos: "</span> <span class="op">&lt;&lt;</span> i<span class="op">+</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="st">" | Pi aproximado: "</span> </span>
<span id="lst-rev3-1-29"><a href="#lst-rev3-1-29" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;&lt;</span> piCalculado <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev3-1-30"><a href="#lst-rev3-1-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-rev3-1-31"><a href="#lst-rev3-1-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-rev3-1-32"><a href="#lst-rev3-1-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Verificar precisão de 6 casas decimais</span></span>
<span id="lst-rev3-1-33"><a href="#lst-rev3-1-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>piCalculado <span class="op">-</span> piReferencia<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.000001</span> <span class="kw">and</span> <span class="kw">not</span> precisaoAtingida<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev3-1-34"><a href="#lst-rev3-1-34" aria-hidden="true" tabindex="-1"></a>            termosParaPrecisao <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="lst-rev3-1-35"><a href="#lst-rev3-1-35" aria-hidden="true" tabindex="-1"></a>            precisaoAtingida <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="lst-rev3-1-36"><a href="#lst-rev3-1-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-rev3-1-37"><a href="#lst-rev3-1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-rev3-1-38"><a href="#lst-rev3-1-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev3-1-39"><a href="#lst-rev3-1-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Pi calculado: "</span> <span class="op">&lt;&lt;</span> piCalculado <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev3-1-40"><a href="#lst-rev3-1-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Pi de referência: "</span> <span class="op">&lt;&lt;</span> piReferencia <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev3-1-41"><a href="#lst-rev3-1-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Erro absoluto: "</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>abs<span class="op">(</span>piCalculado <span class="op">-</span> piReferencia<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev3-1-42"><a href="#lst-rev3-1-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev3-1-43"><a href="#lst-rev3-1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>precisaoAtingida<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev3-1-44"><a href="#lst-rev3-1-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Precisão de 6 casas atingida com "</span> <span class="op">&lt;&lt;</span> termosParaPrecisao <span class="op">&lt;&lt;</span> <span class="st">" termos"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev3-1-45"><a href="#lst-rev3-1-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="lst-rev3-1-46"><a href="#lst-rev3-1-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Precisão de 6 casas não atingida com "</span> <span class="op">&lt;&lt;</span> numeroTermos <span class="op">&lt;&lt;</span> <span class="st">" termos"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev3-1-47"><a href="#lst-rev3-1-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-rev3-1-48"><a href="#lst-rev3-1-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev3-1-49"><a href="#lst-rev3-1-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-rev3-1-50"><a href="#lst-rev3-1-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p><strong>Revisão 4</strong>: no Centro de Pesquisa em Matemática Computacional, o Dr.&nbsp;Roberto está estudando diferentes métodos para aproximar fatoriais de números grandes. Ele decidiu implementar uma versão simplificada da fórmula de Stirling combinada com uma série de correção. A fórmula de Stirling é uma aproximação do fatorial de um número grande <span class="math inline">\(n\)</span> e é dada por:</p>
<p><span class="math display">\[n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n \cdot \left(1 + \frac{1}{12n} + \frac{1}{288n^2}\right)\]</span></p>
<p>Que pode ser expressa usando somatório e produtório como:</p>
<p><span class="math display">\[\text{Aproximação} = \sqrt{2\pi n} \cdot \prod_{i=1}^{n} \frac{i}{e} \cdot \sum_{k=0}^{2} \frac{c_k}{n^k}\]</span></p>
<p>Na qual <span class="math inline">\(c_0 = 1\)</span>, <span class="math inline">\(c_1 = \frac{1}{12}\)</span>, <span class="math inline">\(c_2 = \frac{1}{288}\)</span>.</p>
<p>O sistema deve receber um número <code>n</code>, calcular o fatorial exato (para <span class="math inline">\(n \leq 20\)</span>), calcular a aproximação usando a fórmula acima, mostrar os valores do produtório e somatório separadamente, e calcular o erro percentual entre o valor exato e a aproximação. Como a fórmula de Stirling requer o cálculo de <span class="math inline">\(\sqrt{2\pi n}\)</span>, o algoritmo deve implementar o método babilônico para calcular raiz quadrada sem depender de bibliotecas matemáticas externas. O método babilônico utiliza a fórmula iterativa <span class="math inline">\(x_{novo} = \frac{1}{2}(x + \frac{numero}{x})\)</span>, repetindo até atingir a precisão desejada. Desenvolva um algoritmo que implemente este sistema de aproximação fatorial, incluindo uma função para calcular a raiz quadrada usando o método babilônico, uma função para calcular o valor absoluto sem usar a biblioteca <code>cmath</code>, e utilizando os valores pré-definidos <span class="math inline">\(\pi = 3.141592653589793\)</span> e <span class="math inline">\(e = 2.718281828459045\)</span>.</p>
<p><strong>Solução</strong>:</p>
<pre class="shell"><code>ALGORITMO AproximacaoFatorial

ENTRADA:
    n: inteiro

SAÍDA:
    fatorialExato: inteiro
    aproximacaoStirling: real
    erroPercentual: real

INÍCIO
    ESCREVER "Digite o valor de n (≤ 20):"
    LER n
    
    // Calcular fatorial exato
    fatorialExato ← 1
    PARA i DE 1 ATÉ n FAÇA
        fatorialExato ← fatorialExato * i
    FIM PARA
    
    // Calcular produtório: ∏(i/e) de i=1 até n
    produtorio ← 1.0
    e ← 2.718281828459045
    PARA i DE 1 ATÉ n FAÇA
        produtorio ← produtorio * (i / e)
    FIM PARA
    ESCREVER "Produtório ∏(i/e): ", produtorio
    
    // Calcular somatório: Σ(ck/n^k) de k=0 até 2
    c0 ← 1.0
    c1 ← 1.0 / 12.0
    c2 ← 1.0 / 288.0
    
    somatorio ← c0 + (c1 / n) + (c2 / (n * n))
    ESCREVER "Somatório (1 + 1/12n + 1/288n²): ", somatorio
    
    // Calcular raiz quadrada usando método babilônico
    valor ← 2 * pi * n
    raizParte ← RAIZ_BABILONICA(valor)
    
    // Calcular aproximação completa
    pi ← 3.141592653589793
    aproximacaoStirling ← raizParte * produtorio * somatorio
    
    // Calcular erro percentual
    erroPercentual ← VALOR_ABSOLUTO(aproximacaoStirling - fatorialExato) / fatorialExato * 100
    
    ESCREVER "Fatorial exato de ", n, "!: ", fatorialExato
    ESCREVER "Aproximação de Stirling: ", aproximacaoStirling
    ESCREVER "√(2πn): ", raizParte
    ESCREVER "Erro percentual: ", erroPercentual, "%"
    
    RETORNAR fatorialExato, aproximacaoStirling, erroPercentual
FIM

FUNÇÃO RAIZ_BABILONICA(numero: real) → real
    SE numero &lt;= 0 ENTÃO RETORNAR 0
    x ← numero
    REPETIR
        raiz ← 0.5 * (x + numero / x)
        SE VALOR_ABSOLUTO(raiz - x) &lt; 0.000001 ENTÃO
            RETORNAR raiz
        x ← raiz
    ATÉ FALSO
FIM FUNÇÃO

FUNÇÃO VALOR_ABSOLUTO(valor: real) → real
    SE valor &lt; 0 ENTÃO
        RETORNAR -valor
    SENÃO
        RETORNAR valor
    FIM SE
FIM FUNÇÃO</code></pre>
<p>Considerando o pseudo código acima, o código <a href="#lst-rev4-1" class="quarto-xref">Listing&nbsp;<span>7.5</span></a> permite a implementação do algoritmo em C++23:</p>
<div id="lst-rev4-1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-rev4-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;7.5
</figcaption>
<div aria-describedby="lst-rev4-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-rev4-1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-rev4-1-1"><a href="#lst-rev4-1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="lst-rev4-1-2"><a href="#lst-rev4-1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="lst-rev4-1-3"><a href="#lst-rev4-1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev4-1-4"><a href="#lst-rev4-1-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Constantes matemáticas definidas manualmente</span></span>
<span id="lst-rev4-1-5"><a href="#lst-rev4-1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> PI <span class="op">=</span> <span class="fl">3.141592653589793</span><span class="op">;</span></span>
<span id="lst-rev4-1-6"><a href="#lst-rev4-1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> E <span class="op">=</span> <span class="fl">2.718281828459045</span><span class="op">;</span></span>
<span id="lst-rev4-1-7"><a href="#lst-rev4-1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev4-1-8"><a href="#lst-rev4-1-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Função para valor absoluto sem usar cmath</span></span>
<span id="lst-rev4-1-9"><a href="#lst-rev4-1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> abs_manual<span class="op">(</span><span class="kw">auto</span> valor<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev4-1-10"><a href="#lst-rev4-1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>valor <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="op">-</span>valor <span class="op">:</span> valor<span class="op">;</span></span>
<span id="lst-rev4-1-11"><a href="#lst-rev4-1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="lst-rev4-1-12"><a href="#lst-rev4-1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev4-1-13"><a href="#lst-rev4-1-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Função para raiz quadrada usando método babilônico</span></span>
<span id="lst-rev4-1-14"><a href="#lst-rev4-1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sqrt_babilonico<span class="op">(</span><span class="kw">auto</span> numero<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev4-1-15"><a href="#lst-rev4-1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>numero <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="lst-rev4-1-16"><a href="#lst-rev4-1-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-17"><a href="#lst-rev4-1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x <span class="op">=</span> numero<span class="op">;</span></span>
<span id="lst-rev4-1-18"><a href="#lst-rev4-1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev4-1-19"><a href="#lst-rev4-1-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> raiz <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="op">(</span>x <span class="op">+</span> numero <span class="op">/</span> x<span class="op">);</span></span>
<span id="lst-rev4-1-20"><a href="#lst-rev4-1-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>abs_manual<span class="op">(</span>raiz <span class="op">-</span> x<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.000001</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev4-1-21"><a href="#lst-rev4-1-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> raiz<span class="op">;</span></span>
<span id="lst-rev4-1-22"><a href="#lst-rev4-1-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-rev4-1-23"><a href="#lst-rev4-1-23" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> raiz<span class="op">;</span></span>
<span id="lst-rev4-1-24"><a href="#lst-rev4-1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-rev4-1-25"><a href="#lst-rev4-1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="lst-rev4-1-26"><a href="#lst-rev4-1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev4-1-27"><a href="#lst-rev4-1-27" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> calcularFatorial<span class="op">(</span><span class="kw">auto</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev4-1-28"><a href="#lst-rev4-1-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> resultado <span class="op">=</span> <span class="dv">1</span><span class="bu">LL</span><span class="op">;</span></span>
<span id="lst-rev4-1-29"><a href="#lst-rev4-1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> <span class="bu">std::</span>views::iota<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n<span class="op">+</span><span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="lst-rev4-1-30"><a href="#lst-rev4-1-30" aria-hidden="true" tabindex="-1"></a>        resultado <span class="op">*=</span> i<span class="op">;</span></span>
<span id="lst-rev4-1-31"><a href="#lst-rev4-1-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-rev4-1-32"><a href="#lst-rev4-1-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> resultado<span class="op">;</span></span>
<span id="lst-rev4-1-33"><a href="#lst-rev4-1-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="lst-rev4-1-34"><a href="#lst-rev4-1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-rev4-1-35"><a href="#lst-rev4-1-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-rev4-1-36"><a href="#lst-rev4-1-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-rev4-1-37"><a href="#lst-rev4-1-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Digite o valor de n (≤ 20): "</span><span class="op">;</span></span>
<span id="lst-rev4-1-38"><a href="#lst-rev4-1-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> n<span class="op">;</span></span>
<span id="lst-rev4-1-39"><a href="#lst-rev4-1-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-40"><a href="#lst-rev4-1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">20</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-rev4-1-41"><a href="#lst-rev4-1-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Valor muito grande. Use n ≤ 20."</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev4-1-42"><a href="#lst-rev4-1-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="lst-rev4-1-43"><a href="#lst-rev4-1-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-rev4-1-44"><a href="#lst-rev4-1-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-45"><a href="#lst-rev4-1-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calcular fatorial exato</span></span>
<span id="lst-rev4-1-46"><a href="#lst-rev4-1-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> fatorialExato <span class="op">=</span> calcularFatorial<span class="op">(</span>n<span class="op">);</span></span>
<span id="lst-rev4-1-47"><a href="#lst-rev4-1-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-48"><a href="#lst-rev4-1-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calcular produtório: ∏(i/e) de i=1 até n</span></span>
<span id="lst-rev4-1-49"><a href="#lst-rev4-1-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> produtorio <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="lst-rev4-1-50"><a href="#lst-rev4-1-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> <span class="bu">std::</span>views::iota<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n<span class="op">+</span><span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="lst-rev4-1-51"><a href="#lst-rev4-1-51" aria-hidden="true" tabindex="-1"></a>        produtorio <span class="op">*=</span> <span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>i<span class="op">)</span> <span class="op">/</span> E<span class="op">);</span></span>
<span id="lst-rev4-1-52"><a href="#lst-rev4-1-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-rev4-1-53"><a href="#lst-rev4-1-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Produtório ∏(i/e): "</span> <span class="op">&lt;&lt;</span> produtorio <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev4-1-54"><a href="#lst-rev4-1-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-55"><a href="#lst-rev4-1-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calcular somatório: Σ(ck/n^k) de k=0 até 2</span></span>
<span id="lst-rev4-1-56"><a href="#lst-rev4-1-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c0 <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="lst-rev4-1-57"><a href="#lst-rev4-1-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c1 <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="fl">12.0</span><span class="op">;</span></span>
<span id="lst-rev4-1-58"><a href="#lst-rev4-1-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c2 <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="fl">288.0</span><span class="op">;</span></span>
<span id="lst-rev4-1-59"><a href="#lst-rev4-1-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-60"><a href="#lst-rev4-1-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> somatorio <span class="op">=</span> c0 <span class="op">+</span> <span class="op">(</span>c1 <span class="op">/</span> n<span class="op">)</span> <span class="op">+</span> <span class="op">(</span>c2 <span class="op">/</span> <span class="op">(</span>n <span class="op">*</span> n<span class="op">));</span></span>
<span id="lst-rev4-1-61"><a href="#lst-rev4-1-61" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Somatório (1 + 1/12n + 1/288n²): "</span> <span class="op">&lt;&lt;</span> somatorio <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev4-1-62"><a href="#lst-rev4-1-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-63"><a href="#lst-rev4-1-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calcular aproximação completa</span></span>
<span id="lst-rev4-1-64"><a href="#lst-rev4-1-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> valorRaiz <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> PI <span class="op">*</span> n<span class="op">;</span></span>
<span id="lst-rev4-1-65"><a href="#lst-rev4-1-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> raizParte <span class="op">=</span> sqrt_babilonico<span class="op">(</span>valorRaiz<span class="op">);</span></span>
<span id="lst-rev4-1-66"><a href="#lst-rev4-1-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> aproximacaoStirling <span class="op">=</span> raizParte <span class="op">*</span> produtorio <span class="op">*</span> somatorio<span class="op">;</span></span>
<span id="lst-rev4-1-67"><a href="#lst-rev4-1-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-68"><a href="#lst-rev4-1-68" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calcular erro percentual</span></span>
<span id="lst-rev4-1-69"><a href="#lst-rev4-1-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> erroPercentual <span class="op">=</span> abs_manual<span class="op">(</span>aproximacaoStirling <span class="op">-</span> fatorialExato<span class="op">)</span> <span class="op">/</span> fatorialExato <span class="op">*</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="lst-rev4-1-70"><a href="#lst-rev4-1-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-71"><a href="#lst-rev4-1-71" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Fatorial exato de "</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">"!: "</span> <span class="op">&lt;&lt;</span> fatorialExato <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev4-1-72"><a href="#lst-rev4-1-72" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Aproximação de Stirling: "</span> <span class="op">&lt;&lt;</span> aproximacaoStirling <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev4-1-73"><a href="#lst-rev4-1-73" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"√(2πn): "</span> <span class="op">&lt;&lt;</span> raizParte <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev4-1-74"><a href="#lst-rev4-1-74" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Erro percentual: "</span> <span class="op">&lt;&lt;</span> erroPercentual <span class="op">&lt;&lt;</span> <span class="st">"%"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-rev4-1-75"><a href="#lst-rev4-1-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-rev4-1-76"><a href="#lst-rev4-1-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-rev4-1-77"><a href="#lst-rev4-1-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p>Para testar o código <a href="#lst-rev4-1" class="quarto-xref">Listing&nbsp;<span>7.5</span></a>, o professor pode usar os seguintes valores de entrada para n = 5:</p>
<ul>
<li>Fatorial exato: 5! = 120</li>
<li>Aproximação de Stirling esperada: ≈ 118.02</li>
<li>Erro percentual esperado: ≈ 1.65%</li>
</ul>
<section id="reconhecimento-de-padrões-função" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="reconhecimento-de-padrões-função"><span class="header-section-number">7.1.1</span> Reconhecimento de Padrões: Função</h3>
<p>O reconhecimento de padrões é uma habilidade essencial no raciocínio algorítmico, permitindo identificar soluções comuns para problemas recorrentes. Foi o reconhecimento de padrões que levou à criação de funções, que são blocos reutilizáveis de código que encapsulam uma lógica específica. Neste módulo, os alunos devem aprender a identificar padrões em problemas antes de criar funções para resolver esses problemas. O objetivo é que a metáfora de “função” seja vista como uma abstração que permite resolver problemas complexos de forma modular e reutilizável. Além disso, é importante que os alunos entendam que a função é um desvio de fluxo que permite encapsular uma lógica específica, tornando o código mais legível e organizado. Mas que implica em custo computacional extra.</p>
<p>Os exercícios a seguir podem ser aplicados segundo a Técnica da Sequência de Fibonacci, na qual o professor deve escolher o número de problemas que serão resolvidos em cada etapa de acordo com o tamanho e o resultado da turma, mas deve se manter na Técnica da Sequência de Fibonacci. A Técnica da Sequência de Fibonacci foi abordada na <a href="desenv1.html#sec-modulo1-unplugged" class="quarto-xref"><span>Section 6.1.1</span></a> nesta técnica além de tempos e quantidades, o professor precisa se preocupar que a devolutiva deve ser feita no quadro, com o professor explicando cada passo do algoritmo, enfatizando a importância da decomposição e abstração. A seguir está uma lista de problemas que podem ser usados para esta atividade, começando com a repetição de um exercício anterior, apenas revisão:</p>
<p><strong>A</strong>. Um canhão dispara projéteis seguindo a equação de altura <span class="math inline">\(h(t) = -4.9t^2 + v_0 \sin(\theta) \cdot t + h_0\)</span>, na qual <span class="math inline">\(t\)</span> é o tempo em segundos, <span class="math inline">\(v_0\)</span> é a velocidade inicial, <span class="math inline">\(\theta\)</span> é o ângulo de lançamento e <span class="math inline">\(h_0\)</span> é a altura inicial. Você deverá determinar quando o projétil atinge o solo a Atendendo as seguintes especificações.</p>
<p><strong>Entrada</strong>: <span class="math inline">\(v_0\)</span> (velocidade inicial em m/s), <span class="math inline">\(\theta\)</span> (ângulo em graus), <span class="math inline">\(h_0\)</span> (altura inicial em metros)</p>
<p><strong>Tarefa</strong>: Calcule quando o projétil atinge o solo (h = 0). Se existirem duas soluções positivas, mostre a menor (primeiro impacto). Se não houver soluções reais positivas, informe que o projétil não atinge o solo.</p>
<p><strong>Saída</strong>: Tempo de impacto ou mensagem de erro.</p>
<p>Além desta especificações, você deve considerar que o seno de um ângulo pode ser aproximado usando a série de Taylor.</p>
<p>A série de Taylor para calcular <span class="math inline">\(\sin(x)\)</span> é dada por:</p>
<p><span class="math display">\[\sin(x) = \sum_{n=0}^{\infty} \frac{(-1)^n \cdot x^{2n+1}}{(2n+1)!}\]</span></p>
<p>Expandindo os primeiros termos:</p>
<p><span class="math display">\[\sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \frac{x^9}{9!} - \frac{x^{11}}{11!} + \ldots\]</span></p>
<p>Nesta expressão:</p>
<ul>
<li><span class="math inline">\(x\)</span> deve estar em radianos;</li>
<li><span class="math inline">\(n!\)</span> representa o fatorial de <span class="math inline">\(n\)</span>;</li>
<li>A série alterna entre sinais positivos e negativos;</li>
<li>Para precisão razoável, geralmente 7 termos são suficientes.</li>
</ul>
<p><strong>Análise</strong>: o pseudocódigo para este exercício pode ser representado como:</p>
<pre class="shell"><code>ALGORITMO TrajetoriaProjetil

ENTRADA:
    v0, theta, h0: real

SAÍDA:
    tempo: real ou mensagem

INÍCIO
    LER v0, theta, h0
    
    // Converter ângulo para radianos
    pi ← 3.14159265
    radianos ← theta * pi
    radianos ← radianos / 180
    
    // Calcular seno usando aproximação por série de Taylor (5 termos)
    seno ← radianos
    termo ← radianos
    i ← 1
    ENQUANTO i &lt;= 4 FAÇA
        termo ← termo * radianos
        termo ← termo * radianos
        temp ← 2 * i
        temp ← temp + 1
        temp2 ← temp - 1
        temp3 ← temp2 * temp
        termo ← termo / temp3
        SE i % 2 = 0 ENTÃO
            seno ← seno + termo
        SENÃO
            seno ← seno - termo
        FIM SE
        i ← i + 1
    FIM ENQUANTO
    
    // Coeficientes da equação quadrática: at² + bt + c = 0
    a ← -4.9
    b ← v0 * seno
    c ← h0
    
    // Calcular discriminante
    temp ← b * b
    temp2 ← 4 * a
    temp3 ← temp2 * c
    discriminante ← temp - temp3
    
    SE discriminante &lt; 0 ENTÃO
        ESCREVER "O projétil não atinge o solo"
    SENÃO
        // Calcular raiz quadrada do discriminante usando método de Newton
        raizQuadrada ← discriminante / 2
        ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA
            temp ← raizQuadrada * raizQuadrada
            temp ← temp + discriminante
            raizQuadrada ← temp / (2 * raizQuadrada)
        FIM ENQUANTO
        
        // Calcular as duas raízes
        temp ← 0 - b
        temp2 ← 2 * a
        raiz1 ← temp + raizQuadrada
        raiz1 ← raiz1 / temp2
        raiz2 ← temp - raizQuadrada
        raiz2 ← raiz2 / temp2
        
        // Verificar soluções positivas
        SE raiz1 &gt; 0 E raiz2 &gt; 0 ENTÃO
            SE raiz1 &lt; raiz2 ENTÃO
                tempo ← raiz1
            SENÃO
                tempo ← raiz2
            FIM SE
            ESCREVER "Tempo de impacto:", tempo, "segundos"
        SENÃO SE raiz1 &gt; 0 ENTÃO
            ESCREVER "Tempo de impacto:", raiz1, "segundos"
        SENÃO SE raiz2 &gt; 0 ENTÃO
            ESCREVER "Tempo de impacto:", raiz2, "segundos"
        SENÃO
            ESCREVER "O projétil não atinge o solo"
        FIM SE
    FIM SE
FIM</code></pre>
<p>Nós estamos tentando criar a cognição necessária para entender o uso de funções. Assim, o professor pode propor o uso de um fluxograma para melhorar a visualização do algoritmo apresentado no pseudocódigo acima. Para tanto, o professor pode usar o fluxograma apresentado na <a href="#fig-projetil" class="quarto-xref">Figure&nbsp;<span>7.1</span></a>.</p>
<div id="fig-projetil" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-projetil-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/projetil.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-projetil-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.1: Fluxograma do Algoritmo de Trajetória de Projétil usando apenas operações binárias e unárias.
</figcaption>
</figure>
</div>
<p>O fluxograma da <a href="#fig-projetil" class="quarto-xref">Figure&nbsp;<span>7.1</span></a> mostra as operações binárias e unárias necessárias para resolver o problema da trajetória do projétil detalhando cada processo necessário. Esta estrutura pode criar dúvidas e confusão. Contudo, é preciso lembrar que neste momento, estamos trabalhando para criar a abstração necessária ao entendimento do conceito de função. E não usando funções.</p>
<p>O professor pode usar este fluxograma para destacar a necessidade do uso de abstrações mais eficientes. Por exemplo, podemos criar um pseudocódigo, ou conjunto de módulos, só para calcular o quadrado de um valor e dividir este quadrado por outro valor, em vez de um bloco para multiplicar um valor por si mesmo e então dividir este valor por outro, como é feito na <a href="#fig-projetil" class="quarto-xref">Figure&nbsp;<span>7.1</span></a>.</p>
<p>Usando a <a href="#fig-projetil" class="quarto-xref">Figure&nbsp;<span>7.1</span></a>, será importante destacar as áreas que podem ser transformadas em funções, como o cálculo do seno usando a série de Taylor, que pode ser encapsulado em uma função separada.</p>
<p>Finalmente, neste ponto, fica claro que o fluxograma não atende todas as abstrações que precisamos construir para usar linguagens imperativas de forma estruturada. Deste ponto, em diante, vamos dar prioridade ao pseudocódigo.</p>
<p><strong>B</strong>. Um fazendeiro possui 120 metros de cerca para delimitar um terreno retangular. Uma das dimensões será <span class="math inline">\(x\)</span> metros, resultando numa área <span class="math inline">\(A = x(60-x)\)</span> metros quadrados. Determine as dimensões possíveis do terreno para atingir uma determinada área. Sabendo que a equação que representa este fenômeno é <span class="math inline">\(x^2 - 60x + \text{área} = 0\)</span>. Considere as seguintes especificações:</p>
<p><strong>Entrada</strong>: Área desejada em metros quadrados</p>
<p><strong>Saída</strong>: As duas dimensões possíveis ou mensagem informando que a área é impossível de atingir.</p>
<p><strong>Solução</strong>:</p>
<p>Já usando funções no pseudocódigo, podemos representar o problema da seguinte forma:</p>
<pre class="shell"><code>ALGORITMO DimensoesTerreno

ENTRADA:
    area_desejada: real

SAÍDA:
    dimensoes: real, real ou mensagem

INÍCIO
    LER area_desejada
    
    // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA
    // Equação: x² - 60x + area_desejada = 0
    a ← 1
    b ← -60
    c ← area_desejada
    
    // CALCULAR DISCRIMINANTE
    temp1 ← b * b
    temp2 ← 4 * a
    temp3 ← temp2 * c
    discriminante ← temp1 - temp3
    
    // VERIFICAR VIABILIDADE DA SOLUÇÃO
    SE discriminante &lt; 0 ENTÃO
        ESCREVER "Área impossível de atingir com 120 metros de cerca"
    SENÃO
        // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
        raizQuadrada ← calcularRaizQuadrada(discriminante)
        
        // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA
        raiz1, raiz2 ← calcularRaizes(a, b, raizQuadrada)
        
        // CALCULAR AS DIMENSÕES DO TERRENO
        // Primeira dimensão: x = raiz1
        dimensao1_x ← raiz1
        temp_sub1 ← 60 - raiz1
        dimensao1_y ← temp_sub1
        
        // Segunda dimensão: x = raiz2
        dimensao2_x ← raiz2
        temp_sub2 ← 60 - raiz2
        dimensao2_y ← temp_sub2
        
        // VALIDAR DIMENSÕES FÍSICAS
        valida1 ← FALSO
        valida2 ← FALSO
        
        // Verificar primeira solução
        SE dimensao1_x &gt; 0 E dimensao1_x &lt; 60 ENTÃO
            SE dimensao1_y &gt; 0 E dimensao1_y &lt; 60 ENTÃO
                valida1 ← VERDADEIRO
            FIM SE
        FIM SE
        
        // Verificar segunda solução
        SE dimensao2_x &gt; 0 E dimensao2_x &lt; 60 ENTÃO
            SE dimensao2_y &gt; 0 E dimensao2_y &lt; 60 ENTÃO
                valida2 ← VERDADEIRO
            FIM SE
        FIM SE
        
        // APRESENTAR RESULTADOS
        SE valida1 = VERDADEIRO E valida2 = VERDADEIRO ENTÃO
            ESCREVER "Primeira solução:"
            ESCREVER "Dimensões:", dimensao1_x, "metros x", dimensao1_y, "metros"
            ESCREVER "Segunda solução:"
            ESCREVER "Dimensões:", dimensao2_x, "metros x", dimensao2_y, "metros"
        SENÃO SE valida1 = VERDADEIRO ENTÃO
            ESCREVER "Dimensões possíveis:"
            ESCREVER dimensao1_x, "metros x", dimensao1_y, "metros"
        SENÃO SE valida2 = VERDADEIRO ENTÃO
            ESCREVER "Dimensões possíveis:"
            ESCREVER dimensao2_x, "metros x", dimensao2_y, "metros"
        SENÃO
            ESCREVER "Área impossível de atingir com as limitações físicas"
        FIM SE
    FIM SE
FIM

// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
FUNÇÃO calcularRaizQuadrada(discriminante: real): real
INÍCIO
    raizQuadrada ← discriminante / 2

    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA
        // Calcular raizQuadrada² 
        temp_quad ← raizQuadrada * raizQuadrada
        
        // Calcular numerador: raizQuadrada² + discriminante
        numerador ← temp_quad + discriminante
        
        // Calcular denominador: 2 * raizQuadrada
        denominador ← 2 * raizQuadrada
        
        // Nova aproximação
        raizQuadrada ← numerador / denominador
    FIM ENQUANTO
    
    RETORNAR raizQuadrada
FIM

// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA
FUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real
INÍCIO
    // Calcular -b
    menos_b ← 0 - b

    // Calcular denominador comum: 2a
    denominador_comum ← 2 * a
    
    // Calcular raiz1: (-b + √Δ) / 2a
    numerador1 ← menos_b + raizQuadrada
    raiz1 ← numerador1 / denominador_comum
    
    // Calcular raiz2: (-b - √Δ) / 2a  
    numerador2 ← menos_b - raizQuadrada
    raiz2 ← numerador2 / denominador_comum
    
    RETORNAR raiz1, raiz2
FIM

// FUNÇÃO AUXILIAR: VALOR ABSOLUTO
FUNÇÃO abs(valor: real): real
INÍCIO
    SE valor &lt; 0 ENTÃO
        resultado ← 0 - valor
    SENÃO
        resultado ← valor
    FIM SE
    RETORNAR resultado
FIM</code></pre>
<p>Este pseudocódigo serve como ferramenta de abstração para o professor, que pode usar este algoritmo para explicar a decomposição do problema em funções menores. O professor pode destacar como cada função tem uma responsabilidade específica, como calcular a raiz quadrada, calcular as raízes da equação quadrática e validar as dimensões físicas. Além disso, o professor pode enfatizar a importância de validar as entradas e saídas de cada função, garantindo que o código seja robusto e fácil de entender. Por fim, as funções auxiliares foram colocadas no final do pseudocódigo para destacar que elas são abstrações que podem ser reutilizadas em outros contextos, reforçando a ideia de modularidade, reutilização de código e de controle de fluxo. Em C++23, o pseudocódigo está implementado no site GDB Online no link <a href="https://onlinegdb.com/Si-IeJICB">https://onlinegdb.com/Si-IeJICB</a>.</p>
<p><strong>C</strong>. Um veículo em movimento tem sua posição descrita por <span class="math inline">\(s(t) = s_0 + v_0t + \frac{1}{2}at^2\)</span>, na qual <span class="math inline">\(s_0\)</span> é a posição inicial, <span class="math inline">\(v_0\)</span> é a velocidade inicial e <span class="math inline">\(a\)</span> é a aceleração. Sua tarefa é criar um algoritmo que calcule em que instante(s) o veículo passa por uma posição final <span class="math inline">\(s_f\)</span>. Para tanto, considere as seguintes especificações:</p>
<p><strong>Entrada</strong>: <span class="math inline">\(s_0\)</span> (posição inicial em metros), <span class="math inline">\(v_0\)</span> (velocidade inicial em m/s), <span class="math inline">\(a\)</span> (aceleração em m/s²), <span class="math inline">\(s_f\)</span> (posição final desejada em metros)</p>
<p><strong>Tarefa</strong>: Calcule em que instante(s) o veículo passa pela posição <span class="math inline">\(s_f\)</span>. A equação é <span class="math inline">\(\frac{1}{2}at^2 + v_0t + (s_0 - s_f) = 0\)</span>.</p>
<p><strong>Saída</strong>: Tempo(s) em que o veículo passa pela posição ou mensagem de que nunca passa.</p>
<p><strong>Solução</strong>:</p>
<p>Neste caso, reusando as abstrações criadas para funções do exercício anterior, teremos:</p>
<pre class="shell"><code>ALGORITMO PosicaoVeiculo

ENTRADA:
    s0, v0, a, sf: real

SAÍDA:
    tempo(s): real ou mensagem

INÍCIO
    LER s0, v0, a, sf
    
    // VERIFICAR TIPO DE MOVIMENTO
    
    SE a = 0 ENTÃO
        // Movimento uniforme: s = s0 + v0*t
        // sf = s0 + v0*t  =&gt;  t = (sf - s0)/v0
        
        SE v0 = 0 ENTÃO
            SE s0 = sf ENTÃO
                ESCREVER "O veículo está sempre na posição desejada"
            SENÃO
                ESCREVER "O veículo nunca passa pela posição desejada"
            FIM SE
        SENÃO
            // Calcular t = (sf - s0) / v0
            diferenca ← sf - s0
            tempo ← diferenca / v0
            ESCREVER "O veículo passa pela posição no tempo:", tempo, "segundos"
        FIM SE
    SENÃO
        
        // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA
        // Equação: (1/2)at² + v0t + (s0 - sf) = 0
        // Multiplicando por 2: at² + 2v0t + 2(s0 - sf) = 0
        coef_a ← a
        temp_2v0 ← 2 * v0
        coef_b ← temp_2v0
        temp_diff ← s0 - sf
        temp_2diff ← 2 * temp_diff
        coef_c ← temp_2diff
        
        
        // CALCULAR DISCRIMINANTE
        temp1 ← coef_b * coef_b
        temp2 ← 4 * coef_a
        temp3 ← temp2 * coef_c
        discriminante ← temp1 - temp3
        
        
        // VERIFICAR VIABILIDADE DA SOLUÇÃO
        SE discriminante &lt; 0 ENTÃO
            ESCREVER "O veículo nunca passa pela posição desejada"
        SENÃO
            
            // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
            raizQuadrada ← calcularRaizQuadrada(discriminante)
            
            // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA
           tempo1, tempo2 ← calcularRaizes(coef_a, coef_b, raizQuadrada)
            
            // VALIDAR E APRESENTAR TEMPOS
            tempos_validos ← 0
            
            // Verificar primeiro tempo
            SE tempo1 &gt;= 0 ENTÃO
                tempos_validos ← tempos_validos + 1
                primeiro_tempo_valido ← tempo1
            FIM SE
            
            // Verificar segundo tempo
            SE tempo2 &gt;= 0 ENTÃO
                tempos_validos ← tempos_validos + 1
                SE tempos_validos = 1 ENTÃO
                    primeiro_tempo_valido ← tempo2
                SENÃO
                    segundo_tempo_valido ← tempo2
                FIM SE
            FIM SE
            
            
            // APRESENTAR RESULTADOS
            SE tempos_validos = 0 ENTÃO
                ESCREVER "O veículo passou pela posição apenas no passado:"
                ESCREVER "Tempo 1:", tempo1, "segundos"
                ESCREVER "Tempo 2:", tempo2, "segundos"
            SENÃO SE tempos_validos = 1 ENTÃO
                ESCREVER "O veículo passa pela posição no tempo:"
                ESCREVER primeiro_tempo_valido, "segundos"
                
                // Mostrar também tempo negativo se existir
                SE tempo1 &lt; 0 ENTÃO
                    ESCREVER "Também passou no passado em:", tempo1, "segundos"
                FIM SE
                SE tempo2 &lt; 0 ENTÃO
                    ESCREVER "Também passou no passado em:", tempo2, "segundos"
                FIM SE
            SENÃO
                // Ordenar os tempos (menor primeiro)
                SE primeiro_tempo_valido &gt; segundo_tempo_valido ENTÃO
                    temp_swap ← primeiro_tempo_valido
                    primeiro_tempo_valido ← segundo_tempo_valido
                    segundo_tempo_valido ← temp_swap
                FIM SE
                
                ESCREVER "O veículo passa pela posição em dois momentos:"
                ESCREVER "Primeiro tempo:", primeiro_tempo_valido, "segundos"
                ESCREVER "Segundo tempo:", segundo_tempo_valido, "segundos"
            FIM SE
        FIM SE
    FIM SE
FIM


// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
FUNÇÃO calcularRaizQuadrada(discriminante: real): real
INÍCIO
    raizQuadrada ← discriminante / 2
    
    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA
        // Calcular raizQuadrada² 
        temp_quad ← raizQuadrada * raizQuadrada
        
        // Calcular numerador: raizQuadrada² + discriminante
        numerador ← temp_quad + discriminante
        
        // Calcular denominador: 2 * raizQuadrada
        denominador ← 2 * raizQuadrada
        
        // Nova aproximação
        raizQuadrada ← numerador / denominador
    FIM ENQUANTO
    
    RETORNAR raizQuadrada
FIM


// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA
FUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real
INÍCIO
    // Calcular -b
    menos_b ← 0 - b
    
    // Calcular denominador comum: 2a
    denominador_comum ← 2 * a
    
    // Calcular raiz1: (-b + √Δ) / 2a
    numerador1 ← menos_b + raizQuadrada
    raiz1 ← numerador1 / denominador_comum
    
    // Calcular raiz2: (-b - √Δ) / 2a  
    numerador2 ← menos_b - raizQuadrada
    raiz2 ← numerador2 / denominador_comum
    
    RETORNAR raiz1, raiz2
FIM

// FUNÇÃO AUXILIAR: VALOR ABSOLUTO
FUNÇÃO abs(valor: real): real
INÍCIO
    SE valor &lt; 0 ENTÃO
        resultado ← 0 - valor
    SENÃO
        resultado ← valor
    FIM SE
    RETORNAR resultado
FIM</code></pre>
<p>O código em C++23 para o pseudocódigo acima pode ser encontrado no site GDB Online no link <a href="https://onlinegdb.com/2ZaBx62x_">https://onlinegdb.com/2ZaBx62x_</a>.</p>
<p><strong>D</strong>. Uma empresa possui função de lucro <span class="math inline">\(L(q) = -2q^2 + 80q - 300\)</span>, na qual <span class="math inline">\(q\)</span> é a quantidade produzida e <span class="math inline">\(L\)</span> é o lucro em reais. Você deverá criar um programa que determine a quantidade de produção necessária para atingir o lucro desejado. A equação é <span class="math inline">\(-2q^2 + 80q - (300 + \text{lucro desejado}) = 0\)</span>. Considerando as seguintes especificações:</p>
<p><strong>Entrada</strong>: Lucro desejado em reais</p>
<p><strong>Saída</strong>: Quantidade(s) de produção ou mensagem de que o lucro é inatingível.</p>
<p><strong>Solução</strong>:</p>
<p>Neste caso, teremos:</p>
<pre class="shell"><code>ALGORITMO LucroEmpresa

ENTRADA:
    lucro_desejado: real

SAÍDA:
    quantidade(s): real ou mensagem

INÍCIO
    LER lucro_desejado
    
    // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA
    // Equação: -2q² + 80q - (300 + lucro_desejado) = 0
    a ← -2
    b ← 80
    temp_soma ← 300 + lucro_desejado
    temp_negativo ← 0 - temp_soma
    c ← temp_negativo
    
    // CALCULAR DISCRIMINANTE
    temp1 ← b * b
    temp2 ← 4 * a
    temp3 ← temp2 * c
    discriminante ← temp1 - temp3
    
    // VERIFICAR VIABILIDADE DA SOLUÇÃO
    SE discriminante &lt; 0 ENTÃO
        ESCREVER "Lucro inatingível com a função de produção atual"
    SENÃO
        
        // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
        raizQuadrada ← calcularRaizQuadrada(discriminante)
        
        // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA
        quantidade1, quantidade2 ← calcularRaizes(a, b, raizQuadrada)
        
        // VALIDAR QUANTIDADES FÍSICAS
        valida1 ← FALSO
        valida2 ← FALSO
        
        // Verificar primeira quantidade
        SE quantidade1 &gt; 0 ENTÃO
            valida1 ← VERDADEIRO
        FIM SE
        
        // Verificar segunda quantidade
        SE quantidade2 &gt; 0 ENTÃO
            valida2 ← VERDADEIRO
        FIM SE
        
        // CALCULAR LUCROS PARA VERIFICAÇÃO
        SE valida1 = VERDADEIRO ENTÃO
            // Calcular L(q1) = -2q1² + 80q1 - 300
            temp_q1_quadrado ← quantidade1 * quantidade1
            temp_menos2q1_quadrado ← -2 * temp_q1_quadrado
            temp_80q1 ← 80 * quantidade1
            temp_soma_termos ← temp_menos2q1_quadrado + temp_80q1
            lucro_verificacao1 ← temp_soma_termos - 300
        FIM SE
        
        SE valida2 = VERDADEIRO ENTÃO
            // Calcular L(q2) = -2q2² + 80q2 - 300
            temp_q2_quadrado ← quantidade2 * quantidade2
            temp_menos2q2_quadrado ← -2 * temp_q2_quadrado
            temp_80q2 ← 80 * quantidade2
            temp_soma_termos2 ← temp_menos2q2_quadrado + temp_80q2
            lucro_verificacao2 ← temp_soma_termos2 - 300
        FIM SE
        
        // APRESENTAR RESULTADOS
        SE valida1 = VERDADEIRO E valida2 = VERDADEIRO ENTÃO
            // Ordenar quantidades (menor primeiro)
            SE quantidade1 &gt; quantidade2 ENTÃO
                temp_swap ← quantidade1
                quantidade1 ← quantidade2
                quantidade2 ← temp_swap
            FIM SE
            
            ESCREVER "Duas quantidades de produção possíveis:"
            ESCREVER "Primeira quantidade:", quantidade1, "unidades"
            ESCREVER "Segunda quantidade:", quantidade2, "unidades"
            ESCREVER "Ambas geram o lucro de:", lucro_desejado, "reais"
            
        SENÃO SE valida1 = VERDADEIRO ENTÃO
            ESCREVER "Quantidade de produção necessária:"
            ESCREVER quantidade1, "unidades"
            ESCREVER "Lucro gerado:", lucro_verificacao1, "reais"
            
            // Mostrar também quantidade negativa se existir
            SE quantidade2 &lt; 0 ENTÃO
                ESCREVER "Quantidade negativa descartada:", quantidade2
            FIM SE
            
        SENÃO SE valida2 = VERDADEIRO ENTÃO
            ESCREVER "Quantidade de produção necessária:"
            ESCREVER quantidade2, "unidades"
            ESCREVER "Lucro gerado:", lucro_verificacao2, "reais"
            
            // Mostrar também quantidade negativa se existir
            SE quantidade1 &lt; 0 ENTÃO
                ESCREVER "Quantidade negativa descartada:", quantidade1
            FIM SE
            
        SENÃO
            ESCREVER "Todas as soluções resultam em quantidades negativas:"
            ESCREVER "Quantidade 1:", quantidade1, "unidades"
            ESCREVER "Quantidade 2:", quantidade2, "unidades"
            ESCREVER "Não é possível produzir quantidades negativas"
        FIM SE
    FIM SE
    
    // INFORMAÇÕES ADICIONAIS SOBRE A EMPRESA
    ESCREVER "Informações da função de lucro L(q) = -2q² + 80q - 300:"
    
    // Calcular lucro máximo (vértice da parábola)
    // q_max = -b/(2a) = -80/(2*(-2)) = 80/4 = 20
    temp_2a ← 2 * a
    temp_menos_b ← 0 - b
    q_maximo ← temp_menos_b / temp_2a
    
    // Calcular lucro máximo L(20)
    temp_qmax_quadrado ← q_maximo * q_maximo
    temp_menos2qmax_quadrado ← -2 * temp_qmax_quadrado
    temp_80qmax ← 80 * q_maximo
    temp_soma_max ← temp_menos2qmax_quadrado + temp_80qmax
    lucro_maximo ← temp_soma_max - 300
    
    ESCREVER "Quantidade para lucro máximo:", q_maximo, "unidades"
    ESCREVER "Lucro máximo possível:", lucro_maximo, "reais"
FIM

// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
FUNÇÃO calcularRaizQuadrada(discriminante: real): real
INÍCIO
    raizQuadrada ← discriminante / 2
    
    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA
        // Calcular raizQuadrada² 
        temp_quad ← raizQuadrada * raizQuadrada
        
        // Calcular numerador: raizQuadrada² + discriminante
        numerador ← temp_quad + discriminante
        
        // Calcular denominador: 2 * raizQuadrada
        denominador ← 2 * raizQuadrada
        
        // Nova aproximação
        raizQuadrada ← numerador / denominador
    FIM ENQUANTO
    
    RETORNAR raizQuadrada
FIM

// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA
FUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real
INÍCIO
    // Calcular -b
    menos_b ← 0 - b
    
    // Calcular denominador comum: 2a
    denominador_comum ← 2 * a
    
    // Calcular raiz1: (-b + √Δ) / 2a
    numerador1 ← menos_b + raizQuadrada
    raiz1 ← numerador1 / denominador_comum
    
    // Calcular raiz2: (-b - √Δ) / 2a  
    numerador2 ← menos_b - raizQuadrada
    raiz2 ← numerador2 / denominador_comum
    
    RETORNAR raiz1, raiz2
FIM

// FUNÇÃO AUXILIAR: VALOR ABSOLUTO
FUNÇÃO abs(valor: real): real
INÍCIO
    SE valor &lt; 0 ENTÃO
        resultado ← 0 - valor
    SENÃO
        resultado ← valor
    FIM SE
    RETORNAR resultado
FIM</code></pre>
<p>O código em C++23 para o pseudocódigo acima pode ser encontrado no site GDB Online no link <a href="https://onlinegdb.com/flCt2mss0">https://onlinegdb.com/flCt2mss0</a>.</p>
<p><strong>E</strong>. O ganho de uma antena parabólica em função do diâmetro segue a relação <span class="math inline">\(G = -0.1d^2 + 3d + 5\)</span>, na qual <span class="math inline">\(d\)</span> é o diâmetro em metros e <span class="math inline">\(G\)</span> é o ganho em dB. Você precisa criar um algoritmo que calcule o diâmetro de uma antena que forneça o ganho desejado. A equação é <span class="math inline">\(-0.1d^2 + 3d + (5 - \text{ganho desejado}) = 0\)</span>. Considere as seguintes especificações:</p>
<p><strong>Entrada</strong>: Ganho mínimo desejado em dB</p>
<p><strong>Saída</strong>: Diâmetro(s) da antena ou mensagem de que o ganho é impossível.</p>
<p><strong>Solução</strong>:</p>
<p>Para este exercício o pseudocódigo será semelhante ao anterior, mas com ajustes para a função de ganho da antena parabólica:</p>
<pre class="shell"><code>ALGORITMO GanhoAntenaParabolica

ENTRADA:
    ganho_desejado: real

SAÍDA:
    diametro(s): real ou mensagem

INÍCIO
    LER ganho_desejado
    
    // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA
    // Equação: -0.1d² + 3d + (5 - ganho_desejado) = 0
    a ← -0.1
    b ← 3
    temp_subtracao ← 5 - ganho_desejado
    c ← temp_subtracao
    
    // CALCULAR DISCRIMINANTE
    temp1 ← b * b
    temp2 ← 4 * a
    temp3 ← temp2 * c
    discriminante ← temp1 - temp3
    
    // VERIFICAR VIABILIDADE DA SOLUÇÃO
    SE discriminante &lt; 0 ENTÃO
        ESCREVER "Ganho impossível de atingir com antena parabólica"
    SENÃO
        
        // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
        raizQuadrada ← calcularRaizQuadrada(discriminante)
        
        
        // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA
        diametro1, diametro2 ← calcularRaizes(a, b, raizQuadrada)
        
        // VALIDAR DIÂMETROS FÍSICOS
        valida1 ← FALSO
        valida2 ← FALSO
        
        // Verificar primeiro diâmetro
        SE diametro1 &gt; 0 ENTÃO
            valida1 ← VERDADEIRO
        FIM SE
        
        // Verificar segundo diâmetro
        SE diametro2 &gt; 0 ENTÃO
            valida2 ← VERDADEIRO
        FIM SE
        
        
        // CALCULAR GANHOS PARA VERIFICAÇÃO
        SE valida1 = VERDADEIRO ENTÃO
            // Calcular G(d1) = -0.1d1² + 3d1 + 5
            temp_d1_quadrado ← diametro1 * diametro1
            temp_menos01d1_quadrado ← -0.1 * temp_d1_quadrado
            temp_3d1 ← 3 * diametro1
            temp_soma_termos ← temp_menos01d1_quadrado + temp_3d1
            ganho_verificacao1 ← temp_soma_termos + 5
        FIM SE
        
        SE valida2 = VERDADEIRO ENTÃO
            // Calcular G(d2) = -0.1d2² + 3d2 + 5
            temp_d2_quadrado ← diametro2 * diametro2
            temp_menos01d2_quadrado ← -0.1 * temp_d2_quadrado
            temp_3d2 ← 3 * diametro2
            temp_soma_termos2 ← temp_menos01d2_quadrado + temp_3d2
            ganho_verificacao2 ← temp_soma_termos2 + 5
        FIM SE
        
        
        // APRESENTAR RESULTADOS
        SE valida1 = VERDADEIRO E valida2 = VERDADEIRO ENTÃO
            // Ordenar diâmetros (menor primeiro)
            SE diametro1 &gt; diametro2 ENTÃO
                temp_swap ← diametro1
                diametro1 ← diametro2
                diametro2 ← temp_swap
            FIM SE
            
            ESCREVER "Dois diâmetros de antena possíveis:"
            ESCREVER "Primeiro diâmetro:", diametro1, "metros"
            ESCREVER "Segundo diâmetro:", diametro2, "metros"
            ESCREVER "Ambos geram o ganho de:", ganho_desejado, "dB"
            ESCREVER "Recomendação: usar o menor diâmetro por economia de material"
            
        SENÃO SE valida1 = VERDADEIRO ENTÃO
            ESCREVER "Diâmetro da antena necessário:"
            ESCREVER diametro1, "metros"
            ESCREVER "Ganho gerado:", ganho_verificacao1, "dB"
            
            // Mostrar também diâmetro negativo se existir
            SE diametro2 &lt; 0 ENTÃO
                ESCREVER "Diâmetro negativo descartado:", diametro2
            FIM SE
            
        SENÃO SE valida2 = VERDADEIRO ENTÃO
            ESCREVER "Diâmetro da antena necessário:"
            ESCREVER diametro2, "metros"
            ESCREVER "Ganho gerado:", ganho_verificacao2, "dB"
            
            // Mostrar também diâmetro negativo se existir
            SE diametro1 &lt; 0 ENTÃO
                ESCREVER "Diâmetro negativo descartado:", diametro1
            FIM SE
            
        SENÃO
            ESCREVER "Todas as soluções resultam em diâmetros negativos:"
            ESCREVER "Diâmetro 1:", diametro1, "metros"
            ESCREVER "Diâmetro 2:", diametro2, "metros"
            ESCREVER "Não é possível construir antenas com diâmetros negativos"
        FIM SE
    FIM SE
    
    
    // INFORMAÇÕES TÉCNICAS DA ANTENA
    ESCREVER "Informações da função de ganho G(d) = -0.1d² + 3d + 5:"
    
    // Calcular diâmetro para ganho máximo (vértice da parábola)
    // d_max = -b/(2a) = -3/(2*(-0.1)) = 3/0.2 = 15
    temp_2a ← 2 * a
    temp_menos_b ← 0 - b
    d_maximo ← temp_menos_b / temp_2a
    
    // Calcular ganho máximo G(15)
    temp_dmax_quadrado ← d_maximo * d_maximo
    temp_menos01dmax_quadrado ← -0.1 * temp_dmax_quadrado
    temp_3dmax ← 3 * d_maximo
    temp_soma_max ← temp_menos01dmax_quadrado + temp_3dmax
    ganho_maximo ← temp_soma_max + 5
    
    ESCREVER "Diâmetro para ganho máximo:", d_maximo, "metros"
    ESCREVER "Ganho máximo possível:", ganho_maximo, "dB"
    
    // Calcular diâmetro mínimo para ganho positivo (G = 0)
    // -0.1d² + 3d + 5 = 0
    a_min ← -0.1
    b_min ← 3
    c_min ← 5
    
    temp1_min ← b_min * b_min
    temp2_min ← 4 * a_min
    temp3_min ← temp2_min * c_min
    discriminante_min ← temp1_min - temp3_min
    
    SE discriminante_min &gt;= 0 ENTÃO
        raizQuadrada_min ← calcularRaizQuadrada(discriminante_min)
        diametro_min1, diametro_min2 ← calcularRaizes(a_min, b_min, raizQuadrada_min)
        
        // Escolher a maior raiz positiva (ponto no qual o ganho volta a zero)
        SE diametro_min1 &gt; diametro_min2 ENTÃO
            d_limite ← diametro_min1
        SENÃO
            d_limite ← diametro_min2
        FIM SE
        
        ESCREVER "Diâmetro limite (ganho = 0dB):", d_limite, "metros"
    FIM SE
FIM

// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)
FUNÇÃO calcularRaizQuadrada(discriminante: real): real
INÍCIO
    raizQuadrada ← discriminante / 2
    
    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA
        // Calcular raizQuadrada² 
        temp_quad ← raizQuadrada * raizQuadrada
        
        // Calcular numerador: raizQuadrada² + discriminante
        numerador ← temp_quad + discriminante
        
        // Calcular denominador: 2 * raizQuadrada
        denominador ← 2 * raizQuadrada
        
        // Nova aproximação
        raizQuadrada ← numerador / denominador
    FIM ENQUANTO
    
    RETORNAR raizQuadrada
FIM

// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA
FUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real
INÍCIO
    // Calcular -b
    menos_b ← 0 - b
    
    // Calcular denominador comum: 2a
    denominador_comum ← 2 * a
    
    // Calcular raiz1: (-b + √Δ) / 2a
    numerador1 ← menos_b + raizQuadrada
    raiz1 ← numerador1 / denominador_comum
    
    // Calcular raiz2: (-b - √Δ) / 2a  
    numerador2 ← menos_b - raizQuadrada
    raiz2 ← numerador2 / denominador_comum
    
    RETORNAR raiz1, raiz2
FIM

// FUNÇÃO AUXILIAR: VALOR ABSOLUTO
FUNÇÃO abs(valor: real): real
INÍCIO
    SE valor &lt; 0 ENTÃO
        resultado ← 0 - valor
    SENÃO
        resultado ← valor
    FIM SE
    RETORNAR resultado
FIM</code></pre>
<p>O código em C++23 para o pseudocódigo acima pode ser encontrado no site GDB Online no link <a href="https://onlinegdb.com/ZGj9kp4Jp">https://onlinegdb.com/ZGj9kp4Jp</a>.</p>
</section>
<section id="usando-funções-da-biblioteca-padrão" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="usando-funções-da-biblioteca-padrão"><span class="header-section-number">7.1.2</span> Usando funções da biblioteca padrão</h3>
<p>A maioria das linguagens de programação modernas possui um conjunto de funções pré-definidas para as ações comuns em uma grande variedade de aplicações. Essas funções são otimizadas e testadas, oferecendo uma maneira eficiente de realizar tarefas comuns sem a necessidade de reescrever o código. Os exercícios a seguir exploram o uso destas funções. O professor, deve adequar estes exercícios de acordo com a linguagem de programação escolhida para a disciplina. Aqui, os exemplos serão realizados em C++23.</p>
<p>Para o conjunto e exercícios a seguir, considere que o aluno já tenha sido apresentado às funções de manipulação de <em>strings</em>, manipulação de arquivos, e funções matemáticas básicas. Além das funções, métodos e classes da biblioteca padrão que estamos usando desde o primeiro código que fizemos, como <code>std::cout</code>, <code>std::cin</code>, <code>std::string</code>, etc.</p>
<p>Os exercícios a seguir foram dimensionados para o uso da Técnica da Sequência de Fibonacci (1, 1, 2, 3,), como foi proposto para as seções anteriores.</p>
<p>Finalmente, todos os exercícios são para a criação de sistemas especialistas. O professor pode aproveitar este conjunto de exercícios para discutir com os alunos a importância de se criar sistemas especialistas.</p>
<p><strong>A2</strong>: Uma casa lotérica precisa de um sistema para calcular probabilidades e combinações para seus jogos. O sistema deve calcular quantas combinações existem para a Mega-Sena (<span class="math inline">\(6\)</span> números entre <span class="math inline">\(1\)</span> e <span class="math inline">\(60\)</span>), probabilidades de acertos parciais e outras operações matemáticas relacionadas. Desenvolva um programa que ofereça um menu com opções para calcular fatorial de um número, combinações <span class="math inline">\(C(n,r)\)</span>, permutações <span class="math inline">\(P(n,r)\)</span>, as probabilidades relacionadas com a Mega-Sena, e a chance de ganhar o prêmio principal de outras modalidades de loteria (Lotofácil, Quina, etc.). Conforme as especificações a seguir:</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><strong>Funções próprias</strong>: <code>calcularFatorial()</code>, <code>calcularCombinacao()</code>, <code>calcularPermutacao()</code></li>
<li><strong>Funções da biblioteca padrão</strong>: As funções que sejam necessárias para resolver o problema</li>
</ul>
<p><strong>Menu do sistema</strong>:</p>
<ol type="1">
<li>Calcular fatorial de um número;</li>
<li>Calcular combinação <span class="math inline">\(C(n,r)\)</span>;</li>
<li>Calcular permutação <span class="math inline">\(P(n,r)\)</span>;</li>
<li>Mega-Sena: probabilidades de acertos (sena, quina, quadra);</li>
<li>Outras loterias: Lotofácil (<span class="math inline">\(15\)</span> de <span class="math inline">\(25\)</span>), Quina (<span class="math inline">\(5\)</span> de <span class="math inline">\(80\)</span>), Dupla Sena (<span class="math inline">\(6\)</span> de <span class="math inline">\(50\)</span>);</li>
<li>Sair.</li>
</ol>
<p><strong>Entrada</strong>: Números para os cálculos conforme a opção escolhida</p>
<p><strong>Saída</strong>: Menu interativo com resultados dos cálculos matemáticos</p>
<p><strong>Operações específicas</strong>:</p>
<ul>
<li>Mega-Sena: <span class="math inline">\(C(60,6)\)</span> combinações totais, probabilidades de <span class="math inline">\(4\)</span>, <span class="math inline">\(5\)</span> e <span class="math inline">\(6\)</span> acertos;</li>
<li>Lotofácil: <span class="math inline">\(C(25,15)\)</span> para <span class="math inline">\(15\)</span> acertos;</li>
<li>Quina: <span class="math inline">\(C(80,5)\)</span> para <span class="math inline">\(5\)</span> acertos;</li>
<li>Dupla Sena: <span class="math inline">\(C(50,6)\)</span> para <span class="math inline">\(6\)</span> acertos em cada sorteio.</li>
</ul>
<p><strong>Solução</strong>:</p>
<p>Começamos com o pseudocódigo para o exercício:</p>
<pre class="shell"><code>ALGORITMO SistemaCasaLoterica

ENTRADA:
    opcao_menu, numeros: inteiro

SAÍDA:
    resultados_calculos: real

INÍCIO
    opcao ← 0
    
    ENQUANTO opcao ≠ 7 FAÇA
        
        // APRESENTAR MENU PRINCIPAL
        
        ESCREVER "=== SISTEMA CASA LOTÉRICA ==="
        ESCREVER "1. Calcular Fatorial"
        ESCREVER "2. Calcular Combinação C(n,r)"
        ESCREVER "3. Calcular Permutação P(n,r)"
        ESCREVER "4. Mega-Sena: Probabilidades Completas"
        ESCREVER "5. Outros Jogos de Loteria"
        ESCREVER "6. Simulação de Apostas"
        ESCREVER "7. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        // PROCESSAR OPÇÃO ESCOLHIDA
        SE opcao = 1 ENTÃO
            ESCREVER "Digite um número para calcular o fatorial:"
            LER n
            SE n &gt;= 0 ENTÃO
                resultado ← calcularFatorial(n)
                ESCREVER "Fatorial de", n, "=", resultado
            SENÃO
                ESCREVER "Erro: Número deve ser não-negativo"
            FIM SE
            
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite n (total de elementos):"
            LER n
            ESCREVER "Digite r (elementos escolhidos):"
            LER r
            SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO
                resultado ← calcularCombinacao(n, r)
                ESCREVER "C(", n, ",", r, ") =", resultado
            SENÃO
                ESCREVER "Erro: Parâmetros inválidos (n≥0, r≥0, r≤n)"
            FIM SE
            
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "Digite n (total de elementos):"
            LER n
            ESCREVER "Digite r (elementos escolhidos):"
            LER r
            SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO
                resultado ← calcularPermutacao(n, r)
                ESCREVER "P(", n, ",", r, ") =", resultado
            SENÃO
                ESCREVER "Erro: Parâmetros inválidos (n≥0, r≥0, r≤n)"
            FIM SE
            
        SENÃO SE opcao = 4 ENTÃO
            ESCREVER "=== MEGA-SENA: ANÁLISE COMPLETA ==="
            
            // Combinações totais possíveis
            total_combinacoes ← calcularCombinacao(60, 6)
            ESCREVER "Total de combinações possíveis:", total_combinacoes
            
            // Probabilidade de acertar 6 números (sena)
            prob_sena ← 1.0 / total_combinacoes
            ESCREVER "Sena (6 acertos):"
            ESCREVER "  Probabilidade:", prob_sena
            ESCREVER "  Chance: 1 em", total_combinacoes
            
            // Probabilidade de acertar 5 números (quina)
            comb_5_acertos ← calcularCombinacao(6, 5)
            comb_1_erro ← calcularCombinacao(54, 1)
            casos_quina ← comb_5_acertos * comb_1_erro
            prob_quina ← casos_quina / total_combinacoes
            chance_quina ← total_combinacoes / casos_quina
            ESCREVER "Quina (5 acertos):"
            ESCREVER "  Probabilidade:", prob_quina
            ESCREVER "  Chance: 1 em", chance_quina
            
            // Probabilidade de acertar 4 números (quadra)
            comb_4_acertos ← calcularCombinacao(6, 4)
            comb_2_erros ← calcularCombinacao(54, 2)
            casos_quadra ← comb_4_acertos * comb_2_erros
            prob_quadra ← casos_quadra / total_combinacoes
            chance_quadra ← total_combinacoes / casos_quadra
            ESCREVER "Quadra (4 acertos):"
            ESCREVER "  Probabilidade:", prob_quadra
            ESCREVER "  Chance: 1 em", chance_quadra
            
        SENÃO SE opcao = 5 ENTÃO
            ESCREVER "=== OUTROS JOGOS DE LOTERIA ==="
            ESCREVER "Escolha o jogo:"
            ESCREVER "1. Lotofácil (15 de 25)"
            ESCREVER "2. Quina (5 de 80)"
            ESCREVER "3. Dupla Sena (6 de 50, dois sorteios)"
            ESCREVER "4. Personalizado"
            LER jogo
            
            SE jogo = 1 ENTÃO
                // Lotofácil: 15 números de 25
                total_lotofacil ← calcularCombinacao(25, 15)
                prob_lotofacil ← 1.0 / total_lotofacil
                ESCREVER "Lotofácil - Combinações possíveis:", total_lotofacil
                ESCREVER "Probabilidade de 15 acertos:", prob_lotofacil
                
            SENÃO SE jogo = 2 ENTÃO
                // Quina: 5 números de 80
                total_quina ← calcularCombinacao(80, 5)
                prob_quina_jogo ← 1.0 / total_quina
                ESCREVER "Quina - Combinações possíveis:", total_quina
                ESCREVER "Probabilidade de 5 acertos:", prob_quina_jogo
                
            SENÃO SE jogo = 3 ENTÃO
                // Dupla Sena: 6 números de 50, dois sorteios
                total_dupla ← calcularCombinacao(50, 6)
                prob_um_sorteio ← 1.0 / total_dupla
                prob_qualquer_sorteio ← 2.0 * prob_um_sorteio
                ESCREVER "Dupla Sena - Combinações por sorteio:", total_dupla
                ESCREVER "Probabilidade em um sorteio:", prob_um_sorteio
                ESCREVER "Probabilidade em qualquer sorteio:", prob_qualquer_sorteio
                
            SENÃO SE jogo = 4 ENTÃO
                ESCREVER "Digite o total de números disponíveis:"
                LER total_numeros
                ESCREVER "Digite quantos números são sorteados:"
                LER numeros_sorteados
                SE total_numeros &gt;= numeros_sorteados E numeros_sorteados &gt; 0 ENTÃO
                    total_personalizado ← calcularCombinacao(total_numeros, numeros_sorteados)
                    prob_personalizado ← 1.0 / total_personalizado
                    ESCREVER "Combinações possíveis:", total_personalizado
                    ESCREVER "Probabilidade de acerto:", prob_personalizado
                SENÃO
                    ESCREVER "Parâmetros inválidos"
                FIM SE
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 6 ENTÃO
            ESCREVER "=== SIMULAÇÃO DE APOSTAS ==="
            ESCREVER "Digite o valor da aposta individual (R$):"
            LER valor_aposta
            ESCREVER "Digite o número de apostas:"
            LER num_apostas
            
            // Custo total
            custo_total ← valor_aposta * num_apostas
            ESCREVER "Custo total: R$", custo_total
            
            // Probabilidade de ganhar pelo menos uma vez usando pow()
            total_comb_mega ← calcularCombinacao(60, 6)
            prob_perder_uma ← (total_comb_mega - 1.0) / total_comb_mega
            prob_perder_todas ← pow(prob_perder_uma, num_apostas)
            prob_ganhar_pelo_menos_uma ← 1.0 - prob_perder_todas
            
            ESCREVER "Probabilidade de não ganhar:", prob_perder_todas
            ESCREVER "Probabilidade de ganhar pelo menos uma vez:", prob_ganhar_pelo_menos_uma
            
            // Estatísticas
            apostas_necessarias ← total_comb_mega
            custo_garantia ← apostas_necessarias * valor_aposta
            ESCREVER "Apostas necessárias para garantir vitória:", apostas_necessarias
            ESCREVER "Custo para garantir vitória: R$", custo_garantia
            
        SENÃO SE opcao = 7 ENTÃO
            ESCREVER "Encerrando sistema da casa lotérica..."
            
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE
        
        // Pausa para visualização
        SE opcao ≠ 7 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM

// FUNÇÃO: CALCULAR FATORIAL
FUNÇÃO calcularFatorial(n: inteiro): real
INÍCIO
    SE n &lt; 0 ENTÃO
        RETORNAR -1
    FIM SE
    
    SE n = 0 OU n = 1 ENTÃO
        RETORNAR 1
    FIM SE
    
    resultado ← 1.0
    PARA i DE 2 ATÉ n FAÇA
        resultado ← resultado * i
    FIM PARA
    
    RETORNAR resultado
FIM

// FUNÇÃO: CALCULAR COMBINAÇÃO C(n,r)
FUNÇÃO calcularCombinacao(n: inteiro, r: inteiro): real
INÍCIO
    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO
        RETORNAR -1
    FIM SE
    
    SE r = 0 OU r = n ENTÃO
        RETORNAR 1
    FIM SE
    
    // Otimização: C(n,r) = C(n,n-r)
    SE r &gt; n - r ENTÃO
        r ← n - r
    FIM SE
    
    // Cálculo iterativo para evitar overflow
    resultado ← 1.0
    PARA i DE 0 ATÉ r-1 FAÇA
        resultado ← resultado * (n - i)
        resultado ← resultado / (i + 1)
    FIM PARA
    
    RETORNAR resultado
FIM

// FUNÇÃO: CALCULAR PERMUTAÇÃO P(n,r)
FUNÇÃO calcularPermutacao(n: inteiro, r: inteiro): real
INÍCIO
    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO
        RETORNAR -1
    FIM SE
    
    SE r = 0 ENTÃO
        RETORNAR 1
    FIM SE
    
    // P(n,r) = n! / (n-r)! = n * (n-1) * ... * (n-r+1)
    resultado ← 1.0
    PARA i DE 0 ATÉ r-1 FAÇA
        resultado ← resultado * (n - i)
    FIM PARA
    
    RETORNAR resultado
FIM</code></pre>
<p>O código em C++23 para implementar o pseudocódigo acima pode ser encontrado no site GDB Online no link <a href="https://onlinegdb.com/ugIolKSuu">https://onlinegdb.com/ugIolKSuu</a>.</p>
<p>Finalmente, este exercício <strong>A2</strong> pode ser usado para introduzir outra abstração, <code>switch-case</code>. Sendo assim, o pseudocódigo será:</p>
<pre class="shell"><code>ALGORITMO SistemaCasaLoterica

ENTRADA:
    opcao_menu, numeros: inteiro

SAÍDA:
    resultados_calculos: real

INÍCIO
    opcao ← 0
    
    ENQUANTO opcao ≠ 6 FAÇA
        
        // APRESENTAR MENU PRINCIPAL
        ESCREVER "=== SISTEMA CASA LOTÉRICA ==="
        ESCREVER "1. Calcular fatorial de um número"
        ESCREVER "2. Calcular combinação C(n,r)"
        ESCREVER "3. Calcular permutação P(n,r)"
        ESCREVER "4. Mega-Sena: probabilidades de acertos"
        ESCREVER "5. Outras loterias"
        ESCREVER "6. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        // PROCESSAR OPÇÃO COM SWITCH-CASE
        ESCOLHA opcao FAÇA
            CASO 1:
                ESCREVER "Digite um número para calcular o fatorial:"
                LER n
                SE n &gt;= 0 ENTÃO
                    resultado ← calcularFatorial(n)
                    ESCREVER "Fatorial de", n, "=", resultado
                SENÃO
                    ESCREVER "Erro: Número deve ser não-negativo"
                FIM SE
                PARE
                
            CASO 2:
                ESCREVER "Digite n (total de elementos):"
                LER n
                ESCREVER "Digite r (elementos escolhidos):"
                LER r
                SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO
                    resultado ← calcularCombinacao(n, r)
                    ESCREVER "C(", n, ",", r, ") =", resultado
                SENÃO
                    ESCREVER "Erro: Parâmetros inválidos"
                FIM SE
                PARE
                
            CASO 3:
                ESCREVER "Digite n (total de elementos):"
                LER n
                ESCREVER "Digite r (elementos escolhidos):"
                LER r
                SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO
                    resultado ← calcularPermutacao(n, r)
                    ESCREVER "P(", n, ",", r, ") =", resultado
                SENÃO
                    ESCREVER "Erro: Parâmetros inválidos"
                FIM SE
                PARE
                
            CASO 4:
                ESCREVER "=== MEGA-SENA: PROBABILIDADES ==="
                
                // Combinações totais C(60,6)
                total_combinacoes ← calcularCombinacao(60, 6)
                ESCREVER "Total de combinações:", total_combinacoes
                
                // Sena (6 acertos)
                prob_sena ← 1.0 / total_combinacoes
                ESCREVER "Sena (6 acertos): 1 em", total_combinacoes
                
                // Quina (5 acertos): C(6,5) * C(54,1) / C(60,6)
                casos_quina ← calcularCombinacao(6, 5) * calcularCombinacao(54, 1)
                prob_quina ← casos_quina / total_combinacoes
                chance_quina ← total_combinacoes / casos_quina
                ESCREVER "Quina (5 acertos): 1 em", chance_quina
                
                // Quadra (4 acertos): C(6,4) * C(54,2) / C(60,6)
                casos_quadra ← calcularCombinacao(6, 4) * calcularCombinacao(54, 2)
                prob_quadra ← casos_quadra / total_combinacoes
                chance_quadra ← total_combinacoes / casos_quadra
                ESCREVER "Quadra (4 acertos): 1 em", chance_quadra
                PARE
                
            CASO 5:
                ESCREVER "=== OUTRAS LOTERIAS ==="
                ESCREVER "1. Lotofácil (15 de 25)"
                ESCREVER "2. Quina (5 de 80)"
                ESCREVER "3. Dupla Sena (6 de 50)"
                ESCREVER "Escolha:"
                LER subloteria
                
                ESCOLHA subloteria FAÇA
                    CASO 1:
                        total_lotofacil ← calcularCombinacao(25, 15)
                        ESCREVER "Lotofácil - Combinações:", total_lotofacil
                        ESCREVER "Chance de ganhar: 1 em", total_lotofacil
                        PARE
                        
                    CASO 2:
                        total_quina ← calcularCombinacao(80, 5)
                        ESCREVER "Quina - Combinações:", total_quina
                        ESCREVER "Chance de ganhar: 1 em", total_quina
                        PARE
                        
                    CASO 3:
                        total_dupla ← calcularCombinacao(50, 6)
                        ESCREVER "Dupla Sena - Combinações por sorteio:", total_dupla
                        ESCREVER "Chance por sorteio: 1 em", total_dupla
                        PARE
                        
                    PADRÃO:
                        ESCREVER "Opção inválida"
                        PARE
                FIM ESCOLHA
                PARE
                
            CASO 6:
                ESCREVER "Encerrando sistema..."
                PARE
                
            PADRÃO:
                ESCREVER "Opção inválida! Tente novamente."
                PARE
        FIM ESCOLHA
        
        // Pausa para visualização
        SE opcao ≠ 6 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM

// FUNÇÃO: CALCULAR FATORIAL
FUNÇÃO calcularFatorial(n: inteiro): real
INÍCIO
    SE n &lt; 0 ENTÃO
        RETORNAR -1
    FIM SE
    
    SE n = 0 OU n = 1 ENTÃO
        RETORNAR 1
    FIM SE
    
    resultado ← 1.0
    PARA i DE 2 ATÉ n FAÇA
        resultado ← resultado * i
    FIM PARA
    
    RETORNAR resultado
FIM

// FUNÇÃO: CALCULAR COMBINAÇÃO C(n,r)
FUNÇÃO calcularCombinacao(n: inteiro, r: inteiro): real
INÍCIO
    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO
        RETORNAR -1
    FIM SE
    
    SE r = 0 OU r = n ENTÃO
        RETORNAR 1
    FIM SE
    
    // Otimização: C(n,r) = C(n,n-r)
    SE r &gt; n - r ENTÃO
        r ← n - r
    FIM SE
    
    // Cálculo iterativo para evitar overflow
    resultado ← 1.0
    PARA i DE 0 ATÉ r-1 FAÇA
        resultado ← resultado * (n - i)
        resultado ← resultado / (i + 1)
    FIM PARA
    
    RETORNAR resultado
FIM

// FUNÇÃO: CALCULAR PERMUTAÇÃO P(n,r)
FUNÇÃO calcularPermutacao(n: inteiro, r: inteiro): real
INÍCIO
    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO
        RETORNAR -1
    FIM SE
    
    SE r = 0 ENTÃO
        RETORNAR 1
    FIM SE
    
    // P(n,r) = n! / (n-r)!
    resultado ← 1.0
    PARA i DE 0 ATÉ r-1 FAÇA
        resultado ← resultado * (n - i)
    FIM PARA
    
    RETORNAR resultado
FIM</code></pre>
<p>Neste caso, #### Código C++23 O código para implementar o pseudocódigo com <code>switch-case</code> está disponível no site GDB Online no link <a href="https://onlinegdb.com/WED1nNGeV">https://onlinegdb.com/WED1nNGeV</a>.</p>
<p><strong>B2</strong>: um banco precisa de um sistema para orientar clientes sobre investimentos. O sistema deve calcular rendimentos de aplicações em renda fixa, determinar quanto tempo leva para duplicar um investimento e validar se os dados inseridos pelo cliente estão corretos. Crie um programa que calcule o montante final de um investimento com juros compostos, determine em quantos anos o capital dobra de valor e valide se as entradas do usuário são positivas e realistas.</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><strong>Funções próprias</strong>: <code>calcularJuroComposto()</code>, <code>tempoParaDobrar()</code>, <code>validarEntrada()</code></li>
<li><strong>Funções padrão</strong>: <code>pow()</code>, <code>log()</code></li>
</ul>
<p><strong>Entrada</strong>: Capital inicial, taxa de juros anual, período de investimento <strong>Saída</strong>: Montante final, tempo para dobrar o capital, alertas de validação</p>
<p><strong>Solução</strong>:</p>
<p>Neste caso, podemos representar o probleam como:</p>
<pre class="shell"><code>ALGORITMO SistemaBancarioInvestimentos

ENTRADA:
    capital_inicial, taxa_juros, periodo: real

SAÍDA:
    montante_final, tempo_dobrar, alertas: real

INÍCIO
    opcao ← 0
    
    ENQUANTO opcao ≠ 5 FAÇA
        
        // APRESENTAR MENU PRINCIPAL
        
        ESCREVER "=== SISTEMA BANCÁRIO DE INVESTIMENTOS ==="
        ESCREVER "1. Calcular montante final (juros compostos)"
        ESCREVER "2. Calcular tempo para dobrar o capital"
        ESCREVER "3. Validar dados de entrada"
        ESCREVER "4. Sistema completo de análise"
        ESCREVER "5. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        
        // PROCESSAR OPÇÃO ESCOLHIDA
        
        SE opcao = 1 ENTÃO
            ESCREVER "=== CÁLCULO DE MONTANTE FINAL ==="
            ESCREVER "Digite o capital inicial (R$):"
            LER capital_inicial
            ESCREVER "Digite a taxa de juros anual (%):"
            LER taxa_juros
            ESCREVER "Digite o período em anos:"
            LER periodo
            
            // Validar entradas
            validacao ← validarEntrada(capital_inicial, taxa_juros, periodo)
            
            SE validacao = VERDADEIRO ENTÃO
                montante ← calcularJuroComposto(capital_inicial, taxa_juros, periodo)
                rendimento ← montante - capital_inicial
                ESCREVER "Capital inicial: R$", capital_inicial
                ESCREVER "Montante final: R$", montante
                ESCREVER "Rendimento: R$", rendimento
                porcentagem_ganho ← (rendimento / capital_inicial) * 100
                ESCREVER "Ganho percentual:", porcentagem_ganho, "%"
            SENÃO
                ESCREVER "Dados inválidos! Verifique os valores inseridos."
            FIM SE
            
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "=== TEMPO PARA DOBRAR O CAPITAL ==="
            ESCREVER "Digite a taxa de juros anual (%):"
            LER taxa_juros
            
            SE taxa_juros &gt; 0 E taxa_juros &lt;= 50 ENTÃO
                tempo ← tempoParaDobrar(taxa_juros)
                ESCREVER "Com taxa de", taxa_juros, "% ao ano:"
                ESCREVER "Tempo para dobrar o capital:", tempo, "anos"
                
                // Regra prática dos 72
                regra_72 ← 72 / taxa_juros
                ESCREVER "Regra dos 72 (aproximação):", regra_72, "anos"
                diferenca ← abs(tempo - regra_72)
                ESCREVER "Diferença entre cálculo exato e regra dos 72:", diferenca, "anos"
            SENÃO
                ESCREVER "Taxa de juros inválida! Use valores entre 0.1% e 50%."
            FIM SE
            
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "=== VALIDAÇÃO DE DADOS ==="
            ESCREVER "Digite o capital inicial (R$):"
            LER capital_inicial
            ESCREVER "Digite a taxa de juros anual (%):"
            LER taxa_juros
            ESCREVER "Digite o período em anos:"
            LER periodo
            
            validacao ← validarEntrada(capital_inicial, taxa_juros, periodo)
            
            SE validacao = VERDADEIRO ENTÃO
                ESCREVER "✓ Todos os dados estão válidos!"
                ESCREVER "✓ Capital inicial: R$", capital_inicial, "(válido)"
                ESCREVER "✓ Taxa de juros:", taxa_juros, "% ao ano (válida)"
                ESCREVER "✓ Período:", periodo, "anos (válido)"
            SENÃO
                ESCREVER "✗ Dados inválidos detectados!"
                
                // Validações específicas
                SE capital_inicial &lt;= 0 ENTÃO
                    ESCREVER "✗ Capital inicial deve ser positivo"
                FIM SE
                
                SE taxa_juros &lt;= 0 OU taxa_juros &gt; 50 ENTÃO
                    ESCREVER "✗ Taxa de juros deve estar entre 0.1% e 50%"
                FIM SE
                
                SE periodo &lt;= 0 OU periodo &gt; 100 ENTÃO
                    ESCREVER "✗ Período deve estar entre 1 e 100 anos"
                FIM SE
            FIM SE
            
        SENÃO SE opcao = 4 ENTÃO
            ESCREVER "=== SISTEMA COMPLETO DE ANÁLISE ==="
            ESCREVER "Digite o capital inicial (R$):"
            LER capital_inicial
            ESCREVER "Digite a taxa de juros anual (%):"
            LER taxa_juros
            ESCREVER "Digite o período em anos:"
            LER periodo
            
            // Validar todas as entradas
            validacao ← validarEntrada(capital_inicial, taxa_juros, periodo)
            
            SE validacao = VERDADEIRO ENTÃO
                ESCREVER "\n--- ANÁLISE COMPLETA DO INVESTIMENTO ---"
                
                // Cálculo do montante final
                montante ← calcularJuroComposto(capital_inicial, taxa_juros, periodo)
                rendimento ← montante - capital_inicial
                
                ESCREVER "💰 RESULTADOS FINANCEIROS:"
                ESCREVER "Capital inicial: R$", capital_inicial
                ESCREVER "Montante final: R$", montante
                ESCREVER "Rendimento total: R$", rendimento
                porcentagem_ganho ← (rendimento / capital_inicial) * 100
                ESCREVER "Ganho percentual total:", porcentagem_ganho, "%"
                
                // Tempo para dobrar
                tempo_dobrar ← tempoParaDobrar(taxa_juros)
                ESCREVER "\n⏰ TEMPO PARA DOBRAR:"
                ESCREVER "Tempo para dobrar o capital:", tempo_dobrar, "anos"
                
                // Análise comparativa
                SE periodo &gt;= tempo_dobrar ENTÃO
                    multiplicador ← periodo / tempo_dobrar
                    ESCREVER "Em", periodo, "anos, o capital dobrará", multiplicador, "vezes"
                SENÃO
                    faltam_anos ← tempo_dobrar - periodo
                    ESCREVER "Faltam", faltam_anos, "anos para o capital dobrar"
                FIM SE
                
                // Recomendações
                ESCREVER "\n📊 RECOMENDAÇÕES:"
                SE taxa_juros &lt; 5 ENTÃO
                    ESCREVER "⚠️  Taxa baixa - considere outras opções de investimento"
                SENÃO SE taxa_juros &gt; 20 ENTÃO
                    ESCREVER "⚠️  Taxa alta - verifique os riscos envolvidos"
                SENÃO
                    ESCREVER "✓ Taxa dentro de padrões normais do mercado"
                FIM SE
                
                SE periodo &lt; 2 ENTÃO
                    ESCREVER "💡 Investimento de curto prazo - juros compostos têm menor impacto"
                SENÃO SE periodo &gt; 10 ENTÃO
                    ESCREVER "💡 Investimento de longo prazo - excelente para juros compostos"
                FIM SE
                
            SENÃO
                ESCREVER "❌ Não é possível realizar a análise com dados inválidos."
                ESCREVER "Por favor, corrija os valores e tente novamente."
            FIM SE
            
        SENÃO SE opcao = 5 ENTÃO
            ESCREVER "Encerrando sistema bancário..."
            
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE
        
        // Pausa para visualização
        SE opcao ≠ 5 ENTÃO
            ESCREVER "\nPressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM


// FUNÇÃO: CALCULAR JUROS COMPOSTOS
// M = C * (1 + i)^t

FUNÇÃO calcularJuroComposto(capital: real, taxa: real, tempo: real): real
INÍCIO
    // Converter taxa percentual para decimal
    taxa_decimal ← taxa / 100
    
    // Calcular (1 + taxa)
    base ← 1 + taxa_decimal
    
    // Calcular (1 + taxa)^tempo usando pow()
    fator_multiplicacao ← pow(base, tempo)
    
    // Calcular montante final
    montante ← capital * fator_multiplicacao
    
    RETORNAR montante
FIM


// FUNÇÃO: TEMPO PARA DOBRAR O CAPITAL
// 2 = (1 + i)^t  =&gt;  t = log(2) / log(1 + i)

FUNÇÃO tempoParaDobrar(taxa: real): real
INÍCIO
    // Converter taxa percentual para decimal
    taxa_decimal ← taxa / 100
    
    // Calcular (1 + taxa)
    base ← 1 + taxa_decimal
    
    // Calcular log(2) / log(1 + taxa) usando log()
    numerador ← log(2)
    denominador ← log(base)
    tempo ← numerador / denominador
    
    RETORNAR tempo
FIM

// FUNÇÃO: VALIDAR ENTRADA
FUNÇÃO validarEntrada(capital: real, taxa: real, periodo: real): logico
INÍCIO
    // Validar capital inicial
    SE capital &lt;= 0 ENTÃO
        RETORNAR FALSO
    FIM SE
    
    // Validar taxa de juros (entre 0.1% e 50%)
    SE taxa &lt;= 0 OU taxa &gt; 50 ENTÃO
        RETORNAR FALSO
    FIM SE
    
    // Validar período (entre 1 e 100 anos)
    SE periodo &lt;= 0 OU periodo &gt; 100 ENTÃO
        RETORNAR FALSO
    FIM SE
    
    // Se chegou até aqui, todos os dados são válidos
    RETORNAR VERDADEIRO
FIM</code></pre>
<p>Resultando no código em C++23 que pode ser encontrado no GDB Online no link <a href="https://onlinegdb.com/Ha2Sfflfd">https://onlinegdb.com/Ha2Sfflfd</a>.</p>
<p><strong>C2</strong>: Um escritório de engenharia civil precisa de um sistema para calcular parâmetros de rampas de acessibilidade e escadas. O sistema deve determinar ângulos de inclinação, comprimentos necessários e validar se os projetos atendem às normas de acessibilidade. Crie um programa que calcule ângulos de rampas, comprimentos de escadas e valide conformidade com normas brasileiras de acessibilidade.</p>
<p><strong>Funções a implementar</strong>: - <strong>Funções próprias</strong>: <code>calcularAnguloRampa()</code>, <code>calcularComprimentoEscada()</code>, <code>validarAcessibilidade()</code> - <strong>Funções padrão</strong>: <code>sin()</code>, <code>cos()</code>, <code>tan()</code>, <code>atan()</code>, <code>asin()</code></p>
<p><strong>Entrada</strong>: Altura, comprimento, ângulo (conforme tipo de cálculo) <strong>Saída</strong>: Ângulos em graus, comprimentos em metros, status de conformidade com normas</p>
<p><strong>Cálculos específicos</strong>: - Rampa de acessibilidade: máximo 8.33% de inclinação (NBR 9050) - Escadas: ângulo ideal entre 25° e 35° - Conversão radianos/graus automática</p>
<p><strong>Solução</strong>:</p>
<p>Começando pelo pseudocódigo, teremos:</p>
<pre class="shell"><code>ALGORITMO SistemaEngenhariaCivil

ENTRADA:
    altura, comprimento, angulo: real

SAÍDA:
    angulos, comprimentos, status_conformidade: real

INÍCIO
    opcao ← 0
    PI ← 3.14159265359
    
    ENQUANTO opcao ≠ 6 FAÇA
        
        // APRESENTAR MENU PRINCIPAL
        ESCREVER "=== SISTEMA DE ENGENHARIA CIVIL ==="
        ESCREVER "1. Calcular ângulo de rampa de acessibilidade"
        ESCREVER "2. Calcular comprimento de escada"
        ESCREVER "3. Validar conformidade com normas"
        ESCREVER "4. Análise completa de projeto"
        ESCREVER "5. Conversões trigonométricas"
        ESCREVER "6. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        
        // PROCESSAR OPÇÃO ESCOLHIDA
        SE opcao = 1 ENTÃO
            ESCREVER "=== CÁLCULO DE ÂNGULO DE RAMPA ==="
            ESCREVER "Digite a altura da rampa (metros):"
            LER altura
            ESCREVER "Digite o comprimento da rampa (metros):"
            LER comprimento
            
            SE altura &gt; 0 E comprimento &gt; 0 ENTÃO
                angulo ← calcularAnguloRampa(altura, comprimento)
                inclinacao_percentual ← (altura / comprimento) * 100
                
                ESCREVER "Altura:", altura, "m"
                ESCREVER "Comprimento:", comprimento, "m"
                ESCREVER "Ângulo de inclinação:", angulo, "graus"
                ESCREVER "Inclinação percentual:", inclinacao_percentual, "%"
                
                // Verificar conformidade NBR 9050
                SE inclinacao_percentual &lt;= 8.33 ENTÃO
                    ESCREVER "✓ Rampa CONFORME com NBR 9050 (máx. 8.33%)"
                SENÃO
                    ESCREVER "✗ Rampa NÃO CONFORME com NBR 9050"
                    comprimento_minimo ← altura / 0.0833
                    ESCREVER "Comprimento mínimo necessário:", comprimento_minimo, "m"
                FIM SE
            SENÃO
                ESCREVER "Erro: Altura e comprimento devem ser positivos"
            FIM SE
            
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "=== CÁLCULO DE COMPRIMENTO DE ESCADA ==="
            ESCREVER "Digite a altura total da escada (metros):"
            LER altura
            ESCREVER "Digite o ângulo desejado (graus):"
            LER angulo
            
            SE altura &gt; 0 E angulo &gt; 0 E angulo &lt; 90 ENTÃO
                comprimento ← calcularComprimentoEscada(altura, angulo)
                projecao_horizontal ← altura / tan(angulo * PI / 180)
                
                ESCREVER "Altura total:", altura, "m"
                ESCREVER "Ângulo:", angulo, "graus"
                ESCREVER "Comprimento da escada:", comprimento, "m"
                ESCREVER "Projeção horizontal:", projecao_horizontal, "m"
                
                // Verificar ângulo ideal para escadas
                SE angulo &gt;= 25 E angulo &lt;= 35 ENTÃO
                    ESCREVER "✓ Ângulo IDEAL para escadas (25° a 35°)"
                SENÃO SE angulo &lt; 25 ENTÃO
                    ESCREVER "⚠️ Ângulo muito baixo - escada pode ser desconfortável"
                SENÃO
                    ESCREVER "⚠️ Ângulo muito alto - escada pode ser perigosa"
                FIM SE
            SENÃO
                ESCREVER "Erro: Altura deve ser positiva e ângulo entre 0° e 90°"
            FIM SE
            
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "=== VALIDAÇÃO DE CONFORMIDADE ==="
            ESCREVER "Escolha o tipo de estrutura:"
            ESCREVER "1. Rampa de acessibilidade"
            ESCREVER "2. Escada"
            LER tipo_estrutura
            
            SE tipo_estrutura = 1 ENTÃO
                ESCREVER "Digite a altura da rampa (metros):"
                LER altura
                ESCREVER "Digite o comprimento da rampa (metros):"
                LER comprimento
                
                SE altura &gt; 0 E comprimento &gt; 0 ENTÃO
                    conformidade ← validarAcessibilidade(altura, comprimento, 1)
                    
                    SE conformidade = VERDADEIRO ENTÃO
                        ESCREVER "✓ Rampa APROVADA - Conforme NBR 9050"
                    SENÃO
                        ESCREVER "✗ Rampa REPROVADA - Não conforme NBR 9050"
                    FIM SE
                SENÃO
                    ESCREVER "Dados inválidos"
                FIM SE
                
            SENÃO SE tipo_estrutura = 2 ENTÃO
                ESCREVER "Digite o ângulo da escada (graus):"
                LER angulo
                
                SE angulo &gt; 0 E angulo &lt; 90 ENTÃO
                    conformidade ← validarAcessibilidade(0, 0, angulo)
                    
                    SE conformidade = VERDADEIRO ENTÃO
                        ESCREVER "✓ Escada APROVADA - Ângulo adequado"
                    SENÃO
                        ESCREVER "✗ Escada com ângulo inadequado"
                    FIM SE
                SENÃO
                    ESCREVER "Ângulo inválido"
                FIM SE
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 4 ENTÃO
            ESCREVER "=== ANÁLISE COMPLETA DE PROJETO ==="
            ESCREVER "Digite a altura (metros):"
            LER altura
            ESCREVER "Digite o comprimento disponível (metros):"
            LER comprimento_disponivel
            
            SE altura &gt; 0 E comprimento_disponivel &gt; 0 ENTÃO
                ESCREVER "\n--- ANÁLISE PARA RAMPA ---"
                
                // Análise de rampa
                angulo_rampa ← calcularAnguloRampa(altura, comprimento_disponivel)
                inclinacao ← (altura / comprimento_disponivel) * 100
                
                ESCREVER "Ângulo atual:", angulo_rampa, "graus"
                ESCREVER "Inclinação:", inclinacao, "%"
                
                comprimento_ideal_rampa ← altura / 0.0833
                ESCREVER "Comprimento ideal para rampa:", comprimento_ideal_rampa, "m"
                
                SE comprimento_disponivel &gt;= comprimento_ideal_rampa ENTÃO
                    ESCREVER "✓ Espaço SUFICIENTE para rampa conforme"
                SENÃO
                    ESCREVER "✗ Espaço INSUFICIENTE para rampa conforme"
                FIM SE
                
                ESCREVER "\n--- ANÁLISE PARA ESCADA ---"
                
                // Análise de escada com ângulos ideais
                angulo_30 ← 30.0
                comprimento_escada_30 ← calcularComprimentoEscada(altura, angulo_30)
                projecao_30 ← altura / tan(angulo_30 * PI / 180)
                
                ESCREVER "Com ângulo de 30° (ideal):"
                ESCREVER "Comprimento da escada:", comprimento_escada_30, "m"
                ESCREVER "Projeção horizontal:", projecao_30, "m"
                
                SE projecao_30 &lt;= comprimento_disponivel ENTÃO
                    ESCREVER "✓ Espaço SUFICIENTE para escada ideal"
                SENÃO
                    ESCREVER "✗ Espaço INSUFICIENTE para escada ideal"
                    
                    // Calcular ângulo máximo possível
                    angulo_maximo ← atan(altura / comprimento_disponivel) * 180 / PI
                    ESCREVER "Ângulo máximo possível:", angulo_maximo, "graus"
                FIM SE
                
                ESCREVER "\n--- RECOMENDAÇÃO FINAL ---"
                SE comprimento_disponivel &gt;= comprimento_ideal_rampa ENTÃO
                    ESCREVER "💡 RECOMENDAÇÃO: Construir rampa de acessibilidade"
                SENÃO SE projecao_30 &lt;= comprimento_disponivel ENTÃO
                    ESCREVER "💡 RECOMENDAÇÃO: Construir escada com ângulo ideal"
                SENÃO
                    ESCREVER "💡 RECOMENDAÇÃO: Reavaliar projeto - espaço limitado"
                FIM SE
            SENÃO
                ESCREVER "Dados inválidos"
            FIM SE
            
        SENÃO SE opcao = 5 ENTÃO
            ESCREVER "=== CONVERSÕES TRIGONOMÉTRICAS ==="
            ESCREVER "1. Graus para radianos"
            ESCREVER "2. Radianos para graus"
            ESCREVER "3. Calcular seno/cosseno/tangente"
            LER tipo_conversao
            
            SE tipo_conversao = 1 ENTÃO
                ESCREVER "Digite o ângulo em graus:"
                LER angulo_graus
                radianos ← angulo_graus * PI / 180
                ESCREVER angulo_graus, "° =", radianos, "radianos"
                
            SENÃO SE tipo_conversao = 2 ENTÃO
                ESCREVER "Digite o ângulo em radianos:"
                LER angulo_radianos
                graus ← angulo_radianos * 180 / PI
                ESCREVER angulo_radianos, "rad =", graus, "°"
                
            SENÃO SE tipo_conversao = 3 ENTÃO
                ESCREVER "Digite o ângulo em graus:"
                LER angulo_graus
                radianos ← angulo_graus * PI / 180
                
                seno ← sin(radianos)
                cosseno ← cos(radianos)
                tangente ← tan(radianos)
                
                ESCREVER "Para ângulo de", angulo_graus, "°:"
                ESCREVER "Seno:", seno
                ESCREVER "Cosseno:", cosseno
                ESCREVER "Tangente:", tangente
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 6 ENTÃO
            ESCREVER "Encerrando sistema de engenharia..."
            
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE
        
        // Pausa para visualização
        SE opcao ≠ 6 ENTÃO
            ESCREVER "\nPressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM

// FUNÇÃO: CALCULAR ÂNGULO DE RAMPA
FUNÇÃO calcularAnguloRampa(altura: real, comprimento: real): real
INÍCIO
    PI ← 3.14159265359
    
    // Calcular ângulo usando arcotangente
    angulo_radianos ← atan(altura / comprimento)
    
    // Converter para graus
    angulo_graus ← angulo_radianos * 180 / PI
    
    RETORNAR angulo_graus
FIM


// FUNÇÃO: CALCULAR COMPRIMENTO DE ESCADA
FUNÇÃO calcularComprimentoEscada(altura: real, angulo_graus: real): real
INÍCIO
    PI ← 3.14159265359
    
    // Converter ângulo para radianos
    angulo_radianos ← angulo_graus * PI / 180
    
    // Calcular comprimento usando seno: altura = comprimento * sen(ângulo)
    comprimento ← altura / sin(angulo_radianos)
    
    RETORNAR comprimento
FIM


// FUNÇÃO: VALIDAR ACESSIBILIDADE
FUNÇÃO validarAcessibilidade(altura: real, comprimento: real, angulo: real): logico
INÍCIO
    // Se ângulo foi fornecido, é validação de escada
    SE angulo &gt; 0 ENTÃO
        // Validar escada: ângulo ideal entre 25° e 35°
        SE angulo &gt;= 25 E angulo &lt;= 35 ENTÃO
            RETORNAR VERDADEIRO
        SENÃO
            RETORNAR FALSO
        FIM SE
    SENÃO
        // Validar rampa: inclinação máxima 8.33% (NBR 9050)
        inclinacao_percentual ← (altura / comprimento) * 100
        
        SE inclinacao_percentual &lt;= 8.33 ENTÃO
            RETORNAR VERDADEIRO
        SENÃO
            RETORNAR FALSO
        FIM SE
    FIM SE
FIM</code></pre>
<p>O que código para implementação do pseudocódigo acima está disponível no GDB OnLine no endereço <a href="https://onlinegdb.com/_2rc38V9b">https://onlinegdb.com/_2rc38V9b</a>.</p>
<p><strong>D2</strong>: Uma empresa de engenharia acústica precisa de um sistema para calcular níveis de ruído e intensidade sonora em projetos urbanos. O sistema deve converter intensidades para decibéis, calcular atenuação sonora com a distância e somar níveis de ruído de múltiplas fontes. Crie um programa que processe medições acústicas para controle de poluição sonora.</p>
<p><strong>Funções a implementar</strong>: - <strong>Funções próprias</strong>: <code>calcularDecibeis()</code>, <code>calcularAtenuacao()</code>, <code>somarRuidos()</code> - <strong>Funções padrão</strong>: <code>log10()</code>, <code>exp()</code>, <code>pow()</code>, <code>log()</code></p>
<p><strong>Entrada</strong>: Intensidade sonora, distância, múltiplos níveis de ruído <strong>Saída</strong>: Níveis em dB, atenuação por distância, soma logarítmica de ruídos</p>
<p><strong>Cálculos específicos</strong>: - Conversão I→dB: dB = 10×log₁₀(I/I₀) - Atenuação: dB_dist = dB_orig - 20×log₁₀(d₂/d₁) - Soma de ruídos: dB_total = 10×log₁₀(∑10^(dBᵢ/10))</p>
<p><strong>Solução</strong>:</p>
<p>Começando pelo pseudocódigo, teremos:</p>
<pre class="shell"><code>ALGORITMO SistemaEngenhariaAcustica

ENTRADA:
    intensidade, distancia, niveis_db: real

SAÍDA:
    decibeis, atenuacao, soma_ruidos: real

INÍCIO
    opcao ← 0
    I0 ← 1e-12  // Intensidade de referência: 10⁻¹² W/m²
    
    ENQUANTO opcao ≠ 6 FAÇA
        
        // APRESENTAR MENU PRINCIPAL
        
        ESCREVER "=== SISTEMA DE ENGENHARIA ACÚSTICA ==="
        ESCREVER "1. Converter intensidade para decibéis"
        ESCREVER "2. Calcular atenuação sonora com distância"
        ESCREVER "3. Somar níveis de ruído (múltiplas fontes)"
        ESCREVER "4. Análise completa de projeto acústico"
        ESCREVER "5. Conversões logarítmicas"
        ESCREVER "6. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        
        // PROCESSAR OPÇÃO ESCOLHIDA
        
        SE opcao = 1 ENTÃO
            ESCREVER "=== CONVERSÃO INTENSIDADE → DECIBÉIS ==="
            ESCREVER "Digite a intensidade sonora (W/m²):"
            LER intensidade
            
            SE intensidade &gt; 0 ENTÃO
                decibeis ← calcularDecibeis(intensidade)
                
                ESCREVER "Intensidade:", intensidade, "W/m²"
                ESCREVER "Nível sonoro:", decibeis, "dB"
                
                // Classificação do ruído
                SE decibeis &lt;= 30 ENTÃO
                    ESCREVER "Classificação: Muito silencioso"
                SENÃO SE decibeis &lt;= 50 ENTÃO
                    ESCREVER "Classificação: Silencioso"
                SENÃO SE decibeis &lt;= 70 ENTÃO
                    ESCREVER "Classificação: Moderado"
                SENÃO SE decibeis &lt;= 85 ENTÃO
                    ESCREVER "Classificação: Alto"
                SENÃO SE decibeis &lt;= 100 ENTÃO
                    ESCREVER "Classificação: Muito alto"
                SENÃO
                    ESCREVER "Classificação: Perigoso - usar proteção auditiva"
                FIM SE
                
                // Limites legais
                SE decibeis &gt; 55 ENTÃO
                    ESCREVER "⚠️ Acima do limite diurno residencial (55 dB)"
                FIM SE
                
                SE decibeis &gt; 70 ENTÃO
                    ESCREVER "⚠️ Acima do limite comercial (70 dB)"
                FIM SE
                
            SENÃO
                ESCREVER "Erro: Intensidade deve ser positiva"
            FIM SE
            
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "=== CÁLCULO DE ATENUAÇÃO SONORA ==="
            ESCREVER "Digite o nível inicial (dB):"
            LER nivel_inicial
            ESCREVER "Digite a distância inicial (metros):"
            LER distancia_inicial
            ESCREVER "Digite a nova distância (metros):"
            LER distancia_final
            
            SE nivel_inicial &gt;= 0 E distancia_inicial &gt; 0 E distancia_final &gt; 0 ENTÃO
                nivel_final ← calcularAtenuacao(nivel_inicial, distancia_inicial, distancia_final)
                perda_sonora ← nivel_inicial - nivel_final
                
                ESCREVER "Nível inicial:", nivel_inicial, "dB a", distancia_inicial, "m"
                ESCREVER "Nível final:", nivel_final, "dB a", distancia_final, "m"
                ESCREVER "Perda sonora:", perda_sonora, "dB"
                
                // Análise da atenuação
                SE distancia_final &gt; distancia_inicial ENTÃO
                    fator_distancia ← distancia_final / distancia_inicial
                    ESCREVER "Distância aumentou", fator_distancia, "vezes"
                    ESCREVER "Redução esperada: ~", 20 * log10(fator_distancia), "dB"
                SENÃO
                    ESCREVER "⚠️ Som ficou mais alto - distância diminuiu"
                FIM SE
                
            SENÃO
                ESCREVER "Erro: Dados devem ser positivos e válidos"
            FIM SE
            
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "=== SOMA DE NÍVEIS DE RUÍDO ==="
            ESCREVER "Quantas fontes de ruído você quer somar (2-5):"
            LER num_fontes
            
            SE num_fontes &gt;= 2 E num_fontes &lt;= 5 ENTÃO
                nivel1 ← 0
                nivel2 ← 0
                nivel3 ← 0
                nivel4 ← 0
                nivel5 ← 0
                
                ESCREVER "Digite o nível da fonte 1 (dB):"
                LER nivel1
                ESCREVER "Digite o nível da fonte 2 (dB):"
                LER nivel2
                
                SE num_fontes &gt;= 3 ENTÃO
                    ESCREVER "Digite o nível da fonte 3 (dB):"
                    LER nivel3
                FIM SE
                
                SE num_fontes &gt;= 4 ENTÃO
                    ESCREVER "Digite o nível da fonte 4 (dB):"
                    LER nivel4
                FIM SE
                
                SE num_fontes = 5 ENTÃO
                    ESCREVER "Digite o nível da fonte 5 (dB):"
                    LER nivel5
                FIM SE
                
                // Calcular soma logarítmica
                nivel_total ← somarRuidos(nivel1, nivel2, nivel3, nivel4, nivel5, num_fontes)
                
                ESCREVER "Fontes individuais:"
                ESCREVER "Fonte 1:", nivel1, "dB"
                ESCREVER "Fonte 2:", nivel2, "dB"
                
                SE num_fontes &gt;= 3 ENTÃO
                    ESCREVER "Fonte 3:", nivel3, "dB"
                FIM SE
                SE num_fontes &gt;= 4 ENTÃO
                    ESCREVER "Fonte 4:", nivel4, "dB"
                FIM SE
                SE num_fontes = 5 ENTÃO
                    ESCREVER "Fonte 5:", nivel5, "dB"
                FIM SE
                
                ESCREVER "Nível total combinado:", nivel_total, "dB"
                
                // Análise da soma
                maior_individual ← nivel1
                SE nivel2 &gt; maior_individual ENTÃO maior_individual ← nivel2 FIM SE
                SE nivel3 &gt; maior_individual ENTÃO maior_individual ← nivel3 FIM SE
                SE nivel4 &gt; maior_individual ENTÃO maior_individual ← nivel4 FIM SE
                SE nivel5 &gt; maior_individual ENTÃO maior_individual ← nivel5 FIM SE
                
                incremento ← nivel_total - maior_individual
                ESCREVER "Incremento sobre a fonte mais alta:", incremento, "dB"
                
            SENÃO
                ESCREVER "Número de fontes deve estar entre 2 e 5"
            FIM SE
            
        SENÃO SE opcao = 4 ENTÃO
            ESCREVER "=== ANÁLISE COMPLETA DE PROJETO ACÚSTICO ==="
            ESCREVER "Digite a intensidade da fonte principal (W/m²):"
            LER intensidade_principal
            ESCREVER "Digite a distância da medição (metros):"
            LER distancia_medicao
            ESCREVER "Digite o nível de ruído de fundo (dB):"
            LER ruido_fundo
            
            SE intensidade_principal &gt; 0 E distancia_medicao &gt; 0 E ruido_fundo &gt;= 0 ENTÃO
                ESCREVER "\n--- ANÁLISE DA FONTE PRINCIPAL ---"
                
                // Converter intensidade para dB
                nivel_fonte ← calcularDecibeis(intensidade_principal)
                ESCREVER "Nível da fonte:", nivel_fonte, "dB"
                
                // Calcular níveis em diferentes distâncias
                distancia_1m ← 1.0
                nivel_1m ← calcularAtenuacao(nivel_fonte, distancia_medicao, distancia_1m)
                
                distancia_10m ← 10.0
                nivel_10m ← calcularAtenuacao(nivel_fonte, distancia_medicao, distancia_10m)
                
                distancia_100m ← 100.0
                nivel_100m ← calcularAtenuacao(nivel_fonte, distancia_medicao, distancia_100m)
                
                ESCREVER "Nível a 1m:", nivel_1m, "dB"
                ESCREVER "Nível a 10m:", nivel_10m, "dB"
                ESCREVER "Nível a 100m:", nivel_100m, "dB"
                
                ESCREVER "\n--- ANÁLISE COM RUÍDO DE FUNDO ---"
                
                // Combinar fonte principal com ruído de fundo
                nivel_combinado ← somarRuidos(nivel_fonte, ruido_fundo, 0, 0, 0, 2)
                ESCREVER "Nível combinado (fonte + fundo):", nivel_combinado, "dB"
                
                mascaramento ← nivel_combinado - ruido_fundo
                ESCREVER "Efeito de mascaramento:", mascaramento, "dB"
                
                ESCREVER "\n--- CONFORMIDADE LEGAL ---"
                
                // Verificar limites legais (CONAMA 001/90)
                SE nivel_combinado &lt;= 55 ENTÃO
                    ESCREVER "✓ Conforme para área residencial (≤55 dB diurno)"
                SENÃO
                    ESCREVER "✗ Não conforme para área residencial"
                    reducao_necessaria ← nivel_combinado - 55
                    ESCREVER "Redução necessária:", reducao_necessaria, "dB"
                FIM SE
                
                SE nivel_combinado &lt;= 70 ENTÃO
                    ESCREVER "✓ Conforme para área comercial (≤70 dB)"
                SENÃO
                    ESCREVER "✗ Não conforme para área comercial"
                FIM SE
                
                ESCREVER "\n--- RECOMENDAÇÕES ---"
                
                SE nivel_combinado &gt; 85 ENTÃO
                    ESCREVER "🔊 Recomenda-se proteção auditiva"
                FIM SE
                
                SE nivel_combinado &gt; 55 ENTÃO
                    distancia_segura ← distancia_medicao * pow(10, (nivel_combinado - 55) / 20)
                    ESCREVER "💡 Distância mínima para 55dB:", distancia_segura, "m"
                FIM SE
                
            SENÃO
                ESCREVER "Dados inválidos"
            FIM SE
            
        SENÃO SE opcao = 5 ENTÃO
            ESCREVER "=== CONVERSÕES LOGARÍTMICAS ==="
            ESCREVER "1. dB para intensidade (W/m²)"
            ESCREVER "2. Intensidade para dB"
            ESCREVER "3. Calcular log₁₀ e logaritmo natural"
            LER tipo_conversao
            
            SE tipo_conversao = 1 ENTÃO
                ESCREVER "Digite o nível em dB:"
                LER decibeis
                
                // Converter dB para intensidade: I = I₀ × 10^(dB/10)
                intensidade ← I0 * pow(10, decibeis / 10)
                ESCREVER decibeis, "dB =", intensidade, "W/m²"
                
            SENÃO SE tipo_conversao = 2 ENTÃO
                ESCREVER "Digite a intensidade (W/m²):"
                LER intensidade
                
                SE intensidade &gt; 0 ENTÃO
                    decibeis ← calcularDecibeis(intensidade)
                    ESCREVER intensidade, "W/m² =", decibeis, "dB"
                SENÃO
                    ESCREVER "Intensidade deve ser positiva"
                FIM SE
                
            SENÃO SE tipo_conversao = 3 ENTÃO
                ESCREVER "Digite um número positivo:"
                LER numero
                
                SE numero &gt; 0 ENTÃO
                    log_10 ← log10(numero)
                    log_natural ← log(numero)
                    
                    ESCREVER "Número:", numero
                    ESCREVER "log₁₀(", numero, ") =", log_10
                    ESCREVER "ln(", numero, ") =", log_natural
                SENÃO
                    ESCREVER "Número deve ser positivo"
                FIM SE
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 6 ENTÃO
            ESCREVER "Encerrando sistema de engenharia acústica..."
            
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE
        
        // Pausa para visualização
        SE opcao ≠ 6 ENTÃO
            ESCREVER "\nPressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM

// FUNÇÃO: CALCULAR DECIBÉIS
// dB = 10 × log₁₀(I/I₀)
FUNÇÃO calcularDecibeis(intensidade: real): real
INÍCIO
    I0 ← 1e-12  // Intensidade de referência: 10⁻¹² W/m²
    
    // Calcular razão I/I₀
    razao ← intensidade / I0
    
    // Calcular dB = 10 × log₁₀(I/I₀)
    decibeis ← 10 * log10(razao)
    
    RETORNAR decibeis
FIM


// FUNÇÃO: CALCULAR ATENUAÇÃO
// dB_dist = dB_orig - 20 × log₁₀(d₂/d₁)
FUNÇÃO calcularAtenuacao(nivel_inicial: real, dist_inicial: real, dist_final: real): real
INÍCIO
    // Calcular razão das distâncias
    razao_distancias ← dist_final / dist_inicial
    
    // Calcular perda por distância: 20 × log₁₀(d₂/d₁)
    perda ← 20 * log10(razao_distancias)
    
    // Nível final = nível inicial - perda
    nivel_final ← nivel_inicial - perda
    
    RETORNAR nivel_final
FIM

// FUNÇÃO: SOMAR RUÍDOS
// dB_total = 10 × log₁₀(∑10^(dBᵢ/10))
FUNÇÃO somarRuidos(db1: real, db2: real, db3: real, db4: real, db5: real, num_fontes: inteiro): real
INÍCIO
    // Converter cada dB para intensidade relativa
    intensidade1 ← pow(10, db1 / 10)
    intensidade2 ← pow(10, db2 / 10)
    
    soma_intensidades ← intensidade1 + intensidade2
    
    SE num_fontes &gt;= 3 ENTÃO
        intensidade3 ← pow(10, db3 / 10)
        soma_intensidades ← soma_intensidades + intensidade3
    FIM SE
    
    SE num_fontes &gt;= 4 ENTÃO
        intensidade4 ← pow(10, db4 / 10)
        soma_intensidades ← soma_intensidades + intensidade4
    FIM SE
    
    SE num_fontes = 5 ENTÃO
        intensidade5 ← pow(10, db5 / 10)
        soma_intensidades ← soma_intensidades + intensidade5
    FIM SE
    
    // Converter soma de volta para dB
    db_total ← 10 * log10(soma_intensidades)
    
    RETORNAR db_total
FIM</code></pre>
<p>Cujo código C++ correspondente está disponivel no GDB OnLine no link <a href="https://onlinegdb.com/-ACks3zVu">https://onlinegdb.com/-ACks3zVu</a>.</p>
<p><strong>E2</strong>: Uma empresa de engenharia elétrica precisa de um sistema para calcular parâmetros de circuitos trifásicos, eficiência energética e análise de harmônicos. O sistema deve determinar as potências ativa (<span class="math inline">\(P\)</span>), reativa (<span class="math inline">\(Q\)</span>) e aparente (<span class="math inline">\(S\)</span>), calcular o fator de potência (<span class="math inline">\(FP\)</span>) e analisar a distorção harmônica total (<span class="math inline">\(THD\)</span>) em instalações industriais.</p>
<p><strong>Funções a implementar</strong>: - <strong>Funções próprias</strong>: <code>calcularPotenciaTrifasica()</code>, <code>calcularFatorPotencia()</code>, <code>analisarHarmonicos()</code> - <strong>Funções padrão</strong>: <code>sqrt()</code>, <code>pow()</code>, <code>sin()</code>, <code>cos()</code>, <code>atan()</code>, <code>fabs()</code></p>
<p><strong>Entrada</strong>: Tensão (<span class="math inline">\(V\)</span>), corrente (<span class="math inline">\(I\)</span>), ângulo de fase (<span class="math inline">\(\phi\)</span>), e as amplitudes das frequências harmônicas (<span class="math inline">\(H_h\)</span>). <strong>Saída</strong>: Potências (<span class="math inline">\(P\)</span> em kW, <span class="math inline">\(Q\)</span> em kVAr, <span class="math inline">\(S\)</span> em kVA), fator de potência (<span class="math inline">\(FP\)</span>), <span class="math inline">\(THD\%\)</span>, e status de conformidade com normas.</p>
<p><strong>Cálculos específicos</strong>: - Potência ativa (<span class="math inline">\(P\)</span>): <span class="math display">\[P = \sqrt{3} \cdot V \cdot I \cdot \cos(\phi)\]</span></p>
<ul>
<li><p>Potência reativa (<span class="math inline">\(Q\)</span>): <span class="math display">\[Q = \sqrt{3} \cdot V \cdot I \cdot \sin(\phi)\]</span></p></li>
<li><p>Fator de Potência (<span class="math inline">\(FP\)</span>): <span class="math display">\[FP = \cos(\phi)\]</span></p></li>
<li><p>Distorção Harmônica Total (<span class="math inline">\(THD\)</span>): <span class="math display">\[THD = \frac{\sqrt{\sum_{h=2}^{n} H_h^2}}{H_1} \times 100\%\]</span></p></li>
</ul>
<p><strong>Solução</strong>:</p>
<p>Começando pelo pseudocódigo.</p>
<pre class="shell"><code>ALGORITMO SistemaEngenhariaEletrica

ENTRADA:
    tensao, corrente, angulo_fase, harmonicos: real

SAÍDA:
    potencias, fator_potencia, thd, conformidade: real

INÍCIO
    opcao ← 0
    PI ← 3.14159265359
    
    ENQUANTO opcao ≠ 6 FAÇA
        
        // BLOCO: APRESENTAR MENU PRINCIPAL
        ESCREVER "=== SISTEMA DE ENGENHARIA ELÉTRICA ==="
        ESCREVER "1. Calcular potências trifásicas"
        ESCREVER "2. Calcular fator de potência"
        ESCREVER "3. Analisar distorção harmônica (THD)"
        ESCREVER "4. Análise completa do sistema elétrico"
        ESCREVER "5. Conversões e utilidades elétricas"
        ESCREVER "6. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        
        // BLOCO: PROCESSAR OPÇÃO ESCOLHIDA
        SE opcao = 1 ENTÃO
            ESCREVER "=== CÁLCULO DE POTÊNCIAS TRIFÁSICAS ==="
            ESCREVER "Digite a tensão de linha (V):"
            LER tensao
            ESCREVER "Digite a corrente de linha (A):"
            LER corrente
            ESCREVER "Digite o ângulo de fase (graus):"
            LER angulo_graus
            
            SE tensao &gt; 0 E corrente &gt; 0 ENTÃO
                potencia_ativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 1)
                potencia_reativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 2)
                potencia_aparente ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 3)
                
                ESCREVER "Tensão de linha:", tensao, "V"
                ESCREVER "Corrente de linha:", corrente, "A"
                ESCREVER "Ângulo de fase:", angulo_graus, "°"
                ESCREVER "Potência ativa (P):", potencia_ativa, "kW"
                ESCREVER "Potência reativa (Q):", potencia_reativa, "kVAr"
                ESCREVER "Potência aparente (S):", potencia_aparente, "kVA"
                
                // Classificação do sistema
                SE potencia_ativa &lt; 100 ENTÃO
                    ESCREVER "Classificação: Sistema de baixa potência"
                SENÃO SE potencia_ativa &lt; 1000 ENTÃO
                    ESCREVER "Classificação: Sistema de média potência"
                SENÃO
                    ESCREVER "Classificação: Sistema de alta potência"
                FIM SE
                
            SENÃO
                ESCREVER "Erro: Tensão e corrente devem ser positivas"
            FIM SE
            
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "=== CÁLCULO DE FATOR DE POTÊNCIA ==="
            ESCREVER "Digite a potência ativa (kW):"
            LER potencia_ativa
            ESCREVER "Digite a potência aparente (kVA):"
            LER potencia_aparente
            
            SE potencia_ativa &gt; 0 E potencia_aparente &gt; 0 E potencia_ativa &lt;= potencia_aparente ENTÃO
                fator_potencia ← calcularFatorPotencia(potencia_ativa, potencia_aparente)
                angulo_phi ← acos(fator_potencia) * 180 / PI
                
                ESCREVER "Potência ativa:", potencia_ativa, "kW"
                ESCREVER "Potência aparente:", potencia_aparente, "kVA"
                ESCREVER "Fator de potência:", fator_potencia
                ESCREVER "Ângulo φ:", angulo_phi, "°"
                
                // Análise da qualidade
                SE fator_potencia &gt;= 0.95 ENTÃO
                    ESCREVER "✓ Excelente - Sem necessidade de correção"
                SENÃO SE fator_potencia &gt;= 0.85 ENTÃO
                    ESCREVER "⚠️ Bom - Considerar correção para grandes cargas"
                SENÃO SE fator_potencia &gt;= 0.75 ENTÃO
                    ESCREVER "⚠️ Regular - Recomenda-se correção"
                SENÃO
                    ESCREVER "✗ Ruim - Correção urgente necessária"
                FIM SE
                
                // Cálculo de capacitores para correção
                SE fator_potencia &lt; 0.95 ENTÃO
                    potencia_reativa_atual ← potencia_ativa * tan(acos(fator_potencia))
                    potencia_reativa_desejada ← potencia_ativa * tan(acos(0.95))
                    capacitores_necessarios ← potencia_reativa_atual - potencia_reativa_desejada
                    ESCREVER "Capacitores necessários para FP=0.95:", fabs(capacitores_necessarios), "kVAr"
                FIM SE
                
            SENÃO
                ESCREVER "Erro: Dados inválidos (P deve ser ≤ S)"
            FIM SE
            
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "=== ANÁLISE DE DISTORÇÃO HARMÔNICA ==="
            ESCREVER "Digite a amplitude da fundamental (A ou V):"
            LER fundamental
            ESCREVER "Quantos harmônicos analisar (2-10):"
            LER num_harmonicos
            
            SE fundamental &gt; 0 E num_harmonicos &gt;= 2 E num_harmonicos &lt;= 10 ENTÃO
                thd ← analisarHarmonicos(fundamental, num_harmonicos)
                
                ESCREVER "Fundamental (H1):", fundamental
                ESCREVER "THD total:", thd, "%"
                
                // Classificação da qualidade
                SE thd &lt;= 5 ENTÃO
                    ESCREVER "✓ Excelente qualidade - THD ≤ 5%"
                SENÃO SE thd &lt;= 8 ENTÃO
                    ESCREVER "✓ Boa qualidade - THD ≤ 8%"
                SENÃO SE thd &lt;= 15 ENTÃO
                    ESCREVER "⚠️ Qualidade aceitável - THD ≤ 15%"
                SENÃO
                    ESCREVER "✗ Má qualidade - THD &gt; 15%"
                FIM SE
                
                // Normas brasileiras (PRODIST)
                SE thd &lt;= 10 ENTÃO
                    ESCREVER "✓ Conforme PRODIST - Módulo 8"
                SENÃO
                    ESCREVER "✗ Não conforme PRODIST - Módulo 8"
                FIM SE
                
            SENÃO
                ESCREVER "Erro: Dados inválidos"
            FIM SE
            
        SENÃO SE opcao = 4 ENTÃO
            ESCREVER "=== ANÁLISE COMPLETA DO SISTEMA ELÉTRICO ==="
            ESCREVER "Digite a tensão de linha (V):"
            LER tensao
            ESCREVER "Digite a corrente de linha (A):"
            LER corrente
            ESCREVER "Digite o ângulo de fase (graus):"
            LER angulo_graus
            ESCREVER "Digite a amplitude da fundamental para THD:"
            LER fundamental
            
            SE tensao &gt; 0 E corrente &gt; 0 E fundamental &gt; 0 ENTÃO
                ESCREVER "\n--- ANÁLISE DE POTÊNCIAS ---"
                
                // Cálculos de potência
                potencia_ativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 1)
                potencia_reativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 2)
                potencia_aparente ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 3)
                
                ESCREVER "Potência ativa:", potencia_ativa, "kW"
                ESCREVER "Potência reativa:", potencia_reativa, "kVAr"
                ESCREVER "Potência aparente:", potencia_aparente, "kVA"
                
                // Fator de potência
                fator_potencia ← calcularFatorPotencia(potencia_ativa, potencia_aparente)
                ESCREVER "Fator de potência:", fator_potencia
                
                ESCREVER "\n--- ANÁLISE DE QUALIDADE ---"
                
                // THD com 5 harmônicos por padrão
                thd ← analisarHarmonicos(fundamental, 5)
                ESCREVER "THD (5 harmônicos):", thd, "%"
                
                ESCREVER "\n--- ANÁLISE ECONÔMICA ---"
                
                // Custo estimado por perdas
                perda_percentual ← (1 - fator_potencia) * 100
                ESCREVER "Perdas por baixo FP:", perda_percentual, "%"
                
                // Estimativa de custo mensal (R$ 0,50/kWh)
                custo_kwh ← 0.50
                horas_mes ← 720  // 30 dias × 24 horas
                custo_mensal ← potencia_ativa * horas_mes * custo_kwh
                ESCREVER "Custo mensal estimado: R$", custo_mensal
                
                ESCREVER "\n--- CONFORMIDADE GERAL ---"
                
                problemas ← 0
                
                SE fator_potencia &lt; 0.85 ENTÃO
                    problemas ← problemas + 1
                    ESCREVER "⚠️ Fator de potência baixo"
                FIM SE
                
                SE thd &gt; 10 ENTÃO
                    problemas ← problemas + 1
                    ESCREVER "⚠️ THD acima do limite PRODIST"
                FIM SE
                
                SE problemas = 0 ENTÃO
                    ESCREVER "✓ Sistema em conformidade total"
                SENÃO
                    ESCREVER "✗ Sistema com", problemas, "não conformidade(s)"
                FIM SE
                
            SENÃO
                ESCREVER "Dados inválidos"
            FIM SE
            
        SENÃO SE opcao = 5 ENTÃO
            ESCREVER "=== CONVERSÕES E UTILIDADES ELÉTRICAS ==="
            ESCREVER "1. Converter potência (W ↔ HP ↔ CV)"
            ESCREVER "2. Calcular resistência por temperatura"
            ESCREVER "3. Converter ângulos (graus ↔ radianos)"
            LER tipo_conversao
            
            SE tipo_conversao = 1 ENTÃO
                ESCREVER "Digite a potência em Watts:"
                LER potencia_watts
                
                SE potencia_watts &gt; 0 ENTÃO
                    hp ← potencia_watts / 745.7
                    cv ← potencia_watts / 735.5
                    
                    ESCREVER potencia_watts, "W ="
                    ESCREVER "  ", hp, "HP"
                    ESCREVER "  ", cv, "CV"
                SENÃO
                    ESCREVER "Potência deve ser positiva"
                FIM SE
                
            SENÃO SE tipo_conversao = 2 ENTÃO
                ESCREVER "Digite a resistência a 20°C (Ω):"
                LER r20
                ESCREVER "Digite a temperatura atual (°C):"
                LER temperatura
                
                // Coeficiente de temperatura do cobre
                alfa ← 0.00393
                r_temp ← r20 * (1 + alfa * (temperatura - 20))
                
                ESCREVER "Resistência a", temperatura, "°C:", r_temp, "Ω"
                variacao ← ((r_temp - r20) / r20) * 100
                ESCREVER "Variação:", variacao, "%"
                
            SENÃO SE tipo_conversao = 3 ENTÃO
                ESCREVER "1. Graus para radianos"
                ESCREVER "2. Radianos para graus"
                LER direcao
                
                SE direcao = 1 ENTÃO
                    ESCREVER "Digite o ângulo em graus:"
                    LER graus
                    radianos ← graus * PI / 180
                    ESCREVER graus, "° =", radianos, "rad"
                SENÃO SE direcao = 2 ENTÃO
                    ESCREVER "Digite o ângulo em radianos:"
                    LER radianos
                    graus ← radianos * 180 / PI
                    ESCREVER radianos, "rad =", graus, "°"
                SENÃO
                    ESCREVER "Opção inválida"
                FIM SE
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 6 ENTÃO
            ESCREVER "Encerrando sistema de engenharia elétrica..."
            
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE
        
        // Pausa para visualização
        SE opcao ≠ 6 ENTÃO
            ESCREVER "\nPressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM

// FUNÇÃO: CALCULAR POTÊNCIA TRIFÁSICA
// P = √3 × V × I × cos(φ)  [tipo 1]
// Q = √3 × V × I × sin(φ)  [tipo 2]
// S = √3 × V × I           [tipo 3]

FUNÇÃO calcularPotenciaTrifasica(tensao: real, corrente: real, angulo_graus: real, tipo: inteiro): real
INÍCIO
    PI ← 3.14159265359
    
    // Converter ângulo para radianos
    angulo_rad ← angulo_graus * PI / 180
    
    // Fator √3
    raiz_tres ← sqrt(3)
    
    // Potência base em VA
    potencia_base ← raiz_tres * tensao * corrente
    
    SE tipo = 1 ENTÃO
        // Potência ativa (kW)
        potencia_ativa ← potencia_base * cos(angulo_rad)
        RETORNAR potencia_ativa / 1000
    SENÃO SE tipo = 2 ENTÃO
        // Potência reativa (kVAr)
        potencia_reativa ← potencia_base * sin(angulo_rad)
        RETORNAR potencia_reativa / 1000
    SENÃO SE tipo = 3 ENTÃO
        // Potência aparente (kVA)
        RETORNAR potencia_base / 1000
    SENÃO
        RETORNAR 0
    FIM SE
FIM

// FUNÇÃO: CALCULAR FATOR DE POTÊNCIA
// FP = P / S = cos(φ)
FUNÇÃO calcularFatorPotencia(potencia_ativa: real, potencia_aparente: real): real
INÍCIO
    SE potencia_aparente = 0 ENTÃO
        RETORNAR 0
    FIM SE
    
    fator_potencia ← potencia_ativa / potencia_aparente
    
    // Garantir que está entre 0 e 1
    SE fator_potencia &gt; 1 ENTÃO
        fator_potencia ← 1
    FIM SE
    
    SE fator_potencia &lt; 0 ENTÃO
        fator_potencia ← 0
    FIM SE
    
    RETORNAR fator_potencia
FIM

// FUNÇÃO: ANALISAR HARMÔNICOS
// THD = √(∑H²₂₋ₙ)/H₁ × 100%
FUNÇÃO analisarHarmonicos(fundamental: real, num_harmonicos: inteiro): real
INÍCIO
    soma_quadrados ← 0
    
    // Processar cada harmônico sequencialmente
    PARA i DE 2 ATÉ num_harmonicos FAÇA
        ESCREVER "Digite a amplitude do", i, "º harmônico:"
        LER harmonica
        
        SE harmonica &gt;= 0 ENTÃO
            quadrado ← pow(harmonica, 2)
            soma_quadrados ← soma_quadrados + quadrado
            
            // Mostrar porcentagem individual
            percentual_individual ← (harmonica / fundamental) * 100
            ESCREVER "H", i, ":", percentual_individual, "% da fundamental"
        FIM SE
    FIM PARA
    
    // Calcular THD
    SE fundamental &gt; 0 ENTÃO
        raiz_soma ← sqrt(soma_quadrados)
        thd ← (raiz_soma / fundamental) * 100
        RETORNAR thd
    SENÃO
        RETORNAR 0
    FIM SE
FIM</code></pre>
<p>O código C++ correspondente está disponível no GDB OnLine no link <a href="https://onlinegdb.com/hWZ7dfvok">https://onlinegdb.com/hWZ7dfvok</a>.</p>
<p><strong>F2</strong>: Um observatório astronômico precisa de um sistema para calcular posições de corpos celestes, distâncias interplanetárias e janelas de lançamento de missões espaciais. O sistema deve converter coordenadas celestes (e.g., de <span class="math inline">\((\alpha, \delta)\)</span> para <span class="math inline">\((x,y,z)\)</span>), calcular órbitas elípticas e determinar tempos de trânsito (<span class="math inline">\(t\)</span>) usando mecânica orbital.</p>
<p><strong>Funções a implementar</strong>: - <strong>Funções próprias</strong>: <code>calcularPosicaoOrbital()</code>, <code>determinarJanelaLancamento()</code>, <code>converterCoordenadas()</code> - <strong>Funções padrão</strong>: <code>sin()</code>, <code>cos()</code>, <code>tan()</code>, <code>asin()</code>, <code>acos()</code>, <code>sqrt()</code>, <code>pow()</code>, <code>fmod()</code></p>
<p><strong>Entrada</strong>: Elementos orbitais (e.g., <span class="math inline">\(a, e, i, \Omega, \omega, M\)</span>), coordenadas, tempo (<span class="math inline">\(t\)</span>), velocidade inicial (<span class="math inline">\(v_0\)</span>). <strong>Saída</strong>: Posições celestes, distâncias (<span class="math inline">\(d\)</span>) em UA, velocidade de escape (<span class="math inline">\(v_e\)</span>), delta-V (<span class="math inline">\(\Delta v\)</span>).</p>
<p><strong>Cálculos específicos</strong>: - Equação de Kepler (relaciona anomalia média <span class="math inline">\(M\)</span> com anomalia excêntrica <span class="math inline">\(E\)</span> e excentricidade <span class="math inline">\(e\)</span>): <span class="math display">\[M = E - e \sin(E)\]</span></p>
<ul>
<li>Velocidade orbital (Equação <em>vis-viva</em>), na qual de <span class="math inline">\(v\)</span> é a velocidade, <span class="math inline">\(\mu\)</span> o parâmetro gravitacional, <span class="math inline">\(r\)</span> a distância radial e <span class="math inline">\(a\)</span> o semi-eixo maior: <span class="math display">\[v = \sqrt{\mu \left( \frac{2}{r} - \frac{1}{a} \right)}\]</span></li>
</ul>
<p><strong>Solução</strong>:</p>
<p>Começando com o pseudocódigo:</p>
<pre class="shell"><code>ALGORITMO SistemaObservatorioAstronomico

ENTRADA:
    elementos_orbitais, coordenadas, tempo, velocidades: real

SAÍDA:
    posicoes_celestes, distancias_ua, velocidades_escape, delta_v: real

INÍCIO
    opcao ← 0
    PI ← 3.14159265359
    MU_SOL ← 1.32712440018e20  // μ solar em m³/s²
    UA ← 149597870700.0        // Unidade Astronômica em metros
    
    ENQUANTO opcao ≠ 6 FAÇA
        
        // BLOCO: APRESENTAR MENU PRINCIPAL
        ESCREVER "=== SISTEMA DE OBSERVATÓRIO ASTRONÔMICO ==="
        ESCREVER "1. Calcular posição orbital de corpo celeste"
        ESCREVER "2. Determinar janela de lançamento"
        ESCREVER "3. Converter coordenadas celestes"
        ESCREVER "4. Análise completa de missão espacial"
        ESCREVER "5. Conversões astronômicas"
        ESCREVER "6. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        // BLOCO: PROCESSAR OPÇÃO ESCOLHIDA
        SE opcao = 1 ENTÃO
            ESCREVER "=== CÁLCULO DE POSIÇÃO ORBITAL ==="
            ESCREVER "Digite o semi-eixo maior (UA):"
            LER semi_eixo_maior
            ESCREVER "Digite a excentricidade (0-1):"
            LER excentricidade
            ESCREVER "Digite a anomalia média (graus):"
            LER anomalia_media_graus
            ESCREVER "Digite a inclinação (graus):"
            LER inclinacao_graus
            
            SE semi_eixo_maior &gt; 0 E excentricidade &gt;= 0 E excentricidade &lt; 1 ENTÃO
                posicao_orbital ← calcularPosicaoOrbital(semi_eixo_maior, excentricidade, anomalia_media_graus, inclinacao_graus)
                
                ESCREVER "Semi-eixo maior:", semi_eixo_maior, "UA"
                ESCREVER "Excentricidade:", excentricidade
                ESCREVER "Anomalia média:", anomalia_media_graus, "graus"
                ESCREVER "Distância heliocêntrica:", posicao_orbital, "UA"
                
                // Calcular período orbital (3ª Lei de Kepler)
                periodo_anos ← sqrt(pow(semi_eixo_maior, 3))
                ESCREVER "Período orbital:", periodo_anos, "anos"
                
                // Velocidade no periélio e afélio
                r_perielio ← semi_eixo_maior * (1 - excentricidade)
                r_afelio ← semi_eixo_maior * (1 + excentricidade)
                
                // Converter UA para metros para cálculos de velocidade
                a_metros ← semi_eixo_maior * UA
                r_per_metros ← r_perielio * UA
                r_af_metros ← r_afelio * UA
                
                v_perielio ← sqrt(MU_SOL * (2 / r_per_metros - 1 / a_metros))
                v_afelio ← sqrt(MU_SOL * (2 / r_af_metros - 1 / a_metros))
                
                ESCREVER "Velocidade no periélio:", v_perielio / 1000, "km/s"
                ESCREVER "Velocidade no afélio:", v_afelio / 1000, "km/s"
                
            SENÃO
                ESCREVER "Erro: Parâmetros orbitais inválidos"
            FIM SE
            
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "=== DETERMINAÇÃO DE JANELA DE LANÇAMENTO ==="
            ESCREVER "Digite a distância Terra-destino atual (UA):"
            LER distancia_atual
            ESCREVER "Digite a velocidade relativa (km/s):"
            LER velocidade_relativa
            ESCREVER "Digite o período sinódico do destino (dias):"
            LER periodo_sinodico
            
            SE distancia_atual &gt; 0 E velocidade_relativa &gt; 0 E periodo_sinodico &gt; 0 ENTÃO
                janela_otima ← determinarJanelaLancamento(distancia_atual, velocidade_relativa, periodo_sinodico)
                
                ESCREVER "Distância atual:", distancia_atual, "UA"
                ESCREVER "Velocidade relativa:", velocidade_relativa, "km/s"
                ESCREVER "Tempo de viagem ótimo:", janela_otima, "dias"
                
                // Calcular delta-V necessário
                distancia_metros ← distancia_atual * UA
                delta_v_ms ← sqrt(2 * MU_SOL / distancia_metros)
                delta_v_escape_terra ← 11200  // m/s
                delta_v_total ← delta_v_ms + delta_v_escape_terra
                
                ESCREVER "Delta-V de escape:", delta_v_escape_terra / 1000, "km/s"
                ESCREVER "Delta-V interplanetário:", delta_v_ms / 1000, "km/s"
                ESCREVER "Delta-V total:", delta_v_total / 1000, "km/s"
                
                // Próxima janela
                proxima_janela ← janela_otima + periodo_sinodico
                ESCREVER "Próxima janela em:", proxima_janela, "dias"
                
            SENÃO
                ESCREVER "Erro: Parâmetros de missão inválidos"
            FIM SE
            
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "=== CONVERSÃO DE COORDENADAS CELESTES ==="
            ESCREVER "1. Equatoriais (α,δ) para cartesianas (x,y,z)"
            ESCREVER "2. Cartesianas (x,y,z) para equatoriais (α,δ)"
            ESCREVER "3. Eclípticas para equatoriais"
            LER tipo_conversao
            
            SE tipo_conversao = 1 ENTÃO
                ESCREVER "Digite a ascensão reta α (horas):"
                LER ascensao_reta_horas
                ESCREVER "Digite a declinação δ (graus):"
                LER declinacao_graus
                ESCREVER "Digite a distância (UA):"
                LER distancia
                
                SE distancia &gt; 0 ENTÃO
                    x_coord, y_coord, z_coord ← converterCoordenadas(ascensao_reta_horas, declinacao_graus, distancia, 1)
                    
                    ESCREVER "Coordenadas equatoriais:"
                    ESCREVER "α =", ascensao_reta_horas, "h"
                    ESCREVER "δ =", declinacao_graus, "°"
                    ESCREVER "Coordenadas cartesianas:"
                    ESCREVER "x =", x_coord, "UA"
                    ESCREVER "y =", y_coord, "UA"
                    ESCREVER "z =", z_coord, "UA"
                SENÃO
                    ESCREVER "Distância deve ser positiva"
                FIM SE
                
            SENÃO SE tipo_conversao = 2 ENTÃO
                ESCREVER "Digite a coordenada x (UA):"
                LER x_coord
                ESCREVER "Digite a coordenada y (UA):"
                LER y_coord
                ESCREVER "Digite a coordenada z (UA):"
                LER z_coord
                
                ascensao_reta, declinacao, distancia ← converterCoordenadas(x_coord, y_coord, z_coord, 2)
                
                ESCREVER "Coordenadas cartesianas:"
                ESCREVER "x =", x_coord, "UA"
                ESCREVER "y =", y_coord, "UA"
                ESCREVER "z =", z_coord, "UA"
                ESCREVER "Coordenadas equatoriais:"
                ESCREVER "α =", ascensao_reta, "h"
                ESCREVER "δ =", declinacao, "°"
                ESCREVER "Distância =", distancia, "UA"
                
            SENÃO SE tipo_conversao = 3 ENTÃO
                ESCREVER "Digite a longitude eclíptica (graus):"
                LER longitude_ecl
                ESCREVER "Digite a latitude eclíptica (graus):"
                LER latitude_ecl
                
                obliquidade ← 23.43929  // Obliquidade da eclíptica
                
                // Conversão eclíptica para equatorial
                long_rad ← longitude_ecl * PI / 180
                lat_rad ← latitude_ecl * PI / 180
                obl_rad ← obliquidade * PI / 180
                
                ascensao_reta_rad ← atan2(sin(long_rad) * cos(obl_rad) - tan(lat_rad) * sin(obl_rad), cos(long_rad))
                declinacao_rad ← asin(sin(lat_rad) * cos(obl_rad) + cos(lat_rad) * sin(obl_rad) * sin(long_rad))
                
                ascensao_reta_final ← ascensao_reta_rad * 180 / PI / 15  // Converter para horas
                declinacao_final ← declinacao_rad * 180 / PI
                
                SE ascensao_reta_final &lt; 0 ENTÃO
                    ascensao_reta_final ← ascensao_reta_final + 24
                FIM SE
                
                ESCREVER "Coordenadas eclípticas:"
                ESCREVER "Longitude =", longitude_ecl, "°"
                ESCREVER "Latitude =", latitude_ecl, "°"
                ESCREVER "Coordenadas equatoriais:"
                ESCREVER "α =", ascensao_reta_final, "h"
                ESCREVER "δ =", declinacao_final, "°"
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 4 ENTÃO
            ESCREVER "=== ANÁLISE COMPLETA DE MISSÃO ESPACIAL ==="
            ESCREVER "Digite o planeta de destino (1=Marte, 2=Júpiter, 3=Saturno):"
            LER planeta_destino
            ESCREVER "Digite a massa da espaçonave (kg):"
            LER massa_nave
            
            SE planeta_destino &gt;= 1 E planeta_destino &lt;= 3 E massa_nave &gt; 0 ENTÃO
                ESCREVER "\n--- PARÂMETROS DO DESTINO ---"
                
                // Definir parâmetros planetários
                SE planeta_destino = 1 ENTÃO
                    // Marte
                    nome_planeta ← "Marte"
                    semi_eixo_planeta ← 1.52
                    excentricidade_planeta ← 0.0934
                    periodo_planeta ← 687
                    massa_planeta ← 6.39e23
                    raio_planeta ← 3389.5e3
                    
                SENÃO SE planeta_destino = 2 ENTÃO
                    // Júpiter
                    nome_planeta ← "Júpiter"
                    semi_eixo_planeta ← 5.20
                    excentricidade_planeta ← 0.0489
                    periodo_planeta ← 4333
                    massa_planeta ← 1.898e27
                    raio_planeta ← 69911e3
                    
                SENÃO
                    // Saturno
                    nome_planeta ← "Saturno"
                    semi_eixo_planeta ← 9.54
                    excentricidade_planeta ← 0.0565
                    periodo_planeta ← 10759
                    massa_planeta ← 5.683e26
                    raio_planeta ← 58232e3
                FIM SE
                
                ESCREVER "Destino:", nome_planeta
                ESCREVER "Semi-eixo maior:", semi_eixo_planeta, "UA"
                ESCREVER "Período orbital:", periodo_planeta, "dias"
                
                ESCREVER "\n--- CÁLCULOS DE TRAJETÓRIA ---"
                
                // Calcular transferência de Hohmann
                semi_eixo_transferencia ← (1.0 + semi_eixo_planeta) / 2
                periodo_transferencia ← sqrt(pow(semi_eixo_transferencia, 3)) * 365.25
                tempo_viagem ← periodo_transferencia / 2
                
                ESCREVER "Semi-eixo da órbita de transferência:", semi_eixo_transferencia, "UA"
                ESCREVER "Tempo de viagem:", tempo_viagem, "dias"
                
                // Velocidades características
                v_terra_orbital ← 29.78  // km/s
                v_escape_terra ← 11.2    // km/s
                
                // Velocidade no afélio da transferência
                a_transf_metros ← semi_eixo_transferencia * UA
                r_destino_metros ← semi_eixo_planeta * UA
                v_chegada ← sqrt(MU_SOL * (2 / r_destino_metros - 1 / a_transf_metros))
                v_chegada_kms ← v_chegada / 1000
                
                ESCREVER "Velocidade de chegada:", v_chegada_kms, "km/s"
                
                // Delta-V total
                delta_v_partida ← v_escape_terra + 3.6  // 3.6 km/s para escape da órbita terrestre
                delta_v_chegada ← fabs(v_chegada_kms - semi_eixo_planeta * 6.28)  // Aproximação
                delta_v_missao ← delta_v_partida + delta_v_chegada
                
                ESCREVER "Delta-V de partida:", delta_v_partida, "km/s"
                ESCREVER "Delta-V de chegada:", delta_v_chegada, "km/s"
                ESCREVER "Delta-V total da missão:", delta_v_missao, "km/s"
                
                ESCREVER "\n--- ANÁLISE ENERGÉTICA ---"
                
                // Energia específica
                energia_especifica ← pow(delta_v_missao * 1000, 2) / 2  // J/kg
                energia_total ← energia_especifica * massa_nave / 1e9   // GJ
                
                ESCREVER "Energia específica:", energia_especifica / 1e6, "MJ/kg"
                ESCREVER "Energia total necessária:", energia_total, "GJ"
                
                // Período sinódico para próxima oportunidade
                periodo_sinodico_calc ← fabs(365.25 * periodo_planeta / (periodo_planeta - 365.25))
                ESCREVER "Próxima janela em:", periodo_sinodico_calc, "dias"
                
            SENÃO
                ESCREVER "Parâmetros inválidos"
            FIM SE
            
        SENÃO SE opcao = 5 ENTÃO
            ESCREVER "=== CONVERSÕES ASTRONÔMICAS ==="
            ESCREVER "1. Anos-luz para UA e parsecs"
            ESCREVER "2. Magnitudes estelares"
            ESCREVER "3. Tempos astronômicos"
            LER tipo_conversao_astro
            
            SE tipo_conversao_astro = 1 ENTÃO
                ESCREVER "Digite a distância em anos-luz:"
                LER anos_luz
                
                SE anos_luz &gt; 0 ENTÃO
                    ua_equiv ← anos_luz * 63241.1  // 1 ano-luz = 63241.1 UA
                    parsecs ← anos_luz / 3.26156   // 1 parsec = 3.26156 anos-luz
                    
                    ESCREVER anos_luz, "anos-luz ="
                    ESCREVER "  ", ua_equiv, "UA"
                    ESCREVER "  ", parsecs, "parsecs"
                SENÃO
                    ESCREVER "Distância deve ser positiva"
                FIM SE
                
            SENÃO SE tipo_conversao_astro = 2 ENTÃO
                ESCREVER "Digite a magnitude aparente:"
                LER mag_aparente
                ESCREVER "Digite a distância em parsecs:"
                LER distancia_pc
                
                SE distancia_pc &gt; 0 ENTÃO
                    modulo_distancia ← 5 * log10(distancia_pc) - 5
                    magnitude_absoluta ← mag_aparente - modulo_distancia
                    
                    ESCREVER "Magnitude aparente:", mag_aparente
                    ESCREVER "Módulo de distância:", modulo_distancia
                    ESCREVER "Magnitude absoluta:", magnitude_absoluta
                SENÃO
                    ESCREVER "Distância deve ser positiva"
                FIM SE
                
            SENÃO SE tipo_conversao_astro = 3 ENTÃO
                ESCREVER "Digite o tempo em dias julianos:"
                LER dias_julianos
                
                // Converter para anos desde J2000
                anos_j2000 ← (dias_julianos - 2451545.0) / 365.25
                
                ESCREVER "Dias julianos:", dias_julianos
                ESCREVER "Anos desde J2000.0:", anos_j2000
                
                // Equinócio vernal aproximado
                equinocio ← fmod(anos_j2000, 1.0) * 365.25
                SE equinocio &lt; 0 ENTÃO equinocio ← equinocio + 365.25 FIM SE
                
                ESCREVER "Dia do ano aproximado:", equinocio
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 6 ENTÃO
            ESCREVER "Encerrando sistema de observatório astronômico..."
            
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE
        
        // Pausa para visualização
        SE opcao ≠ 6 ENTÃO
            ESCREVER "\nPressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM

// FUNÇÃO: CALCULAR POSIÇÃO ORBITAL
// Resolve equação de Kepler: M = E - e*sin(E)
FUNÇÃO calcularPosicaoOrbital(semi_eixo: real, excentricidade: real, anomalia_media_graus: real, inclinacao_graus: real): real
INÍCIO
    PI ← 3.14159265359
    
    // Converter anomalia média para radianos
    anomalia_media_rad ← anomalia_media_graus * PI / 180
    
    // Resolver equação de Kepler iterativamente
    anomalia_excentrica ← anomalia_media_rad  // Estimativa inicial
    
    PARA i DE 1 ATÉ 10 FAÇA
        anomalia_excentrica_nova ← anomalia_media_rad + excentricidade * sin(anomalia_excentrica)
        
        // Verificar convergência
        diferenca ← fabs(anomalia_excentrica_nova - anomalia_excentrica)
        SE diferenca &lt; 1e-8 ENTÃO
            PARE
        FIM SE
        
        anomalia_excentrica ← anomalia_excentrica_nova
    FIM PARA
    
    // Calcular distância heliocêntrica
    distancia_heliocentrica ← semi_eixo * (1 - excentricidade * cos(anomalia_excentrica))
    
    RETORNAR distancia_heliocentrica
FIM

// FUNÇÃO: DETERMINAR JANELA DE LANÇAMENTO
// Calcula tempo ótimo considerando mecânica orbital
FUNÇÃO determinarJanelaLancamento(distancia_ua: real, velocidade_kms: real, periodo_sinodico: real): real
INÍCIO
    // Converter distância para metros e velocidade para m/s
    UA ← 149597870700.0
    distancia_metros ← distancia_ua * UA
    velocidade_ms ← velocidade_kms * 1000
    
    // Tempo de viagem básico
    tempo_viagem_segundos ← distancia_metros / velocidade_ms
    tempo_viagem_dias ← tempo_viagem_segundos / 86400  // segundos por dia
    
    // Ajuste para órbita elíptica (transferência de Hohmann)
    fator_correcao ← sqrt(2) * 0.5  // Aproximação para transferência elíptica
    tempo_otimizado ← tempo_viagem_dias * fator_correcao
    
    // Considerar período sinódico para janela
    SE tempo_otimizado &gt; periodo_sinodico / 2 ENTÃO
        tempo_otimizado ← periodo_sinodico / 2
    FIM SE
    
    RETORNAR tempo_otimizado
FIM

// FUNÇÃO: CONVERTER COORDENADAS
// Tipo 1: (α,δ,r) -&gt; (x,y,z)
// Tipo 2: (x,y,z) -&gt; (α,δ,r)
FUNÇÃO converterCoordenadas(param1: real, param2: real, param3: real, tipo: inteiro): real, real, real
INÍCIO
    PI ← 3.14159265359
    
    SE tipo = 1 ENTÃO
        // Equatoriais para cartesianas
        ascensao_reta_horas ← param1
        declinacao_graus ← param2
        distancia ← param3
        
        // Converter para radianos
        alpha_rad ← ascensao_reta_horas * 15 * PI / 180  // 15°/hora
        delta_rad ← declinacao_graus * PI / 180
        
        // Coordenadas cartesianas
        x ← distancia * cos(delta_rad) * cos(alpha_rad)
        y ← distancia * cos(delta_rad) * sin(alpha_rad)
        z ← distancia * sin(delta_rad)
        
        RETORNAR x, y, z
        
    SENÃO SE tipo = 2 ENTÃO
        // Cartesianas para equatoriais
        x ← param1
        y ← param2
        z ← param3
        
        // Distância
        distancia ← sqrt(x * x + y * y + z * z)
        
        // Ascensão reta
        alpha_rad ← atan2(y, x)
        SE alpha_rad &lt; 0 ENTÃO
            alpha_rad ← alpha_rad + 2 * PI
        FIM SE
        ascensao_reta_horas ← alpha_rad * 180 / PI / 15
        
        // Declinação
        delta_rad ← asin(z / distancia)
        declinacao_graus ← delta_rad * 180 / PI
        
        RETORNAR ascensao_reta_horas, declinacao_graus, distancia
        
    SENÃO
        RETORNAR 0, 0, 0
    FIM SE
FIM</code></pre>
<p>A partir desse pseudocódigo, podemos implementar o código em C++ que está disponível em <a href="https://onlinegdb.com/acME7DYnz">https://onlinegdb.com/acME7DYnz</a>.</p>
<p><strong>G2</strong>: Um laboratório farmacêutico precisa de um sistema para análise estatística de dados experimentais, cálculo de concentrações moleculares e modelagem farmacocinética. O sistema deve processar dados sequencialmente, calcular estatísticas descritivas (como média, <span class="math inline">\(\mu\)</span>, e desvio padrão, <span class="math inline">\(\sigma\)</span>) e determinar parâmetros de absorção/eliminação de medicamentos.</p>
<p><strong>Funções a implementar</strong>: - <strong>Funções próprias</strong>: <code>calcularEstatisticas()</code>, <code>modelarFarmacocinetica()</code>, <code>determinarBioequivalencia()</code> - <strong>Funções padrão</strong>: <code>exp()</code>, <code>log()</code>, <code>pow()</code>, <code>sqrt()</code>, <code>fabs()</code>, <code>floor()</code>, <code>ceil()</code></p>
<p><strong>Entrada</strong>: Concentrações sanguíneas sequenciais (<span class="math inline">\(C\)</span>), tempos de coleta (<span class="math inline">\(t\)</span>), doses administradas (<span class="math inline">\(Dose\)</span>). <strong>Saída</strong>: Média (<span class="math inline">\(\mu\)</span>), desvio padrão (<span class="math inline">\(\sigma\)</span>), meia-vida (<span class="math inline">\(t_{1/2}\)</span>), clearance (<span class="math inline">\(CL\)</span>), área sob a curva (<span class="math inline">\(AUC\)</span>), resultado de bioequivalência.</p>
<p><strong>Cálculos específicos</strong>:</p>
<ul>
<li><p>Modelo monocompartimental, no qual <span class="math inline">\(C(t)\)</span> é a concentração no tempo <span class="math inline">\(t\)</span>, <span class="math inline">\(C_0\)</span> é a concentração inicial e <span class="math inline">\(k\)</span> é a constante de eliminação: <span class="math display">\[C(t) = C_0 \cdot e^{-k \cdot t}\]</span></p></li>
<li><p>Área Sob a Curva (<span class="math inline">\(AUC\)</span>), calculada numericamente (e.g., pela regra dos trapézios): <span class="math display">\[AUC = \int_{0}^{\infty} C(t) \, dt\]</span></p></li>
<li><p>Clearance (<span class="math inline">\(CL\)</span>), ou depuração, que relaciona a dose com a área sob a curva: <span class="math display">\[CL = \frac{Dose}{AUC}\]</span></p></li>
<li><p>Estatísticas calculadas sequencialmente (sem o uso de arrays para armazenamento completo dos dados).</p></li>
</ul>
<p><strong>Solução</strong>:</p>
<p>Primeiro o pseudocódigo para a função de cálculo de estatísticas e farmacocinética:</p>
<pre class="shell"><code>ALGORITMO SistemaLaboratorioFarmaceutico

ENTRADA:
    concentracoes, tempos, doses: real

SAÍDA:
    media, desvio_padrao, meia_vida, clearance, auc, bioequivalencia: real

INÍCIO
    opcao ← 0
    
    ENQUANTO opcao ≠ 6 FAÇA
        
        // BLOCO: APRESENTAR MENU PRINCIPAL
        
        ESCREVER "=== SISTEMA DE LABORATÓRIO FARMACÊUTICO ==="
        ESCREVER "1. Calcular estatísticas descritivas"
        ESCREVER "2. Modelar farmacocinética"
        ESCREVER "3. Determinar bioequivalência"
        ESCREVER "4. Análise completa de medicamento"
        ESCREVER "5. Cálculos auxiliares"
        ESCREVER "6. Sair"
        ESCREVER "Escolha uma opção:"
        LER opcao
        
        
        // BLOCO: PROCESSAR OPÇÃO ESCOLHIDA
        
        SE opcao = 1 ENTÃO
            ESCREVER "=== CÁLCULO DE ESTATÍSTICAS DESCRITIVAS ==="
            ESCREVER "Quantos dados você tem (2-20):"
            LER num_dados
            
            SE num_dados &gt;= 2 E num_dados &lt;= 20 ENTÃO
                media, desvio_padrao ← calcularEstatisticas(num_dados)
                
                ESCREVER "Número de amostras:", num_dados
                ESCREVER "Média (μ):", media
                ESCREVER "Desvio padrão (σ):", desvio_padrao
                ESCREVER "Coeficiente de variação:", (desvio_padrao / media) * 100, "%"
                
                // Classificação da variabilidade
                cv ← (desvio_padrao / media) * 100
                SE cv &lt;= 5 ENTÃO
                    ESCREVER "Variabilidade: Muito baixa (excelente)"
                SENÃO SE cv &lt;= 10 ENTÃO
                    ESCREVER "Variabilidade: Baixa (boa)"
                SENÃO SE cv &lt;= 20 ENTÃO
                    ESCREVER "Variabilidade: Moderada (aceitável)"
                SENÃO
                    ESCREVER "Variabilidade: Alta (revisar protocolo)"
                FIM SE
                
            SENÃO
                ESCREVER "Número de dados deve estar entre 2 e 20"
            FIM SE
            
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "=== MODELAGEM FARMACOCINÉTICA ==="
            ESCREVER "Digite a concentração inicial C0 (mg/L):"
            LER c0
            ESCREVER "Digite a constante de eliminação k (/h):"
            LER k_eliminacao
            ESCREVER "Digite o tempo para análise (h):"
            LER tempo_analise
            ESCREVER "Digite a dose administrada (mg):"
            LER dose
            
            SE c0 &gt; 0 E k_eliminacao &gt; 0 E tempo_analise &gt; 0 E dose &gt; 0 ENTÃO
                concentracao_tempo, meia_vida, auc, clearance ← modelarFarmacocinetica(c0, k_eliminacao, tempo_analise, dose)
                
                ESCREVER "Concentração inicial C0:", c0, "mg/L"
                ESCREVER "Constante de eliminação k:", k_eliminacao, "/h"
                ESCREVER "Concentração em t =", tempo_analise, "h:", concentracao_tempo, "mg/L"
                ESCREVER "Meia-vida (t½):", meia_vida, "h"
                ESCREVER "AUC (0→∞):", auc, "mg⋅h/L"
                ESCREVER "Clearance (CL):", clearance, "L/h"
                
                // Análise da eliminação
                percentual_eliminado ← (1 - concentracao_tempo / c0) * 100
                ESCREVER "Percentual eliminado em", tempo_analise, "h:", percentual_eliminado, "%"
                
                // Tempo para concentração específica
                ESCREVER "Para atingir 10% da concentração inicial:"
                tempo_10_porcento ← -log(0.1) / k_eliminacao
                ESCREVER "Tempo necessário:", tempo_10_porcento, "h"
                
            SENÃO
                ESCREVER "Todos os valores devem ser positivos"
            FIM SE
            
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "=== DETERMINAÇÃO DE BIOEQUIVALÊNCIA ==="
            ESCREVER "Dados do medicamento de referência:"
            ESCREVER "Digite a AUC de referência (mg⋅h/L):"
            LER auc_referencia
            ESCREVER "Digite a Cmax de referência (mg/L):"
            LER cmax_referencia
            
            ESCREVER "Dados do medicamento teste:"
            ESCREVER "Digite a AUC do teste (mg⋅h/L):"
            LER auc_teste
            ESCREVER "Digite a Cmax do teste (mg/L):"
            LER cmax_teste
            
            SE auc_referencia &gt; 0 E cmax_referencia &gt; 0 E auc_teste &gt; 0 E cmax_teste &gt; 0 ENTÃO
                bioequivalencia ← determinarBioequivalencia(auc_referencia, cmax_referencia, auc_teste, cmax_teste)
                
                razao_auc ← auc_teste / auc_referencia
                razao_cmax ← cmax_teste / cmax_referencia
                
                ESCREVER "Medicamento de referência:"
                ESCREVER "  AUC:", auc_referencia, "mg⋅h/L"
                ESCREVER "  Cmax:", cmax_referencia, "mg/L"
                
                ESCREVER "Medicamento teste:"
                ESCREVER "  AUC:", auc_teste, "mg⋅h/L"
                ESCREVER "  Cmax:", cmax_teste, "mg/L"
                
                ESCREVER "Razão AUC (teste/referência):", razao_auc
                ESCREVER "Razão Cmax (teste/referência):", razao_cmax
                
                SE bioequivalencia = 1 ENTÃO
                    ESCREVER "Resultado: BIOEQUIVALENTES"
                    ESCREVER "Ambas as razões estão entre 0.80 e 1.25"
                SENÃO
                    ESCREVER "Resultado: NÃO BIOEQUIVALENTES"
                    SE razao_auc &lt; 0.8 OU razao_auc &gt; 1.25 ENTÃO
                        ESCREVER "AUC fora do intervalo 0.80-1.25"
                    FIM SE
                    SE razao_cmax &lt; 0.8 OU razao_cmax &gt; 1.25 ENTÃO
                        ESCREVER "Cmax fora do intervalo 0.80-1.25"
                    FIM SE
                FIM SE
                
            SENÃO
                ESCREVER "Todos os valores devem ser positivos"
            FIM SE
            
        SENÃO SE opcao = 4 ENTÃO
            ESCREVER "=== ANÁLISE COMPLETA DE MEDICAMENTO ==="
            ESCREVER "Quantas amostras de concentração foram coletadas (3-10):"
            LER num_amostras
            
            SE num_amostras &gt;= 3 E num_amostras &lt;= 10 ENTÃO
                ESCREVER "Digite a dose administrada (mg):"
                LER dose_total
                
                SE dose_total &gt; 0 ENTÃO
                    // Calcular estatísticas das concentrações
                    media_concentracao, dp_concentracao ← calcularEstatisticas(num_amostras)
                    
                    ESCREVER "Estimativa dos parâmetros farmacocinéticos:"
                    ESCREVER "Digite a concentração inicial estimada C0 (mg/L):"
                    LER c0_estimado
                    ESCREVER "Digite a constante de eliminação estimada k (/h):"
                    LER k_estimado
                    
                    SE c0_estimado &gt; 0 E k_estimado &gt; 0 ENTÃO
                        // Modelagem completa
                        concentracao_24h, meia_vida_calc, auc_calc, clearance_calc ← modelarFarmacocinetica(c0_estimado, k_estimado, 24, dose_total)
                        
                        ESCREVER "\n--- ESTATÍSTICAS DESCRITIVAS ---"
                        ESCREVER "Média das concentrações:", media_concentracao, "mg/L"
                        ESCREVER "Desvio padrão:", dp_concentracao, "mg/L"
                        cv_total ← (dp_concentracao / media_concentracao) * 100
                        ESCREVER "Coeficiente de variação:", cv_total, "%"
                        
                        ESCREVER "\n--- PARÂMETROS FARMACOCINÉTICOS ---"
                        ESCREVER "Concentração inicial (C0):", c0_estimado, "mg/L"
                        ESCREVER "Meia-vida (t½):", meia_vida_calc, "h"
                        ESCREVER "AUC (0→∞):", auc_calc, "mg⋅h/L"
                        ESCREVER "Clearance total:", clearance_calc, "L/h"
                        ESCREVER "Volume de distribuição:", dose_total / c0_estimado, "L"
                        
                        ESCREVER "\n--- PREDIÇÕES ---"
                        ESCREVER "Concentração em 24h:", concentracao_24h, "mg/L"
                        
                        // Tempo para diferentes frações
                        tempo_50_porcento ← meia_vida_calc
                        tempo_25_porcento ← 2 * meia_vida_calc
                        tempo_12_5_porcento ← 3 * meia_vida_calc
                        
                        ESCREVER "Tempo para 50% eliminação:", tempo_50_porcento, "h"
                        ESCREVER "Tempo para 75% eliminação:", tempo_25_porcento, "h"
                        ESCREVER "Tempo para 87.5% eliminação:", tempo_12_5_porcento, "h"
                        
                        ESCREVER "\n--- CLASSIFICAÇÃO FARMACOCINÉTICA ---"
                        
                        SE meia_vida_calc &lt; 6 ENTÃO
                            ESCREVER "Eliminação: Rápida (t½ &lt; 6h)"
                        SENÃO SE meia_vida_calc &lt; 24 ENTÃO
                            ESCREVER "Eliminação: Moderada (6h ≤ t½ &lt; 24h)"
                        SENÃO
                            ESCREVER "Eliminação: Lenta (t½ ≥ 24h)"
                        FIM SE
                        
                        SE clearance_calc &lt; 1 ENTÃO
                            ESCREVER "Clearance: Baixo (&lt; 1 L/h)"
                        SENÃO SE clearance_calc &lt; 10 ENTÃO
                            ESCREVER "Clearance: Moderado (1-10 L/h)"
                        SENÃO
                            ESCREVER "Clearance: Alto (&gt; 10 L/h)"
                        FIM SE
                        
                    SENÃO
                        ESCREVER "Parâmetros estimados devem ser positivos"
                    FIM SE
                SENÃO
                    ESCREVER "Dose deve ser positiva"
                FIM SE
            SENÃO
                ESCREVER "Número de amostras deve estar entre 3 e 10"
            FIM SE
            
        SENÃO SE opcao = 5 ENTÃO
            ESCREVER "=== CÁLCULOS AUXILIARES ==="
            ESCREVER "1. Converter unidades de concentração"
            ESCREVER "2. Calcular dose por peso corporal"
            ESCREVER "3. Funções matemáticas (exp, log, etc.)"
            LER tipo_calculo
            
            SE tipo_calculo = 1 ENTÃO
                ESCREVER "Digite a concentração em mg/L:"
                LER conc_mg_l
                ESCREVER "Digite o peso molecular (g/mol):"
                LER peso_molecular
                
                SE conc_mg_l &gt;= 0 E peso_molecular &gt; 0 ENTÃO
                    // Converter mg/L para μM
                    conc_micromolar ← (conc_mg_l * 1000) / peso_molecular
                    ESCREVER conc_mg_l, "mg/L =", conc_micromolar, "μM"
                    
                    // Converter para outras unidades
                    conc_ng_ml ← conc_mg_l * 1000
                    conc_g_dl ← conc_mg_l / 10
                    
                    ESCREVER "Equivalências:"
                    ESCREVER "  ", conc_ng_ml, "ng/mL"
                    ESCREVER "  ", conc_g_dl, "μg/dL"
                SENÃO
                    ESCREVER "Valores devem ser não negativos"
                FIM SE
                
            SENÃO SE tipo_calculo = 2 ENTÃO
                ESCREVER "Digite a dose total (mg):"
                LER dose_mg
                ESCREVER "Digite o peso corporal (kg):"
                LER peso_kg
                
                SE dose_mg &gt; 0 E peso_kg &gt; 0 ENTÃO
                    dose_por_kg ← dose_mg / peso_kg
                    ESCREVER "Dose por peso corporal:", dose_por_kg, "mg/kg"
                    
                    // Classificação pediátrica vs adulto
                    SE peso_kg &lt; 20 ENTÃO
                        ESCREVER "Classificação: Dose pediátrica"
                    SENÃO SE peso_kg &lt; 80 ENTÃO
                        ESCREVER "Classificação: Dose adulto padrão"
                    SENÃO
                        ESCREVER "Classificação: Dose para peso elevado"
                    FIM SE
                SENÃO
                    ESCREVER "Valores devem ser positivos"
                FIM SE
                
            SENÃO SE tipo_calculo = 3 ENTÃO
                ESCREVER "Digite um valor para testar funções matemáticas:"
                LER valor
                
                SE valor &gt; 0 ENTÃO
                    resultado_exp ← exp(valor)
                    resultado_log ← log(valor)
                    resultado_sqrt ← sqrt(valor)
                    resultado_floor ← floor(valor)
                    resultado_ceil ← ceil(valor)
                    
                    ESCREVER "Para x =", valor, ":"
                    ESCREVER "exp(x) =", resultado_exp
                    ESCREVER "ln(x) =", resultado_log
                    ESCREVER "sqrt(x) =", resultado_sqrt
                    ESCREVER "floor(x) =", resultado_floor
                    ESCREVER "ceil(x) =", resultado_ceil
                    
                    SE valor &lt;= 10 ENTÃO
                        potencia_2 ← pow(valor, 2)
                        potencia_3 ← pow(valor, 3)
                        ESCREVER "x² =", potencia_2
                        ESCREVER "x³ =", potencia_3
                    FIM SE
                SENÃO
                    ESCREVER "Valor deve ser positivo para logaritmo"
                FIM SE
            SENÃO
                ESCREVER "Opção inválida"
            FIM SE
            
        SENÃO SE opcao = 6 ENTÃO
            ESCREVER "Encerrando sistema de laboratório farmacêutico..."
            
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE
        
        // Pausa para visualização
        SE opcao ≠ 6 ENTÃO
            ESCREVER "\nPressione Enter para continuar..."
            LER pausa
        FIM SE
    FIM ENQUANTO
FIM

// FUNÇÃO: CALCULAR ESTATÍSTICAS
// Processamento sequencial sem arrays
FUNÇÃO calcularEstatisticas(n: inteiro): real, real
INÍCIO
    soma ← 0
    soma_quadrados ← 0
    
    // Primeira passagem: calcular média
    PARA i DE 1 ATÉ n FAÇA
        ESCREVER "Digite o valor", i, ":"
        LER valor
        soma ← soma + valor
    FIM PARA
    
    media ← soma / n
    
    // Segunda passagem: calcular desvio padrão
    ESCREVER "Agora digite os valores novamente para calcular o desvio padrão:"
    PARA i DE 1 ATÉ n FAÇA
        ESCREVER "Digite novamente o valor", i, ":"
        LER valor
        diferenca ← valor - media
        quadrado_diferenca ← pow(diferenca, 2)
        soma_quadrados ← soma_quadrados + quadrado_diferenca
    FIM PARA
    
    variancia ← soma_quadrados / (n - 1)
    desvio_padrao ← sqrt(variancia)
    
    RETORNAR media, desvio_padrao
FIM

// FUNÇÃO: MODELAR FARMACOCINÉTICA
// C(t) = C0 × e^(-kt)
FUNÇÃO modelarFarmacocinetica(c0: real, k: real, tempo: real, dose: real): real, real, real, real
INÍCIO
    // Concentração no tempo t: C(t) = C0 × e^(-kt)
    concentracao_t ← c0 * exp(-k * tempo)
    
    // Meia-vida: t½ = ln(2) / k
    meia_vida ← log(2) / k
    
    // AUC (0→∞): AUC = C0 / k
    auc ← c0 / k
    
    // Clearance: CL = Dose / AUC
    clearance ← dose / auc
    
    RETORNAR concentracao_t, meia_vida, auc, clearance
FIM

// FUNÇÃO: DETERMINAR BIOEQUIVALÊNCIA
// Critérios: 0.80 ≤ razão ≤ 1.25 para AUC e Cmax
FUNÇÃO determinarBioequivalencia(auc_ref: real, cmax_ref: real, auc_teste: real, cmax_teste: real): inteiro
INÍCIO
    // Calcular razões
    razao_auc ← auc_teste / auc_ref
    razao_cmax ← cmax_teste / cmax_ref
    
    // Verificar critérios de bioequivalência
    auc_ok ← (razao_auc &gt;= 0.80) E (razao_auc &lt;= 1.25)
    cmax_ok ← (razao_cmax &gt;= 0.80) E (razao_cmax &lt;= 1.25)
    
    // Retornar 1 se bioequivalente, 0 se não
    SE auc_ok E cmax_ok ENTÃO
        RETORNAR 1
    SENÃO
        RETORNAR 0
    FIM SE
FIM</code></pre>
<p>O pseudocódigo proposto pode ser representado pelo código disponível em <a href="https://onlinegdb.com/ayWgb_nfH">https://onlinegdb.com/ayWgb_nfH</a>.</p>
<p><strong>Nota</strong>: O professor pode adaptar os exercícios para incluir mais funções ou módulos, dependendo do nível de conhecimento dos alunos e do tempo disponível. O Exercício <strong>G2</strong> é uma boa oportunidade para o professor introduzir estruturas de dados complexas, pares e vetores por exemplo.</p>
</section>
</section>
<section id="decomposição-e-abstração-estruturas-de-dados-compostas" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="decomposição-e-abstração-estruturas-de-dados-compostas"><span class="header-section-number">7.2</span> Decomposição e Abstração: Estruturas de Dados Compostas</h2>
<p>Ao completar o exercício <strong>G2</strong>, os alunos devem estar prontos para desafios mais complexos que envolvem estruturas de dados compostas, como arrays, vetores, strings, tuplas e registros. Que completam o conhecimento básico de manipulação de dados. As abstrações representadas por estas estruturas tem impacto além dos cursos de Ciência e Engenharia da Computação.</p>
<p>Nesta seção, serão usadas as funções, métodos e módulos que são relacinados a leitura e gravação de arquivos. Novamente, o professor deve escolhar ente usar a Técnica da Sequência de Fibonacci, ou a sua própria metodologia. Considerando que a Técnica da Sequência de Fibonacci é uma possibilidade, a seguir estão explicitados <span class="math inline">\(7\)</span> exercícios (1, 1, 2, 3).</p>
<p>Finalmente, neste ponto da disciplina, o aluno já será capaz de ler código e entender o algoritmo que ele representa. Deste ponto em diante, os exercícios serão mais desafiadores. Porém, os eventuas fluxograms, ou pseudocódigos, serão deixados para o professor e seus alunos, de acordo com a capacidade e evolução de cada turma.</p>
<p>Os exercícios são mais desafiadores e, consequentemente mais demorados, o professor pode sugerir que eles sejam realizados em grupos e, neste caso, cabe ao professor dividir os exerícios em módulos que possam ser implementados separadamente. A divisão em módulos é uma boa prática de programação, que ajuda a organizar o código e facilita a manutenção. Além disso, serve como prática de <strong>D</strong>epuração e engenharia de software. Nos exercícios a seguir serão considerados grupos de 4 alunos.</p>
<p><strong>Estratégia de Apresentação</strong>: O professor pode dividir a turma em grupos de 4 alunos, apresentar o problema e solicitar que seja criado um fluxograma para a solução. O problema <strong>H2</strong> deve ser usado para apresentar uma estratégia de <strong>D</strong>ecomposição. Todos os outros problemas devem ser apresentados, sem incluir qualquer estratégia de decomposição. É importante que os alunos mudem de personagem a cada exercício, para que todos tenham a oportunidade de praticar a leitura e escrita de código. Ou seja, a pessoa que ocupa a posição Aluno 1 no exercício <strong>H2</strong> deve ser a Aluno 2 no exercício <strong>I2</strong>, e assim por diante.</p>
<section id="h2" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="h2"><span class="header-section-number">7.2.1</span> <strong>H2</strong></h3>
<p>Uma pequena biblioteca precisa gerenciar os empréstimos de livros, registrando o nome do usuário e a quantidade de dias do empréstimo. O programa deve usar um array para armazenar até 10 empréstimos, salvar os dados em disco e permitir consultas. Desenvolva um sistema que registre empréstimos, mantenha um histórico em um array e permita consultar todos os empréstimos ou os de um usuário específico.</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><strong>Estruturas de dados</strong>: Array para armazenar nomes e dias de empréstimo;</li>
<li><strong>Funções próprias</strong>: <code>registrarEmprestimo()</code>, <code>salvarEmprestimos()</code>, <code>lerEmprestimos()</code>, <code>buscarEmprestimo()</code>;</li>
<li><strong>Funções padrão</strong>: <code>getline()</code>, <code>stoi()</code>, <code>to_string()</code>;</li>
</ul>
<p><strong>Entrada</strong>: Nome do usuário (string) e dias de empréstimo (inteiro, <span class="math inline">\(1\)</span> a <span class="math inline">\(30\)</span>) <strong>Saída</strong>: Lista de todos os empréstimos ou empréstimos de um usuário específico, com média dos dias de empréstimo</p>
<section id="algoritmização-pseudocódigo-e-código" class="level4" data-number="7.2.1.1">
<h4 data-number="7.2.1.1" class="anchored" data-anchor-id="algoritmização-pseudocódigo-e-código"><span class="header-section-number">7.2.1.1</span> Algoritmização: Pseudocódigo e Código</h4>
<p>O pseudocódigo para esta tarefa pode ser:</p>
<pre class="shell"><code>ALGORITMO GerenciadorEmprestimos

    // Constantes
    MAX_EMPRESTIMOS ← 10
    ARQUIVO ← "empréstimos.csv"

    // Declaração de arrays
    nomes[MAX_EMPRESTIMOS]: string
    dias[MAX_EMPRESTIMOS]: inteiro
    quantidade: inteiro

INÍCIO
    // Inicializar sistema
    ESCREVER "=== Sistema de Empréstimos de Livros ==="
    ESCREVER "Inicializando sistema..."
    inicializarArquivo()

    // Carregar dados existentes
    lerEmprestimos(nomes, dias, quantidade)

    FAÇA
        exibirMenu()
        ESCREVER "Escolha uma opção: "
        LER opcao

        SE opcao = 1 ENTÃO
            registrarEmprestimo(nomes, dias, quantidade)
            salvarEmprestimos(nomes, dias, quantidade)
            ESCREVER quantidade, " empréstimos registrados."
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite o nome do usuário para busca: "
            LER nome
            buscarEmprestimo(nome)
        SENÃO SE opcao = 3 ENTÃO
            nomesTemp[MAX_EMPRESTIMOS]: string
            diasTemp[MAX_EMPRESTIMOS]: inteiro
            totalRegistros: inteiro
            SE lerEmprestimos(nomesTemp, diasTemp, totalRegistros) = FALSO ENTÃO
                ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
            SENÃO
                SE totalRegistros = 0 ENTÃO
                    ESCREVER "Nenhum registro encontrado!"
                SENÃO
                    ESCREVER "=== RELATÓRIO COMPLETO ==="
                    soma ← 0.0
                    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
                        ESCREVER "Usuário: ", nomesTemp[i], ", Dias: ", diasTemp[i]
                        soma ← soma + diasTemp[i]
                    FIM PARA
                    ESCREVER "Total de empréstimos: ", totalRegistros
                    ESCREVER "Média dos dias: ", soma / totalRegistros
                FIM SE
            FIM SE
        SENÃO SE opcao = 0 ENTÃO
            ESCREVER "Encerrando sistema..."
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE

        SE opcao ≠ 0 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    ENQUANTO opcao ≠ 0

FIM

FUNÇÃO registrarEmprestimo(nomes: string[], dias: inteiro[], quantidade: inteiro): void
INÍCIO
    SE quantidade ≥ MAX_EMPRESTIMOS ENTÃO
        ESCREVER "Limite de empréstimos atingido!"
        RETORNAR
    FIM SE

    FAÇA
        ESCREVER "Digite o nome do usuário (ou 'sair' para encerrar): "
        LER nome
        SE nome = "sair" ENTÃO
            RETORNAR
        FIM SE

        SE nome = "" OU nome CONTER "," ENTÃO
            ESCREVER "Nome inválido! Deve ser não vazio e sem vírgulas."
            CONTINUAR
        FIM SE

        ESCREVER "Digite a quantidade de dias (1-30): "
        LER entrada
        TENTAR
            dia ← CONVERTER_PARA_INTEIRO(entrada)
            SE dia ≥ 1 E dia ≤ 30 ENTÃO
                nomes[quantidade] ← nome
                dias[quantidade] ← dia
                quantidade ← quantidade + 1
                SE quantidade = MAX_EMPRESTIMOS ENTÃO
                    ESCREVER "Limite de empréstimos atingido!"
                    RETORNAR
                FIM SE
            SENÃO
                ESCREVER "Dias fora do intervalo (1-30). Ignorado."
            FIM SE
        SENÃO
            ESCREVER "Valor inválido para dias. Ignorado."
        FIM TENTAR
    ENQUANTO VERDADEIRO
FIM

FUNÇÃO salvarEmprestimos(nomes: string[], dias: inteiro[], quantidade: inteiro): void
INÍCIO
    ABRIR arquivo(ARQUIVO, SOBRESCREVER)
    SE arquivo NÃO ABERTO ENTÃO
        ESCREVER "Erro ao abrir arquivo para gravação!"
        RETORNAR
    FIM SE

    ESCREVER_ARQUIVO(arquivo, "Nome,Dias")
    PARA i DE 0 ATÉ quantidade - 1 FAÇA
        ESCREVER_ARQUIVO(arquivo, nomes[i], ",", dias[i])
    FIM PARA
    FECHAR arquivo
FIM

FUNÇÃO lerEmprestimos(nomes: string[], dias: inteiro[], quantidade: inteiro, nomeFiltro: string = ""): booleano
INÍCIO
    ABRIR arquivo(ARQUIVO, LEITURA)
    SE arquivo NÃO ABERTO ENTÃO
        RETORNAR FALSO
    FIM SE

    quantidade ← 0
    LER_LINHA(arquivo, linha)
    SE linha CONTER "Nome" ENTÃO
        // Cabeçalho detectado
    SENÃO
        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)
    FIM SE

    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_EMPRESTIMOS FAÇA
        SEPARAR(linha, ",", nome, diasStr)
        SE nomeFiltro = "" OU nome = nomeFiltro ENTÃO
            TENTAR
                dias[quantidade] ← CONVERTER_PARA_INTEIRO(diasStr)
                nomes[quantidade] ← nome
                quantidade ← quantidade + 1
            SENÃO
                // Ignorar linhas inválidas
            FIM TENTAR
        FIM SE
    FIM ENQUANTO

    SE quantidade = MAX_EMPRESTIMOS E MAIS_LINHAS(arquivo) ENTÃO
        ESCREVER "Aviso: Mais registros no arquivo do que o limite de ", MAX_EMPRESTIMOS
    FIM SE

    FECHAR arquivo
    RETORNAR VERDADEIRO
FIM

FUNÇÃO buscarEmprestimo(nome: string): void
INÍCIO
    nomes[MAX_EMPRESTIMOS]: string
    dias[MAX_EMPRESTIMOS]: inteiro
    totalRegistros: inteiro

    SE lerEmprestimos(nomes, dias, totalRegistros, nome) = FALSO ENTÃO
        ESCREVER "Erro ao ler dados!"
        RETORNAR
    FIM SE

    SE totalRegistros = 0 ENTÃO
        ESCREVER "Nenhum empréstimo encontrado para ", nome, "!"
        RETORNAR
    FIM SE

    ESCREVER "=== EMPRÉSTIMOS DE ", nome, " ==="
    soma ← 0.0
    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
        ESCREVER "Usuário: ", nomes[i], ", Dias: ", dias[i]
        soma ← soma + dias[i]
    FIM PARA
    ESCREVER "Total de empréstimos: ", totalRegistros
    ESCREVER "Média dos dias: ", soma / totalRegistros
FIM

FUNÇÃO inicializarArquivo(): void
INÍCIO
    SE ARQUIVO NÃO EXISTIR ENTÃO
        ABRIR arquivo(ARQUIVO, ESCRITA)
        SE arquivo ABERTO ENTÃO
            ESCREVER_ARQUIVO(arquivo, "Nome,Dias")
            FECHAR arquivo
            ESCREVER "Arquivo de dados criado: ", ARQUIVO
        SENÃO
            ESCREVER "Erro ao criar arquivo de dados!"
        FIM SE
    SENÃO
        ESCREVER "Arquivo de dados encontrado: ", ARQUIVO
    FIM SE
FIM

FUNÇÃO exibirMenu(): void
INÍCIO
    ESCREVER "=== MENU PRINCIPAL ==="
    ESCREVER "1. Registrar empréstimos"
    ESCREVER "2. Buscar empréstimos por usuário"
    ESCREVER "3. Relatório completo"
    ESCREVER "0. Sair"
FIM</code></pre>
</section>
<section id="decomposição-divisão-de-tarefas-para-o-problema-h2" class="level4" data-number="7.2.1.2">
<h4 data-number="7.2.1.2" class="anchored" data-anchor-id="decomposição-divisão-de-tarefas-para-o-problema-h2"><span class="header-section-number">7.2.1.2</span> Decomposição: Divisão de Tarefas para o Problema H2</h4>
<p>Para resolver o problema <strong>H2</strong> de gerenciamento de empréstimos de livros, o trabalho pode ser dividido entre quatro alunos que trabalharão independentemente na mesma sala, sem sistema de controle de versão, durante o mesmo período de tempo. Cada aluno será responsável por uma parte específica do sistema, com interfaces claras para facilitar a integração final. Abaixo está a divisão das tarefas, considerando as funções solicitadas (<code>registrarEmprestimo</code>, <code>salvarEmprestimos</code>, <code>lerEmprestimos</code>, <code>buscarEmprestimo</code>).</p>
<p><strong>Aluno 1</strong>: Função <code>registrarEmprestimo</code> e Validação de Entrada</p>
<p><strong>Responsabilidades</strong>: implementar <code>registrarEmprestimo(std::string nomes[], int dias[], int&amp; quantidade)</code> para coletar nome do usuário e dias de empréstimo (<span class="math inline">\(1\)</span> a <span class="math inline">\(30\)</span>). Validar:</p>
<ul>
<li>Nome não vazio e sem vírgulas (para evitar corromper o CSV);</li>
<li>Dias como inteiro entre <span class="math inline">\(1\)</span> e <span class="math inline">\(30\)</span>, usando stoi com tratamento de exceções;</li>
<li>Não zerar quantidade para preservar empréstimos anteriores no array.</li>
</ul>
<p>Permitir múltiplos empréstimos até <code>MAX_EMPRESTIMOS</code> (<span class="math inline">\(10\)</span>) ou até o usuário digitar “sair”; Corrigir uso de <code>std::cin.ignore</code> para evitar problemas com o <code>buffer</code>. Ou o equivalente em Python.</p>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Escrever a função com entrada via <code>getline</code> para nome e dias;</li>
<li>Validar nome (Ex.: <code>if (nome.empty() || nome.find(',') != std::string::npos)</code>);</li>
<li>Adicionar novos empréstimos a partir do índice quantidade, sem zerar o array;</li>
<li>Testar isoladamente com entradas válidas e inválidas (Ex.: dias fora do intervalo, nomes com vírgulas).</li>
</ul>
<p><strong>Interface</strong>:</p>
<p>Recebe <code>nomes[]</code>, <code>dias[]</code> e <code>quantidade</code> como parâmetros; Fornece dados válidos para <code>salvarEmprestimos</code> e consultas.</p>
<p><strong>Aluno 2</strong>: Função <code>salvarEmprestimos</code> e Inicialização do Arquivo</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>salvarEmprestimos(const std::string nomes[], const int dias[], int quantidade)</code> para gravar empréstimos no arquivo <code>emprestimos.csv</code>;</li>
<li>Sobrescrever o arquivo (usando <code>std::ios::trunc</code>) para evitar duplicatas;</li>
<li>Implementar <code>inicializarArquivo()</code> para criar o arquivo CSV com cabeçalho <code>Nome,Dias</code> se não existir;</li>
<li>Verificar erros ao abrir/escrever no arquivo.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Gravar cada par nome,dias em uma linha do CSV, sobrescrevendo o arquivo;</li>
<li>Preservar o cabeçalho ao sobrescrever;</li>
<li>Verificar abertura do arquivo e exibir mensagens de erro;</li>
<li>Testar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.</li>
</ul>
<p><strong>Interface</strong>:</p>
<p>Recebe <code>nomes[], dias[]</code> e quantidade de <code>registrarEmprestimo</code>; Produz um arquivo CSV lido por <code>lerEmprestimos</code>.</p>
<p><strong>Aluno 3</strong>: Função <code>lerEmprestimos</code> e Carregamento Inicial</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>lerEmprestimos(std::string nomes[], int dias[], int&amp; quantidade, const std::string&amp; nomeFiltro = "")</code> para ler o arquivo CSV; Suportar leitura de todos os registros ou apenas os de um usuário (com nomeFiltro); Alertar se o arquivo tiver mais registros que <code>MAX_EMPRESTIMOS</code>; Carregar dados do arquivo no início do programa (no <code>main</code>) para sincronizar o array local.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Ler o CSV, ignorar o cabeçalho e preencher nomes e dias;</li>
<li>Implementar filtragem por nomeFiltro quando não vazio;</li>
<li>Contar registros e alertar se exceder <code>MAX_EMPRESTIMOS</code>;</li>
<li>Modificar o <code>main</code> para chamar <code>lerEmprestimos</code> no início;</li>
<li>Testar com arquivos CSV vazios, com menos de <span class="math inline">\(10\)</span> registros e com mais de <span class="math inline">\(10\)</span>.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Lê o arquivo CSV de <code>salvarEmprestimos</code>;</li>
<li>Fornece dados para buscarEmprestimo e relatório completo.</li>
</ul>
<p><strong>Aluno 4</strong>: Função buscarEmprestimo, Relatório e Interface do Usuário</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>buscarEmprestimo(const std::string&amp; nome)</code> para exibir empréstimos de um usuário e calcular a média dos dias;</li>
<li>Implementar o relatório completo (opção <span class="math inline">\(3\)</span> do menu) para listar todos os empréstimos e a média dos dias;</li>
<li>Escrever <code>exibirMenu()</code> e gerenciar a interface no <code>main</code>, corrigindo <code>std::cin.ignore</code>;</li>
<li>Garantir saídas formatadas (média com uma casa decimal, mensagens claras).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Chamar <code>lerEmprestimos</code> com filtro de nome e exibir resultados com total e média;</li>
<li>Implementar relatório completo no <code>main</code>, usando <code>lerEmprestimos</code> sem filtro;</li>
<li>Corrigir <code>std::cin.ignore</code> no <code>main</code> (e.g., usar <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code> após <code>std::cin &gt;&gt; opcao</code>);</li>
<li>Testar a interface com busca de usuário existente/inexistente e relatórios.</li>
</ul>
<p><strong>Interface</strong>:</p>
<p>Usa dados de <code>lerEmprestimos</code> para exibir resultados; Interage com o usuário, fornecendo nomes para <code>registrarEmprestimo</code> e <code>buscarEmprestimo</code>.</p>
</section>
<section id="considerações-para-integração-do-problema-h2" class="level4" data-number="7.2.1.3">
<h4 data-number="7.2.1.3" class="anchored" data-anchor-id="considerações-para-integração-do-problema-h2"><span class="header-section-number">7.2.1.3</span> Considerações para Integração do Problema H2</h4>
<p><strong>Interfaces</strong>: os alunos devem concordar com assinaturas das funções e formato do CSV (nome,dias com cabeçalho); <strong>Depuração</strong>: os alunos devem fazer a <strong>D</strong>epuração de cada parte isoladamente, simulando entradas/saídas;</p>
<p><strong>Passos importantes da integração</strong>:</p>
<ul>
<li>Copiar main e exibirMenu do Aluno 4;</li>
<li>Inserir <code>inicializarArquivo</code> e <code>salvarEmprestimos</code> do Aluno 2;</li>
<li>Adicionar <code>lerEmprestimos</code> do Aluno 3, ajustando o <code>main</code> para carregar dados iniciais;</li>
<li>Incluir <code>registrarEmprestimo</code> do Aluno 1 e <code>buscarEmprestimo</code> do Aluno 4.</li>
</ul>
<p><strong>Resolução de conflitos</strong>: discutir problemas imediatamente na sala. <strong>Depuração</strong>: testar o programa com cenários como registrar empréstimos, buscar por usuário e exibir relatórios.</p>
</section>
<section id="código-c23" class="level4" data-number="7.2.1.4">
<h4 data-number="7.2.1.4" class="anchored" data-anchor-id="código-c23"><span class="header-section-number">7.2.1.4</span> Código C++23</h4>
<p>Um dos códigos em C++23 que implementa o pseudocódigo acima pode ser encontrado em <a href="https://onlinegdb.com/KzjXw8xZm">https://onlinegdb.com/KzjXw8xZm</a>.</p>
</section>
</section>
<section id="i2" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="i2"><span class="header-section-number">7.2.2</span> I2</h3>
<p>Um estudante quer organizar suas tarefas diárias em uma lista dinâmica, com descrições curtas. O programa deve usar um vector para armazenar as tarefas, salvar em disco e permitir consultas. Desenvolva um sistema que gerencie tarefas, adicione ou remova tarefas de um vector e permita buscar tarefas por palavra-chave.</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><strong>Funções próprias</strong>: <code>adicionarTarefa()</code>, <code>removerTarefa()</code>, <code>salvarTarefas()</code>, <code>lerTarefas()</code>, <code>buscarTarefa()</code></li>
<li><strong>Funções padrão</strong>: <code>getline()</code>, <code>to_string()</code></li>
</ul>
<p><strong>Entrada</strong>: Descrição da tarefa (string) ou palavra-chave para busca <strong>Saída</strong>: Lista completa de tarefas ou tarefas encontradas, com contagem total de tarefas</p>
<section id="algoritmização-pseudocódigo-e-código-1" class="level4" data-number="7.2.2.1">
<h4 data-number="7.2.2.1" class="anchored" data-anchor-id="algoritmização-pseudocódigo-e-código-1"><span class="header-section-number">7.2.2.1</span> Algoritmização: Pseudocódigo e Código</h4>
<pre class="plaintext"><code>ALGORITMO GerenciadorTarefas

    // Constantes
    ARQUIVO ← "tarefas.txt"

    // Declaração do vetor dinâmico
    tarefas: vetor dinâmico de string

INÍCIO
    // Inicializar sistema
    ESCREVER "=== Sistema de Gerenciamento de Tarefas ==="
    ESCREVER "Inicializando sistema..."
    inicializarArquivo()

    // Carregar dados existentes
    lerTarefas(tarefas)

    FAÇA
        exibirMenu()
        ESCREVER "Escolha uma opção: "
        LER opcao

        SE opcao = 1 ENTÃO
            adicionarTarefa(tarefas)
            salvarTarefas(tarefas)
            ESCREVER "Tarefa(s) registrada(s)."
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite o índice da tarefa a remover (1-based): "
            LER indice
            removerTarefa(tarefas, indice)
            salvarTarefas(tarefas)
            ESCREVER "Tarefa removida."
        SENÃO SE opcao = 3 ENTÃO
            ESCREVER "Digite a palavra-chave para busca (ou vazio para todas): "
            LER palavraChave
            buscarTarefa(tarefas, palavraChave)
        SENÃO SE opcao = 4 ENTÃO
            tarefasTemp: vetor dinâmico de string
            SE lerTarefas(tarefasTemp) = FALSO ENTÃO
                ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
            SENÃO
                SE tamanho(tarefasTemp) = 0 ENTÃO
                    ESCREVER "Nenhuma tarefa encontrada!"
                SENÃO
                    ESCREVER "=== RELATÓRIO COMPLETO ==="
                    PARA i DE 0 ATÉ tamanho(tarefasTemp) - 1 FAÇA
                        ESCREVER "Tarefa ", i + 1, ": ", tarefasTemp[i]
                    FIM PARA
                    ESCREVER "Total de tarefas: ", tamanho(tarefasTemp)
                FIM SE
            FIM SE
        SENÃO SE opcao = 0 ENTÃO
            ESCREVER "Encerrando sistema..."
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE

        SE opcao ≠ 0 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    ENQUANTO opcao ≠ 0

FIM

FUNÇÃO adicionarTarefa(tarefas: vetor dinâmico de string): void
INÍCIO
    FAÇA
        ESCREVER "Digite a descrição da tarefa (ou 'sair' para encerrar): "
        LER descricao
        SE descricao = "sair" ENTÃO
            RETORNAR
        FIM SE

        SE descricao = "" OU descricao CONTER "," ENTÃO
            ESCREVER "Descrição inválida! Deve ser não vazia e sem vírgulas."
            CONTINUAR
        FIM SE

        tarefas.ADICIONAR(descricao)
    ENQUANTO VERDADEIRO
FIM

FUNÇÃO salvarTarefas(tarefas: vetor dinâmico de string): void
INÍCIO
    ABRIR arquivo(ARQUIVO, SOBRESCREVER)
    SE arquivo NÃO ABERTO ENTÃO
        ESCREVER "Erro ao abrir arquivo para gravação!"
        RETORNAR
    FIM SE

    ESCREVER_ARQUIVO(arquivo, "Tarefas")
    PARA i DE 0 ATÉ tamanho(tarefas) - 1 FAÇA
        ESCREVER_ARQUIVO(arquivo, tarefas[i])
    FIM PARA
    FECHAR arquivo
FIM

FUNÇÃO lerTarefas(tarefas: vetor dinâmico de string): booleano
INÍCIO
    ABRIR arquivo(ARQUIVO, LEITURA)
    SE arquivo NÃO ABERTO ENTÃO
        RETORNAR FALSO
    FIM SE

    tarefas.LIMPAR()
    LER_LINHA(arquivo, linha)
    SE linha CONTER "Tarefas" ENTÃO
        // Cabeçalho detectado
    SENÃO
        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)
    FIM SE

    ENQUANTO LER_LINHA(arquivo, linha) FAÇA
        SE linha ≠ "" ENTÃO
            tarefas.ADICIONAR(linha)
        FIM SE
    FIM ENQUANTO

    FECHAR arquivo
    RETORNAR VERDADEIRO
FIM

FUNÇÃO removerTarefa(tarefas: vetor dinâmico de string, indice: inteiro): void
INÍCIO
    SE indice &lt; 1 OU indice &gt; tamanho(tarefas) ENTÃO
        ESCREVER "Índice inválido!"
        RETORNAR
    FIM SE

    tarefas.REMOVER(indice - 1)
FIM

FUNÇÃO buscarTarefa(tarefas: vetor dinâmico de string, palavraChave: string): void
INÍCIO
    totalEncontradas ← 0
    SE palavraChave = "" ENTÃO
        ESCREVER "=== TODAS AS TAREFAS ==="
        PARA i DE 0 ATÉ tamanho(tarefas) - 1 FAÇA
            ESCREVER "Tarefa ", i + 1, ": ", tarefas[i]
            totalEncontradas ← totalEncontradas + 1
        FIM PARA
    SENÃO
        ESCREVER "=== TAREFAS COM PALAVRA-CHAVE '", palavraChave, "' ==="
        PARA i DE 0 ATÉ tamanho(tarefas) - 1 FAÇA
            SE tarefas[i] CONTER palavraChave ENTÃO
                ESCREVER "Tarefa ", i + 1, ": ", tarefas[i]
                totalEncontradas ← totalEncontradas + 1
            FIM SE
        FIM PARA
    FIM SE

    SE totalEncontradas = 0 ENTÃO
        ESCREVER "Nenhuma tarefa encontrada!"
    SENÃO
        ESCREVER "Total de tarefas encontradas: ", totalEncontradas
    FIM SE
FIM

FUNÇÃO inicializarArquivo(): void
INÍCIO
    SE ARQUIVO NÃO EXISTIR ENTÃO
        ABRIR arquivo(ARQUIVO, ESCRITA)
        SE arquivo ABERTO ENTÃO
            ESCREVER_ARQUIVO(arquivo, "Tarefas")
            FECHAR arquivo
            ESCREVER "Arquivo de dados criado: ", ARQUIVO
        SENÃO
            ESCREVER "Erro ao criar arquivo de dados!"
        FIM SE
    SENÃO
        ESCREVER "Arquivo de dados encontrado: ", ARQUIVO
    FIM SE
FIM

FUNÇÃO exibirMenu(): void
INÍCIO
    ESCREVER "=== MENU PRINCIPAL ==="
    ESCREVER "1. Adicionar tarefa"
    ESCREVER "2. Remover tarefa"
    ESCREVER "3. Buscar tarefas por palavra-chave"
    ESCREVER "4. Relatório completo"
    ESCREVER "0. Sair"
FIM</code></pre>
</section>
<section id="decomposição-divisão-de-tarefas-para-o-problema-i2" class="level4" data-number="7.2.2.2">
<h4 data-number="7.2.2.2" class="anchored" data-anchor-id="decomposição-divisão-de-tarefas-para-o-problema-i2"><span class="header-section-number">7.2.2.2</span> Decomposição: Divisão de Tarefas para o Problema I2</h4>
<p><strong>Aluno 1</strong>: Função <code>adicionarTarefa</code> e Validação de Entrada</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>adicionarTarefa(vector&lt;string&gt;&amp; tarefas)</code> para coletar descrições de tarefas (strings).</li>
<li>Validar:
<ul>
<li>Descrição não vazia e sem vírgulas (para evitar corromper o arquivo)]</li>
<li>Permitir múltiplas adições até o usuário digitar “sair”;</li>
</ul></li>
<li>Usar <code>getline</code> para entrada da descrição;</li>
<li>Adicionar tarefas ao vetor dinâmico sem limite fixo.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Escrever a função para ler descrição via <code>getline</code> e adicionar ao vetor;</li>
<li>Validar descrição (ex.: <code>if (descricao.empty() || descricao.find(',') != string::npos)</code> em C++);</li>
<li>Testar isoladamente com entradas válidas (ex.: “Estudar C++”) e inválidas (ex.: ““,”Comprar leite, pão”);</li>
<li>Tratar buffer de entrada adequadamente (ex.: evitar problemas com <code>std::cin</code>).</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>vector&lt;string&gt;&amp; tarefas</code> como parâmetro;</li>
<li>Modifica o vetor diretamente, fornecendo dados para <code>salvarTarefas</code> e consultas.</li>
</ul>
<p><strong>Aluno 2</strong>: Função <code>salvarTarefas</code> e Inicialização do Arquivo</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>salvarTarefas(const vector&lt;string&gt;&amp; tarefas)</code> para gravar tarefas em <code>tarefas.txt</code> (uma tarefa por linha);</li>
<li>Sobrescrever o arquivo (ex.: <code>std::ios::trunc</code> em C++) para evitar duplicatas;</li>
<li>Implementar <code>inicializarArquivo()</code> para criar o arquivo com cabeçalho “Tarefas” se não existir;</li>
<li>Verificar erros ao abrir/escrever no arquivo.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Gravar cada tarefa em uma linha, sobrescrevendo o arquivo;</li>
<li>Preservar o cabeçalho ao sobrescrever;</li>
<li>Verificar abertura do arquivo e exibir mensagens de erro;</li>
<li>Testar isoladamente com vetores de diferentes tamanhos e verificar o arquivo gerado.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>vector&lt;string&gt;&amp; tarefas</code> de <code>adicionarTarefa</code> ou <code>removerTarefa</code>.</li>
<li>Produz um arquivo lido por <code>lerTarefas</code>.</li>
</ul>
<p><strong>Aluno 3</strong>: Função <code>lerTarefas</code> e Carregamento Inicial</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>lerTarefas(vector&lt;string&gt;&amp; tarefas)</code> para ler o arquivo e preencher o vetor;</li>
<li>Ignorar o cabeçalho do arquivo;</li>
<li>Carregar dados do arquivo no início do programa (no <code>main</code>) para sincronizar o vetor local;</li>
<li>Tratar erros como arquivo inexistente ou vazio.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Ler o arquivo linha por linha, ignorar o cabeçalho e adicionar tarefas ao vetor;</li>
<li>Limpar o vetor antes de carregar para evitar duplicatas;</li>
<li>Modificar o <code>main</code> para chamar <code>lerTarefas</code> no início;</li>
<li>Testar com arquivos vazios, com uma tarefa e com múltiplas tarefas.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Lê o arquivo gerado por <code>salvarTarefas</code>;</li>
<li>Fornece dados para <code>buscarTarefa</code> e relatórios.</li>
</ul>
<p><strong>Aluno 4</strong>: Funções <code>removerTarefa</code>, <code>buscarTarefa</code>, Relatório e Interface do Usuário</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>removerTarefa(vector&lt;string&gt;&amp; tarefas, int indice)</code> para remover uma tarefa pelo índice (1-based para o usuário);</li>
<li>Implementar <code>buscarTarefa(const vector&lt;string&gt;&amp; tarefas, const string&amp; palavraChave)</code> para exibir tarefas que contenham a palavra-chave (case-insensitive, se possível);</li>
<li>Implementar o relatório completo (opção 3 do menu) para listar todas as tarefas e contar o total;</li>
<li>Escrever <code>exibirMenu()</code> e gerenciar a interface no <code>main</code>, corrigindo problemas de buffer (ex.: <code>std::cin.ignore</code> em C++);</li>
<li>Garantir saídas formatadas (ex.: mensagens claras, contagem de tarefas).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Implementar remoção por índice com validação (ex.: índice válido);</li>
<li>Implementar busca por palavra-chave, verificando substrings na descrição;</li>
<li>Implementar relatório completo no <code>main</code>, usando <code>lerTarefas</code> para listar todas as tarefas;</li>
<li>Corrigir <code>std::cin.ignore</code> no <code>main</code> (ex.: <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code> após leitura de opção);</li>
<li>Testar a interface com busca de palavras existentes/inexistentes, remoção válida/inválida e relatórios.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Usa dados de <code>lerTarefas</code> para exibir resultados;</li>
<li>Interage com o usuário, fornecendo descrições para <code>adicionarTarefa</code>, índices para <code>removerTarefa</code> e palavras-chave para <code>buscarTarefa</code>.</li>
</ul>
</section>
<section id="considerações-para-integração" class="level4" data-number="7.2.2.3">
<h4 data-number="7.2.2.3" class="anchored" data-anchor-id="considerações-para-integração"><span class="header-section-number">7.2.2.3</span> Considerações para Integração</h4>
<p><strong>Interfaces</strong>:</p>
<ul>
<li>Os alunos devem concordar com a assinatura das funções e o formato do arquivo (<code>tarefas.txt</code>, uma tarefa por linha, com cabeçalho);</li>
<li>O vetor dinâmico (<code>vector&lt;string&gt;</code>) é passado por referência para modificações e como const para consultas.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Cada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, vetores pré-preenchidos).</li>
</ul>
<p><strong>Passos importantes da integração</strong>:</p>
<ol type="1">
<li>Copiar <code>main</code> e <code>exibirMenu</code> do Aluno 4;</li>
<li>Inserir <code>inicializarArquivo</code> e <code>salvarTarefas</code> do Aluno 2;</li>
<li>Adicionar <code>lerTarefas</code> do Aluno 3, ajustando o <code>main</code> para carregar dados iniciais;</li>
<li>Incluir <code>adicionarTarefa</code> do Aluno 1, <code>removerTarefa</code> e <code>buscarTarefa</code> do Aluno 4.</li>
</ol>
<p><strong>Resolução de conflitos</strong>:</p>
<ul>
<li>Discutir problemas imediatamente na sala (ex.: formato do arquivo, tratamento de buffer);</li>
<li>Testar o programa completo com cenários como adicionar tarefas, remover, buscar por palavra-chave e exibir relatórios.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Verificar adição de múltiplas tarefas, remoção por índice, busca por palavra-chave e relatório completo;</li>
<li>Testar casos extremos (arquivo vazio, palavra-chave não encontrada, índice inválido).</li>
</ul>
</section>
<section id="código-c23-1" class="level4" data-number="7.2.2.4">
<h4 data-number="7.2.2.4" class="anchored" data-anchor-id="código-c23-1"><span class="header-section-number">7.2.2.4</span> Código C++23</h4>
<p>A solução em C++23 para o problema I2 pode ser encontrada em <a href="https://onlinegdb.com/SHylYeSy7">https://onlinegdb.com/SHylYeSy7</a>.`</p>
</section>
</section>
<section id="j2" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="j2"><span class="header-section-number">7.2.3</span> J2</h3>
<p>Uma loja de conveniência precisa registrar os produtos vendidos, armazenando nome e preço como uma string formatada. O programa deve usar um array de strings para até 15 produtos, salvar em disco e permitir consultas. Desenvolva um sistema que registre vendas, mantenha um array de strings com os produtos e permita buscar produtos por nome.</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><strong>Funções próprias</strong>: <code>registrarProduto()</code>, <code>salvarProdutos()</code>, <code>lerProdutos()</code>, <code>buscarProduto()</code></li>
<li><strong>Funções padrão</strong>: <code>getline()</code>, <code>stod()</code>, <code>to_string()</code></li>
</ul>
<p><strong>Entrada</strong>: Nome do produto e preço (combinados em uma string no formato “nome,preco”) <strong>Saída</strong>: Lista de todos os produtos ou produtos encontrados por busca, com soma dos preços</p>
<section id="algoritmização-pseudocódigo" class="level4" data-number="7.2.3.1">
<h4 data-number="7.2.3.1" class="anchored" data-anchor-id="algoritmização-pseudocódigo"><span class="header-section-number">7.2.3.1</span> Algoritmização: Pseudocódigo</h4>
<pre class="plaintext"><code>ALGORITMO GerenciadorProdutos

    // Constantes
    MAX_PRODUTOS ← 15
    ARQUIVO ← "produtos.csv"

    // Declaração de arrays
    produtos[MAX_PRODUTOS]: string
    quantidade: inteiro

INÍCIO
    // Inicializar sistema
    ESCREVER "=== Sistema de Gerenciamento de Produtos ==="
    ESCREVER "Inicializando sistema..."
    inicializarArquivo()

    // Carregar dados existentes
    lerProdutos(produtos, quantidade)

    FAÇA
        exibirMenu()
        ESCREVER "Escolha uma opção: "
        LER opcao

        SE opcao = 1 ENTÃO
            registrarProduto(produtos, quantidade)
            salvarProdutos(produtos, quantidade)
            ESCREVER quantidade, " produto(s) registrado(s)."
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite o nome do produto para busca: "
            LER nome
            buscarProduto(nome)
        SENÃO SE opcao = 3 ENTÃO
            produtosTemp[MAX_PRODUTOS]: string
            totalRegistros: inteiro
            SE lerProdutos(produtosTemp, totalRegistros) = FALSO ENTÃO
                ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
            SENÃO
                SE totalRegistros = 0 ENTÃO
                    ESCREVER "Nenhum produto encontrado!"
                SENÃO
                    ESCREVER "=== RELATÓRIO COMPLETO ==="
                    soma ← 0.0
                    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
                        SEPARAR(produtosTemp[i], ",", nome, precoStr)
                        TENTAR
                            preco ← CONVERTER_PARA_DOUBLE(precoStr)
                            ESCREVER "Produto: ", nome, ", Preço: R$", preco
                            soma ← soma + preco
                        SENÃO
                            ESCREVER "Erro ao processar preço em: ", produtosTemp[i]
                        FIM TENTAR
                    FIM PARA
                    ESCREVER "Total de produtos: ", totalRegistros
                    ESCREVER "Soma dos preços: R$", soma
                FIM SE
            FIM SE
        SENÃO SE opcao = 0 ENTÃO
            ESCREVER "Encerrando sistema..."
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE

        SE opcao ≠ 0 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    ENQUANTO opcao ≠ 0

FIM

FUNÇÃO registrarProduto(produtos: string[], quantidade: inteiro): void
INÍCIO
    SE quantidade ≥ MAX_PRODUTOS ENTÃO
        ESCREVER "Limite de produtos atingido!"
        RETORNAR
    FIM SE

    FAÇA
        ESCREVER "Digite o nome do produto (ou 'sair' para encerrar): "
        LER nome
        SE nome = "sair" ENTÃO
            RETORNAR
        FIM SE

        SE nome = "" OU nome CONTER "," ENTÃO
            ESCREVER "Nome inválido! Deve ser não vazio e sem vírgulas."
            CONTINUAR
        FIM SE

        ESCREVER "Digite o preço do produto (positivo): "
        LER entrada
        TENTAR
            preco ← CONVERTER_PARA_DOUBLE(entrada)
            SE preco &gt; 0 ENTÃO
                produtos[quantidade] ← nome + "," + to_string(preco)
                quantidade ← quantidade + 1
                SE quantidade = MAX_PRODUTOS ENTÃO
                    ESCREVER "Limite de produtos atingido!"
                    RETORNAR
                FIM SE
            SENÃO
                ESCREVER "Preço inválido! Deve ser positivo."
            FIM SE
        SENÃO
            ESCREVER "Valor inválido para preço. Ignorado."
        FIM TENTAR
    ENQUANTO VERDADEIRO
FIM

FUNÇÃO salvarProdutos(produtos: string[], quantidade: inteiro): void
INÍCIO
    ABRIR arquivo(ARQUIVO, SOBRESCREVER)
    SE arquivo NÃO ABERTO ENTÃO
        ESCREVER "Erro ao abrir arquivo para gravação!"
        RETORNAR
    FIM SE

    ESCREVER_ARQUIVO(arquivo, "Nome,Preco")
    PARA i DE 0 ATÉ quantidade - 1 FAÇA
        ESCREVER_ARQUIVO(arquivo, produtos[i])
    FIM PARA
    FECHAR arquivo
FIM

FUNÇÃO lerProdutos(produtos: string[], quantidade: inteiro, nomeFiltro: string = ""): booleano
INÍCIO
    ABRIR arquivo(ARQUIVO, LEITURA)
    SE arquivo NÃO ABERTO ENTÃO
        RETORNAR FALSO
    FIM SE

    quantidade ← 0
    LER_LINHA(arquivo, linha)
    SE linha CONTER "Nome" ENTÃO
        // Cabeçalho detectado
    SENÃO
        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)
    FIM SE

    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_PRODUTOS FAÇA
        SEPARAR(linha, ",", nome, precoStr)
        SE nomeFiltro = "" OU nome CONTER nomeFiltro ENTÃO
            TENTAR
                preco ← CONVERTER_PARA_DOUBLE(precoStr)
                produtos[quantidade] ← linha
                quantidade ← quantidade + 1
            SENÃO
                // Ignorar linhas inválidas
            FIM TENTAR
        FIM SE
    FIM ENQUANTO

    SE quantidade = MAX_PRODUTOS E MAIS_LINHAS(arquivo) ENTÃO
        ESCREVER "Aviso: Mais registros no arquivo do que o limite de ", MAX_PRODUTOS
    FIM SE

    FECHAR arquivo
    RETORNAR VERDADEIRO
FIM

FUNÇÃO buscarProduto(nome: string): void
INÍCIO
    produtosTemp[MAX_PRODUTOS]: string
    totalRegistros: inteiro

    SE lerProdutos(produtosTemp, totalRegistros, nome) = FALSO ENTÃO
        ESCREVER "Erro ao ler dados!"
        RETORNAR
    FIM SE

    SE totalRegistros = 0 ENTÃO
        ESCREVER "Nenhum produto encontrado para '", nome, "'!"
        RETORNAR
    FIM SE

    ESCREVER "=== PRODUTOS COM NOME CONTENDO '", nome, "' ==="
    soma ← 0.0
    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
        SEPARAR(produtosTemp[i], ",", nomeProduto, precoStr)
        TENTAR
            preco ← CONVERTER_PARA_DOUBLE(precoStr)
            ESCREVER "Produto: ", nomeProduto, ", Preço: R$", preco
            soma ← soma + preco
        SENÃO
            ESCREVER "Erro ao processar preço em: ", produtosTemp[i]
        FIM TENTAR
    FIM PARA
    ESCREVER "Total de produtos: ", totalRegistros
    ESCREVER "Soma dos preços: R$", soma
FIM

FUNÇÃO inicializarArquivo(): void
INÍCIO
    SE ARQUIVO NÃO EXISTIR ENTÃO
        ABRIR arquivo(ARQUIVO, ESCRITA)
        SE arquivo ABERTO ENTÃO
            ESCREVER_ARQUIVO(arquivo, "Nome,Preco")
            FECHAR arquivo
            ESCREVER "Arquivo de dados criado: ", ARQUIVO
        SENÃO
            ESCREVER "Erro ao criar arquivo de dados!"
        FIM SE
    SENÃO
        ESCREVER "Arquivo de dados encontrado: ", ARQUIVO
    FIM SE
FIM

FUNÇÃO exibirMenu(): void
INÍCIO
    ESCREVER "=== MENU PRINCIPAL ==="
    ESCREVER "1. Registrar produto"
    ESCREVER "2. Buscar produtos por nome"
    ESCREVER "3. Relatório completo"
    ESCREVER "0. Sair"
FIM</code></pre>
</section>
<section id="decomposição-divisão-de-tarefas-para-o-problema-j2" class="level4" data-number="7.2.3.2">
<h4 data-number="7.2.3.2" class="anchored" data-anchor-id="decomposição-divisão-de-tarefas-para-o-problema-j2"><span class="header-section-number">7.2.3.2</span> Decomposição: Divisão de Tarefas para o Problema J2</h4>
<p>O problema <strong>J2</strong> propõe um sistema para gerenciar vendas de produtos em uma loja de conveniência, usando um array fixo de até 15 strings formatadas como “nome,preco”, com persistência em arquivo e funcionalidades de registro, salvamento, leitura e busca por nome. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.</p>
<p><strong>Aluno 1</strong>: Função <code>registrarProduto</code> e Validação de Entrada</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li><p>Implementar <code>registrarProduto(string produtos[], int&amp; quantidade)</code> para coletar nome do produto (string) e preço (double, positivo), formatando como “nome,preco”.</p></li>
<li><p>Validar:</p>
<ul>
<li>Nome não vazio e sem vírgulas (para evitar corromper o formato);</li>
<li>Preço como double positivo, usando <code>stod</code> com tratamento de exceções;</li>
<li>Não zerar <code>quantidade</code> para preservar produtos anteriores no array;</li>
</ul></li>
<li><p>Permitir múltiplos registros até <code>MAX_PRODUTOS</code> (15) ou até o usuário digitar “sair”;</p></li>
<li><p>Tratar buffer de entrada adequadamente (ex.: corrigir uso de <code>std::cin.ignore</code> em C++).</p></li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Escrever a função com entrada via <code>getline</code> para nome e preço;</li>
<li>Validar nome (ex.: <code>if (nome.empty() || nome.find(',') != string::npos)</code> em C++);</li>
<li>Validar preço (ex.: converter com <code>stod</code>, verificar se positivo);</li>
<li>Adicionar string formatada (“nome,preco”) ao array a partir do índice <code>quantidade</code>;</li>
<li>Testar isoladamente com entradas válidas (ex.: “Leite,3.50”) e inválidas (ex.: ““,”Pão,leite”, “-5”).</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>produtos[]</code> e <code>quantidade</code> como parâmetros;</li>
<li>Fornece strings formatadas para <code>salvarProdutos</code> e consultas.</li>
</ul>
<p><strong>Aluno 2</strong>: Função <code>salvarProdutos</code> e Inicialização do Arquivo</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>salvarProdutos(const string produtos[], int quantidade)</code> para gravar produtos em <code>produtos.csv</code> (formato: “Nome,Preco” por linha);</li>
<li>Sobrescrever o arquivo (ex.: <code>std::ios::trunc</code> em C++) para evitar duplicatas;</li>
<li>Implementar <code>inicializarArquivo()</code> para criar o arquivo CSV com cabeçalho “Nome,Preco” se não existir;</li>
<li>Verificar erros ao abrir/escrever no arquivo.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Gravar cada string formatada (“nome,preco”) em uma linha, sobrescrevendo o arquivo;</li>
<li>Preservar o cabeçalho ao sobrescrever;</li>
<li>Verificar abertura do arquivo e exibir mensagens de erro;</li>
<li>Testar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>produtos[]</code> e <code>quantidade</code> de <code>registrarProduto</code>;</li>
<li>Produz um arquivo CSV lido por <code>lerProdutos</code>.</li>
</ul>
<p><strong>Aluno 3</strong>: Função <code>lerProdutos</code> e Carregamento Inicial</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>lerProdutos(string produtos[], int&amp; quantidade, const string&amp; nomeFiltro = "")</code> para ler o arquivo CSV e preencher o array;</li>
<li>Suportar leitura de todos os produtos ou filtragem por nome (substring no campo nome);</li>
<li>Alertar se o arquivo tiver mais registros que <code>MAX_PRODUTOS</code> (15);</li>
<li>Carregar dados do arquivo no início do programa (no <code>main</code>) para sincronizar o array local.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Ler o CSV, ignorar o cabeçalho e preencher o array com strings formatadas;</li>
<li>Implementar filtragem por <code>nomeFiltro</code> quando não vazio (verificar substring no campo nome);</li>
<li>Contar registros e alertar se exceder <code>MAX_PRODUTOS</code>;</li>
<li>Modificar o <code>main</code> para chamar <code>lerProdutos</code> no início;</li>
<li>Testar com arquivos CSV vazios, com menos de 15 registros e com mais de 15.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Lê o arquivo CSV de <code>salvarProdutos</code>;</li>
<li>Fornece dados para <code>buscarProduto</code> e relatório completo.</li>
</ul>
<p><strong>Aluno 4</strong>: Função <code>buscarProduto</code>, Relatório e Interface do Usuário</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>buscarProduto(const string&amp; nome)</code> para exibir produtos cujo nome contenha a substring fornecida, com soma dos preços;</li>
<li>Implementar o relatório completo (opção 3 do menu) para listar todos os produtos e a soma dos preços;</li>
<li>Escrever <code>exibirMenu()</code> e gerenciar a interface no <code>main</code>, corrigindo problemas de buffer (ex.: <code>std::cin.ignore</code> em C++);</li>
<li>Garantir saídas formatadas (ex.: preços com duas casas decimais, mensagens claras);</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Chamar <code>lerProdutos</code> com filtro de nome e exibir resultados com total e soma dos preços;</li>
<li>Implementar relatório completo no <code>main</code>, usando <code>lerProdutos</code> sem filtro;</li>
<li>Corrigir <code>std::cin.ignore</code> no <code>main</code> (ex.: <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code> após leitura de opção);</li>
<li>Testar a interface com busca de nomes existentes/inexistentes e relatórios.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Usa dados de <code>lerProdutos</code> para exibir resultados;</li>
<li>Interage com o usuário, fornecendo nomes para <code>registrarProduto</code> e <code>buscarProduto</code>.</li>
</ul>
</section>
<section id="considerações-para-integração-1" class="level4" data-number="7.2.3.3">
<h4 data-number="7.2.3.3" class="anchored" data-anchor-id="considerações-para-integração-1"><span class="header-section-number">7.2.3.3</span> Considerações para Integração</h4>
<p><strong>Interfaces</strong>:</p>
<ul>
<li>Os alunos devem concordar com a assinatura das funções e o formato do CSV (uma linha por produto, “nome,preco” com cabeçalho);</li>
<li>O array <code>produtos[]</code> armazena strings no formato “nome,preco”, e <code>quantidade</code> rastreia o número de registros.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Cada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos).</li>
</ul>
<p><strong>Passos importantes da integração</strong>:</p>
<ol type="1">
<li>Copiar <code>main</code> e <code>exibirMenu</code> do Aluno 4;</li>
<li>Inserir <code>inicializarArquivo</code> e <code>salvarProdutos</code> do Aluno 2;</li>
<li>Adicionar <code>lerProdutos</code> do Aluno 3, ajustando o <code>main</code> para carregar dados iniciais;</li>
<li>Incluir <code>registrarProduto</code> do Aluno 1 e <code>buscarProduto</code> do Aluno 4.</li>
</ol>
<p><strong>Resolução de conflitos</strong>:</p>
<ul>
<li>Discutir problemas imediatamente na sala (ex.: formato do CSV, tratamento de buffer);</li>
<li>Testar o programa completo com cenários como registrar produtos, buscar por nome e exibir relatórios.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Verificar registro de múltiplos produtos, busca por nome (substring), e relatório completo com soma de preços;</li>
<li>Testar casos extremos (arquivo vazio, nome não encontrado, mais de 15 produtos).</li>
</ul>
</section>
<section id="código-c23-2" class="level4" data-number="7.2.3.4">
<h4 data-number="7.2.3.4" class="anchored" data-anchor-id="código-c23-2"><span class="header-section-number">7.2.3.4</span> Código C++23</h4>
<p>O código correspondente ao problema J2 pode ser encontrado em <a href="https://onlinegdb.com/_Ng8nLlV1">https://onlinegdb.com/_Ng8nLlV1</a>.</p>
</section>
</section>
<section id="k2" class="level3" data-number="7.2.4">
<h3 data-number="7.2.4" class="anchored" data-anchor-id="k2"><span class="header-section-number">7.2.4</span> K2</h3>
<p>Um clube de eventos precisa gerenciar registros de participantes em atividades culturais. Cada participante é registrado com nome, quantidade de eventos que participou e total pago pelas inscrições. O programa deve usar structs para armazenar os dados, salvar em disco e permitir consultas. Desenvolva um sistema que registre participantes, mantenha os dados em structs, salve em um arquivo CSV e permita consultar todos os registros ou os de um participante específico.</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><p><strong>Funções próprias</strong>: registrarParticipante(), salvarParticipantes(), lerParticipantes(), buscarParticipante();</p></li>
<li><p><strong>Funções padrão</strong>: getline(), stoi(), stod(), to_string().</p></li>
<li><p><strong>Entrada</strong>: nome do participante (string), quantidade de eventos (inteiro, 1 a 50), total pago (decimal).</p></li>
<li><p><strong>Saída</strong>: lista de todos os participantes ou registros de um participante específico, com média de eventos e soma dos valores pagos.</p></li>
</ul>
<section id="algoritmização-pseudocódigo-1" class="level4" data-number="7.2.4.1">
<h4 data-number="7.2.4.1" class="anchored" data-anchor-id="algoritmização-pseudocódigo-1"><span class="header-section-number">7.2.4.1</span> Algoritmização: Pseudocódigo</h4>
<pre class="plaintext"><code>ALGORITMO GerenciadorParticipantes

    // Estrutura de dados
    ESTRUTURA Participante
        nome: string
        eventos: inteiro
        totalPago: decimal
    FIM ESTRUTURA

    // Constantes
    MAX_PARTICIPANTES ← 20
    ARQUIVO ← "participantes.csv"

    // Declaração de arrays
    participantes[MAX_PARTICIPANTES]: Participante
    quantidade: inteiro

INÍCIO
    // Inicializar sistema
    ESCREVER "=== Sistema de Gerenciamento de Participantes ==="
    ESCREVER "Inicializando sistema..."
    inicializarArquivo()

    // Carregar dados existentes
    lerParticipantes(participantes, quantidade)

    FAÇA
        exibirMenu()
        ESCREVER "Escolha uma opção: "
        LER opcao

        SE opcao = 1 ENTÃO
            registrarParticipante(participantes, quantidade)
            salvarParticipantes(participantes, quantidade)
            ESCREVER quantidade, " participante(s) registrado(s)."
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite o nome do participante para busca: "
            LER nome
            buscarParticipante(nome)
        SENÃO SE opcao = 3 ENTÃO
            participantesTemp[MAX_PARTICIPANTES]: Participante
            totalRegistros: inteiro
            SE lerParticipantes(participantesTemp, totalRegistros) = FALSO ENTÃO
                ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
            SENÃO
                SE totalRegistros = 0 ENTÃO
                    ESCREVER "Nenhum participante encontrado!"
                SENÃO
                    ESCREVER "=== RELATÓRIO COMPLETO ==="
                    somaEventos ← 0.0
                    somaPagos ← 0.0
                    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
                        ESCREVER "Participante: ", participantesTemp[i].nome, ", Eventos: ", participantesTemp[i].eventos, ", Total Pago: R$", participantesTemp[i].totalPago
                        somaEventos ← somaEventos + participantesTemp[i].eventos
                        somaPagos ← somaPagos + participantesTemp[i].totalPago
                    FIM PARA
                    ESCREVER "Total de participantes: ", totalRegistros
                    ESCREVER "Média de eventos: ", somaEventos / totalRegistros
                    ESCREVER "Soma dos valores pagos: R$", somaPagos
                FIM SE
            FIM SE
        SENÃO SE opcao = 0 ENTÃO
            ESCREVER "Encerrando sistema..."
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE

        SE opcao ≠ 0 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    ENQUANTO opcao ≠ 0

FIM

FUNÇÃO registrarParticipante(participantes: Participante[], quantidade: inteiro): void
INÍCIO
    SE quantidade ≥ MAX_PARTICIPANTES ENTÃO
        ESCREVER "Limite de participantes atingido!"
        RETORNAR
    FIM SE

    FAÇA
        ESCREVER "Digite o nome do participante (ou 'sair' para encerrar): "
        LER nome
        SE nome = "sair" ENTÃO
            RETORNAR
        FIM SE

        SE nome = "" OU nome CONTER "," ENTÃO
            ESCREVER "Nome inválido! Deve ser não vazio e sem vírgulas."
            CONTINUAR
        FIM SE

        ESCREVER "Digite a quantidade de eventos (1-50): "
        LER entradaEventos
        TENTAR
            eventos ← CONVERTER_PARA_INTEIRO(entradaEventos)
            SE eventos ≥ 1 E eventos ≤ 50 ENTÃO
                ESCREVER "Digite o total pago (positivo): "
                LER entradaTotal
                TENTAR
                    total ← CONVERTER_PARA_DOUBLE(entradaTotal)
                    SE total &gt; 0 ENTÃO
                        participantes[quantidade].nome ← nome
                        participantes[quantidade].eventos ← eventos
                        participantes[quantidade].totalPago ← total
                        quantidade ← quantidade + 1
                        SE quantidade = MAX_PARTICIPANTES ENTÃO
                            ESCREVER "Limite de participantes atingido!"
                            RETORNAR
                        FIM SE
                    SENÃO
                        ESCREVER "Total pago inválido! Deve ser positivo."
                    FIM SE
                SENÃO
                    ESCREVER "Valor inválido para total pago. Ignorado."
                FIM TENTAR
            SENÃO
                ESCREVER "Quantidade de eventos fora do intervalo (1-50). Ignorado."
            FIM SE
        SENÃO
            ESCREVER "Valor inválido para eventos. Ignorado."
        FIM TENTAR
    ENQUANTO VERDADEIRO
FIM

FUNÇÃO salvarParticipantes(participantes: Participante[], quantidade: inteiro): void
INÍCIO
    ABRIR arquivo(ARQUIVO, SOBRESCREVER)
    SE arquivo NÃO ABERTO ENTÃO
        ESCREVER "Erro ao abrir arquivo para gravação!"
        RETORNAR
    FIM SE

    ESCREVER_ARQUIVO(arquivo, "Nome,Eventos,TotalPago")
    PARA i DE 0 ATÉ quantidade - 1 FAÇA
        ESCREVER_ARQUIVO(arquivo, participantes[i].nome, ",", participantes[i].eventos, ",", participantes[i].totalPago)
    FIM PARA
    FECHAR arquivo
FIM

FUNÇÃO lerParticipantes(participantes: Participante[], quantidade: inteiro, nomeFiltro: string = ""): booleano
INÍCIO
    ABRIR arquivo(ARQUIVO, LEITURA)
    SE arquivo NÃO ABERTO ENTÃO
        RETORNAR FALSO
    FIM SE

    quantidade ← 0
    LER_LINHA(arquivo, linha)
    SE linha CONTER "Nome" ENTÃO
        // Cabeçalho detectado
    SENÃO
        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)
    FIM SE

    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_PARTICIPANTES FAÇA
        SEPARAR(linha, ",", nome, eventosStr, totalStr)
        SE nomeFiltro = "" OU nome = nomeFiltro ENTÃO
            TENTAR
                eventos ← CONVERTER_PARA_INTEIRO(eventosStr)
                total ← CONVERTER_PARA_DOUBLE(totalStr)
                participantes[quantidade].nome ← nome
                participantes[quantidade].eventos ← eventos
                participantes[quantidade].totalPago ← total
                quantidade ← quantidade + 1
            SENÃO
                // Ignorar linhas inválidas
            FIM TENTAR
        FIM SE
    FIM ENQUANTO

    SE quantidade = MAX_PARTICIPANTES E MAIS_LINHAS(arquivo) ENTÃO
        ESCREVER "Aviso: Mais registros no arquivo do que o limite de ", MAX_PARTICIPANTES
    FIM SE

    FECHAR arquivo
    RETORNAR VERDADEIRO
FIM

FUNÇÃO buscarParticipante(nome: string): void
INÍCIO
    participantesTemp[MAX_PARTICIPANTES]: Participante
    totalRegistros: inteiro

    SE lerParticipantes(participantesTemp, totalRegistros, nome) = FALSO ENTÃO
        ESCREVER "Erro ao ler dados!"
        RETORNAR
    FIM SE

    SE totalRegistros = 0 ENTÃO
        ESCREVER "Nenhum participante encontrado para '", nome, "'!"
        RETORNAR
    FIM SE

    ESCREVER "=== REGISTROS DE ", nome, " ==="
    somaEventos ← 0.0
    somaPagos ← 0.0
    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
        ESCREVER "Participante: ", participantesTemp[i].nome, ", Eventos: ", participantesTemp[i].eventos, ", Total Pago: R$", participantesTemp[i].totalPago
        somaEventos ← somaEventos + participantesTemp[i].eventos
        somaPagos ← somaPagos + participantesTemp[i].totalPago
    FIM PARA
    ESCREVER "Total de registros: ", totalRegistros
    ESCREVER "Média de eventos: ", somaEventos / totalRegistros
    ESCREVER "Soma dos valores pagos: R$", somaPagos
FIM

FUNÇÃO inicializarArquivo(): void
INÍCIO
    SE ARQUIVO NÃO EXISTIR ENTÃO
        ABRIR arquivo(ARQUIVO, ESCRITA)
        SE arquivo ABERTO ENTÃO
            ESCREVER_ARQUIVO(arquivo, "Nome,Eventos,TotalPago")
            FECHAR arquivo
            ESCREVER "Arquivo de dados criado: ", ARQUIVO
        SENÃO
            ESCREVER "Erro ao criar arquivo de dados!"
        FIM SE
    SENÃO
        ESCREVER "Arquivo de dados encontrado: ", ARQUIVO
    FIM SE
FIM

FUNÇÃO exibirMenu(): void
INÍCIO
    ESCREVER "=== MENU PRINCIPAL ==="
    ESCREVER "1. Registrar participante"
    ESCREVER "2. Buscar participante por nome"
    ESCREVER "3. Relatório completo"
    ESCREVER "0. Sair"
FIM</code></pre>
</section>
<section id="decomposição-divisão-de-tarefas-para-o-problema-k2" class="level4" data-number="7.2.4.2">
<h4 data-number="7.2.4.2" class="anchored" data-anchor-id="decomposição-divisão-de-tarefas-para-o-problema-k2"><span class="header-section-number">7.2.4.2</span> Decomposição: Divisão de Tarefas para o Problema K2</h4>
<p>O problema <strong>K2</strong> propõe um sistema para gerenciar registros de participantes em atividades culturais, usando structs para armazenar nome, quantidade de eventos e total pago, com persistência em arquivo CSV e funcionalidades de registro, salvamento, leitura e busca por nome. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.</p>
<p><strong>Aluno 1</strong>: Função <code>registrarParticipante</code> e Validação de Entrada</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li><p>Implementar <code>registrarParticipante(Participante participantes[], int&amp; quantidade)</code> para coletar nome (string), quantidade de eventos (inteiro, 1 a 50) e total pago (double, positivo);</p></li>
<li><p>Validar:</p>
<ul>
<li>Nome não vazio e sem vírgulas (para evitar corromper o CSV);</li>
<li>Quantidade de eventos entre 1 e 50, usando <code>stoi</code> com tratamento de exceções;</li>
<li>Total pago como double positivo, usando <code>stod</code> com tratamento de exceções;</li>
<li>Não zerar <code>quantidade</code> para preservar registros anteriores;</li>
</ul></li>
<li><p>Permitir múltiplos registros até <code>MAX_PARTICIPANTES</code> (definido como 20, por exemplo) ou até o usuário digitar “sair”;</p></li>
<li><p>Tratar buffer de entrada adequadamente (ex.: corrigir uso de <code>std::cin.ignore</code> em C++).</p></li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Escrever a função com entrada via <code>getline</code> para nome, eventos e total pago;</li>
<li>Validar nome (ex.: <code>if (nome.empty() || nome.find(',') != string::npos)</code> em C++);</li>
<li>Validar eventos (ex.: converter com <code>stoi</code>, verificar intervalo 1-50);</li>
<li>Validar total pago (ex.: converter com <code>stod</code>, verificar se positivo);</li>
<li>Adicionar dados à struct <code>Participante</code> no array a partir do índice <code>quantidade</code>;</li>
<li>Testar isoladamente com entradas válidas (ex.: “Ana,5,100.50”) e inválidas (ex.: ““,”João,pão”, “0”, “-10”).</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>participantes[]</code> e <code>quantidade</code> como parâmetros;</li>
<li>Fornece dados válidos para <code>salvarParticipantes</code> e consultas.</li>
</ul>
<p><strong>Aluno 2</strong>: Função <code>salvarParticipantes</code> e Inicialização do Arquivo</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>salvarParticipantes(const Participante participantes[], int quantidade)</code> para gravar registros em <code>participantes.csv</code> (formato: “Nome,Eventos,TotalPago”);</li>
<li>Sobrescrever o arquivo (ex.: <code>std::ios::trunc</code> em C++) para evitar duplicatas;</li>
<li>Implementar <code>inicializarArquivo()</code> para criar o arquivo CSV com cabeçalho “Nome,Eventos,TotalPago” se não existir;</li>
<li>Verificar erros ao abrir/escrever no arquivo.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Gravar cada registro (nome, eventos, total pago) em uma linha do CSV, sobrescrevendo o arquivo;</li>
<li>Preservar o cabeçalho ao sobrescrever;</li>
<li>Verificar abertura do arquivo e exibir mensagens de erro;</li>
<li>Testar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>participantes[]</code> e <code>quantidade</code> de <code>registrarParticipante</code>;</li>
<li>Produz um arquivo CSV lido por <code>lerParticipantes</code>.</li>
</ul>
<p><strong>Aluno 3</strong>: Função <code>lerParticipantes</code> e Carregamento Inicial</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>lerParticipantes(Participante participantes[], int&amp; quantidade, const string&amp; nomeFiltro = "")</code> para ler o arquivo CSV e preencher o array de structs;</li>
<li>Suportar leitura de todos os registros ou filtragem por nome (exato ou substring);</li>
<li>Alertar se o arquivo tiver mais registros que <code>MAX_PARTICIPANTES</code>;</li>
<li>Carregar dados do arquivo no início do programa (no <code>main</code>) para sincronizar o array local.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Ler o CSV, ignorar o cabeçalho e preencher o array de structs;</li>
<li>Implementar filtragem por <code>nomeFiltro</code> quando não vazio (ex.: verificar igualdade ou substring no campo nome);</li>
<li>Contar registros e alertar se exceder <code>MAX_PARTICIPANTES</code>;</li>
<li>Modificar o <code>main</code> para chamar <code>lerParticipantes</code> no início;</li>
<li>Testar com arquivos CSV vazios, com menos de 20 registros e com mais de 20.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Lê o arquivo CSV de <code>salvarParticipantes</code>;</li>
<li>Fornece dados para <code>buscarParticipante</code> e relatório completo.</li>
</ul>
<p><strong>Aluno 4</strong>: Função <code>buscarParticipante</code>, Relatório e Interface do Usuário</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>buscarParticipante(const string&amp; nome)</code> para exibir registros de um participante, com média de eventos e soma dos valores pagos;</li>
<li>Implementar o relatório completo (opção 3 do menu) para listar todos os participantes, com média de eventos e soma total dos valores pagos;</li>
<li>Escrever <code>exibirMenu()</code> e gerenciar a interface no <code>main</code>, corrigindo problemas de buffer (ex.: <code>std::cin.ignore</code> em C++);</li>
<li>Garantir saídas formatadas (ex.: preços com duas casas decimais, média com uma casa decimal, mensagens claras).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Chamar <code>lerParticipantes</code> com filtro de nome e exibir resultados com total, média de eventos e soma dos valores pagos;</li>
<li>Implementar relatório completo no <code>main</code>, usando <code>lerParticipantes</code> sem filtro;</li>
<li>Corrigir <code>std::cin.ignore</code> no <code>main</code> (ex.: <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code> após leitura de opção);</li>
<li>Testar a interface com busca de nomes existentes/inexistentes e relatórios.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Usa dados de <code>lerParticipantes</code> para exibir resultados;</li>
<li>Interage com o usuário, fornecendo nomes para <code>registrarParticipante</code> e <code>buscarParticipante</code>.</li>
</ul>
</section>
<section id="considerações-para-integração-2" class="level4" data-number="7.2.4.3">
<h4 data-number="7.2.4.3" class="anchored" data-anchor-id="considerações-para-integração-2"><span class="header-section-number">7.2.4.3</span> Considerações para Integração</h4>
<p><strong>Interfaces</strong>:</p>
<ul>
<li>Os alunos devem concordar com a estrutura da <code>struct</code> <code>Participante</code> (campos: nome, eventos, totalPago) e o formato do CSV (“Nome,Eventos,TotalPago” com cabeçalho);</li>
<li>O array <code>participantes[]</code> armazena <code>structs</code>, e <code>quantidade</code> rastreia o número de registros.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Cada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos).</li>
</ul>
<p><strong>Passos importantes da integração</strong>:</p>
<ol type="1">
<li>Copiar <code>main</code> e <code>exibirMenu</code> do Aluno 4;</li>
<li>Inserir <code>inicializarArquivo</code> e <code>salvarParticipantes</code> do Aluno 2;</li>
<li>Adicionar <code>lerParticipantes</code> do Aluno 3, ajustando o <code>main</code> para carregar dados iniciais;</li>
<li>Incluir <code>registrarParticipante</code> do Aluno 1 e <code>buscarParticipante</code> do Aluno 4.</li>
</ol>
<p><strong>Resolução de conflitos</strong>:</p>
<ul>
<li>Discutir problemas imediatamente na sala (ex.: formato do CSV, tratamento de buffer);</li>
<li>Testar o programa completo com cenários como registrar participantes, buscar por nome e exibir relatórios.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Verificar registro de múltiplos participantes, busca por nome, e relatório completo com média de eventos e soma de valores;</li>
<li>Testar casos extremos (arquivo vazio, nome não encontrado, mais de 20 participantes).</li>
</ul>
</section>
<section id="código-c23-3" class="level4" data-number="7.2.4.4">
<h4 data-number="7.2.4.4" class="anchored" data-anchor-id="código-c23-3"><span class="header-section-number">7.2.4.4</span> Código C++23</h4>
<p>O código correspondente ao problema K2 pode ser encontrado em <a href="https://onlinegdb.com/HPGcXEHrR">https://onlinegdb.com/HPGcXEHrR</a>.</p>
</section>
</section>
<section id="l2" class="level3" data-number="7.2.5">
<h3 data-number="7.2.5" class="anchored" data-anchor-id="l2"><span class="header-section-number">7.2.5</span> L2</h3>
<p>A prefeitura instalou sensores de temperatura pela cidade e precisa processar os dados coletados durante um mês. O sistema deve armazenar todas as temperaturas, identificar padrões climáticos, calcular estatísticas detalhadas e gerar relatórios para o departamento de meio ambiente. Desenvolva um programa que armazene até <span class="math inline">\(30\)</span> temperaturas diárias em um array, calcule a temperatura média do dia e do mês, identifique as temperaturas máxima e mínima, no dia e no mês, calcule desvio padrão e identifique dias com temperaturas extremas. Para isso o programa deve manter em disco um arquivo, csv, com data, hora e valor de cada temperatura registrada.</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><strong>Funções próprias</strong>: <code>lerTemperaturas()</code>, <code>gravarTemperaturas()</code>, <code>lerDadosTemperaturas()</code>, <code>calcularEstatisticas()</code>, <code>encontrarExtremos()</code>, <code>calcularDesvio()</code></li>
<li><strong>Funções padrão</strong>: <code>abs()</code>, <code>round()</code>, <code>sqrt()</code></li>
</ul>
<p><strong>Entrada</strong>: um valor de temperatura por hora, ou até 30 valores de uma vez na linha de comando, separados por vírgulas. Os valores de temperatura estão em graus Celsius, com uma casa decimal.</p>
<p><strong>Saída</strong>: Relatório completo com médias, extremos, desvio padrão e análise de tendências. O usuário pode escolher um dia específico para ver as temperaturas registradas, ou o relatório completo de um mês específico.</p>
<section id="algoritmização-pseudocódigo-2" class="level4" data-number="7.2.5.1">
<h4 data-number="7.2.5.1" class="anchored" data-anchor-id="algoritmização-pseudocódigo-2"><span class="header-section-number">7.2.5.1</span> Algoritmização: Pseudocódigo</h4>
<pre class="plaintext"><code>ALGORITMO GerenciadorTemperaturas

    // Constantes
    MAX_TEMPERATURAS ← 30
    ARQUIVO ← "temperaturas.csv"

    // Declaração de arrays
    temperaturas[MAX_TEMPERATURAS]: real

INÍCIO
    // Inicializar sistema
    ESCREVER "=== Sistema de Gerenciamento de Temperaturas ==="
    ESCREVER "Inicializando sistema..."
    inicializarArquivo()

    FAÇA
        exibirMenu()
        ESCREVER "Escolha uma opção: "
        LER opcao

        SE opcao = 1 ENTÃO
            ESCREVER "Digite a data (DD/MM/AAAA): "
            LER data
            quantidade ← 0
            SE VALIDAR_DATA(data) ENTÃO
                lerTemperaturas(temperaturas, quantidade, data)
                gravarTemperaturas(temperaturas, quantidade, data)
                ESCREVER quantidade, " temperatura(s) registrada(s)."
            SENÃO
                ESCREVER "Data inválida! Use o formato DD/MM/AAAA."
            FIM SE
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite a data para busca (DD/MM/AAAA, ou vazio para todas): "
            LER dataFiltro
            SE dataFiltro = "" OU VALIDAR_DATA(dataFiltro) ENTÃO
                quantidade ← 0
                SE lerDadosTemperaturas(temperaturas, quantidade, dataFiltro) = FALSO ENTÃO
                    ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
                SENÃO SE quantidade = 0 ENTÃO
                    ESCREVER "Nenhuma temperatura encontrada para a data!"
                SENÃO
                    media ← 0.0
                    minima ← 0.0
                    maxima ← 0.0
                    calcularEstatisticas(temperaturas, quantidade, media)
                    encontrarExtremos(temperaturas, quantidade, minima, maxima)
                    desvio ← calcularDesvio(temperaturas, quantidade, media)
                    ESCREVER "=== RELATÓRIO PARA ", dataFiltro, " ==="
                    PARA i DE 0 ATÉ quantidade - 1 FAÇA
                        ESCREVER "Hora: ", FORMATAR_HORA(i), ", Temperatura: ", temperaturas[i], "°C"
                    FIM PARA
                    ESCREVER "Total de temperaturas: ", quantidade
                    ESCREVER "Média: ", ARREDONDAR(media, 1), "°C"
                    ESCREVER "Mínima: ", ARREDONDAR(minima, 1), "°C"
                    ESCREVER "Máxima: ", ARREDONDAR(maxima, 1), "°C"
                    ESCREVER "Desvio padrão: ", ARREDONDAR(desvio, 2), "°C"
                FIM SE
            SENÃO
                ESCREVER "Data inválida! Use o formato DD/MM/AAAA."
            FIM SE
        SENÃO SE opcao = 3 ENTÃO
            // Relatório mensal (supõe que o usuário escolhe um mês/ano)
            ESCREVER "Digite o mês e ano (MM/AAAA): "
            LER mesAno
            SE VALIDAR_MES_ANO(mesAno) ENTÃO
                temperaturasTemp[MAX_TEMPERATURAS]: real
                totalRegistros ← 0
                diasExtremos: vetor dinâmico de string
                mediaMensal ← 0.0
                minimaMensal ← 0.0
                maximaMensal ← 0.0
                SE lerDadosTemperaturas(temperaturasTemp, totalRegistros, "") = FALSO ENTÃO
                    ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
                SENÃO SE totalRegistros = 0 ENTÃO
                    ESCREVER "Nenhuma temperatura encontrada!"
                SENÃO
                    ESCREVER "=== RELATÓRIO MENSAL PARA ", mesAno, " ==="
                    soma ← 0.0
                    contagemTotal ← 0
                    PARA CADA data NO ARQUIVO QUE CORRESPONDE A mesAno FAÇA
                        quantidade ← 0
                        lerDadosTemperaturas(temperaturasTemp, quantidade, data)
                        SE quantidade &gt; 0 ENTÃO
                            mediaDia ← 0.0
                            minimaDia ← 0.0
                            maximaDia ← 0.0
                            calcularEstatisticas(temperaturasTemp, quantidade, mediaDia)
                            encontrarExtremos(temperaturasTemp, quantidade, minimaDia, maximaDia)
                            desvioDia ← calcularDesvio(temperaturasTemp, quantidade, mediaDia)
                            soma ← soma + mediaDia * quantidade
                            contagemTotal ← contagemTotal + quantidade
                            SE minimaDia &lt; minimaMensal OU minimaMensal = 0 ENTÃO
                                minimaMensal ← minimaDia
                            FIM SE
                            SE maximaDia &gt; maximaMensal ENTÃO
                                maximaMensal ← maximaDia
                            FIM SE
                            SE ABS(mediaDia - mediaMensal) &gt; 2 * desvioDia ENTÃO
                                diasExtremos.ADICIONAR(data)
                            FIM SE
                        FIM SE
                    FIM PARA
                    mediaMensal ← soma / contagemTotal
                    desvioMensal ← calcularDesvio(temperaturasTemp, totalRegistros, mediaMensal)
                    ESCREVER "Média mensal: ", ARREDONDAR(mediaMensal, 1), "°C"
                    ESCREVER "Mínima mensal: ", ARREDONDAR(minimaMensal, 1), "°C"
                    ESCREVER "Máxima mensal: ", ARREDONDAR(maximaMensal, 1), "°C"
                    ESCREVER "Desvio padrão mensal: ", ARREDONDAR(desvioMensal, 2), "°C"
                    ESCREVER "Dias com temperaturas extremas: "
                    SE tamanho(diasExtremos) = 0 ENTÃO
                        ESCREVER "Nenhum dia extremo identificado."
                    SENÃO
                        PARA CADA dia EM diasExtremos FAÇA
                            ESCREVER dia
                        FIM PARA
                    FIM SE
                FIM SE
            SENÃO
                ESCREVER "Mês/ano inválido! Use o formato MM/AAAA."
            FIM SE
        SENÃO SE opcao = 0 ENTÃO
            ESCREVER "Encerrando sistema..."
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE

        SE opcao ≠ 0 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    ENQUANTO opcao ≠ 0

FIM

FUNÇÃO lerTemperaturas(temperaturas: real[], quantidade: inteiro, data: string): void
INÍCIO
    SE quantidade ≥ MAX_TEMPERATURAS ENTÃO
        ESCREVER "Limite de temperaturas atingido!"
        RETORNAR
    FIM SE

    ESCREVER "Digite as temperaturas (separadas por vírgulas, ou 'sair'): "
    LER entrada
    SE entrada = "sair" ENTÃO
        RETORNAR
    FIM SE

    SEPARAR(entrada, ",", valores)
    PARA CADA valor EM valores FAÇA
        SE quantidade ≥ MAX_TEMPERATURAS ENTÃO
            ESCREVER "Limite de temperaturas atingido!"
            RETORNAR
        FIM SE
        TENTAR
            temp ← CONVERTER_PARA_REAL(valor)
            temp ← ARREDONDAR(temp, 1)
            temperaturas[quantidade] ← temp
            quantidade ← quantidade + 1
        SENÃO
            ESCREVER "Valor inválido: ", valor, ". Ignorado."
        FIM TENTAR
    FIM PARA
FIM

FUNÇÃO gravarTemperaturas(temperaturas: real[], quantidade: inteiro, data: string): void
INÍCIO
    ABRIR arquivo(ARQUIVO, APPEND)
    SE arquivo NÃO ABERTO ENTÃO
        ESCREVER "Erro ao abrir arquivo para gravação!"
        RETORNAR
    FIM SE

    PARA i DE 0 ATÉ quantidade - 1 FAÇA
        ESCREVER_ARQUIVO(arquivo, data, ",", FORMATAR_HORA(i), ",", ARREDONDAR(temperaturas[i], 1))
    FIM PARA
    FECHAR arquivo
FIM

FUNÇÃO lerDadosTemperaturas(temperaturas: real[], quantidade: inteiro, dataFiltro: string = ""): booleano
INÍCIO
    ABRIR arquivo(ARQUIVO, LEITURA)
    SE arquivo NÃO ABERTO ENTÃO
        RETORNAR FALSO
    FIM SE

    quantidade ← 0
    LER_LINHA(arquivo, linha)
    SE linha CONTER "Data" ENTÃO
        // Cabeçalho detectado
    SENÃO
        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)
    FIM SE

    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_TEMPERATURAS FAÇA
        SEPARAR(linha, ",", data, hora, tempStr)
        SE dataFiltro = "" OU data = dataFiltro ENTÃO
            TENTAR
                temp ← CONVERTER_PARA_REAL(tempStr)
                temperaturas[quantidade] ← ARREDONDAR(temp, 1)
                quantidade ← quantidade + 1
            SENÃO
                // Ignorar linhas inválidas
            FIM TENTAR
        FIM SE
    FIM ENQUANTO

    SE quantidade = MAX_TEMPERATURAS E MAIS_LINHAS(arquivo) ENTÃO
        ESCREVER "Aviso: Mais registros para a data do que o limite de ", MAX_TEMPERATURAS
    FIM SE

    FECHAR arquivo
    RETORNAR VERDADEIRO
FIM

FUNÇÃO calcularEstatisticas(temperaturas: real[], quantidade: inteiro, media: real): void
INÍCIO
    SE quantidade = 0 ENTÃO
        media ← 0.0
        RETORNAR
    FIM SE
    soma ← 0.0
    PARA i DE 0 ATÉ quantidade - 1 FAÇA
        soma ← soma + temperaturas[i]
    FIM PARA
    media ← soma / quantidade
FIM

FUNÇÃO encontrarExtremos(temperaturas: real[], quantidade: inteiro, minima: real, maxima: real): void
INÍCIO
    SE quantidade = 0 ENTÃO
        minima ← 0.0
        maxima ← 0.0
        RETORNAR
    FIM SE
    minima ← temperaturas[0]
    maxima ← temperaturas[0]
    PARA i DE 1 ATÉ quantidade - 1 FAÇA
        SE temperaturas[i] &lt; minima ENTÃO
            minima ← temperaturas[i]
        FIM SE
        SE temperaturas[i] &gt; maxima ENTÃO
            maxima ← temperaturas[i]
        FIM SE
    FIM PARA
FIM

FUNÇÃO calcularDesvio(temperaturas: real[], quantidade: inteiro, media: real): real
INÍCIO
    SE quantidade = 0 ENTÃO
        RETORNAR 0.0
    FIM SE
    soma ← 0.0
    PARA i DE 0 ATÉ quantidade - 1 FAÇA
        soma ← soma + (temperaturas[i] - media) * (temperaturas[i] - media)
    FIM PARA
    RETORNAR RAIZ_QUADRADA(soma / quantidade)
FIM

FUNÇÃO exibirMenu(): void
INÍCIO
    ESCREVER "=== MENU PRINCIPAL ==="
    ESCREVER "1. Registrar temperaturas"
    ESCREVER "2. Relatório por dia"
    ESCREVER "3. Relatório mensal"
    ESCREVER "0. Sair"
FIM

FUNÇÃO VALIDAR_DATA(data: string): booleano
INÍCIO
    SE tamanho(data) ≠ 10 OU data[2] ≠ '/' OU data[5] ≠ '/' ENTÃO
        RETORNAR FALSO
    FIM SE
    TENTAR
        dia ← CONVERTER_PARA_INTEIRO(data[0:2])
        mes ← CONVERTER_PARA_INTEIRO(data[3:5])
        ano ← CONVERTER_PARA_INTEIRO(data[6:10])
        SE dia ≥ 1 E dia ≤ 31 E mes ≥ 1 E mes ≤ 12 E ano ≥ 2000 E ano ≤ 2100 ENTÃO
            RETORNAR VERDADEIRO
        FIM SE
    SENÃO
        RETORNAR FALSO
    FIM TENTAR
    RETORNAR FALSO
FIM

FUNÇÃO VALIDAR_MES_ANO(mesAno: string): booleano
INÍCIO
    SE tamanho(mesAno) ≠ 7 OU mesAno[2] ≠ '/' ENTÃO
        RETORNAR FALSO
    FIM SE
    TENTAR
        mes ← CONVERTER_PARA_INTEIRO(mesAno[0:2])
        ano ← CONVERTER_PARA_INTEIRO(mesAno[3:7])
        SE mes ≥ 1 E mes ≤ 12 E ano ≥ 2000 E ano ≤ 2100 ENTÃO
            RETORNAR VERDADEIRO
        FIM SE
    SENÃO
        RETORNAR FALSO
    FIM TENTAR
    RETORNAR FALSO
FIM

FUNÇÃO FORMATAR_HORA(indice: inteiro): string
INÍCIO
    hora ← indice
    RETORNAR to_string(hora) + ":00"
FIM</code></pre>
</section>
<section id="decomposição-divisão-de-tarefas-para-o-problema-l2" class="level4" data-number="7.2.5.2">
<h4 data-number="7.2.5.2" class="anchored" data-anchor-id="decomposição-divisão-de-tarefas-para-o-problema-l2"><span class="header-section-number">7.2.5.2</span> Decomposição: Divisão de Tarefas para o Problema L2</h4>
<p>O problema <strong>L2</strong> propõe um sistema para gerenciar dados de temperatura coletados por sensores durante um mês, armazenando até 30 temperaturas diárias em um array, salvando em um arquivo CSV e gerando estatísticas (média, extremos, desvio padrão) e relatórios. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.</p>
<p><strong>Aluno 1</strong>: Função <code>lerTemperaturas</code> e Validação de Entrada</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>lerTemperaturas(float temperaturas[], int&amp; quantidade, string data)</code> para coletar até 30 temperaturas diárias (em °C, com uma casa decimal) via linha de comando, separadas por vírgulas, associadas a uma data específica.</li>
<li>Validar:
<ul>
<li>Temperaturas como valores <code>float</code>, com uma casa decimal (ex.: 23.5);</li>
<li>Quantidade de temperaturas não exceder 30;</li>
<li>Data no formato “DD/MM/AAAA” (ex.: 01/07/2025);</li>
<li>Não zerar <code>quantidade</code> para preservar registros anteriores;</li>
</ul></li>
<li>Permitir entrada de múltiplas temperaturas em uma única linha (ex.: “23.5,24.0,22.8”) ou uma por vez até o usuário indicar “sair”;</li>
<li>Tratar buffer de entrada adequadamente (ex.: corrigir uso de <code>std::cin.ignore</code> em C++).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Escrever a função com entrada via <code>getline</code> para data e temperaturas;</li>
<li>Validar data (ex.: verificar formato “DD/MM/AAAA” com 10 caracteres e barras corretas);</li>
<li>Validar temperaturas (ex.: converter com <code>stod</code>, verificar uma casa decimal usando <code>round</code>);</li>
<li>Adicionar temperaturas ao array a partir do índice <code>quantidade</code>;</li>
<li>Testar isoladamente com entradas válidas (ex.: “01/07/2025,23.5,24.0”) e inválidas (ex.: “01-07-2025”, “23.55”, ““).</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>temperaturas[]</code>, <code>quantidade</code> e <code>data</code> como parâmetros;</li>
<li>Fornece dados válidos para <code>gravarTemperaturas</code> e análises.</li>
</ul>
<p><strong>Aluno 2</strong>: Função <code>gravarTemperaturas</code> e Inicialização do Arquivo</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>gravarTemperaturas(const float temperaturas[], int quantidade, const string&amp; data)</code> para gravar temperaturas em <code>temperaturas.csv</code> (formato: “Data,Hora,Temperatura”);</li>
<li>Adicionar registros ao arquivo (ex.: <code>std::ios::app</code> em C++) sem sobrescrever dados anteriores;</li>
<li>Implementar <code>inicializarArquivo()</code> para criar o arquivo CSV com cabeçalho “Data,Hora,Temperatura” se não existir;</li>
<li>Verificar erros ao abrir/escrever no arquivo.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Gravar cada temperatura com data, hora (ex.: “00:00” a “23:00”) e valor em uma linha do CSV;</li>
<li>Verificar abertura do arquivo e exibir mensagens de erro;</li>
<li>Testar isoladamente com diferentes quantidades de temperaturas e verificar o arquivo gerado.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>temperaturas[]</code>, <code>quantidade</code> e <code>data</code> de <code>lerTemperaturas</code>;</li>
<li>Produz um arquivo CSV lido por <code>lerDadosTemperaturas</code>.</li>
</ul>
<p><strong>Aluno 3</strong>: Função <code>lerDadosTemperaturas</code> e Carregamento Inicial</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>lerDadosTemperaturas(float temperaturas[], int&amp; quantidade, const string&amp; dataFiltro = "")</code> para ler o arquivo CSV e preencher o array com temperaturas de um dia específico ou todos os dados;</li>
<li>Suportar filtragem por <code>dataFiltro</code> (ex.: “01/07/2025”) ou leitura completa se vazio;</li>
<li>Alertar se o número de temperaturas exceder 30 para um dia;</li>
<li>Carregar dados do arquivo no início do programa (no <code>main</code>) para sincronizar o array local;</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Ler o CSV, ignorar o cabeçalho e preencher o array com temperaturas;</li>
<li>Implementar filtragem por <code>dataFiltro</code> quando não vazio;</li>
<li>Contar registros e alertar se exceder 30 por dia;</li>
<li>Modificar o <code>main</code> para chamar <code>lerDadosTemperaturas</code> no início;</li>
<li>Testar com arquivos CSV vazios, com menos de 30 temperaturas e com múltiplos dias.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Lê o arquivo CSV de <code>gravarTemperaturas</code>;</li>
<li>Fornece dados para <code>calcularEstatisticas</code> e <code>encontrarExtremos</code>.</li>
</ul>
<p><strong>Aluno 4</strong>: Funções <code>calcularEstatisticas</code>, <code>encontrarExtremos</code>, <code>calcularDesvio</code>, Relatório e Interface do Usuário</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>calcularEstatisticas(const float temperaturas[], int quantidade, float&amp; media)</code> para calcular a média das temperaturas;</li>
<li>Implementar <code>encontrarExtremos(const float temperaturas[], int quantidade, float&amp; minima, float&amp; maxima)</code> para identificar temperaturas mínima e máxima;</li>
<li>Implementar <code>calcularDesvio(const float temperaturas[], int quantidade, float media)</code> para calcular o desvio padrão;</li>
<li>Implementar o relatório completo (opção 3 do menu) para listar estatísticas do mês (média, extremos, desvio padrão, dias com temperaturas extremas);</li>
<li>Escrever <code>exibirMenu()</code> e gerenciar a interface no <code>main</code>, corrigindo problemas de buffer (ex.: <code>std::cin.ignore</code> em C++);</li>
<li>Garantir saídas formatadas (ex.: uma casa decimal para temperaturas e média, duas casas para desvio padrão).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Calcular média, extremos e desvio padrão para um dia ou mês;</li>
<li>Identificar dias com temperaturas extremas (ex.: fora de 2 desvios padrão da média mensal);</li>
<li>Chamar <code>lerDadosTemperaturas</code> com filtro de data para relatórios diários;</li>
<li>Implementar relatório completo no <code>main</code>, usando <code>lerDadosTemperaturas</code> sem filtro;</li>
<li>Corrigir <code>std::cin.ignore</code> no <code>main</code> (ex.: <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code> após leitura de opção);</li>
<li>Testar com busca de dias existentes/inexistentes, relatórios diários e mensais.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Usa dados de <code>lerDadosTemperaturas</code> para exibir resultados;</li>
<li>Interage com o usuário, fornecendo datas para <code>lerTemperaturas</code> e relatórios.</li>
</ul>
</section>
<section id="considerações-para-integração-3" class="level4" data-number="7.2.5.3">
<h4 data-number="7.2.5.3" class="anchored" data-anchor-id="considerações-para-integração-3"><span class="header-section-number">7.2.5.3</span> Considerações para Integração</h4>
<p><strong>Interfaces</strong>:</p>
<ul>
<li>Os alunos devem concordar com o formato do CSV (“Data,Hora,Temperatura”) e a estrutura do array <code>temperaturas[]</code>;</li>
<li>O array armazena até 30 temperaturas por dia, e <code>quantidade</code> rastreia o número de registros.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Cada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos);</li>
</ul>
<p><strong>Passos importantes da integração</strong>:</p>
<ol type="1">
<li>Copiar <code>main</code> e <code>exibirMenu</code> do Aluno 4;</li>
<li>Inserir <code>inicializarArquivo</code> e <code>gravarTemperaturas</code> do Aluno 2;</li>
<li>Adicionar <code>lerDadosTemperaturas</code> do Aluno 3, ajustando o <code>main</code> para carregar dados iniciais;</li>
<li>Incluir <code>lerTemperaturas</code> do Aluno 1, <code>calcularEstatisticas</code>, <code>encontrarExtremos</code> e <code>calcularDesvio</code> do Aluno 4.</li>
</ol>
<p><strong>Resolução de conflitos</strong>:</p>
<ul>
<li>Discutir problemas imediatamente na sala (ex.: formato do CSV, validação de data);</li>
<li>Testar o programa completo com cenários como registrar temperaturas, buscar por dia e exibir relatórios.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Verificar registro de temperaturas, busca por dia, e relatório mensal com estatísticas;</li>
<li>Testar casos extremos (arquivo vazio, data inválida, mais de 30 temperaturas).</li>
</ul>
</section>
<section id="código-c23-4" class="level4" data-number="7.2.5.4">
<h4 data-number="7.2.5.4" class="anchored" data-anchor-id="código-c23-4"><span class="header-section-number">7.2.5.4</span> Código C++23</h4>
<p>O código correspondente ao problema L2 pode ser encontrado em <a href="https://onlinegdb.com/zAYiGjouh">https://onlinegdb.com/zAYiGjouh</a>.</p>
</section>
</section>
<section id="m2" class="level3" data-number="7.2.6">
<h3 data-number="7.2.6" class="anchored" data-anchor-id="m2"><span class="header-section-number">7.2.6</span> M2</h3>
<p>Um laboratório de pesquisas precisa de uma calculadora que mantenha histórico completo das operações para auditoria e análise posterior. A calculadora deve realizar operações complexas e permitir análise estatística do histórico. Desenvolva uma calculadora científica que execute operações matemáticas avançadas, mantenha um array com histórico das operações, permita buscar operações anteriores e calcule estatísticas sobre o uso.</p>
<p><strong>Funções a implementar</strong>:</p>
<ul>
<li><strong>Funções próprias</strong>: <code>adicionarHistorico()</code>, <code>mostrarHistorico()</code>, <code>buscarOperacao()</code>, <code>analisarUso()</code></li>
<li><strong>Funções padrão</strong>: <code>sin()</code>, <code>cos()</code>, <code>tan()</code>, <code>exp()</code>, <code>log10()</code></li>
</ul>
<p><strong>Entrada</strong>: Expressões matemáticas e comandos de histórico <strong>Saída</strong>: Resultados, histórico completo e análises estatísticas de uso</p>
<section id="algoritmização-pseudocódigo-3" class="level4" data-number="7.2.6.1">
<h4 data-number="7.2.6.1" class="anchored" data-anchor-id="algoritmização-pseudocódigo-3"><span class="header-section-number">7.2.6.1</span> Algoritmização: Pseudocódigo</h4>
<pre class="plaintext"><code>ALGORITMO CalculadoraCientifica

    // Constantes
    MAX_OPERACOES ← 100
    ARQUIVO ← "historico.csv"

    // Declaração de arrays
    historico[MAX_OPERACOES]: string
    quantidade: inteiro

INÍCIO
    // Inicializar sistema
    ESCREVER "=== Calculadora Científica com Histórico ==="
    ESCREVER "Inicializando sistema..."
    inicializarArquivo()

    // Carregar dados existentes
    mostrarHistorico(historico, quantidade)

    FAÇA
        exibirMenu()
        ESCREVER "Escolha uma opção: "
        LER opcao

        SE opcao = 1 ENTÃO
            ESCREVER "Digite a expressão matemática (ou 'sair'): "
            LER expressao
            SE expressao ≠ "sair" ENTÃO
                SE VALIDAR_EXPRESSAO(expressao) ENTÃO
                    resultado ← CALCULAR_EXPRESSAO(expressao)
                    adicionarHistorico(historico, quantidade, expressao, resultado)
                    gravarHistorico(historico, quantidade)
                    ESCREVER "Resultado: ", ARREDONDAR(resultado, 2)
                SENÃO
                    ESCREVER "Expressão inválida! Use sin(), cos(), tan(), exp(), log10() ou operações básicas."
                FIM SE
            FIM SE
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite a expressão para busca (ex.: 'sin', ou vazio para todas): "
            LER expressaoFiltro
            buscarOperacao(expressaoFiltro)
        SENÃO SE opcao = 3 ENTÃO
            historicoTemp[MAX_OPERACOES]: string
            totalRegistros: inteiro
            SE mostrarHistorico(historicoTemp, totalRegistros) = FALSO ENTÃO
                ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
            SENÃO SE totalRegistros = 0 ENTÃO
                ESCREVER "Nenhuma operação encontrada!"
            SENÃO
                ESCREVER "=== RELATÓRIO COMPLETO ==="
                PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
                    SEPARAR(historicoTemp[i], ",", expressao, resultadoStr)
                    TENTAR
                        resultado ← CONVERTER_PARA_REAL(resultadoStr)
                        ESCREVER "Operação ", i + 1, ": ", expressao, " = ", ARREDONDAR(resultado, 2)
                    SENÃO
                        ESCREVER "Erro ao processar resultado em: ", historicoTemp[i]
                    FIM TENTAR
                FIM PARA
                ESCREVER "Total de operações: ", totalRegistros
                analisarUso(historicoTemp, totalRegistros)
            FIM SE
        SENÃO SE opcao = 0 ENTÃO
            ESCREVER "Encerrando sistema..."
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE

        SE opcao ≠ 0 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    ENQUANTO opcao ≠ 0

FIM

FUNÇÃO adicionarHistorico(historico: string[], quantidade: inteiro, expressao: string, resultado: real): void
INÍCIO
    SE quantidade ≥ MAX_OPERACOES ENTÃO
        ESCREVER "Limite de operações atingido!"
        RETORNAR
    FIM SE

    SE expressao = "" OU expressao CONTER "," ENTÃO
        ESCREVER "Expressão inválida! Deve ser não vazia e sem vírgulas."
        RETORNAR
    FIM SE

    historico[quantidade] ← expressao + "," + to_string(ARREDONDAR(resultado, 2))
    quantidade ← quantidade + 1
FIM

FUNÇÃO gravarHistorico(historico: string[], quantidade: inteiro): void
INÍCIO
    ABRIR arquivo(ARQUIVO, APPEND)
    SE arquivo NÃO ABERTO ENTÃO
        ESCREVER "Erro ao abrir arquivo para gravação!"
        RETORNAR
    FIM SE

    PARA i DE quantidade - 1 ATÉ quantidade - 1 FAÇA
        ESCREVER_ARQUIVO(arquivo, historico[i])
    FIM PARA
    FECHAR arquivo
FIM

FUNÇÃO mostrarHistorico(historico: string[], quantidade: inteiro, expressaoFiltro: string = ""): booleano
INÍCIO
    ABRIR arquivo(ARQUIVO, LEITURA)
    SE arquivo NÃO ABERTO ENTÃO
        RETORNAR FALSO
    FIM SE

    quantidade ← 0
    LER_LINHA(arquivo, linha)
    SE linha CONTER "Expressao" ENTÃO
        // Cabeçalho detectado
    SENÃO
        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)
    FIM SE

    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_OPERACOES FAÇA
        SEPARAR(linha, ",", expressao, resultadoStr)
        SE expressaoFiltro = "" OU expressao CONTER expressaoFiltro ENTÃO
            TENTAR
                resultado ← CONVERTER_PARA_REAL(resultadoStr)
                historico[quantidade] ← linha
                quantidade ← quantidade + 1
            SENÃO
                // Ignorar linhas inválidas
            FIM TENTAR
        FIM SE
    FIM ENQUANTO

    SE quantidade = MAX_OPERACOES E MAIS_LINHAS(arquivo) ENTÃO
        ESCREVER "Aviso: Mais registros no arquivo do que o limite de ", MAX_OPERACOES
    FIM SE

    FECHAR arquivo
    RETORNAR VERDADEIRO
FIM

FUNÇÃO buscarOperacao(expressao: string): void
INÍCIO
    historicoTemp[MAX_OPERACOES]: string
    totalRegistros: inteiro

    SE mostrarHistorico(historicoTemp, totalRegistros, expressao) = FALSO ENTÃO
        ESCREVER "Erro ao ler dados!"
        RETORNAR
    FIM SE

    SE totalRegistros = 0 ENTÃO
        ESCREVER "Nenhuma operação encontrada para '", expressao, "'!"
        RETORNAR
    FIM SE

    ESCREVER "=== OPERAÇÕES COM '", expressao, "' ==="
    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
        SEPARAR(historicoTemp[i], ",", expressaoEncontrada, resultadoStr)
        TENTAR
            resultado ← CONVERTER_PARA_REAL(resultadoStr)
            ESCREVER "Operação ", i + 1, ": ", expressaoEncontrada, " = ", ARREDONDAR(resultado, 2)
        SENÃO
            ESCREVER "Erro ao processar resultado em: ", historicoTemp[i]
        FIM TENTAR
    FIM PARA
    ESCREVER "Total de operações encontradas: ", totalRegistros
FIM

FUNÇÃO analisarUso(historico: string[], quantidade: inteiro): void
INÍCIO
    contSin ← 0
    contCos ← 0
    contTan ← 0
    contExp ← 0
    contLog ← 0
    contOutros ← 0

    PARA i DE 0 ATÉ quantidade - 1 FAÇA
        SEPARAR(historico[i], ",", expressao, resultadoStr)
        SE expressao CONTER "sin(" ENTÃO
            contSin ← contSin + 1
        SENÃO SE expressao CONTER "cos(" ENTÃO
            contCos ← contCos + 1
        SENÃO SE expressao CONTER "tan(" ENTÃO
            contTan ← contTan + 1
        SENÃO SE expressao CONTER "exp(" ENTÃO
            contExp ← contExp + 1
        SENÃO SE expressao CONTER "log10(" ENTÃO
            contLog ← contLog + 1
        SENÃO
            contOutros ← contOutros + 1
        FIM SE
    FIM PARA

    ESCREVER "=== ANÁLISE DE USO ==="
    ESCREVER "Operações com sin: ", contSin
    ESCREVER "Operações com cos: ", contCos
    ESCREVER "Operações com tan: ", contTan
    ESCREVER "Operações com exp: ", contExp
    ESCREVER "Operações com log10: ", contLog
    ESCREVER "Outras operações: ", contOutros
FIM

FUNÇÃO inicializarArquivo(): void
INÍCIO
    SE ARQUIVO NÃO EXISTIR ENTÃO
        ABRIR arquivo(ARQUIVO, ESCRITA)
        SE arquivo ABERTO ENTÃO
            ESCREVER_ARQUIVO(arquivo, "Expressao,Resultado")
            FECHAR arquivo
            ESCREVER "Arquivo de dados criado: ", ARQUIVO
        SENÃO
            ESCREVER "Erro ao criar arquivo de dados!"
        FIM SE
    SENÃO
        ESCREVER "Arquivo de dados encontrado: ", ARQUIVO
    FIM SE
FIM

FUNÇÃO exibirMenu(): void
INÍCIO
    ESCREVER "=== MENU PRINCIPAL ==="
    ESCREVER "1. Realizar operação"
    ESCREVER "2. Buscar operações por expressão"
    ESCREVER "3. Relatório completo"
    ESCREVER "0. Sair"
FIM

FUNÇÃO VALIDAR_EXPRESSAO(expressao: string): booleano
INÍCIO
    SE expressao = "" ENTÃO
        RETORNAR FALSO
    FIM SE
    // Verifica se a expressão contém funções válidas ou operações básicas
    SE expressao CONTER "sin(" OU expressao CONTER "cos(" OU expressao CONTER "tan(" OU
       expressao CONTER "exp(" OU expressao CONTER "log10(" OU
       expressao CONTER "+" OU expressao CONTER "-" OU expressao CONTER "*" OU expressao CONTER "/" ENTÃO
        RETORNAR VERDADEIRO
    FIM SE
    RETORNAR FALSO
FIM

FUNÇÃO CALCULAR_EXPRESSAO(expressao: string): real
INÍCIO
    // Implementação simplificada: supõe que a expressão é válida e usa funções padrão
    SE expressao CONTER "sin(" ENTÃO
        valor ← EXTRAIR_NUMERO(expressao)
        RETORNAR SIN(valor)
    SENÃO SE expressao CONTER "cos(" ENTÃO
        valor ← EXTRAIR_NUMERO(expressao)
        RETORNAR COS(valor)
    SENÃO SE expressao CONTER "tan(" ENTÃO
        valor ← EXTRAIR_NUMERO(expressao)
        RETORNAR TAN(valor)
    SENÃO SE expressao CONTER "exp(" ENTÃO
        valor ← EXTRAIR_NUMERO(expressao)
        RETORNAR EXP(valor)
    SENÃO SE expressao CONTER "log10(" ENTÃO
        valor ← EXTRAIR_NUMERO(expressao)
        RETORNAR LOG10(valor)
    SENÃO
        // Supõe operação básica (ex.: "2 + 3")
        TENTAR
            resultado ← AVALIAR_OPERACAO_BASICA(expressao)
            RETORNAR resultado
        SENÃO
            RETORNAR 0.0
        FIM TENTAR
    FIM SE
FIM</code></pre>
</section>
<section id="decomposição-divisão-de-tarefas-para-o-problema-m2" class="level4" data-number="7.2.6.2">
<h4 data-number="7.2.6.2" class="anchored" data-anchor-id="decomposição-divisão-de-tarefas-para-o-problema-m2"><span class="header-section-number">7.2.6.2</span> Decomposição: Divisão de Tarefas para o Problema M2</h4>
<p>O problema <strong>M2</strong> propõe uma calculadora científica que executa operações matemáticas avançadas, armazena um histórico de operações em um array, permite consultas ao histórico e realiza análises estatísticas do uso. O histórico é salvo em um arquivo CSV para auditoria. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.</p>
<p><strong>Aluno 1</strong>: Função <code>adicionarHistorico</code> e Validação de Entrada</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>adicionarHistorico(string historico[], int&amp; quantidade, string expressao, real resultado)</code> para coletar e armazenar expressões matemáticas (string) e seus resultados (real) no array de histórico;</li>
<li>Validar:
<ul>
<li>Expressão não vazia e sem vírgulas (para evitar corromper o CSV);</li>
<li>Resultado como número real válido;</li>
<li>Quantidade não exceder <code>MAX_OPERACOES</code> (definido como 100, por exemplo);</li>
</ul></li>
<li>Interpretar expressões matemáticas (ex.: “sin(3.14)”, “2 + 3 * 4”, “log10(100)”) e calcular resultados usando <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>exp</code>, <code>log10</code>;</li>
<li>Tratar buffer de entrada adequadamente (ex.: corrigir uso de <code>std::cin.ignore</code> em C++).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Escrever a função para ler expressões via <code>getline</code> e calcular resultados;</li>
<li>Validar expressão (ex.: <code>if (expressao.empty() || expressao.find(',') != string::npos)</code> em C++);</li>
<li>Adicionar par “expressao,resultado” ao array a partir do índice <code>quantidade</code>;</li>
<li>Testar isoladamente com expressões válidas (ex.: “sin(0)”, “2 + 2”) e inválidas (ex.: ““,”sin,a”).</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>historico[]</code>, <code>quantidade</code>, <code>expressao</code> e <code>resultado</code> como parâmetros;</li>
<li>Fornece dados válidos para <code>gravarHistorico</code> e análises.</li>
</ul>
<p><strong>Aluno 2</strong>: Função <code>gravarHistorico</code> e Inicialização do Arquivo</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>gravarHistorico(const string historico[], int quantidade)</code> para gravar o histórico em <code>historico.csv</code> (formato: “Expressao,Resultado”);</li>
<li>Adicionar registros ao arquivo (ex.: <code>std::ios::app</code> em C++) para preservar o histórico anterior;</li>
<li>Implementar <code>inicializarArquivo()</code> para criar o arquivo CSV com cabeçalho “Expressao,Resultado” se não existir;</li>
<li>Verificar erros ao abrir/escrever no arquivo.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Gravar cada entrada do histórico (expressão e resultado) em uma linha do CSV;</li>
<li>Verificar abertura do arquivo e exibir mensagens de erro;</li>
<li>Testar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>historico[]</code> e <code>quantidade</code> de <code>adicionarHistorico</code>;</li>
<li>Produz um arquivo CSV lido por <code>mostrarHistorico</code>.</li>
</ul>
<p><strong>Aluno 3</strong>: Função <code>mostrarHistorico</code> e Carregamento Inicial</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>mostrarHistorico(string historico[], int&amp; quantidade, const string&amp; expressaoFiltro = "")</code> para ler o arquivo CSV e preencher o array com o histórico, filtrando por expressão (<em>substring</em>) se especificado;</li>
<li>Suportar leitura de todo o histórico ou filtragem por <code>expressaoFiltro</code>;</li>
<li>Alertar se o número de operações exceder <code>MAX_OPERACOES</code>;</li>
<li>Carregar dados do arquivo no início do programa (no <code>main</code>) para sincronizar o array local.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Ler o CSV, ignorar o cabeçalho e preencher o array com strings no formato “expressao,resultado”;</li>
<li>Implementar filtragem por <code>expressaoFiltro</code> quando não vazio;</li>
<li>Contar registros e alertar se exceder <code>MAX_OPERACOES</code>;</li>
<li>Modificar o <code>main</code> para chamar <code>mostrarHistorico</code> no início;</li>
<li>Testar com arquivos CSV vazios, com poucas operações e com mais de 100.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Lê o arquivo CSV de <code>gravarHistorico</code>;</li>
<li>Fornece dados para <code>buscarOperacao</code> e análises.</li>
</ul>
<p><strong>Aluno 4</strong>: Função <code>buscarOperacao</code>, <code>analisarUso</code>, Relatório e Interface do Usuário</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>buscarOperacao(const string&amp; expressao)</code> para exibir operações cujo nome (ex.: “sin”, “cos”) ou expressão completa contenha a substring fornecida;</li>
<li>Implementar <code>analisarUso(const string historico[], int quantidade)</code> para calcular estatísticas de uso (ex.: número de operações por tipo, frequência de cada função);</li>
<li>Implementar o relatório completo (opção 3 do menu) para listar todo o histórico e estatísticas de uso;</li>
<li>Escrever <code>exibirMenu()</code> e gerenciar a interface no <code>main</code>, corrigindo problemas de buffer (ex.: <code>std::cin.ignore</code> em C++);</li>
<li>Garantir saídas formatadas (ex.: resultados com duas casas decimais, mensagens claras).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Chamar <code>mostrarHistorico</code> com filtro de expressão para buscas;</li>
<li>Implementar análise estatística (ex.: contar uso de <code>sin</code>, <code>cos</code>, etc.);</li>
<li>Implementar relatório completo no <code>main</code>, usando <code>mostrarHistorico</code> sem filtro;</li>
<li>Corrigir <code>std::cin.ignore</code> no <code>main</code> (ex.: <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code> após leitura de opção);</li>
<li>Testar com busca de expressões existentes/inexistentes e relatórios.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Usa dados de <code>mostrarHistorico</code> para exibir resultados;</li>
<li>Interage com o usuário, fornecendo expressões para <code>adicionarHistorico</code> e <code>buscarOperacao</code>.</li>
</ul>
</section>
<section id="considerações-para-integração-4" class="level4" data-number="7.2.6.3">
<h4 data-number="7.2.6.3" class="anchored" data-anchor-id="considerações-para-integração-4"><span class="header-section-number">7.2.6.3</span> Considerações para Integração</h4>
<p><strong>Interfaces</strong>:</p>
<ul>
<li>Os alunos devem concordar com o formato do CSV (“Expressao,Resultado”) e a estrutura do array <code>historico[]</code> (strings no formato “expressao,resultado”);</li>
<li>O array armazena até <code>MAX_OPERACOES</code> entradas, e <code>quantidade</code> rastreia o número de registros.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Cada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos).</li>
</ul>
<p><strong>Passos importantes da integração</strong>:</p>
<ol type="1">
<li>Copiar <code>main</code> e <code>exibirMenu</code> do Aluno 4;</li>
<li>Inserir <code>inicializarArquivo</code> e <code>gravarHistorico</code> do Aluno 2;</li>
<li>Adicionar <code>mostrarHistorico</code> do Aluno 3, ajustando o <code>main</code> para carregar dados iniciais;</li>
<li>Incluir <code>adicionarHistorico</code>, <code>buscarOperacao</code> e <code>analisarUso</code> do Aluno 4.</li>
</ol>
<p><strong>Resolução de conflitos</strong>:</p>
<ul>
<li>Discutir problemas imediatamente na sala (ex.: formato do CSV, validação de expressões);</li>
<li>Testar o programa completo com cenários como adicionar operações, buscar por expressão e exibir relatórios.</li>
</ul>
<p><strong>Depuração</strong>:</p>
<ul>
<li>Verificar registro de operações, busca por expressão, e relatório com estatísticas.</li>
<li>Testar casos extremos (arquivo vazio, expressão inválida, mais de 100 operações).</li>
</ul>
</section>
<section id="código-c23-5" class="level4" data-number="7.2.6.4">
<h4 data-number="7.2.6.4" class="anchored" data-anchor-id="código-c23-5"><span class="header-section-number">7.2.6.4</span> Código C++23</h4>
<p>O código correspondente ao problema M2 pode ser encontrado em <a href="https://onlinegdb.com/UHaBupDCz">https://onlinegdb.com/UHaBupDCz</a>.</p>
</section>
</section>
<section id="n2" class="level3" data-number="7.2.7">
<h3 data-number="7.2.7" class="anchored" data-anchor-id="n2"><span class="header-section-number">7.2.7</span> N2</h3>
<p>Uma loja de departamentos precisa organizar as vendas diárias por categoria de produtos. Cada categoria (ex.: “Roupas”, “Eletrônicos”) contém uma lista de valores de vendas (decimais). O programa deve usar vetores de vetores para armazenar as vendas, salvar em disco e permitir consultas. Desenvolva um sistema que registre vendas por categoria, mantenha os dados em vetores de vetores, salve em um arquivo CSV e permita consultar todas as vendas ou as de uma categoria específica.</p>
<p><strong>Funções a implementar:</strong></p>
<ul>
<li><strong>Funções próprias:</strong> <code>registrarVendas()</code>, <code>salvarVendas()</code>, <code>lerVendas()</code>, <code>buscarVendasCategoria()</code></li>
<li><strong>Funções padrão:</strong> <code>getline()</code>, <code>stod()</code>, <code>to_string()</code></li>
</ul>
<p><strong>Entrada:</strong> Nome da categoria (string) e valores de vendas (decimais, positivos) <strong>Saída:</strong> Lista de todas as vendas por categoria ou vendas de uma categoria específica, com soma total das vendas</p>
<section id="algoritmização-pseudocódigo-4" class="level4" data-number="7.2.7.1">
<h4 data-number="7.2.7.1" class="anchored" data-anchor-id="algoritmização-pseudocódigo-4"><span class="header-section-number">7.2.7.1</span> Algoritmização: Pseudocódigo</h4>
<pre class="plaintext"><code>ALGORITMO GerenciadorVendas

    // Constantes
    MAX_CATEGORIAS ← 50
    ARQUIVO ← "vendas.csv"

    // Declaração de vetores
    vendas: vetor de vetores de real
    categorias: vetor de string
    numCategorias: inteiro

INÍCIO
    // Inicializar sistema
    ESCREVER "=== Sistema de Gerenciamento de Vendas ==="
    ESCREVER "Inicializando sistema..."
    inicializarArquivo()

    // Carregar dados existentes
    lerVendas(vendas, categorias, numCategorias)

    FAÇA
        exibirMenu()
        ESCREVER "Escolha uma opção: "
        LER opcao

        SE opcao = 1 ENTÃO
            registrarVendas(vendas, categorias, numCategorias)
            salvarVendas(vendas, categorias, numCategorias)
            ESCREVER "Venda(s) registrada(s)."
        SENÃO SE opcao = 2 ENTÃO
            ESCREVER "Digite a categoria para busca: "
            LER categoria
            buscarVendasCategoria(categoria)
        SENÃO SE opcao = 3 ENTÃO
            vendasTemp: vetor de vetores de real
            categoriasTemp: vetor de string
            totalRegistros: inteiro
            SE lerVendas(vendasTemp, categoriasTemp, totalRegistros) = FALSO ENTÃO
                ESCREVER "Erro ao ler dados ou arquivo não encontrado!"
            SENÃO SE totalRegistros = 0 ENTÃO
                ESCREVER "Nenhuma venda encontrada!"
            SENÃO
                ESCREVER "=== RELATÓRIO COMPLETO ==="
                somaTotal ← 0.0
                PARA i DE 0 ATÉ totalRegistros - 1 FAÇA
                    ESCREVER "Categoria: ", categoriasTemp[i]
                    somaCategoria ← 0.0
                    PARA CADA valor EM vendasTemp[i] FAÇA
                        ESCREVER "  Venda: R$", ARREDONDAR(valor, 2)
                        somaCategoria ← somaCategoria + valor
                    FIM PARA
                    ESCREVER "  Soma da categoria: R$", ARREDONDAR(somaCategoria, 2)
                    somaTotal ← somaTotal + somaCategoria
                FIM PARA
                ESCREVER "Total de categorias: ", totalRegistros
                ESCREVER "Soma total das vendas: R$", ARREDONDAR(somaTotal, 2)
            FIM SE
        SENÃO SE opcao = 0 ENTÃO
            ESCREVER "Encerrando sistema..."
        SENÃO
            ESCREVER "Opção inválida! Tente novamente."
        FIM SE

        SE opcao ≠ 0 ENTÃO
            ESCREVER "Pressione Enter para continuar..."
            LER pausa
        FIM SE
    ENQUANTO opcao ≠ 0

FIM

FUNÇÃO registrarVendas(vendas: vetor de vetores de real, categorias: vetor de string, numCategorias: inteiro): void
INÍCIO
    FAÇA
        ESCREVER "Digite a categoria (ou 'sair' para encerrar): "
        LER categoria
        SE categoria = "sair" ENTÃO
            RETORNAR
        FIM SE

        SE categoria = "" OU categoria CONTER "," ENTÃO
            ESCREVER "Categoria inválida! Deve ser não vazia e sem vírgulas."
            CONTINUAR
        FIM SE

        indiceCategoria ← -1
        PARA i DE 0 ATÉ numCategorias - 1 FAÇA
            SE categorias[i] = categoria ENTÃO
                indiceCategoria ← i
                SAIR
            FIM SE
        FIM PARA

        SE indiceCategoria = -1 ENTÃO
            SE numCategorias ≥ MAX_CATEGORIAS ENTÃO
                ESCREVER "Limite de categorias atingido!"
                RETORNAR
            FIM SE
            categorias[numCategorias] ← categoria
            vendas[numCategorias]: novo vetor de real
            indiceCategoria ← numCategorias
            numCategorias ← numCategorias + 1
        FIM SE

        ESCREVER "Digite o valor da venda (positivo, ou 'sair'): "
        LER entrada
        SE entrada = "sair" ENTÃO
            CONTINUAR
        FIM SE

        TENTAR
            valor ← CONVERTER_PARA_REAL(entrada)
            SE valor &gt; 0 ENTÃO
                vendas[indiceCategoria].ADICIONAR(valor)
            SENÃO
                ESCREVER "Valor inválido! Deve ser positivo."
            FIM SE
        SENÃO
            ESCREVER "Valor inválido para venda. Ignorado."
        FIM TENTAR
    ENQUANTO VERDADEIRO
FIM

FUNÇÃO salvarVendas(vendas: vetor de vetores de real, categorias: vetor de string, numCategorias: inteiro): void
INÍCIO
    ABRIR arquivo(ARQUIVO, SOBRESCREVER)
    SE arquivo NÃO ABERTO ENTÃO
        ESCREVER "Erro ao abrir arquivo para gravação!"
        RETORNAR
    FIM SE

    ESCREVER_ARQUIVO(arquivo, "Categoria,Valor")
    PARA i DE 0 ATÉ numCategorias - 1 FAÇA
        PARA CADA valor EM vendas[i] FAÇA
            ESCREVER_ARQUIVO(arquivo, categorias[i], ",", ARREDONDAR(valor, 2))
        FIM PARA
    FIM PARA
    FECHAR arquivo
FIM

FUNÇÃO lerVendas(vendas: vetor de vetores de real, categorias: vetor de string, numCategorias: inteiro, categoriaFiltro: string = ""): booleano
INÍCIO
    ABRIR arquivo(ARQUIVO, LEITURA)
    SE arquivo NÃO ABERTO ENTÃO
        RETORNAR FALSO
    FIM SE

    numCategorias ← 0
    vendas.LIMPAR()
    categorias.LIMPAR()

    LER_LINHA(arquivo, linha)
    SE linha CONTER "Categoria" ENTÃO
        // Cabeçalho detectado
    SENÃO
        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)
    FIM SE

    ENQUANTO LER_LINHA(arquivo, linha) FAÇA
        SEPARAR(linha, ",", categoria, valorStr)
        SE categoriaFiltro = "" OU categoria = categoriaFiltro ENTÃO
            TENTAR
                valor ← CONVERTER_PARA_REAL(valorStr)
                indiceCategoria ← -1
                PARA i DE 0 ATÉ numCategorias - 1 FAÇA
                    SE categorias[i] = categoria ENTÃO
                        indiceCategoria ← i
                        SAIR
                    FIM SE
                FIM PARA
                SE indiceCategoria = -1 ENTÃO
                    categorias[numCategorias] ← categoria
                    vendas[numCategorias]: novo vetor de real
                    indiceCategoria ← numCategorias
                    numCategorias ← numCategorias + 1
                FIM SE
                vendas[indiceCategoria].ADICIONAR(valor)
            SENÃO
                // Ignorar linhas inválidas
            FIM TENTAR
        FIM SE
    FIM ENQUANTO

    FECHAR arquivo
    RETORNAR VERDADEIRO
FIM

FUNÇÃO buscarVendasCategoria(categoria: string): void
INÍCIO
    vendasTemp: vetor de vetores de real
    categoriasTemp: vetor de string
    totalRegistros: inteiro

    SE lerVendas(vendasTemp, categoriasTemp, totalRegistros, categoria) = FALSO ENTÃO
        ESCREVER "Erro ao ler dados!"
        RETORNAR
    FIM SE

    SE totalRegistros = 0 ENTÃO
        ESCREVER "Nenhuma venda encontrada para '", categoria, "'!"
        RETORNAR
    FIM SE

    ESCREVER "=== VENDAS DA CATEGORIA ", categoria, " ==="
    somaCategoria ← 0.0
    PARA CADA valor EM vendasTemp[0] FAÇA
        ESCREVER "Venda: R$", ARREDONDAR(valor, 2)
        somaCategoria ← somaCategoria + valor
    FIM PARA
    ESCREVER "Soma da categoria: R$", ARREDONDAR(somaCategoria, 2)
    ESCREVER "Total de vendas: ", tamanho(vendasTemp[0])
FIM

FUNÇÃO inicializarArquivo(): void
INÍCIO
    SE ARQUIVO NÃO EXISTIR ENTÃO
        ABRIR arquivo(ARQUIVO, ESCRITA)
        SE arquivo ABERTO ENTÃO
            ESCREVER_ARQUIVO(arquivo, "Categoria,Valor")
            FECHAR arquivo
            ESCREVER "Arquivo de dados criado: ", ARQUIVO
        SENÃO
            ESCREVER "Erro ao criar arquivo de dados!"
        FIM SE
    SENÃO
        ESCREVER "Arquivo de dados encontrado: ", ARQUIVO
    FIM SE
FIM

FUNÇÃO exibirMenu(): void
INÍCIO
    ESCREVER "=== MENU PRINCIPAL ==="
    ESCREVER "1. Registrar vendas"
    ESCREVER "2. Buscar vendas por categoria"
    ESCREVER "3. Relatório completo"
    ESCREVER "0. Sair"
FIM</code></pre>
</section>
<section id="decomposição-divisão-de-tarefas-para-o-problema-n2" class="level4" data-number="7.2.7.2">
<h4 data-number="7.2.7.2" class="anchored" data-anchor-id="decomposição-divisão-de-tarefas-para-o-problema-n2"><span class="header-section-number">7.2.7.2</span> Decomposição: Divisão de Tarefas para o Problema N2</h4>
<p>O problema <strong>N2</strong> propõe um sistema para gerenciar vendas diárias de uma loja de departamentos, organizadas por categorias de produtos, usando vetores de vetores para armazenar valores de vendas (decimais), com persistência em arquivo CSV e funcionalidades de registro, salvamento, leitura e consulta por categoria. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.</p>
<p><strong>Aluno 1</strong>: Função <code>registrarVendas</code> e Validação de Entrada</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>registrarVendas(vetor de vetores de real vendas, vetor de string categorias, inteiro&amp; numCategorias)</code> para coletar nome da categoria (string) e valores de vendas (decimais, positivos).</li>
<li>Validar:
<ul>
<li>Nome da categoria não vazio e sem vírgulas (para evitar corromper o CSV);</li>
<li>Valores de vendas como decimais positivos, usando <code>stod</code> com tratamento de exceções;</li>
<li>Permitir múltiplas vendas por categoria até o usuário indicar “sair”;</li>
</ul></li>
<li>Adicionar nova categoria ao vetor <code>categorias</code> se não existir, ou atualizar o vetor de vendas da categoria existente.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Escrever a função com entrada via <code>getline</code> para categoria e valores de vendas;</li>
<li>Validar categoria (ex.: <code>if (categoria.empty() || categoria.find(',') != string::npos)</code> em C++);</li>
<li>Validar vendas (ex.: converter com <code>stod</code>, verificar se positivo);</li>
<li>Adicionar vendas ao vetor de vetores, criando nova entrada em <code>categorias</code> se necessário;</li>
<li>Testar isoladamente com entradas válidas (ex.: “Roupas,29.99,49.99”) e inválidas (ex.: ““,”Eletrônicos,pão”, “-10.0”).</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>vendas</code> (vetor de vetores de real), <code>categorias</code> (vetor de string) e <code>numCategorias</code> como parâmetros;</li>
<li>Fornece dados válidos para <code>salvarVendas</code> e consultas.</li>
</ul>
<p><strong>Aluno 2</strong>: Função <code>salvarVendas</code> e Inicialização do Arquivo</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>salvarVendas(const vetor de vetores de real vendas, const vetor de string categorias, inteiro numCategorias)</code> para gravar vendas em <code>vendas.csv</code> (formato: “Categoria,Valor”);</li>
<li>Sobrescrever o arquivo (ex.: <code>std::ios::trunc</code> em C++) para evitar duplicatas;</li>
<li>Implementar <code>inicializarArquivo()</code> para criar o arquivo CSV com cabeçalho “Categoria,Valor” se não existir.</li>
<li>Verificar erros ao abrir/escrever no arquivo;</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Gravar cada venda com sua categoria em uma linha do CSV, sobrescrevendo o arquivo;</li>
<li>Preservar o cabeçalho ao sobrescrever;</li>
<li>Verificar abertura do arquivo e exibir mensagens de erro;</li>
<li>Testar isoladamente com diferentes tamanhos de vetores e verificar o arquivo gerado.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Recebe <code>vendas</code>, <code>categorias</code> e <code>numCategorias</code> de <code>registrarVendas</code>;</li>
<li>Produz um arquivo CSV lido por <code>lerVendas</code>.</li>
</ul>
<p><strong>Aluno 3</strong>: Função <code>lerVendas</code> e Carregamento Inicial</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>lerVendas(vetor de vetores de real vendas, vetor de string categorias, inteiro&amp; numCategorias, const string&amp; categoriaFiltro = "")</code> para ler o arquivo CSV e preencher os vetores;</li>
<li>Suportar leitura de todas as vendas ou filtragem por categoria (exata);</li>
<li>Carregar dados do arquivo no início do programa (no <code>main</code>) para sincronizar os vetores locais.</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Ler o CSV, ignorar o cabeçalho e preencher <code>vendas</code> e <code>categorias</code>;</li>
<li>Implementar filtragem por <code>categoriaFiltro</code> quando não vazio;</li>
<li>Modificar o <code>main</code> para chamar <code>lerVendas</code> no início;</li>
<li>Testar com arquivos CSV vazios, com poucas vendas e com múltiplas categorias.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Lê o arquivo CSV de <code>salvarVendas</code>;</li>
<li>Fornece dados para <code>buscarVendasCategoria</code> e relatório completo.</li>
</ul>
<p><strong>Aluno 4</strong>: Função <code>buscarVendasCategoria</code>, Relatório e Interface do Usuário</p>
<p><strong>Responsabilidades</strong>:</p>
<ul>
<li>Implementar <code>buscarVendasCategoria(const string&amp; categoria)</code> para exibir vendas de uma categoria específica, com soma dos valores;</li>
<li>Implementar o relatório completo (opção 3 do menu) para listar todas as vendas por categoria e a soma total;</li>
<li>Escrever <code>exibirMenu()</code> e gerenciar a interface no <code>main</code>, corrigindo problemas de buffer (ex.: <code>std::cin.ignore</code> em C++);</li>
<li>Garantir saídas formatadas (ex.: valores com duas casas decimais, mensagens claras).</li>
</ul>
<p><strong>Tarefas específicas</strong>:</p>
<ul>
<li>Chamar <code>lerVendas</code> com filtro de categoria e exibir resultados com soma;</li>
<li>Implementar relatório completo no <code>main</code>, usando <code>lerVendas</code> sem filtro;</li>
<li>Corrigir <code>std::cin.ignore</code> no <code>main</code> (ex.: <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code> após leitura de opção);</li>
<li>Testar com busca de categorias existentes/inexistentes e relatórios.</li>
</ul>
<p><strong>Interface</strong>:</p>
<ul>
<li>Usa dados de <code>lerVendas</code> para exibir resultados;</li>
<li>Interage com o usuário, fornecendo categorias para <code>registrarVendas</code> e <code>buscarVendasCategoria</code>.</li>
</ul>
</section>
<section id="considerações-para-integração-5" class="level4" data-number="7.2.7.3">
<h4 data-number="7.2.7.3" class="anchored" data-anchor-id="considerações-para-integração-5"><span class="header-section-number">7.2.7.3</span> Considerações para Integração</h4>
<p><strong>Interfaces</strong>:</p>
<ul>
<li>Os alunos devem concordar com o formato do CSV (“Categoria,Valor”) e a estrutura dos vetores (<code>vendas</code> como vetor de vetores de real, <code>categorias</code> como vetor de string);</li>
<li>O número de categorias é rastreado por <code>numCategorias</code>.</li>
</ul>
<p><strong>Testes unitários</strong>:</p>
<ul>
<li>Cada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, vetores pré-preenchidos).</li>
</ul>
<p><strong>Passos importantes da integração</strong>:</p>
<ol type="1">
<li>Copiar <code>main</code> e <code>exibirMenu</code> do Aluno 4;</li>
<li>Inserir <code>inicializarArquivo</code> e <code>salvarVendas</code> do Aluno 2;</li>
<li>Adicionar <code>lerVendas</code> do Aluno 3, ajustando o <code>main</code> para carregar dados iniciais;</li>
<li>Incluir <code>registrarVendas</code> do Aluno 1 e <code>buscarVendasCategoria</code> do Aluno 4.</li>
</ol>
<p><strong>Resolução de conflitos</strong>:</p>
<ul>
<li>Discutir problemas imediatamente na sala (ex.: formato do CSV, tratamento de buffer);</li>
<li>Testar o programa completo com cenários como registrar vendas, buscar por categoria e exibir relatórios.</li>
</ul>
<p><strong>Teste conjunto</strong>:</p>
<ul>
<li>Verificar registro de vendas, busca por categoria, e relatório completo com soma total;</li>
<li>Testar casos extremos (arquivo vazio, categoria não encontrada, múltiplas vendas);</li>
</ul>
</section>
<section id="código-c23-6" class="level4" data-number="7.2.7.4">
<h4 data-number="7.2.7.4" class="anchored" data-anchor-id="código-c23-6"><span class="header-section-number">7.2.7.4</span> Código C++23</h4>
<p>O código correspondente ao problema N2 pode ser encontrado em <a href="https://onlinegdb.com/t5M4rGaOm3">https://onlinegdb.com/t5M4rGaOm3</a>.</p>


<div id="refs" class="references csl-bib-body" data-entry-spacing="1" role="list" style="display: none">
<div id="ref-PythonDocs" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">PYTHON SOFTWARE FOUNDATION. <strong><span>The Python Language Reference</span></strong>. Disponível em: &lt;<a href="https://docs.python.org/3/reference/index.html">https://docs.python.org/3/reference/index.html</a>&gt;. Acesso em: 13 jul. 2025. </div>
</div>
<div id="ref-ISO_CPP20" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. <strong><span class="nocase">Information technology – Programming languages – C++</span></strong>. Geneva, Switzerland: <span>International Organization for Standardization (ISO)</span>, 2020. Disponível em: &lt;<a href="https://isocpp.org/std/the-standard">https://isocpp.org/std/the-standard</a>&gt;.</div>
</div>
</div>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./desenv1.html" class="pagination-link" aria-label="**Módulo 1**: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title"><strong>Módulo 1</strong>: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./desenv3.html" class="pagination-link" aria-label="**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title"><strong>Módulo 3</strong>: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linefollower/edit/main/desenv2.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linefollower/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>