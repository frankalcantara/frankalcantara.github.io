<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Linguagens Formais e Autômatos - 7&nbsp; Conjuntos FIRST e FOLLOW</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./07-parserLR1.html" rel="next">
<link href="./05-parsersLL1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04-Gramaticas.html">Analisadores Sintáticos</a></li><li class="breadcrumb-item"><a href="./06-first-follow.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Conjuntos FIRST e FOLLOW</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Linguagens Formais e Autômatos</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linguagens-formais" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Disciplina de Linguagens Formais</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Analisadores Léxicos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Analisadores Léxicos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Analisadores Sintáticos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-Gramaticas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Gramáticas e Linguagens Livres de Contexto</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-parsersLL1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Parsers LL(1): Começando a Análise Sintática</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-first-follow.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Conjuntos FIRST e FOLLOW</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-parserLR1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Parsers <span class="math inline">\(LR(1)\)</span>: Análise Sintática <em>bottom-up</em></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-parserSLR1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Parsers <span class="math inline">\(SLR(1)\)</span>: A Ponte Entre Simplicidade e Poder</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Analisadores Semânticos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-semantico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Analisadores Semânticos: a determinação do significado</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10a-semantico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fundamentos Matemáticos da Semântica</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10b-semantico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Julgamento de Tipos em Linguagens Imperativas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10c-semantico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">O Sistema de Tipos Hindley-Milner</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-tabelaSimbolos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Tabela de Símbolos em Compiladores Modernos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Projetos da Disciplina - 2025-2</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Fase 1 - Projeto Prático</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Fase 2 - Analisador Sintático <span class="math inline">\(LL(1)\)</span></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Fase 3 - Analisador Semântico</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apend1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Apêndice 1: A Relação de Myhill-Nerode</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sol-exercicios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Solução dos Exercícios</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#o-conjunto-first" id="toc-o-conjunto-first" class="nav-link active" data-scroll-target="#o-conjunto-first"><span class="header-section-number">7.1</span> O Conjunto FIRST</a>
  <ul class="collapse">
  <li><a href="#regras-de-criação-do-conjunto-first" id="toc-regras-de-criação-do-conjunto-first" class="nav-link" data-scroll-target="#regras-de-criação-do-conjunto-first"><span class="header-section-number">7.1.1</span> Regras de Criação do Conjunto FIRST</a></li>
  <li><a href="#exemplo-1-criação-de-conjuntos-first" id="toc-exemplo-1-criação-de-conjuntos-first" class="nav-link" data-scroll-target="#exemplo-1-criação-de-conjuntos-first"><span class="header-section-number">7.1.2</span> Exemplo 1: Criação de Conjuntos FIRST</a></li>
  <li><a href="#algoritmo-para-calcular-o-conjunto-first" id="toc-algoritmo-para-calcular-o-conjunto-first" class="nav-link" data-scroll-target="#algoritmo-para-calcular-o-conjunto-first"><span class="header-section-number">7.1.3</span> Algoritmo para calcular o conjunto FIRST</a></li>
  </ul></li>
  <li><a href="#o-conjunto-follow" id="toc-o-conjunto-follow" class="nav-link" data-scroll-target="#o-conjunto-follow"><span class="header-section-number">7.2</span> O Conjunto FOLLOW</a>
  <ul class="collapse">
  <li><a href="#exemplo-1-criação-de-conjuntos-follow" id="toc-exemplo-1-criação-de-conjuntos-follow" class="nav-link" data-scroll-target="#exemplo-1-criação-de-conjuntos-follow"><span class="header-section-number">7.2.1</span> Exemplo 1: Criação de Conjuntos FOLLOW</a></li>
  <li><a href="#algoritmo-para-calcular-o-conjunto-follow" id="toc-algoritmo-para-calcular-o-conjunto-follow" class="nav-link" data-scroll-target="#algoritmo-para-calcular-o-conjunto-follow"><span class="header-section-number">7.2.2</span> Algoritmo para calcular o conjunto FOLLOW</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/06-first-follow.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04-Gramaticas.html">Analisadores Sintáticos</a></li><li class="breadcrumb-item"><a href="./06-first-follow.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Conjuntos FIRST e FOLLOW</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-first-follow" class="quarto-section-identifier"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Conjuntos FIRST e FOLLOW</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Não dá nem para começar a pensar em criar um <em>parser</em> <span class="math inline">\(LL(1)\)</span> se não entender os conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span>. <a href="https://frankalcantara.com/parsers-ll(1)/">Também não dá para entender estes conjuntos se não souber o que é um <em>parser</em> <span class="math inline">\(LL(1)\)</span></a> Imagine que você está aprendendo um novo idioma. Para formar frases corretas, você precisará entender quais palavras podem vir antes ou depois de outras. Ou corre o risco de falar como o Yoda. Se quiser evitar ser confundido com um velho alienígena, precisa aprender, no mínimo, a ordem das palavras, muito antes de entender a classe gramatical destas mesmas palavras. Como uma criança aprendendo a falar.</p>
<p>Eu forcei um pouco a barra na metáfora, mas na análise sintática de linguagens livres de contexto, os conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> desempenham um papel importante que quase valida minha metáfora. Estes conjuntos ajudam a decifrar a gramática da linguagem de forma determinística determinando as regras de produção que serão aplicadas aos símbolos da <em>string</em> de entrada para garantir que ele faça parte da linguagem.</p>
<p>O conjunto <span class="math inline">\(FIRST\)</span> de um símbolo não-terminal será composto dos símbolos terminais que podem aparecer como <strong>primeiro símbolo</strong> de qualquer sequência de símbolos que seja derivada desse não-terminal. Em outras palavras, o conjunto <span class="math inline">\(FIRST\)</span> indica quais terminais podem iniciar uma declaração válida (frase) dentro da estrutura gramática definida por um não-terminal. Por exemplo, considere uma gramática para definir expressões aritméticas. O não-terminal <em>EXPR</em> pode derivar diversas sequências de símbolos, como <em>2 + 3</em>, <em>(4 </em> 5)<em>, </em>x - y<em>. O conjunto <span class="math inline">\(FIRST\)</span> do não-terminal </em>EXPR* seria, neste caso específico, <span class="math inline">\({número, '+', '-', '('}\)</span>, porque esses são os símbolos que podem iniciar qualquer expressão aritmética válida nesta gramática até onde podemos saber com as informações passadas neste parágrafo. Uma gramática para todas as expressões aritméticas possíveis teria um conjunto <span class="math inline">\(FIRST\)</span> maior.</p>
<p>O conjunto <span class="math inline">\(FOLLOW\)</span>, por sua vez, determina o conjunto de símbolos terminais que podem aparecer <strong>imediatamente após</strong> um não-terminal em alguma derivação da gramática. Ou colocando de outra forma, o conjunto <span class="math inline">\(FOLLOW\)</span> indica quais terminais podem seguir (<em>follow</em>) um não-terminal em uma declaração válida da linguagem.</p>
<p>Diferentemente do <span class="math inline">\(FIRST\)</span>, que se concentra no início de uma derivação, o <span class="math inline">\(FOLLOW\)</span> analisa a situação em que um não-terminal aparece, considerando as produções diretas do não-terminal e também as produções de outros não terminais que, por ventura, contenham o não-terminal em análise. Por exemplo, considere uma gramática que define declarações de variáveis. O não-terminal <em>DECLARACAO_VAR</em> pode ser seguido por diferentes símbolos, dependendo do contexto. Em uma linguagem como o <span class="math inline">\(C\)</span>, uma declaração de variável pode terminar com um ponto e vírgula, ser seguida por um operador de atribuição e uma expressão, ou até mesmo ser parte de uma estrutura maior. Neste cenário, o conjunto <span class="math inline">\(FOLLOW\)</span> do não-terminal <em>DECLARACAO_VAR</em> incluiria, portanto, o ponto e vírgula ‘;’, o sinal de igual ‘=’, e todos os outros símbolos que podem iniciar uma expressão ou um comando que a linguagem permita ocorrer na mesma linha da declaração da variável.</p>
<p>Os conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> serão utilizados para construir a Tabela de Derivação <span class="math inline">\(LL(1)\)</span>. A forma tecnicamente mais correta seria dizer que estes conjuntos formam a Tabela De Análise <span class="math inline">\(LL(1)\)</span>. Entretanto, pobre de mim, prefiro chamar de Tabela de Derivação.</p>
<p>As Tabelas de Derivação são tabelas que guiam o processo de análise sintática descendente preditiva no <em>parser</em> <span class="math inline">\(LL(1)\)</span> deterministicamente. Cada célula dessas tabelas corresponde a relação que existe em um par não-terminal, terminal. De forma que o valor da célula apontada por este par indica qual regra de produção deve ser aplicada quando o analisador encontrar este par específico durante a análise preditiva <span class="math inline">\(LL(1)\)</span>.</p>
<section id="o-conjunto-first" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="o-conjunto-first"><span class="header-section-number">7.1</span> O Conjunto FIRST</h2>
<p>O conjunto <span class="math inline">\(FIRST\)</span> de um símbolo não-terminal é o conjunto de todos os terminais que podem aparecer no início de qualquer <em>string</em> derivada desse símbolo, incluindo o símbolo vazio (<span class="math inline">\(\varepsilon\)</span>) se o não-terminal puder derivar a <em>string</em> vazia. Para os símbolos terminais, o elemento do conjunto <span class="math inline">\(FIRST\)</span> será o próprio símbolo terminal.</p>
<section id="regras-de-criação-do-conjunto-first" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="regras-de-criação-do-conjunto-first"><span class="header-section-number">7.1.1</span> Regras de Criação do Conjunto FIRST</h3>
<p>Para definir o conjunto <span class="math inline">\(FIRST(X)\)</span> para todos os símbolos não-terminais <span class="math inline">\(X\)</span> de uma gramática que esteja definida por um conjunto de regras de produção, podemos seguir os seguintes passos:</p>
<ol type="1">
<li><p><strong>Para símbolos terminais</strong>: o conjunto <span class="math inline">\(FIRST\)</span> é o próprio símbolo terminal. Ou seja, se <span class="math inline">\(a\)</span> é um terminal, então <span class="math inline">\(FIRST(a) = {a}\)</span>.</p></li>
<li><p><strong>Para um símbolo não-terminal <span class="math inline">\(X\)</span></strong>: olhe para cada regra de produção <span class="math inline">\(X \rightarrow \alpha\)</span> e siga as seguintes regras:</p>
<ul>
<li>Se <span class="math inline">\(\alpha\)</span> é um terminal, adicione <span class="math inline">\(\alpha\)</span> ao conjunto <span class="math inline">\(FIRST(X)\)</span>.</li>
<li>Se <span class="math inline">\(\alpha\)</span> começa com um símbolo não-terminal <span class="math inline">\(Y\)</span>, adicione <span class="math inline">\(FIRST(Y)\)</span> ao <span class="math inline">\(FIRST(X)\)</span>, exceto pelo símbolo de vazio <span class="math inline">\((\varepsilon\)</span>) se ele estiver presente.</li>
<li>Se <span class="math inline">\(\alpha\)</span> consiste apenas em não-terminais e todos eles podem derivar em vazio (diretamente ou indiretamente), adicione <span class="math inline">\(\varepsilon\)</span> ao conjunto <span class="math inline">\(FIRST(X)\)</span>.</li>
</ul></li>
</ol>
<p><strong>O símbolo vazio <span class="math inline">\(\varepsilon\)</span> pertence ao conjunto FIRST(X) se, e somente se, <span class="math inline">\(X\)</span> pode derivar a string vazia (diretamente ou indiretamente).</strong></p>
<p>Repita esses passos até que os conjuntos <span class="math inline">\(FIRST\)</span> de todos os símbolos não-terminais não possam ser alterado.</p>
</section>
<section id="exemplo-1-criação-de-conjuntos-first" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="exemplo-1-criação-de-conjuntos-first"><span class="header-section-number">7.1.2</span> Exemplo 1: Criação de Conjuntos FIRST</h3>
<p>Considere a gramática definida pelo seguinte conjunto de regras de produção:</p>
<p><span class="math display">\[
\begin{array}{cc}
1. &amp;S \rightarrow aB \vert  bA \\
2. &amp;A \rightarrow c \vert  d \\
3. &amp;B \rightarrow e \vert  f \\
\end{array}
\]</span></p>
<p>Este conjunto de regras de produção permite criar:</p>
<table class="table">
<thead>
<tr class="header">
<th>Símbolo</th>
<th>FIRST</th>
<th>Explicação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S</td>
<td>{a, b}</td>
<td>S pode ser derivado em “aB” ou “bA”</td>
</tr>
<tr class="even">
<td>A</td>
<td>{c, d}</td>
<td>A pode ser derivado em “c” ou “d”</td>
</tr>
<tr class="odd">
<td>B</td>
<td>{e, f}</td>
<td>B pode ser derivado em “e” ou “f”</td>
</tr>
</tbody>
</table>
<p>Logo: <span class="math inline">\(FIRST =\{(S,\{a, b\}),(A,\{c, d\}),(B,\{e, f\})\}\)</span>, um conjunto de tuplas.</p>
<p>Agora que entendemos o algoritmo, podemos tentar criar um pseudocódigo para encontrar os elementos do conjunto <span class="math inline">\(First\)</span>.</p>
</section>
<section id="algoritmo-para-calcular-o-conjunto-first" class="level3" data-number="7.1.3">
<h3 data-number="7.1.3" class="anchored" data-anchor-id="algoritmo-para-calcular-o-conjunto-first"><span class="header-section-number">7.1.3</span> Algoritmo para calcular o conjunto FIRST</h3>
<pre class="pseudo"><code>## Algoritmo para calcular o conjunto FIRST para símbolos não-terminais

# Entrada: Um conjunto de regras de produção P
# Saída: Um dicionário FIRST, onde FIRST[X] é o conjunto FIRST do símbolo não-terminal X

função calcular_FIRST(gramática):
    FIRST = {}  # Inicializa o dicionário FIRST

    # Passo 1: Inicialização para não-terminais
    para cada símbolo não-terminal X na gramática:
        FIRST[X] &lt;- {}

    # Passo 2: Iteração para não-terminais
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada regra de produção X \rightarrow Y1 Y2 ... Yn na gramática:
            k = 0
            adicionou_epsilon = verdadeiro
            enquanto k &lt; n e adicionou_epsilon:
                adicionou_epsilon = falso
                Yk = Y[k]

                # Se Yk é terminal, adicionar Yk ao FIRST[X]
                se Yk é terminal:
                    se Yk não está em FIRST[X]:
                        adicionar Yk a FIRST[X]
                        mudou = verdadeiro
                # Se Yk é não-terminal, adicionar FIRST[Yk] ao FIRST[X], exceto \varepsilon
                senão:
                    para cada símbolo t em FIRST[Yk]:
                        se t != "\varepsilon":
                            se t não está em FIRST[X]:
                                adicionar t a FIRST[X]
                                mudou = verdadeiro
                        senão:
                            adicionou_epsilon = verdadeiro
                k = k + 1

            # Se todos os Y1, Y2, ..., Yn podem derivar \varepsilon, adicionar \varepsilon ao FIRST[X]
            se k == n e adicionou_epsilon:
                se "\varepsilon" não está em FIRST[X]:
                    adicionar "\varepsilon" a FIRST[X]
                    mudou = verdadeiro

    retornar FIRST</code></pre>
<p>Este pseudocódigo, poderia ser criado em python com um código parecido com este:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_FIRST(producoes):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    FIRST <span class="op">=</span> {}</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Passo 1: Inicialização para não-terminais</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Identificamos todos os símbolos não-terminais presentes nas produções</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    nao_terminais <span class="op">=</span> {regra.split(<span class="st">'</span><span class="ch">\r</span><span class="st">ightarrow'</span>)[<span class="dv">0</span>].strip() <span class="cf">for</span> regra <span class="kw">in</span> producoes}</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inicializamos o conjunto FIRST de cada não-terminal como um conjunto vazio</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nao_terminal <span class="kw">in</span> nao_terminais:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        FIRST[nao_terminal] <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># O loop continua até que não haja mais mudanças nos conjuntos FIRST</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> mudou:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        mudou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Iteramos por todas as produções da gramática</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            partes <span class="op">=</span> producao.split(<span class="st">'</span><span class="ch">\r</span><span class="st">ightarrow'</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            X <span class="op">=</span> partes[<span class="dv">0</span>].strip()  <span class="co"># Não-terminal do lado esquerdo da produção</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            Y <span class="op">=</span> partes[<span class="dv">1</span>].strip().split()  <span class="co"># Lista de símbolos do lado direito da produção</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            adicionou_epsilon <span class="op">=</span> <span class="va">True</span>  <span class="co"># Flag para controlar a adição de \varepsilon</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Iteramos sobre os símbolos do lado direito da produção</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> k <span class="op">&lt;</span> <span class="bu">len</span>(Y) <span class="kw">and</span> adicionou_epsilon:</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                adicionou_epsilon <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>                Yk <span class="op">=</span> Y[k]</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Se Yk é um não-terminal, adicionamos seus FIRST ao FIRST de X</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> Yk <span class="kw">in</span> nao_terminais:</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> simbolo <span class="kw">in</span> FIRST[Yk]:</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> simbolo <span class="op">!=</span> <span class="st">"</span><span class="ch">\v</span><span class="st">arepsilon"</span>:</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> FIRST[X]:</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                                FIRST[X].add(simbolo)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>                                mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">else</span>:</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>                            adicionou_epsilon <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Se Yk é um terminal, adicionamos Yk ao FIRST de X</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> Yk <span class="kw">not</span> <span class="kw">in</span> FIRST[X]:</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>                        FIRST[X].add(Yk)</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>                        mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>                    adicionou_epsilon <span class="op">=</span> <span class="va">False</span>  <span class="co"># Paramos de adicionar se encontramos um terminal</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>                k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Se todos os símbolos Y1, Y2, ..., Yn podem derivar \varepsilon, adicionamos \varepsilon ao FIRST de X</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> k <span class="op">==</span> <span class="bu">len</span>(Y) <span class="kw">and</span> adicionou_epsilon:</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="st">"</span><span class="ch">\v</span><span class="st">arepsilon"</span> <span class="kw">not</span> <span class="kw">in</span> FIRST[X]:</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>                    FIRST[X].add(<span class="st">"</span><span class="ch">\v</span><span class="st">arepsilon"</span>)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>                    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FIRST</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Exemplo de uso</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>producoes <span class="op">=</span> [</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S </span><span class="ch">\r</span><span class="st">ightarrow a B"</span>,</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S </span><span class="ch">\r</span><span class="st">ightarrow b A"</span>,</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A </span><span class="ch">\r</span><span class="st">ightarrow c"</span>,</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A </span><span class="ch">\r</span><span class="st">ightarrow d"</span>,</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span class="st">"B </span><span class="ch">\r</span><span class="st">ightarrow e"</span>,</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="st">"B </span><span class="ch">\r</span><span class="st">ightarrow f"</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>FIRST <span class="op">=</span> calcular_FIRST(producoes)</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> nao_terminal <span class="kw">in</span> FIRST:</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"FIRST(</span><span class="sc">{</span>nao_terminal<span class="sc">}</span><span class="ss">) = </span><span class="sc">{</span>FIRST[nao_terminal]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="o-conjunto-follow" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="o-conjunto-follow"><span class="header-section-number">7.2</span> O Conjunto FOLLOW</h2>
<p>O conjunto <span class="math inline">\(FOLLOW\)</span> de um símbolo não-terminal é o conjunto de terminais que podem aparecer imediatamente à direita (após, <em>follow</em>) desse não-terminal em alguma forma sentencial derivada, <strong>ou o símbolo de fim de entrada ($) se o não-terminal puder aparecer no final de uma forma sentencial</strong>.</p>
<p>Para definir o conjunto <span class="math inline">\(FOLLOW(A)\)</span> para cada não-terminal <span class="math inline">\(A\)</span>, siga estes passos:</p>
<ol type="1">
<li><p>Coloque o símbolo de fim de entrada <span class="math inline">\((\$)\)</span> no <span class="math inline">\(FOLLOW\)</span> do símbolo inicial da gramática. Ao colocar o símbolo de fim de entrada ($) no <span class="math inline">\(FOLLOW\)</span> do símbolo inicial da gramática, garantimos que o analisador sintático reconheça a última derivação da gramática como válida. Isso significa que o analisador estará preparado para encontrar o símbolo (<span class="math inline">\(\$\)</span>) ao final da string de entrada, indicando que a análise foi concluída com sucesso. Em outras palavras, o símbolo (<span class="math inline">\(\$\)</span>) no <span class="math inline">\(FOLLOW\)</span> do símbolo inicial representa a expectativa de que a string de entrada seja completamente processada e que não existam símbolos após a última derivada.</p></li>
<li><p>Para cada produção da forma <span class="math inline">\(A \rightarrow \alpha B \beta\)</span>, onde <span class="math inline">\(B\)</span> é um não-terminal:</p></li>
</ol>
<ul>
<li>Se <span class="math inline">\(\beta\)</span> não deriva <span class="math inline">\(\varepsilon\)</span> (a string vazia), adicione <span class="math inline">\(FIRST(\beta)\)</span> (sem <span class="math inline">\(\varepsilon\)</span>) a <span class="math inline">\(FOLLOW(B)\)</span>.</li>
<li>Se <span class="math inline">\(\beta\)</span> deriva <span class="math inline">\(\varepsilon\)</span> (a string vazia) <strong>ou <span class="math inline">\(\beta\)</span> é a string vazia</strong>, adicione <span class="math inline">\(FOLLOW(A)\)</span> a <span class="math inline">\(FOLLOW(B)\)</span>.</li>
</ul>
<p>Repita esses passos até que os conjuntos <span class="math inline">\(FOLLOW\)</span> de todos os símbolos não-terminais não mudem mais.</p>
<section id="exemplo-1-criação-de-conjuntos-follow" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="exemplo-1-criação-de-conjuntos-follow"><span class="header-section-number">7.2.1</span> Exemplo 1: Criação de Conjuntos FOLLOW</h3>
<p>Considere a gramática definida por:</p>
<p><span class="math display">\[
\begin{array}{cc}
1. &amp; S \rightarrow aB \vert  bA \\
2. &amp; A \rightarrow c \vert  d \\
3. &amp; B \rightarrow e \vert  f \\
\end{array}
\]</span></p>
<p><strong>Conjunto FIRST</strong>:</p>
<ul>
<li><span class="math inline">\(FIRST(S) = \{a, b\}\)</span> (S pode derivar em <span class="math inline">\(aB\)</span> ou <span class="math inline">\(bA\)</span>)</li>
<li><span class="math inline">\(FIRST(A) = \{c, d\}\)</span> (A pode derivar em <span class="math inline">\(c\)</span> ou <span class="math inline">\(d\)</span>)</li>
<li><span class="math inline">\(FIRST(B) = \{e, f\}\)</span> (B pode derivar em <span class="math inline">\(e\)</span> ou <span class="math inline">\(f\)</span>)</li>
</ul>
<p><strong>Conjunto FOLLOW</strong>:</p>
<p>Para calcular o conjunto FOLLOW, seguimos as regras aplicadas à gramática do exemplo:</p>
<ol type="1">
<li><span class="math inline">\(FOLLOW(S) = \{\$\}\)</span>
<ul>
<li><span class="math inline">\(S\)</span> é o símbolo inicial, então adicionamos o marcador de fim de entrada (<span class="math inline">\(\$\)</span>) ao seu conjunto FOLLOW.</li>
</ul></li>
<li><span class="math inline">\(FOLLOW(A) = \{\$\}\)</span>
<ul>
<li>Analisamos as regras para encontrar onde <span class="math inline">\(A\)</span> aparece no lado direito. Encontramos <span class="math inline">\(A\)</span> na produção <span class="math inline">\(S \to bA\)</span>.</li>
<li>Como não há nenhum símbolo após <span class="math inline">\(A\)</span> nesta produção, adicionamos todos os elementos de <span class="math inline">\(FOLLOW(S)\)</span> ao conjunto <span class="math inline">\(FOLLOW(A)\)</span>.</li>
<li>Portanto, <span class="math inline">\(FOLLOW(A)\)</span> recebe <span class="math inline">\(\{\$\}\)</span>.</li>
</ul></li>
<li><span class="math inline">\(FOLLOW(B) = \{\$\}\)</span>
<ul>
<li>Analisamos as regras para encontrar onde <span class="math inline">\(B\)</span> aparece no lado direito. Encontramos <span class="math inline">\(B\)</span> na produção <span class="math inline">\(S \rightarrow aB\)</span>.</li>
<li>Como também não há nenhum símbolo após <span class="math inline">\(B\)</span> nesta produção, adicionamos todos os elementos de <span class="math inline">\(FOLLOW(S)\)</span> ao conjunto <span class="math inline">\(FOLLOW(B)\)</span>.</li>
<li>Portanto, <span class="math inline">\(FOLLOW(B)\)</span> também recebe <span class="math inline">\(\{\$\}\)</span>.</li>
</ul></li>
</ol>
<p>Criamos o conjunto <span class="math inline">\(FIRST\)</span> porque este é necessário para a criação do conjunto <span class="math inline">\(FOLLOW\)</span>. Mas, neste momento nos interessa apenas o conjunto <span class="math inline">\(FOLLOW\)</span>. O conjunto resultante será:</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Símbolo</th>
<th style="text-align: left;">FOLLOW</th>
<th style="text-align: left;">Explicação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(S\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \$ \}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(S\)</span> é o símbolo inicial, então <span class="math inline">\(\$\)</span> é adicionado ao seu conjunto FOLLOW.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(A\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \$ \}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(A\)</span> aparece na produção <span class="math inline">\(S \to bA\)</span>. Como <span class="math inline">\(A\)</span> está no final, <span class="math inline">\(FOLLOW(A)\)</span> herda o conteúdo de <span class="math inline">\(FOLLOW(S)\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(B\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \$ \}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(B\)</span> aparece na produção <span class="math inline">\(S \to aB\)</span>. Como <span class="math inline">\(B\)</span> está no final, <span class="math inline">\(FOLLOW(B)\)</span> herda o conteúdo de <span class="math inline">\(FOLLOW(S)\)</span>.</td>
</tr>
</tbody>
</table>
</section>
<section id="algoritmo-para-calcular-o-conjunto-follow" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="algoritmo-para-calcular-o-conjunto-follow"><span class="header-section-number">7.2.2</span> Algoritmo para calcular o conjunto FOLLOW</h3>
<p>Assim como fizemos com o <span class="math inline">\(FIRST\)</span> podemos criar um algoritmo para criar o conjunto <span class="math inline">\(FOLLOW\)</span>:</p>
<pre class="shell"><code># Algoritmo para calcular o conjunto FIRST para símbolos não-terminais
# Entrada: Um conjunto de regras de produção P
# Saída: Um dicionário FIRST, onde FIRST[X] é o conjunto FIRST do símbolo não-terminal X

função calcular_FIRST(producoes):
    FIRST = {}  # Inicializa o dicionário FIRST
    
    # Identifica todos os não-terminais e terminais
    nao_terminais = conjunto vazio
    para cada producao nas producoes:
        X = lado esquerdo da producao (antes de "-&gt;")
        adicionar X aos nao_terminais
    
    # Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal
    para cada X em nao_terminais:
        FIRST[X] = conjunto vazio
    
    # Passo 2: Iteração até convergência
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada producao nas producoes:
            X = lado esquerdo da producao
            simbolos = lado direito da producao (lista de símbolos)
            
            # Caso especial: produção vazia (X -&gt; epsilon)
            se simbolos == ["epsilon"]:
                se "epsilon" não está em FIRST[X]:
                    adicionar "epsilon" a FIRST[X]
                    mudou = verdadeiro
                continuar para próxima produção
            
            # Percorre os símbolos do lado direito
            k = 0
            continuar = verdadeiro
            enquanto k &lt; tamanho(simbolos) e continuar:
                Yk = simbolos[k]
                continuar = falso
                
                # Se Yk é terminal
                se Yk não está em nao_terminais e Yk != "epsilon":
                    se Yk não está em FIRST[X]:
                        adicionar Yk a FIRST[X]
                        mudou = verdadeiro
                # Se Yk é não-terminal
                senão se Yk está em nao_terminais:
                    # Adiciona FIRST[Yk] - {epsilon} a FIRST[X]
                    para cada simbolo em FIRST[Yk]:
                        se simbolo != "epsilon":
                            se simbolo não está em FIRST[X]:
                                adicionar simbolo a FIRST[X]
                                mudou = verdadeiro
                    # Se epsilon está em FIRST[Yk], continua para próximo símbolo
                    se "epsilon" está em FIRST[Yk]:
                        continuar = verdadeiro
                k = k + 1
            
            # Se todos os símbolos podem derivar epsilon
            se continuar == verdadeiro:
                se "epsilon" não está em FIRST[X]:
                    adicionar "epsilon" a FIRST[X]
                    mudou = verdadeiro
    
    retornar FIRST</code></pre>
<p>Agora que temos um pseudo código, podemos partir para o código em Python. Neste ponto, a atenta leitora precisa lembrar que vamos precisar do conjunto <span class="math inline">\(FIRST\)</span> para encontrar o conjunto <span class="math inline">\(FOLLOW\)</span>. Logo começando pelo <span class="math inline">\(FIRST\)</span>, teremos:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_FIRST(producoes):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula o conjunto FIRST para todos os não-terminais de uma gramática.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">        producoes: Lista de strings representando as produções (ex: "S -&gt; a B")</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Dicionário onde as chaves são não-terminais e valores são conjuntos FIRST</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    FIRST <span class="op">=</span> {}</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Identifica todos os não-terminais (símbolos do lado esquerdo)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    nao_terminais <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> producao.split(<span class="st">'-&gt;'</span>)[<span class="dv">0</span>].strip()</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        nao_terminais.add(X)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nao_terminal <span class="kw">in</span> nao_terminais:</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        FIRST[nao_terminal] <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Passo 2: Iteração até convergência</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> mudou:</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        mudou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>            partes <span class="op">=</span> producao.split(<span class="st">'-&gt;'</span>)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            X <span class="op">=</span> partes[<span class="dv">0</span>].strip()</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>            simbolos <span class="op">=</span> partes[<span class="dv">1</span>].strip().split()</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Caso especial: produção vazia (X -&gt; epsilon)</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> simbolos <span class="op">==</span> [<span class="st">'epsilon'</span>]:</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="st">'epsilon'</span> <span class="kw">not</span> <span class="kw">in</span> FIRST[X]:</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                    FIRST[X].add(<span class="st">'epsilon'</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>                    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Percorre os símbolos do lado direito</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>            continuar <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> k <span class="op">&lt;</span> <span class="bu">len</span>(simbolos) <span class="kw">and</span> continuar:</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>                Yk <span class="op">=</span> simbolos[k]</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>                continuar <span class="op">=</span> <span class="va">False</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Se Yk é terminal</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> Yk <span class="kw">not</span> <span class="kw">in</span> nao_terminais <span class="kw">and</span> Yk <span class="op">!=</span> <span class="st">'epsilon'</span>:</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> Yk <span class="kw">not</span> <span class="kw">in</span> FIRST[X]:</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>                        FIRST[X].add(Yk)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>                        mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Se Yk é não-terminal</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> Yk <span class="kw">in</span> nao_terminais:</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Adiciona FIRST[Yk] - {epsilon} a FIRST[X]</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> simbolo <span class="kw">in</span> FIRST[Yk]:</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> simbolo <span class="op">!=</span> <span class="st">'epsilon'</span>:</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> FIRST[X]:</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>                                FIRST[X].add(simbolo)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>                                mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Se epsilon está em FIRST[Yk], continua para próximo símbolo</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="st">'epsilon'</span> <span class="kw">in</span> FIRST[Yk]:</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>                        continuar <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>                k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Se todos os símbolos podem derivar epsilon</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> continuar:</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="st">'epsilon'</span> <span class="kw">not</span> <span class="kw">in</span> FIRST[X]:</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>                    FIRST[X].add(<span class="st">'epsilon'</span>)</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>                    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FIRST</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finalmente podemos ver o pseudocódigo e o código em Python para encontrar o conjunto <span class="math inline">\(FOLLOW\)</span>:</p>
<pre class="shell"><code># Algoritmo para calcular o conjunto FOLLOW para símbolos não-terminais
# Entrada: Um conjunto de regras de produção P e o símbolo inicial S
# Saída: Um dicionário FOLLOW, onde FOLLOW[X] é o conjunto FOLLOW do símbolo não-terminal X

função calcular_FOLLOW(producoes, simbolo_inicial):
    # Primeiro calcula o conjunto FIRST que será necessário
    FIRST = calcular_FIRST(producoes)
    FOLLOW = {}  # Inicializa o dicionário FOLLOW
    
    # Identifica todos os não-terminais
    nao_terminais = conjunto vazio
    para cada producao nas producoes:
        X = lado esquerdo da producao (antes de "-&gt;")
        adicionar X aos nao_terminais
    
    # Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal
    para cada X em nao_terminais:
        FOLLOW[X] = conjunto vazio
    
    # Passo 2: Adiciona $ ao FOLLOW do símbolo inicial
    FOLLOW[simbolo_inicial] = {"$"}
    
    # Passo 3: Iteração até convergência
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada producao nas producoes:
            A = lado esquerdo da producao
            alfa = lado direito da producao (lista de símbolos)
            
            # Para cada símbolo na produção
            para i de 0 até tamanho(alfa) - 1:
                B = alfa[i]
                
                # Se B é um não-terminal
                se B está em nao_terminais:
                    beta = alfa[i+1:fim]  # símbolos após B
                    
                    # Se existe sequência beta após B
                    se beta não é vazia:
                        # Calcula FIRST(beta)
                        first_beta = calcular_first_da_sequencia(beta, FIRST, nao_terminais)
                        
                        # Adiciona FIRST(beta) - {epsilon} em FOLLOW(B)
                        para cada simbolo em first_beta:
                            se simbolo != "epsilon":
                                se simbolo não está em FOLLOW[B]:
                                    adicionar simbolo a FOLLOW[B]
                                    mudou = verdadeiro
                        
                        # Se epsilon está em FIRST(beta), adiciona FOLLOW(A) em FOLLOW(B)
                        se "epsilon" está em first_beta:
                            para cada simbolo em FOLLOW[A]:
                                se simbolo não está em FOLLOW[B]:
                                    adicionar simbolo a FOLLOW[B]
                                    mudou = verdadeiro
                    
                    # Se não há nada após B (B está no final)
                    senão:
                        # Adiciona FOLLOW(A) em FOLLOW(B)
                        para cada simbolo em FOLLOW[A]:
                            se simbolo não está em FOLLOW[B]:
                                adicionar simbolo a FOLLOW[B]
                                mudou = verdadeiro
    
    retornar FOLLOW

# Função auxiliar para calcular FIRST de uma sequência de símbolos
função calcular_first_da_sequencia(sequencia, FIRST, nao_terminais):
    first_sequencia = conjunto vazio
    
    para cada simbolo na sequencia:
        # Se é terminal, adiciona e para
        se simbolo não está em nao_terminais:
            adicionar simbolo a first_sequencia
            parar o loop
        # Se é não-terminal
        senão:
            # Adiciona FIRST[simbolo] - {epsilon}
            para cada s em FIRST[simbolo]:
                se s != "epsilon":
                    adicionar s a first_sequencia
            # Se epsilon não está em FIRST[simbolo], para
            se "epsilon" não está em FIRST[simbolo]:
                parar o loop
    
    # Se percorreu toda a sequência (todos derivam epsilon)
    se percorreu toda a sequencia:
        adicionar "epsilon" a first_sequencia
    
    retornar first_sequencia</code></pre>
<p>Finalmente o código em Python será:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_first_da_sequencia(sequencia, FIRST, nao_terminais):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula o FIRST de uma sequência de símbolos.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">        sequencia: Lista de símbolos</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">        FIRST: Dicionário com conjuntos FIRST já calculados</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        nao_terminais: Conjunto de não-terminais da gramática</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Conjunto FIRST da sequência</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    first_sequencia <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> simbolo <span class="kw">in</span> sequencia:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Se é terminal, adiciona e para</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> nao_terminais:</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            first_sequencia.add(simbolo)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Se é não-terminal</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adiciona FIRST[simbolo] - {epsilon}</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> FIRST[simbolo]:</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> s <span class="op">!=</span> <span class="st">'epsilon'</span>:</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>                    first_sequencia.add(s)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Se epsilon não está em FIRST[simbolo], para</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="st">'epsilon'</span> <span class="kw">not</span> <span class="kw">in</span> FIRST[simbolo]:</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Se percorreu toda a sequência (todos derivam epsilon)</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        first_sequencia.add(<span class="st">'epsilon'</span>)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> first_sequencia</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_FOLLOW(producoes, simbolo_inicial):</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula o conjunto FOLLOW para todos os não-terminais de uma gramática.</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="co">        producoes: Lista de strings representando as produções</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="co">        simbolo_inicial: Símbolo inicial da gramática</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="co">        Dicionário onde as chaves são não-terminais e valores são conjuntos FOLLOW</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Primeiro calcula o conjunto FIRST que será necessário</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    FIRST <span class="op">=</span> calcular_FIRST(producoes)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    FOLLOW <span class="op">=</span> {}</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Identifica todos os não-terminais</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>    nao_terminais <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> producao.split(<span class="st">'-&gt;'</span>)[<span class="dv">0</span>].strip()</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>        nao_terminais.add(X)</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal</span></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nao_terminal <span class="kw">in</span> nao_terminais:</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>        FOLLOW[nao_terminal] <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Passo 2: Adiciona $ ao FOLLOW do símbolo inicial</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>    FOLLOW[simbolo_inicial].add(<span class="st">'$'</span>)</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Passo 3: Iteração até convergência</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> mudou:</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>        mudou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>            partes <span class="op">=</span> producao.split(<span class="st">'-&gt;'</span>)</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>            A <span class="op">=</span> partes[<span class="dv">0</span>].strip()</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>            alfa <span class="op">=</span> partes[<span class="dv">1</span>].strip().split()</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Para cada símbolo na produção</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(alfa)):</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>                B <span class="op">=</span> alfa[i]</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Se B é um não-terminal</span></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> B <span class="kw">in</span> nao_terminais:</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>                    beta <span class="op">=</span> alfa[i<span class="op">+</span><span class="dv">1</span>:]  <span class="co"># símbolos após B</span></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Se existe sequência beta após B</span></span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> beta:</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Calcula FIRST(beta)</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>                        first_beta <span class="op">=</span> calcular_first_da_sequencia(beta, FIRST, nao_terminais)</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Adiciona FIRST(beta) - {epsilon} em FOLLOW(B)</span></span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> simbolo <span class="kw">in</span> first_beta:</span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> simbolo <span class="op">!=</span> <span class="st">'epsilon'</span>:</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> FOLLOW[B]:</span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>                                    FOLLOW[B].add(simbolo)</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>                                    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Se epsilon está em FIRST(beta), adiciona FOLLOW(A) em FOLLOW(B)</span></span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="st">'epsilon'</span> <span class="kw">in</span> first_beta:</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">for</span> simbolo <span class="kw">in</span> FOLLOW[A]:</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> FOLLOW[B]:</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>                                    FOLLOW[B].add(simbolo)</span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a>                                    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Se não há nada após B (B está no final)</span></span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Adiciona FOLLOW(A) em FOLLOW(B)</span></span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> simbolo <span class="kw">in</span> FOLLOW[A]:</span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> FOLLOW[B]:</span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a>                                FOLLOW[B].add(simbolo)</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a>                                mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FOLLOW</span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a><span class="co"># Exemplo de uso completo</span></span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Definindo a gramática</span></span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a>    producoes <span class="op">=</span> [</span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a>        <span class="st">"S -&gt; a B"</span>,</span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a>        <span class="st">"S -&gt; b A"</span>,</span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a>        <span class="st">"A -&gt; c"</span>,</span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a>        <span class="st">"A -&gt; d"</span>,</span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a>        <span class="st">"B -&gt; e"</span>,</span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a>        <span class="st">"B -&gt; f"</span></span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a>    simbolo_inicial <span class="op">=</span> <span class="st">"S"</span></span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculando FIRST</span></span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Conjuntos FIRST:"</span>)</span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a>    FIRST <span class="op">=</span> calcular_FIRST(producoes)</span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nao_terminal <span class="kw">in</span> <span class="bu">sorted</span>(FIRST.keys()):</span>
<span id="cb6-126"><a href="#cb6-126" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  FIRST(</span><span class="sc">{</span>nao_terminal<span class="sc">}</span><span class="ss">) = </span><span class="ch">{{</span><span class="sc">{</span><span class="st">', '</span><span class="sc">.</span>join(<span class="bu">sorted</span>(FIRST[nao_terminal]))<span class="sc">}</span><span class="ch">}}</span><span class="ss">"</span>)</span>
<span id="cb6-127"><a href="#cb6-127" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-128"><a href="#cb6-128" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculando FOLLOW</span></span>
<span id="cb6-129"><a href="#cb6-129" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Conjuntos FOLLOW:"</span>)</span>
<span id="cb6-130"><a href="#cb6-130" aria-hidden="true" tabindex="-1"></a>    FOLLOW <span class="op">=</span> calcular_FOLLOW(producoes, simbolo_inicial)</span>
<span id="cb6-131"><a href="#cb6-131" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nao_terminal <span class="kw">in</span> <span class="bu">sorted</span>(FOLLOW.keys()):</span>
<span id="cb6-132"><a href="#cb6-132" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  FOLLOW(</span><span class="sc">{</span>nao_terminal<span class="sc">}</span><span class="ss">) = </span><span class="ch">{{</span><span class="sc">{</span><span class="st">', '</span><span class="sc">.</span>join(<span class="bu">sorted</span>(FOLLOW[nao_terminal]))<span class="sc">}</span><span class="ch">}}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./05-parsersLL1.html" class="pagination-link" aria-label="Parsers LL(1): Começando a Análise Sintática">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Parsers LL(1): Começando a Análise Sintática</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./07-parserLR1.html" class="pagination-link" aria-label="Parsers $LR(1)$: Análise Sintática _bottom-up_">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Parsers <span class="math inline">\(LR(1)\)</span>: Análise Sintática <em>bottom-up</em></span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/06-first-follow.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>