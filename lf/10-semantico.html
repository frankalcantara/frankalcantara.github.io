<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Linguagens Formais e Autômatos - 10&nbsp; Analisadores Semânticos: a determinação do significado</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./10a-semantico.html" rel="next">
<link href="./08-parserSLR1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./10-semantico.html">Analisadores Semânticos</a></li><li class="breadcrumb-item"><a href="./10-semantico.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Analisadores Semânticos: a determinação do significado</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Linguagens Formais e Autômatos</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linguagens-formais" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Disciplina de Linguagens Formais</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Analisadores Léxicos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Analisadores Léxicos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Analisadores Sintáticos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-Gramaticas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Gramáticas e Linguagens Livres de Contexto</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-parsersLL1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Parsers LL(1): Começando a Análise Sintática</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-first-follow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Conjuntos FIRST e FOLLOW</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-parserLR1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Parsers <span class="math inline">\(LR(1)\)</span>: Análise Sintática <em>bottom-up</em></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-parserSLR1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Parsers <span class="math inline">\(SLR(1)\)</span>: A Ponte Entre Simplicidade e Poder</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Analisadores Semânticos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-semantico.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Analisadores Semânticos: a determinação do significado</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10a-semantico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fundamentos Matemáticos da Semântica</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10b-semantico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Julgamento de Tipos em Linguagens Imperativas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10c-semantico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">O Sistema de Tipos Hindley-Milner</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-tabelaSimbolos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Tabela de Símbolos em Compiladores Modernos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Projetos da Disciplina - 2025-2</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Fase 1 - Projeto Prático</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Fase 2 - Analisador Sintático <span class="math inline">\(LL(1)\)</span></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Fase 3 - Analisador Semântico</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apend1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Apêndice 1: A Relação de Myhill-Nerode</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sol-exercicios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Solução dos Exercícios</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#perspectiva-histórica-a-evolução-da-análise-semântica" id="toc-perspectiva-histórica-a-evolução-da-análise-semântica" class="nav-link active" data-scroll-target="#perspectiva-histórica-a-evolução-da-análise-semântica"><span class="header-section-number">10.1</span> Perspectiva Histórica: A Evolução da Análise Semântica</a></li>
  <li><a href="#da-necessidade-à-solução-por-que-gramáticas-de-atributos" id="toc-da-necessidade-à-solução-por-que-gramáticas-de-atributos" class="nav-link" data-scroll-target="#da-necessidade-à-solução-por-que-gramáticas-de-atributos"><span class="header-section-number">10.2</span> Da Necessidade à Solução: Por Que Gramáticas de Atributos?</a></li>
  <li><a href="#a-análise-semântica-no-contexto-do-compilador" id="toc-a-análise-semântica-no-contexto-do-compilador" class="nav-link" data-scroll-target="#a-análise-semântica-no-contexto-do-compilador"><span class="header-section-number">10.3</span> A Análise Semântica no Contexto do Compilador</a></li>
  <li><a href="#semântica-estática-vs.-dinâmica-o-limite-da-compilação" id="toc-semântica-estática-vs.-dinâmica-o-limite-da-compilação" class="nav-link" data-scroll-target="#semântica-estática-vs.-dinâmica-o-limite-da-compilação"><span class="header-section-number">10.4</span> Semântica Estática vs.&nbsp;Dinâmica: O Limite da Compilação</a>
  <ul class="collapse">
  <li><a href="#indecidibilidade-e-trade-offs" id="toc-indecidibilidade-e-trade-offs" class="nav-link" data-scroll-target="#indecidibilidade-e-trade-offs"><span class="header-section-number">10.4.1</span> Indecidibilidade e <em>Trade-offs</em></a></li>
  </ul></li>
  <li><a href="#gramáticas-de-atributos-formalizando-a-análise-semântica" id="toc-gramáticas-de-atributos-formalizando-a-análise-semântica" class="nav-link" data-scroll-target="#gramáticas-de-atributos-formalizando-a-análise-semântica"><span class="header-section-number">10.5</span> Gramáticas de Atributos: Formalizando a Análise Semântica</a>
  <ul class="collapse">
  <li><a href="#da-intuição-ao-formalismo-atributos-e-regras-semânticas" id="toc-da-intuição-ao-formalismo-atributos-e-regras-semânticas" class="nav-link" data-scroll-target="#da-intuição-ao-formalismo-atributos-e-regras-semânticas"><span class="header-section-number">10.5.1</span> Da Intuição ao Formalismo: Atributos e Regras Semânticas</a></li>
  <li><a href="#atributos-sintetizados-e-herdados-o-fluxo-de-informação" id="toc-atributos-sintetizados-e-herdados-o-fluxo-de-informação" class="nav-link" data-scroll-target="#atributos-sintetizados-e-herdados-o-fluxo-de-informação"><span class="header-section-number">10.5.2</span> Atributos Sintetizados e Herdados: O Fluxo de Informação</a></li>
  <li><a href="#definição-formal-e-exemplos-práticos" id="toc-definição-formal-e-exemplos-práticos" class="nav-link" data-scroll-target="#definição-formal-e-exemplos-práticos"><span class="header-section-number">10.5.3</span> Definição Formal E Exemplos Práticos</a></li>
  <li><a href="#avaliação-de-atributos-grafos-de-dependência-e-ordenação-topológica" id="toc-avaliação-de-atributos-grafos-de-dependência-e-ordenação-topológica" class="nav-link" data-scroll-target="#avaliação-de-atributos-grafos-de-dependência-e-ordenação-topológica"><span class="header-section-number">10.5.4</span> Avaliação de Atributos: Grafos de Dependência e Ordenação Topológica</a></li>
  <li><a href="#classes-de-gramáticas-de-atributos-e-o-impacto-na-eficiência" id="toc-classes-de-gramáticas-de-atributos-e-o-impacto-na-eficiência" class="nav-link" data-scroll-target="#classes-de-gramáticas-de-atributos-e-o-impacto-na-eficiência"><span class="header-section-number">10.5.5</span> Classes de Gramáticas de Atributos e o Impacto na Eficiência</a></li>
  <li><a href="#definição-formal-e-exemplo-prático" id="toc-definição-formal-e-exemplo-prático" class="nav-link" data-scroll-target="#definição-formal-e-exemplo-prático"><span class="header-section-number">10.5.6</span> Definição Formal e Exemplo Prático</a></li>
  <li><a href="#esquemas-de-tradução-dirigida-por-sintaxe-sdt" id="toc-esquemas-de-tradução-dirigida-por-sintaxe-sdt" class="nav-link" data-scroll-target="#esquemas-de-tradução-dirigida-por-sintaxe-sdt"><span class="header-section-number">10.5.7</span> Esquemas de Tradução Dirigida por Sintaxe (SDT)</a></li>
  </ul></li>
  <li><a href="#catálogo-de-verificações-semânticas-comuns" id="toc-catálogo-de-verificações-semânticas-comuns" class="nav-link" data-scroll-target="#catálogo-de-verificações-semânticas-comuns"><span class="header-section-number">10.6</span> Catálogo de Verificações Semânticas Comuns</a>
  <ul class="collapse">
  <li><a href="#verificações-relacionadas-a-nomes-e-escopos" id="toc-verificações-relacionadas-a-nomes-e-escopos" class="nav-link" data-scroll-target="#verificações-relacionadas-a-nomes-e-escopos"><span class="header-section-number">10.6.1</span> Verificações Relacionadas a Nomes e Escopos</a></li>
  <li><a href="#verificações-de-tipo" id="toc-verificações-de-tipo" class="nav-link" data-scroll-target="#verificações-de-tipo"><span class="header-section-number">10.6.2</span> Verificações de Tipo</a></li>
  <li><a href="#verificações-relacionadas-a-sub-rotinas-funçõesmétodos" id="toc-verificações-relacionadas-a-sub-rotinas-funçõesmétodos" class="nav-link" data-scroll-target="#verificações-relacionadas-a-sub-rotinas-funçõesmétodos"><span class="header-section-number">10.6.3</span> Verificações Relacionadas a Sub-rotinas (Funções/Métodos)</a></li>
  <li><a href="#verificações-de-controle-de-fluxo" id="toc-verificações-de-controle-de-fluxo" class="nav-link" data-scroll-target="#verificações-de-controle-de-fluxo"><span class="header-section-number">10.6.4</span> Verificações de Controle de Fluxo</a></li>
  </ul></li>
  <li><a href="#o-produto-final-a-árvore-de-sintaxe-abstrata-atribuída" id="toc-o-produto-final-a-árvore-de-sintaxe-abstrata-atribuída" class="nav-link" data-scroll-target="#o-produto-final-a-árvore-de-sintaxe-abstrata-atribuída"><span class="header-section-number">10.7</span> O Produto Final: A Árvore de Sintaxe Abstrata <em>Atribuída</em></a></li>
  <li><a href="#verificação-de-tipos-type-checking" id="toc-verificação-de-tipos-type-checking" class="nav-link" data-scroll-target="#verificação-de-tipos-type-checking"><span class="header-section-number">10.8</span> Verificação de Tipos, <em>Type Checking</em></a>
  <ul class="collapse">
  <li><a href="#a-importância-dos-tipos-prevenindo-o-absurdo-computacional" id="toc-a-importância-dos-tipos-prevenindo-o-absurdo-computacional" class="nav-link" data-scroll-target="#a-importância-dos-tipos-prevenindo-o-absurdo-computacional"><span class="header-section-number">10.8.1</span> A Importância dos Tipos: Prevenindo o “Absurdo” Computacional</a></li>
  <li><a href="#equivalência-de-tipos-quando-t1-é-igual-a-t2" id="toc-equivalência-de-tipos-quando-t1-é-igual-a-t2" class="nav-link" data-scroll-target="#equivalência-de-tipos-quando-t1-é-igual-a-t2"><span class="header-section-number">10.8.2</span> Equivalência de Tipos: Quando T1 é igual a T2?</a></li>
  <li><a href="#compatibilidade-de-tipos-coerção-e-conversão-casting" id="toc-compatibilidade-de-tipos-coerção-e-conversão-casting" class="nav-link" data-scroll-target="#compatibilidade-de-tipos-coerção-e-conversão-casting"><span class="header-section-number">10.8.3</span> Compatibilidade de Tipos: Coerção e Conversão (Casting)</a></li>
  <li><a href="#lidando-com-polimorfismo-muitas-formas" id="toc-lidando-com-polimorfismo-muitas-formas" class="nav-link" data-scroll-target="#lidando-com-polimorfismo-muitas-formas"><span class="header-section-number">10.8.4</span> Lidando com Polimorfismo: “Muitas Formas”</a></li>
  <li><a href="#a-base-formal-dos-sistemas-de-tipos" id="toc-a-base-formal-dos-sistemas-de-tipos" class="nav-link" data-scroll-target="#a-base-formal-dos-sistemas-de-tipos"><span class="header-section-number">10.8.5</span> A Base Formal dos Sistemas de Tipos</a></li>
  <li><a href="#construindo-uma-árvore-de-derivação-um-exemplo-prático" id="toc-construindo-uma-árvore-de-derivação-um-exemplo-prático" class="nav-link" data-scroll-target="#construindo-uma-árvore-de-derivação-um-exemplo-prático"><span class="header-section-number">10.8.6</span> Construindo uma Árvore de Derivação: Um Exemplo Prático</a></li>
  <li><a href="#exemplo-adicional-verificação-de-tipos-em-c" id="toc-exemplo-adicional-verificação-de-tipos-em-c" class="nav-link" data-scroll-target="#exemplo-adicional-verificação-de-tipos-em-c"><span class="header-section-number">10.8.7</span> Exemplo Adicional: Verificação de Tipos em <strong>C++</strong></a></li>
  </ul></li>
  <li><a href="#exercícios-da-seção" id="toc-exercícios-da-seção" class="nav-link" data-scroll-target="#exercícios-da-seção"><span class="header-section-number">10.9</span> Exercícios da Seção</a>
  <ul class="collapse">
  <li><a href="#questão-1-considerando-que-estamos-trabalhando-em-uma-liguagem-de-programação-na-qual-o-contexto-pode-ser-formado-de-objetos-o-métodos-m-e-classes-c.-qual-a-regra-de-dedução-para-o-julgamento-de-tipo-para-a-adição-de-inteiros" id="toc-questão-1-considerando-que-estamos-trabalhando-em-uma-liguagem-de-programação-na-qual-o-contexto-pode-ser-formado-de-objetos-o-métodos-m-e-classes-c.-qual-a-regra-de-dedução-para-o-julgamento-de-tipo-para-a-adição-de-inteiros" class="nav-link" data-scroll-target="#questão-1-considerando-que-estamos-trabalhando-em-uma-liguagem-de-programação-na-qual-o-contexto-pode-ser-formado-de-objetos-o-métodos-m-e-classes-c.-qual-a-regra-de-dedução-para-o-julgamento-de-tipo-para-a-adição-de-inteiros"><span class="header-section-number">10.9.1</span> Questão 1: Considerando que estamos trabalhando em uma liguagem de programação na qual o contexto pode ser formado de objetos <span class="math inline">\(O\)</span>, métodos <span class="math inline">\(M\)</span> e classes <span class="math inline">\(C\)</span>. Qual a regra de dedução para o julgamento de tipo para a adição de inteiros?</a></li>
  <li><a href="#questão-2-no-mesmo-ambiente-da-questão-um.-como-seria-o-julgamento-de-tipo-para-instruções-if" id="toc-questão-2-no-mesmo-ambiente-da-questão-um.-como-seria-o-julgamento-de-tipo-para-instruções-if" class="nav-link" data-scroll-target="#questão-2-no-mesmo-ambiente-da-questão-um.-como-seria-o-julgamento-de-tipo-para-instruções-if"><span class="header-section-number">10.9.2</span> Questão 2: No mesmo ambiente da questão um. Como seria o julgamento de tipo para instruções <code>IF</code>?</a></li>
  <li><a href="#questão-3-o-que-a-seguinte-regra-significa-como-lemos-ela" id="toc-questão-3-o-que-a-seguinte-regra-significa-como-lemos-ela" class="nav-link" data-scroll-target="#questão-3-o-que-a-seguinte-regra-significa-como-lemos-ela"><span class="header-section-number">10.9.3</span> Questão 3: O que a seguinte regra significa? Como lemos ela?</a></li>
  <li><a href="#questão-4-considere-uma-linguagem-de-programação-que-suporta-variáveis-funções-e-expressões-aritméticas-com-tipos-inteiro-real-e-string.-crie-um-sistema-de-tipos-com-cálculo-de-sequentes-e-escreva-as-regra-de-tipagem-para-a-declaração-de-variáveis-operações-aritméticas-strings-e-para-a-chamada-de-função." id="toc-questão-4-considere-uma-linguagem-de-programação-que-suporta-variáveis-funções-e-expressões-aritméticas-com-tipos-inteiro-real-e-string.-crie-um-sistema-de-tipos-com-cálculo-de-sequentes-e-escreva-as-regra-de-tipagem-para-a-declaração-de-variáveis-operações-aritméticas-strings-e-para-a-chamada-de-função." class="nav-link" data-scroll-target="#questão-4-considere-uma-linguagem-de-programação-que-suporta-variáveis-funções-e-expressões-aritméticas-com-tipos-inteiro-real-e-string.-crie-um-sistema-de-tipos-com-cálculo-de-sequentes-e-escreva-as-regra-de-tipagem-para-a-declaração-de-variáveis-operações-aritméticas-strings-e-para-a-chamada-de-função."><span class="header-section-number">10.9.4</span> Questão 4: Considere uma linguagem de programação que suporta variáveis, funções e expressões aritméticas com tipos inteiro, real e <em>string</em>. Crie um sistema de tipos com Cálculo de Sequentes e escreva as regra de tipagem para a declaração de variáveis, operações aritméticas, <em>strings</em> e para a chamada de função.</a></li>
  <li><a href="#complexidade-da-verificação-e-inferência-de-tipos" id="toc-complexidade-da-verificação-e-inferência-de-tipos" class="nav-link" data-scroll-target="#complexidade-da-verificação-e-inferência-de-tipos"><span class="header-section-number">10.9.5</span> Complexidade da Verificação e Inferência de Tipos</a></li>
  </ul></li>
  <li><a href="#implementação-prática-da-teoria-à-prática" id="toc-implementação-prática-da-teoria-à-prática" class="nav-link" data-scroll-target="#implementação-prática-da-teoria-à-prática"><span class="header-section-number">10.10</span> Implementação Prática: Da Teoria à Prática</a>
  <ul class="collapse">
  <li><a href="#definição-da-mini-linguagem-langarit" id="toc-definição-da-mini-linguagem-langarit" class="nav-link" data-scroll-target="#definição-da-mini-linguagem-langarit"><span class="header-section-number">10.10.1</span> Definição da Mini-Linguagem: Langarit</a></li>
  <li><a href="#gramática-livre-de-contexto-para-langarit" id="toc-gramática-livre-de-contexto-para-langarit" class="nav-link" data-scroll-target="#gramática-livre-de-contexto-para-langarit"><span class="header-section-number">10.10.2</span> Gramática Livre de Contexto para Langarit</a></li>
  <li><a href="#gramática-de-atributos-para-langarit" id="toc-gramática-de-atributos-para-langarit" class="nav-link" data-scroll-target="#gramática-de-atributos-para-langarit"><span class="header-section-number">10.10.3</span> Gramática de Atributos para Langarit</a></li>
  <li><a href="#implementação-empython" id="toc-implementação-empython" class="nav-link" data-scroll-target="#implementação-empython"><span class="header-section-number">10.10.4</span> Implementação em<strong>Python</strong></a></li>
  <li><a href="#exemplo-de-uso-completo" id="toc-exemplo-de-uso-completo" class="nav-link" data-scroll-target="#exemplo-de-uso-completo"><span class="header-section-number">10.10.5</span> Exemplo de Uso Completo</a></li>
  <li><a href="#saída-esperada" id="toc-saída-esperada" class="nav-link" data-scroll-target="#saída-esperada"><span class="header-section-number">10.10.6</span> Saída Esperada</a></li>
  <li><a href="#exercícios-propostos" id="toc-exercícios-propostos" class="nav-link" data-scroll-target="#exercícios-propostos"><span class="header-section-number">10.10.7</span> Exercícios Propostos</a></li>
  </ul></li>
  <li><a href="#a-ponte-para-a-geração-de-código-intermediário" id="toc-a-ponte-para-a-geração-de-código-intermediário" class="nav-link" data-scroll-target="#a-ponte-para-a-geração-de-código-intermediário"><span class="header-section-number">10.11</span> A Ponte para a Geração de Código Intermediário</a>
  <ul class="collapse">
  <li><a href="#da-análise-à-síntese-o-papel-da-ast-atribuída" id="toc-da-análise-à-síntese-o-papel-da-ast-atribuída" class="nav-link" data-scroll-target="#da-análise-à-síntese-o-papel-da-ast-atribuída"><span class="header-section-number">10.11.1</span> Da Análise à Síntese: O Papel da <strong>AST</strong> Atribuída</a></li>
  <li><a href="#código-de-três-endereços-tac-uma-representação-linear" id="toc-código-de-três-endereços-tac-uma-representação-linear" class="nav-link" data-scroll-target="#código-de-três-endereços-tac-uma-representação-linear"><span class="header-section-number">10.11.2</span> Código de Três Endereços (TAC): Uma Representação Linear</a></li>
  <li><a href="#exemplo-de-tradução-gerando-tac-a-partir-da-ast-atribuída" id="toc-exemplo-de-tradução-gerando-tac-a-partir-da-ast-atribuída" class="nav-link" data-scroll-target="#exemplo-de-tradução-gerando-tac-a-partir-da-ast-atribuída"><span class="header-section-number">10.11.3</span> Exemplo de Tradução: Gerando TAC a partir da <strong>AST</strong> Atribuída</a></li>
  </ul></li>
  <li><a href="#exercícios" id="toc-exercícios" class="nav-link" data-scroll-target="#exercícios"><span class="header-section-number">10.12</span> Exercícios</a>
  <ul class="collapse">
  <li><a href="#exercício-1-semântica-básica" id="toc-exercício-1-semântica-básica" class="nav-link" data-scroll-target="#exercício-1-semântica-básica"><span class="header-section-number">10.12.1</span> Exercício 1: Semântica Básica</a></li>
  <li><a href="#exercício-2-análise-de-tipos" id="toc-exercício-2-análise-de-tipos" class="nav-link" data-scroll-target="#exercício-2-análise-de-tipos"><span class="header-section-number">10.12.2</span> Exercício 2: Análise de Tipos</a></li>
  <li><a href="#exercício-3-otimização" id="toc-exercício-3-otimização" class="nav-link" data-scroll-target="#exercício-3-otimização"><span class="header-section-number">10.12.3</span> Exercício 3: Otimização</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/10-semantico.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./10-semantico.html">Analisadores Semânticos</a></li><li class="breadcrumb-item"><a href="./10-semantico.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Analisadores Semânticos: a determinação do significado</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Analisadores Semânticos: a determinação do significado</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\10-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>Após as fases de análise léxica e sintática, um compilador já será capaz de reconhecer corretamente a estrutura de um programa. Ele pode afirmar, com certeza, que uma sequência de <em>tokens</em> como <code>int x = y + z;</code> conforma-se à gramática de uma declaração de variável seguida de uma atribuição e é formado por um conjunto de <em>tokens</em> válido na linguagem. Contudo, a análise sintática é agvérticestica ao significado. Ela não sabe o que <code>int</code>, <code>x</code>, <code>y</code> ou <code>z</code> significam. Foram <code>y</code> e <code>z</code> declarados anteriormente? Seus tipos são compatíveis com o operador <code>+</code>? O resultado pode ser armazenado em uma variável do tipo <code>int</code>? Responder a essas perguntas é a tarefa da análise semântica.</p>
<p>A análise sintática garante que um programa tem a forma correta, mas não garante que ele faz qualquer sentido. A atenta leitora talvez já tenha se deparado com a famosa frase do linguista <a href="https://en.wikipedia.org/wiki/Noam_Chomsky">Noam Chomsky</a>: <em>Colorless green ideas sleep furiously</em>, Ideias verdes incolores dormem furiosamente. Esta frase é, de longe, a forma mais simples de entender o valor da análise semântica. A frase é gramaticalmente sintaticamente impecável em inglês, um adjetivo precede outro adjetivo que precede um substantivo, seguido por um verbo e um advérbio. Ainda assim, semanticamente, <em>Colorless green ideas sleep furiously</em> é um disparate agressivo.</p>
<p>Em linguagens de programação, este tipo de disparate pode acontecer com mais frequência do que a sociedade deveria poder aguentar. Por exemplo, uma gramática livre de contexto poderia perfeitamente aceitar a construção <code>x = "olá" * 5;</code>. Estruturalmente, temos um identificador, um operador de atribuição e uma expressão. No entanto, para a maioria das linguagens, multiplicar uma <em>string</em> por um número, exceto em casos específicos como em <strong>Python</strong>, é uma operação sem significado. Um comportamento contra-intuitivo mesmo que a linguagem permita. Cabe a análise semântica detectar e rejeitar tais absurdos. Exceto quando a linguagem permitir, claro.</p>
<p>A análise semântica é a fase do compilador que preenche essa lacuna, verificando se as construções sintaticamente válidas formam um conjunto de instruções coerente e com significado, de acordo com as regras da linguagem. Mesmo que as regras sejam contra-intuitivas como algumas do <strong>Python</strong> e outras do <strong>JavaScript</strong>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Contra-intuições Semânticas Em</strong>Python****</p>
<pre class="**python**"><code># Multiplicação de string por booleano
resultado = "texto" * True # Retorna "texto"
resultado = "texto" * False # Retorna ""

# Soma de booleanos com números
valor = True + True + False # Retorna 2
valor = 50 + True # Retorna 51

# Lista multiplicada por número negativo
lista = [1, 2, 3] * -1 # Retorna []

# Uso de and/or para retornar valores não booleanos
resultado = 0 or "default" # Retorna "default"
resultado = 5 and "texto" # Retorna "texto"</code></pre>
<p><strong>Contra-intuições Semânticas Em </strong>Java<strong>Script</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// NaN não é igual a si mesmo</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="kw">NaN</span> <span class="op">===</span> <span class="kw">NaN</span><span class="op">;</span> <span class="co">// Retorna false</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Conversão implícita em comparações</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="st">"5"</span> <span class="op">-</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Retorna 2</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="st">"5"</span> <span class="op">+</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Retorna "53"</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Incremento de string numérica</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="st">"5"</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>x<span class="op">++;</span> <span class="co">// x agora é 6 (número)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Array com buracos</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>arr<span class="op">.</span><span class="at">length</span><span class="op">;</span> <span class="co">// Retorna 3</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>arr[<span class="dv">1</span>]<span class="op">;</span> <span class="co">// Retorna undefined</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Conversão de booleano para número</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="kw">true</span> <span class="op">+</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Retorna 2</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="kw">true</span> <span class="op">-</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// Retorna 1</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">// Infinity é um número</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="kw">typeof</span> <span class="kw">Infinity</span><span class="op">;</span> <span class="co">// Retorna "number"</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">0</span><span class="op">;</span> <span class="co">// Retorna Infinity</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>A análise semântica é a ponte que conecta a estrutura à semântica, garantindo que o programa não seja apenas bem-formado, mas também que tenha sentido.</p>
<section id="perspectiva-histórica-a-evolução-da-análise-semântica" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="perspectiva-histórica-a-evolução-da-análise-semântica"><span class="header-section-number">10.1</span> Perspectiva Histórica: A Evolução da Análise Semântica</h2>
<p>A <strong>análise semântica</strong>, o centro nervoso do compilador para significado e a coerência, não nasceu pronta. Sua história é uma jornada que acompanha a própria evolução das linguagens de programação, partindo de verificações simples e dispersas para se tornar uma estrutura formal e sofisticada. A incansável leitora poderá traçar essa trajetória desde os primórdios da computação até os complexos sistemas de tipos que usamos hoje. A Figura <a href="#fig-timeline-semantics" class="quarto-xref">Figure&nbsp;<span>10.1</span></a> ilustra essa evolução.</p>
<div id="fig-timeline-semantics" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-timeline-semantics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/semaHistory.webp" class="img-fluid figure-img"></p>
<figcaption>Linha do Tempo da Análise Semântica</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-timeline-semantics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.1
</figcaption>
</figure>
</div>
<p>Nos primeiros dias da compilação, com linguagens como o <strong>FORTRAN I (1957)</strong>, a análise semântica era uma atividade <em>ad-hoc</em>. Não havia uma fase distinta especificamente destinada a análise de sentido; as verificações de tipo e coerência eram feitas de forma improvisada, entrelaçadas diretamente com a lógica de geração de código. O objetivo era fazer o programa funcionar, e a separação de responsabilidades era uma ambição distante. Vamos fixar o marco inicial desta jornada de criação e evolução no <strong>ALGOL 60 (1960)</strong>. O projeto de linguagem de programação que fez a primeira tentativa séria de separar a sintaxe (a forma) da semântica (o significado). Mais importante, o <strong>ALGOL 60</strong> introduziu o conceito revolucionário da <strong>estrutura de blocos</strong> e, consequentemente, do <strong>escopo léxico</strong>, forçando os compiladores a entenderem em que bloco de código uma determinada variável era válida. Sem dúvidas uma das primeiras tarefas verdadeiramente semânticas atribuídas a um compilador.</p>
<p>A necessidade de rigor, programas que rodassem sempre da mesma forma e com os mesmos resultados, levou a uma era de formalização na década seguinte. Em vez de manter um conjunto regras desconexas espalhadas pelo código do compilador, os pesquisadores buscaram uma base teórica sólida. Que explicassem, justificassem e formalizassem a análise semântica. Neste interim, <strong>Robert Floyd (1967)</strong> contribuiu ao associar a semântica dos programas à lógica formal através de asserções e invariantes. Contudo, o grande salto foi dado por <strong>Donald Knuth (1968)</strong> com suas <strong>Gramáticas de Atributos</strong>. Pela primeira vez, havia um formalismo poderoso e sistemático para descrever e implementar a análise semântica. As regras semânticas podiam agora ser <em>anexadas</em> diretamente às regras da gramática sintática, permitindo que informações como tipos de dados fluíssem pela árvore sintática de forma estruturada. A linguagem <strong>Pascal</strong>, projetada por <strong>Niklaus Wirth (1971)</strong>, foi um exemplo brilhante dessa nova abordagem, demonstrando como uma análise semântica completa e estruturada poderia ser elegantemente implementada em um único passo. Neste ponto, tínhamos a base teórica, Floyd, uma formatação prática, Knuth, e uma linguagem que a utilizava, Wirth.</p>
<p>Com fundamentos sólidos estabelecidos, a fase seguinte foi de sistematização e popularização. O livro <em>Principles of Compiler Design</em> de <strong>Aho e Ullman (1977)</strong>, o famoso <strong>Livro do Dragão</strong>, estabeleceu a estrutura canônica dos compiladores, consolidando a análise semântica como uma fase bem definida. Paralelamente, a linguagem <strong>C</strong>, desenvolvida por <strong>Dennis Ritchie (1972)</strong> e padronizada neste período, demonstrava que um sistema de tipos simples mas rigoroso poderia ser extremamente eficaz, influenciando profundamente o design de compiladores com sua abordagem pragmática de verificação de tipos em tempo de compilação. Foi nesse período que uma das ideias mais poderosas da teoria das linguagens surgiu: a <strong>inferência de tipos</strong>. O <strong>algoritmo W</strong>, desenvolvido por <strong>Robin Milner (1978)</strong> para a linguagem ML, permitiu que o compilador deduzisse os tipos das variáveis automaticamente, sem a necessidade de anotações explícitas, combinando segurança e flexibilidade de uma forma inédita, um contraste marcante com a filosofia da linguagem <strong>C</strong>, que exigia declarações explícitas mas oferecia controle direto sobre a representação em memória. Ao mesmo tempo, linguagens como <strong>Ada (1983)</strong> exploravam o outro extremo, implementando sistemas de tipos extremamente ricos e complexos, projetados para a construção de software robusto e de missão crítica, enquanto o <strong>C</strong> mantinha sua posição como a escolha para programação de sistemas, nos quais a previsibilidade e o controle fino da memória e performance eram mais valorizados que a expressividade do sistema de tipos.</p>
<p>A partir de meados da década de 1980, a complexidade das linguagens explodiu, trazendo consigo desafios semânticos sem precedentes. O <strong>C++ (1985)</strong>, com a introdução de <strong>templates</strong> e <strong>sobrecarga</strong> de funções e operadores, exigiu que os analisadores semânticos resolvessem nomes e tipos em contextos muito mais elaborados. O <strong>Java (1995)</strong> popularizou um modelo híbrido, realizando verificações de tipo rigorosas tanto em tempo de compilação quanto em tempo de execução através da <strong>JVM</strong>. Paralelamente, a tradição funcional, representada pelo <strong>Haskell (1990)</strong>, continuou a empurrar as fronteiras da teoria, introduzindo conceitos como <strong>type classes</strong> e polimorfismo paramétrico avançado, que hoje influenciam o design de muitas linguagens modernas.</p>
</section>
<section id="da-necessidade-à-solução-por-que-gramáticas-de-atributos" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="da-necessidade-à-solução-por-que-gramáticas-de-atributos"><span class="header-section-number">10.2</span> Da Necessidade à Solução: Por Que Gramáticas de Atributos?</h2>
<p>A evolução histórica da análise semântica que acabamos de traçar revela um padrão: à medida que as linguagens de programação se tornavam mais expressivas, as verificações semânticas necessárias cresciam em número e complexidade. Contudo, um problema fundamental permanecia sem solução satisfatória: <strong>como especificar formalmente essas verificações?</strong></p>
<p>As gramáticas livres de contexto (<strong>GLC</strong>), poderosas para descrever a sintaxe, revelavam-se insuficientes para capturar regras semânticas. Considere a regra <em>toda variável deve ser declarada antes de seu uso</em>. Uma <strong>GLC</strong> pode garantir que <code>x = y + z;</code> seja uma atribuição sintaticamente válida, mas não pode verificar se <code>y</code> e <code>z</code> foram previamente declarados. Este tipo de restrição é <strong>sensível ao contexto</strong> e depende de informações que estão fora da estrutura local da produção.</p>
<p>Durante os anos 1960, a análise semântica nos compiladores era implementada como código <em>ad-hoc</em> espalhado pelo parser. Cada compilador tinha sua própria abordagem, muitas vezes não documentada e difícil de manter. Não havia uma especificação formal da semântica, apenas a implementação. Isso criava problemas sérios:</p>
<ol type="1">
<li><strong>Não-portabilidade</strong>: reaproveitar código entre compiladores era praticamente impossível;</li>
<li><strong>Verificação impossível</strong>: sem especificação formal, não havia como provar que a implementação estava correta;</li>
<li><strong>Manutenção custosa</strong>: modificar ou estender as regras semânticas exigia alterações profundas no código do compilador;</li>
<li><strong>Falta de clareza</strong>: a semântica da linguagem estava implícita no código, não explícita em documentação.</li>
</ol>
<p>A comunidade de compiladores necessitava de um formalismo que:</p>
<ul>
<li>Estendesse naturalmente as <strong>GLC</strong>s, mantendo sua elegância matemática;</li>
<li>Permitisse especificar como informação contextual flui pela árvore sintática;</li>
<li>Fosse implementável de forma sistemática e automática;</li>
<li>Servisse tanto como especificação quanto como base para implementação.</li>
</ul>
<p>A resposta veio em 1968, quando <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a> introduziu as <strong>Gramáticas de Atributos</strong>. Sua ideia central era engenhosamente simples: se as produções da gramática descrevem a estrutura do programa, por que não anotar essas mesmas produções com regras que descrevem o significado? Em vez de criar um formalismo completamente novo, Knuth estendeu as <strong>GLC</strong>s adicionando duas características:</p>
<ol type="1">
<li><strong>Atributos</strong>: propriedades associadas aos símbolos gramaticais, como o tipo de uma expressão;</li>
<li><strong>Regras Semânticas</strong>: equações que definem como calcular atributos a partir de outros atributos.</li>
</ol>
<p>Esta abordagem unificava sintaxe e semântica sob um único formalismo matemático. A análise semântica deixava de ser código disperso para se tornar um conjunto de equações anexadas à gramática, verificável, modular e automaticamente implementável. Era a ponte que faltava entre a teoria formal das linguagens e a prática da construção de compiladores.</p>
</section>
<section id="a-análise-semântica-no-contexto-do-compilador" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="a-análise-semântica-no-contexto-do-compilador"><span class="header-section-number">10.3</span> A Análise Semântica no Contexto do Compilador</h2>
<p>Considerando a estrutura de compilação canônica, como definida por <a href="https://en.wikipedia.org/wiki/Alfred_Aho">Aho</a> (1977), e histórica que estamos adotando ao longo de todo este livro, a análise semântica será a terceira fase do <em>front-end</em> de um compilador, posicionando-se logo após a análise sintática. Como pode ser visto na Figura <a href="#fig-compilador1" class="quarto-xref">Figure&nbsp;<span>10.2</span></a>. A principal informação de entrada do analisador semântico será a Árvore de Sintática Abstrata, termo importado do inglês <strong>A</strong>bstract <strong>S</strong>yntactic <strong>T</strong>ree, <strong>AST</strong>, a representação hierárquica da estrutura do programa que foi gerada pelo analisador sintático.</p>
<div id="fig-compilador1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-compilador1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Compiler_Diagram.webp" class="img-fluid figure-img"></p>
<figcaption>Fases do Compilador</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-compilador1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.2
</figcaption>
</figure>
</div>
<p>É importante que a sagaz leitora compreenda que, nos compiladores modernos, a análise semântica raramente é um módulo completamente separado que será executado após o término da análise sintática. Neste texto, usaremos esta divisão por motivos didáticos e um pouco de preguiça. Ok, confesso, muita preguiça. Mas, a verdade é que na maior parte dos compiladores modernos, a análise semântica está implementada como um conjunto de procedimentos, conhecidos como <em>ações semânticas</em>, que serão invocados pelo analisador sintático em momentos específicos e importantes da geração da <strong>AST</strong>. Por exemplo, em um analisador sintático de descida recursiva, <span class="math inline">\(LL(k)\)</span>, as chamadas para as rotinas de verificação semântica podem, simplesmente, ser inseridas no corpo das funções que fazem o <em>parse</em> de cada regra da gramática. Em um analisador <span class="math inline">\(LR(k)\)</span>, <em>bottom-up</em>, uma ação semântica pode ser disparada sempre que o <em>parser</em> realizar uma redução, ou seja, quando reconhece o lado direito de uma produção da gramática.</p>
<p>Essa integração entre as fases sintática e semântica está fundamentada em uma decisão de projeto: a arquitetura do compilador será de <strong>uma única passagem</strong>, <em>one-pass</em>, ou de <strong>múltiplas passagens</strong>, <em>multi-pass</em>? São opções diferentes com impacto profundo na complexidade, desempenho e flexibilidade do compilador.</p>
<p><strong>Compiladores de uma passagem</strong>: intercalam a análise léxica, sintática, semântica e até a geração de código em uma única travessia do código-fonte. São extremamente rápidos, mas impõem restrições à linguagem, como a exigência de que todas as entidades sejam declaradas antes de serem usadas.</p>
<p><strong>Compiladores de múltiplas passagens</strong>: utilizam a <strong>AST</strong> como uma representação intermediária entre as fases. A primeira passagem constrói a <strong>AST</strong>, e passagens subsequentes a percorrem para realizar a análise semântica, otimizações e, finalmente, a geração de código. Essa abordagem é mais modular, flexível e adequada para linguagens complexas como <strong>C++</strong> ou <strong>Java</strong>, que permitem declarações em qualquer ordem. A <strong>AST</strong>, nesse contexto, não é apenas uma estrutura de dados, mas uma estrutura de dados que desacopla a sintaxe do significado.</p>
</section>
<section id="semântica-estática-vs.-dinâmica-o-limite-da-compilação" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="semântica-estática-vs.-dinâmica-o-limite-da-compilação"><span class="header-section-number">10.4</span> Semântica Estática vs.&nbsp;Dinâmica: O Limite da Compilação</h2>
<p>As regras semânticas de uma linguagem se dividem em duas categorias, que definem o que pode e o que não pode ser verificado antes da execução do programa. Estas categorias são:</p>
<p><strong>Semântica Estática</strong>: compreende todas as regras de significado que podem ser verificadas em <strong>tempo de compilação</strong>. Essas regras são chamadas de estáticas porque a verificação ocorre através da análise do código-fonte, sem necessidade de execução. A análise semântica concentra-se primariamente em impor essas regras estáticas, que podem ser categorizadas em:</p>
<p><strong>1. Verificações de Escopo e Declarações</strong>:</p>
<ul>
<li>Toda variável deve ser declarada antes de seu uso;</li>
<li>Identificadores não podem ser redeclarados no mesmo escopo;</li>
<li>Variáveis locais ocultam variáveis de escopos externos conforme as regras da linguagem.</li>
</ul>
<p><strong>2. Verificações de Tipos</strong>:</p>
<ul>
<li>Os tipos dos operandos de uma expressão devem ser compatíveis com o operador;</li>
<li>O tipo da expressão atribuída deve ser compatível com o tipo da variável receptora;</li>
<li>Expressões condicionais (<code>if</code>, <code>while</code>) devem resultar em valores booleanos;</li>
<li>Operações de indexação de arrays devem usar índices inteiros.</li>
</ul>
<p><strong>3. Verificações de Sub-rotinas</strong>:</p>
<ul>
<li>Funções devem ser chamadas com o número correto de argumentos;</li>
<li>Os tipos dos argumentos passados devem corresponder aos tipos dos parâmetros formais;</li>
<li>O tipo do valor retornado deve corresponder ao tipo de retorno declarado;</li>
<li>Funções não-void devem ter pelo menos um comando <code>return</code> em todos os caminhos de execução.</li>
</ul>
<p><strong>4. Verificações de Fluxo de Controle</strong>:</p>
<ul>
<li>Comandos <code>break</code> e <code>continue</code> só podem aparecer dentro de laços;</li>
<li>Comandos <code>return</code> só podem aparecer dentro de funções;</li>
<li>Labels referenciados por <code>goto</code> devem existir no escopo da função;</li>
<li>Em linguagens com <code>switch</code>, valores de <code>case</code> devem ser únicos e do tipo compatível.</li>
</ul>
<p><strong>5. Verificações de Unicidade e Consistência</strong>:</p>
<ul>
<li>Campos de estruturas/classes não podem ter nomes duplicados;</li>
<li>Enumerações não podem ter valores duplicados (quando aplicável);</li>
<li>Modificadores de acesso (<code>public</code>, <code>private</code>) devem ser mutuamente exclusivos;</li>
<li>Sobrecarga de funções deve ter assinaturas distintas.</li>
</ul>
<p><strong>6. Verificações de Acessibilidade</strong>:</p>
<ul>
<li>Membros <code>private</code> só podem ser acessados dentro da própria classe;</li>
<li>Membros <code>protected</code> seguem regras de visibilidade conforme hierarquia de herança;</li>
<li>Variáveis <code>const</code>/<code>final</code> não podem ser modificadas após inicialização.</li>
</ul>
<p>A leitora deve observar que essas regras são frequentemente <strong>dependentes de contexto</strong>, característica que as gramáticas livres de contexto, por si sós, não conseguem capturar. Uma expressão como <code>x + y</code> é sintaticamente válida independente de <code>x</code> e <code>y</code> terem sido declarados ou de seus tipos serem compatíveis com o operador <code>+</code>. É a análise semântica que impõe essas restrições contextuais, fazendo dela, em essência, uma <strong>verificação de contexto sensível</strong>.</p>
<p><strong>Semântica Dinâmica</strong>: refere-se aos aspectos do significado do programa que só podem ser determinados em <strong>tempo de execução</strong>. Diferentemente da semântica estática, essas propriedades dependem dos valores concretos que os dados assumem durante a execução, informação geralmente não disponível durante a compilação. O compilador insere verificações explícitas no código gerado que serão executadas junto com a lógica do programa, detectando violações e gerando exceções ou encerrando a execução.</p>
<p><strong>1. Erros Aritméticos</strong>:</p>
<ul>
<li><strong>Divisão por zero</strong>: impossível detectar estaticamente quando o divisor é uma variável;</li>
<li><strong>Overflow/Underflow aritmético</strong>: quando o resultado de uma operação excede os limites do tipo;</li>
<li><strong>Operações com valores especiais</strong>: operações envolvendo <code>NaN</code>, <code>Infinity</code> em ponto flutuante;</li>
<li><strong>Raiz quadrada de número negativo</strong>: em linguagens sem suporte nativo a números complexos.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> divisor <span class="op">=</span> obterValorDoUsuario<span class="op">();</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> resultado <span class="op">=</span> <span class="dv">100</span> <span class="op">/</span> divisor<span class="op">;</span> <span class="co">// Erro se divisor == 0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> INT_MAX<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b <span class="op">=</span> a <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Overflow: comportamento pode ser indefinido</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>2. Erros de Acesso à Memória</strong>:</p>
<ul>
<li><strong>Desreferenciamento de ponteiro nulo</strong>: acessar memória através de ponteiro não inicializado;</li>
<li><strong>Acesso fora dos limites de array</strong>: índice negativo ou maior/igual ao tamanho do array;</li>
<li><strong>Dangling pointers</strong>: acessar memória já liberada;</li>
<li><strong>Double free</strong>: liberar a mesma região de memória múltiplas vezes;</li>
<li><strong>Memory leaks</strong>: falha em liberar memória alocada (detectável por ferramentas especializadas).</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> numeros <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> indice <span class="op">=</span> <span class="fu">calcularIndice</span><span class="op">();</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> valor <span class="op">=</span> numeros<span class="op">[</span>indice<span class="op">];</span> <span class="co">// Erro se indice &lt; 0 ou indice &gt;= 10</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> texto <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tamanho <span class="op">=</span> texto<span class="op">.</span><span class="fu">length</span><span class="op">();</span> <span class="co">// NullPointerException</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>3. Erros de Tipo Dinâmico</strong>: em linguagens com tipagem dinâmica ou conversões inseguras:</p>
<ul>
<li><strong>Conversão de tipo inválida</strong> (casting incorreto);</li>
<li><strong>Chamada de método inexistente</strong> em objetos de tipo incorreto;</li>
<li><strong>Operações entre tipos incompatíveis</strong> não detectadas estaticamente.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> processar(obj):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> obj.metodo() <span class="co"># Erro se obj não possui metodo()</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="st">"texto"</span> <span class="op">/</span> <span class="dv">2</span> <span class="co"># TypeError em**Python**</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Object</span> obj <span class="op">=</span> <span class="st">"String"</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Integer</span> num <span class="op">=</span> <span class="op">(</span><span class="bu">Integer</span><span class="op">)</span> obj<span class="op">;</span> <span class="co">// ClassCastException em tempo de execução</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>4. Erros de Recursos e Limites do Sistema</strong>:</p>
<ul>
<li><strong>Stack overflow</strong>: recursão muito profunda ou alocação excessiva na pilha;</li>
<li><strong>Heap exhaustion</strong>: falha ao alocar memória dinâmica;</li>
<li><strong>Deadlock</strong>: threads esperando indefinidamente por recursos mutuamente bloqueados;</li>
<li><strong>Timeout</strong>: operações que excedem limites de tempo estabelecidos;</li>
<li><strong>Limites de arquivo/rede</strong>: disco cheio, conexão perdida, arquivo não encontrado.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> recursaoInfinita<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> array<span class="op">[</span><span class="dv">10000</span><span class="op">];</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  recursaoInfinita<span class="op">();</span> <span class="co">// Estoura a pilha</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> p <span class="op">=</span> malloc<span class="op">(</span>SIZE_MAX<span class="op">);</span> <span class="co">// Falha se memória insuficiente</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>5. Violações de Invariantes e Contratos</strong>:</p>
<ul>
<li><strong>Asserções falhando</strong>: condições que deveriam sempre ser verdadeiras;</li>
<li><strong>Pré-condições violadas</strong>: função chamada com argumentos inválidos;</li>
<li><strong>Pós-condições não satisfeitas</strong>: função não produz resultado esperado;</li>
<li><strong>Invariantes de classe quebradas</strong>: estado interno inconsistente.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>assert<span class="op">(</span>saldo <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Falha se invariante violada</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sacar<span class="op">(</span><span class="dt">double</span> valor<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">(</span>valor <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> valor <span class="op">&lt;=</span> saldo<span class="op">);</span> <span class="co">// Pré-condição</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  saldo <span class="op">-=</span> valor<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">(</span>saldo <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Pós-condição</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>6. Erros de Concorrência</strong>:</p>
<ul>
<li><strong>Race conditions</strong>: resultado depende do timing de threads concorrentes;</li>
<li><strong>Deadlocks</strong>: impasse circular na aquisição de recursos;</li>
<li><strong>Starvation</strong>: thread nunca obtém acesso a recurso necessário;</li>
<li><strong>Atomicidade violada</strong>: operação que deveria ser atômica é interrompida.</li>
</ul>
<section id="indecidibilidade-e-trade-offs" class="level3" data-number="10.4.1">
<h3 data-number="10.4.1" class="anchored" data-anchor-id="indecidibilidade-e-trade-offs"><span class="header-section-number">10.4.1</span> Indecidibilidade e <em>Trade-offs</em></h3>
<p>A leitora perspicaz notará que muitos desses problemas são <strong>indecidíveis</strong> estaticamente. O <strong>Problema da Parada</strong> de Turing prova que não existe algoritmo geral que possa determinar se um programa arbitrário terminará ou entrará em loop infinito. Consequentemente:</p>
<ul>
<li>Não é possível determinar estaticamente se um divisor será zero sem executar o código;</li>
<li>Não é possível prever todos os índices de array que serão usados em tempo de execução;</li>
<li>Não é possível detectar todos os deadlocks potenciais através de análise estática.</li>
</ul>
<p>Este fato fundamental força um <em>trade-off</em> no design de linguagens:</p>
<p><strong>Verificações Agressivas (Linguagens Seguras)</strong>:</p>
<ul>
<li><strong>Exemplos</strong>: <strong>Java</strong>, <strong>Python</strong>, <strong>Rust</strong>;</li>
<li><strong>Características</strong>: inserem verificações extensivas em tempo de execução;</li>
<li><strong>Custo</strong>: <em>overhead</em> de performance (5-15% tipicamente);</li>
<li><strong>Benefício</strong>: programas nunca apresentam comportamento indefinido; erros são capturados e reportados.</li>
</ul>
<p><strong>Verificações Mínimas (Linguagens de Sistema)</strong>:</p>
<ul>
<li><strong>Exemplos</strong>: <strong>C</strong>, <strong>C++</strong> (sem flags de sanitização);</li>
<li><strong>Características</strong>: assumem que o programador está correto; comportamento indefinido em erros;</li>
<li><strong>Custo</strong>: programas podem corromper memória silenciosamente, criar vulnerabilidades de segurança;</li>
<li><strong>Benefício</strong>: máxima performance; controle total sobre o hardware.</li>
</ul>
<p><strong>Verificações Opcionais (Abordagem Híbrida)</strong>:</p>
<ul>
<li><strong>Exemplos</strong>: <strong>C++</strong> com sanitizers, <strong>Rust</strong> com <code>unsafe</code>, <strong>Python</strong> com <code>-O</code>;</li>
<li><strong>Características</strong>: verificações podem ser habilitadas/desabilitadas;</li>
<li><strong>Uso típico</strong>: verificações ativadas em desenvolvimento/debug, desativadas em produção.</li>
</ul>
<p>A análise semântica dinâmica representa, portanto, a última linha de defesa do programa contra comportamento incorreto. Enquanto a semântica estática previne erros que podem ser provados impossíveis, a semântica dinâmica detecta erros que só se manifestam sob condições específicas de execução, transformando falhas catastróficas em exceções controláveis.</p>
</section>
</section>
<section id="gramáticas-de-atributos-formalizando-a-análise-semântica" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="gramáticas-de-atributos-formalizando-a-análise-semântica"><span class="header-section-number">10.5</span> Gramáticas de Atributos: Formalizando a Análise Semântica</h2>
<p>Vimos que as gramáticas livres de contexto (GLC) são excelentes para descrever a estrutura sintática de uma linguagem, mas insuficientes para capturar regras contextuais, como a verificação de tipos. Para formalizar a análise semântica de maneira sistemática e rigorosa, precisamos de uma ferramenta mais poderosa. Aqui voltamos a ideia de <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>.</p>
<section id="da-intuição-ao-formalismo-atributos-e-regras-semânticas" class="level3" data-number="10.5.1">
<h3 data-number="10.5.1" class="anchored" data-anchor-id="da-intuição-ao-formalismo-atributos-e-regras-semânticas"><span class="header-section-number">10.5.1</span> Da Intuição ao Formalismo: Atributos e Regras Semânticas</h3>
<p>Uma Gramática de Atributos é, em sua essência, uma Gramática Livre de Contexto na qual cada símbolo gramatical, terminal ou não-terminal, é anotado com um conjunto de <strong>atributos</strong>, e cada produção da gramática é acompanhada por um conjunto de <strong>regras semânticas</strong> que especificam como calcular os valores desses atributos.</p>
<ul>
<li><strong>Atributos</strong>: São propriedades associadas aos vértices da árvore sintática. Eles podem carregar informações como o tipo de uma expressão, o valor de uma constante, uma <em>string</em> de código gerado, ou um ponteiro para a <strong>Tabela de Símbolos</strong>.</li>
<li><strong>Regras Semânticas</strong>: São equações que definem o valor de um atributo em termos dos valores de outros atributos nos vértices vizinhos da árvore sintática (pai, filhos ou irmãos).</li>
</ul>
<p>Esse formalismo transforma a análise semântica em um processo de avaliação de atributos sobre a árvore sintática, um processo conhecido como “decoração” da árvore.</p>
</section>
<section id="atributos-sintetizados-e-herdados-o-fluxo-de-informação" class="level3" data-number="10.5.2">
<h3 data-number="10.5.2" class="anchored" data-anchor-id="atributos-sintetizados-e-herdados-o-fluxo-de-informação"><span class="header-section-number">10.5.2</span> Atributos Sintetizados e Herdados: O Fluxo de Informação</h3>
<p>Os atributos são classificados com base na direção em que a informação flui pela árvore sintática. Como pode ser visto na Figura <a href="#fig-sint-herdados" class="quarto-xref">Figure&nbsp;<span>10.3</span></a>.</p>
<div id="fig-sint-herdados" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-sint-herdados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sintetizadosVsHerdados.webp" class="img-fluid figure-img"></p>
<figcaption>Atributos Sintetizados e Herdados</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-sint-herdados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.3
</figcaption>
</figure>
</div>
<p><strong>Atributos Sintetizados</strong>: um atributo de um vértice é sintetizado se seu valor é calculado a partir dos valores dos atributos de seus filhos. A informação flui de baixo para cima na árvore sintática, das folhas para a raiz. Eles são ideais para agregar informações.</p>
<p><strong>Exemplo</strong>: calcular o valor de uma expressão aritmética. Considere a produção <code>expr -&gt; expr1 + term</code>. O atributo <code>valor</code> de <code>expr</code> é naturalmente sintetizado pela soma dos atributos <code>valor</code> de <code>expr1</code> e <code>term</code>.</p>
<ul>
<li><strong>Regra Semântica</strong>: <code>expr.valor = expr1.valor + term.valor</code></li>
</ul>
<p><strong>Atributos Herdados</strong>: um atributo de um vértice é herdado se seu valor é calculado a partir dos valores dos atributos de seu <strong>pai</strong> ou de seus <strong>irmãos</strong>. A informação flui <strong>de cima para baixo</strong> ou <strong>lateralmente</strong> na árvore. Eles são perfeitos para propagar informações de contexto.</p>
<p><strong>Exemplo</strong>: propagar o tipo em uma declaração de variáveis. Considere a produção <code>declaracao -&gt; tipo lista_vars</code>. O tipo de cada variável em <code>lista_vars</code> depende do tipo especificado no início da declaração.</p>
<ul>
<li><strong>Regra Semântica</strong>: <code>lista_vars.tipo_herdado = tipo.tipo_sintetizado</code></li>
</ul>
<p>O poder das gramáticas de atributos reside na interação entre esses dois tipos de fluxo, permitindo que informações contextuais, herdadas, influenciem cálculos locais que, por sua vez, são agregados e passados para cima, os atributos sintetizados.</p>
</section>
<section id="definição-formal-e-exemplos-práticos" class="level3" data-number="10.5.3">
<h3 data-number="10.5.3" class="anchored" data-anchor-id="definição-formal-e-exemplos-práticos"><span class="header-section-number">10.5.3</span> Definição Formal E Exemplos Práticos</h3>
<p>Para transformar a análise semântica em um processo sistemático e guiado pela sintaxe, utilizamos o formalismo das Gramáticas de Atributos. Formalmente, uma Gramática de Atributos (AG) é uma tupla <span class="math inline">\(AG = \{G, A, R\}\)</span>, na qual cada componente tem um papel bem definido:</p>
<ul>
<li><p><strong><span class="math inline">\(G\)</span>: A Gramática Livre de Contexto (GLC)</strong>: a fundação sintática, definida por <span class="math inline">\(G = \{N, T, P, S\}\)</span>, na qual:</p>
<ul>
<li><span class="math inline">\(N\)</span> é o conjunto de símbolos <strong>não-terminais</strong> (variáveis sintáticas como <code>expr</code>, <code>declaracao</code>).</li>
<li><span class="math inline">\(T\)</span> é o conjunto de símbolos <strong>terminais</strong> (<em>tokens</em> como <code>id</code>, <code>int</code>, <code>+</code>).</li>
<li><span class="math inline">\(P\)</span> é o conjunto de <strong>produções</strong> ou regras gramaticais (ex: <span class="math inline">\(E \rightarrow E + T\)</span>).</li>
<li><span class="math inline">\(S\)</span> é o <strong>símbolo inicial</strong> da gramática.</li>
</ul></li>
</ul>
<p>A <strong>GLC</strong> descreve a <em>forma</em>, mas não o <em>significado</em>.</p>
<ul>
<li><p><strong><span class="math inline">\(A\)</span>: O Conjunto de Atributos</strong>: o componente que carrega a informação semântica. O conjunto <span class="math inline">\(A\)</span> é a união de todos os atributos associados a cada símbolo gramatical definido como: <span class="math inline">\(A = \bigcup_{X \in N \cup T} A(X)\)</span>.</p>
<ul>
<li>Um <strong>atributo</strong> é uma propriedade ou valor associado a um vértice na árvore sintática, como o tipo de uma variável (<code>tipo</code>), o valor de uma expressão (<code>valor</code>), ou o código gerado (<code>codigo</code>).</li>
<li>Para cada símbolo <span class="math inline">\(X\)</span>, seu conjunto de atributos <span class="math inline">\(A(X)\)</span> é dividido em dois grupos disjuntos, <span class="math inline">\(A(X) = I(X) \cup S(X)\)</span>:</li>
<li><span class="math inline">\(I(X)\)</span>: <strong>Atributos Herdados</strong> (<em>Inherited</em>), cujo valor em um vértice é determinado a partir dos atributos de seu vértice-pai ou de seus irmãos. Eles propagam informação de cima para baixo e lateralmente na árvore, distribuindo o contexto.</li>
<li><span class="math inline">\(S(X)\)</span>: <strong>Atributos Sintetizados</strong> (<em>Synthesized</em>), cujo valor em um vértice é calculado a partir dos atributos de seus vértices-filhos. Eles agregam informação de baixo para cima, das folhas em direção à raiz.</li>
</ul></li>
<li><p><strong><span class="math inline">\(R\)</span>: O Conjunto de Regras Semânticas</strong>: o cérebro da operação, associando a cada produção <span class="math inline">\(p \in P\)</span> um conjunto de equações que definem como os atributos são calculados. Para uma produção <span class="math inline">\(p: X_0 \rightarrow X_1 X_2 \dots X_n\)</span>, as regras em <span class="math inline">\(R\)</span> especificam como calcular:</p></li>
</ul>
<ol type="1">
<li>Os atributos sintetizados de <span class="math inline">\(X_0\)</span> a partir dos atributos de <span class="math inline">\(X_1, \dots, X_n\)</span>.</li>
<li>Os atributos herdados de <span class="math inline">\(X_1, \dots, X_n\)</span> a partir dos atributos de <span class="math inline">\(X_0\)</span> ou de outros símbolos <span class="math inline">\(X_j\)</span> na mesma produção.</li>
</ol>
<section id="exemplo-1-declaração-de-variáveis" class="level4" data-number="10.5.3.1">
<h4 data-number="10.5.3.1" class="anchored" data-anchor-id="exemplo-1-declaração-de-variáveis"><span class="header-section-number">10.5.3.1</span> Exemplo 1: Declaração de Variáveis</h4>
<p>Vamos definir uma Gramática de Atributos para processar declarações simples como <code>float x, y;</code>, na qual o tipo deve ser distribuído para cada variável na lista.</p>
<p><strong>1. Gramática (<span class="math inline">\(G\)</span>)</strong>: começamos com a seguinte gramática livre de contexto:</p>
<p><span class="math display">\[
\begin{align*}
\text{Declaracao} &amp; \rightarrow \text{Tipo} \quad \text{ListaIDs} \\
\text{Tipo} &amp; \rightarrow \textbf{int} \mid \textbf{float} \\
\text{ListaIDs} &amp; \rightarrow \text{ListaIDs}_1, \textbf{id} \mid \textbf{id}
\end{align*}
\]</span></p>
<p><strong>2. Análise do Fluxo de Informação</strong>: para transformar esta gramática em uma Gramática de Atributos, precisamos primeiro identificar como a informação flui pela árvore sintática que pode ser vista na Figura <a href="#fig-decl-tree" class="quarto-xref">Figure&nbsp;<span>10.4</span></a>:</p>
<div id="fig-decl-tree" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-decl-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ex1AST.webp" class="img-fluid figure-img"></p>
<figcaption>Árvore Sintática de Declaração</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-decl-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.4
</figcaption>
</figure>
</div>
<p>Na <strong>AST</strong> da Figura <a href="#fig-decl-tree" class="quarto-xref">Figure&nbsp;<span>10.4</span></a>, podemos observar dois fluxos principais de informação:</p>
<ul>
<li><p><strong>Informação que sobe (sintetizada)</strong>: o tipo declarado (<code>int</code> ou <code>float</code>) é reconhecido nas folhas da árvore (<em>tokens</em> <code>int</code> ou <code>float</code>) e precisa ser propagado para cima até o símbolo <code>Tipo</code>.</p></li>
<li><p><strong>Informação que desce (herdada)</strong>: uma vez que o tipo foi determinado, ele precisa ser distribuído para todos os identificadores na <code>ListaIDs</code>. Como a lista pode ter múltiplos elementos separados por vírgulas, o tipo deve “fluir para baixo” através da recursão da lista.</p></li>
</ul>
<p><strong>3. Definição dos Atributos (<span class="math inline">\(A\)</span>)</strong>: com base na análise do fluxo, definimos:</p>
<p><strong>Para o símbolo <code>Tipo</code></strong>:</p>
<ul>
<li><strong>Atributo sintetizado <code>tipo</code></strong>: armazena o tipo reconhecido (<code>'int'</code> ou <code>'float'</code>). A informação flui das folhas, <em>tokens</em> terminais, para cima, logo é sintetizado.</li>
</ul>
<p><strong>Para o símbolo <code>ListaIDs</code></strong>:</p>
<ul>
<li><strong>Atributo herdado <code>tipo_herdado</code></strong>: recebe o tipo que deve ser atribuído a todos os identificadores. A informação do tipo vem de fora, do pai <code>Declaracao</code>, e deve ser propagada através da lista, caracterizando um atributo herdado.</li>
</ul>
<p><strong>Para o terminal <code>id</code></strong>:</p>
<ul>
<li><strong>Atributo sintetizado <code>lexval</code></strong>: contém o nome do identificador, fornecido pelo analisador léxico. Este valor vem da análise léxica e é uma propriedade inerente ao <em>token</em>.</li>
</ul>
<p><strong>4. Construção das Regras Semânticas (<span class="math inline">\(R\)</span>)</strong>: com os atributos definidos, podemos agora estabelecer as regras semânticas que governam como esses atributos são calculados e propagados. As regras semânticas serão sistematicamente derivadas para cada produção da gramática:</p>
<p><strong>Produção 1</strong>: <span class="math inline">\(\text{Declaracao} \rightarrow \text{Tipo} \quad \text{ListaIDs}\)</span>. Esta produção conecta a determinação do tipo, filho esquerdo, com sua distribuição, filho direito. A regra semântica estabelece a ponte:</p>
<p><span class="math display">\[\text{ListaIDs.tipo\_herdado} = \text{Tipo.tipo}\]</span></p>
<p>O valor sintetizado de <code>Tipo</code>, que subiu da folha, agora deve descer como atributo herdado para <code>ListaIDs</code>. Esta é a transição crítica entre fluxo ascendente e descendente que sempre irá requerer atenção.</p>
<p><strong>Produção 2</strong>: <span class="math inline">\(\text{Tipo} \rightarrow \textbf{int}\)</span></p>
<p><span class="math display">\[\text{Tipo.tipo} = \text{'integer'}\]</span></p>
<p>Quando reconhecemos o <em>token</em> <code>int</code>, sintetizamos o atributo <code>tipo</code> com o valor semântico correspondente. Esta é uma regra de tradução do léxico para o semântico.</p>
<p><strong>Produção 3</strong>: <span class="math inline">\(\text{Tipo} \rightarrow \textbf{float}\)</span></p>
<p><span class="math display">\[\text{Tipo.tipo} = \text{'real'}\]</span></p>
<p>Análogo à produção anterior, mas para o tipo <code>float</code>.</p>
<p><strong>Produção 4</strong>: <span class="math inline">\(\text{ListaIDs} \rightarrow \text{ListaIDs}_1, \textbf{id}\)</span></p>
<p>Esta produção recursiva é o núcleo da propagação do tipo através da lista:</p>
<p><span class="math display">\[
\begin{align*}
\text{ListaIDs}_1\text{.tipo\_herdado} &amp;= \text{ListaIDs.tipo\_herdado} \\
\text{adicionar\_tipo}(\text{id.lexval}, &amp;\text{ListaIDs.tipo\_herdado})
\end{align*}
\]</span></p>
<p><strong>Raciocínio detalhado</strong>:</p>
<ol type="1">
<li><strong>Primeira regra</strong>: o atributo herdado do pai (<code>ListaIDs</code>) deve ser copiado para o filho recursivo (<code>ListaIDs₁</code>). Isso garante que o tipo continue fluindo através da recursão, alcançando todos os identificadores da lista.</li>
<li><strong>Segunda regra</strong>: para o identificador atual (<code>id</code>), executamos a ação semântica de adicionar seu nome (<code>id.lexval</code>) e tipo (<code>ListaIDs.tipo_herdado</code>) à <strong>Tabela de Símbolos</strong>.</li>
</ol>
<p><strong>Produção 5</strong>: <span class="math inline">\(\text{ListaIDs} \rightarrow \textbf{id}\)</span></p>
<p>Esta é a produção base da recursão:</p>
<p><span class="math display">\[\text{adicionar\_tipo}(\text{id.lexval}, \text{ListaIDs.tipo\_herdado})\]</span></p>
<p>Quando chegamos ao último, ou ao único, identificador da lista, simplesmente adicionamos suas informações à <strong>Tabela de Símbolos</strong>. Não há recursão para propagar.</p>
<p><strong>5. Tabela Resumida</strong>:</p>
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Produção</th>
<th style="text-align: left;">Regras Semânticas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Declaracao} \rightarrow \text{Tipo} \text{ListaIDs}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{ListaIDs.tipo\_herdado} = \text{Tipo.tipo}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Tipo} \rightarrow \textbf{int}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{Tipo.tipo} = \text{'integer'}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Tipo} \rightarrow \textbf{float}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{Tipo.tipo} = \text{'real'}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{ListaIDs} \rightarrow \text{ListaIDs}_1, \textbf{id}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{ListaIDs}_1\text{.tipo\_herdado} = \text{ListaIDs.tipo\_herdado}\)</span> <br> <code>adicionar_tipo(id.lexval, ListaIDs.tipo_herdado)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{ListaIDs} \rightarrow \textbf{id}\)</span></td>
<td style="text-align: left;"><code>adicionar_tipo(id.lexval, ListaIDs.tipo_herdado)</code></td>
</tr>
</tbody>
</table>
<p><strong>6. Exemplo de Avaliação</strong>: para a declaração <code>float x, y;</code>, a árvore sintática anotada seria construída conforme ilustrado na Figura <a href="#fig-exemplo-atributos" class="quarto-xref">Figure&nbsp;<span>10.5</span></a>, na qual, temos:</p>
<ol type="1">
<li>O atributo <code>Tipo.tipo</code> é sintetizado com valor <code>'real'</code>;</li>
<li>Este valor é passado como <code>ListaIDs.tipo_herdado</code>;</li>
<li>O tipo é propagado recursivamente através da lista;</li>
<li>Cada identificador é adicionado à <strong>Tabela de Símbolos</strong> com o tipo correto.</li>
</ol>
<div id="fig-exemplo-atributos" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-exemplo-atributos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/float.webp" class="img-fluid figure-img"></p>
<figcaption>Exemplo de Gramática de Atributos</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-exemplo-atributos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.5
</figcaption>
</figure>
</div>
</section>
<section id="exemplo-2-estrutura-de-tomada-de-decisão-if-then-else" class="level4" data-number="10.5.3.2">
<h4 data-number="10.5.3.2" class="anchored" data-anchor-id="exemplo-2-estrutura-de-tomada-de-decisão-if-then-else"><span class="header-section-number">10.5.3.2</span> Exemplo 2: Estrutura de Tomada de Decisão (if-then-else)</h4>
<p>Vamos construir uma Gramática de Atributos para processar estruturas condicionais como <code>if (x &gt; 0) then y = 1 else y = -1</code>.</p>
<p><strong>1. Gramática Base (<span class="math inline">\(G\)</span>)</strong>:</p>
<p><span class="math display">\[
\begin{align*}
\text{Comando} &amp; \rightarrow \textbf{if} \, \text{Expr} \, \textbf{then} \, \text{Comando}_1 \, \textbf{else} \, \text{Comando}_2 \\
\text{Expr} &amp; \rightarrow \text{Expr}_1 \, \text{oprel} \, \text{Expr}_2 \\
\text{Expr} &amp; \rightarrow \textbf{id} \mid \textbf{num}
\end{align*}
\]</span></p>
<p><strong>2. Análise do Fluxo de Informação</strong>: para processar estruturas condicionais, precisamos identificar como a informação flui pela árvore sintática:</p>
<div id="fig-if-tree" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-if-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ex2AST.webp" class="img-fluid figure-img"></p>
<figcaption>Árvore Sintática de If-Then-Else</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-if-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.6
</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Informação que desce (herdada)</strong>: cada comando precisa saber qual rótulo usar como destino para continuar a execução após sua conclusão. Isso é necessário para estruturas aninhadas. A expressão booleana precisa conhecer os rótulos de destino para quando a condição for verdadeira ou falsa.</p></li>
<li><p><strong>Informação que sobe (sintetizada)</strong>: cada componente da estrutura tem características que precisam ser agregadas, como informações de tipo ou outras propriedades semânticas.</p></li>
</ul>
<p><strong>3. Definição dos Atributos (<span class="math inline">\(A\)</span>)</strong></p>
<p><strong>Para o símbolo <code>Comando</code></strong>:</p>
<ul>
<li><strong>Atributo herdado <code>proximo</code></strong>: rótulo para no qual o fluxo deve ir após executar este comando.</li>
<li><strong>Justificativa</strong>: o destino após o comando é determinado pelo contexto (comando pai), não pelo próprio comando.</li>
</ul>
<p><strong>Para o símbolo <code>Expr</code></strong>:</p>
<ul>
<li><strong>Atributo herdado <code>verdadeiro</code></strong>: rótulo para saltar quando a expressão for verdadeira.</li>
<li><strong>Atributo herdado <code>falso</code></strong>: rótulo para saltar quando a expressão for falsa.</li>
<li><strong>Justificativa</strong>: os destinos dos saltos são determinados pela estrutura de controle que contém a expressão.</li>
<li><strong>Atributo sintetizado <code>local</code></strong>: nome da variável ou temporária que armazena o resultado (para expressões não booleanas).</li>
</ul>
<p><strong>Para os terminais <code>id</code> e <code>num</code></strong>:</p>
<ul>
<li><strong>Atributo sintetizado <code>lexval</code></strong>: valor léxico do identificador ou número.</li>
</ul>
<p><strong>4. Construção das Regras Semânticas (<span class="math inline">\(R\)</span>)</strong></p>
<p>Assumimos a existência da função auxiliar:</p>
<ul>
<li><code>novo_rotulo()</code>: gera um rótulo único (L1, L2, etc.)</li>
</ul>
<p><strong>Produção 1</strong>:</p>
<p><span class="math display">\[\text{Comando} \rightarrow \textbf{if} \, \text{Expr} \, \textbf{then} \, \text{Comando}_1 \, \textbf{else} \, \text{Comando}_2\]</span></p>
<p>Esta produção implementa a estrutura condicional completa:</p>
<p><span class="math display">\[
\begin{align*}
\text{Expr.verdadeiro} &amp;:= \text{novo\_rotulo()} \\
\text{Expr.falso} &amp;:= \text{novo\_rotulo()} \\
\text{Comando}_1\text{.proximo} &amp;:= \text{Comando.proximo} \\
\text{Comando}_2\text{.proximo} &amp;:= \text{Comando.proximo}
\end{align*}
\]</span></p>
<p>Para entender o raciocínio por trás dessas regras:</p>
<ol type="1">
<li><p><strong>Criação de rótulos</strong>: geramos dois rótulos únicos, um para o comando <code>then</code> (<code>Expr.verdadeiro</code>) e outro para o comando <code>else</code> (<code>Expr.falso</code>).</p></li>
<li><p><strong>Propagação do <code>proximo</code></strong>: ambos os comandos (<code>then</code> e <code>else</code>) devem convergir para o mesmo ponto de continuação, que é herdado do contexto externo. Isso garante que, independentemente do caminho tomado, a execução continue no mesmo ponto.</p></li>
<li><p><strong>Fluxo de controle</strong>: a expressão usa seus atributos herdados <code>verdadeiro</code> e <code>falso</code> para determinar os destinos dos saltos condicionais.</p></li>
</ol>
<p><strong>Produção 2</strong>:</p>
<p><span class="math display">\[\text{Expr} \rightarrow \text{Expr}_1 \, \text{oprel} \, \text{Expr}_2\]</span></p>
<p>Esta produção define como os atributos herdados <code>verdadeiro</code> e <code>falso</code> são usados para especificar a semântica do desvio.</p>
<p><span class="math display">\[\text{realizar\_desvio\_condicional}(\text{Expr}_1\text{.local, oprel.lexval, Expr}_2\text{.local, Expr.verdadeiro, Expr.falso})\]</span></p>
<p>A regra invoca uma ação semântica que representa a lógica do desvio. Ela usa os locais das subexpressões e os rótulos herdados para indicar que, se a condição <code>Expr₁.local oprel.lexval Expr₂.local</code> for verdadeira, o fluxo deve ir para <code>Expr.verdadeiro</code>; caso contrário, para <code>Expr.falso</code>.</p>
<p><strong>Produção 3</strong>: a partir da regra:</p>
<p><span class="math display">\[\text{Expr} \rightarrow \textbf{id}\]</span></p>
<p>Teremos: <span class="math display">\[\text{Expr.local} = \text{id.lexval}\]</span></p>
<p>Um identificador não requer processamento adicional; seu valor está em sua entrada na <strong>Tabela de Símbolos</strong>. Apenas registramos sua localização.</p>
<p><strong>Produção 4</strong>: considerando a regra:</p>
<p><span class="math display">\[\text{Expr} \rightarrow \textbf{num}\]</span></p>
<p>Teremos:</p>
<p><span class="math display">\[\text{Expr.local} = \text{num.lexval}\]</span></p>
<p>Processo análogo ao identificador; constantes são usadas diretamente.</p>
<p><strong>5. Tabela de Regras Semânticas</strong>:</p>
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Produção</th>
<th style="text-align: left;">Regras Semânticas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Comando} \rightarrow \textbf{if} \, \text{Expr} \, \textbf{then} \, \text{Cmd}_1 \, \textbf{else} \, \text{Cmd}_2\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{Expr.verdadeiro} := \text{novo\_rotulo()}\)</span> <br> <span class="math inline">\(\text{Expr.falso} := \text{novo\_rotulo()}\)</span> <br> <span class="math inline">\(\text{Cmd}_1\text{.proximo} := \text{Cmd.proximo}\)</span> <br> <span class="math inline">\(\text{Cmd}_2\text{.proximo} := \text{Cmd.proximo}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \text{Expr}_1 \, \text{oprel} \, \text{Expr}_2\)</span></td>
<td style="text-align: left;"><code>realizar_desvio_condicional(Expr₁.local, oprel.lexval, Expr₂.local, Expr.verdadeiro, Expr.falso)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \textbf{id}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{Expr.local} = \text{id.lexval}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \textbf{num}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{Expr.local} = \text{num.lexval}\)</span></td>
</tr>
</tbody>
</table>
<p><strong>6. Exemplo de Avaliação</strong>: para o comando <code>if (x &gt; 0) then y = 1 else y = -1</code> com <code>Comando.proximo = L_fim</code>:</p>
<ul>
<li><code>Expr.verdadeiro</code> recebe um novo rótulo <code>L1</code></li>
<li><code>Expr.falso</code> recebe um novo rótulo <code>L2</code></li>
<li><code>Comando₁.proximo</code> recebe <code>L_fim</code> (ambos os ramos convergem para o mesmo destino)</li>
<li><code>Comando₂.proximo</code> recebe <code>L_fim</code></li>
</ul>
<p>A árvore sintática deve ser anotada com estes valores, o que permitirá que a estrutura condicional seja processada corretamente com os destinos apropriados para cada um dos caminho de execução.</p>
</section>
<section id="exemplo-3-laço-de-repetição-while" class="level4" data-number="10.5.3.3">
<h4 data-number="10.5.3.3" class="anchored" data-anchor-id="exemplo-3-laço-de-repetição-while"><span class="header-section-number">10.5.3.3</span> Exemplo 3: Laço de Repetição (while)</h4>
<p>Finalmente, vamos construir uma Gramática de Atributos para laços como <code>while (x &gt; 0) do x = x - 1</code>, em que o fluxo de controle deve retornar ao início após cada iteração.</p>
<p><strong>1. Gramática Base (<span class="math inline">\(G\)</span>)</strong>:</p>
<p><span class="math display">\[
\begin{align*}
\text{Comando} &amp; \rightarrow \textbf{while} \, \text{Expr} \, \textbf{do} \, \text{Comando}_1 \\
\text{Expr} &amp; \rightarrow \text{Expr}_1 \, \text{oprel} \, \text{Expr}_2 \\
\text{Expr} &amp; \rightarrow \textbf{id} \mid \textbf{num} \\
\text{Comando} &amp; \rightarrow \textbf{id} \, \text{=} \, \text{Expr}
\end{align*}
\]</span></p>
<p><strong>2. Análise do Fluxo de Informação</strong>: para laços de repetição, a análise do fluxo de informação é crucial para garantir que o controle retorne ao início do laço após cada iteração. A árvore sintática para um comando <code>while</code> pode ser vista na Figura <a href="#fig-while-tree" class="quarto-xref">Figure&nbsp;<span>10.7</span></a>:</p>
<div id="fig-while-tree" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-while-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ex3AST.webp" class="img-fluid figure-img"></p>
<figcaption>Árvore Sintática de While</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-while-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.7
</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Informação que desce (herdada)</strong>: o comando do corpo do laço precisa saber para que ponto do código deve ir após sua execução, como voltar ao início do laço. A expressão precisa saber para que ponto saltar em caso <code>verdadeiro</code>, início do corpo, e <code>falso</code>, após o laço.</p></li>
<li><p><strong>Informação que sobe (sintetizada)</strong>: cada componente tem propriedades que precisam ser agregadas.</p></li>
<li><p><strong>Ponto fundamental</strong>: o laço cria um ciclo no fluxo de controle - após executar o corpo, devemos retornar à avaliação da condição.</p></li>
</ul>
<p><strong>3. Definição dos Atributos (<span class="math inline">\(A\)</span>)</strong>: avaliando símbolo por símbolo, teremos:</p>
<p><strong>Para o símbolo <code>Comando</code> (em geral)</strong>:</p>
<ul>
<li><strong>Atributo herdado <code>proximo</code></strong>: rótulo para continuar após este comando. Determina o fluxo após a conclusão do comando.</li>
</ul>
<p><strong>Para o símbolo <code>Expr</code></strong>:</p>
<ul>
<li><strong>Atributo herdado <code>verdadeiro</code></strong>: rótulo quando a condição é verdadeira (entra no corpo).</li>
<li><strong>Atributo herdado <code>falso</code></strong>: rótulo quando a condição é falsa (sai do laço). Os dois controlam o fluxo baseado na avaliação da condição.</li>
<li><strong>Atributo sintetizado <code>local</code></strong>: localização do resultado da expressão.</li>
</ul>
<p><strong>4. Construção das Regras Semânticas (<span class="math inline">\(R\)</span>)</strong>: vamos definir as regras individualmente para cada produção.</p>
<p><strong>Produção 1</strong>:</p>
<p><span class="math display">\[\text{Comando} \rightarrow \textbf{while} \, \text{Expr} \, \textbf{do} \, \text{Comando}_1\]</span></p>
<p>Esta é a produção central, que implementa a semântica do laço:</p>
<p><span class="math display">\[
\begin{align*}
\text{inicio\_laco} &amp;:= \text{novo\_rotulo()} \\
\text{Expr.verdadeiro} &amp;:= \text{novo\_rotulo()} \\
\text{Expr.falso} &amp;:= \text{Comando.proximo} \\
\text{Comando}_1\text{.proximo} &amp;:= \text{inicio\_laco}
\end{align*}
\]</span></p>
<p>Observando o raciocínio por trás dessas regras veremos:</p>
<ol type="1">
<li><p><strong>Criação do rótulo de início</strong> (<code>inicio_laco</code>): este é o ponto para o qual voltaremos após cada iteração. Este é um valor gerado localmente na regra para controlar o fluxo; não é um atributo formal do símbolo <code>Comando</code>.</p></li>
<li><p><strong>Configuração dos destinos da expressão</strong>:</p>
<ul>
<li><code>Expr.verdadeiro</code>: cria um novo rótulo que marca o início do corpo do laço.</li>
<li><code>Expr.falso</code>: aponta para <code>Comando.proximo</code>, ou seja, o código após o laço. Quando a condição falha, saímos do laço.</li>
</ul></li>
<li><p><strong>Fechamento do ciclo</strong> (<code>Comando₁.proximo := inicio_laco</code>): esta é a regra fundamental que implementa a semântica do laço. Dizemos ao corpo do laço que, após sua execução, ele deve retornar ao <code>inicio_laco</code>, criando assim o ciclo de repetição.</p></li>
<li><p><strong>Distinção importante</strong>: no <code>if-then-else</code>, após executar o “then”, saltamos para <code>proximo</code> (para frente). No <code>while</code>, após executar o corpo, saltamos para <code>inicio_laco</code> (para trás), criando o ciclo.</p></li>
</ol>
<p><strong>Produção 2</strong>:</p>
<p><span class="math display">\[\text{Comando} \rightarrow \textbf{id} \, \text{=} \, \text{Expr}\]</span></p>
<p>Comando de atribuição simples (necessário para o corpo do laço). Os atributos são processados conforme apropriado para uma atribuição.</p>
<p><strong>Produção 3</strong>:</p>
<p><span class="math display">\[\text{Expr} \rightarrow \text{Expr}_1 \, \text{oprel} \, \text{Expr}_2\]</span></p>
<p>Expressão relacional (idêntica ao exemplo anterior). Os atributos herdados <code>verdadeiro</code> e <code>falso</code> são usados pela ação semântica para especificar o desvio.</p>
<p><strong>Produção 4</strong>: a partir da regra:</p>
<p><span class="math display">\[\text{Expr} \rightarrow \textbf{id}\]</span></p>
<p>teremos:</p>
<p><span class="math display">\[\text{Expr.local} = \text{id.lexval}\]</span></p>
<p><strong>Produção 5</strong>: a partir da regra:</p>
<p><span class="math display">\[\text{Expr} \rightarrow \textbf{num}\]</span></p>
<p>teremos:</p>
<p><span class="math display">\[
\text{Expr.local} = \text{num.lexval}
\]</span></p>
<p><strong>5. Tabela de Regras Semânticas</strong>:</p>
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Produção</th>
<th style="text-align: left;">Regras Semânticas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Comando} \rightarrow \textbf{while} \, \text{Expr} \, \textbf{do} \, \text{Cmd}_1\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{inicio\_laco} := \text{novo\_rotulo()}\)</span> <br> <span class="math inline">\(\text{Expr.verdadeiro} := \text{novo\_rotulo()}\)</span> <br> <span class="math inline">\(\text{Expr.falso} := \text{Cmd.proximo}\)</span> <br> <span class="math inline">\(\text{Cmd}_1\text{.proximo} := \text{inicio\_laco}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Comando} \rightarrow \textbf{id} \, \text{=} \, \text{Expr}\)</span></td>
<td style="text-align: left;"><code>realizar_atribuicao(id.lexval, Expr.local)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \text{Expr}_1 \, \text{oprel} \, \text{Expr}_2\)</span></td>
<td style="text-align: left;"><code>realizar_desvio_condicional(Expr₁.local, oprel.lexval, Expr₂.local, Expr.verdadeiro, Expr.falso)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \textbf{id}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{Expr.local} = \text{id.lexval}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \textbf{num}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\text{Expr.local} = \text{num.lexval}\)</span></td>
</tr>
</tbody>
</table>
<p><strong>6. Exemplo de Avaliação</strong>:</p>
<p>Para o comando <code>while (x &gt; 0) do x = x - 1</code> com <code>Comando.proximo = L_fim</code>:</p>
<ul>
<li>Um novo rótulo <code>L_inicio</code> é gerado para o laço;</li>
<li><code>Expr.verdadeiro</code> recebe um novo rótulo <code>L_corpo</code>;</li>
<li><code>Expr.falso</code> recebe <code>L_fim</code> (sai do laço);</li>
<li><code>Comando₁.proximo</code> recebe <code>L_inicio</code> (retorna ao início - ciclo!).</li>
</ul>
<p><strong>Diferença fundamental entre o <code>if</code> e o <code>while</code></strong>:</p>
<p>No <code>if-then-else</code>, após executar o “then”, saltamos para <code>proximo</code> (para frente):</p>
<p><span class="math display">\[\text{Comando}_1\text{.proximo} = \text{Comando.proximo}\]</span></p>
<p>No <code>while</code>, após executar o corpo, saltamos para <code>inicio_laco</code> (para trás):</p>
<p><span class="math display">\[\text{Comando}_1\text{.proximo} = \text{inicio\_laco}\]</span></p>
<p>Esta diferença nas regras semânticas é o que implementa comportamentos completamente distintos: execução condicional única versus repetição em ciclo. A árvore sintática anotada com estes atributos captura perfeitamente a semântica do laço de repetição.</p>
</section>
</section>
<section id="avaliação-de-atributos-grafos-de-dependência-e-ordenação-topológica" class="level3" data-number="10.5.4">
<h3 data-number="10.5.4" class="anchored" data-anchor-id="avaliação-de-atributos-grafos-de-dependência-e-ordenação-topológica"><span class="header-section-number">10.5.4</span> Avaliação de Atributos: Grafos de Dependência e Ordenação Topológica</h3>
<p>As regras semânticas de uma gramática de atributos formam um sistema de equações. Contudo, para resolver esse sistema, precisamos estabelecer uma ordem de avaliação, pois o cálculo de um atributo frequentemente depende do valor de outro. O <strong>Grafo de Dependências</strong> é a ferramenta formal que nos permite visualizar e determinar essa ordem.</p>
<p>Para uma determinada árvore sintática, o grafo de dependências é um grafo direcionado <span class="math inline">\(D = (V, E)\)</span> que torna explícitas as interdependências entre os atributos:</p>
<ul>
<li><strong>Vértices (<span class="math inline">\(V\)</span>)</strong>: Cada vértice no grafo de dependências corresponde a <strong>um atributo</strong> de um vértice na árvore sintática.</li>
<li><strong>Arestas (<span class="math inline">\(E\)</span>)</strong>: Existe uma aresta direcionada do vértice <span class="math inline">\((n_1, a_1)\)</span> para <span class="math inline">\((n_2, a_2)\)</span> se, e somente se, o valor do atributo <code>a2</code> depende diretamente do valor do atributo <code>a1</code>.</li>
</ul>
<div id="fig-grafo-dependencias" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-grafo-dependencias-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/depend1.webp" class="img-fluid figure-img"></p>
<figcaption>Grafo de Dependências para x = a + b</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-grafo-dependencias-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.8: Exemplo de árvore sintática e seu grafo de dependências correspondente
</figcaption>
</figure>
</div>
<p>Uma gramática de atributos é considerada <strong>não-circular</strong> se, para qualquer árvore sintática que ela possa gerar, seu grafo de dependências for <strong>acíclico</strong> (não contiver ciclos).</p>
<p>O problema de encontrar a sequência correta de avaliação é resolvido pela <strong>ordenação topológica</strong> do grafo. O algoritmo geral consiste em construir o grafo, verificar se há ciclos e, em caso negativo, percorrê-lo em uma ordem topológica para calcular cada atributo.</p>
</section>
<section id="classes-de-gramáticas-de-atributos-e-o-impacto-na-eficiência" class="level3" data-number="10.5.5">
<h3 data-number="10.5.5" class="anchored" data-anchor-id="classes-de-gramáticas-de-atributos-e-o-impacto-na-eficiência"><span class="header-section-number">10.5.5</span> Classes de Gramáticas de Atributos e o Impacto na Eficiência</h3>
<p>Embora a definição de uma gramática de atributos seja muito flexível, essa flexibilidade tem um custo. Regras semânticas irrestritas podem levar a dependências complexas, difíceis de avaliar ou, no pior caso, a dependências circulares que tornam a avaliação impossível. Para gerenciar essa complexidade, as gramáticas de atributos são classificadas em uma hierarquia baseada nas restrições impostas sobre o fluxo de informação. Em uma estrutura aninhada que pode ser vista na Figura <a href="#fig-classes-gramaticas" class="quarto-xref">Figure&nbsp;<span>10.9</span></a>, cada classe é um subconjunto estrito da anterior, com propriedades específicas que impactam diretamente a implementação do compilador.</p>
<div id="fig-classes-gramaticas" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-classes-gramaticas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/latrib1.webp" class="img-fluid figure-img"></p>
<figcaption>Classes de Gramáticas de Atributos</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-classes-gramaticas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.9
</figcaption>
</figure>
</div>
<p>Essa classificação é de suma importância para o design de linguagens e compiladores, pois representa um balanço direto entre o poder expressivo das regras semânticas e a eficiência do algoritmo de avaliação.</p>
<section id="gramáticas-s-atribuídas" class="level4" data-number="10.5.5.1">
<h4 data-number="10.5.5.1" class="anchored" data-anchor-id="gramáticas-s-atribuídas"><span class="header-section-number">10.5.5.1</span> Gramáticas S-Atribuídas</h4>
<p>A classe mais simples e restrita. Uma gramática é <strong>S-atribuída</strong> se ela utiliza <strong>apenas</strong> atributos sintetizados.</p>
<ul>
<li><strong>Característica</strong>: A informação flui estritamente de baixo para cima (bottom-up) na árvore sintática.</li>
<li><strong>Implicação no Compilador</strong>: São muito fáceis de avaliar. Uma simples travessia em pós-ordem da árvore é suficiente para calcular todos os atributos. Elas se integram perfeitamente com analisadores sintáticos <em>bottom-up</em> (como LALR, usado por ferramentas como YACC/Bison), nos quais a ação semântica pode ser executada assim que uma produção é reduzida.</li>
<li><strong>Complexidade</strong>: Avaliação em tempo linear, <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</section>
<section id="gramáticas-l-atribuídas" class="level4" data-number="10.5.5.2">
<h4 data-number="10.5.5.2" class="anchored" data-anchor-id="gramáticas-l-atribuídas"><span class="header-section-number">10.5.5.2</span> Gramáticas L-Atribuídas</h4>
<p>Esta é a classe mais importante para a maioria das linguagens de programação modernas. Uma gramática é <strong>L-atribuída</strong> se, para cada produção <span class="math inline">\(A \rightarrow X_1 X_2 \dots X_n\)</span>, os atributos herdados de um símbolo <span class="math inline">\(X_j\)</span> no lado direito dependem apenas:</p>
<ol type="1">
<li>Dos atributos herdados de <span class="math inline">\(A\)</span> (o pai).</li>
<li>De quaisquer atributos dos símbolos à sua esquerda (<span class="math inline">\(X_1, X_2, \dots, X_{j-1}\)</span>).</li>
</ol>
<ul>
<li><strong>Característica</strong>: A informação pode fluir para baixo (herdada) e para cima (sintetizada), mas o fluxo de dependências herdadas segue estritamente a ordem da escrita, da esquerda para a direita. O “L” vem de <em>Left-to-right</em>.</li>
<li><strong>Implicação no Compilador</strong>: Esta restrição é o “ponto ideal” (<code>sweet spot</code>) do design de compiladores. Ela garante que todos os atributos possam ser avaliados em uma <strong>única travessia em profundidade e da esquerda para a direita</strong> da árvore sintática. Isso as torna perfeitas para analisadores de descida recursiva (<em>top-down</em>).</li>
<li><strong>Complexidade</strong>: Avaliação em tempo linear, <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</section>
<section id="gramáticas-não-circulares" class="level4" data-number="10.5.5.3">
<h4 data-number="10.5.5.3" class="anchored" data-anchor-id="gramáticas-não-circulares"><span class="header-section-number">10.5.5.3</span> Gramáticas Não-Circulares</h4>
<p>Esta é a classe mais geral de gramáticas de atributos que ainda é utilizável.</p>
<ul>
<li><strong>Característica</strong>: A única restrição é que o grafo de dependências não pode ter ciclos para nenhuma árvore sintática possível. No entanto, as dependências podem ser complexas, com atributos dependendo de irmãos à sua direita, por exemplo.</li>
<li><strong>Implicação no Compilador</strong>: A ordem de avaliação não é fixa e pode mudar para cada árvore sintática. O compilador não pode usar uma simples travessia; ele é forçado a construir o grafo de dependências explicitamente e executar uma ordenação topológica.</li>
<li><strong>Complexidade</strong>: A avaliação é mais cara, geralmente quadrática (<span class="math inline">\(O(n^2)\)</span>) ou pior, dependendo da estrutura do grafo. Linguagens com funcionalidades semânticas muito complexas, como templates em <strong>C++</strong>, podem exigir essa flexibilidade.</li>
</ul>
</section>
<section id="gramáticas-circulares" class="level4" data-number="10.5.5.4">
<h4 data-number="10.5.5.4" class="anchored" data-anchor-id="gramáticas-circulares"><span class="header-section-number">10.5.5.4</span> Gramáticas Circulares</h4>
<ul>
<li><strong>Característica</strong>: Existe pelo menos uma árvore sintática que gera um grafo de dependências com um ciclo. Isso representa uma definição semântica recursiva sem caso base (ex: <code>a = b + 1</code> e <code>b = a * 2</code>).</li>
<li><strong>Implicação no Compilador</strong>: São semanticamente malformadas e inúteis na prática, pois a avaliação de atributos é impossível. Pior ainda, o problema de determinar se uma gramática de atributos geral é circular ou não é <strong>indecidível</strong>.</li>
</ul>
<p>A tabela a seguir resume estas classes, suas características e o impacto na complexidade da análise semântica.</p>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 31%">
<col style="width: 23%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Classe</th>
<th style="text-align: left;">Característica</th>
<th style="text-align: left;">Complexidade de Avaliação</th>
<th style="text-align: left;">Exemplo de Uso</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>S-atribuída</strong></td>
<td style="text-align: left;">Apenas atributos sintetizados</td>
<td style="text-align: left;"><span class="math inline">\(O(n)\)</span></td>
<td style="text-align: left;">Calculadoras, expressões</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>L-atribuída</strong></td>
<td style="text-align: left;">Restrições em atributos herdados</td>
<td style="text-align: left;"><span class="math inline">\(O(n)\)</span></td>
<td style="text-align: left;">Maioria das linguagens (<strong>C</strong>, <strong>Java</strong>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Absolutamente não-circular</strong></td>
<td style="text-align: left;">Ordem fixa para todas as árvores</td>
<td style="text-align: left;"><span class="math inline">\(O(n)\)</span></td>
<td style="text-align: left;">Subclasse de L-atribuídas</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Não-circular</strong></td>
<td style="text-align: left;">Ordem depende da árvore</td>
<td style="text-align: left;"><span class="math inline">\(O(n^2)\)</span></td>
<td style="text-align: left;"><strong>Ada</strong>, <strong>C++</strong> (templates)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Circular</strong></td>
<td style="text-align: left;">Possui ciclos</td>
<td style="text-align: left;">Indecidível</td>
<td style="text-align: left;">Não utilizável</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="definição-formal-e-exemplo-prático" class="level3" data-number="10.5.6">
<h3 data-number="10.5.6" class="anchored" data-anchor-id="definição-formal-e-exemplo-prático"><span class="header-section-number">10.5.6</span> Definição Formal e Exemplo Prático</h3>
<p>Uma <strong>Definição Dirigida por Sintaxe (SDD)</strong> é a especificação formal de uma gramática de atributos. É uma generalização que associa regras semânticas a cada produção de uma <strong>GLC</strong>. Uma <strong>SDD</strong> especifica <em>o que</em> deve ser calculado, mas não <em>como</em> ou <em>em que ordem</em>. A ordem de avaliação é determinada pelas dependências entre os atributos.</p>
<p>Com base nos tipos de atributos que utilizam, as <strong>SDD</strong>s podem ser classificadas em categorias importantes que impactam diretamente a implementação do compilador:</p>
<p><strong>Gramáticas S-Atribuídas</strong>: São <strong>SDD</strong>s que utilizam <strong>apenas</strong> atributos sintetizados. A avaliação desses atributos pode ser feita de forma natural durante uma travessia em pós-ordem da árvore sintática. Isso as torna perfeitamente compatíveis com analisadores sintáticos <em>bottom-up</em> (como os <span class="math inline">\(LR\)</span>), nos quais as ações semânticas podem ser executadas no momento em que uma produção é reduzida.</p>
<p><strong>Gramáticas L-Atribuídas</strong>: São uma classe mais ampla de <strong>SDD</strong>s que permitem tanto atributos sintetizados quanto herdados, mas com uma restrição: para uma produção A→X₁X₂…Xₙ, um atributo herdado de Xⱼ só pode depender:</p>
<ol type="1">
<li>Dos atributos herdados de <code>A</code>; e</li>
<li>De quaisquer atributos, herdados ou sintetizados, dos símbolos à sua esquerda, <code>X₁,…,Xⱼ₋₁</code>.</li>
</ol>
<p>Essa restrição garante que os atributos possam ser avaliados em uma única travessia em profundidade e da esquerda para a direita da árvore sintática. Isso as torna ideais para implementação em conjunto com analisadores sintáticos <em>top-down</em> (como os <span class="math inline">\(LL\)</span> e os de descida recursiva).</p>
</section>
<section id="esquemas-de-tradução-dirigida-por-sintaxe-sdt" class="level3" data-number="10.5.7">
<h3 data-number="10.5.7" class="anchored" data-anchor-id="esquemas-de-tradução-dirigida-por-sintaxe-sdt"><span class="header-section-number">10.5.7</span> Esquemas de Tradução Dirigida por Sintaxe (SDT)</h3>
<p>Enquanto uma <strong>SDD</strong> é uma especificação, um <strong>Esquema de Tradução Dirigida por Sintaxe (SDT)</strong> é uma implementação concreta. Um SDT é uma <strong>GLC</strong>na qual as <strong>ações semânticas</strong> (fragmentos de código) são embutidas diretamente no lado direito das produções. Essas ações são executadas no momento em que o analisador sintático reconhece aquela parte da produção.</p>
<p><strong>Exemplo de SDT para uma calculadora simples</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Produção</th>
<th style="text-align: left;">Ação Semântica</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">E→E₁+T</td>
<td style="text-align: left;">{ E.valor = E₁.valor + T.valor; }</td>
</tr>
<tr class="even">
<td style="text-align: left;">E→T</td>
<td style="text-align: left;">{ E.valor = T.valor; }</td>
</tr>
<tr class="odd">
<td style="text-align: left;">T→T₁*F</td>
<td style="text-align: left;">{ T.valor = T₁.valor * F.valor; }</td>
</tr>
<tr class="even">
<td style="text-align: left;">T→F</td>
<td style="text-align: left;">{ T.valor = F.valor; }</td>
</tr>
<tr class="odd">
<td style="text-align: left;">F→(E)</td>
<td style="text-align: left;">{ F.valor = E.valor; }</td>
</tr>
<tr class="even">
<td style="text-align: left;">F→num</td>
<td style="text-align: left;">{ F.valor = num.lexval; }</td>
</tr>
</tbody>
</table>
<p>Este é um exemplo de uma gramática S-atribuída, pois todas as ações calculam um atributo para o símbolo à esquerda da produção a partir dos símbolos à direita.</p>
<p>O formalismo das gramáticas de atributos e dos SDTs transforma a análise semântica, que poderia ser uma tarefa <em>ad-hoc</em> e propensa a erros, em um processo sistemático e declarativo. Ele nos permite raciocinar sobre o fluxo de informações contextuais de maneira estruturada, guiada diretamente pela sintaxe da linguagem, personificando o princípio da composicionalidade: o significado do todo é derivado do significado de suas partes.</p>
</section>
</section>
<section id="catálogo-de-verificações-semânticas-comuns" class="level2" data-number="10.6">
<h2 data-number="10.6" class="anchored" data-anchor-id="catálogo-de-verificações-semânticas-comuns"><span class="header-section-number">10.6</span> Catálogo de Verificações Semânticas Comuns</h2>
<p>A análise semântica é a última linha de defesa do <em>front-end</em> contra programas incorretos. Ela é responsável por capturar uma ampla gama de erros que são sintaticamente invisíveis, mas semanticamente inválidos. Esta seção cataloga as verificações mais comuns realizadas por um analisador semântico, com exemplos práticos de código que falhariam em cada verificação.</p>
<section id="verificações-relacionadas-a-nomes-e-escopos" class="level3" data-number="10.6.1">
<h3 data-number="10.6.1" class="anchored" data-anchor-id="verificações-relacionadas-a-nomes-e-escopos"><span class="header-section-number">10.6.1</span> Verificações Relacionadas a Nomes e Escopos</h3>
<p>Estas verificações garantem que os identificadores sejam usados de acordo com as regras de escopo da linguagem. A <strong>Tabela de Símbolos</strong> é a ferramenta central para realizar essas checagens.</p>
<p><strong>Uso de Identificador Não Declarado</strong>: Talvez o erro semântico mais fundamental. O compilador deve garantir que todo identificador (variável, função, etc.) tenha sido declarado antes de ser utilizado.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> b <span class="op">=</span> a <span class="op">+</span> c<span class="op">;</span> <span class="co">// ERRO: 'c' não foi declarado.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Declaração Múltipla de Identificador no Mesmo Escopo</strong>: A maioria das linguagens proíbe a redeclaração de um mesmo identificador dentro do mesmo escopo.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">minhaFuncao</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">String</span> x <span class="op">=</span> <span class="st">"hello"</span><span class="op">;</span> <span class="co">// ERRO: 'x' já está definido neste escopo.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="verificações-de-tipo" class="level3" data-number="10.6.2">
<h3 data-number="10.6.2" class="anchored" data-anchor-id="verificações-de-tipo"><span class="header-section-number">10.6.2</span> Verificações de Tipo</h3>
<p>O coração da análise semântica, a verificação de tipos garante que os dados sejam usados de maneira consistente com suas definições.</p>
<p><strong>Incompatibilidade em Atribuições</strong>: O tipo da expressão do lado direito de uma atribuição deve ser compatível (ou poder ser coagido) com o tipo da variável do lado esquerdo.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode csharp code-with-copy"><code class="sourceCode cs"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> idade<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>idade <span class="op">=</span> <span class="st">"vinte"</span><span class="op">;</span> <span class="co">// ERRO: Não é possível converter tipo 'string' para 'int'.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Incompatibilidade em Operandos de Expressões</strong>: Os operandos de um operador devem ter tipos que são válidos para aquele operador.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>resultado <span class="op">=</span> <span class="st">"Total: "</span> <span class="op">-</span> <span class="dv">10</span> <span class="co"># ERRO: Operador '-' não suportado entre 'str' e 'int'.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Tipo Incorreto em Estruturas de Controle</strong>: A expressão de controle em estruturas como <code>if</code>, <code>while</code> e <code>for</code> deve resultar em um tipo booleano (ou um tipo que possa ser coagido para booleano).</p>
<p><strong>Exemplo de Erro (em uma linguagem como</strong> <strong>Java)</strong>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> contador <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>contador<span class="op">)</span> <span class="op">{</span> <span class="co">// ERRO: 'contador' é int, mas um booleano é esperado.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">//...</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="verificações-relacionadas-a-sub-rotinas-funçõesmétodos" class="level3" data-number="10.6.3">
<h3 data-number="10.6.3" class="anchored" data-anchor-id="verificações-relacionadas-a-sub-rotinas-funçõesmétodos"><span class="header-section-number">10.6.3</span> Verificações Relacionadas a Sub-rotinas (Funções/Métodos)</h3>
<p>Essas verificações garantem que as funções sejam chamadas corretamente, respeitando suas assinaturas.</p>
<p><strong>Número Incorreto de Argumentos em Chamada</strong>: A chamada de uma função deve fornecer exatamente o número de argumentos que sua declaração exige.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> imprimirSoma<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  imprimirSoma<span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// ERRO: Poucos argumentos para a função.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Tipo Incorreto de Argumentos em Chamada</strong>: Os tipos dos argumentos passados em uma chamada devem ser compatíveis com os tipos dos parâmetros na declaração da função.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> imprimirNome<span class="op">(</span><span class="bu">std::</span>string nome<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> nome<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  imprimirNome<span class="op">(</span><span class="dv">123</span><span class="op">);</span> <span class="co">// ERRO: Tipo de argumento inválido (esperado string, obteve int).</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Retorno de Valor Incompatível</strong>: O valor retornado por uma função deve ser compatível com o tipo de retorno declarado na sua assinatura.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">obterIdade</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="st">"jovem"</span><span class="op">;</span> <span class="co">// ERRO: Tipo de retorno incompatível.</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="verificações-de-controle-de-fluxo" class="level3" data-number="10.6.4">
<h3 data-number="10.6.4" class="anchored" data-anchor-id="verificações-de-controle-de-fluxo"><span class="header-section-number">10.6.4</span> Verificações de Controle de Fluxo</h3>
<p>Essas regras garantem que as construções de controle de fluxo sejam usadas em contextos apropriados.</p>
<p><strong>break ou continue Fora de um Laço</strong>: As palavras-chave <code>break</code> e <code>continue</code> só são permitidas dentro do corpo de estruturas de repetição (como <code>while</code>, <code>for</code>, <code>do-while</code>).</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> verificar<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span> <span class="co">// ERRO: 'break' statement not within loop or switch.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Uso de Rótulos (Labels) Inexistentes</strong>: Em linguagens que suportam <code>goto</code>, o rótulo de destino deve existir dentro do escopo da função atual.</p>
<p><strong>Exemplo de Erro</strong>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> processar<span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">//...</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">goto</span> erro_fatal<span class="op">;</span> <span class="co">// ERRO: Rótulo 'erro_fatal' não definido.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="o-produto-final-a-árvore-de-sintaxe-abstrata-atribuída" class="level2" data-number="10.7">
<h2 data-number="10.7" class="anchored" data-anchor-id="o-produto-final-a-árvore-de-sintaxe-abstrata-atribuída"><span class="header-section-number">10.7</span> O Produto Final: A Árvore de Sintaxe Abstrata <em>Atribuída</em></h2>
<p>O resultado de uma análise semântica bem-sucedida, em uma passagem ou em múltiplas passagens, não será percebido por um valor <em>booleano</em> indicando sucesso ou falha. O produto tangível desta fase será uma <strong>Árvore de Sintaxe Abstrata “Atribuída”</strong>, ou em alguns livros árvore sintática abstrata anotada, ou ainda árvore sintática abstrata decorada.</p>
<p>O processo de decorar a árvore consiste em percorrer seus vértices e enriquecê-los com informações semânticas que foram inferidas durante a análise. Este é um processo de atribuição de informação aos vértices da árvore sintática. Por exemplo:</p>
<ul>
<li>um vértice que representa o uso de uma variável pode ser decorado com um ponteiro para a entrada correspondente na <strong>Tabela de Símbolos</strong>;</li>
<li>um vértice de expressão (como <code>+</code> ou <code>*</code>) pode ser decorado com o tipo resultante da operação (ex.: <code>int</code> ou <code>float</code>);</li>
<li>um vértice de declaração de tipo pode ser decorado com informações sobre o layout de memória daquele tipo.</li>
</ul>
<p>Essa <strong>AST</strong> atribuída é uma estrutura de dados rica. Ela contém não apenas a estrutura sintática do programa, mas também todo o entendimento contextual que o compilador adquiriu durante o processo de compilação. Ela serve como a única fonte de verdade para as fases subsequentes do processo de compilação, como a geração de código intermediário e a otimização. Nesse sentido, a análise semântica não apenas detecta e elimina erros, mas enriquece a representação do programa com informações que o fortalecem e o preparam para a transformação final em código executável.</p>
<p>A <strong>AST</strong> é a principal e mais importante estrutura de dados usada como entrada pelo analisador semântico. Mas, não é a única.</p>
<p>Para que um compilador possa realizar verificações semânticas, como garantir que uma variável foi declarada antes de ser usada ou que o tipo de uma expressão é válido, ele precisa de um mecanismo para registrar e recuperar informações sobre os identificadores encontrados no código-fonte. Essa “memória” do compilador é a <strong>Tabela de Símbolos</strong>. Os processos de análise léxica e sintática precisaram consultar esta tabela para identificar palavras reservadas e tipos básicos, mas é o analisador semântico que fará o uso mais intensivo e complexo desta estrutura.</p>
<p>A <strong>Tabela de Símbolos</strong> é uma estrutura de dados fundamental que associa cada identificador, ou símbolo, a um conjunto de informações, os atributos que citamos antes, que pertencem ao símbolo. Esta tabela funciona como um dicionário em que as chaves são os nomes dos símbolos e os valores são os metadados coletados sobre eles.</p>
<p>Praticamente todas as fases do compilador interagem com a <strong>Tabela de Símbolos</strong>:</p>
<ol type="1">
<li><strong>Análise Léxica</strong>: ao encontrar um identificador, o analisador léxico pode inseri-lo na <strong>Tabela de Símbolos</strong> se ele ainda não estiver presente. Ou para classificar um determinado lexema como uma palavra reservada, o analisador léxico consulta a tabela;</li>
<li><strong>Análise Sintática/Semântica</strong>: o analisador semântico consulta a <strong>Tabela de Símbolos</strong> constantemente para verificar declarações, tipos e escopos. Ele também a preenche com informações obtidas das declarações.</li>
<li><strong>Geração de Código e Otimização</strong>: as fases do <em>back-end</em> usam a tabela para obter informações como o tipo de uma variável e seu endereço de memória para gerar o código de máquina apropriado.</li>
</ol>
<p>A <strong>Tabela de Símbolos</strong> está detalhada na seção <a href="11-tabelaSimbolos.html" class="quarto-xref"><span>Chapter 14</span></a></p>
</section>
<section id="verificação-de-tipos-type-checking" class="level2" data-number="10.8">
<h2 data-number="10.8" class="anchored" data-anchor-id="verificação-de-tipos-type-checking"><span class="header-section-number">10.8</span> Verificação de Tipos, <em>Type Checking</em></h2>
<p>A verificação de tipos é, sem dúvida, a tarefa central da análise semântica. Ela consiste em percorrer a <strong>AST</strong> e aplicar um conjunto de regras para garantir que os tipos de dados sejam usados de maneira consistente e segura. Um <strong>tipo</strong> pode ser formalmente definido como um conjunto de valores e um conjunto de operações permitidas sobre esses valores. A verificação de tipos assegura que um programa não tente realizar operações absurdas, como somar uma <em>string</em> a um objeto de arquivo ou calcular a raiz quadrada de um booleano.</p>
<section id="a-importância-dos-tipos-prevenindo-o-absurdo-computacional" class="level3" data-number="10.8.1">
<h3 data-number="10.8.1" class="anchored" data-anchor-id="a-importância-dos-tipos-prevenindo-o-absurdo-computacional"><span class="header-section-number">10.8.1</span> A Importância dos Tipos: Prevenindo o “Absurdo” Computacional</h3>
<p>Os sistemas de tipos impõem uma disciplina que traz enormes benefícios, principalmente a detecção de uma vasta classe de erros antes mesmo da execução do programa. Essa verificação pode ocorrer em momentos distintos, o que nos leva a uma das mais importantes classificações de linguagens de programação.</p>
<section id="tipagem-estática-vs.-dinâmica" class="level4" data-number="10.8.1.1">
<h4 data-number="10.8.1.1" class="anchored" data-anchor-id="tipagem-estática-vs.-dinâmica"><span class="header-section-number">10.8.1.1</span> Tipagem Estática vs.&nbsp;Dinâmica</h4>
<p><strong>Tipagem Estática</strong>: A verificação de tipos é realizada em <strong>tempo de compilação</strong>. O compilador analisa o código-fonte, infere ou lê as anotações de tipo e valida todas as operações. Se um erro de tipo é encontrado, a compilação falha. Linguagens como <strong>Java</strong>, <strong>C++</strong>, <strong>C#</strong>, <strong>Rust</strong> e <strong>Haskell</strong> são estaticamente tipadas.</p>
<p><strong>Vantagens</strong>:</p>
<ol type="1">
<li><strong>Detecção Precoce de Erros</strong>: Erros de tipo são encontrados durante o desenvolvimento, não em produção.</li>
<li><strong>Performance</strong>: O compilador pode gerar código de máquina altamente otimizado, pois não precisa inserir verificações de tipo em tempo de execução nem carregar “tags” de tipo junto com os dados.</li>
<li><strong>Documentação e Manutenibilidade</strong>: As declarações de tipo servem como uma forma de documentação, tornando o código mais fácil de entender e refatorar.</li>
</ol>
<p><strong>Desvantagens</strong>: Pode ser menos flexível e exigir mais código explícito (boilerplate) do programador.</p>
<p><strong>Tipagem Dinâmica</strong>: A verificação de tipos é adiada para <strong>tempo de execução</strong>. As variáveis não possuem tipos fixos, mas os valores que elas contêm sim. Antes de cada operação, o sistema de tempo de execução verifica se os tipos dos valores são compatíveis. Se não forem, um erro é lançado durante a execução. Linguagens como <strong>Python</strong>, <strong>JavaScript</strong>, <strong>Ruby</strong> e <strong>LISP</strong> são dinamicamente tipadas.</p>
<p><strong>Vantagens</strong>:</p>
<ol type="1">
<li><strong>Flexibilidade</strong>: permite estruturas de dados heterogêneas e um estilo de programação mais fluido, ideal para prototipagem rápida.</li>
<li><strong>Menos Verboso</strong>: geralmente, não requer anotações de tipo explícitas.</li>
</ol>
<p><strong>Desvantagens</strong>:</p>
<ol type="1">
<li><strong>Erros em Tempo de Execução</strong>: Erros de tipo só são descobertos quando o código é efetivamente executado, o que pode ocorrer tardiamente no ciclo de vida do software.</li>
<li><strong><em>overhead</em> de Performance</strong>: A necessidade de verificar tipos em tempo de execução e de armazenar informações de tipo com cada valor impõe uma penalidade de desempenho.</li>
</ol>
</section>
<section id="tipagem-forte-vs.-fraca" class="level4" data-number="10.8.1.2">
<h4 data-number="10.8.1.2" class="anchored" data-anchor-id="tipagem-forte-vs.-fraca"><span class="header-section-number">10.8.1.2</span> Tipagem Forte vs.&nbsp;Fraca</h4>
<p>Essa distinção, muitas vezes confundida com estática vs.&nbsp;dinâmica, refere-se ao rigor com que a linguagem impõe suas regras de tipo.</p>
<p><strong>Tipagem Forte</strong>: Uma linguagem fortemente tipada não permite que operações sejam realizadas entre tipos incompatíveis, prevenindo comportamento indefinido. Ela pode permitir conversões implícitas (coerção), mas apenas de maneiras bem-definidas e seguras. Por exemplo, em<strong>Python</strong> (fortemente tipado), <code>3 + "olá"</code> resulta em um <code>TypeError</code> em tempo de execução, pois a operação não está definida.</p>
<p><strong>Tipagem Fraca</strong>: Uma linguagem fracamente tipada possui regras de tipo mais permissivas e pode tentar realizar operações mesmo entre tipos incompatíveis, muitas vezes tratando os dados como sequências de bits. Em C (fracamente tipado), é possível usar um *<em>cast</em> para tratar um ponteiro para um inteiro como um ponteiro para uma estrutura, contornando o sistema de tipos e abrindo a porta para erros difíceis de depurar e vulnerabilidades de segurança.</p>
<p>É importante que a atenta leitora perceba que essas duas classificações são ortogonais. Temos:</p>
<ul>
<li><strong>Estática e Forte</strong>: <strong>Java</strong>, <strong>Rust</strong>, <strong>Haskell</strong>;</li>
<li><strong>Estática e Fraca</strong>: <strong>C</strong>, <strong>C++</strong>;</li>
<li><strong>Dinâmica e Forte</strong>: <strong>Python</strong>, <strong>Ruby</strong>;</li>
<li><strong>Dinâmica e Fraca</strong>: <strong>Tcl</strong>, <strong>JavaScript</strong>.</li>
</ul>
<p>A escolha de um sistema de tipos reflete uma filosofia de design da linguagem, um balanço entre segurança, flexibilidade, performance e expressividade.</p>
</section>
</section>
<section id="equivalência-de-tipos-quando-t1-é-igual-a-t2" class="level3" data-number="10.8.2">
<h3 data-number="10.8.2" class="anchored" data-anchor-id="equivalência-de-tipos-quando-t1-é-igual-a-t2"><span class="header-section-number">10.8.2</span> Equivalência de Tipos: Quando T1 é igual a T2?</h3>
<p>Para verificar se uma operação é válida, o compilador precisa primeiro determinar se os tipos envolvidos são equivalentes. Existem duas abordagens principais para isso:</p>
<p><strong>Equivalência por Nome (Nominal)</strong>: dois tipos são considerados equivalentes se, e somente se, eles têm o mesmo nome. Cada declaração de um novo tipo (ex.: com <code>typedef</code> em C, <code>type</code> em Pascal, ou <code>class</code> em <strong>Java</strong>) cria um tipo único e distinto dos outros, mesmo que suas estruturas subjacentes sejam idênticas. Essa é a abordagem mais comum em linguagens modernas como <strong>Java</strong>, <strong>C#</strong> e <strong>C++</strong>. Esta abordagem é mais segura e reflete melhor a intenção do programador.</p>
<p><strong>Exemplo</strong>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Definição da classe para representar um Ponto</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Ponto <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">Ponto</span><span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">x</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">y</span> <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Definição da classe para representar um Vetor</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vetor <span class="op">{</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">Vetor</span><span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">x</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">y</span> <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="co">// Classe principal para testar a compatibilidade</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> TesteTipos <span class="op">{</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    Ponto p <span class="op">=</span> <span class="kw">new</span> <span class="fu">Ponto</span><span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    Vetor v <span class="op">=</span> <span class="kw">new</span> <span class="fu">Vetor</span><span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="op">-</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A linha a seguir causará um ERRO DE COMPILAÇÃO</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// p = v; </span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Erro típico: "incompatible types: Vetor cannot be converted to Ponto"</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Apesar de <code>Ponto</code> e <code>Vetor</code> serem estruturalmente idênticas, ambas possuem dois campos <code>int</code> chamados <code>x</code> e <code>y</code>, o compilador <strong>Java</strong> as considera como tendo tipos completamente incompatíveis. A tentativa de atribuir um objeto <code>Vetor</code> a uma variável do tipo <code>Ponto</code> (<code>p = v;</code>) falha com um erro claro, como: <code>error: incompatible types: Vetor cannot be converted to Ponto</code>. Isso ocorre porque, para o <strong>Java</strong>, o que importa é o nome do tipo. <code>Ponto</code> é um nome, <code>Vetor</code> é outro. Em <strong>Java</strong> a equivalência é nominal.</p>
<p><strong>Equivalência Estrutural</strong>: dois tipos são equivalentes se eles têm a mesma estrutura interna. Os nomes dos tipos são ignorados; o compilador expande as definições de tipo e compara suas formas recursivamente. Essa abordagem é mais flexível, mas pode levar a equivalências acidentais entre tipos que são conceitualmente diferentes. É usada em linguagens como <strong>Go</strong> e <strong>TypeScript</strong>.</p>
<p><strong>Exemplo</strong>: no exemplo acima, sob equivalência estrutural, <code>Ponto</code> e <code>Vetor</code> seriam considerados o mesmo tipo, pois ambos são estruturas com dois campos inteiros chamados <code>x</code> e <code>y</code>. A atribuição <code>v = p;</code> seria válida.</p>
</section>
<section id="compatibilidade-de-tipos-coerção-e-conversão-casting" class="level3" data-number="10.8.3">
<h3 data-number="10.8.3" class="anchored" data-anchor-id="compatibilidade-de-tipos-coerção-e-conversão-casting"><span class="header-section-number">10.8.3</span> Compatibilidade de Tipos: Coerção e Conversão (Casting)</h3>
<p>Mesmo que dois tipos não sejam equivalentes, eles podem ser <strong>compatíveis</strong>. A compatibilidade permite que um valor de um tipo seja usado em um contexto que espera outro.</p>
<p><strong>Conversão (Casting)</strong>: é uma mudança de tipo explícita, solicitada pelo programador. O <em>cast</em> informa ao compilador: “Eu sei o que estou fazendo; trate este valor como se fosse deste outro tipo”. O compilador insere o código necessário para realizar a conversão.</p>
<p>Exemplo em <strong>C</strong>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span> </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>f<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Coerção (<em>Coercion</em>)</strong>: é uma conversão de tipo <strong>implícita</strong>, realizada automaticamente pelo compilador para que uma operação seja válida. Isso acontece em “promoções numéricas”, por exemplo.</p>
<p>Exemplo:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> d <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O compilador automaticamente promove o literal inteiro <code>5</code> para o valor de ponto flutuante <code>5.0</code> antes da atribuição. A coerção aumenta a conveniência, mas pode mascarar erros graves se as regras não forem bem compreendidas.</p>
</section>
<section id="lidando-com-polimorfismo-muitas-formas" class="level3" data-number="10.8.4">
<h3 data-number="10.8.4" class="anchored" data-anchor-id="lidando-com-polimorfismo-muitas-formas"><span class="header-section-number">10.8.4</span> Lidando com Polimorfismo: “Muitas Formas”</h3>
<p>Polimorfismo, da expressão em grego para muitas formas, é a capacidade de uma única interface, como uma função ou um operador, ser usada com diferentes tipos de dados. Existem três tipos principais de polimorfismo que um sistema de tipos deve gerenciar:</p>
<ol type="1">
<li><p><strong>Polimorfismo Ad-hoc (Sobrecarga)</strong>: ocorre quando múltiplas funções ou métodos compartilham o mesmo nome, mas têm assinaturas (tipos e/ou número de parâmetros) diferentes. O compilador (ou o sistema de tempo de execução) seleciona a implementação correta com base nos tipos dos argumentos fornecidos na chamada. O exemplo clássico é o operador <code>+</code>, que realiza adição para números e concatenação para <em>strings</em>.</p></li>
<li><p><strong>Polimorfismo Paramétrico (Generics)</strong>: permite que uma função ou tipo de dado seja escrito de forma genérica, para que possa lidar com valores de forma idêntica, sem depender de seu tipo. O código é parametrizado por uma ou mais variáveis de tipo. Um exemplo é uma função <code>reverse</code> que pode reverter uma lista de qualquer tipo, pois o algoritmo de reversão não depende do tipo dos elementos da lista.</p></li>
<li><p><strong>Polimorfismo de Subtipo (Herança)</strong>: é a base da programação orientada a objetos. Permite que um objeto de uma classe derivada (subtipo) seja usado em qualquer contexto que espere um objeto da classe base. Por exemplo, uma função que espera um objeto do tipo <code>Animal</code> pode receber, sem problemas, um objeto do tipo <code>Cachorro</code>, assumindo que <code>Cachorro</code> herda de <code>Animal</code>.</p></li>
</ol>
</section>
<section id="a-base-formal-dos-sistemas-de-tipos" class="level3" data-number="10.8.5">
<h3 data-number="10.8.5" class="anchored" data-anchor-id="a-base-formal-dos-sistemas-de-tipos"><span class="header-section-number">10.8.5</span> A Base Formal dos Sistemas de Tipos</h3>
<p>Até agora, discutimos a verificação de tipos de forma intuitiva. No entanto, para que um compilador possa executar essa tarefa de maneira automática e correta, nossa intuição precisa ser traduzida para um sistema matemático rigoroso. A teoria dos tipos nos fornece exatamente esse formalismo, permitindo não apenas especificar as regras de tipo de uma linguagem, mas também provar que um programa é seguro com relação a tipos, conceito chamado de <em>type-safe</em>, antes de sua execução.</p>
<p>O pilar deste sistema é uma afirmação conhecida como <strong>julgamento de tipo</strong>, em inglês: <em>typing judgment</em>, representada pela seguinte notação:</p>
<p><span class="math display">\[\Gamma \vdash e : \tau\]</span></p>
<p>A atenta leitora não deve se intimidar com os símbolos. Essa expressão formaliza uma ideia bastante simples e pode ser lida da seguinte forma: “<strong>No contexto <span class="math inline">\(\Gamma\)</span>, é possível provar que a expressão <span class="math inline">\(e\)</span> tem o tipo <span class="math inline">\(\tau\)</span></strong>”. Vamos dissecar cada componente:</p>
<ul>
<li><span class="math inline">\(\Gamma\)</span> (Gama): é o <strong>contexto de tipagem</strong>, também chamado de ambiente. Na prática, ele é a nossa <strong>Tabela de Símbolos</strong>. É um mapa que armazena as informações de tipo que já conhecemos, como as associações entre nomes de variáveis e seus respectivos tipos (por exemplo, <span class="math inline">\(\{ x: \text{int}, y: \text{bool} \}\)</span>).</li>
<li><span class="math inline">\(\vdash\)</span> (<em>Turnstile</em>, ou “|-”, ou ainda catraca): é o símbolo de derivação. Ele separa as nossas premissas (o que já sabemos, o contexto <span class="math inline">\(\Gamma\)</span>) da nossa conclusão, a afirmação de que <span class="math inline">\(e\)</span> tem o tipo <span class="math inline">\(\tau\)</span>.</li>
<li><span class="math inline">\(e : \tau\)</span>: é a afirmação central que queremos provar: a expressão <span class="math inline">\(e\)</span> tem o tipo <span class="math inline">\(\tau\)</span>.</li>
</ul>
<p>Com essa estrutura, podemos definir as regras de tipo de uma linguagem como <strong>regras de inferência</strong>. Elas nos dizem como derivar novos julgamentos de tipo a partir de julgamentos existentes. A estrutura de uma regra de inferência é sempre a mesma: se as premissas (acima da linha) forem verdadeiras, então podemos concluir que a afirmação (abaixo da linha) também é verdadeira.</p>
<p>Vejamos as três regras fundamentais para uma linguagem funcional simples:</p>
<p><strong>Regra da Variável (O Axioma)</strong>: esta é a regra mais básica, nosso ponto de partida. Ela formaliza a consulta à <strong>Tabela de Símbolos</strong>.</p>
<p><span class="math display">\[\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}\]</span></p>
<p><strong>Leitura</strong>: se o contexto <span class="math inline">\(\Gamma\)</span> nos informa que a variável <code>x</code> está associada ao tipo <span class="math inline">\(\tau\)</span>, então podemos concluir que, neste contexto, <code>x</code> tem o tipo <span class="math inline">\(\tau\)</span>. Este é o nosso caso base: a prova de que o tipo de uma variável é simplesmente o tipo que lhe foi declarado.</p>
<p><strong>Regra da Abstração (Definição de Função)</strong>: esta regra nos ensina a determinar o tipo de uma função (em cálculo lambda, uma “abstração”).</p>
<p><span class="math display">\[\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x : \tau_1 . e : \tau_1 \rightarrow \tau_2}\]</span></p>
<p><strong>Leitura</strong>: para descobrir o tipo de uma função <span class="math inline">\(\lambda x.e\)</span>, primeiro assumimos que seu argumento <code>x</code> tem um tipo <span class="math inline">\(\tau_1\)</span>. Adicionamos essa suposição (<span class="math inline">\(x : \tau_1\)</span>) ao nosso contexto, criando um novo contexto <span class="math inline">\(\Gamma, x : \tau_1\)</span>. Se, nesse novo contexto, conseguirmos provar que o corpo da função <span class="math inline">\(e\)</span> tem o tipo <span class="math inline">\(\tau_2\)</span>, então podemos concluir que a função inteira tem o tipo <span class="math inline">\(\tau_1 \rightarrow \tau_2\)</span>, uma função que recebe <span class="math inline">\(\tau_1\)</span> e retorna <span class="math inline">\(\tau_2\)</span>.</p>
<p><strong>Regra da Aplicação (Chamada de Função)</strong>: esta regra governa como verificamos a chamada de uma função.</p>
<p><span class="math display">\[\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 \, e_2 : \tau_2}\]</span></p>
<p><strong>Leitura</strong>: para verificar a chamada de função <span class="math inline">\(e_1 \, e_2\)</span>, precisamos provar duas coisas em nosso contexto <span class="math inline">\(\Gamma\)</span>: primeiro, que <span class="math inline">\(e_1\)</span> é de fato uma função do tipo <span class="math inline">\(\tau_1 \rightarrow \tau_2\)</span>, e segundo, que o argumento <span class="math inline">\(e_2\)</span> que estamos passando para ela tem o tipo <span class="math inline">\(\tau_1\)</span>. Se ambas as premissas forem verdadeiras, podemos concluir que a expressão inteira da chamada de função resulta em um valor do tipo <span class="math inline">\(\tau_2\)</span>.</p>
</section>
<section id="construindo-uma-árvore-de-derivação-um-exemplo-prático" class="level3" data-number="10.8.6">
<h3 data-number="10.8.6" class="anchored" data-anchor-id="construindo-uma-árvore-de-derivação-um-exemplo-prático"><span class="header-section-number">10.8.6</span> Construindo uma Árvore de Derivação: Um Exemplo Prático</h3>
<p>Para tornar essas regras abstratas mais concretas, vamos construir uma <strong>árvore de derivação de tipos</strong> passo a passo. Nosso objetivo será provar formalmente que a expressão <code>(λx:int. x + 1) 5</code> tem o tipo <code>int</code>, partindo de um contexto vazio <code>Γ = {}</code>.</p>
<p>Uma árvore de derivação é uma representação visual de como as regras de inferência se encaixam. A expressão final que queremos provar fica na raiz (embaixo), e as premissas formam os galhos que crescem para cima, terminando em axiomas (regras que não têm premissas).</p>
<p>Antes de começar, precisamos de mais duas regras simples para lidar com literais e operadores:</p>
<p><strong>Regra da Constante (ou Literal)</strong>: Um literal já carrega seu próprio tipo. <span class="math display">\[\frac{c \text{ é um literal de tipo } \tau}{\Gamma \vdash c : \tau}\]</span></p>
<p><strong>Regra do Operador (exemplo para <code>+</code>)</strong>: Se somarmos dois inteiros, o resultado é um inteiro. <span class="math display">\[\frac{\Gamma \vdash e_1 : \text{int} \quad \Gamma \vdash e_2 : \text{int}}{\Gamma \vdash e_1 + e_2 : \text{int}}\]</span></p>
<p>Agora, vamos provar que <code>{} ⊢ (λx:int. x + 1) 5 : int</code>. Construímos a prova de baixo para cima, aplicando a regra que corresponde à estrutura da expressão em cada passo.</p>
<ol type="1">
<li><p><strong>O Objetivo Final:</strong> A expressão <code>(λx:int. x + 1) 5</code> é uma <em>aplicação de função</em>. Portanto, a última regra a ser usada é a <strong>Regra da Aplicação</strong>. Para que a conclusão seja <code>... : int</code>, a regra nos diz que a função deve ter o tipo <code>τ₁ → int</code> e o argumento deve ter o tipo <code>τ₁</code>. Nossa hipótese é que <code>τ₁</code> seja <code>int</code>. Então, precisamos provar duas premissas:</p>
<ul>
<li><code>{} ⊢ (λx:int. x + 1) : int → int</code></li>
<li><code>{} ⊢ 5 : int</code></li>
</ul></li>
<li><p><strong>Provando a Premissa 2 (o argumento):</strong> Provar <code>{} ⊢ 5 : int</code> é simples. Usamos a <strong>Regra da Constante</strong>. Este é um galho finalizado (um axioma).</p></li>
<li><p><strong>Provando a Premissa 1 (a função):</strong> A expressão <code>λx:int. x + 1</code> é uma <em>abstração de função</em>. A única regra que se aplica é a <strong>Regra da Abstração</strong>. Para provar que a função tem o tipo <code>int → int</code>, precisamos adicionar a hipótese do argumento (<code>x:int</code>) ao contexto e provar que o corpo da função (<code>x + 1</code>) tem o tipo <code>int</code> nesse novo contexto. Nossa nova meta é:</p>
<ul>
<li><code>{x:int} ⊢ x + 1 : int</code></li>
</ul></li>
<li><p><strong>Provando o Corpo da Função:</strong> A expressão <code>x + 1</code> é uma operação de soma. Aplicamos a <strong>Regra do Operador <code>+</code></strong>. Para isso, precisamos provar suas duas premissas no contexto atual (<code>{x:int}</code>):</p>
<ul>
<li><code>{x:int} ⊢ x : int</code></li>
<li><code>{x:int} ⊢ 1 : int</code></li>
</ul></li>
<li><p><strong>Provando as Folhas da Árvore:</strong></p>
<ul>
<li>Para provar <code>{x:int} ⊢ x : int</code>, usamos a <strong>Regra da Variável</strong>. Como <code>x:int</code> está no contexto, a regra se aplica diretamente.</li>
<li>Para provar <code>{x:int} ⊢ 1 : int</code>, usamos a **Regra da Constante`.</li>
</ul></li>
</ol>
<p>Como conseguimos provar todas as premissas até chegar a axiomas, a derivação inteira é válida!</p>
<section id="a-árvore-de-derivação-completa" class="level4" data-number="10.8.6.1">
<h4 data-number="10.8.6.1" class="anchored" data-anchor-id="a-árvore-de-derivação-completa"><span class="header-section-number">10.8.6.1</span> A Árvore de Derivação Completa</h4>
<p>Visualmente, a prova completa se parece com esta árvore, na qual lemos de cima (axiomas) para baixo (conclusão):</p>
<pre class="shell"><code>
Regra da Variável         Regra da Constante
-----------------        ------------------
{x:int} ⊢ x : int         {x:int} ⊢ 1 : int
------------------------------------------------------ Regra do Operador (+)
    {x:int} ⊢ x + 1 : int
------------------------------------------------------ Regra da Abstração    ---------------- Regra da Constante
{} ⊢ (λx:int. x + 1) : int → int                    {} ⊢ 5 : int
-------------------------------------------------------------------------------------------------- Regra da Aplicação
               {} ⊢ (λx:int. x + 1) 5 : int
</code></pre>
</section>
</section>
<section id="exemplo-adicional-verificação-de-tipos-em-c" class="level3" data-number="10.8.7">
<h3 data-number="10.8.7" class="anchored" data-anchor-id="exemplo-adicional-verificação-de-tipos-em-c"><span class="header-section-number">10.8.7</span> Exemplo Adicional: Verificação de Tipos em <strong>C++</strong></h3>
<p>Para demonstrar como o mesmo formalismo se aplica a linguagens imperativas, vamos analisar um trecho de código <strong>C++</strong> muito comum. O objetivo não é mais encontrar o tipo de uma expressão única, mas sim provar que uma sequência de comandos é <strong>bem-tipada</strong>, passo a passo, atualizando o contexto de tipagem (<code>Γ</code>) a cada declaração. Considere o código:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> x <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Vamos começar com um contexto vazio, <code>Γ₀ = {}</code>.</p>
<section id="análise-da-linha-1-int-x-10" class="level4" data-number="10.8.7.1">
<h4 data-number="10.8.7.1" class="anchored" data-anchor-id="análise-da-linha-1-int-x-10"><span class="header-section-number">10.8.7.1</span> Análise da Linha 1: <code>int x = 10;</code></h4>
<p>Para validar uma declaração com inicialização, precisamos de uma regra específica.</p>
<p><strong>Regra da Declaração (Simplificada)</strong>: Uma declaração <code>T v = e;</code> é bem-tipada se a expressão <code>e</code> tiver o tipo <code>T</code>. O efeito de uma declaração bem-tipada é adicionar a nova variável <code>v</code> com seu tipo <code>T</code> ao contexto para as linhas seguintes. <span class="math display">\[\frac{\Gamma \vdash e : T}{\Gamma \vdash (\texttt{T v = e;}) : \textbf{ok}}\]</span></p>
<p>Na qual, <strong>ok</strong> significa que a declaração é semanticamente válida/bem-tipada.</p>
<p>Para validar <code>int x = 10;</code> no contexto <code>Γ₀</code>, aplicamos esta regra:</p>
<ol type="1">
<li><strong>Objetivo:</strong> Provar que <code>Γ₀ ⊢ (int x = 10;) : ok</code>.</li>
<li><strong>Premissa Necessária:</strong> Pela regra, precisamos primeiro provar que <code>Γ₀ ⊢ 10 : int</code>.</li>
<li><strong>Prova da Premissa:</strong> Usando a <strong>Regra da Constante</strong>, sabemos que o literal <code>10</code> tem o tipo <code>int</code>. A premissa é verdadeira.</li>
</ol>
<p>Como a premissa é válida, a declaração <code>int x = 10;</code> é bem-tipada. O efeito colateral desta análise é a criação de um novo contexto para a próxima linha: <code>Γ₁ = Γ₀ ∪ {x:int}</code>.</p>
</section>
<section id="análise-da-linha-2-int-y-x-5" class="level4" data-number="10.8.7.2">
<h4 data-number="10.8.7.2" class="anchored" data-anchor-id="análise-da-linha-2-int-y-x-5"><span class="header-section-number">10.8.7.2</span> Análise da Linha 2: <code>int y = x + 5;</code></h4>
<p>Agora, analisamos a segunda linha no <strong>novo contexto</strong> <code>Γ₁ = {x:int}</code>.</p>
<ol type="1">
<li><p><strong>Objetivo:</strong> Provar que <code>Γ₁ ⊢ (int y = x + 5;) : ok</code>.</p></li>
<li><p><strong>Premissa Necessária:</strong> Usando a mesma <strong>Regra da Declaração</strong>, precisamos provar que a expressão do lado direito tem o tipo <code>int</code>, ou seja, <code>Γ₁ ⊢ x + 5 : int</code>.</p></li>
<li><p><strong>Prova da Premissa:</strong> A expressão <code>x + 5</code> é uma soma. Usamos a <strong>Regra do Operador <code>+</code></strong>, que por sua vez exige duas novas premissas:</p>
<ul>
<li><code>Γ₁ ⊢ x : int</code></li>
<li><code>Γ₁ ⊢ 5 : int</code></li>
</ul></li>
<li><p><strong>Prova das Sub-premissas:</strong></p>
<ul>
<li><code>Γ₁ ⊢ x : int</code> é verdadeiro pela <strong>Regra da Variável</strong>, pois <code>x:int</code> existe em nosso contexto <code>Γ₁</code>.</li>
<li><code>Γ₁ ⊢ 5 : int</code> é verdadeiro pela <strong>Regra da Constante</strong>.</li>
</ul></li>
</ol>
<p>Como todas as premissas foram satisfeitas, a expressão <code>x + 5</code> de fato tem o tipo <code>int</code>. Consequentemente, a declaração <code>int y = x + 5;</code> é bem-tipada.</p>
<p>A árvore de derivação para a segunda linha seria:</p>
<pre class="shell"><code>Regra da Variável    Regra da Constante
-------------------  ------------------
Γ₁ ⊢ x : int       Γ₁ ⊢ 5 : int
------------------------------------------- Regra do Operador (+)
      Γ₁ ⊢ x + 5 : int
------------------------------------------- Regra da Declaração
     Γ₁ ⊢ (int y = x + 5;) : ok</code></pre>
<p>Este exemplo mostra como o sistema de julgamento de tipos funciona como um mecanismo formal que não só valida expressões, mas também modela a forma como o contexto (o conhecimento do compilador sobre as variáveis declaradas) evolui ao longo da análise de um programa imperativo.</p>
</section>
</section>
</section>
<section id="exercícios-da-seção" class="level2" data-number="10.9">
<h2 data-number="10.9" class="anchored" data-anchor-id="exercícios-da-seção"><span class="header-section-number">10.9</span> Exercícios da Seção</h2>
<section id="questão-1-considerando-que-estamos-trabalhando-em-uma-liguagem-de-programação-na-qual-o-contexto-pode-ser-formado-de-objetos-o-métodos-m-e-classes-c.-qual-a-regra-de-dedução-para-o-julgamento-de-tipo-para-a-adição-de-inteiros" class="level3" data-number="10.9.1">
<h3 data-number="10.9.1" class="anchored" data-anchor-id="questão-1-considerando-que-estamos-trabalhando-em-uma-liguagem-de-programação-na-qual-o-contexto-pode-ser-formado-de-objetos-o-métodos-m-e-classes-c.-qual-a-regra-de-dedução-para-o-julgamento-de-tipo-para-a-adição-de-inteiros"><span class="header-section-number">10.9.1</span> Questão 1: Considerando que estamos trabalhando em uma liguagem de programação na qual o contexto pode ser formado de objetos <span class="math inline">\(O\)</span>, métodos <span class="math inline">\(M\)</span> e classes <span class="math inline">\(C\)</span>. Qual a regra de dedução para o julgamento de tipo para a adição de inteiros?</h3>
<p>O julgamento de tipo para adição de inteiros pode ser expresso como:</p>
<p><span class="math display">\[\frac{O,M,C \vdash e_1 : \text{Int} \quad O,M,C \vdash e_2 : \text{Int}}{O,M,C \vdash e_1 + e_2 : \text{Int}}\]</span></p>
<p>Leitura da regra: Se no ambiente de objetos <span class="math inline">\(O\)</span>, métodos <span class="math inline">\(M\)</span> e classes <span class="math inline">\(C\)</span>, a expressão <span class="math inline">\(e_1\)</span> tem tipo <code>Int</code> e a expressão <span class="math inline">\(e_2\)</span> tem tipo <code>Int</code>, então a expressão <span class="math inline">\(e_1 + e_2\)</span> tem tipo <code>Int</code>.</p>
<p>Em outras palavras, para que uma operação de adição seja bem tipada, ambos os operandos devem ter tipo inteiro, e o resultado também será um inteiro.</p>
</section>
<section id="questão-2-no-mesmo-ambiente-da-questão-um.-como-seria-o-julgamento-de-tipo-para-instruções-if" class="level3" data-number="10.9.2">
<h3 data-number="10.9.2" class="anchored" data-anchor-id="questão-2-no-mesmo-ambiente-da-questão-um.-como-seria-o-julgamento-de-tipo-para-instruções-if"><span class="header-section-number">10.9.2</span> Questão 2: No mesmo ambiente da questão um. Como seria o julgamento de tipo para instruções <code>IF</code>?</h3>
<p>O julgamento de tipo para instruções condicionais (IF) pode ser expresso como:</p>
<p><span class="math display">\[\frac{O,M,C \vdash e_1 : \text{Bool} \quad O,M,C \vdash e_2 : T_2 \quad O,M,C \vdash e_3 : T_3 \quad T_2 \sqcup T_3 = T}{O,M,C \vdash \text{if } e_1 \text{ then } e_2 \text{ else } e_3 : T}\]</span></p>
<p>Leitura da regra: Se a condição <span class="math inline">\(e_1\)</span> tem tipo <code>Bool</code>, o ramo then <span class="math inline">\(e_2\)</span> tem tipo <span class="math inline">\(T_2\)</span>, o ramo else <span class="math inline">\(e_3\)</span> tem tipo <span class="math inline">\(T_3\)</span>, e o menor limite superior (join) de <span class="math inline">\(T_2\)</span> e <span class="math inline">\(T_3\)</span> é <span class="math inline">\(T\)</span>, então toda a expressão if tem tipo <span class="math inline">\(T\)</span>.</p>
</section>
<section id="questão-3-o-que-a-seguinte-regra-significa-como-lemos-ela" class="level3" data-number="10.9.3">
<h3 data-number="10.9.3" class="anchored" data-anchor-id="questão-3-o-que-a-seguinte-regra-significa-como-lemos-ela"><span class="header-section-number">10.9.3</span> Questão 3: O que a seguinte regra significa? Como lemos ela?</h3>
<p>A regra apresentada é:</p>
<p><span class="math display">\[\frac{O,M,C \vdash e_1 : T_1 \quad O,M,C \vdash e_2 : T_2 \quad \vdots \quad O,M,C \vdash e_n : T_n}{O,M,C \vdash \{ e_1; e_2; \ldots e_n; \} : T_n} \quad \text{[Sequence]}\]</span></p>
<p><strong>Significado da regra</strong>: Esta é a regra de tipagem para sequências de expressões. Ela especifica que uma sequência de expressões tem o tipo da última expressão na sequência.</p>
<p><strong>Como ler</strong>: Se no contexto de tipagem <span class="math inline">\(O,M,C\)</span> temos que:</p>
<ul>
<li>a expressão <span class="math inline">\(e_1\)</span> tem tipo <span class="math inline">\(T_1\)</span>;</li>
<li>a expressão <span class="math inline">\(e_2\)</span> tem tipo <span class="math inline">\(T_2\)</span>;</li>
<li>e assim por diante até a expressão <span class="math inline">\(e_n\)</span> que tem tipo <span class="math inline">\(T_n\)</span></li>
</ul>
<p>Então a sequência inteira <code>{ e₁; e₂; ... eₙ; }</code> tem tipo <span class="math inline">\(T_n\)</span> (o tipo da última expressão).</p>
<p><strong>Intuição</strong>: Em muitas linguagens, uma sequência de comandos é executada em ordem, e o valor retornado é o valor da última expressão. Por exemplo:</p>
<pre class="shell"><code>{
  x &lt;- 5;
  y &lt;- 10;
  x + y
}</code></pre>
<p>Esta sequência tem tipo <code>Int</code> porque a última expressão <code>x + y</code> tem tipo <code>Int</code>, independentemente dos tipos das expressões anteriores.</p>
</section>
<section id="questão-4-considere-uma-linguagem-de-programação-que-suporta-variáveis-funções-e-expressões-aritméticas-com-tipos-inteiro-real-e-string.-crie-um-sistema-de-tipos-com-cálculo-de-sequentes-e-escreva-as-regra-de-tipagem-para-a-declaração-de-variáveis-operações-aritméticas-strings-e-para-a-chamada-de-função." class="level3" data-number="10.9.4">
<h3 data-number="10.9.4" class="anchored" data-anchor-id="questão-4-considere-uma-linguagem-de-programação-que-suporta-variáveis-funções-e-expressões-aritméticas-com-tipos-inteiro-real-e-string.-crie-um-sistema-de-tipos-com-cálculo-de-sequentes-e-escreva-as-regra-de-tipagem-para-a-declaração-de-variáveis-operações-aritméticas-strings-e-para-a-chamada-de-função."><span class="header-section-number">10.9.4</span> Questão 4: Considere uma linguagem de programação que suporta variáveis, funções e expressões aritméticas com tipos inteiro, real e <em>string</em>. Crie um sistema de tipos com Cálculo de Sequentes e escreva as regra de tipagem para a declaração de variáveis, operações aritméticas, <em>strings</em> e para a chamada de função.</h3>
<section id="regras-de-tipagem-para-declaração-de-variável-e-chamada-de-função" class="level4" data-number="10.9.4.1">
<h4 data-number="10.9.4.1" class="anchored" data-anchor-id="regras-de-tipagem-para-declaração-de-variável-e-chamada-de-função"><span class="header-section-number">10.9.4.1</span> Regras de Tipagem para Declaração de Variável e Chamada de Função</h4>
<section id="axiomas-da-linguagem" class="level5" data-number="10.9.4.1.1">
<h5 data-number="10.9.4.1.1" class="anchored" data-anchor-id="axiomas-da-linguagem"><span class="header-section-number">10.9.4.1.1</span> 1. Axiomas da Linguagem</h5>
<p>Axiomas são regras de tipagem sem premissas - definem os tipos dos valores primitivos da linguagem.</p>
<section id="axioma-para-literais-inteiros" class="level6" data-number="10.9.4.1.1.1">
<h6 data-number="10.9.4.1.1.1" class="anchored" data-anchor-id="axioma-para-literais-inteiros"><span class="header-section-number">10.9.4.1.1.1</span> Axioma para literais inteiros:</h6>
<p><span class="math display">\[\frac{}{O, M, C \vdash n : \text{Int}}\]</span></p>
<p>onde <span class="math inline">\(n \in \mathbb{Z}\)</span> (qualquer número inteiro)</p>
<p><strong>Exemplo</strong>: <code>42 : Int</code>, <code>-7 : Int</code>, <code>0 : Int</code></p>
</section>
<section id="axioma-para-literais-reais" class="level6" data-number="10.9.4.1.1.2">
<h6 data-number="10.9.4.1.1.2" class="anchored" data-anchor-id="axioma-para-literais-reais"><span class="header-section-number">10.9.4.1.1.2</span> Axioma para literais reais:</h6>
<p><span class="math display">\[\frac{}{O, M, C \vdash r : \text{Real}}\]</span></p>
<p>onde <span class="math inline">\(r \in \mathbb{R}\)</span> (qualquer número real)</p>
<p><strong>Exemplo</strong>: <code>3.14 : Real</code>, <code>-0.5 : Real</code>, <code>2.0 : Real</code></p>
</section>
<section id="axioma-para-literais-de-string" class="level6" data-number="10.9.4.1.1.3">
<h6 data-number="10.9.4.1.1.3" class="anchored" data-anchor-id="axioma-para-literais-de-string"><span class="header-section-number">10.9.4.1.1.3</span> Axioma para literais de string:</h6>
<p><span class="math display">\[\frac{}{O, M, C \vdash s : \text{String}}\]</span></p>
<p>onde <span class="math inline">\(s\)</span> é uma sequência de caracteres entre aspas</p>
<p><strong>Exemplo</strong>: <code>"hello" : String</code>, <code>"" : String</code>, <code>"123" : String</code></p>
</section>
</section>
<section id="axioma-para-variáveis-no-ambiente" class="level5" data-number="10.9.4.1.2">
<h5 data-number="10.9.4.1.2" class="anchored" data-anchor-id="axioma-para-variáveis-no-ambiente"><span class="header-section-number">10.9.4.1.2</span> Axioma para variáveis no ambiente:</h5>
<p><span class="math display">\[\frac{C(x) = T}{O, M, C \vdash x : T}\]</span></p>
<p>Se a variável <span class="math inline">\(x\)</span> está no ambiente <span class="math inline">\(C\)</span> com tipo <span class="math inline">\(T\)</span>, então <span class="math inline">\(x\)</span> tem tipo <span class="math inline">\(T\)</span>.</p>
</section>
</section>
<section id="regras-de-tipagem-para-operações-aritméticas" class="level4" data-number="10.9.4.2">
<h4 data-number="10.9.4.2" class="anchored" data-anchor-id="regras-de-tipagem-para-operações-aritméticas"><span class="header-section-number">10.9.4.2</span> 2. Regras de Tipagem para Operações Aritméticas</h4>
<section id="adição-de-inteiros" class="level5" data-number="10.9.4.2.1">
<h5 data-number="10.9.4.2.1" class="anchored" data-anchor-id="adição-de-inteiros"><span class="header-section-number">10.9.4.2.1</span> Adição de inteiros:</h5>
<p><span class="math display">\[\frac{O, M, C \vdash e_1 : \text{Int} \quad O, M, C \vdash e_2 : \text{Int}}{O, M, C \vdash e_1 + e_2 : \text{Int}}\]</span></p>
</section>
<section id="adição-de-reais" class="level5" data-number="10.9.4.2.2">
<h5 data-number="10.9.4.2.2" class="anchored" data-anchor-id="adição-de-reais"><span class="header-section-number">10.9.4.2.2</span> Adição de reais:</h5>
<p><span class="math display">\[\frac{O, M, C \vdash e_1 : \text{Real} \quad O, M, C \vdash e_2 : \text{Real}}{O, M, C \vdash e_1 + e_2 : \text{Real}}\]</span></p>
</section>
<section id="adição-mista-coerção-de-int-para-real" class="level5" data-number="10.9.4.2.3">
<h5 data-number="10.9.4.2.3" class="anchored" data-anchor-id="adição-mista-coerção-de-int-para-real"><span class="header-section-number">10.9.4.2.3</span> Adição mista (coerção de Int para Real):</h5>
<p><span class="math display">\[\frac{O, M, C \vdash e_1 : \text{Int} \quad O, M, C \vdash e_2 : \text{Real}}{O, M, C \vdash e_1 + e_2 : \text{Real}}\]</span></p>
<p><span class="math display">\[\frac{O, M, C \vdash e_1 : \text{Real} \quad O, M, C \vdash e_2 : \text{Int}}{O, M, C \vdash e_1 + e_2 : \text{Real}}\]</span></p>
<p><strong>Nota</strong>: As mesmas regras aplicam-se para subtração, multiplicação e divisão.</p>
</section>
<section id="concatenação-de-strings" class="level5" data-number="10.9.4.2.4">
<h5 data-number="10.9.4.2.4" class="anchored" data-anchor-id="concatenação-de-strings"><span class="header-section-number">10.9.4.2.4</span> Concatenação de strings:</h5>
<p><span class="math display">\[\frac{O, M, C \vdash e_1 : \text{String} \quad O, M, C \vdash e_2 : \text{String}}{O, M, C \vdash e_1 \oplus e_2 : \text{String}}\]</span></p>
<p>onde <span class="math inline">\(\oplus\)</span> representa o operador de concatenação.</p>
</section>
</section>
<section id="regra-de-tipagem-para-declaração-de-variável" class="level4" data-number="10.9.4.3">
<h4 data-number="10.9.4.3" class="anchored" data-anchor-id="regra-de-tipagem-para-declaração-de-variável"><span class="header-section-number">10.9.4.3</span> 3. Regra de Tipagem para Declaração de Variável</h4>
<p>A declaração de uma variável envolve associar um nome a um tipo e, opcionalmente, a uma expressão de inicialização.</p>
<section id="forma-geral-da-declaração" class="level5" data-number="10.9.4.3.1">
<h5 data-number="10.9.4.3.1" class="anchored" data-anchor-id="forma-geral-da-declaração"><span class="header-section-number">10.9.4.3.1</span> Forma geral da declaração:</h5>
<p><code>x : T &lt;- e</code></p>
<p>onde <code>x</code> é o nome da variável, <code>T</code> é o tipo declarado e <code>e</code> é a expressão de inicialização.</p>
</section>
<section id="regra-de-tipagem" class="level5" data-number="10.9.4.3.2">
<h5 data-number="10.9.4.3.2" class="anchored" data-anchor-id="regra-de-tipagem"><span class="header-section-number">10.9.4.3.2</span> Regra de tipagem:</h5>
<p><span class="math display">\[\frac{O, M, C \vdash e : T' \quad T' \leq T \quad O, M, C[x \mapsto T] \vdash e_{corpo} : T_{corpo}}{O, M, C \vdash (x : T \leftarrow e; e_{corpo}) : T_{corpo}}\]</span></p>
<p><strong>Leitura da regra</strong>:</p>
<ul>
<li>A expressão de inicialização <span class="math inline">\(e\)</span> deve ter tipo <span class="math inline">\(T'\)</span>;</li>
<li>O tipo <span class="math inline">\(T'\)</span> deve ser um subtipo de <span class="math inline">\(T\)</span> (ou igual a <span class="math inline">\(T\)</span>);</li>
<li>No contexto estendido onde <span class="math inline">\(x\)</span> tem tipo <span class="math inline">\(T\)</span>, o corpo subsequente <span class="math inline">\(e_{corpo}\)</span> tem tipo <span class="math inline">\(T_{corpo}\)</span>;</li>
<li>Então toda a construção tem tipo <span class="math inline">\(T_{corpo}\)</span>.</li>
</ul>
<p><strong>Variante simplificada</strong> (apenas declaração sem corpo subsequente):</p>
<p><span class="math display">\[\frac{O, M, C \vdash e : T' \quad T' \leq T}{O, M, C \vdash (x : T \leftarrow e) : T}\]</span></p>
<p><strong>Exemplo</strong>:</p>
<pre class="shell"><code>x : Int &lt;- 5 + 3</code></pre>
<p>Neste caso, <code>5 + 3</code> tem tipo <code>Int</code>, que é compatível com o tipo declarado <code>Int</code>.</p>
<p><strong>Outro exemplo com coerção</strong>:</p>
<pre class="shell"><code>y : Real &lt;- 10</code></pre>
<p>Aqui, <code>10</code> tem tipo <code>Int</code>, mas <code>Int</code> <span class="math inline">\(\leq\)</span> <code>Real</code>, então a declaração é válida.</p>
</section>
</section>
<section id="regra-de-tipagem-para-chamada-de-função" class="level4" data-number="10.9.4.4">
<h4 data-number="10.9.4.4" class="anchored" data-anchor-id="regra-de-tipagem-para-chamada-de-função"><span class="header-section-number">10.9.4.4</span> 4. Regra de Tipagem para Chamada de Função</h4>
<p>A chamada de uma função envolve verificar que os argumentos passados são compatíveis com os parâmetros esperados.</p>
<section id="forma-geral-da-chamada" class="level5" data-number="10.9.4.4.1">
<h5 data-number="10.9.4.4.1" class="anchored" data-anchor-id="forma-geral-da-chamada"><span class="header-section-number">10.9.4.4.1</span> Forma geral da chamada:</h5>
<p><code>f(e₁, e₂, ..., eₙ)</code></p>
<p>onde <code>f</code> é o nome da função e <span class="math inline">\(e_1, e_2, \ldots, e_n\)</span> são os argumentos.</p>
</section>
<section id="regra-de-tipagem-1" class="level5" data-number="10.9.4.4.2">
<h5 data-number="10.9.4.4.2" class="anchored" data-anchor-id="regra-de-tipagem-1"><span class="header-section-number">10.9.4.4.2</span> Regra de tipagem:</h5>
<p><span class="math display">\[\frac{M(f) = (T_1, T_2, \ldots, T_n) \rightarrow T_{ret} \quad O, M, C \vdash e_1 : T_1' \quad T_1' \leq T_1 \quad \ldots \quad O, M, C \vdash e_n : T_n' \quad T_n' \leq T_n}{O, M, C \vdash f(e_1, e_2, \ldots, e_n) : T_{ret}}\]</span></p>
<p><strong>Leitura da regra</strong>:</p>
<ul>
<li>A função <span class="math inline">\(f\)</span> deve estar definida no ambiente de métodos <span class="math inline">\(M\)</span> com assinatura <span class="math inline">\((T_1, T_2, \ldots, T_n) \rightarrow T_{ret}\)</span>;</li>
<li>Cada argumento <span class="math inline">\(e_i\)</span> deve ter tipo <span class="math inline">\(T_i'\)</span>;</li>
<li>Cada tipo de argumento <span class="math inline">\(T_i'\)</span> deve ser subtipo (ou igual) ao tipo de parâmetro esperado <span class="math inline">\(T_i\)</span>;</li>
<li>Se todas as premissas são satisfeitas, a chamada tem tipo <span class="math inline">\(T_{ret}\)</span> (tipo de retorno da função).</li>
</ul>
<p><strong>Exemplo 1</strong>: suponha que temos a função:</p>
<pre class="shell"><code>def soma(a : Int, b : Int) : Int { a + b }</code></pre>
<p>Para a chamada <code>soma(5, 10)</code>: - Verificamos que <code>5</code> tem tipo <code>Int</code> e <code>Int</code> <span class="math inline">\(\leq\)</span> <code>Int</code> - Verificamos que <code>10</code> tem tipo <code>Int</code> e <code>Int</code> <span class="math inline">\(\leq\)</span> <code>Int</code> - Portanto, <code>soma(5, 10)</code> tem tipo <code>Int</code></p>
<p><strong>Exemplo 2 (com coerção)</strong>: suponha a função:</p>
<pre class="shell"><code>def media(a : Real, b : Real) : Real { (a + b) / 2.0 }</code></pre>
<p>Para a chamada <code>media(5, 3.5)</code>:</p>
<ul>
<li>Verificamos que <code>5</code> tem tipo <code>Int</code> e <code>Int</code> <span class="math inline">\(\leq\)</span> <code>Real</code>;</li>
<li>Verificamos que <code>3.5</code> tem tipo <code>Real</code> e <code>Real</code> <span class="math inline">\(\leq\)</span> <code>Real</code>;</li>
<li>Portanto, <code>media(5, 3.5)</code> tem tipo <code>Real</code>.</li>
</ul>
</section>
</section>
<section id="hierarquia-de-tipos" class="level4" data-number="10.9.4.5">
<h4 data-number="10.9.4.5" class="anchored" data-anchor-id="hierarquia-de-tipos"><span class="header-section-number">10.9.4.5</span> 4. Hierarquia de Tipos</h4>
<p>Para que a relação de subtipagem <span class="math inline">\(\leq\)</span> funcione, definimos:</p>
<p><span class="math display">\[\text{Int} \leq \text{Real}\]</span></p>
<p>Isso permite que inteiros sejam usados onde reais são esperados (coerção implícita).</p>
<p>Reflexividade e transitividade também são válidas:</p>
<ul>
<li><span class="math inline">\(T \leq T\)</span> para qualquer tipo <span class="math inline">\(T\)</span>;</li>
<li>Se <span class="math inline">\(T_1 \leq T_2\)</span> e <span class="math inline">\(T_2 \leq T_3\)</span>, então <span class="math inline">\(T_1 \leq T_3\)</span>.</li>
</ul>
</section>
<section id="o-motor-da-inferência-algoritmo-de-hindley-milner" class="level4" data-number="10.9.4.6">
<h4 data-number="10.9.4.6" class="anchored" data-anchor-id="o-motor-da-inferência-algoritmo-de-hindley-milner"><span class="header-section-number">10.9.4.6</span> O Motor da Inferência: Algoritmo de Hindley-Milner</h4>
<p>As regras acima são ótimas para verificar tipos que já estão anotados. Mas, o que acontece em linguagens como <strong>ML</strong> ou <strong>Haskell</strong>, nas quais podemos escrever declarações como <code>let f x = x + 1</code> e o compilador descobre sozinho que <code>f</code> tem o tipo <code>int -&gt; int</code>? Isso é <strong>inferência de tipos</strong>, e o motor por trás dessa arte é, em grande parte, movido pelo <strong>algoritmo W</strong>, desenvolvido por <a href="https://en.wikipedia.org/wiki/Robin_Milner">Robin Milner</a>.</p>
<p>O <strong>algoritmo W</strong> automatiza o processo de encontrar os tipos, mesmo quando eles não são declarados. Sua ideia central é usar <strong>variáveis de tipo</strong>, símbolos como <span class="math inline">\(\alpha, \beta, \gamma\)</span> que funcionam como <em>placeholders</em> para tipos desconhecidos e um processo chamado <strong>unificação</strong>. Unificação é, em essência, um algoritmo para resolver equações entre tipos.</p>
<p>Quando o <strong>algoritmo W</strong> analisa uma expressão, ele gera um conjunto de equações de tipo. Por exemplo, para <code>f x = x + 1</code>, ele diria:</p>
<ol type="1">
<li><code>x</code> deve ter um tipo <span class="math inline">\(\alpha\)</span>.</li>
<li><code>1</code> tem o tipo <code>int</code>.</li>
<li>O operador <code>+</code> tem o tipo <code>(int, int) -&gt; int</code>.</li>
<li>Portanto, <code>x</code> (que é <span class="math inline">\(\alpha\)</span>) deve ser compatível com <code>int</code>. <strong>Equação: <span class="math inline">\(\alpha = \text{int}\)</span></strong>.</li>
<li>O resultado de <code>x + 1</code> é <code>int</code>.</li>
<li>A função <code>f</code> recebe <code>x</code> (cujo tipo é <span class="math inline">\(\alpha\)</span>) e retorna o resultado de <code>x + 1</code> (cujo tipo é <code>int</code>).</li>
<li>Portanto, o tipo de <code>f</code> é <span class="math inline">\(\alpha \rightarrow \text{int}\)</span>.</li>
<li>Resolvendo a equação do passo 4, substituímos <span class="math inline">\(\alpha\)</span> por <code>int</code>, e o algoritmo conclui que o tipo de <code>f</code> é <span class="math inline">\(\text{int} \rightarrow \text{int}\)</span>.</li>
</ol>
<p>O pseudocódigo do algoritmo formaliza exatamente esse processo de geração e resolução de restrições de tipo:</p>
<pre class="pseudocódigo"><code>algoritmo W(Γ, e):
  caso e de:
    // Variável: simplesmente a procuramos no ambiente.
    x → 
      se x : σ ∈ Γ então
        retornar (instanciar(σ), ∅)
      senão
        erro "variável não ligada"
    
    // Função: criamos uma nova variável de tipo α para o argumento,
    // e descobrimos o tipo do corpo nesse novo contexto.
    λx.e₁ →
      α ← nova_variavel_tipo()
      (τ₁, S₁) ← W(Γ ∪ {x : α}, e₁)
      retornar (S₁(α) → τ₁, S₁)
    
    // Aplicação: o passo mais complexo. Descobrimos os tipos da
    // função (e₁) e do argumento (e₂), e então unificamos.
    e₁ e₂ →
      (τ₁, S₁) ← W(Γ, e₁)
      (τ₂, S₂) ← W(S₁(Γ), e₂)
      α ← nova_variavel_tipo()
      // A equação a ser resolvida: τ₁ deve ser igual a τ₂ → α
      S₃ ← unificar(S₂(τ₁), τ₂ → α)
      // O resultado final é o tipo de α, após aplicar todas as
      // substituições (soluções) encontradas.
      retornar (S₃(α), S₃ ∘ S₂ ∘ S₁)</code></pre>
<p>No pseudocódigo, as variáveis <span class="math inline">\(S\)</span> representam as <strong>substituições</strong>, as soluções parciais para as equações de tipo, que são compostas ao longo do processo.</p>
<p>O <strong>Algoritmo W</strong> é poderoso e tem histórico de uso em linguagens funcionais descendentes do <strong>ML</strong>. O sistema de tipos do <strong>Haskell</strong> evoluiu para incluir extensões mais avançadas, como classes de tipos, a sua base para a inferência de tipos ainda é o <strong>Algoritmo W</strong>. Isso permite que o compilador do <strong>Haskell</strong>, o <strong>G</strong>lasgow <strong>H</strong>askell <strong>C</strong>ompiler, <strong>GHC</strong>, infira os tipos da maioria das funções e expressões de forma automática. Fora do domínio das linguagens funcionais, o <strong>Algoritmo W</strong> também influenciou sistemas de tipos em linguagens como <strong>TypeScript</strong>, que trazem a inferência de tipos para o mundo da programação orientada a objetos e funcional. Finalmente, precisamos destacar a linguagem <strong>Rust</strong>, conhecida por seu foco em segurança de memória e concorrência, que possui um sistema de inferência de tipos. Embora seja baseado no sistema <strong>Hindley-Milner</strong>, ele é significativamente estendido para lidar com o sistema de <em>lifetimes</em> e <em>traits</em> característicos da linguagem. Portanto, a curiosa leitora não pode dizer que o <strong>Rust</strong> utiliza uma implementação pura do <strong>Algoritmo W</strong>, mas sim um sistema que evoluiu a partir de suas fundações.</p>
<p>Finalmente, na <a href="10c-semantico.html" class="quarto-xref"><span>Chapter 13</span></a> discutimos o sistema de tipos <strong>Hindley-Milner</strong> e o <strong>Algoritmo W</strong> em mais detalhes.</p>
</section>
</section>
<section id="complexidade-da-verificação-e-inferência-de-tipos" class="level3" data-number="10.9.5">
<h3 data-number="10.9.5" class="anchored" data-anchor-id="complexidade-da-verificação-e-inferência-de-tipos"><span class="header-section-number">10.9.5</span> Complexidade da Verificação e Inferência de Tipos</h3>
<p>A complexidade para garantir a segurança de tipos varia drasticamente com o poder do sistema de tipos:</p>
<ul>
<li><strong>Tipagem Monomórfica Simples</strong>: em linguagens como <strong>Pascal</strong> ou <strong>C</strong>, a verificação de tipos é muito eficiente. Ela pode ser feita em tempo linear, <span class="math inline">\(O(n)\)</span>, correspondendo a uma única travessia na <strong>AST</strong>.</li>
<li><strong>Inferência de Hindley-Milner</strong>: o <strong>algoritmo W</strong>, apesar de sua expressividade, ainda é considerado eficiente. Em teoria, seu pior caso é exponencial, mas com otimizações na estrutura de dados de unificação, ele se comporta de forma quase linear na prática. Porém, a atenta leitora deve observar que a observação empírica não muda a complexidade exponencial deste algoritmo, <span class="math inline">\(O(n^3)\)</span>.</li>
<li><strong>Sistemas Mais Complexos</strong>: à medida que adicionamos funcionalidades ao sistema de tipos, a complexidade pode explodir. A inferência de tipos na presença de <strong>subtipos</strong> (comuns em programação orientada a objetos) torna o problema <strong>PSPACE-completo</strong>, como provado por <a href="https://www.cis.upenn.edu/~bcpierce/">Benjamin Pierce</a>. Se adicionarmos características ainda mais poderosas, como as <strong>type classes</strong> do <strong>Haskell</strong> em sua forma mais geral, o problema da inferência de tipos se torna <strong>indecidível</strong> — ou seja, não existe um algoritmo que possa resolver todos os casos. Isso demonstra um dos balanços mais fundamentais no design de linguagens: a troca entre o poder de expressividade do sistema de tipos e a capacidade do compilador de verificá-lo e inferi-lo de forma automática e eficiente.</li>
</ul>
</section>
</section>
<section id="implementação-prática-da-teoria-à-prática" class="level2" data-number="10.10">
<h2 data-number="10.10" class="anchored" data-anchor-id="implementação-prática-da-teoria-à-prática"><span class="header-section-number">10.10</span> Implementação Prática: Da Teoria à Prática</h2>
<p>Até este ponto, discutimos os fundamentos teóricos da análise semântica e das gramáticas de atributos. Um diagrama em blocos da estrutura do analisador semântico pode ser visto na Figura <a href="#fig-analisSemantico1" class="quarto-xref">Figure&nbsp;<span>10.10</span></a>.</p>
<div id="fig-analisSemantico1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-analisSemantico1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/analisSemantico.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-analisSemantico1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.10
</figcaption>
</figure>
</div>
<p>Agora, a persistente leitora deverá aplicar esses conceitos construindo um analisador semântico completo para uma mini-linguagem de expressões aritméticas. Se acompanhar detalhada e cuidadosamente este exercício demonstrará como a teoria se traduz em código executável, consolidando o entendimento através da prática. Porém, esta é uma implementação simplificada, destinada a ilustrar os conceitos principais. Sendo assim, existem alguns pontos importantes que a leitora deve observar:</p>
<p><strong>Separação de Responsabilidades</strong>: o analisador semântico é completamente independente do parser. Ele recebe uma <strong>AST</strong> como entrada e a anota com informações semânticas. Esta modularidade é essencial em compiladores reais. Uma opção a favor da didática.</p>
<p><strong>Recuperação de Erros</strong>: o analisador que criaremos não irá interromper a execução no primeiro erro; ele continuará analisando e acumulará todos os erros encontrados. Isso fornece o objetivo é fornecer informações mais completas ao programador.</p>
<p><strong>Decoração da AST</strong>: os vértices da <strong>AST</strong> serão anotados com tipos inferidos (<code>tipo_inferido</code>). Esta <strong>AST</strong> decorada poderia ser passada para a fase de geração de código intermediário, que usaria essas informações para gerar instruções apropriadas.</p>
<p><strong>Limitações</strong>: por simplicidade, nossa implementação não cobre aspectos importantes como:</p>
<ul>
<li>Análise de fluxo de dados (variáveis não inicializadas, código morto);</li>
<li>Otimizações baseadas em tipos (<em>constant folding</em>);</li>
<li>Mensagens de erro com informações de localização;</li>
<li>Suporte a estruturas de dados compostas (<code>arrays</code>, <code>structs</code>).</li>
</ul>
<section id="definição-da-mini-linguagem-langarit" class="level3" data-number="10.10.1">
<h3 data-number="10.10.1" class="anchored" data-anchor-id="definição-da-mini-linguagem-langarit"><span class="header-section-number">10.10.1</span> Definição da Mini-Linguagem: Langarit</h3>
<p>Iniciaremos definindo uma linguagem simples, mas suficientemente rica para demonstrar os principais conceitos da análise semântica. Nossa linguagem, <strong>Langarit</strong>, suportará:</p>
<ul>
<li>Declarações de variáveis com tipos <code>int</code> e <code>float</code>;</li>
<li>Expressões aritméticas com operadores <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>;</li>
<li>Atribuições de valores a variáveis;</li>
<li>Literais numéricos inteiros e de ponto flutuante.</li>
</ul>
<p><strong>Exemplos de programas válidos em Langarit</strong>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> y<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> x <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> y <span class="op">*</span> <span class="fl">2.0</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Exemplos de programas com erros semânticos</strong>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>     # ERRO<span class="op">:</span> x não foi declarado</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span>    # ERRO<span class="op">:</span> tentativa de atribuir <span class="dt">float</span> a <span class="dt">int</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> x <span class="op">/</span> <span class="dv">0</span><span class="op">;</span>    # ERRO<span class="op">:</span> divisão por zero <span class="op">(</span>semântica dinâmica<span class="op">,</span> mas detectável em literais<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="gramática-livre-de-contexto-para-langarit" class="level3" data-number="10.10.2">
<h3 data-number="10.10.2" class="anchored" data-anchor-id="gramática-livre-de-contexto-para-langarit"><span class="header-section-number">10.10.2</span> Gramática Livre de Contexto para Langarit</h3>
<p>Nossa linguagem precisa de uma sintaxe de Langarit, vamos criar uma gramática livre de contexto para Langarit. Lembre-se, esta gramática descreve apenas a forma dos programas válidos, sem considerar o significado.</p>
<p><span class="math display">\[
\begin{align*}
\text{Programa} &amp; \rightarrow \text{Declaracoes} \quad \text{Comandos} \\
\text{Declaracoes} &amp; \rightarrow \text{Declaracao} \quad \text{Declaracoes} \mid \epsilon \\
\text{Declaracao} &amp; \rightarrow \text{Tipo} \quad \textbf{id} \; \textbf{;} \\
\text{Tipo} &amp; \rightarrow \textbf{int} \mid \textbf{float} \\
\text{Comandos} &amp; \rightarrow \text{Comando} \quad \text{Comandos} \mid \epsilon \\
\text{Comando} &amp; \rightarrow \textbf{id} \; \textbf{=} \; \text{Expr} \; \textbf{;} \\
\text{Expr} &amp; \rightarrow \text{Expr} \; \textbf{+} \; \text{Term} \mid \text{Expr} \; \textbf{-} \; \text{Term} \mid \text{Term} \\
\text{Term} &amp; \rightarrow \text{Term} \; \textbf{*} \; \text{Factor} \mid \text{Term} \; \textbf{/} \; \text{Factor} \mid \text{Factor} \\
\text{Factor} &amp; \rightarrow \textbf{(} \; \text{Expr} \; \textbf{)} \mid \textbf{id} \mid \textbf{num\_int} \mid \textbf{num\_float}
\end{align*}
\]</span></p>
<p>Observe como a estrutura desta gramática, cuja hierarquia pode ser vista na Figura <a href="#fig-langarit1" class="quarto-xref">Figure&nbsp;<span>10.11</span></a>, já impõe regras de precedência e associatividade. Ao separar Expr (adição/subtração), Term (multiplicação/divisão) e Factor (literais, variáveis), garantimos que as operações em Term sejam avaliadas antes das de Expr. A recursão à esquerda nas regras (Expr -&gt; Expr + Term) define a associatividade da esquerda para a direita para os operadores.</p>
<div id="fig-langarit1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-langarit1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/ast-langarit1.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-langarit1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.11
</figcaption>
</figure>
</div>
</section>
<section id="gramática-de-atributos-para-langarit" class="level3" data-number="10.10.3">
<h3 data-number="10.10.3" class="anchored" data-anchor-id="gramática-de-atributos-para-langarit"><span class="header-section-number">10.10.3</span> Gramática de Atributos para Langarit</h3>
<p>Uma vez que temos uma gramática livre de contexto, estenderemos a gramática sintática com atributos e regras semânticas. Neste momento, nossos objetivos são:</p>
<ol type="1">
<li><strong>Verificar declarações</strong>: toda variável usada foi previamente declarada;</li>
<li><strong>Verificar tipos</strong>: operações são realizadas entre tipos compatíveis;</li>
<li><strong>Inferir tipos</strong>: determinar o tipo resultante de cada expressão;</li>
<li><strong>Anotar a AST</strong>: decorar a árvore com informações de tipo.</li>
</ol>
<p>Com estes objetivos em mente, definimos os atributos e as regras semânticas. Começando com os atributos. Nossa estratégia de análise semântica seguirá dois fluxos principais de informação:</p>
<p>Um <strong>fluxo contextual</strong>, semelhante ao herdado: as declarações de variáveis irão popular a <strong>Tabela de Símbolos</strong>. Esta tabela funcionará como nosso contexto, sendo consultada posteriormente quando uma variável for usada em uma expressão ou atribuição.</p>
<p>Um <strong>fluxo sintetizado</strong>, <em>bottom-up</em>: para as expressões, o tipo será sintetizado a partir das folhas da árvore. Começaremos com os tipos dos números e variáveis e, subindo pela <strong>AST</strong>, usaremos a função <code>promover_tipo</code> para calcular o tipo resultante de cada subexpressão até chegarmos à raiz da expressão. Assim, teremos:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Símbolo</th>
<th style="text-align: left;">Atributos Sintetizados</th>
<th style="text-align: left;">Atributos Herdados</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Tipo</code></td>
<td style="text-align: left;"><code>tipo</code> (string: “int” ou “float”)</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Expr</code></td>
<td style="text-align: left;"><code>tipo</code> (string)</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Term</code></td>
<td style="text-align: left;"><code>tipo</code> (string)</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Factor</code></td>
<td style="text-align: left;"><code>tipo</code> (string)</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id</code></td>
<td style="text-align: left;"><code>lexema</code> (string), <code>tipo</code> (string)</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>num_int</code></td>
<td style="text-align: left;"><code>valor</code> (int), <code>tipo</code> = “int”</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>num_float</code></td>
<td style="text-align: left;"><code>valor</code> (float), <code>tipo</code> = “float”</td>
<td style="text-align: left;">-</td>
</tr>
</tbody>
</table>
<p>Podemos definir as regras semânticas associadas a cada produção da gramática:</p>
<p><strong>Para Declarações</strong>:</p>
<table class="table">
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Produção</th>
<th style="text-align: left;">Regras Semânticas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Declaracao} \rightarrow \text{Tipo} \; \textbf{id} \; \textbf{;}\)</span></td>
<td style="text-align: left;"><code>tabela_simbolos.adicionar(id.lexema, Tipo.tipo)</code> <br> Se <code>id.lexema</code> já existe: <strong>ERRO</strong></td>
</tr>
</tbody>
</table>
<p><strong>Para Expressões Aritméticas</strong>:</p>
<table class="table">
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Produção</th>
<th style="text-align: left;">Regras Semânticas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \text{Expr}_1 \; \textbf{+} \; \text{Term}\)</span></td>
<td style="text-align: left;"><code>Expr.tipo = promover_tipo(Expr1.tipo, Term.tipo)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \text{Expr}_1 \; \textbf{-} \; \text{Term}\)</span></td>
<td style="text-align: left;"><code>Expr.tipo = promover_tipo(Expr1.tipo, Term.tipo)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Expr} \rightarrow \text{Term}\)</span></td>
<td style="text-align: left;"><code>Expr.tipo = Term.tipo</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Term} \rightarrow \text{Term}_1 \; \textbf{*} \; \text{Factor}\)</span></td>
<td style="text-align: left;"><code>Term.tipo = promover_tipo(Term1.tipo, Factor.tipo)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Term} \rightarrow \text{Term}_1 \; \textbf{/} \; \text{Factor}\)</span></td>
<td style="text-align: left;"><code>Term.tipo = promover_tipo(Term1.tipo, Factor.tipo)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Term} \rightarrow \text{Factor}\)</span></td>
<td style="text-align: left;"><code>Term.tipo = Factor.tipo</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Factor} \rightarrow \textbf{(} \; \text{Expr} \; \textbf{)}\)</span></td>
<td style="text-align: left;"><code>Factor.tipo = Expr.tipo</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Factor} \rightarrow \textbf{id}\)</span></td>
<td style="text-align: left;"><code>Factor.tipo = tabela_simbolos.consultar(id.lexema)</code> <br> Se não encontrado: <strong>ERRO</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Factor} \rightarrow \textbf{num\_int}\)</span></td>
<td style="text-align: left;"><code>Factor.tipo = "int"</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\text{Factor} \rightarrow \textbf{num\_float}\)</span></td>
<td style="text-align: left;"><code>Factor.tipo = "float"</code></td>
</tr>
</tbody>
</table>
<p><strong>Para Atribuições</strong>:</p>
<table class="table">
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Produção</th>
<th style="text-align: left;">Regras Semânticas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\text{Comando} \rightarrow \textbf{id} \; \textbf{=} \; \text{Expr} \; \textbf{;}\)</span></td>
<td style="text-align: left;"><code>tipo_var = tabela_simbolos.consultar(id.lexema)</code> <br> Se não encontrado: <strong>ERRO</strong> <br> Se <code>tipo_var == "int"</code> e <code>Expr.tipo == "float"</code>: <strong>ERRO</strong> (perda de precisão) <br> Se <code>tipo_var == "float"</code> e <code>Expr.tipo == "int"</code>: <strong>OK</strong> (promoção implícita)</td>
</tr>
</tbody>
</table>
<p><strong>Função de Promoção de Tipos</strong>:</p>
<p>A função <code>promover_tipo(tipo1, tipo2)</code> implementa as regras de coerção:</p>
<ul>
<li><code>promover_tipo("int", "int")</code> retorna <code>"int"</code></li>
<li><code>promover_tipo("float", "float")</code> retorna <code>"float"</code></li>
<li><code>promover_tipo("int", "float")</code> retorna <code>"float"</code></li>
<li><code>promover_tipo("float", "int")</code> retorna <code>"float"</code></li>
</ul>
</section>
<section id="implementação-empython" class="level3" data-number="10.10.4">
<h3 data-number="10.10.4" class="anchored" data-anchor-id="implementação-empython"><span class="header-section-number">10.10.4</span> Implementação em<strong>Python</strong></h3>
<p>Implementaremos o analisador semântico como um percurso da <strong>AST</strong> gerada por um <em>parser</em>. Por simplicidade, assumiremos que já temos a <strong>AST</strong> construída. Contudo, antes de escrever o analisador, precisamos de uma forma de representar a <strong>Árvore Sintática Abstrata</strong> em<strong>Python</strong>. Usaremos <code>dataclasses</code> para criar uma hierarquia de classes simples e legível, em que cada classe corresponde a um conceito da nossa gramática, um programa, uma declaração, uma expressão binária, etc..</p>
<section id="estrutura-dos-vértices-da-ast" class="level4" data-number="10.10.4.1">
<h4 data-number="10.10.4.1" class="anchored" data-anchor-id="estrutura-dos-vértices-da-ast"><span class="header-section-number">10.10.4.1</span> Estrutura dos vértices da AST</h4>
<div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Optional, List, Union</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NoAST:</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Classe base para todos os vértices da AST"""</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">pass</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Programa(NoAST):</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>  declaracoes: List[<span class="st">'Declaracao'</span>]</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>  comandos: List[<span class="st">'Comando'</span>]</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Declaracao(NoAST):</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>  tipo: <span class="bu">str</span> <span class="co"># "int" ou "float"</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>  nome: <span class="bu">str</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Comando(NoAST):</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">pass</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Atribuicao(Comando):</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>  variavel: <span class="bu">str</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>  expressao: <span class="st">'Expressao'</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Expressao(NoAST):</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>  tipo_inferido: Optional[<span class="bu">str</span>] <span class="op">=</span> <span class="va">None</span> <span class="co"># Preenchido pelo analisador semântico</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ExpressaoBinaria(Expressao):</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>  esquerda: Expressao</span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>  operador: <span class="bu">str</span> <span class="co"># "+", "-", "*", "/"</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>  direita: Expressao</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Variavel(Expressao):</span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>  nome: <span class="bu">str</span></span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LiteralInt(Expressao):</span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>  valor: <span class="bu">int</span></span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a>  tipo_inferido: <span class="bu">str</span> <span class="op">=</span> <span class="st">"int"</span></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LiteralFloat(Expressao):</span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a>  valor: <span class="bu">float</span></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>  tipo_inferido: <span class="bu">str</span> <span class="op">=</span> <span class="st">"float"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="tabela-de-símbolos" class="level4" data-number="10.10.4.2">
<h4 data-number="10.10.4.2" class="anchored" data-anchor-id="tabela-de-símbolos"><span class="header-section-number">10.10.4.2</span> <strong>Tabela de Símbolos</strong></h4>
<p>A <strong>Tabela de Símbolos</strong> (<a href="11-tabelaSimbolos.html" class="quarto-xref"><span>Chapter 14</span></a>) é a estrutura de dados que servirá como a memória do nosso analisador. É ela que armazena o contexto necessário para as verificações semânticas, associando o nome de cada variável ao seu tipo (<code>int</code> ou <code>float</code>). Nossa implementação usará uma pilha de dicionários para gerenciar escopos, embora neste exemplo inicial utilizemos apenas o escopo global.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TabelaSimbolos:</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">  **Tabela de Símbolos** para armazenar informações de variáveis.</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co">  Suporta escopos aninhados através de uma pilha de dicionários.</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.escopos <span class="op">=</span> [{}] <span class="co"># Lista de dicionários; escopo global no índice 0</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> adicionar(<span class="va">self</span>, nome: <span class="bu">str</span>, tipo: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Adiciona uma variável ao escopo atual.</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Lança exceção se a variável já foi declarada no escopo atual.</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    escopo_atual <span class="op">=</span> <span class="va">self</span>.escopos[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> nome <span class="kw">in</span> escopo_atual:</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="ss">f"Erro semântico: variável '</span><span class="sc">{</span>nome<span class="sc">}</span><span class="ss">' já declarada neste escopo"</span>)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    escopo_atual[nome] <span class="op">=</span> tipo</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> consultar(<span class="va">self</span>, nome: <span class="bu">str</span>) <span class="op">-&gt;</span> Optional[<span class="bu">str</span>]:</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="co">    Busca o tipo de uma variável percorrendo os escopos do mais interno ao mais externo.</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="co">    Retorna None se a variável não foi encontrada.</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> escopo <span class="kw">in</span> <span class="bu">reversed</span>(<span class="va">self</span>.escopos):</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> nome <span class="kw">in</span> escopo:</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> escopo[nome]</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> entrar_escopo(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Cria um novo escopo (para blocos aninhados)"""</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.escopos.append({})</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> sair_escopo(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Remove o escopo mais interno"""</span></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.escopos) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.escopos.pop()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="analisador-semântico" class="level4" data-number="10.10.4.3">
<h4 data-number="10.10.4.3" class="anchored" data-anchor-id="analisador-semântico"><span class="header-section-number">10.10.4.3</span> Analisador Semântico</h4>
<p>O coração da nossa implementação é a classe <code>AnalisadorSemantico</code>. Ela percorrerá a <strong>AST</strong> aplicando as regras que definimos. A estrutura do código seguirá o padrão de projeto <code>Visitor</code>, no qual criamos um método específico, <code>_analisar_...</code>, para cada tipo de vértice da árvore. Neste caso, usamos uma abordagem em duas passagens para simplificar a implementação:</p>
<p>Primeiro, percorreremos todas as <code>declaracoes</code> para popular a <strong>Tabela de Símbolos</strong>. Depois, em uma segunda passagem, analisaremos os <code>comandos</code>, usando a tabela já preenchida para realizar as verificações de tipo e uso.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AnalisadorSemantico:</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">  Analisador semântico que percorre a AST, verifica regras semânticas</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">  e anota os vértices com informações de tipo.</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.tabela <span class="op">=</span> TabelaSimbolos()</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.erros <span class="op">=</span> []</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> analisar(<span class="va">self</span>, programa: Programa) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Ponto de entrada principal. Analisa um programa completo.</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Retorna True se não houver erros semânticos.</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._analisar_programa(programa)</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.erros) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.erros.append(<span class="bu">str</span>(e))</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _analisar_programa(<span class="va">self</span>, programa: Programa) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Analisa declarações seguidas de comandos"""</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Primeira passagem: processar todas as declarações</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> decl <span class="kw">in</span> programa.declaracoes:</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._analisar_declaracao(decl)</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Segunda passagem: processar comandos</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> cmd <span class="kw">in</span> programa.comandos:</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._analisar_comando(cmd)</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _analisar_declaracao(<span class="va">self</span>, decl: Declaracao) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Adiciona variável à **Tabela de Símbolos**"""</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.tabela.adicionar(decl.nome, decl.tipo)</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.erros.append(<span class="bu">str</span>(e))</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _analisar_comando(<span class="va">self</span>, cmd: Comando) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Despacha análise para o tipo específico de comando"""</span></span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(cmd, Atribuicao):</span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._analisar_atribuicao(cmd)</span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>      <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="ss">f"Tipo de comando desconhecido: </span><span class="sc">{</span><span class="bu">type</span>(cmd)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _analisar_atribuicao(<span class="va">self</span>, atrib: Atribuicao) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Verifica compatibilidade de tipos em atribuição"""</span></span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verificar se a variável foi declarada</span></span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a>    tipo_var <span class="op">=</span> <span class="va">self</span>.tabela.consultar(atrib.variavel)</span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tipo_var <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.erros.append(</span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"Erro semântico: variável '</span><span class="sc">{</span>atrib<span class="sc">.</span>variavel<span class="sc">}</span><span class="ss">' não declarada"</span></span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span></span>
<span id="cb35-55"><a href="#cb35-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-56"><a href="#cb35-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inferir tipo da expressão</span></span>
<span id="cb35-57"><a href="#cb35-57" aria-hidden="true" tabindex="-1"></a>    tipo_expr <span class="op">=</span> <span class="va">self</span>._analisar_expressao(atrib.expressao)</span>
<span id="cb35-58"><a href="#cb35-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-59"><a href="#cb35-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verificar compatibilidade</span></span>
<span id="cb35-60"><a href="#cb35-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tipo_var <span class="op">==</span> <span class="st">"int"</span> <span class="kw">and</span> tipo_expr <span class="op">==</span> <span class="st">"float"</span>:</span>
<span id="cb35-61"><a href="#cb35-61" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.erros.append(</span>
<span id="cb35-62"><a href="#cb35-62" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"Erro semântico: não é possível atribuir float a variável int '</span><span class="sc">{</span>atrib<span class="sc">.</span>variavel<span class="sc">}</span><span class="ss">'"</span></span>
<span id="cb35-63"><a href="#cb35-63" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb35-64"><a href="#cb35-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># int para float é permitido (promoção implícita)</span></span>
<span id="cb35-65"><a href="#cb35-65" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-66"><a href="#cb35-66" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _analisar_expressao(<span class="va">self</span>, expr: Expressao) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb35-67"><a href="#cb35-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb35-68"><a href="#cb35-68" aria-hidden="true" tabindex="-1"></a><span class="co">    Analisa uma expressão e retorna seu tipo.</span></span>
<span id="cb35-69"><a href="#cb35-69" aria-hidden="true" tabindex="-1"></a><span class="co">    Anota o vértice da AST com o tipo inferido.</span></span>
<span id="cb35-70"><a href="#cb35-70" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb35-71"><a href="#cb35-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(expr, LiteralInt):</span>
<span id="cb35-72"><a href="#cb35-72" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="st">"int"</span></span>
<span id="cb35-73"><a href="#cb35-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-74"><a href="#cb35-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, LiteralFloat):</span>
<span id="cb35-75"><a href="#cb35-75" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="st">"float"</span></span>
<span id="cb35-76"><a href="#cb35-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-77"><a href="#cb35-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, Variavel):</span>
<span id="cb35-78"><a href="#cb35-78" aria-hidden="true" tabindex="-1"></a>      tipo <span class="op">=</span> <span class="va">self</span>.tabela.consultar(expr.nome)</span>
<span id="cb35-79"><a href="#cb35-79" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> tipo <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb35-80"><a href="#cb35-80" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.erros.append(</span>
<span id="cb35-81"><a href="#cb35-81" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"Erro semântico: variável '</span><span class="sc">{</span>expr<span class="sc">.</span>nome<span class="sc">}</span><span class="ss">' não declarada"</span></span>
<span id="cb35-82"><a href="#cb35-82" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb35-83"><a href="#cb35-83" aria-hidden="true" tabindex="-1"></a>        expr.tipo_inferido <span class="op">=</span> <span class="st">"int"</span> <span class="co"># Tipo padrão para recuperação de erro</span></span>
<span id="cb35-84"><a href="#cb35-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"int"</span></span>
<span id="cb35-85"><a href="#cb35-85" aria-hidden="true" tabindex="-1"></a>      expr.tipo_inferido <span class="op">=</span> tipo</span>
<span id="cb35-86"><a href="#cb35-86" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> tipo</span>
<span id="cb35-87"><a href="#cb35-87" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-88"><a href="#cb35-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, ExpressaoBinaria):</span>
<span id="cb35-89"><a href="#cb35-89" aria-hidden="true" tabindex="-1"></a>      tipo_esq <span class="op">=</span> <span class="va">self</span>._analisar_expressao(expr.esquerda)</span>
<span id="cb35-90"><a href="#cb35-90" aria-hidden="true" tabindex="-1"></a>      tipo_dir <span class="op">=</span> <span class="va">self</span>._analisar_expressao(expr.direita)</span>
<span id="cb35-91"><a href="#cb35-91" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb35-92"><a href="#cb35-92" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Verificar divisão por zero em literais (semântica dinâmica parcialmente estática)</span></span>
<span id="cb35-93"><a href="#cb35-93" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> expr.operador <span class="op">==</span> <span class="st">"/"</span> <span class="kw">and</span> <span class="bu">isinstance</span>(expr.direita, (LiteralInt, LiteralFloat)):</span>
<span id="cb35-94"><a href="#cb35-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> expr.direita.valor <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb35-95"><a href="#cb35-95" aria-hidden="true" tabindex="-1"></a>          <span class="va">self</span>.erros.append(<span class="st">"Erro semântico: divisão por zero detectada"</span>)</span>
<span id="cb35-96"><a href="#cb35-96" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb35-97"><a href="#cb35-97" aria-hidden="true" tabindex="-1"></a>      <span class="co"># A linha a seguir é a implementação em código da regra semântica:</span></span>
<span id="cb35-98"><a href="#cb35-98" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Expr.tipo = promover_tipo(Expr1.tipo, Term.tipo)</span></span>
<span id="cb35-99"><a href="#cb35-99" aria-hidden="true" tabindex="-1"></a>      tipo_resultado <span class="op">=</span> <span class="va">self</span>._promover_tipo(tipo_esq, tipo_dir)</span>
<span id="cb35-100"><a href="#cb35-100" aria-hidden="true" tabindex="-1"></a>      expr.tipo_inferido <span class="op">=</span> tipo_resultado</span>
<span id="cb35-101"><a href="#cb35-101" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> tipo_resultado</span>
<span id="cb35-102"><a href="#cb35-102" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-103"><a href="#cb35-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb35-104"><a href="#cb35-104" aria-hidden="true" tabindex="-1"></a>      <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="ss">f"Tipo de expressão desconhecido: </span><span class="sc">{</span><span class="bu">type</span>(expr)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-105"><a href="#cb35-105" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-106"><a href="#cb35-106" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _promover_tipo(<span class="va">self</span>, tipo1: <span class="bu">str</span>, tipo2: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb35-107"><a href="#cb35-107" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb35-108"><a href="#cb35-108" aria-hidden="true" tabindex="-1"></a><span class="co">    Implementa regras de promoção de tipos em operações aritméticas.</span></span>
<span id="cb35-109"><a href="#cb35-109" aria-hidden="true" tabindex="-1"></a><span class="co">    float + int -&gt; float</span></span>
<span id="cb35-110"><a href="#cb35-110" aria-hidden="true" tabindex="-1"></a><span class="co">    int + int -&gt; int</span></span>
<span id="cb35-111"><a href="#cb35-111" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb35-112"><a href="#cb35-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tipo1 <span class="op">==</span> <span class="st">"float"</span> <span class="kw">or</span> tipo2 <span class="op">==</span> <span class="st">"float"</span>:</span>
<span id="cb35-113"><a href="#cb35-113" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="st">"float"</span></span>
<span id="cb35-114"><a href="#cb35-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"int"</span></span>
<span id="cb35-115"><a href="#cb35-115" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-116"><a href="#cb35-116" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> imprimir_erros(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb35-117"><a href="#cb35-117" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Imprime todos os erros semânticos encontrados"""</span></span>
<span id="cb35-118"><a href="#cb35-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.erros:</span>
<span id="cb35-119"><a href="#cb35-119" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="st">"Nenhum erro semântico encontrado."</span>)</span>
<span id="cb35-120"><a href="#cb35-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb35-121"><a href="#cb35-121" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="ss">f"Encontrados </span><span class="sc">{</span><span class="bu">len</span>(<span class="va">self</span>.erros)<span class="sc">}</span><span class="ss"> erro(s) semântico(s):"</span>)</span>
<span id="cb35-122"><a href="#cb35-122" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> i, erro <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.erros, <span class="dv">1</span>):</span>
<span id="cb35-123"><a href="#cb35-123" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>erro<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="exemplo-de-uso-completo" class="level3" data-number="10.10.5">
<h3 data-number="10.10.5" class="anchored" data-anchor-id="exemplo-de-uso-completo"><span class="header-section-number">10.10.5</span> Exemplo de Uso Completo</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exemplo_programa_valido():</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Programa correto: todas as variáveis declaradas, tipos compatíveis"""</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  programa <span class="op">=</span> Programa(</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    declaracoes<span class="op">=</span>[</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>      Declaracao(tipo<span class="op">=</span><span class="st">"int"</span>, nome<span class="op">=</span><span class="st">"x"</span>),</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>      Declaracao(tipo<span class="op">=</span><span class="st">"float"</span>, nome<span class="op">=</span><span class="st">"y"</span>),</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    comandos<span class="op">=</span>[</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>LiteralInt(valor<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"y"</span>,</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>LiteralFloat(valor<span class="op">=</span><span class="fl">3.14</span>)</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>ExpressaoBinaria(</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>          esquerda<span class="op">=</span>Variavel(nome<span class="op">=</span><span class="st">"x"</span>),</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>          operador<span class="op">=</span><span class="st">"+"</span>,</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>          direita<span class="op">=</span>LiteralInt(valor<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"y"</span>,</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>ExpressaoBinaria(</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>          esquerda<span class="op">=</span>Variavel(nome<span class="op">=</span><span class="st">"y"</span>),</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>          operador<span class="op">=</span><span class="st">"*"</span>,</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>          direita<span class="op">=</span>LiteralFloat(valor<span class="op">=</span><span class="fl">2.0</span>)</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>  analisador <span class="op">=</span> AnalisadorSemantico()</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>  sucesso <span class="op">=</span> analisador.analisar(programa)</span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"=== Programa Válido ==="</span>)</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>  analisador.imprimir_erros()</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"Análise: </span><span class="sc">{</span><span class="st">'SUCESSO'</span> <span class="cf">if</span> sucesso <span class="cf">else</span> <span class="st">'FALHOU'</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sucesso</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exemplo_variavel_nao_declarada():</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Erro: uso de variável não declarada"""</span></span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>  programa <span class="op">=</span> Programa(</span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a>    declaracoes<span class="op">=</span>[</span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a>      Declaracao(tipo<span class="op">=</span><span class="st">"int"</span>, nome<span class="op">=</span><span class="st">"x"</span>),</span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a>    comandos<span class="op">=</span>[</span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"y"</span>, <span class="co"># Erro: y não foi declarada</span></span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>LiteralInt(valor<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb36-54"><a href="#cb36-54" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-55"><a href="#cb36-55" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb36-56"><a href="#cb36-56" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb36-57"><a href="#cb36-57" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-58"><a href="#cb36-58" aria-hidden="true" tabindex="-1"></a>  analisador <span class="op">=</span> AnalisadorSemantico()</span>
<span id="cb36-59"><a href="#cb36-59" aria-hidden="true" tabindex="-1"></a>  sucesso <span class="op">=</span> analisador.analisar(programa)</span>
<span id="cb36-60"><a href="#cb36-60" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-61"><a href="#cb36-61" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"=== Variável Não Declarada ==="</span>)</span>
<span id="cb36-62"><a href="#cb36-62" aria-hidden="true" tabindex="-1"></a>  analisador.imprimir_erros()</span>
<span id="cb36-63"><a href="#cb36-63" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"Análise: </span><span class="sc">{</span><span class="st">'SUCESSO'</span> <span class="cf">if</span> sucesso <span class="cf">else</span> <span class="st">'FALHOU'</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb36-64"><a href="#cb36-64" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sucesso</span>
<span id="cb36-65"><a href="#cb36-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-66"><a href="#cb36-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exemplo_incompatibilidade_tipo():</span>
<span id="cb36-67"><a href="#cb36-67" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Erro: tentativa de atribuir float a variável int"""</span></span>
<span id="cb36-68"><a href="#cb36-68" aria-hidden="true" tabindex="-1"></a>  programa <span class="op">=</span> Programa(</span>
<span id="cb36-69"><a href="#cb36-69" aria-hidden="true" tabindex="-1"></a>    declaracoes<span class="op">=</span>[</span>
<span id="cb36-70"><a href="#cb36-70" aria-hidden="true" tabindex="-1"></a>      Declaracao(tipo<span class="op">=</span><span class="st">"int"</span>, nome<span class="op">=</span><span class="st">"x"</span>),</span>
<span id="cb36-71"><a href="#cb36-71" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb36-72"><a href="#cb36-72" aria-hidden="true" tabindex="-1"></a>    comandos<span class="op">=</span>[</span>
<span id="cb36-73"><a href="#cb36-73" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-74"><a href="#cb36-74" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb36-75"><a href="#cb36-75" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>LiteralFloat(valor<span class="op">=</span><span class="fl">3.14</span>) <span class="co"># Erro: float para int</span></span>
<span id="cb36-76"><a href="#cb36-76" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-77"><a href="#cb36-77" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb36-78"><a href="#cb36-78" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb36-79"><a href="#cb36-79" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-80"><a href="#cb36-80" aria-hidden="true" tabindex="-1"></a>  analisador <span class="op">=</span> AnalisadorSemantico()</span>
<span id="cb36-81"><a href="#cb36-81" aria-hidden="true" tabindex="-1"></a>  sucesso <span class="op">=</span> analisador.analisar(programa)</span>
<span id="cb36-82"><a href="#cb36-82" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-83"><a href="#cb36-83" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"=== Incompatibilidade de Tipo ==="</span>)</span>
<span id="cb36-84"><a href="#cb36-84" aria-hidden="true" tabindex="-1"></a>  analisador.imprimir_erros()</span>
<span id="cb36-85"><a href="#cb36-85" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"Análise: </span><span class="sc">{</span><span class="st">'SUCESSO'</span> <span class="cf">if</span> sucesso <span class="cf">else</span> <span class="st">'FALHOU'</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb36-86"><a href="#cb36-86" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sucesso</span>
<span id="cb36-87"><a href="#cb36-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-88"><a href="#cb36-88" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exemplo_divisao_por_zero():</span>
<span id="cb36-89"><a href="#cb36-89" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Erro: divisão por zero detectada estaticamente"""</span></span>
<span id="cb36-90"><a href="#cb36-90" aria-hidden="true" tabindex="-1"></a>  programa <span class="op">=</span> Programa(</span>
<span id="cb36-91"><a href="#cb36-91" aria-hidden="true" tabindex="-1"></a>    declaracoes<span class="op">=</span>[</span>
<span id="cb36-92"><a href="#cb36-92" aria-hidden="true" tabindex="-1"></a>      Declaracao(tipo<span class="op">=</span><span class="st">"int"</span>, nome<span class="op">=</span><span class="st">"x"</span>),</span>
<span id="cb36-93"><a href="#cb36-93" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb36-94"><a href="#cb36-94" aria-hidden="true" tabindex="-1"></a>    comandos<span class="op">=</span>[</span>
<span id="cb36-95"><a href="#cb36-95" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-96"><a href="#cb36-96" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb36-97"><a href="#cb36-97" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>ExpressaoBinaria(</span>
<span id="cb36-98"><a href="#cb36-98" aria-hidden="true" tabindex="-1"></a>          esquerda<span class="op">=</span>LiteralInt(valor<span class="op">=</span><span class="dv">10</span>),</span>
<span id="cb36-99"><a href="#cb36-99" aria-hidden="true" tabindex="-1"></a>          operador<span class="op">=</span><span class="st">"/"</span>,</span>
<span id="cb36-100"><a href="#cb36-100" aria-hidden="true" tabindex="-1"></a>          direita<span class="op">=</span>LiteralInt(valor<span class="op">=</span><span class="dv">0</span>) <span class="co"># Erro: divisão por zero</span></span>
<span id="cb36-101"><a href="#cb36-101" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb36-102"><a href="#cb36-102" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-103"><a href="#cb36-103" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb36-104"><a href="#cb36-104" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb36-105"><a href="#cb36-105" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-106"><a href="#cb36-106" aria-hidden="true" tabindex="-1"></a>  analisador <span class="op">=</span> AnalisadorSemantico()</span>
<span id="cb36-107"><a href="#cb36-107" aria-hidden="true" tabindex="-1"></a>  sucesso <span class="op">=</span> analisador.analisar(programa)</span>
<span id="cb36-108"><a href="#cb36-108" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-109"><a href="#cb36-109" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"=== Divisão por Zero ==="</span>)</span>
<span id="cb36-110"><a href="#cb36-110" aria-hidden="true" tabindex="-1"></a>  analisador.imprimir_erros()</span>
<span id="cb36-111"><a href="#cb36-111" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"Análise: </span><span class="sc">{</span><span class="st">'SUCESSO'</span> <span class="cf">if</span> sucesso <span class="cf">else</span> <span class="st">'FALHOU'</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb36-112"><a href="#cb36-112" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sucesso</span>
<span id="cb36-113"><a href="#cb36-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-114"><a href="#cb36-114" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exemplo_promocao_tipo():</span>
<span id="cb36-115"><a href="#cb36-115" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""Promoção automática de int para float"""</span></span>
<span id="cb36-116"><a href="#cb36-116" aria-hidden="true" tabindex="-1"></a>  programa <span class="op">=</span> Programa(</span>
<span id="cb36-117"><a href="#cb36-117" aria-hidden="true" tabindex="-1"></a>    declaracoes<span class="op">=</span>[</span>
<span id="cb36-118"><a href="#cb36-118" aria-hidden="true" tabindex="-1"></a>      Declaracao(tipo<span class="op">=</span><span class="st">"float"</span>, nome<span class="op">=</span><span class="st">"resultado"</span>),</span>
<span id="cb36-119"><a href="#cb36-119" aria-hidden="true" tabindex="-1"></a>      Declaracao(tipo<span class="op">=</span><span class="st">"int"</span>, nome<span class="op">=</span><span class="st">"x"</span>),</span>
<span id="cb36-120"><a href="#cb36-120" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb36-121"><a href="#cb36-121" aria-hidden="true" tabindex="-1"></a>    comandos<span class="op">=</span>[</span>
<span id="cb36-122"><a href="#cb36-122" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-123"><a href="#cb36-123" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb36-124"><a href="#cb36-124" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>LiteralInt(valor<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb36-125"><a href="#cb36-125" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-126"><a href="#cb36-126" aria-hidden="true" tabindex="-1"></a>      Atribuicao(</span>
<span id="cb36-127"><a href="#cb36-127" aria-hidden="true" tabindex="-1"></a>        variavel<span class="op">=</span><span class="st">"resultado"</span>,</span>
<span id="cb36-128"><a href="#cb36-128" aria-hidden="true" tabindex="-1"></a>        expressao<span class="op">=</span>ExpressaoBinaria(</span>
<span id="cb36-129"><a href="#cb36-129" aria-hidden="true" tabindex="-1"></a>          esquerda<span class="op">=</span>Variavel(nome<span class="op">=</span><span class="st">"x"</span>), <span class="co"># int</span></span>
<span id="cb36-130"><a href="#cb36-130" aria-hidden="true" tabindex="-1"></a>          operador<span class="op">=</span><span class="st">"+"</span>,</span>
<span id="cb36-131"><a href="#cb36-131" aria-hidden="true" tabindex="-1"></a>          direita<span class="op">=</span>LiteralFloat(valor<span class="op">=</span><span class="fl">3.14</span>) <span class="co"># float</span></span>
<span id="cb36-132"><a href="#cb36-132" aria-hidden="true" tabindex="-1"></a>        ) <span class="co"># Resultado: float (promoção de x)</span></span>
<span id="cb36-133"><a href="#cb36-133" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb36-134"><a href="#cb36-134" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb36-135"><a href="#cb36-135" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb36-136"><a href="#cb36-136" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-137"><a href="#cb36-137" aria-hidden="true" tabindex="-1"></a>  analisador <span class="op">=</span> AnalisadorSemantico()</span>
<span id="cb36-138"><a href="#cb36-138" aria-hidden="true" tabindex="-1"></a>  sucesso <span class="op">=</span> analisador.analisar(programa)</span>
<span id="cb36-139"><a href="#cb36-139" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-140"><a href="#cb36-140" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"=== Promoção de Tipo (int -&gt; float) ==="</span>)</span>
<span id="cb36-141"><a href="#cb36-141" aria-hidden="true" tabindex="-1"></a>  analisador.imprimir_erros()</span>
<span id="cb36-142"><a href="#cb36-142" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"Análise: </span><span class="sc">{</span><span class="st">'SUCESSO'</span> <span class="cf">if</span> sucesso <span class="cf">else</span> <span class="st">'FALHOU'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb36-143"><a href="#cb36-143" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb36-144"><a href="#cb36-144" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Verificar tipo inferido</span></span>
<span id="cb36-145"><a href="#cb36-145" aria-hidden="true" tabindex="-1"></a>  expr <span class="op">=</span> programa.comandos[<span class="dv">1</span>].expressao</span>
<span id="cb36-146"><a href="#cb36-146" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"Tipo inferido da expressão: </span><span class="sc">{</span>expr<span class="sc">.</span>tipo_inferido<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb36-147"><a href="#cb36-147" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sucesso</span>
<span id="cb36-148"><a href="#cb36-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-149"><a href="#cb36-149" aria-hidden="true" tabindex="-1"></a><span class="co"># Executar todos os exemplos</span></span>
<span id="cb36-150"><a href="#cb36-150" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb36-151"><a href="#cb36-151" aria-hidden="true" tabindex="-1"></a>  exemplo_programa_valido()</span>
<span id="cb36-152"><a href="#cb36-152" aria-hidden="true" tabindex="-1"></a>  exemplo_variavel_nao_declarada()</span>
<span id="cb36-153"><a href="#cb36-153" aria-hidden="true" tabindex="-1"></a>  exemplo_incompatibilidade_tipo()</span>
<span id="cb36-154"><a href="#cb36-154" aria-hidden="true" tabindex="-1"></a>  exemplo_divisao_por_zero()</span>
<span id="cb36-155"><a href="#cb36-155" aria-hidden="true" tabindex="-1"></a>  exemplo_promocao_tipo()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="saída-esperada" class="level3" data-number="10.10.6">
<h3 data-number="10.10.6" class="anchored" data-anchor-id="saída-esperada"><span class="header-section-number">10.10.6</span> Saída Esperada</h3>
<pre class="shell"><code>=== Programa Válido ===
Nenhum erro semântico encontrado.
Análise: SUCESSO

=== Variável Não Declarada ===
Encontrados 1 erro(s) semântico(s):
 1. Erro semântico: variável 'y' não declarada
Análise: FALHOU

=== Incompatibilidade de Tipo ===
Encontrados 1 erro(s) semântico(s):
 1. Erro semântico: não é possível atribuir float a variável int 'x'
Análise: FALHOU

=== Divisão por Zero ===
Encontrados 1 erro(s) semântico(s):
 1. Erro semântico: divisão por zero detectada
Análise: FALHOU

=== Promoção de Tipo (int -&gt; float) ===
Nenhum erro semântico encontrado.
Análise: SUCESSO
Tipo inferido da expressão: float</code></pre>
</section>
<section id="exercícios-propostos" class="level3" data-number="10.10.7">
<h3 data-number="10.10.7" class="anchored" data-anchor-id="exercícios-propostos"><span class="header-section-number">10.10.7</span> Exercícios Propostos</h3>
<p>A implementação acima fornece uma base sólida, mas pode ser estendida de várias maneiras instrutivas:</p>
<p><strong>1. Adicionar Operadores Relacionais</strong>: estenda a gramática e o analisador para suportar operadores de comparação (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>). Esses operadores devem:</p>
<ul>
<li>Aceitar operandos numéricos (<code>int</code> ou <code>float</code>);</li>
<li>Sempre retornar tipo booleano;</li>
<li>Requer adicionar o tipo <code>bool</code> à linguagem.</li>
</ul>
<p><strong>2. Implementar Comandos Condicionais</strong>: adicione suporte para <code>if-else</code>:</p>
<ul>
<li>A condição deve ser do tipo booleano;</li>
<li>Ambos os ramos devem ser semanticamente válidos;</li>
<li>Considere como escopos aninhados afetam a <strong>Tabela de Símbolos</strong>.</li>
</ul>
<p><strong>3. Suportar Múltiplas Declarações na Mesma Linha</strong>: modifique a gramática para permitir: <code>int x, y, z;</code>:</p>
<ul>
<li>Todas as variáveis devem receber o mesmo tipo;</li>
<li>Nomes duplicados na mesma declaração devem ser rejeitados.</li>
</ul>
<p><strong>4. Adicionar Verificação de Inicialização</strong>: implemente análise de fluxo de dados para detectar uso de variáveis não inicializadas:</p>
<ul>
<li>Variáveis devem ser atribuídas antes de serem usadas em expressões;</li>
<li>Requer rastrear o estado de inicialização de cada variável</li>
</ul>
<p><strong>5. Implementar Funções e Escopo</strong>: Estenda a linguagem com funções:</p>
<ul>
<li>Parâmetros e variáveis locais;</li>
<li>Verificação de tipos de argumentos em chamadas;</li>
<li>Verificação de retorno em funções não-void;</li>
<li>Escopos aninhados (função dentro de função).</li>
</ul>
<p><strong>6. Gerar Mensagens de Erro Mais Informativas</strong>: melhore a qualidade das mensagens de erro adicionando:</p>
<ul>
<li>Números de linha e coluna;</li>
<li>Sugestões de correção (ex: “Você quis dizer ‘variavel’ em vez de ‘varaivel’?”);</li>
<li>Contexto do erro (mostrar a linha de código).</li>
</ul>
</section>
</section>
<section id="a-ponte-para-a-geração-de-código-intermediário" class="level2" data-number="10.11">
<h2 data-number="10.11" class="anchored" data-anchor-id="a-ponte-para-a-geração-de-código-intermediário"><span class="header-section-number">10.11</span> A Ponte para a Geração de Código Intermediário</h2>
<p>A análise semântica marca o fim da fase de análise do compilador. Neste ponto, o programa-fonte foi validado como sintática e semanticamente correto. A <strong>AST</strong>, agora ricamente Atribuída com informações de tipo e escopo, está pronta para ser entregue à fase de <em>síntese</em>, cujo primeiro passo é a <strong>geração de código intermediário (CI)</strong>.</p>
<section id="da-análise-à-síntese-o-papel-da-ast-atribuída" class="level3" data-number="10.11.1">
<h3 data-number="10.11.1" class="anchored" data-anchor-id="da-análise-à-síntese-o-papel-da-ast-atribuída"><span class="header-section-number">10.11.1</span> Da Análise à Síntese: O Papel da <strong>AST</strong> Atribuída</h3>
<p>A transição da análise para a síntese é um momento crítico no processo de compilação. O compilador deixa de <em>entender</em> o código-fonte e começa a <em>construir</em> o programa-alvo. Gerar código de máquina diretamente a partir da <strong>AST</strong> é possível, mas apresenta duas grandes desvantagens:</p>
<ol type="1">
<li><strong>Complexidade</strong>: A estrutura hierárquica e de alto nível da <strong>AST</strong> está muito distante da natureza linear e de baixo nível do código de máquina. A tradução direta seria complexa e propensa a erros.</li>
<li><strong>Acoplamento</strong>: Um gerador de código que vai direto da <strong>AST</strong> para o código de máquina acopla fortemente o <em>front-end</em> (dependente da linguagem) ao <em>back-end</em> (dependente da arquitetura). Isso tornaria a portabilidade do compilador para novas máquinas um pesadelo, exigindo uma reescrita completa do gerador de código.</li>
</ol>
<p>A solução é usar uma <strong>Representação Intermediária (RI)</strong> ou <strong>Código Intermediário (CI)</strong>. O CI é uma linguagem abstrata, mais simples que a linguagem-fonte, mas mais rica que a linguagem de máquina. Ele atua como uma ponte, permitindo que o <em>front-end</em> traduza a <strong>AST</strong> Atribuída para essa linguagem universal, e que o <em>back-end</em> traduza o CI para o código de máquina específico da arquitetura-alvo. Essa abordagem promove a modularidade e a portabilidade.</p>
</section>
<section id="código-de-três-endereços-tac-uma-representação-linear" class="level3" data-number="10.11.2">
<h3 data-number="10.11.2" class="anchored" data-anchor-id="código-de-três-endereços-tac-uma-representação-linear"><span class="header-section-number">10.11.2</span> Código de Três Endereços (TAC): Uma Representação Linear</h3>
<p>Uma das formas mais populares de código intermediário é o <strong>Código de Três Endereços (TAC)</strong>. Sua principal característica é que cada instrução possui, no máximo, um operador e três endereços (dois para operandos e um para o resultado). Um “endereço” pode ser um nome de variável, uma constante ou uma variável temporária gerada pelo compilador.</p>
<p>O formato geral é: <code>resultado = operando1 op operando2</code>.</p>
<p>O TAC transforma a estrutura hierárquica da <strong>AST</strong> em uma sequência linear de instruções simples, muito semelhante a uma linguagem de montagem abstrata. Algumas instruções típicas do TAC incluem:</p>
<ul>
<li><strong>Atribuição Binária</strong>: <code>x = y + z</code>;</li>
<li><strong>Atribuição Unária</strong>: <code>x = -y</code>;</li>
<li><strong>Atribuição de Cópia</strong>: <code>x = y</code>;</li>
<li><strong>Salto Incondicional</strong>: <code>goto L</code>;</li>
<li><strong>Salto Condicional</strong>: <code>if x &lt; y goto L</code>;</li>
<li><strong>Chamada de Procedimento</strong>: <code>param x1, call p, n</code>;</li>
<li><strong>Acesso a Array</strong>: <code>x = y[i]</code>, <code>x[i] = y</code>.</li>
</ul>
</section>
<section id="exemplo-de-tradução-gerando-tac-a-partir-da-ast-atribuída" class="level3" data-number="10.11.3">
<h3 data-number="10.11.3" class="anchored" data-anchor-id="exemplo-de-tradução-gerando-tac-a-partir-da-ast-atribuída"><span class="header-section-number">10.11.3</span> Exemplo de Tradução: Gerando TAC a partir da <strong>AST</strong> Atribuída</h3>
<p>O processo de geração de TAC é tipicamente implementado como uma travessia recursiva da <strong>AST</strong> Atribuída, geralmente em pós-ordem. Para cada vértice da árvore, o compilador gera uma sequência de instruções TAC.</p>
<p>Vamos considerar a tradução da instrução <code>w = (a + b) * c;</code>, assumindo que todas as variáveis são do tipo <code>float</code>.</p>
<ol type="1">
<li><strong>AST Atribuída (Simplificada)</strong>: A análise semântica já validou os tipos e decorou a árvore. O vértice da atribuição, o <code>+</code> e o <code>*</code> estão todos anotados com o tipo <code>float</code>.</li>
</ol>
<pre class="shell"><code>    =
  / \
id(w) * [type: float]
    /  \
    + [type: float] id(c)
  / \
id(a) id(b)</code></pre>
<ol start="2" type="1">
<li><p><strong>Travessia e Geração de TAC</strong>: O gerador de código percorre a árvore recursivamente.</p>
<ul>
<li>Ele desce até o vértice <code>+</code>. Para gerar o código para <code>+</code>, ele primeiro precisa gerar o código para seus filhos, <code>a</code> e <code>b</code>.</li>
<li>Os operandos <code>a</code> e <code>b</code> não requerem geração de código; seus valores serão usados diretamente.</li>
<li>Ao retornar ao vértice <code>+</code>, o gerador de código cria uma nova variável temporária, <code>t1</code>, para armazenar o resultado da soma. Ele emite a primeira instrução TAC: <code>t1 = a + b</code></li>
<li>Agora, o gerador de código sobe para o vértice <code>*</code>. Ele já processou o filho esquerdo (cujo resultado está em <code>t1</code>) e agora processa o filho direito, <code>c</code>.</li>
<li>Com os resultados de ambos os filhos (<code>t1</code> e <code>c</code>), ele cria uma segunda variável temporária, <code>t2</code>, e emite a instrução de multiplicação: <code>t2 = t1 * c</code></li>
<li>Finalmente, ele sobe para o vértice raiz, <code>=</code>. O resultado da expressão do lado direito está em <code>t2</code>. Ele então emite a instrução de atribuição final: <code>w = t2</code></li>
</ul></li>
<li><p><strong>Código de Três Endereços Resultante</strong>: A sequência linear de instruções TAC para a expressão original é:</p></li>
</ol>
<pre class="shell"><code>t1 = a + b
t2 = t1 * c
w = t2</code></pre>
<p>Que pode ser vista na Figura <a href="#fig-tac1" class="quarto-xref">Figure&nbsp;<span>10.12</span></a>.</p>
<div id="fig-tac1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tac1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/ast-tac.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-tac1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.12
</figcaption>
</figure>
</div>
<p>A informação da <strong>AST</strong> Atribuída é fundamental aqui. O atributo de tipo em cada vértice de operador (<code>+</code>, <code>*</code>) informa ao gerador de código qual instrução específica emitir (ex.: <code>ADD_FLOAT</code> vs.&nbsp;<code>ADD_INT</code>). As referências dos vértices de identificador (<code>a</code>, <code>b</code>, <code>c</code>, <code>w</code>) à <strong>Tabela de Símbolos</strong> fornecem os endereços de memória que serão usados no código final. A <strong>AST</strong> Atribuída, portanto, não é apenas uma representação validada, mas um projeto detalhado a partir do qual a fase de síntese pode construir o programa executável.</p>
</section>
</section>
<section id="exercícios" class="level2" data-number="10.12">
<h2 data-number="10.12" class="anchored" data-anchor-id="exercícios"><span class="header-section-number">10.12</span> Exercícios</h2>
<section id="exercício-1-semântica-básica" class="level3" data-number="10.12.1">
<h3 data-number="10.12.1" class="anchored" data-anchor-id="exercício-1-semântica-básica"><span class="header-section-number">10.12.1</span> Exercício 1: Semântica Básica</h3>
<p>Dado o programa:</p>
<pre class="shell"><code>x := 3;
y := x * 2;
x := x + y;</code></pre>
<p>Trace a execução usando semântica denotacional, mostrando o estado após cada comando.</p>
<p><strong>Solução</strong>:</p>
<ul>
<li><span class="math inline">\(\sigma_0 = \{\}\)</span> (estado inicial);</li>
<li><span class="math inline">\(\sigma_1 = [\![x := 3]\!]\sigma_0 = \{x \mapsto 3\}\)</span>;</li>
<li><span class="math inline">\(\sigma_2 = [\![y := x * 2]\!]\sigma_1 = \{x \mapsto 3, y \mapsto 6\}\)</span>;</li>
<li><span class="math inline">\(\sigma_3 = [\![x := x + y]\!]\sigma_2 = \{x \mapsto 9, y \mapsto 6\}\)</span>.</li>
</ul>
</section>
<section id="exercício-2-análise-de-tipos" class="level3" data-number="10.12.2">
<h3 data-number="10.12.2" class="anchored" data-anchor-id="exercício-2-análise-de-tipos"><span class="header-section-number">10.12.2</span> Exercício 2: Análise de Tipos</h3>
<p>Verifique se o seguinte programa está bem tipado:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> b <span class="op">=</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="cf">if</span> b then x <span class="op">+</span> <span class="dv">1</span> <span class="cf">else</span> x <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><span class="math inline">\(x : \text{int}\)</span>;</li>
<li><span class="math inline">\(x &gt; 0 : \text{bool}\)</span> (comparação de inteiros);</li>
<li><span class="math inline">\(b : \text{bool}\)</span>;</li>
<li><span class="math inline">\(x + 1 : \text{int}\)</span>;</li>
<li><span class="math inline">\(x - 1 : \text{int}\)</span>;</li>
<li><span class="math inline">\(\text{if } b \text{ then } \text{int} \text{ else } \text{int} : \text{int}\)</span>;</li>
<li><span class="math inline">\(y : \text{int}\)</span>.</li>
</ol>
<p>Programa bem tipado!</p>
</section>
<section id="exercício-3-otimização" class="level3" data-number="10.12.3">
<h3 data-number="10.12.3" class="anchored" data-anchor-id="exercício-3-otimização"><span class="header-section-number">10.12.3</span> Exercício 3: Otimização</h3>
<p>Identifique otimizações possíveis para:</p>
<pre class="shell"><code>x := 10;
y := x + 0;
z := y * 1;
w := z - z;</code></pre>
<p><strong>Solução</strong>: aplicando regras semânticas de identidade:</p>
<ul>
<li><span class="math inline">\(y := x + 0\)</span> pode ser simplificado para <span class="math inline">\(y := x\)</span>;</li>
<li><span class="math inline">\(z := y * 1\)</span> pode ser simplificado para <span class="math inline">\(z := y\)</span>;</li>
<li><span class="math inline">\(w := z - z\)</span> pode ser simplificado para <span class="math inline">\(w := 0\)</span>.</li>
</ul>
<p>Código otimizado:</p>
<pre class="shell"><code>x := 10;
y := x;
z := y;
w := 0;</code></pre>
<p>Ou ainda mais otimizado:</p>
<pre class="shell"><code>x := 10;
y := 10;
z := 10;
w := 0;</code></pre>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./08-parserSLR1.html" class="pagination-link" aria-label="Parsers $SLR(1)$: A Ponte Entre Simplicidade e Poder">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Parsers <span class="math inline">\(SLR(1)\)</span>: A Ponte Entre Simplicidade e Poder</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./10a-semantico.html" class="pagination-link" aria-label="Fundamentos Matemáticos da Semântica">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fundamentos Matemáticos da Semântica</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/10-semantico.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>