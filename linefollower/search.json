[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RobotZero",
    "section": "",
    "text": "0.1 The Platform: Arduino Nano (@ArduinoNano)\nFor this project, we chose the Arduino Nano (@ArduinoNano) as our main controller specifically for its constrained environment. When we can achieve efficiency and speed within such limitations, we learn how to optimize ideas, algorithms, and programs - skills that are valuable across all computing platforms. The Arduino Nano (@ArduinoNano), based on the ATmega328P microcontroller, offers a small form factor (45 x 18 mm), ideal for compact robot designs. It includes 32KB of Flash memory, suitable for our advanced logging system, 2KB of SRAM for runtime operations, and runs at 16MHz, providing adequate processing power. The board features multiple analog inputs for our sensor array, PWM outputs for precise motor control, and maintains low power consumption while being cost-effective for both prototyping and final implementation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#project-overview",
    "href": "index.html#project-overview",
    "title": "RobotZero",
    "section": "0.2 Project Overview",
    "text": "0.2 Project Overview\nIn most projects, adjusting a line following robot for speed and efficiency becomes a tedious and time-consuming trial-and-error routine. Our project addresses this challenge by incorporating an advanced logging and analysis system that transforms the tuning process into a data-driven approach. The robot includes high-precision line detection using a 6-sensor array, PID-based motion control for smooth operation, and dual operating modes for analysis and high-speed performance. The comprehensive data logging system enables real-time performance monitoring, with flash-based storage for post-run analysis and a USB interface for data retrieval and analysis, providing the tools necessary for systematic testing and configuration.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#why-c",
    "href": "index.html#why-c",
    "title": "RobotZero",
    "section": "0.3 Why C++?",
    "text": "0.3 Why C++?\nThe choice of C++ as our programming language was deliberate and based on several key factors. C++ allows us to organize our code into logical classes and modules, making the system more maintainable and easier to understand. This is particularly important for complex systems like our logging mechanism. The language provides low-level hardware access while supporting high-level abstractions, crucial for real-time operations where microseconds matter, such as sensor reading and motor control.\nWith limited resources on the Arduino Nano (@ArduinoNano), C++’s efficient memory management and minimal runtime overhead are essential. We can precisely control memory allocation and ensure optimal use of the available RAM. The language’s support for namespaces, classes, and templates helps maintain clean code architecture despite the system’s complexity. C++’s strong type system helps catch errors at compile-time rather than runtime, which is crucial for a system that needs to operate autonomously. Additionally, C++ allows us to create clean abstractions over hardware components while maintaining direct access when needed, making the code both maintainable and efficient. The object-oriented features facilitate code reuse and modular design, making it easier to extend or modify the robot’s functionality.\nThe combination of Arduino Nano (@ArduinoNano)’s capabilities with C++’s features allows us to create a sophisticated line following robot that not only performs its primary function but also provides valuable insights into its operation through advanced logging and analysis capabilities.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "oper.html",
    "href": "oper.html",
    "title": "2  Line Following Robot Operation",
    "section": "",
    "text": "2.1 Operating Procedure",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Line Following Robot Operation</span>"
    ]
  },
  {
    "objectID": "oper.html#operating-procedure",
    "href": "oper.html#operating-procedure",
    "title": "2  Line Following Robot Operation",
    "section": "",
    "text": "2.1.1 Initial Setup\n\nPlace the robot near the course\nPower on the robot\nWait for initial setup delay (600ms)\n\nStatus LED will be on during this period\nMotors will be inactive\n\nAfter delay, LED turns off and robot is ready for calibration\n\n\n\n2.1.2 Calibration Process\n\nPress the start button for first calibration phase\n\nLED will turn on\n\nThe calibration process:\n\nTakes 400 samples from each sensor\n30ms delay between samples (total ~12 seconds)\nEstablishes minimum and maximum values for each sensor\n\nAfter calibration completes:\n\nLED turns off\nRobot waits for second button press\n\n\n\n\n2.1.3 Operation Start\n\nPlace robot on the track\nPress start button again to begin operation\n\nLED turns on\nRobot starts line following operation\n\nInitial operating parameters:\n\nSpeed mode begins at BASE_FAST (115)\nPID control active with default parameters\nNormal operating mode engaged\n\n\n\n\n2.1.4 During Operation\nThe robot recognizes three marker patterns: 1. Finish line marker (both sensors) - Updates lap count - Triggers stop sequence on second detection 2. Speed mode marker (left sensor only) - Toggles between normal and precision mode - In precision mode: SPEED_SLOW - In normal mode: BASE_FAST 3. Intersection marker (both sensors) - Logged but no special action taken\n\n\n2.1.5 Stop Sequence\nThe robot will stop automatically when: 1. Second finish line is detected 2. Stop sequence activates: - Speed reduces to SPEED_BRAKE - After 50ms deceleration - Final stop after 300ms - Motors power off\n\n\n2.1.6 Data Retrieval (Debug Mode Only)\nIf DEBUG_LEVEL &gt; 0: 1. When robot stops, flash memory is marked as ready 2. LED displays transmission pattern: - Alternates between slow blink (1000ms) and fast blink (300ms) - Pattern switches every 3000ms 3. Data can be retrieved through serial interface 4. After successful transmission: - Log ready flag is cleared - LED pattern stops\n\n\n2.1.7 Error Recovery\nIf line is lost: 1. Robot uses last valid position 2. Position is forced to extreme (-100 or 100) based on last direction 3. PID controller attempts to recover 4. Robot continues operation if line is found\n\n\n2.1.8 Operating Modes\nTwo base operating speeds: 1. Normal Mode (BASE_FAST): - Base speed of 115 - Curve speed reduction active - Boost after curves (if not in precision mode)\n\nPrecision Mode:\n\nActivated by left marker\nUses SPEED_SLOW\nDisables boost feature\nMore conservative operation\n\n\nDebug Operating Modes (if DEBUG_LEVEL &gt; 0): 1. Analysis Mode (DEBUG_LEVEL = 1): - 5 laps - Conservative speeds - Full data logging\n\nSpeed Mode (DEBUG_LEVEL = 2):\n\n3 laps\nMaximum performance\nFull data logging",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Line Following Robot Operation</span>"
    ]
  },
  {
    "objectID": "block.html",
    "href": "block.html",
    "title": "3  RoboZero Modules Description",
    "section": "",
    "text": "3.1 Configuration Layer",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#configuration-layer",
    "href": "block.html#configuration-layer",
    "title": "3  RoboZero Modules Description",
    "section": "",
    "text": "3.1.1 config.h\nThe configuration hub of the system, this module defines all crucial parameters including pin assignments, speed settings, and control constants. A notable feature is its use of conditional compilation (#if DEBUG_LEVEL &gt; 0) to ensure zero overhead in normal operation mode, demonstrating our commitment to efficiency.\n\n\n3.1.2 globals.h\nManages global state variables that need to be accessed across different modules. While global variables are generally discouraged, here they serve a crucial role in maintaining real-time performance by avoiding function call overhead for frequently accessed states.\n\n\n3.1.3 debug.h\nImplements a sophisticated debug message system that stores strings in Flash memory instead of RAM, using PROGMEM for optimal memory usage. This approach ensures that debug capabilities don’t impact the robot’s limited RAM resources.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#hardware-interface-layer",
    "href": "block.html#hardware-interface-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.2 Hardware Interface Layer",
    "text": "3.2 Hardware Interface Layer\n\n3.2.1 Sensors\nManages six line sensors and two marker sensors through a calibration-based approach. The unique feature here is the weighted average calculation that provides precise positional data. The system maintains both raw and processed values, enabling real-time adjustments while preserving original readings for analysis.\n\n\n3.2.2 MotorsDrivers\nImplements motor control using PWM, with a key feature being its ability to handle both forward and reverse motion through a single interface. The module includes built-in protection against invalid PWM values, ensuring safe operation even under software errors.\n\n\n3.2.3 Peripherals\nHandles external interfaces including button input and LED status indication. Notable is its debounce implementation that maintains responsiveness while ensuring reliable button detection, essential for both operation and calibration phases.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#control-layer",
    "href": "block.html#control-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.3 Control Layer",
    "text": "3.3 Control Layer\n\n3.3.1 CourseMarkers\nProcesses track markers using a state machine approach to detect different patterns (finish line, speed mode changes, intersections). Its sophisticated detection system can differentiate between various marker combinations while maintaining reliable operation under varying light conditions.\n\n\n3.3.2 ProfileManager\nManages different operation profiles (analysis and speed modes). The key innovation here is its transparent speed value translation system, which allows the same base code to operate under different performance parameters without modification.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#debug-layer",
    "href": "block.html#debug-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.4 Debug Layer",
    "text": "3.4 Debug Layer\n\n3.4.1 Logger\nImplements a sophisticated logging system using circular buffers to maintain performance. A key feature is its ability to write to flash memory only during straight-line sections, ensuring logging doesn’t interfere with critical control operations.\n\n\n3.4.2 FlashManager\nHandles flash memory operations with built-in error checking and recovery mechanisms. Notable is its page-aligned writing system that maximizes flash memory lifespan while ensuring data integrity.\n\n\n3.4.3 FlashReader\nManages data retrieval through a structured protocol, including checksums for data validation. The module implements a multi-marker system to ensure reliable data transmission even under noisy serial connections.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#main-control",
    "href": "block.html#main-control",
    "title": "3  RoboZero Modules Description",
    "section": "3.5 Main Control",
    "text": "3.5 Main Control\n\n3.5.1 main.cpp\nThe core control loop implementing PID-based line following. A significant feature is its non-blocking setup sequence that maintains system responsiveness during initialization and calibration. The module seamlessly integrates debug features when compiled with DEBUG_LEVEL &gt; 0 while maintaining optimal performance in normal operation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "config_layer.html",
    "href": "config_layer.html",
    "title": "4  Configuration Layer",
    "section": "",
    "text": "4.1 Configuration Values (config.h)\nThe config.h file is structured into logical sections, each handling specific aspects of the robot’s configuration. Let’s examine each section in detail:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "config_layer.html#configuration-values-config.h",
    "href": "config_layer.html#configuration-values-config.h",
    "title": "4  Configuration Layer",
    "section": "",
    "text": "4.1.1 Debug Configuration\nThis section controls the debugging features of the system. The DEBUG_LEVEL setting determines the robot’s operating mode and what features are compiled into the final binary.\n// Set to 1 for analysis mode, 2 for speed mode, or 0 for normal operation\n#ifndef DEBUG_LEVEL\n#define DEBUG_LEVEL 0\n#endif\n\n#if DEBUG_LEVEL &gt; 0\n#include \"DataStructures.h\"  // Include debug-related structures\n\n// Debug configuration\nstatic constexpr uint8_t DEBUG_LAPS_MODE1 = 5;    // Analysis mode laps\nstatic constexpr uint8_t DEBUG_LAPS_MODE2 = 3;    // Speed mode laps\n\n// Logging parameters\nstatic constexpr uint16_t SAMPLE_RATE_STRAIGHT = 50;   // Sampling in straight lines\nstatic constexpr uint16_t SAMPLE_RATE_CURVE = 20;      // Sampling in curves\nstatic constexpr uint16_t LOG_BUFFER_SIZE = 64;        // Circular buffer size\n\n// Flash memory parameters\nstatic constexpr uint32_t FLASH_LOG_START = 0x1000;    // Log start address\nstatic constexpr uint16_t FLASH_PAGE_SIZE = 256;       // Flash page size\nstatic constexpr uint32_t FLASH_CONTROL_BYTE = 0x0800; // Control byte location\nstatic constexpr uint8_t FLASH_LOG_READY = 0xAA;       // Log ready indicator\n#endif\nThe debug configuration implements a conditional compilation system that ensures optimal performance in normal operation. When DEBUG_LEVEL is set to 0, all debugging code is completely excluded from the final binary, resulting in no runtime overhead. Setting DEBUG_LEVEL to 1 activates the analysis mode, where the robot operates at moderate speeds and collects comprehensive data about its performance, including position errors, motor speeds, and PID corrections, completing 5 laps for detailed analysis. In speed mode, activated with DEBUG_LEVEL 2, the robot performs 3 laps at maximum speed while still collecting performance data, allowing for optimization of high-speed behaviour. The system adjusts its sampling rate based on track conditions - sampling more frequently in curves where behaviour is more dynamic, and at a lower rate in straight sections to conserve memory. All collected data is stored in a structured format in flash memory, organized to maximize data integrity and facilitate post-run analysis.\nThe flash memory organization is carefully structured to maximize efficiency and reliability. The logging system begins storing data at address 0x1000 (FLASH_LOG_START), providing ample space for system data in lower memory addresses. Each page of flash memory is 256 bytes (FLASH_PAGE_SIZE), allowing efficient writing operations that balance between memory usage and write cycles. A control byte located at address 0x0800 (FLASH_CONTROL_BYTE) serves as a state indicator for the logging system. When this byte contains the value 0xAA (FLASH_LOG_READY), it signals that valid performance data is available for retrieval, ensuring proper synchronization between data logging and retrieval operations.\n\n\n4.1.2 Pin Configuration\nDefines all hardware connections, centralizing pin assignments for easy modification and hardware revision control.\n// Only modify if changing physical robot connections\nstatic const uint8_t PIN_START_BUTTON = 11;      // Start/calibrate button\nstatic const uint8_t PIN_STATUS_LED = 13;        // Status LED\nstatic const uint8_t PIN_MOTOR_LEFT_FWD = 7;     // Left Motor Forward\nstatic const uint8_t PIN_MOTOR_LEFT_REV = 4;     // Left Motor Reverse\nstatic const uint8_t PIN_MOTOR_LEFT_PWM = 3;     // Left Motor Speed\nstatic const uint8_t PIN_MOTOR_RIGHT_FWD = 8;    // Right Motor Forward\nstatic const uint8_t PIN_MOTOR_RIGHT_REV = 9;    // Right Motor Reverse\nstatic const uint8_t PIN_MOTOR_RIGHT_PWM = 10;   // Right Motor Speed\n\n// Sensor pins\nstatic const uint8_t PIN_LINE_LEFT_EDGE = A6;    // Leftmost sensor\nstatic const uint8_t PIN_LINE_LEFT_MID = A5;\nstatic const uint8_t PIN_LINE_CENTER_LEFT = A4;\nstatic const uint8_t PIN_LINE_CENTER_RIGHT = A3;\nstatic const uint8_t PIN_LINE_RIGHT_MID = A2;\nstatic const uint8_t PIN_LINE_RIGHT_EDGE = A1;   // Rightmost sensor\nstatic const uint8_t PIN_MARKER_LEFT = A7;       // Left marker\nstatic const uint8_t PIN_MARKER_RIGHT = A0;      // Right marker\nThe pin configuration employs a systematic approach to hardware interface management. Each pin assignment is thoroughly documented with clear comments indicating its purpose, from motor control signals to sensor inputs, making hardware modifications and debugging straightforward. Related pins are logically grouped together - motor control pins are clustered by function (forward, reverse, and PWM for each motor), while sensor pins are arranged according to their physical layout on the robot (from left edge to right edge). The use of static const declarations for pin assignments not only makes the code more readable but also allows the compiler to optimize memory usage by storing these values in program memory rather than RAM. This approach maintains flexibility for hardware modifications while ensuring efficient runtime performance, as these values are resolved at compile time rather than being calculated during program execution.\n\n\n4.1.3 Speed Parameters\nDefines the various speed levels used by the robot, providing a comprehensive speed control system.\n// Base speeds - do not modify without thorough testing\nstatic constexpr uint8_t SPEED_STOP = 0;       // Stopped\nstatic constexpr uint8_t SPEED_STARTUP = 80;   // Initial movement\nstatic constexpr uint8_t SPEED_TURN = 100;     // Turn speed\nstatic constexpr uint8_t SPEED_BRAKE = 120;    // Braking speed\nstatic constexpr uint8_t SPEED_CRUISE = 140;   // Medium speed\nstatic constexpr uint8_t SPEED_SLOW = 160;     // Precision mode\nstatic constexpr uint8_t SPEED_FAST = 180;     // High speed\nstatic constexpr uint8_t SPEED_BOOST = 200;    // Boost speed\nstatic constexpr uint8_t SPEED_MAX = 220;      // Maximum speed\n\n// Speed control parameters\nstatic constexpr uint8_t ACCELERATION_STEP = 25;   // Speed increase step\nstatic constexpr uint8_t BRAKE_STEP = 60;         // Speed decrease step\nstatic constexpr uint8_t TURN_SPEED = 120;        // Curve speed\nstatic constexpr uint8_t TURN_THRESHOLD = 45;     // Curve detection\nstatic constexpr uint8_t STRAIGHT_THRESHOLD = 20;  // Straight line detection\nstatic constexpr uint8_t BOOST_DURATION = 10;     // Boost time\nstatic constexpr uint8_t BOOST_INCREMENT = 20;    // Boost step\nThese speed constants and control parameters are extensively used throughout the codebase. The CourseMarkers class uses them to determine appropriate speeds for different track sections, with TURN_THRESHOLD and STRAIGHT_THRESHOLD helping identify track geometry. In the main control loop, these values drive the PID controller’s response, with ACCELERATION_STEP and BRAKE_STEP ensuring smooth speed transitions. When DEBUG_LEVEL is greater than 0, the ProfileManager modifies these base values according to the current operating mode, allowing for different performance profiles while maintaining the same core control logic.\n\n\n4.1.4 Control Parameters\nDefines the PID controller and sensor processing parameters.\n// PID Control Parameters\nstatic constexpr float K_PROPORTIONAL_DEFAULT = 5.0f;\nstatic constexpr float K_DERIVATIVE_DEFAULT = 600.0f;\nstatic constexpr float FILTER_COEFFICIENT_DEFAULT = 0.6f;\n\n// Sensor Parameters\nstatic const uint8_t NUM_SENSORES = 6;\nstatic constexpr int16_t SENSOR_MAX_VALUE = 1023;\nstatic constexpr int16_t SENSOR_MIN_VALUE = 0;\nstatic constexpr int16_t SENSOR_THRESHOLD = 120;\n\n// Sensor Weights\nstatic constexpr float SENSOR_WEIGHT_S1 = -2.5f;  // Far left\nstatic constexpr float SENSOR_WEIGHT_S2 = -1.2f;  // Left\nstatic constexpr float SENSOR_WEIGHT_S3 = -0.6f;  // Center-left\nstatic constexpr float SENSOR_WEIGHT_S4 = 0.6f;   // Center-right\nstatic constexpr float SENSOR_WEIGHT_S5 = 1.2f;   // Right\nstatic constexpr float SENSOR_WEIGHT_S6 = 2.5f;   // Far right\nThe control system parameters represent the core of the robot’s line-following behaviour. The PID controller uses carefully tuned constants, with a proportional gain (K_PROPORTIONAL_DEFAULT) of 5.0 providing immediate response to position errors, while the high derivative gain (K_DERIVATIVE_DEFAULT) of 600.0 helps predict and dampen oscillations. A filter coefficient of 0.6 balances between noise reduction and response time in the derivative calculation.\nThe sensor array consists of six sensors (NUM_SENSORES), each providing analog readings from 0 to 1023 (SENSOR_MIN_VALUE to SENSOR_MAX_VALUE). A threshold value of 120 helps distinguish between line and background surface conditions. The sensor weights are particularly crucial, implementing a distributed sensing system where outer sensors (±2.5) have greater influence than inner ones (±0.6), creating a non-linear response that enhances stability in straight lines while maintaining sensitivity to curves. These weights are asymmetrical around the center point, allowing the robot to detect and respond to position changes with increasing urgency as it deviates further from the line. When processed together in the main control loop, these parameters enable the robot to maintain precise line following while adapting to various track conditions and geometries.\n\n\n4.1.5 Timing Parameters\nControls various timing aspects of the robot’s operation.\n// Delays and Timings\nstatic const uint16_t SETUP_DELAY = 600;           // Initial setup\nstatic const uint16_t CALIBRATION_SAMPLES = 400;   // Calibration precision\nstatic const uint8_t CALIBRATION_DELAY = 30;       // Sample interval\nstatic const uint16_t STOP_DELAY = 300;            // Final stop timing\nstatic const uint16_t DEBOUNCE_DELAY = 50;         // Button debounce\nThe timing parameters, all specified in milliseconds, govern critical operational sequences of the robot. The SETUP_DELAY of 600ms allows the system to stabilize after power-up, ensuring all sensors and components are ready for operation. During calibration, the system takes 400 samples (CALIBRATION_SAMPLES) from each sensor, with a 30ms interval (CALIBRATION_DELAY) between samples, providing a comprehensive baseline for sensor readings while balancing between accuracy and calibration time - resulting in a total calibration period of approximately 12 seconds. When the robot detects its final lap marker, it initiates a controlled stop sequence lasting 300ms (STOP_DELAY), allowing for smooth deceleration. Button inputs are processed with a 50ms debounce period (DEBOUNCE_DELAY), effectively filtering out mechanical noise and contact bounce while maintaining responsive user interaction.\nThese timing values were established during the November 2024 competition where RoboZero secured second place, proving their effectiveness under competitive conditions.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "config_layer.html#global-variables-management-globals.h",
    "href": "config_layer.html#global-variables-management-globals.h",
    "title": "4  Configuration Layer",
    "section": "4.2 Global Variables Management (globals.h)",
    "text": "4.2 Global Variables Management (globals.h)\nThe globals.h file represents a strategic decision in RobotZero’s architecture, implementing a carefully selected set of global variables that require system-wide access. While global variables are generally discouraged in software development, their use here is justified by the real-time nature of the system and the Arduino Nano (@ArduinoNano)’s limited resources.\n#ifndef GLOBALS_H\n#define GLOBALS_H\n\n// Global control variables\nextern int currentSpeed;             // Base speed\nextern bool isRobotStopped;          // Robot stopped state\nextern bool isStopSequenceActive;    // Stopping sequence active\nextern int lapCount;                 // End marker counter\nextern bool isPrecisionMode;         // Slow mode active\n\n#endif // GLOBALS_H\nThe currentSpeed variable serves as the base speed reference for the entire system. It is modified by various components including the CourseMarkers class during turns, the main control loop during PID corrections, and the ProfileManager when operating in debug modes. By maintaining this as a global variable, we avoid the overhead of function calls and parameter passing in time-critical control loops.\nThe robot’s state is tracked through three critical boolean flags. isRobotStopped indicates when the robot has completed its run or encountered a stop condition, allowing all components to safely cease operations. isStopSequenceActive manages the controlled deceleration process, triggered when the robot reaches its final lap, ensuring smooth and precise stopping. The isPrecisionMode flag enables the system to switch between normal and precision operation modes, affecting speed calculations and control parameters throughout the system.\nThe lapCount variable keeps track of completed laps, crucial for both normal operation and debugging modes. In normal mode, it triggers the stop sequence after one lap, while in debug modes (controlled by DEBUG_LEVEL), it follows the specified number of laps (5 for analysis mode, 3 for speed mode).\nAll these variables are declared as external (extern) in the header file, with their actual definitions residing in main.cpp. This approach maintains proper encapsulation while allowing necessary access across the system. Each variable is initialized at system startup and modified only in specific, well-defined circumstances, ensuring predictable behaviour despite their global nature.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "config_layer.html#debug-system-configuration-debug.h",
    "href": "config_layer.html#debug-system-configuration-debug.h",
    "title": "4  Configuration Layer",
    "section": "4.3 Debug System Configuration (debug.h)",
    "text": "4.3 Debug System Configuration (debug.h)\nThe debug.h file implements an efficient debugging system that provides comprehensive diagnostic information without compromising the robot’s performance. The system’s most notable feature is its use of Flash memory for string storage, preserving valuable RAM for critical operations.\n#ifndef DEBUG_H\n#define DEBUG_H\n\n#include \"config.h\"\n#include &lt;avr/pgmspace.h&gt;\n\n// Store debug messages in Flash memory instead of RAM\nconst char DEBUG_BASE[] PROGMEM = \"Base: \";\nconst char DEBUG_ERROR[] PROGMEM = \" Error: \";\nconst char DEBUG_CORRECTION[] PROGMEM = \" Correction: \";\nconst char DEBUG_GEOMETRY[] PROGMEM = \"Geometry: \";\nconst char DEBUG_RIGHT_MARKER[] PROGMEM = \"rightMarkerDetected: \";\nconst char DEBUG_LEFT_MARKER[] PROGMEM = \" leftMarkerDetected: \";\nconst char DEBUG_A0[] PROGMEM = \" A0: \";\nconst char DEBUG_A7[] PROGMEM = \" A7: \";\nconst char DEBUG_SLOW_MODE[] PROGMEM = \"Slow mode activated\";\nconst char DEBUG_FAST_MODE[] PROGMEM = \"Fast mode activated\";\nconst char DEBUG_INTERSECTION[] PROGMEM = \"Intersection detected\";\nconst char DEBUG_SETUP_START[] PROGMEM = \"Starting setup\";\nconst char DEBUG_SETUP_COMPLETE[] PROGMEM = \"Setup completed\";\nThese string constants are stored in program memory using the PROGMEM attribute. This approach saves precious RAM space on the Arduino Nano (@ArduinoNano), which only has 2KB available. To facilitate reading these stored strings, the system implements a helper function:\n// Helper function to print strings from Flash\ninline void debugPrintFlash(const char* str) {\n    char c;\n    while ((c = pgm_read_byte(str++))) {\n        Serial.write(c);\n    }\n}\nThe system provides a set of debugging macros that are completely eliminated when debugging is disabled. These macros are defined based on the DEBUG_LEVEL configuration:\n// Debug macros - only active when DEBUG_LEVEL &gt; 0\n#if DEBUG_LEVEL &gt; 0\n#define DEBUG_BEGIN(x) Serial.begin(x)\n#define DEBUG_PRINT(x) debugPrintFlash(x)\n#define DEBUG_PRINTLN(x) do { debugPrintFlash(x); Serial.println(); } while(0)\n#define DEBUG_PRINT_VAL(x) Serial.print(x)\n#define DEBUG_PRINTLN_VAL(x) Serial.println(x)\n#else\n#define DEBUG_BEGIN(x)\n#define DEBUG_PRINT(x)\n#define DEBUG_PRINTLN(x)\n#define DEBUG_PRINT_VAL(x)\n#define DEBUG_PRINTLN_VAL(x)\n#endif\nWhen DEBUG_LEVEL is 0, these macros expand to nothing, ensuring zero overhead in the compiled code. When debugging is enabled, they provide different printing capabilities: DEBUG_PRINT and DEBUG_PRINTLN handle Flash-stored strings, while DEBUG_PRINT_VAL and DEBUG_PRINTLN_VAL handle direct value output. The do-while construct in DEBUG_PRINTLN ensures proper behaviour when the macro is used in if-else statements.\nIn practice, these macros are used throughout the codebase to provide diagnostic information. For example, during sensor readings:\nDEBUG_PRINT(\"rightMarkerDetected: \");\nDEBUG_PRINT_VAL(rightMarkerDetected);\nDEBUG_PRINT(\" leftMarkerDetected: \");\nDEBUG_PRINT_VAL(leftMarkerDetected);\nDEBUG_PRINTLN(\"\");\nThe system outputs debug information at 115200 baud when enabled, allowing real-time monitoring of the robot’s behaviour while maintaining efficient execution.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "control_layer.html",
    "href": "control_layer.html",
    "title": "5  Control Layer Implementation",
    "section": "",
    "text": "5.1 CourseMarkers Implementation\nThe CourseMarkers class manages track feature detection and robot behaviour through a state-based approach:\nThe marker detection system operates through the readCourseMarkers method, which processes analog readings from dedicated marker sensors:\nSpeed control is managed through a system that takes into account the robot’s current state and track conditions:\nThe processMarkerSignals method ties everything together, managing the robot’s response to detected markers:\nThe state machine implementation uses a combination of current and historical marker states to reliably detect track features and transitions. The system maintains four state variables:\ncurrentMarkerState: The present state based on marker sensors; lastMarkerState: The immediately previous state; previousMarkerState: The state before the last; oldMarkerState: The third previous state.\nEach marker state can be one of four conditions:\n0: No markers detected (both sensors reading 0);\n1: Left marker only (left sensor = 1, right sensor = 0);\n2: Right marker only (left sensor = 0, right sensor = 1);\n3: Both markers (both sensors reading 1);\nThe state transitions trigger specific behaviors:\nThis multi-state history approach helps filter out false readings and ensures reliable feature detection even at high speeds or under varying light conditions. Each state change is processed only once, and the system maintains proper operation even when markers are detected in rapid succession.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  },
  {
    "objectID": "control_layer.html#coursemarkers-implementation",
    "href": "control_layer.html#coursemarkers-implementation",
    "title": "5  Control Layer Implementation",
    "section": "",
    "text": "class CourseMarkers {\nprivate:\n    // State variables\n    static int speed;\n    static int lastMarkerState;\n    static int previousMarkerState;\n    static int oldMarkerState;\n    static int currentMarkerState;\n    static int16_t leftMarkerDetected;   \n    static int16_t rightMarkerDetected;  \n\n    // Speed control variables\n    static bool isTurning;\n    static bool isExitingTurn;\n    static uint8_t boostCountdown;\n\n    // Timers for precise control\n    static Timer stopTimer;\n    static Timer slowdownTimer;\n\n    // Internal methods\n    static void readCourseMarkers();\n    static void handleFinishLine();\n    static void handleSpeedMode();\n    static void handleIntersection();\n\npublic:\n    // Public methods\n    static void processMarkerSignals();\n    static int speedControl(int error);\n};\n\nvoid CourseMarkers::readCourseMarkers() {\n    leftMarkerDetected = analogRead(PIN_MARKER_LEFT);\n    rightMarkerDetected = analogRead(PIN_MARKER_RIGHT);\n\n    bool ledState = false;\n\n    if (leftMarkerDetected &gt; MARKER_DETECTION_THRESHOLD) {\n        leftMarkerDetected = 0;\n    }\n    else {\n        leftMarkerDetected = 1;\n        ledState = true;\n    }\n\n    if (rightMarkerDetected &gt; MARKER_DETECTION_THRESHOLD) {\n        rightMarkerDetected = 0;\n    }\n    else {\n        rightMarkerDetected = 1;\n        ledState = true;\n    }\n\n    digitalWrite(PIN_STATUS_LED, ledState);\n}\n\nint CourseMarkers::speedControl(int error) {\n    bool curve_detected = abs(error) &gt; TURN_THRESHOLD;\n    bool straight_detected = abs(error) &lt; STRAIGHT_THRESHOLD;\n    int target_speed;\n\n    if (curve_detected) {\n        isTurning = true;\n        isExitingTurn = false;\n        target_speed = TURN_SPEED;\n    }\n    else if (straight_detected) {\n        if (isTurning) {\n            isExitingTurn = true;\n            boostCountdown = BOOST_DURATION;\n        }\n        isTurning = false;\n        target_speed = isPrecisionMode ? SPEED_SLOW : BASE_FAST;\n    }\n    else {\n        target_speed = map(abs(error),\n            STRAIGHT_THRESHOLD,\n            TURN_THRESHOLD,\n            (isPrecisionMode ? SPEED_SLOW : BASE_FAST),\n            TURN_SPEED);\n    }\n\n    if (isExitingTurn && boostCountdown &gt; 0 && !isPrecisionMode) {\n        target_speed = min(255, target_speed + 30);\n        boostCountdown--;\n    }\n\n    int step = (target_speed &gt; currentSpeed) ? ACCELERATION_STEP : BRAKE_STEP;\n\n    if (abs(target_speed - currentSpeed) &lt;= step) {\n        currentSpeed = target_speed;\n    }\n    else {\n        currentSpeed += (target_speed &gt; currentSpeed) ? step : -step;\n    }\n\n    return constrain(currentSpeed, TURN_SPEED, \n                    (isPrecisionMode ? SPEED_SLOW : BASE_FAST));\n}\n\nvoid CourseMarkers::processMarkerSignals() {\n    readCourseMarkers();\n\n    if ((leftMarkerDetected == 0) && (rightMarkerDetected == 0)) \n        currentMarkerState = 0;\n    if ((leftMarkerDetected == 1) && (rightMarkerDetected == 0)) \n        currentMarkerState = 1;\n    if ((leftMarkerDetected == 0) && (rightMarkerDetected == 1)) \n        currentMarkerState = 2;\n    if ((leftMarkerDetected == 1) && (rightMarkerDetected == 1)) \n        currentMarkerState = 3;\n\n    if (lastMarkerState != currentMarkerState) {\n        if (currentMarkerState == 0 && lastMarkerState == 2 && \n            previousMarkerState == 0) {\n            handleFinishLine();\n        }\n        if (currentMarkerState == 0 && lastMarkerState == 1 && \n            previousMarkerState == 0) {\n            handleSpeedMode();\n        }\n        if (currentMarkerState == 0 && ((lastMarkerState == 3) || \n            (previousMarkerState == 3) || (oldMarkerState == 3))) {\n            handleIntersection();\n        }\n        oldMarkerState = previousMarkerState;\n        previousMarkerState = lastMarkerState;\n        lastMarkerState = currentMarkerState;\n    }\n\n    if (isStopSequenceActive && !isRobotStopped) {\n        if (!slowdownTimer.Expired() && currentSpeed &gt; SPEED_BRAKE) {\n            currentSpeed = SPEED_BRAKE;\n        }\n        else if (stopTimer.Expired()) {\n            currentSpeed = 0;\n            MotorDriver::setMotorsPower(0, 0);\n            isRobotStopped = true;\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\nFinish Line Detection: Identified by the sequence [0 → 2 → 0], representing a clean pass over the right marker;\nSpeed Mode Change: Detected by [0 → 1 → 0], indicating a left marker pass;\nIntersection Detection: Triggered by any sequence containing state 3 (both markers) within the last three states.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  },
  {
    "objectID": "control_layer.html#profilemanager-implementation",
    "href": "control_layer.html#profilemanager-implementation",
    "title": "5  Control Layer Implementation",
    "section": "5.2 ProfileManager Implementation",
    "text": "5.2 ProfileManager Implementation\nThe ProfileManager serves as RobotZero’s configuration system for different operating modes, providing two distinct profiles: one optimized for analysis and another for high-speed performance. This implementation is entirely conditional, only compiled when DEBUG_LEVEL is greater than 0, ensuring zero overhead during normal operation.\nclass ProfileManager {\npublic:\n    // Initialize profile manager\n    static void initialize(DebugMode mode);\n\n    // Get current debug mode\n    static DebugMode getCurrentMode();\n\n    // Get speed value based on original speed constant\n    static uint8_t getSpeedValue(uint8_t defaultSpeed);\n\n    // Get PID parameters\n    static float getKP(float defaultValue);\n    static float getKD(float defaultValue);\n    static float getFilterCoefficient(float defaultValue);\n\n    // Get acceleration parameters\n    static uint8_t getAccelerationStep();\n    static uint8_t getBrakeStep();\n    static uint8_t getTurnSpeed();\n    static uint8_t getTurnThreshold();\n    static uint8_t getStraightThreshold();\n    static uint8_t getBoostDuration();\n    static uint8_t getBoostIncrement();\n\nprivate:\n    static DebugMode currentMode;\n    static const SpeedProfile* activeProfile;\n\n    static const SpeedProfile ANALYSIS_PROFILE;\n    static const SpeedProfile SPEED_PROFILE;\n\n    static void setActiveProfile(DebugMode mode);\n    static uint8_t validateSpeed(uint8_t speed);\n};\nThe system is built around two predefined profiles, each optimized for specific purposes:\nconst SpeedProfile ProfileManager::ANALYSIS_PROFILE = {\n    // Speed settings - Conservative for analysis\n    .speedStop = 0,\n    .speedStartup = 60,    // Slower startup\n    .speedTurn = 80,       // Careful turns\n    .speedBrake = 90,      // Gentle braking\n    .speedCruise = 100,    // Moderate cruising\n    .speedSlow = 120,      // Moderate slow speed\n    .speedFast = 140,      // Moderate fast speed\n    .speedBoost = 160,     // Moderate boost\n    .speedMax = 180,       // Limited top speed\n\n    // Control parameters - Smooth operation\n    .accelerationStep = 15, // Gentle acceleration\n    .brakeStep = 40,       // Moderate braking\n    .turnSpeed = 80,       // Conservative turns\n    .turnThreshold = 50,   // Earlier turn detection\n    .straightThreshold = 25, // Stricter straight detection\n    .boostDuration = 8,    // Short boost\n    .boostIncrement = 15,  // Gentle boost\n\n    // PID parameters - Stable control\n    .kProportional = 4.0f,\n    .kDerivative = 500.0f,\n    .filterCoefficient = 0.5f\n};\n\nconst SpeedProfile ProfileManager::SPEED_PROFILE = {\n    // Speed settings - Aggressive for performance\n    .speedStop = 0,\n    .speedStartup = 100,   // Quick startup\n    .speedTurn = 120,      // Fast turns\n    .speedBrake = 140,     // Strong braking\n    .speedCruise = 160,    // Fast cruising\n    .speedSlow = 180,      // Fast slow mode\n    .speedFast = 200,      // High speed\n    .speedBoost = 220,     // Strong boost\n    .speedMax = 255,       // Maximum speed\n\n    // Control parameters - Performance focused\n    .accelerationStep = 35, // Quick acceleration\n    .brakeStep = 70,       // Strong braking\n    .turnSpeed = 140,      // Fast turns\n    .turnThreshold = 40,   // Later turn detection\n    .straightThreshold = 15, // Quicker straight detection\n    .boostDuration = 12,   // Longer boost\n    .boostIncrement = 25,  // Strong boost\n\n    // PID parameters - Aggressive control\n    .kProportional = 6.0f,\n    .kDerivative = 700.0f,\n    .filterCoefficient = 0.7f\n};\n\nImplementation Note:\nTODO: These variables should be transferred to macros or constexpr’s in the configuration layer, maintaining the system’s design principles of compile-time optimization and centralized configuration.\n\nThe translation between default values and profile-specific values is handled through the getSpeedValue method:\nuint8_t ProfileManager::getSpeedValue(uint8_t defaultSpeed) {\n    if (activeProfile == nullptr) {\n        return defaultSpeed;\n    }\n\n    // Map original speed constants to profile values\n    if (defaultSpeed == SPEED_STOP) return activeProfile-&gt;speedStop;\n    if (defaultSpeed == SPEED_STARTUP) return activeProfile-&gt;speedStartup;\n    if (defaultSpeed == SPEED_TURN) return activeProfile-&gt;speedTurn;\n    if (defaultSpeed == SPEED_BRAKE) return activeProfile-&gt;speedBrake;\n    if (defaultSpeed == SPEED_CRUISE) return activeProfile-&gt;speedCruise;\n    if (defaultSpeed == SPEED_SLOW) return activeProfile-&gt;speedSlow;\n    if (defaultSpeed == SPEED_FAST) return activeProfile-&gt;speedFast;\n    if (defaultSpeed == SPEED_BOOST) return activeProfile-&gt;speedBoost;\n    if (defaultSpeed == SPEED_MAX) return activeProfile-&gt;speedMax;\n\n    return validateSpeed(defaultSpeed);\n}\nThe Analysis Profile is designed for development and testing, with conservative speeds and gentle transitions. It prioritizes stability and predictability over raw speed, making it ideal for collecting performance data and tuning control parameters. All speed values are reduced, acceleration is gentler, and the PID parameters are tuned for stability.\nThe Speed Profile, in contrast, is optimized for maximum performance. It uses aggressive speed settings, quick transitions, and more responsive control parameters. The PID constants are increased for faster response, and the thresholds are adjusted to maintain control at higher speeds. These profiles have not yet been tested in competition conditions.\nThe ProfileManager ensures smooth operation by validating all speed values and providing fallback behaviour when no profile is active. When DEBUG_LEVEL is 0, the entire ProfileManager code is excluded from compilation, maintaining the efficiency of the production code.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  }
]