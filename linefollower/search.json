[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RobotZero",
    "section": "",
    "text": "0.1 The Platform: Arduino Nano (Arduino (2024))\nFor this project, we chose the Arduino Nano (Arduino 2024) as our main controller specifically for its constrained environment. When we can achieve efficiency and speed within such limitations, we learn how to optimize ideas, algorithms, and programs - skills that are valuable across all computing platforms. The Arduino Nano (Arduino 2024), based on the ATmega328P microcontroller, offers a small form factor (45 x 18 mm), ideal for compact robot designs. It includes 32KB of Flash memory, suitable for our advanced logging system, 2KB of SRAM for runtime operations, and runs at 16MHz, providing adequate processing power. The board features multiple analog inputs for our sensor array, PWM outputs for precise motor control, and maintains low power consumption while being cost-effective for both prototyping and final implementation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#project-overview",
    "href": "index.html#project-overview",
    "title": "RobotZero",
    "section": "0.2 Project Overview",
    "text": "0.2 Project Overview\nIn most projects, adjusting a line following robot for speed and efficiency becomes a tedious and time-consuming trial-and-error routine. Our project addresses this challenge by incorporating an advanced logging and analysis system that transforms the tuning process into a data-driven approach. The robot includes high-precision line detection using a 6-sensor array, PID-based motion control for smooth operation, and dual operating modes for analysis and high-speed performance. The comprehensive data logging system enables real-time performance monitoring, with flash-based storage for post-run analysis and a USB interface for data retrieval and analysis, providing the tools necessary for systematic testing and configuration.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#why-c",
    "href": "index.html#why-c",
    "title": "RobotZero",
    "section": "0.3 Why C++?",
    "text": "0.3 Why C++?\nThe choice of C++ as our programming language was deliberate and based on several key factors. C++ allows us to organize our code into logical classes and modules, making the system more maintainable and easier to understand. This is particularly important for complex systems like our logging mechanism. The language provides low-level hardware access while supporting high-level abstractions, crucial for real-time operations where microseconds matter, such as sensor reading and motor control.\nWith limited resources on the Arduino Nano (Arduino 2024), C++’s efficient memory management and minimal runtime overhead are essential. We can precisely control memory allocation and ensure optimal use of the available RAM. The language’s support for namespaces, classes, and templates helps maintain clean code architecture despite the system’s complexity. C++’s strong type system helps catch errors at compile-time rather than runtime, which is crucial for a system that needs to operate autonomously. Additionally, C++ allows us to create clean abstractions over hardware components while maintaining direct access when needed, making the code both maintainable and efficient. The object-oriented features facilitate code reuse and modular design, making it easier to extend or modify the robot’s functionality.\nThe combination of Arduino Nano (Arduino 2024)’s capabilities with C++’s features allows us to create a line following robot that not only performs its primary function but also provides valuable insights into its operation through advanced logging and analysis capabilities.\n\n\n\n\nArduino. 2024. “Arduino Nano (@ArduinoNano).” 2024. https://docs.arduino.cc/hardware/nano/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "oper.html",
    "href": "oper.html",
    "title": "2  Line Following Robot Operation",
    "section": "",
    "text": "2.1 Operating Procedure",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Line Following Robot Operation</span>"
    ]
  },
  {
    "objectID": "oper.html#operating-procedure",
    "href": "oper.html#operating-procedure",
    "title": "2  Line Following Robot Operation",
    "section": "",
    "text": "2.1.1 Initial Setup\n\nPlace the robot near the course\nPower on the robot\nWait for initial setup delay (600ms)\n\nStatus LED will be on during this period\nMotors will be inactive\n\nAfter delay, LED turns off and robot is ready for calibration\n\n\n\n2.1.2 Calibration Process\n\nPress the start button for first calibration phase\n\nLED will turn on\n\nThe calibration process:\n\nTakes 400 samples from each sensor\n30ms delay between samples (total ~12 seconds)\nEstablishes minimum and maximum values for each sensor\n\nAfter calibration completes:\n\nLED turns off\nRobot waits for second button press\n\n\n\n\n2.1.3 Operation Start\n\nPlace robot on the track\nPress start button again to begin operation\n\nLED turns on\nRobot starts line following operation\n\nInitial operating parameters:\n\nSpeed mode begins at BASE_FAST (115)\nPID control active with default parameters\nNormal operating mode engaged\n\n\n\n\n2.1.4 During Operation\nThe robot recognizes three marker patterns: 1. Finish line marker (both sensors) - Updates lap count - Triggers stop sequence on second detection 2. Speed mode marker (left sensor only) - Toggles between normal and precision mode - In precision mode: SPEED_SLOW - In normal mode: BASE_FAST 3. Intersection marker (both sensors) - Logged but no special action taken\n\n\n2.1.5 Stop Sequence\nThe robot will stop automatically when: 1. Second finish line is detected 2. Stop sequence activates: - Speed reduces to SPEED_BRAKE - After 50ms deceleration - Final stop after 300ms - Motors power off\n\n\n2.1.6 Data Retrieval (Debug Mode Only)\nIf DEBUG_LEVEL &gt; 0: 1. When robot stops, flash memory is marked as ready 2. LED displays transmission pattern: - Alternates between slow blink (1000ms) and fast blink (300ms) - Pattern switches every 3000ms 3. Data can be retrieved through serial interface 4. After successful transmission: - Log ready flag is cleared - LED pattern stops\n\n\n2.1.7 Error Recovery\nIf line is lost: 1. Robot uses last valid position 2. Position is forced to extreme (-100 or 100) based on last direction 3. PID controller attempts to recover 4. Robot continues operation if line is found\n\n\n2.1.8 Operating Modes\nTwo base operating speeds: 1. Normal Mode (BASE_FAST): - Base speed of 115 - Curve speed reduction active - Boost after curves (if not in precision mode)\n\nPrecision Mode:\n\nActivated by left marker\nUses SPEED_SLOW\nDisables boost feature\nMore conservative operation\n\n\nDebug Operating Modes (if DEBUG_LEVEL &gt; 0): 1. Analysis Mode (DEBUG_LEVEL = 1): - 5 laps - Conservative speeds - Full data logging\n\nSpeed Mode (DEBUG_LEVEL = 2):\n\n3 laps\nMaximum performance\nFull data logging",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Line Following Robot Operation</span>"
    ]
  },
  {
    "objectID": "block.html",
    "href": "block.html",
    "title": "3  RoboZero Modules Description",
    "section": "",
    "text": "3.1 Configuration Layer",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#configuration-layer",
    "href": "block.html#configuration-layer",
    "title": "3  RoboZero Modules Description",
    "section": "",
    "text": "3.1.1 config.h\nThe configuration hub of the system, this module defines all crucial parameters including pin assignments, speed settings, and control constants. A notable feature is its use of conditional compilation (#if DEBUG_LEVEL &gt; 0) to ensure zero overhead in normal operation mode, demonstrating our commitment to efficiency.\n\n\n3.1.2 globals.h\nManages global state variables that need to be accessed across different modules. While global variables are generally discouraged, here they serve a crucial role in maintaining real-time performance by avoiding function call overhead for frequently accessed states.\n\n\n3.1.3 debug.h\nImplements a debug message system that stores strings in Flash memory instead of RAM, using PROGMEM for optimal memory usage. This approach ensures that debug capabilities don’t impact the robot’s limited RAM resources.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#hardware-interface-layer",
    "href": "block.html#hardware-interface-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.2 Hardware Interface Layer",
    "text": "3.2 Hardware Interface Layer\n\n3.2.1 Sensors\nManages six line sensors and two marker sensors through a calibration-based approach. The unique feature here is the weighted average calculation that provides precise positional data. The system maintains both raw and processed values, enabling real-time adjustments while preserving original readings for analysis.\n\n\n3.2.2 MotorsDrivers\nImplements motor control using PWM, with a key feature being its ability to handle both forward and reverse motion through a single interface. The module includes built-in protection against invalid PWM values, ensuring safe operation even under software errors.\n\n\n3.2.3 Peripherals\nHandles external interfaces including button input and LED status indication. Notable is its debounce implementation that maintains responsiveness while ensuring reliable button detection, essential for both operation and calibration phases.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#control-layer",
    "href": "block.html#control-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.3 Control Layer",
    "text": "3.3 Control Layer",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#debug-layer",
    "href": "block.html#debug-layer",
    "title": "3  RoboZero Modules Description",
    "section": "4.1 Debug Layer",
    "text": "4.1 Debug Layer\n\n4.1.1 Logger\nImplements a logging system using circular buffers to maintain performance. A key feature is its ability to write to flash memory only during straight-line sections, ensuring logging doesn’t interfere with critical control operations.\n\n\n4.1.2 FlashManager\nHandles flash memory operations with built-in error checking and recovery mechanisms. Notable is its page-aligned writing system that maximizes flash memory lifespan while ensuring data integrity.\n\n\n4.1.3 FlashReader\nManages data retrieval through a structured protocol, including checksums for data validation. The module implements a multi-marker system to ensure reliable data transmission even under noisy serial connections.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#main-control",
    "href": "block.html#main-control",
    "title": "3  RoboZero Modules Description",
    "section": "4.2 Main Control",
    "text": "4.2 Main Control\n\n4.2.1 main.cpp\nThe core control loop implementing PID-based line following. A significant feature is its non-blocking setup sequence that maintains system responsiveness during initialization and calibration. The module seamlessly integrates debug features when compiled with DEBUG_LEVEL &gt; 0 while maintaining optimal performance in normal operation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "config_layer.html",
    "href": "config_layer.html",
    "title": "4  Configuration Layer",
    "section": "",
    "text": "4.1 Configuration Values (config.h)\nThe config.h file is structured into logical sections, each handling specific aspects of the robot’s configuration. Let’s examine each section in detail:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "config_layer.html#configuration-values-config.h",
    "href": "config_layer.html#configuration-values-config.h",
    "title": "4  Configuration Layer",
    "section": "",
    "text": "4.1.1 Debug Configuration\nThis section controls the debugging features of the system. The DEBUG_LEVEL setting determines the robot’s operating mode and what features are compiled into the final binary.\n// Set to 1 for analysis mode, 2 for speed mode, or 0 for normal operation\n#ifndef DEBUG_LEVEL\n#define DEBUG_LEVEL 0\n#endif\n\n#if DEBUG_LEVEL &gt; 0\n#include \"DataStructures.h\"  // Include debug-related structures\n\n// Debug configuration\nstatic constexpr uint8_t DEBUG_LAPS_MODE1 = 5;    // Analysis mode laps\nstatic constexpr uint8_t DEBUG_LAPS_MODE2 = 3;    // Speed mode laps\n\n// Logging parameters\nstatic constexpr uint16_t SAMPLE_RATE_STRAIGHT = 50;   // Sampling in straight lines\nstatic constexpr uint16_t SAMPLE_RATE_CURVE = 20;      // Sampling in curves\nstatic constexpr uint16_t LOG_BUFFER_SIZE = 64;        // Circular buffer size\n\n// Flash memory parameters\nstatic constexpr uint32_t FLASH_LOG_START = 0x1000;    // Log start address\nstatic constexpr uint16_t FLASH_PAGE_SIZE = 256;       // Flash page size\nstatic constexpr uint32_t FLASH_CONTROL_BYTE = 0x0800; // Control byte location\nstatic constexpr uint8_t FLASH_LOG_READY = 0xAA;       // Log ready indicator\n#endif\nThe debug configuration implements a conditional compilation system that ensures optimal performance in normal operation. When DEBUG_LEVEL is set to 0, all debugging code is completely excluded from the final binary, resulting in no runtime overhead. Setting DEBUG_LEVEL to 1 activates the analysis mode, where the robot operates at moderate speeds and collects comprehensive data about its performance, including position errors, motor speeds, and PID corrections, completing 5 laps for detailed analysis. In speed mode, activated with DEBUG_LEVEL 2, the robot performs 3 laps at maximum speed while still collecting performance data, allowing for optimization of high-speed behaviour. The system adjusts its sampling rate based on track conditions - sampling more frequently in curves where behaviour is more dynamic, and at a lower rate in straight sections to conserve memory. All collected data is stored in a structured format in flash memory, organized to maximize data integrity and facilitate post-run analysis.\nThe flash memory organization is carefully structured to maximize efficiency and reliability. The logging system begins storing data at address 0x1000 (FLASH_LOG_START), providing ample space for system data in lower memory addresses. Each page of flash memory is 256 bytes (FLASH_PAGE_SIZE), allowing efficient writing operations that balance between memory usage and write cycles. A control byte located at address 0x0800 (FLASH_CONTROL_BYTE) serves as a state indicator for the logging system. When this byte contains the value 0xAA (FLASH_LOG_READY), it signals that valid performance data is available for retrieval, ensuring proper synchronization between data logging and retrieval operations.\n\n\n4.1.2 Pin Configuration\nDefines all hardware connections, centralizing pin assignments for easy modification and hardware revision control.\n// Only modify if changing physical robot connections\nstatic const uint8_t PIN_START_BUTTON = 11;      // Start/calibrate button\nstatic const uint8_t PIN_STATUS_LED = 13;        // Status LED\nstatic const uint8_t PIN_MOTOR_LEFT_FWD = 7;     // Left Motor Forward\nstatic const uint8_t PIN_MOTOR_LEFT_REV = 4;     // Left Motor Reverse\nstatic const uint8_t PIN_MOTOR_LEFT_PWM = 3;     // Left Motor Speed\nstatic const uint8_t PIN_MOTOR_RIGHT_FWD = 8;    // Right Motor Forward\nstatic const uint8_t PIN_MOTOR_RIGHT_REV = 9;    // Right Motor Reverse\nstatic const uint8_t PIN_MOTOR_RIGHT_PWM = 10;   // Right Motor Speed\n\n// Sensor pins\nstatic const uint8_t PIN_LINE_LEFT_EDGE = A6;    // Leftmost sensor\nstatic const uint8_t PIN_LINE_LEFT_MID = A5;\nstatic const uint8_t PIN_LINE_CENTER_LEFT = A4;\nstatic const uint8_t PIN_LINE_CENTER_RIGHT = A3;\nstatic const uint8_t PIN_LINE_RIGHT_MID = A2;\nstatic const uint8_t PIN_LINE_RIGHT_EDGE = A1;   // Rightmost sensor\nstatic const uint8_t PIN_MARKER_LEFT = A7;       // Left marker\nstatic const uint8_t PIN_MARKER_RIGHT = A0;      // Right marker\nThe pin configuration employs a systematic approach to hardware interface management. Each pin assignment is thoroughly documented with clear comments indicating its purpose, from motor control signals to sensor inputs, making hardware modifications and debugging straightforward. Related pins are logically grouped together - motor control pins are clustered by function (forward, reverse, and PWM for each motor), while sensor pins are arranged according to their physical layout on the robot (from left edge to right edge). The use of static const declarations for pin assignments not only makes the code more readable but also allows the compiler to optimize memory usage by storing these values in program memory rather than RAM. This approach maintains flexibility for hardware modifications while ensuring efficient runtime performance, as these values are resolved at compile time rather than being calculated during program execution.\n\n\n4.1.3 Speed Parameters\nDefines the various speed levels used by the robot, providing a comprehensive speed control system.\n// Base speeds - do not modify without thorough testing\nstatic constexpr uint8_t SPEED_STOP = 0;       // Stopped\nstatic constexpr uint8_t SPEED_STARTUP = 80;   // Initial movement\nstatic constexpr uint8_t SPEED_TURN = 100;     // Turn speed\nstatic constexpr uint8_t SPEED_BRAKE = 120;    // Braking speed\nstatic constexpr uint8_t SPEED_CRUISE = 140;   // Medium speed\nstatic constexpr uint8_t SPEED_SLOW = 160;     // Precision mode\nstatic constexpr uint8_t SPEED_FAST = 180;     // High speed\nstatic constexpr uint8_t SPEED_BOOST = 200;    // Boost speed\nstatic constexpr uint8_t SPEED_MAX = 220;      // Maximum speed\n\n// Speed control parameters\nstatic constexpr uint8_t ACCELERATION_STEP = 25;   // Speed increase step\nstatic constexpr uint8_t BRAKE_STEP = 60;         // Speed decrease step\nstatic constexpr uint8_t TURN_SPEED = 120;        // Curve speed\nstatic constexpr uint8_t TURN_THRESHOLD = 45;     // Curve detection\nstatic constexpr uint8_t STRAIGHT_THRESHOLD = 20;  // Straight line detection\nstatic constexpr uint8_t BOOST_DURATION = 10;     // Boost time\nstatic constexpr uint8_t BOOST_INCREMENT = 20;    // Boost step\nThese speed constants and control parameters are extensively used throughout the codebase. The CourseMarkers class uses them to determine appropriate speeds for different track sections, with TURN_THRESHOLD and STRAIGHT_THRESHOLD helping identify track geometry. In the main control loop, these values drive the PID controller’s response, with ACCELERATION_STEP and BRAKE_STEP ensuring smooth speed transitions. When DEBUG_LEVEL is greater than 0, the ProfileManager modifies these base values according to the current operating mode, allowing for different performance profiles while maintaining the same core control logic.\n\n\n4.1.4 Control Parameters\nDefines the PID controller and sensor processing parameters.\n// PID Control Parameters\nstatic constexpr float K_PROPORTIONAL_DEFAULT = 5.0f;\nstatic constexpr float K_DERIVATIVE_DEFAULT = 600.0f;\nstatic constexpr float FILTER_COEFFICIENT_DEFAULT = 0.6f;\n\n// Sensor Parameters\nstatic const uint8_t NUM_SENSORES = 6;\nstatic constexpr int16_t SENSOR_MAX_VALUE = 1023;\nstatic constexpr int16_t SENSOR_MIN_VALUE = 0;\nstatic constexpr int16_t SENSOR_THRESHOLD = 120;\n\n// Sensor Weights\nstatic constexpr float SENSOR_WEIGHT_S1 = -2.5f;  // Far left\nstatic constexpr float SENSOR_WEIGHT_S2 = -1.2f;  // Left\nstatic constexpr float SENSOR_WEIGHT_S3 = -0.6f;  // Center-left\nstatic constexpr float SENSOR_WEIGHT_S4 = 0.6f;   // Center-right\nstatic constexpr float SENSOR_WEIGHT_S5 = 1.2f;   // Right\nstatic constexpr float SENSOR_WEIGHT_S6 = 2.5f;   // Far right\nThe control system parameters represent the core of the robot’s line-following behaviour. The PID controller uses carefully tuned constants, with a proportional gain (K_PROPORTIONAL_DEFAULT) of 5.0 providing immediate response to position errors, while the high derivative gain (K_DERIVATIVE_DEFAULT) of 600.0 helps predict and dampen oscillations. A filter coefficient of 0.6 balances between noise reduction and response time in the derivative calculation.\nThe sensor array consists of six sensors (NUM_SENSORES), each providing analog readings from 0 to 1023 (SENSOR_MIN_VALUE to SENSOR_MAX_VALUE). A threshold value of 120 helps distinguish between line and background surface conditions. The sensor weights are particularly crucial, implementing a distributed sensing system where outer sensors (±2.5) have greater influence than inner ones (±0.6), creating a non-linear response that enhances stability in straight lines while maintaining sensitivity to curves. These weights are asymmetrical around the center point, allowing the robot to detect and respond to position changes with increasing urgency as it deviates further from the line. When processed together in the main control loop, these parameters enable the robot to maintain precise line following while adapting to various track conditions and geometries.\n\n\n4.1.5 Timing Parameters\nThe timing parameters control various time-dependent aspects of the robot’s operation, each carefully tuned for optimal performance:\n// Delays and Timings\nstatic const uint16_t SETUP_DELAY = 600;           // Initial setup\nstatic const uint16_t CALIBRATION_SAMPLES = 400;   // Calibration precision\nstatic const uint8_t CALIBRATION_DELAY = 30;       // Sample interval\nstatic const uint16_t STOP_DELAY = 300;            // Final stop timing\nstatic const uint16_t DEBOUNCE_DELAY = 50;         // Button debounce\nstatic constexpr uint16_t MARKER_READ_INTERVAL = 2; // Marker reading interval\nEach timing parameter serves a specific purpose in the system:\n\nSETUP_DELAY (600ms): Allows system stabilization after power-up\nCALIBRATION_SAMPLES (400) and CALIBRATION_DELAY (30ms): Controls sensor calibration timing\nSTOP_DELAY (300ms): Controls gradual deceleration sequence\nDEBOUNCE_DELAY (50ms): Ensures reliable button operation\nMARKER_READ_INTERVAL (2ms): Controls the frequency of marker sensor readings\n\nThe MARKER_READ_INTERVAL parameter is particularly crucial for the CourseMarkers system. It ensures consistent and efficient marker detection by establishing a fixed interval between marker sensor readings. This 2ms interval was chosen to balance between: Detection reliability (frequent enough to not miss markers); Processing efficiency (not reading unnecessarily often) and System responsiveness (minimal delay in marker detection).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "config_layer.html#global-variables-management-globals.h",
    "href": "config_layer.html#global-variables-management-globals.h",
    "title": "4  Configuration Layer",
    "section": "4.2 Global Variables Management (globals.h)",
    "text": "4.2 Global Variables Management (globals.h)\nThe globals.h file represents a strategic decision in RobotZero’s architecture, implementing a carefully selected set of global variables that require system-wide access. While global variables are generally discouraged in software development, their use here is justified by the real-time nature of the system and the Arduino Nano’s (Arduino 2024) limited resources.\n#ifndef GLOBALS_H\n#define GLOBALS_H\n\n// Global control variables\nextern int currentSpeed;             // Base speed\nextern bool isRobotStopped;          // Robot stopped state\nextern bool isStopSequenceActive;    // Stopping sequence active\nextern int lapCount;                 // End marker counter\nextern bool isPrecisionMode;         // Slow mode active\n\n#endif // GLOBALS_H\nThe currentSpeed variable serves as the base speed reference for the entire system. It is modified by various components including the CourseMarkers class during turns, the main control loop during PID corrections, and the ProfileManager when operating in debug modes. By maintaining this as a global variable, we avoid the overhead of function calls and parameter passing in time-critical control loops.\nThe robot’s state is tracked through three critical boolean flags. isRobotStopped indicates when the robot has completed its run or encountered a stop condition, allowing all components to safely cease operations. isStopSequenceActive manages the controlled deceleration process, triggered when the robot reaches its final lap, ensuring smooth and precise stopping. The isPrecisionMode flag enables the system to switch between normal and precision operation modes, affecting speed calculations and control parameters throughout the system.\nThe lapCount variable keeps track of completed laps, crucial for both normal operation and debugging modes. In normal mode, it triggers the stop sequence after one lap, while in debug modes (controlled by DEBUG_LEVEL), it follows the specified number of laps (5 for analysis mode, 3 for speed mode).\nAll these variables are declared as external (extern) in the header file, with their actual definitions residing in main.cpp. This approach maintains proper encapsulation while allowing necessary access across the system. Each variable is initialized at system startup and modified only in specific, well-defined circumstances, ensuring predictable behaviour despite their global nature.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "config_layer.html#debug-system-configuration-debug.h",
    "href": "config_layer.html#debug-system-configuration-debug.h",
    "title": "4  Configuration Layer",
    "section": "4.3 Debug System Configuration (debug.h)",
    "text": "4.3 Debug System Configuration (debug.h)\nThe debug.h file implements an efficient debugging system that provides comprehensive diagnostic information without compromising the robot’s performance. The system’s most notable feature is its use of Flash memory for string storage, preserving valuable RAM for critical operations.\n#ifndef DEBUG_H\n#define DEBUG_H\n\n#include \"config.h\"\n#include &lt;avr/pgmspace.h&gt;\n\n// Store debug messages in Flash memory instead of RAM\nconst char DEBUG_BASE[] PROGMEM = \"Base: \";\nconst char DEBUG_ERROR[] PROGMEM = \" Error: \";\nconst char DEBUG_CORRECTION[] PROGMEM = \" Correction: \";\nconst char DEBUG_GEOMETRY[] PROGMEM = \"Geometry: \";\nconst char DEBUG_RIGHT_MARKER[] PROGMEM = \"rightMarkerDetected: \";\nconst char DEBUG_LEFT_MARKER[] PROGMEM = \" leftMarkerDetected: \";\nconst char DEBUG_A0[] PROGMEM = \" A0: \";\nconst char DEBUG_A7[] PROGMEM = \" A7: \";\nconst char DEBUG_SLOW_MODE[] PROGMEM = \"Slow mode activated\";\nconst char DEBUG_FAST_MODE[] PROGMEM = \"Fast mode activated\";\nconst char DEBUG_INTERSECTION[] PROGMEM = \"Intersection detected\";\nconst char DEBUG_SETUP_START[] PROGMEM = \"Starting setup\";\nconst char DEBUG_SETUP_COMPLETE[] PROGMEM = \"Setup completed\";\nThese string constants are stored in program memory using the PROGMEM attribute. This approach saves precious RAM space on the Arduino Nano (Arduino 2024), which only has 2KB available. To facilitate reading these stored strings, the system implements a helper function:\n// Helper function to print strings from Flash\ninline void debugPrintFlash(const char* str) {\n    char c;\n    while ((c = pgm_read_byte(str++))) {\n        Serial.write(c);\n    }\n}\nThe system provides a set of debugging macros that are completely eliminated when debugging is disabled. These macros are defined based on the DEBUG_LEVEL configuration:\n// Debug macros - only active when DEBUG_LEVEL &gt; 0\n#if DEBUG_LEVEL &gt; 0\n#define DEBUG_BEGIN(x) Serial.begin(x)\n#define DEBUG_PRINT(x) debugPrintFlash(x)\n#define DEBUG_PRINTLN(x) do { debugPrintFlash(x); Serial.println(); } while(0)\n#define DEBUG_PRINT_VAL(x) Serial.print(x)\n#define DEBUG_PRINTLN_VAL(x) Serial.println(x)\n#else\n#define DEBUG_BEGIN(x)\n#define DEBUG_PRINT(x)\n#define DEBUG_PRINTLN(x)\n#define DEBUG_PRINT_VAL(x)\n#define DEBUG_PRINTLN_VAL(x)\n#endif\nWhen DEBUG_LEVEL is 0, these macros expand to nothing, ensuring zero overhead in the compiled code. When debugging is enabled, they provide different printing capabilities: DEBUG_PRINT and DEBUG_PRINTLN handle Flash-stored strings, while DEBUG_PRINT_VAL and DEBUG_PRINTLN_VAL handle direct value output. The do-while construct in DEBUG_PRINTLN ensures proper behaviour when the macro is used in if-else statements.\nIn practice, these macros are used throughout the codebase to provide diagnostic information. For example, during sensor readings:\nDEBUG_PRINT(\"rightMarkerDetected: \");\nDEBUG_PRINT_VAL(rightMarkerDetected);\nDEBUG_PRINT(\" leftMarkerDetected: \");\nDEBUG_PRINT_VAL(leftMarkerDetected);\nDEBUG_PRINTLN(\"\");\nThe system outputs debug information at 115200 baud when enabled, allowing real-time monitoring of the robot’s behaviour while maintaining efficient execution.\n\n\n\n\nArduino. 2024. “Arduino Nano (@ArduinoNano).” 2024. https://docs.arduino.cc/hardware/nano/.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Configuration Layer</span>"
    ]
  },
  {
    "objectID": "control_layer.html",
    "href": "control_layer.html",
    "title": "5  Control Layer Implementation",
    "section": "",
    "text": "6 CourseMarkers Implementation\nThe CourseMarkers class represents a control component implementing track feature detection and robot behaviour management through an optimized state-based approach. This implementation focuses on efficient timing control, reliable marker detection, and seamless integration with both the debug system and main control loop.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  },
  {
    "objectID": "control_layer.html#core-architecture",
    "href": "control_layer.html#core-architecture",
    "title": "5  Control Layer Implementation",
    "section": "6.1 Core Architecture",
    "text": "6.1 Core Architecture\nclass CourseMarkers {\nprivate:\n    // Timing control\n    static uint32_t lastReadTime;\n    static const uint16_t MARKER_READ_INTERVAL = 2;  // 2ms read interval\n    \n    // State tracking\n    static int speed;\n    static int lastMarkerState;\n    static int previousMarkerState;\n    static int oldMarkerState;\n    static int currentMarkerState;\n    static int16_t leftMarkerDetected;   \n    static int16_t rightMarkerDetected;  \n\n    // Motion control\n    static bool isTurning;\n    static bool isExitingTurn;\n    static uint8_t boostCountdown;\n\n    // Timing control\n    static Timer stopTimer;\n    static Timer slowdownTimer;\n};\nThe implementation utilizes a set of static members to maintain system state while minimizing memory usage. Key innovations include:\n\nTime-Controlled Operation: The system implements a precise timing mechanism that regulates marker reading frequency:\nvoid readCourseMarkers() {\n    uint32_t currentTime = millis();\n    if (currentTime - lastReadTime &lt; MARKER_READ_INTERVAL) {\n        return;\n    }\n    lastReadTime = currentTime;\n\n    // Optimized marker reading\n    bool leftDetected = analogRead(PIN_MARKER_LEFT) &lt;= MARKER_DETECTION_THRESHOLD;\n    bool rightDetected = analogRead(PIN_MARKER_RIGHT) &lt;= MARKER_DETECTION_THRESHOLD;\n    currentMarkerState = (leftDetected &lt;&lt; 1) | rightDetected;\n\n    digitalWrite(PIN_STATUS_LED, leftDetected || rightDetected);\n}\nThis time-controlled approach ensures consistent sampling intervals while preventing unnecessary processor load. The 2ms interval was chosen based on empirical testing to balance between reliable detection and system performance.\nState Machine Implementation: The system maintains a three-level state history (current, previous, and old) enabling pattern recognition:\nswitch (currentMarkerState) {\ncase 0: // No markers\n    if (lastMarkerState == 2 && previousMarkerState == 0) {\n        handleFinishLine();\n    }\n    else if (lastMarkerState == 1 && previousMarkerState == 0) {\n        handleSpeedMode();\n    }\n    else if (lastMarkerState == 3 || previousMarkerState == 3 || \n             oldMarkerState == 3) {\n        handleIntersection();\n    }\n    break;\n}\n\nThe state machine processes four distinct states: - State 0: No markers detected; - State 1: Left marker only; - State 2: Right marker only; - State 3: Both markers detected.\n\nSpeed Control System: Implements an optimized decision tree for rapid response:\nint CourseMarkers::speedControl(int error) {\n    // Early curve detection\n    bool curve_detected = abs(error) &gt; TURN_THRESHOLD;\n    if (curve_detected) {\n        isTurning = true;\n        isExitingTurn = false;\n        return TURN_SPEED;\n    }\n\n    bool straight_detected = abs(error) &lt; STRAIGHT_THRESHOLD;\n    int target_speed;\n\n    if (straight_detected) {\n        if (isTurning) {\n            isExitingTurn = true;\n            boostCountdown = BOOST_DURATION;\n        }\n        isTurning = false;\n        target_speed = isPrecisionMode ? SPEED_SLOW : BASE_FAST;\n    }\n    else {\n        target_speed = map(abs(error),\n            STRAIGHT_THRESHOLD,\n            TURN_THRESHOLD,\n            (isPrecisionMode ? SPEED_SLOW : BASE_FAST),\n            TURN_SPEED);\n    }\n\n    // Boost control\n    if (isExitingTurn && boostCountdown &gt; 0 && !isPrecisionMode) {\n        target_speed = min(255, target_speed + BOOST_INCREMENT);\n        boostCountdown--;\n    }\n\n    // Speed adjustment\n    int step = (target_speed &gt; currentSpeed) ? ACCELERATION_STEP : BRAKE_STEP;\n    if (abs(target_speed - currentSpeed) &lt;= step) {\n        currentSpeed = target_speed;\n    }\n    else {\n        currentSpeed += (target_speed &gt; currentSpeed) ? step : -step;\n    }\n\n    return constrain(currentSpeed, TURN_SPEED, \n                    (isPrecisionMode ? SPEED_SLOW : BASE_FAST));\n}\nDebug Integration: When DEBUG_LEVEL &gt; 0, the system integrates with the logging framework:\nvoid handleFinishLine() {\n    lapCount++;\n    if (lapCount == 2 && !isStopSequenceActive) {\n        isStopSequenceActive = true;\n        slowdownTimer.Start(50);\n        stopTimer.Start(STOP_DELAY);\n#if DEBUG_LEVEL &gt; 0\n        FlashManager::setLogReady();\n#endif\n    }\n}\nEvent Handling: The system implements specialized handlers for different track features:\n\nhandleFinishLine(): Manages lap counting and stop sequence;\nhandleSpeedMode(): Controls precision/speed mode transitions;\nhandleIntersection(): Logs intersection detection.\n\n\n\n6.1.1 State Management\nThe state management system operates through a decision tree (Figure 1), processing marker states in the processMarkerSignals method. The decision process begins with a read operation that captures the current state of both markers, encoding them into a single value through binary manipulation: the right marker contributes the least significant bit (1), while the left marker sets the second bit (2), resulting in four possible states (0: no markers, 1: left only, 2: right only, 3: both markers).\n\n\n\nCourse Markers, decision tree diagram.\n\n\nBefore entering the main decision logic, the system performs a critical optimization check: if the current state matches the last state (lastMarkerState == currentMarkerState), the method returns immediately, preventing unnecessary processing cycles. This early-return mechanism significantly reduces CPU load during steady-state operation when no markers are being detected.\nUpon detecting a state change, the system enters its primary decision sequence. The root decision node examines the current state, with special emphasis on the ‘no markers’ state (0). When in state 0, the system traverses a carefully ordered sequence of pattern checks, each designed to identify specific track features through state history analysis. The sequence is deliberately ordered by priority: finish line detection takes precedence, followed by speed mode transitions, and finally intersection detection.\nThe finish line check looks for a specific pattern: a right marker only (state 2) followed by no markers, with the previous state also being no markers (lastMarkerState == 2 && previousMarkerState == 0). This three-state sequence definitively identifies the finish line pattern while rejecting spurious signals. When detected, handleFinishLine() executes, incrementing the lap counter and potentially initiating the stopping sequence.\nIf the finish line pattern isn’t matched, the system checks for speed mode transitions by looking for a left marker only (state 1) followed by a history of no markers (previousMarkerState == 0). This pattern triggers a complete mode transition through handleSpeedMode(), which orchestrates a comprehensive state reset. The speed mode handler not only toggles between precision and normal operation but also ensures a clean transition by resetting all motion-related states:\nvoid handleSpeedMode() {\n    isPrecisionMode = !isPrecisionMode;\n    currentSpeed = isPrecisionMode ? SPEED_SLOW : BASE_FAST;\n    isTurning = false;\n    isExitingTurn = false;\n    boostCountdown = 0;\n}\nThe final check in the decision sequence examines whether any of the three previous states indicated both markers were detected (state 3). This more permissive check allows for intersection detection regardless of the exact sequence of marker readings, accommodating various approach angles and speeds. The handleIntersection() call logs the event but maintains current robot behaviour, as intersections don’t require specific responses in the current implementation.\nAfter processing through the decision tree, the system executes its state history update, shifting each state one position in the history chain (oldMarkerState = previousMarkerState; previousMarkerState = lastMarkerState; lastMarkerState = currentMarkerState). This shift operation maintains the continuous state history required for pattern detection while minimizing memory usage through reuse of existing variables.\nThe process concludes with a check of the stopping sequence flags. When active, the stop sequence implements a two-phase deceleration: first reducing speed to SPEED_BRAKE if the slowdown timer hasn’t expired, then bringing the robot to a complete stop once the stop timer completes. This gradual stopping process ensures smooth deceleration while maintaining control throughout the stopping sequence.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  },
  {
    "objectID": "control_layer.html#integration-with-debug-layer",
    "href": "control_layer.html#integration-with-debug-layer",
    "title": "5  Control Layer Implementation",
    "section": "6.2 Integration with Debug Layer",
    "text": "6.2 Integration with Debug Layer\nWhen operating in debug mode (DEBUG_LEVEL &gt; 0), the system provides comprehensive data collection:\n\nEvent Logging:\n\nState transitions\nSpeed mode changes\nIntersection detections\nFinish line crossings\n\nPerformance Monitoring:\n\nSpeed adjustments\nTurn detection\nBoost activation\n\nStop Sequence Management:\nif (isStopSequenceActive && !isRobotStopped) {\n    if (!slowdownTimer.Expired() && currentSpeed &gt; SPEED_BRAKE) {\n        currentSpeed = SPEED_BRAKE;\n    }\n    else if (stopTimer.Expired()) {\n        currentSpeed = 0;\n        MotorDriver::setMotorsPower(0, 0);\n        isRobotStopped = true;\n    }\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  },
  {
    "objectID": "control_layer.html#timing-considerations",
    "href": "control_layer.html#timing-considerations",
    "title": "5  Control Layer Implementation",
    "section": "6.3 Timing Considerations",
    "text": "6.3 Timing Considerations\nThe timing system implementation represents a critical aspect of RobotZero’s control architecture, orchestrating multiple time-sensitive operations through carefully calibrated intervals. At its core, the marker detection system operates on a fixed 2ms sampling interval, implemented through a time-difference check at the start of each reading cycle. This precise timing ensures consistent marker detection while preventing excessive sensor polling that could impact system performance. The sampling rate was determined through empirical testing to balance between reliable detection and system overhead.\nWhen the robot initiates its stopping sequence, the system employs a two-phase timing approach. Initially, a 50ms slowdown period allows for controlled deceleration to SPEED_BRAKE, providing a smooth transition from full speed. After this initial brake phase, a longer STOP_DELAY interval guides the robot to a complete stop, preventing abrupt movements that could affect positioning accuracy. These timing values work in concert with the speed adjustment system, which uses `ACCELERATION_STEP` and `BRAKE_STEP` to control velocity changes. The step values create a gradual acceleration and deceleration profile, protecting the motors while maintaining precise control over the robot’s movement.\nPost-curve speed management introduces another timing element through the boost system. When exiting a curve, the boostCountdown timer activates for a configurable duration (`BOOST_DURATION`), during which the robot can temporarily exceed its normal speed limits. This boost phase is carefully timed to maximize straight-line performance while ensuring the robot maintains stability as it transitions from curved to straight sections. The timing parameters across these systems are interdependent; for example, the marker reading interval must be fast enough to detect course features even at maximum boost speed, while the acceleration steps must be calibrated to work effectively within the boost duration window.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  },
  {
    "objectID": "control_layer.html#profilemanager-implementation",
    "href": "control_layer.html#profilemanager-implementation",
    "title": "5  Control Layer Implementation",
    "section": "6.4 ProfileManager Implementation",
    "text": "6.4 ProfileManager Implementation\nThe ProfileManager serves as RobotZero’s configuration system for different operating modes, providing two distinct profiles: one optimized for analysis and another for high-speed performance. This implementation is entirely conditional, only compiled when DEBUG_LEVEL is greater than 0, ensuring zero overhead during normal operation.\nclass ProfileManager {\npublic:\n    // Initialize profile manager\n    static void initialize(DebugMode mode);\n\n    // Get current debug mode\n    static DebugMode getCurrentMode();\n\n    // Get speed value based on original speed constant\n    static uint8_t getSpeedValue(uint8_t defaultSpeed);\n\n    // Get PID parameters\n    static float getKP(float defaultValue);\n    static float getKD(float defaultValue);\n    static float getFilterCoefficient(float defaultValue);\n\n    // Get acceleration parameters\n    static uint8_t getAccelerationStep();\n    static uint8_t getBrakeStep();\n    static uint8_t getTurnSpeed();\n    static uint8_t getTurnThreshold();\n    static uint8_t getStraightThreshold();\n    static uint8_t getBoostDuration();\n    static uint8_t getBoostIncrement();\n\nprivate:\n    static DebugMode currentMode;\n    static const SpeedProfile* activeProfile;\n\n    static const SpeedProfile ANALYSIS_PROFILE;\n    static const SpeedProfile SPEED_PROFILE;\n\n    static void setActiveProfile(DebugMode mode);\n    static uint8_t validateSpeed(uint8_t speed);\n};\nThe system is built around two predefined profiles, each optimized for specific purposes:\nconst SpeedProfile ProfileManager::ANALYSIS_PROFILE = {\n    // Speed settings - Conservative for analysis\n    .speedStop = 0,\n    .speedStartup = 60,    // Slower startup\n    .speedTurn = 80,       // Careful turns\n    .speedBrake = 90,      // Gentle braking\n    .speedCruise = 100,    // Moderate cruising\n    .speedSlow = 120,      // Moderate slow speed\n    .speedFast = 140,      // Moderate fast speed\n    .speedBoost = 160,     // Moderate boost\n    .speedMax = 180,       // Limited top speed\n\n    // Control parameters - Smooth operation\n    .accelerationStep = 15, // Gentle acceleration\n    .brakeStep = 40,       // Moderate braking\n    .turnSpeed = 80,       // Conservative turns\n    .turnThreshold = 50,   // Earlier turn detection\n    .straightThreshold = 25, // Stricter straight detection\n    .boostDuration = 8,    // Short boost\n    .boostIncrement = 15,  // Gentle boost\n\n    // PID parameters - Stable control\n    .kProportional = 4.0f,\n    .kDerivative = 500.0f,\n    .filterCoefficient = 0.5f\n};\n\nconst SpeedProfile ProfileManager::SPEED_PROFILE = {\n    // Speed settings - Aggressive for performance\n    .speedStop = 0,\n    .speedStartup = 100,   // Quick startup\n    .speedTurn = 120,      // Fast turns\n    .speedBrake = 140,     // Strong braking\n    .speedCruise = 160,    // Fast cruising\n    .speedSlow = 180,      // Fast slow mode\n    .speedFast = 200,      // High speed\n    .speedBoost = 220,     // Strong boost\n    .speedMax = 255,       // Maximum speed\n\n    // Control parameters - Performance focused\n    .accelerationStep = 35, // Quick acceleration\n    .brakeStep = 70,       // Strong braking\n    .turnSpeed = 140,      // Fast turns\n    .turnThreshold = 40,   // Later turn detection\n    .straightThreshold = 15, // Quicker straight detection\n    .boostDuration = 12,   // Longer boost\n    .boostIncrement = 25,  // Strong boost\n\n    // PID parameters - Aggressive control\n    .kProportional = 6.0f,\n    .kDerivative = 700.0f,\n    .filterCoefficient = 0.7f\n};\n\nImplementation Note:\nTODO: These variables should be transferred to macros or constexpr’s in the configuration layer, maintaining the system’s design principles of compile-time optimization and centralized configuration.\n\nThe translation between default values and profile-specific values is handled through the getSpeedValue method:\nuint8_t ProfileManager::getSpeedValue(uint8_t defaultSpeed) {\n    if (activeProfile == nullptr) {\n        return defaultSpeed;\n    }\n\n    // Map original speed constants to profile values\n    if (defaultSpeed == SPEED_STOP) return activeProfile-&gt;speedStop;\n    if (defaultSpeed == SPEED_STARTUP) return activeProfile-&gt;speedStartup;\n    if (defaultSpeed == SPEED_TURN) return activeProfile-&gt;speedTurn;\n    if (defaultSpeed == SPEED_BRAKE) return activeProfile-&gt;speedBrake;\n    if (defaultSpeed == SPEED_CRUISE) return activeProfile-&gt;speedCruise;\n    if (defaultSpeed == SPEED_SLOW) return activeProfile-&gt;speedSlow;\n    if (defaultSpeed == SPEED_FAST) return activeProfile-&gt;speedFast;\n    if (defaultSpeed == SPEED_BOOST) return activeProfile-&gt;speedBoost;\n    if (defaultSpeed == SPEED_MAX) return activeProfile-&gt;speedMax;\n\n    return validateSpeed(defaultSpeed);\n}\nThe Analysis Profile is designed for development and testing, with conservative speeds and gentle transitions. It prioritizes stability and predictability over raw speed, making it ideal for collecting performance data and tuning control parameters. All speed values are reduced, acceleration is gentler, and the PID parameters are tuned for stability.\nThe Speed Profile, in contrast, is optimized for maximum performance. It uses aggressive speed settings, quick transitions, and more responsive control parameters. The PID constants are increased for faster response, and the thresholds are adjusted to maintain control at higher speeds. These profiles have not yet been tested in competition conditions.\nThe ProfileManager ensures smooth operation by validating all speed values and providing fallback behaviour when no profile is active. When DEBUG_LEVEL is 0, the entire ProfileManager code is excluded from compilation, maintaining the efficiency of the production code.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Layer Implementation</span>"
    ]
  },
  {
    "objectID": "testing_guide.html",
    "href": "testing_guide.html",
    "title": "6  Testing Guide",
    "section": "",
    "text": "6.1 RobotZero - Arduino Nano - 2024\nThis document describes five independent test programs designed to verify the proper functioning of different components in your line following robot. Each test is a separate project that must be uploaded individually to your Arduino Nano. This modular approach allows for focused testing of each component without interference from other systems.\nIMPORTANT: Do not attempt to combine these tests into a single program. Each test should be uploaded separately to ensure accurate results.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testing Guide</span>"
    ]
  },
  {
    "objectID": "testing_guide.html#robotzero---arduino-nano---2024",
    "href": "testing_guide.html#robotzero---arduino-nano---2024",
    "title": "6  Testing Guide",
    "section": "",
    "text": "6.1.1 Test Programs\n\n6.1.1.1 1. Line Sensors Test\nPurpose: Verify the proper functioning of the line sensors array.\nSetup: 1. Upload the line-sensor-test program to your Arduino Nano; 2. Open Serial Monitor (9600 baud); 3. Place your robot on a test surface with your line.\nTest Procedure: 1. Move the robot slowly across the line; 2. The LED will blink briefly each time a sensor transitions from low to high; 3. The Serial Monitor will display which sensor detected the transition and its reading; 4. Test each sensor by ensuring the line crosses all sensors.\nExpected Results: - LED should blink when sensors cross the line; - Serial Monitor should show sensor readings; - All sensors should detect the line when crossed; - Readings should change significantly between line and surface.\nTroubleshooting: - If a sensor never triggers, check its connections; - If readings are inconsistent, check sensor height from surface; - If LED doesn’t blink, verify LED pin connection; - If no serial output, check baud rate settings.\n\n\n6.1.1.2 2. Marker Sensors Test\nPurpose: Verify the proper functioning of the course marker sensors.\nSetup: 1. Upload the marker-sensor-test program; 2. Open Serial Monitor (9600 baud); 3. Prepare test markers (either actual course markers or test material).\nTest Procedure: 1. Move the robot over each marker; 2. Observe LED behaviour and Serial Monitor output; 3. Test both left and right marker sensors; 4. Try different marker positions and angles.\nExpected Results: - LED should blink when marker is detected; - Serial Monitor should show which sensor detected the marker; - Both left and right sensors should work independently; - Readings should be consistent for similar marker positions.\nTroubleshooting:- If markers aren't detected, adjustMARKER_THRESHOLD value; - Check sensor height if detection is inconsistent; - Verify sensor connections if one side isn’t working; - Test with different marker materials if detection is poor.\n\n\n6.1.1.3 3. Motors Test\nPurpose: Verify proper motor function and movement patterns.\nSetup: 1. Upload the motor-test program; 2. Place robot on elevated surface or testing stand; 3. Ensure adequate space for movement; 4. Keep USB cable clear of wheels.\nTest Procedure: The robot will automatically perform this sequence: 1. Move forward. 2. Stop. 3. Turn right. 4. Stop. 5. Turn left. 6. Stop. 7. Complete full turn. 8. Stop. 9. Move backward. 10. Stop. 11. Led blinking for 5 seconds. 12. Maximum speed running in straight line for 3s. 13. Stop.\nExpected Results: - Motors should run smoothly in all directions; - Robot should stop completely between movements; - Turns should be consistent; - Motor speed should be steady.\nTroubleshooting: - If motors don’t turn, check connections; - For uneven movement, verify wheel attachment; - If speed seems wrong, adjust MOTOR_SPEED constant; - For erratic behaviour, check battery voltage.\n\n\n6.1.1.4 4. Button and LED Test\nPurpose: Verify button operation and LED signalling.\nSetup: 1. Upload the button-led-test program. 2. Open Serial Monitor (9600 baud).\nTest Procedure: 1. Press button to cycle through LED modes: - Mode 0: LED off; - Mode 1: LED constantly on; - Mode 2: Slow blink (1 Hz); - Mode 3: Fast blink (5 Hz). 2. Test multiple button presses. 3. Observe LED behaviour in each mode.\nExpected Results: - Button should register each press cleanly; - LED should change modes with each press; - Serial Monitor should show mode changes; - LED patterns should be clear and consistent.\nTroubleshooting: - If button seems unresponsive, check debounce timing; - For LED issues, verify PIN_STATUS_LED connection; - If modes skip, adjust DEBOUNCE_DELAY; - Check button wiring if no response.\n\n\n6.1.1.5 5. Line Sensor Calibration Test\nPurpose: Calibrate line sensors and establish proper thresholds.\nSetup: 1. Upload the line-calibration-test program. 2. Open Serial Monitor (9600 baud). 3. Prepare test surface with line.\nTest Procedure: 1. Place robot on testing surface. 2. Press button to start calibration. 3. During the 3-second calibration period: - Move robot over the line multiple times; - Cover all sensors; - Move at different angles. 4. Observe final calibration values.\nExpected Results: - LED blinks rapidly during calibration. - Serial Monitor shows min/max values for each sensor. - Clear difference between line and surface readings. - Consistent readings across all sensors.\nTroubleshooting: - If ranges are too narrow, check sensor height. - For inconsistent readings, clean sensors. - If calibration fails, adjust CALIBRATION_TIME. - Verify surface and line contrast if readings are close.\n\n\n\n6.1.2 General Tips\n\nAlways check battery voltage before testing.\nClean sensors before beginning tests.\nUse a well-lit testing area.\nKeep test surface clean and free of debris.\nDocument unusual readings for future reference.\nTest one component at a time.\nVerify USB connection if Serial Monitor shows no data.\n\nThese tests should be performed in sequence when building a new robot or after any major modifications. Keep a log of typical values and behaviors for your specific robot - this will help identify issues in the future.\nRegular testing using these programs can help identify problems before they affect robot performance in competition. If any test fails, resolve the issue before moving to the next test.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testing Guide</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Arduino. 2024. “Arduino Nano (@ArduinoNano).” 2024. https://docs.arduino.cc/hardware/nano/.",
    "crumbs": [
      "References"
    ]
  }
]