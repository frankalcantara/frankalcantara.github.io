<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sistemas Operacionais - 2&nbsp; Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./intro1.html" rel="next">
<link href="./index.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/styles.css">
<meta property="og:title" content="Sistemas Operacionais - 2&nbsp; Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais">
<meta property="og:description" content="">
<meta property="og:site_name" content="Sistemas Operacionais">
<meta name="twitter:title" content="Sistemas Operacionais - 2&nbsp; Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro.html">Introdução</a></li><li class="breadcrumb-item"><a href="./intro.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Sistemas Operacionais</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linefollower" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Introdução</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Sistemas Operacionais: Equilibrando Recursos e Simplicidade</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Exercícios</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introdução: Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Gestão de Projetos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Gerenciamento de Processos: Introdução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Criando Processos de Forma Programática: O Modelo Linux</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Processos de Sistema: <strong>Linux</strong> vs.&nbsp;Windows</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Controle de Processos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Untitled</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Simuladores e Projetos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12germem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Gestão de Memória</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13gerfiles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Gestão de Arquivos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14geres.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Gestão de Entrada/Saída</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15gerredes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Gestão de Conectividade e Comunicação</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16gerseg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Segurança</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2arqui.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Arquiteturas de Sistemas Operacionais: Estruturando a Complexidade</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3heterox.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Tendências Avançadas em Sistemas Operacionais</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18glossa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Glossário - Sistemas Operacionais: Fundamentos e Evolução</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19exerc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Exercícios Resolvidos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#uma-jornada-no-tempo-evolução-histórica-dos-sistemas-operacionais" id="toc-uma-jornada-no-tempo-evolução-histórica-dos-sistemas-operacionais" class="nav-link active" data-scroll-target="#uma-jornada-no-tempo-evolução-histórica-dos-sistemas-operacionais"><span class="header-section-number">2.1</span> Uma Jornada no Tempo: Evolução Histórica dos Sistemas Operacionais</a>
  <ul class="collapse">
  <li><a href="#o-estágio-nascente-máquinas-nuas-e-programação-direta-1940s---início-dos-1950s" id="toc-o-estágio-nascente-máquinas-nuas-e-programação-direta-1940s---início-dos-1950s" class="nav-link" data-scroll-target="#o-estágio-nascente-máquinas-nuas-e-programação-direta-1940s---início-dos-1950s"><span class="header-section-number">2.1.1</span> O Estágio Nascente: Máquinas Nuas e Programação Direta (1940s - início dos 1950s)</a></li>
  <li><a href="#a-revolução-batch-automatizando-o-throughput-final-dos-1950s---meados-dos-1960s" id="toc-a-revolução-batch-automatizando-o-throughput-final-dos-1950s---meados-dos-1960s" class="nav-link" data-scroll-target="#a-revolução-batch-automatizando-o-throughput-final-dos-1950s---meados-dos-1960s"><span class="header-section-number">2.1.2</span> A Revolução Batch: Automatizando o <code>throughput</code> (final dos 1950s - meados dos 1960s)</a></li>
  <li><a href="#malabarismo-de-recursos-o-advento-da-multiprogramação-meados-dos-1960s---1970s" id="toc-malabarismo-de-recursos-o-advento-da-multiprogramação-meados-dos-1960s---1970s" class="nav-link" data-scroll-target="#malabarismo-de-recursos-o-advento-da-multiprogramação-meados-dos-1960s---1970s"><span class="header-section-number">2.1.3</span> Malabarismo de Recursos: O Advento da multiprogramação (meados dos 1960s - 1970s)</a></li>
  <li><a href="#sec-timesharing" id="toc-sec-timesharing" class="nav-link" data-scroll-target="#sec-timesharing"><span class="header-section-number">2.1.4</span> Era da Interatividade: Sistemas de Tempo Compartilhado (final dos 1960s - 1980s)</a></li>
  <li><a href="#a-democratização-da-computação-era-dos-computadores-pessoais-final-dos-1970s---presente" id="toc-a-democratização-da-computação-era-dos-computadores-pessoais-final-dos-1970s---presente" class="nav-link" data-scroll-target="#a-democratização-da-computação-era-dos-computadores-pessoais-final-dos-1970s---presente"><span class="header-section-number">2.1.5</span> A Democratização da Computação: Era dos Computadores Pessoais (final dos 1970s - presente)</a></li>
  </ul></li>
  <li><a href="#fronteiras-modernas" id="toc-fronteiras-modernas" class="nav-link" data-scroll-target="#fronteiras-modernas"><span class="header-section-number">2.2</span> Fronteiras Modernas</a>
  <ul class="collapse">
  <li><a href="#sistemas-operacionais-embarcados-e-iot-conectando-o-mundo-físico" id="toc-sistemas-operacionais-embarcados-e-iot-conectando-o-mundo-físico" class="nav-link" data-scroll-target="#sistemas-operacionais-embarcados-e-iot-conectando-o-mundo-físico"><span class="header-section-number">2.2.1</span> Sistemas Operacionais Embarcados e IoT: Conectando o Mundo Físico</a></li>
  <li><a href="#sistemas-operacionais-móveis" id="toc-sistemas-operacionais-móveis" class="nav-link" data-scroll-target="#sistemas-operacionais-móveis"><span class="header-section-number">2.2.2</span> Sistemas Operacionais Móveis</a></li>
  <li><a href="#sistemas-distribuídos" id="toc-sistemas-distribuídos" class="nav-link" data-scroll-target="#sistemas-distribuídos"><span class="header-section-number">2.2.3</span> Sistemas Distribuídos</a></li>
  <li><a href="#computação-em-nuvem-transformando-o-design-de-sistemas-operacionais" id="toc-computação-em-nuvem-transformando-o-design-de-sistemas-operacionais" class="nav-link" data-scroll-target="#computação-em-nuvem-transformando-o-design-de-sistemas-operacionais"><span class="header-section-number">2.2.4</span> Computação em Nuvem: transformando o Design de Sistemas Operacionais</a></li>
  <li><a href="#inteligência-artificial-e-modelos-de-linguagem-de-grande-escala-llms" id="toc-inteligência-artificial-e-modelos-de-linguagem-de-grande-escala-llms" class="nav-link" data-scroll-target="#inteligência-artificial-e-modelos-de-linguagem-de-grande-escala-llms"><span class="header-section-number">2.2.5</span> Inteligência Artificial e Modelos de Linguagem de Grande Escala (LLMs)</a></li>
  <li><a href="#o-impacto-da-computação-quântica-em-sistemas-operacionais" id="toc-o-impacto-da-computação-quântica-em-sistemas-operacionais" class="nav-link" data-scroll-target="#o-impacto-da-computação-quântica-em-sistemas-operacionais"><span class="header-section-number">2.2.6</span> O Impacto da Computação Quântica em Sistemas Operacionais</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linefollower/edit/main/intro.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linefollower/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro.html">Introdução</a></li><li class="breadcrumb-item"><a href="./intro.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\intro-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>Em cada computador, smartphone ou dispositivo inteligente que utilizamos hoje quase como extensões do nosso próprio corpo, existe um software fundamental que orquestra silenciosamente todas as operações: o <strong>Sistema Operacional</strong>, que, assim como o capitão pilota um navio, coordena cada pequeno subsistema da máquina criando harmonia perfeita, integrando os sistemas de hardware e software em um ambiente computacional funcional e eficiente. Contudo, ao contrário do capitão, cuja presença é evidente, inestimável e inevitável, a natureza ubíqua dos <strong>Sistemas Operacionais</strong> torna-os quase invisíveis para a maioria dos usuários. Quando a cuidadosa leitora salva um arquivo, executa um programa ou conecta-se à internet, o faz sem se dar conta dos mecanismos complexos que tornam essas ações possíveis. Mais importante, além de não se dar conta, ela não precisa se preocupar com isso. Por trás da aparente simplicidade das nossas máquinas, reside uma das criações mais sofisticadas e interessantes da engenharia de software: um sistema capaz de gerenciar recursos limitados, coordenar atividades concorrentes, garantir segurança e fornecer uma interface amigável, de acesso simultâneo,transparente e eficiente.</p>
<p>Compreender os <strong>Sistemas Operacionais</strong> não é apenas uma questão de curiosidade acadêmica, mas uma necessidade fundamental para qualquer profissional que deseje trabalhar com tecnologia de forma competente. Esta necessidade é maximizada em tempos de crescente complexidade tecnológica, impulsionada por avanços nos campos da Inteligência Artificial, Computação Quântica e dispositivos móveis. Novas tecnologias estão surgindo e mudando toda a relação que temos com a computação e talvez as bases da nossa sociedade. Eu não sei como serão as máquinas, sistemas e o mercado de trabalho no futuro próximo, mas aposto meu chapéu que estas máquinas usarão <strong>Sistemas Operacionais</strong> sofisticados.</p>
<p>Os <strong>Sistemas Operacionais</strong> formam as pontes entre o hardware bruto e as aplicações que utilizamos, definindo como os recursos computacionais são utilizados e como as tarefas destes sistemas são executadas. Neste ponto, a atenta leitora deve ter percebido que este conhecimento é essencial para o desenvolvimento de softwares eficientes, a resolução de problemas de desempenho e a compreensão das limitações e possibilidades dos sistemas computacionais. Se a tecnologia avança, também avançam os <strong>Sistemas Operacionais</strong>.</p>
<p>Neste texto, vou guiá-la em uma jornada pela evolução histórica dos <strong>Sistemas Operacionais</strong>, desde as primeiras máquinas programáveis até os sistemas modernos que gerenciam servidores e redes complexas. Exploraremos as funções fundamentais que todos os <strong>Sistemas Operacionais</strong> devem realizar, as diferentes perspectivas por meio das quais podemos compreendê-los, e os princípios arquiteturais que orientam o seu design. Nossa meta é construir uma compreensão sólida que sirva como fundação para estudos mais avançados em ciência da computação e engenharia de software. Prepare-se, esta não será uma jornada para fracos de coração ou vontade.</p>
<p>Escrevo com a esperança e ambição de que ao final desta jornada, a persistente leitora não apenas compreenda os <strong>Sistemas Operacionais</strong>, mas que seja capaz de utilizar esse conhecimento para resolver problemas práticos, otimizar sistemas e contribuir para o avanço da tecnologia.</p>
<p>Que o céu esteja azul e que os ventos sejam justos!</p>
<section id="uma-jornada-no-tempo-evolução-histórica-dos-sistemas-operacionais" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="uma-jornada-no-tempo-evolução-histórica-dos-sistemas-operacionais"><span class="header-section-number">2.1</span> Uma Jornada no Tempo: Evolução Histórica dos Sistemas Operacionais</h2>
<p>A história dos <strong>Sistemas Operacionais</strong> foi impulsionada pela constante evolução do hardware, pelas crescentes demandas dos usuários e, principalmente pela criatividade aplicada à solução de novos problemas ou pela busca de novos recursos. Para que a atenta leitora tenha um vislumbre desta história, a linha do tempo apresentada na <a href="#fig-timeline1" class="quarto-xref">Figure&nbsp;<span>2.1</span></a> ilustra as principais eras da evolução dos <strong>Sistemas Operacionais</strong> segundo esse pretensioso autor.</p>
<div id="fig-timeline1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-timeline1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/timeline_evolutivo_so.webp" class="img-fluid figure-img"></p>
<figcaption>Linha de tempo da evolução dos Sistemas Operacionais</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-timeline1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.1: Linha temporal mostrando as eras (1940s-presente) com marcos tecnológicos importantes para o entendimento da evolução dos <strong>Sistemas Operacionais</strong>, destacando os sistemas mais representativos de cada era e as inovações de hardware correspondentes.
</figcaption>
</figure>
</div>
<p>A <a href="#fig-timeline1" class="quarto-xref">Figure&nbsp;<span>2.1</span></a> mostra que a evolução dos <strong>Sistemas Operacionais</strong> pode ser dividida em eras, marcadas por inovações tecnológicas, fomentadas por mudanças nas necessidades dos usuários. Por outro lado, a <a href="#fig-timeline2" class="quarto-xref">Figure&nbsp;<span>2.2</span></a> destaca um aspecto importante: a evolução do hardware, que teve impacto direto na evolução dos <strong>Sistemas Operacionais</strong>, seja criando uma nova oportunidade de evolução, seja forçando esta evolução.</p>
<div id="fig-timeline2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-timeline2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/hardware_evolution_svg.webp" class="img-fluid figure-img"></p>
<figcaption>Evolução do Hardware e Impact nos Sistemas Operacionais</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-timeline2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.2: Linha temporal destacando a relação entre a evolução do hardware e a dos <strong>Sistemas Operacionais</strong>.
</figcaption>
</figure>
</div>
<p>A visão destas eras é interessante, mas carece de detalhamento. Talvez um resumo das características que atribuímos a cada uma destas eras permita que a atenta leitora possa entender como chegamos aqui.</p>
<section id="o-estágio-nascente-máquinas-nuas-e-programação-direta-1940s---início-dos-1950s" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="o-estágio-nascente-máquinas-nuas-e-programação-direta-1940s---início-dos-1950s"><span class="header-section-number">2.1.1</span> O Estágio Nascente: Máquinas Nuas e Programação Direta (1940s - início dos 1950s)</h3>
<p>Os primórdios da computação, <em>a era do bit lascado</em>, foram caracterizados por máquinas colossais que utilizavam <strong>válvulas termiônicas e painéis de conexão</strong>, em inglês chamados de <em>plugboard</em>, operando sem qualquer forma de sistema supervisor, gerenciador ou de controle. Estas máquinas primitivas, verdadeiras máquinas nuas, em inglês <em>bare machines</em>, exigiam que os programadores interagissem diretamente com o hardware. Nestas máquinas, cada instrução era codificada manualmente em formato binário e as funções que a máquina deveria executar eram criadas por meio da fiação física interligando circuitos para montar a estrutura capaz de executar as instruções em binário. Assim, se a operação requeria uma soma, o circuito do somador precisava ser montado e incluído no ciclo de processamento, manualmente. As máquinas precisavam ser montadas, fisicamente configuradas, para cada tarefa específica. Nesse tempo, muitos programadores eram especialistas em eletrônica, capazes de entender e manipular o hardware diretamente, atuando em conjunto com matemáticos, capazes de simplificar as equações que seriam executadas.</p>
<p>A atenta leitora deve estar imaginando que esse modo de operação era ineficiente, cansativo e tedioso. Os programadores precisavam se inscrever em uma lista de controle, um diretório, para conseguir direito de usar um intervalo de máquina. Neste intervalo, o programador teria que construir os circuitos que precisaria, incluir manualmente, em binário, as instruções que seriam executadas e, finalmente, executar o programa. A configuração era um processo demorado e propenso a erros. Entretanto, a tecnologia evolui.</p>
<p>A introdução dos cartões e fitas perfurados para a entrada e saída de dados representou uma melhora no processo. Não era mais necessário incluir os comandos manualmente em binário. Entretanto, os circuitos necessários à execução de um programa específico ainda precisavam ser manualmente criados e configurados. Os dados e as instruções entravam e saíam da máquina mais rápido, mas a operação continuava predominantemente manual, tediosa e demorada. O <strong>ENIAC</strong>, um dos computadores desse período, poderia levar dias ou até semanas para ser configurado e programado para a realização de uma tarefa que seria realizada em horas, talvez minutos. A <a href="#fig-eniacfoto" class="quarto-xref">Figure&nbsp;<span>2.3</span></a> é uma foto do <strong>ENIAC</strong>.</p>
<div id="fig-eniacfoto" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-eniacfoto-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/ENIAC2.webp" class="img-fluid figure-img"></p>
<figcaption>foto do eniac mostrando os paineis de cabeamento</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-eniacfoto-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.3: O <strong>ENIAC</strong>, um dos primeiros computadores programáveis, com painéis de conexão e cartões perfurados. Uma máquina colossal. Imagem artificialmente colorizada (WIKIMEDIA COMMONS, 2025).
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ENIAC</strong></p>
<p>O <strong>E</strong>lectronic <strong>N</strong>umerical <strong>I</strong>ntegrator <strong>A</strong>nd <strong>C</strong>omputer, <strong>ENIAC</strong>, é considerado um dos primeiros computadores digitais eletrônicos de grande escala. Este equipamento foi desenvolvido durante a Segunda Guerra Mundial e concluído em 1945. Projetado por <a href="https://pt.wikipedia.org/wiki/John_Presper_Eckert">John Presper Eckert</a> e <a href="https://pt.wikipedia.org/wiki/John_Mauchly">John William Mauchly</a> na Universidade da Pensilvânia para ajudar no esforço de guerra. O <strong>ENIAC</strong> foi criado para calcular trajetórias balísticas para o exército dos Estados Unidos da América. No entanto, sua utilidade transcendeu esse propósito inicial, marcando o início da era dos computadores eletrônicos. <em>Tratava-se de uma máquina colossal, ocupando uma área de aproximadamente <span class="math inline">\(167\)</span> metros quadrados e pesando cerca de <span class="math inline">\(30\)</span> toneladas</em>. Apesar de seu tamanho e complexidade, talvez graças ao seu tamanho e complexidade, o <strong>ENIAC</strong> foi capaz de realizar cálculos em velocidades sem precedentes na sua época, revolucionando a forma como problemas matematicamente complexos e trabalhosos poderiam ser resolvidos.</p>
<p>Há aqui uma curiosidade interessante. Graças ao trabalho e dedicação de <a href="https://www.amazon.com/Proving-Ground-Untold-Programmed-Computer/dp/1538718286">Kathy Kleiman</a> nós sabemos que o <strong>ENIAC</strong> foi programado por um grupo de mulheres matemáticas: Kathleen “Kay” (McNulty); Mauchly Antonelli; Jean “Betty” (Jennings) Bartik; Frances “Betty” (Snyder) Holberton; Marlyn Wescoff Meltzer; Frances “Fran” (Bilas) Spence; e Ruth (Lichterman) Teitelbaum. Em 1997 estas mulheres foram reconhecidas pelo Congresso dos Estados Unidos como as primeiras programadoras de computadores do mundo. Elas desempenharam um papel crucial na programação do <strong>ENIAC</strong>, desenvolvendo algoritmos complexos e configurando a máquina para realizar cálculos específicos. O trabalho dessas mulheres pioneiras foi fundamental para o sucesso do <strong>ENIAC</strong> e para o avanço da computação como um todo. No livro, Kleiman conta que, como os matemáticos da universidade não acreditavam na tecnologia, relegaram a máquina às mulheres, as computadoras.</p>
<p>O <strong>ENIAC</strong> utilizava uma tecnologia revolucionária para o seu tempo, baseada em válvulas termiônicas, tubos de vácuo capazes de executar comutações e operações analógicas simples, em vez de componentes puramente mecânicos como os relés. <em>Com aproximadamente <span class="math inline">\(17.468\)</span> válvulas, <span class="math inline">\(7.200\)</span> diodos de cristal, <span class="math inline">\(1.500\)</span> relés, <span class="math inline">\(70.000\)</span> resistores e <span class="math inline">\(10.000\)</span> capacitores</em>, o <strong>ENIAC</strong> representava o ápice da engenharia eletrônica mundial. As válvulas termiônicas permitiam que o <strong>ENIAC</strong> realizasse cálculos a uma velocidade muito maior do que qualquer máquina anterior. Mesmo assim, a programação do <strong>ENIAC</strong> ainda era feita por meio de painéis de conexão e chaves manuais, interligando conjuntos genéricos de válvulas para criar os circuitos necessários a uma computação específica. O <strong>ENIAC</strong> estabeleceu as bases para o desenvolvimento de computadores mais avançados e acessíveis, pavimentando o caminho para a revolução digital que viria a seguir.</p>
</div>
</div>
<p>O <strong>ENIAC</strong> é um marco importante na história da computação. Mas não foi o primeiro computador, nem o único. Outros computadores notáveis dessa era incluem o <a href="https://en.wikipedia.org/wiki/Colossus_computer"><strong>Colossus</strong></a> anterior à Máquina de Turing, usado para decifrar códigos durante a Segunda Guerra Mundial, o <a href="https://en.wikipedia.org/wiki/EDVAC"><strong>EDVAC</strong></a>, que introduziu o conceito de armazenar programas na memória. E, o mais surpreendente de todos, o <strong>Z3</strong>, que graças aos problemas da segunda guerra mundial, ficou esquecido. Relegado à poeira do preconceito e medo.</p>
<p>O filme, O Jogo da Imitação, induz ao erro, dando a impressão que <a href="https://en.wikipedia.org/wiki/Alan_Turing">Turing</a> construiu sozinho uma supermáquina, o primeiro computador. Na verdade, a grande máquina que a equipe de Turing constrói no filme, e que eles ficcionalmente nomeiam de “Christopher”, é uma representação cinematográfica da <strong>Bombe</strong>. O objetivo da <strong>Bombe</strong>, uma máquina eletromecânica, era decifrar os códigos da máquina Enigma. o trabalho de Turing foi, de fato, aperfeiçoar o projeto de uma máquina polonesa anterior para criar a <strong>Bombe</strong> britânica, que foi fundamental para a quebra da Enigma. Foi Turing quem recrutou <a href="https://en.wikipedia.org/wiki/Tommy_Flowers">Tommy Flowers</a> para o centro de criptoanálise em Bletchley Park. <a href="https://en.wikipedia.org/wiki/Max_Newman">Max Newman</a>, um matemático e colega de Turing, liderava a seção conhecida como “Newmanry”, responsável por automatizar a criptoanálise da <a href="https://en.wikipedia.org/wiki/Lorenz_cipher">cifra de Lorenz</a>. o trabalho teórico de Turing sobre computação, notavelmente o seu artigo de 1936 sobre <a href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf">“Números Computáveis”</a> que introduziu o conceito da Máquina de Turing, forneceu a base teórica para a ideia de que uma máquina poderia resolver problemas lógicos complexos. Enquanto isso, completamente isolado pela distância, política e guerra estava <a href="https://pt.wikipedia.org/wiki/Konrad_Zuse">Konrad Zuse</a>. Zuse era um engenheiro civil e queria automatizar os cálculos tediosos e complexos de engenharia, como os de estática para projetos de aeronaves.</p>
<p>O processo de redescoberta e reconhecimento da relevância do <a href="https://en.wikipedia.org/wiki/Z3_(computer)"><strong>Z3</strong></a> começou a ganhar força na década de 1990. Um marco importante ocorreu após a morte de Konrad Zuse, em 1995, quando um renovado interesse em seu trabalho reacendeu os debates sobre qual foi o primeiro computador da história. Finalmente, em 1998, foi demonstrado que o <strong>Z3</strong> era Turing-completo. Contudo, para isso foi preciso um pequeno truque de programação descoberto por <a href="https://en.wikipedia.org/wiki/Ra%C3%BAl_Rojas">Raúl Rojas</a> em 1998, já que o <strong>Z3</strong> não possuía uma estrutura de desvio condicional. Com isso foi provado que o <strong>Z3</strong> era capaz de realizar qualquer cálculo que um computador moderno pode fazer, desde que devidamente programado e com tempo suficiente. Essa demonstração solidificou a posição do <strong>Z3</strong> como um avanço fundamental na evolução da computação. Para muitos, o primeiro computador moderno.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>O Zuse <strong>Z3</strong></p>
<p>O Zuse <strong>Z3</strong>, criado pelo engenheiro civil alemão <a href="https://pt.wikipedia.org/wiki/Konrad_Zuse">Konrad Zuse</a> em 1941, é reconhecido como o primeiro computador programável e totalmente automático do mundo. Desenvolvido em Berlim, o <strong>Z3</strong> representou uma inovação significativa na capacidade computacional, utilizando relés eletromecânicos para realizar cálculos complexos com entrada e saída de dados automáticas usando fitas perfuradas. Zuse construiu o <strong>Z3</strong> para resolver problemas de engenharia, notadamente problemas de mecânica estática. Existem registros de que o <strong>Z3</strong> tenha sido usado em cálculos estruturais e aerodinâmicos.</p>
<p>O <strong>Z3</strong> utilizava cerca de <span class="math inline">\(2.600\)</span> relés eletromecânicos para realizar suas operações lógicas e aritméticas, uma tecnologia avançada para a época, porém limitada em comparação com os computadores puramente eletrônicos que surgiriam nos EUA e Reino Unido. O <strong>Z3</strong> operava com uma frequência de clock de aproximadamente <span class="math inline">\(5 Hz\)</span>, cinco pulsos por segundo, o que, embora lento pelos padrões atuais, era uma conquista notável para a tecnologia da época. Este projeto introduziu conceitos fundamentais da computação moderna, como a separação entre programa e dados. Além disso, o <strong>Z3</strong> era capaz de realizar operações de ponto flutuante armazenando dados em memória. Uma memória limitada, mas ainda assim, suficiente para resolver eficientemente as tarefas da época. O <strong>Z3</strong> foi destruído durante um bombardeio aliado em 1943.</p>
</div>
</div>
<p>Observe que o <strong>ENIAC</strong> usava válvulas termiônicas, enquanto o <strong>Z3</strong> utilizava relés eletromecânicos. Isto parece implicar que o <strong>ENIAC</strong> era muito mais rápido. Contudo, o <strong>Z3</strong> era montado por fitas perfuradas, enquanto o <strong>ENIAC</strong> utilizava painéis de conexão. O que significa que o <strong>Z3</strong> era mais flexível e fácil de programar. Ou seja, este pobre autor acredita que o tempo entre a definição do problema e a solução do mesmo era menor no <strong>Z3</strong> do que no <strong>ENIAC</strong>. O que, em última análise, é o que importa. A <a href="#fig-eniacz3" class="quarto-xref">Figure&nbsp;<span>2.4</span></a> apresenta as características do <strong>ENIAC</strong> em comparação com o <strong>Z3</strong>.</p>
<div id="fig-eniacz3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-eniacz3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/eniac_z3_comparison_svg.webp" class="img-fluid figure-img"></p>
<figcaption>gráfico de blocos mostrando os sistemas dos dois computadores</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-eniacz3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.4: Comparação entre o <strong>ENIAC</strong> e o <strong>Z3</strong>, destacando as diferenças em tecnologia, programação e velocidade.
</figcaption>
</figure>
</div>
<p>Nesta altura da nossa jornada, a atenta leitora deve focar em compreender que, <strong>mesmo sem qualquer sistema de gerência de hardware ou software, os computadores já eram capazes de realizar tarefas complexas</strong>. No entanto, a falta de abstração e automação tornava o processo trabalhoso, dolorosamente tedioso e propenso a erros. Nesse ponto da história, parece inevitável perceber que existe a necessidade de uma camada extra de tecnologia, entre o hardware e o software, que permitisse automatizar as tarefas básicas de operação, como configurar os circuitos necessários para resolver problemas computacionais, sem a necessidade de intervenção manual constante. E começamos a pensar em lotes. Digo, <code>batches</code>.</p>
</section>
<section id="a-revolução-batch-automatizando-o-throughput-final-dos-1950s---meados-dos-1960s" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="a-revolução-batch-automatizando-o-throughput-final-dos-1950s---meados-dos-1960s"><span class="header-section-number">2.1.2</span> A Revolução Batch: Automatizando o <code>throughput</code> (final dos 1950s - meados dos 1960s)</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Throughput é uma palavra horrível</strong></p>
<p>A palavra <code>throughput</code> da língua inglesa, não tem uma tradução direta para o português. Pode ser entendida como vazão, taxa de transferência ou capacidade de processamento dependendo da área da ciência onde é aplicada. No contexto de <strong>Sistemas Operacionais</strong>, <strong>refere-se à quantidade de trabalho que um sistema computacional pode realizar em um determinado período de tempo</strong>.trata-se de uma métrica importante para avaliar a eficiência e o desempenho de um sistema, especialmente em ambientes de computação nos quais múltiplas tarefas são executadas simultaneamente.</p>
<p>Neste livro, eu vou usar o termo <code>throughput</code> livremente, na esperança de que Cecília Meireles e Fernando Pessoa me perdoem o estrangeirismo. Pecado que, inevitavelmente, cometerei muitas vezes ao longo deste livro. Pobre autor pecador. A compassiva leitora há de ter paciência comigo.</p>
<p>Como o desempenho de sistemas é um conceito complexo, para que a esforçada leitora possa entendê-lo, vamos começar esclarecendo uma confusão comum. No dia a dia, usamos o termo <strong>velocidade</strong> de forma genérica, mas ele, na verdade, é o resultado de duas métricas distintas: <code>throughput</code> e <code>latência</code>. Esta distinção fica evidente quando saímos da computação para a fabricação. Considere uma fábrica de carros. A <strong>velocidade</strong> percebida da fábrica depende de dois fatores: O <code>throughput</code> representa quantos carros a fábrica produz por dia, a vazão total. A <code>latência</code> indica quanto tempo leva para que um carro específico passe por toda a linha de montagem, do início ao fim.</p>
<p>Uma fábrica pode ter um <code>throughput</code> altíssimo, produzindo milhares de carros por dia, mas uma <code>latência</code> elevada, onde cada carro individualmente leva semanas para ficar pronto. Ambas as métricas são essenciais para entender a real eficiência da operação.</p>
</div>
</div>
<p>Estamos na era dos transistores. <em>A substituição das válvulas por transistores tornou os computadores menores, mais confiáveis, rápidos e práticos</em>. Apesar disso, as máquinas da época eram extremamente caras e, por isso mesmo, gerenciadas centralmente. Estas grandes máquinas ficaram conhecidas como <strong>mainframes</strong>.</p>
<p>O termo em inglês <code>main frame</code>, escrito assim: com espaço entre as palavras, era usado para descrever a estrutura física principal que abrigava os componentes centrais de um computador, como a <code>CPU</code>, em inglês <strong>C</strong>entral <strong>P</strong>rocessing <strong>U</strong>nit, e a memória. Nos primeiros computadores de grande porte, os componentes de uma máquina eram montados em grandes gabinetes metálicos, chamados em inglês de <code>frames</code>. Neste caso, o <code>main frame</code> era o mais importante desses gabinetes. Com o tempo, o termo passou a ser escrito sem espaços como <code>mainframe</code> e passou a designar não apenas a estrutura física central, mas todo o sistema computacional de grande porte.</p>
<p>Os <code>mainframes</code> eram operadas por equipes de especialistas e utilizados principalmente para tarefas vitais e estratégicas em grandes organizações, como bancos, institutos militares e universidades. Essas máquinas enfrentavam um problema importante: a <strong>subutilização da unidade central de processamento</strong>.</p>
<p>A <code>CPU</code> ficava ociosa enquanto esperava por operações de Entrada/Saída (<code>E/S</code>), pela conclusão de outros processos, resultando em desperdício de recursos. Tanto na era dos <code>mainframes</code> quanto nos dias atuais, as operações de <code>E/S</code> são os pontos de menor velocidade e <code>Throughput</code> e de maior latência em todo o processo computacional. Entretanto, em um <code>mainframe</code>, deixar a <code>CPU</code> parada representava um custo muito alto. A solução emergiu na forma de <strong>Sistemas Batch</strong>.</p>
<p>Os sistemas <code>batch</code>, uma palavra em inglês que pode ser traduzida por lote, apresentavam características distintas das abordagens anteriores usadas na computação. Uma das suas principais inovações era a capacidade de agrupar tarefas com necessidades similares, formando lotes, <code>batchs</code> de processamento, que eram executados de maneira sequencial, permitindo a utilização mais eficiente dos recursos computacionais. <em>Esses sistemas contavam com um monitor residente, um componente precursor dos <strong>Sistemas Operacionais</strong> modernos, que tinha a função de automatizar o sequenciamento dos trabalhos, eliminando a necessidade de intervenção manual anterior à execução de cada tarefa</em>.</p>
<p>Observe, atenta leitora, a sentença: <strong>… eliminando a necessidade de intervenção manual anterior à execução de cada tarefa</strong>. Aqui está o segredo do sucesso da arquitetura <code>batch</code>. Entretanto, a evolução tecnológica abriu caminhos para a automação do processo de execução de tarefas, permitindo que os sistemas <code>batch</code> fossem programados para executar automaticamente uma sequência de tarefas sem intervenção manual. Aqui surgem as linguagens de programação de domínio específico.</p>
<p>Para controlar esse processo, foi desenvolvida a linguagem <strong>JCL</strong>, em inglês <strong>J</strong>ob <strong>C</strong>ontrol <strong>L</strong>anguage, em português: linguagem de controle de trabalhos. A <strong>JCL</strong> é uma linguagem específica, hoje chamamos de linguagem de domínio específico, que permitia instruir um sistema de monitoramento para processar os trabalhos computacionais definindo parâmetros e sequências de execução. Em resumo, a <strong>JCL</strong> era uma linguagem que permitia programar a ordem de execução dos trabalhos, permitindo, por exemplo, priorizar ou excluir trabalhos de acordo com os resultados anteriores. Além disso, os sistemas <code>batch</code> introduziram o conceito de processamento <code>offline</code>, Aqui, o termo <code>offline</code> está relacionado com a saída dos trabalhos estar direcionada para fitas magnéticas, muito mais rápidas que as impressoras. O sistema grava em fita magnética, muito rápido, e volta à <code>CPU</code> para outra tarefa. Desta forma, libera memória, já que deixa a impressora lendo a fita e imprimindo no seu próprio ritmo. Os sistemas <code>batch</code>representaram um avanço na automação da operação dos computadores, é possível programar os trabalhos computacionais, aumentando consideravelmente a utilização da <code>CPU</code> e o <code>throughput</code> dos sistemas. A <a href="#fig-throughput" class="quarto-xref">Figure&nbsp;<span>2.5</span></a> ilustra essa evolução em uma situação fictícia.</p>
<div id="fig-throughput" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-throughput-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/throughput-comparison.webp" class="img-fluid figure-img"></p>
<figcaption>Diagrama mostrando uma situação fictícia de aumento de throughput</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-throughput-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.5: Diagrama mostrando uma situação fictícia de aumento de throughput. Mais trabalhos realizados em menos tempo. Nessa ilustração simples conseguimos <span class="math inline">\(4\times\)</span> mais <code>throughput</code> com o mesmo hardware!
</figcaption>
</figure>
</div>
<section id="sistemas-influentes-da-era-batch" class="level4" data-number="2.1.2.1">
<h4 data-number="2.1.2.1" class="anchored" data-anchor-id="sistemas-influentes-da-era-batch"><span class="header-section-number">2.1.2.1</span> Sistemas influentes da Era Batch</h4>
<p>Dois Sistemas <code>batch</code>, merecem destaque:</p>
<ol type="1">
<li><strong>FMS</strong>, em inglês, <strong>F</strong>ortran <strong>M</strong>onitor <strong>S</strong>ystem. O <strong>FMS</strong> foi um dos primeiros sistemas de monitoramento desenvolvido especificamente para programas escritos em <strong>FORTRAN</strong>, em inglês: <strong>FOR</strong>mula <strong>TRAN</strong>slation, uma das primeiras linguagens de programação, utilizada para aplicações científicas e de engenharia de alto desempenho. O <strong>FMS</strong> permitia que <em>múltiplos programas <strong>FORTRAN</strong> fossem executados em sequência sem a necessidade de intervenção manual entre cada execução</em>. O <strong>FMS</strong> introduziu os conceitos básicos de gerenciamento de tarefas e alocação de recursos, que se tornariam fundamentais para os <strong>Sistemas Operacionais</strong>. O <strong>FMS</strong> facilitava a compilação e execução de programas <strong>FORTRAN</strong>, tornando o processo de desenvolvimento mais eficiente e menos propenso a erros.</li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Nesta terceira década do século XXI, o <strong>FORTRAN</strong> é amplamente utilizado em áreas onde o desempenho computacional é essencial.trata-se de uma linguagem muito comum em simulações numéricas e aplicações científicas, como no <a href="https://www.vasp.at/wiki/index.php/The_VASP_Manual">VASP</a>, e <a href="https://www.quantum-espresso.org/">Quantum ESPRESSO</a>, usados em química e física computacional. Na meteorologia e climatologia, modelos como o WRF, em inglês <a href="https://github.com/wrf-model/">Weather Research and Forecasting Model</a> e o UFS, em inglês <a href="https://github.com/ufs-community/ufs-weather-model/wiki">Unified Forecast System</a>. Agências como a <a href="https://www.nasa.gov/">NASA</a>, a <a href="https://www.noaa.gov/">NOAA</a> e o <a href="https://www.gov.br/inpe/pt-br">IMPE</a> mantêm códigos extensos em <strong>FORTRAN</strong>, especialmente em simulações aeroespaciais e modelagem climática. Por fim, é preciso não esquecer que o <strong>FORTRAN</strong> é amplamente usado em computação de alto desempenho (HPC), com suporte a paralelismo via <a href="https://www.open-mpi.org/">MPI</a> e [OpenMP]. Sua permanência como linguagem relevante se deve ao alto desempenho em cálculos numéricos, à grande base de código legado e à maturidade de suas bibliotecas científicas. Coloque ênfase em maturidade.</p>
</div>
</div>
<ol start="2" type="1">
<li><strong>IBSYS</strong>: sistema <code>batch</code> para o <strong>IBM 7094</strong>. Este sistema de monitoramento e gestão estabeleceu alguns conceitos que permanecem importantes no processo computacional. O <strong>IBSYS</strong> introduziu técnicas de gerenciamento de memória e escalonamento de tarefas, permitindo que múltiplos trabalhos fossem processados de maneira eficiente. Além disso, implementou mecanismos de proteção de memória, garantindo que um programa não interferisse na execução de outros. Este isolamento de memória é um conceito fundamental e indispensável para a estabilidade e confiabilidade dos sistemas computacionais. Complementarmente, o <strong>IBSYS</strong> oferecia suporte a dispositivos de entrada e saída diversos, incluindo leitores de cartões, impressoras e unidades de fita magnética, permitindo mais flexibilidade na manipulação de dados.</li>
</ol>
<p>Os sistemas <code>Batch</code> foram concebidos para maximizar a utilização da <code>CPU</code> e aumentar o <code>throughput</code>. <em>A execução de mais tarefas em um mesmo intervalo de tempo torna as máquinas economicamente viáveis</em>. Depois de voltar à definição de <code>throughput</code>, só por via das dúvidas, a esforçada leitora deve registrar que esta era marcou o <strong>primeiro passo na automação dos processos de operação das máquinas de computação</strong> e impulsionou os conceitos de abstração que usamos hoje para representar o hardware.</p>
</section>
</section>
<section id="malabarismo-de-recursos-o-advento-da-multiprogramação-meados-dos-1960s---1970s" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="malabarismo-de-recursos-o-advento-da-multiprogramação-meados-dos-1960s---1970s"><span class="header-section-number">2.1.3</span> Malabarismo de Recursos: O Advento da multiprogramação (meados dos 1960s - 1970s)</h3>
<p>A introdução dos circuitos integrados marcou outro passo significativo na evolução dos sistemas computacionais, empurrando o desenvolvimento dos <strong>Sistemas Operacionais</strong>, resultando em computadores mais poderosos, compactos e acessíveis. Nesta era de circuitos integrados, mesmo com a eficiência aprimorada dos sistemas <code>batch</code>, um problema persistia: a <code>CPU</code> permanecia ociosa durante as operações de entrada e saída de dados (<code>E/S</code>). O gargalo devido à velocidade dos dispositivos de entrada e saída resistia.</p>
<p>Nesse contexto surgiu a <strong>multiprogramação</strong>. <strong>Essa técnica propõe manter múltiplos processos na memória principal simultaneamente</strong>. A ideia era simples, mas transformadora: se um programa em execução precisasse realizar uma operação de <code>E/S</code>, um sistema de gestão poderia rapidamente comutar a <code>CPU</code> para outro programa que estivesse pronto para ser executado, em vez de esperar o término da lenta operação de <code>E/S</code>. Multiprogramação, vários programas em memória e sendo colocados em execução sempre que a <code>CPU</code> estivesse ociosa. Parece bom.</p>
<p>A abordagem da multiprogramação aumentou drasticamente a utilização da <code>CPU</code>, reduziu o tempo ocioso e revolucionou a forma como os recursos computacionais são gerenciados.</p>
<p>Antes de continuarmos, podemos fazer uma pequena definição: <strong>chamamos de processo os programas que estejam em memória, estejam sendo executados, ou não</strong>. Depois, voltaremos a essa definição com mais profundidade. Por agora basta para continuarmos.</p>
<section id="características-fundamentais-da-multiprogramação" class="level4" data-number="2.1.3.1">
<h4 data-number="2.1.3.1" class="anchored" data-anchor-id="características-fundamentais-da-multiprogramação"><span class="header-section-number">2.1.3.1</span> Características Fundamentais da multiprogramação</h4>
<p>A multiprogramação introduziu conceitos que se tornariam os pilares dos <strong>Sistemas Operacionais</strong> modernos. Notadamente a capacidade de manter vários programas carregados simultaneamente na memória principal. Diferentemente dos sistemas <code>batch</code>, onde apenas um programa residia na memória por vez, a multiprogramação permitia que múltiplos programas coexistissem na memória principal, aguardando sua vez de utilizar a <code>CPU</code>. Neste contexto os processos só cedem controle da <code>CPU</code> <strong>voluntariamente</strong> ou quando se tornam bloqueados devido a operações de <code>E/S</code>. Chamamos essa regra de comutação de <strong>Troca não-preemptiva</strong> indicando que não há interrupção forçada por um fator temporal. No paradigma da multiprogramação o sistema simplesmente aproveita os momentos naturais de espera para maximizar a utilização dos recursos computacionais. Esta estratégia maximiza a utilização da <code>CPU</code>. Quando um processo executa uma operação de <code>E/S</code> e se torna bloqueado, o <strong>Sistema Operacional</strong> seleciona automaticamente outro processo que esteja pronto para execução. Um exemplo de como este <em>chaveamento de processos</em> em memória, chamado em inglês de <em>context switching</em> pode ser visto na <a href="#fig-multiprogramação" class="quarto-xref">Figure&nbsp;<span>2.6</span></a>.</p>
<div id="fig-multiprogramação" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-multiprogramação-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/multiprocessing-diagram.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-multiprogramação-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.6: Funcionamento da multiprogramação com <em>context switching</em>, a troca de processos em memória. Demonstração do ciclo de execução onde Processo A bloqueia em operação de <code>E/S</code>(t1), o agendador do <strong>Sistema Operacional</strong> realiza a troca de contexto para Processo B (t2-t3), e Processo A retorna à fila de processos prontos após conclusão do <code>E/S</code> (t4-t5).
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>O termo <strong>preemptivo</strong> chegou ao português a partir do inglês <code>preemptive</code>. Este termo tem origem na expressão latina <em>praeemptio</em> que significa: comprar antes. Usada quando uma pessoa tem direito de preferência na compra de um bem. A partir do século XIX o sentido de <code>preemptive</code> se expandiu para um sentido mais geral: agir antes. Durante a guerra fria a expressão <code>preemptive strike</code> se popularizou significando um ataque feito para impedir que o inimigo realize um ataque iminente. No contexto dos <strong>Sistemas Operacionais</strong>, o termo <code>preemptive</code> refere-se a uma técnica onde o <strong>Sistema Operacional</strong> pode interromper um processo em execução para dar prioridade a outro processo, garantindo que todos os processos tenham uma chance justa de serem executados. Há um verbo se esforçando para emergir dos confins do estrangeirismo relacionado a esta palavra no português: preemptar. Eu vou usar preemptivo, mas me recuso a usar preemptar como verbo. Deus me livre!</p>
</div>
</div>
<p>Um fator interessante de multiprogramação é que sua eficácia pode ser modelada matematicamente. Se um processo gasta uma fração <span class="math inline">\(p\)</span> do seu tempo esperando por operações de <code>E/S</code>, a probabilidade de <span class="math inline">\(n\)</span> processos, todos residentes na memória, estarem simultaneamente esperando por <code>E/S</code> é <span class="math inline">\(p^n\)</span>. No paradigma da multiprogramação a <code>CPU</code> só estará ociosa se todos os processos estiverem esperando. Portanto, a utilização da <code>CPU</code> é a probabilidade de que pelo menos um processo não esteja esperando por <code>E/S</code>, o que pode ser expresso pela fórmula:</p>
<p><span class="math display">\[\text{Utilização da CPU} = 1 - p^n\]</span></p>
<p>Nesta equação, temos:</p>
<ul>
<li><span class="math inline">\(p\)</span> representa a fração de tempo que um processo gasta em operações de <code>E/S</code>;</li>
<li><span class="math inline">\(n\)</span> é o número total de processos mantidos na memória.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Demonstração Prática: O Poder da multiprogramação</strong></p>
<p>A fórmula <span class="math inline">\(\text{Utilização da CPU} = 1 - p^n\)</span> pode parecer abstrata, mas seus resultados são impressionantes. Vamos considerar um cenário fictício. Neste cenário, os processos gastam <span class="math inline">\(50\%\)</span> do tempo em <code>E/S</code>. Ou seja, <span class="math inline">\(p = 0.5\)</span>. Logo:</p>
<div id="tbl-simul" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-simul-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2.1: Simulação do ganho de <code>throughput</code> com a multiprogramação.
</figcaption>
<div aria-describedby="tbl-simul-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Processos (n)</th>
<th style="text-align: center;"><span class="math inline">\(p^n\)</span></th>
<th style="text-align: center;">Utilização da <code>CPU</code></th>
<th style="text-align: center;">Melhoria</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(0.5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(50\%\)</span></td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(0.25\)</span></td>
<td style="text-align: center;"><span class="math inline">\(75\%\)</span></td>
<td style="text-align: center;"><span class="math inline">\(+50\%\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(0.0625\)</span></td>
<td style="text-align: center;">$93.75%</td>
<td style="text-align: center;"><span class="math inline">\(+87.5\%\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;"><span class="math inline">\(0.0039\)</span></td>
<td style="text-align: center;"><span class="math inline">\(99.61\%\)</span></td>
<td style="text-align: center;"><span class="math inline">\(+99.2\%\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p><strong>Observação Importante</strong>: com apenas <span class="math inline">\(4\)</span> processos na memória, é possível obter quase <span class="math inline">\(94\%\)</span> de utilização da <code>CPU</code>, mesmo quando cada processo passa metade do tempo esperando <code>E/S</code>! Considere, no entanto, que há uma limitação prática neste cenário: esta análise assume que sempre há pelo menos um processo pronto para executar e não considera o custo computacional da troca de contexto. Esse custo é o custo inerente, na forma de ciclos de máquina e acessos à memória, para tirar um processo da <code>CPU</code> e colocar outro.</p>
</div>
</div>
<p>A esperta leitora deve observar que, mesmo com um valor de <span class="math inline">\(p\)</span> relativamente alto, por exemplo o valor de <span class="math inline">\(0.5\)</span> que usamos para indicar que os processos passam metade do tempo em <code>E/S</code>, aumentar o número de processos <span class="math inline">\(n\)</span> na memória faz com que o termo <span class="math inline">\(p^n\)</span> diminua, levando a utilização da <code>CPU</code> para perto de <span class="math inline">\(100\%\)</span>. A <a href="#fig-multiprog1" class="quarto-xref">Figure&nbsp;<span>2.7</span></a> representa claramente a ideia de multiprogramação, onde múltiplos processos estão na memória, cada um em diferentes estados (<code>CPU</code>, <code>E/S</code>, <code>waiting</code>), e o cronograma temporal demonstra como a <code>CPU</code> alterna entre processos durante operações de <code>E/S</code> de outros.</p>
<div id="fig-multiprog1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-multiprog1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/multiprogramacao_CPU.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-multiprog1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.7: Representação da alocação de múltiplos processos em memória e os estados onde eles se encontram.
</figcaption>
</figure>
</div>
<p>O advento do chaveamento de contexto, essencial para manter a <code>CPU</code> ocupada quando um processo realizava operações lentas de <code>E/S</code>, tornou a gestão de memória eficiente um pré-requisito indispensável. Múltiplos processos precisavam ser mantidos na memória simultaneamente, exigindo que o sistema operacional os alocasse e protegesse de forma rigorosa. Uma gestão de memória eficaz era, portanto, o alicerce que permitia ao agendador de tarefas realizar a troca de processos de forma rápida e confiável.</p>
<p>Outro avanço desta era que merece nossa atenção foi o <em>spooling</em>, em inglês <strong>S</strong>imultane s <strong>P</strong>eripheral <strong>O</strong>peration <strong>O</strong>n-<strong>L</strong>ine<strong>, uma técnica que utiliza o disco como <code>buffer</code> intermediário para operações de <code>E/S</code>. Isso permitiu que a <code>CPU</code> e os dispositivos de <code>E/S</code> operassem de forma concorrente, melhorando a eficiência geral do sistema. Um exemplo marcante dessa era é o </strong>OS/360 da IBM<strong>, anunciado em 1964. O </strong>OS/360** era um sistema de multiprogramação que estabeleceu muitos dos conceitos ainda utilizados nos <strong>Sistemas Operacionais</strong> modernos. O termo <strong>OS/360</strong> refere-se a uma família de <strong>Sistemas Operacionais</strong> desenvolvidos pela IBM para sua linha de mainframes <strong>System/360</strong>. Nesta linha de computadores, a IBM introduziu a multiprogramação como um recurso central e fundamental do sistema. O <strong>OS/360</strong> foi projetado para suportar uma ampla gama de aplicações, desde processamento de dados até computação científica, e estabeleceu padrões que influenciaram profundamente o desenvolvimento de <strong>Sistemas Operacionais</strong> subsequentes<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Definindo Buffer</strong> O termo <code>buffer</code> é outro desses termos em inglês que tomaram de assalto o vocabulário da computação no Brasil. Talvez, algum pesquisador de língua inglesa tenha se lembrado de uma passagem da infância, de alguma outra área da vida e trouxe o termo para a computação e hoje vivemos com ele. O termo <code>buffer</code> deriva do verbo em inglês antigo <code>buff</code>, que significava golpear ou amortecer um golpe. Esse sentido inicial estava ligado à ideia de suavizar ou absorver um impacto físico, como uma pancada. Na física, um <code>buffer</code> é um dispositivo que reduz o impacto ou choque, como os amortecedores usados em trens e carros para suavizar colisões com o meio. Em inglês o termo <code>buffer</code> também pode se referir a algo, alguém, que funciona como uma barreira protetora. Em computação um <code>buffer</code> é uma área de armazenamento temporário para dados, instruções, usada enquanto eles estão sendo transferidos entre dois lugares, processos, distintos. Por exemplo, um <code>buffer</code> pode guardar informações de um dispositivo rápido, como um processador, antes de enviá-las para um dispositivo mais lento, como uma impressora, ajudando a equilibrar diferenças de velocidade.</p>
</div>
</div>
<p>Ó poetas mortos da língua portuguesa, perdoai este pobre autor pelos crimes que comete!</p>
<p>A curiosa leitora deve notar que a IBM não criou o termo <strong>Sistema Operacional</strong>, mas foi fundamental para sua popularização. O termo já existia na comunidade de computação antes do lançamento do <span class="math inline">\(OS/360\)</span> pela IBM em 1964. Por exemplo, sistemas como o <a href="https://en.wikipedia.org/wiki/GM-NAA_%60E/S%60">GM-NAA <code>E/S</code></a>, desenvolvido em 1956, e o <a href="https://pt.wikipedia.org/wiki/Compatible__time-sharing__System">CTSS</a>, descrito em 1962, já eram chamados de <strong>Sistemas Operacionais</strong> em contextos acadêmicos e de pesquisa. No entanto, o <strong>OS/360</strong>, marcou um ponto de virada na história da computação. Deste ponto em diante, <strong>podemos usar o termo </strong>Sistema Operacional** para nos referirmos a um software que gerencia recursos de hardware e fornece serviços essenciais para programas de aplicação**.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Sistema Operacional</strong>: George F. Ryckman utilizou o termo <em>operating system</em> em seu artigo de maio de 1960 intitulado <a href="https://dl.acm.org/doi/pdf/10.1145/1460361.1460406"><em>The computer operation language</em></a>. Neste artigo Ryckman discutiu o <strong>Sistema Operacional</strong> SHARE. Esta parece ser a primeira utilização documentada do termo de uma forma familiar à que utilizamos atualmente. Antes do termo <strong>Sistema Operacional</strong> se estabelecer, esses programas residentes em segundo plano eram frequentemente chamados de <em>monitors</em>, <em>monitor-programs</em>, <em>supervisor</em>, <em>executive</em>, <em>operating executive</em>.</p>
</div>
</div>
<p>A multiprogramação e o <em>spooling</em> estruturaram as bases para a abstração de hardware e a automação do gerenciamento de recursos que usamos hoje. Contudo, a utilização de computadores ainda era árida e limitada a especialistas. Na maior parte das vezes, não havia qualquer interação com o usuário. Um especialista escrevia um programa, outro especialista o rodava e um terceiro entregava os resultados.</p>
</section>
</section>
<section id="sec-timesharing" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="sec-timesharing"><span class="header-section-number">2.1.4</span> Era da Interatividade: Sistemas de Tempo Compartilhado (final dos 1960s - 1980s)</h3>
<p>Os sistemas de tempo compartilhado, em inglês <em>time-sharing</em>, representaram o nascimento da <strong>multitarefa interativa moderna</strong>. Sendo uma evolução natural da multiprogramação, seu foco passou a ser a experiência do usuário, sem abrir mão da eficiência da <code>CPU</code>. Esses sistemas revolucionaram a computação ao dividir o tempo da <code>CPU</code> entre múltiplos usuários interativos quase simultaneamente, criando um ambiente operacional no qual cada usuário tem a impressão de estar utilizando um computador dedicado exclusivamente a ele.</p>
<p>A abordagem de time-sharing marcou uma mudança significativa de paradigma nos sistemas computacionais. Essa transição foi possível graças à implementação do <em>time slicing</em>, fatiamento de tempo, uma técnica na qual cada processo recebe uma pequena fatia de tempo fixa para uso da <code>CPU</code>. Essa fatia de tempo é frequentemente chamada de quantum ou, mantendo o termo em inglês, <em>time slice</em>. O processo acessa a <code>CPU</code> e roda durante este intervalo antes de ser temporariamente suspenso para permitir que outros processos sejam executados. Essa abordagem cria a ilusão de que cada usuário tem acesso exclusivo aos recursos do computador, melhorando significativamente a interatividade e a experiência geral do usuário.</p>
<p>O <em>time-sharing</em> possui características distintivas importantes. A <strong>preempção por tempo</strong> é uma delas: diferentemente da multiprogramação, na qual os processos cedem controle voluntariamente ou quando bloqueiam, o <em>time-sharing</em> introduziu a preempção forçada. Cada processo recebe um quantum de tempo fixo, e quando esse tempo expira, o <strong>Sistema Operacional</strong> interrompe forçosamente o processo e concede a <code>CPU</code> ao próximo processo na fila. Outra característica é a <strong>interatividade prioritária</strong>: o objetivo principal mudou de maximizar <code>throughput</code>, como na multiprogramação, para fornecer responsividade interativa. O sistema é otimizado para garantir que cada usuário receba tempo de <code>CPU</code> de forma rápida e regular. Este quantum de tempo pode ser calculado por:</p>
<p><span class="math display">\[\text{Quantum time} = \frac{\text{Total `CPU` time}}{\text{Number of active processes}}\]</span></p>
<p>A <a href="#fig-time1" class="quarto-xref">Figure&nbsp;<span>2.8</span></a> ilustra o conceito de time-sharing.</p>
<div id="fig-time1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-time1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/time-sharing-diagram.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-time1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.8: Sistema de time-sharing com escalonamento round-robin. Demonstração do quantum temporal e preempção forçada, onde múltiplos usuários (A, B, C) compartilham a <code>CPU</code> através de fatias de tempo fixas, criando a ilusão de uso exclusivo para cada terminal interativo.
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Round-Robin Scheduling</strong></p>
<p>O algoritmo <strong>round-robin</strong> é uma técnica de escalonamento preemptivo na qual cada processo recebe uma fatia de tempo igual para executar em <code>CPU</code> antes de ser suspenso e enviado para o final da fila de processos prontos. Para tanto, o agendador mantém uma fila circular de processos. Quando o quantum de um processo expira, ele é interrompido e o próximo processo da fila obtém a <code>CPU</code>. Isso garante que todos os processos recebam uma oportunidade equitativa de execução. Usando <strong>round-robin</strong> cada processo recebe o mesmo quantum de tempo graças a preempção forçada quando o tempo expira.</p>
<p>O termo <em>round-robin</em> vem em inglês, mas tem sua origem etimológica ligada ao termo francês <em>rond ruban</em> do século XVII. Uma forma de assinar petições em vários círculos concêntricos para que o primeiro a assinar não pudesse ser identificado e punido. Há outra referência, do século XIX, quando o termo foi adotado para torneios nos quais cada participante competia com todos os outros um número igual de vezes, garantindo que todos tivessem a mesma oportunidade de vencer. Quando os cientistas da computação precisaram de um nome para um algoritmo de escalonamento que tratasse todos os processos de forma igualitária, o termo “round-robin” era a analogia perfeita.</p>
<p>O round-robin garante responsividade e justiça. Nenhum processo monopoliza a <code>CPU</code>. Como nem sempre os céus são azuis e os mares estão calmos, o tamanho do quantum é crítico. Muito pequeno causa custos extras de processamento por excesso de chaveamento de contexto. Muito grande reduz a responsividade do sistema. A virtude está no equilíbrio!</p>
</div>
</div>
<section id="distinguindo-multiprogramação-de-time-sharing" class="level4" data-number="2.1.4.1">
<h4 data-number="2.1.4.1" class="anchored" data-anchor-id="distinguindo-multiprogramação-de-time-sharing"><span class="header-section-number">2.1.4.1</span> Distinguindo multiprogramação de Time-Sharing</h4>
<p>É importante que a atenta leitora compreenda as diferenças fundamentais entre multiprogramação e <em>time-sharing</em>. A <a href="#tbl-multiprocessamento_timesharing" class="quarto-xref">Table&nbsp;<span>2.2</span></a> resume as principais distinções entre os dois paradigmas.</p>
<div id="tbl-multiprocessamento_timesharing" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-multiprocessamento_timesharing-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2.2: Comparação entre multiprogramação e Time-Sharing
</figcaption>
<div aria-describedby="tbl-multiprocessamento_timesharing-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 23%">
<col style="width: 34%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th>Aspecto</th>
<th>multiprogramação</th>
<th>Time-Sharing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Objetivo Principal</strong></td>
<td>Maximizar utilização de <code>CPU</code></td>
<td>Garantir responsividade interativa</td>
</tr>
<tr class="even">
<td><strong>Troca de Contexto</strong></td>
<td>Apenas quando processo bloqueia</td>
<td>Por quantum de tempo <strong>ou</strong> quando bloqueia</td>
</tr>
<tr class="odd">
<td><strong>Preempção</strong></td>
<td>Não</td>
<td>Sim (por tempo)</td>
</tr>
<tr class="even">
<td><strong>Tipo de Usuário</strong></td>
<td><code>batch</code>, jobs, processamento em lote</td>
<td>Usuários interativos</td>
</tr>
<tr class="odd">
<td><strong>Custo Computacional</strong></td>
<td>Mínimo</td>
<td>Maior (context switching frequente)</td>
</tr>
<tr class="even">
<td><strong>Aplicação Ideal</strong></td>
<td>Sistemas com alta taxa de <code>E/S</code></td>
<td>Sistemas multiusuário interativos</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Context Switching: O Custo da Interatividade</strong></p>
<p>O <strong>context switching</strong>, troca de contexto, é o mecanismo pelo qual o <strong>Sistema Operacional</strong> salva o estado atual de um processo e carrega o estado de outro processo. Este processo inclui:</p>
<ol type="1">
<li><strong>Salvamento do estado</strong>: registradores da <code>CPU</code>, <em>program counter</em>, <em>stack pointer</em>;</li>
<li><strong>Atualização de estruturas</strong>: tabelas de processos, controle de memória;</li>
<li><strong>Carregamento do novo estado</strong>: restauração dos registradores do próximo processo.</li>
</ol>
<p>O custo computacional do chaveamento de contexto é o preço a ser pago pela interatividade. Em sistemas de <em>time-sharing</em>, esse custo é compensado pela melhor experiência do usuário, enquanto na multiprogramação pura, as trocas são minimizadas para maximizar <code>throughput</code>.</p>
</div>
</div>
</section>
<section id="sistemas-influentes-em-time-sharing" class="level4" data-number="2.1.4.2">
<h4 data-number="2.1.4.2" class="anchored" data-anchor-id="sistemas-influentes-em-time-sharing"><span class="header-section-number">2.1.4.2</span> Sistemas Influentes em Time-Sharing</h4>
<p>Entre os sistemas de tempo compartilhado mais influentes da história da computação, destacaremos três cujas características são importantes para os objetivos deste pretensioso autor:</p>
<ol type="1">
<li><p><strong>CTSS</strong>: o <strong>C</strong>ompatible <strong>T</strong>ime-<strong>S</strong>haring <strong>S</strong>ystem foi desenvolvido no Massachusetts Institute of Technology (MIT). Este sistema foi pioneiro no uso de compartilhamento de tempo com interrupções, uma técnica que permitia a múltiplos usuários compartilharem os recursos de um computador de maneira operacionalmente mais eficiente. O <a href="https://people.csail.mit.edu/saltzer/Multics/CTSS-Documents/CTSS-Documents.html#overview">CTSS</a> estabeleceu muitos dos conceitos fundamentais que formaram a estrutura dos <strong>Sistemas Operacionais</strong> interativos modernos, <strong>incluindo mecanismos de alocação de recursos e gerenciamento de processos que garantiam uma experiência de usuário mais responsiva e interativa</strong>.</p></li>
<li><p><strong>MULTICS</strong>: o <strong>Mult</strong>iplexed <strong>I</strong>nformation and <strong>C</strong>omputing <strong>S</strong>ervice foi o resultado de um projeto colaborativo entre o MIT, a General Electric e os Bell Labs. O <strong>MULTICS</strong> introduziu os conceitos de memória de nível único, simplificando o gerenciamento de memória, a ligação dinâmica de código, que permitiu maior flexibilidade na execução de programas, e um sistema de arquivos hierárquico, que permitiu a organização de dados de forma mais intuitiva. O <a href="https://web.mit.edu/multics-history/">MULTICS</a> tinha um forte foco em segurança, introduzindo mecanismos avançados de proteção de dados e controle de acesso. Embora o <strong>MULTICS</strong> tenha tido um sucesso comercial limitado, sua influência no desenvolvimento dos <strong>Sistemas Operacionais</strong> subsequentes foi relevante, estabelecendo padrões que ainda são seguidos.</p></li>
<li><p><strong>UNIX</strong>, desenvolvido nos Bell Labs por <a href="https://pt.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> e <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie</a>, merece destaque especial. Inspirado pelo <strong>MULTICS</strong>, o <strong>UNIX</strong> foi criado com uma filosofia de simplicidade e elegância que o tornou extremamente popular. Diferente de seu predecessor, o <a href="https://unix.org/"><strong>UNIX</strong></a> foi escrito na <strong>Linguagem C</strong>, o que lhe conferiu uma portabilidade notável, permitindo que fosse executado em uma grande variedade de plataformas de hardware. O <strong>UNIX</strong> também se destacou por seu ambiente multiusuário e multitarefa, permitindo que múltiplos usuários trabalhassem simultaneamente no mesmo sistema, cada um executando várias tarefas ao mesmo tempo. <strong>Os sistemas </strong>UNIX<strong>, versão de 1993, apresentavam pilhas <code>TCP/IP</code> maduras, com <code>sockets BSD</code> desde 1983, memória virtual sofisticada com paginação por demanda, sistemas de arquivos avançados e capacidades de computação distribuída por meio de NFS e RPC. Acrescente a isso que o </strong>UNIX** introduziu um sistema de arquivos hierárquico e um <code>shell</code> de comando, que oferecia aos usuários uma interface flexível e eficiente para interagir com o sistema<strong>. O </strong>UNIX** estabeleceu um padrão de design que influenciou profundamente o desenvolvimento dos <strong>Sistemas Operacionais</strong> subsequentes, incluindo, obviamente o <strong>Linux</strong>, o <strong>macOS</strong> e até mesmo o <strong>Windows</strong> e continua a ser uma referência importante.</p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>O </strong>UNIX** e o C<strong> O nome <code>**UNIX**</code> é uma brincadeira derivada de </strong>Multics<strong>. O </strong>Multics** foi um projeto ambicioso, mas complexo e pesado. Quando Ken Thompson e Dennis Ritchie começaram a desenvolver um sistema mais simples e eficiente, chamaram-no de <strong>UNIX</strong> como um trocadilho, sugerindo algo mais unitário e simplificado. O nome também pode ser interpretado como uma abreviação de <em><strong>UNI</strong>ple<strong>X</strong>ed Information and Computing Service</em>, embora esta interpretação seja mais uma explicação retroativa e racionalização do que a intenção original.</p>
</div>
</div>
<p>A <strong>Linguagem C</strong> foi criada por Dennis Ritchie na Bell Labs entre 1972 e 1973. A <strong>linguagem C</strong> foi desenvolvida especificamente para facilitar o desenvolvimento do <strong>Sistema Operacional UNIX</strong>. Dennis Ritchie descreveu o <strong>C</strong> como <em>uma linguagem de implementação de sistema para o nascente <strong>Sistema Operacional UNIX</strong></em>. A <a href="#fig-unixtimeline" class="quarto-xref">Figure&nbsp;<span>2.9</span></a> ilustra a relação entre o <strong>UNIX</strong> e a <strong>Linguagem C</strong>.</p>
<div id="fig-unixtimeline" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-unixtimeline-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/unix_c_timeline.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-unixtimeline-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.9: A evolução histórica que levou a <strong>UNIX</strong>, <strong>Linux</strong> e <strong>Windows NT</strong>.
</figcaption>
</figure>
</div>
<p>Para facilitar o desenvolvimento do <strong>UNIX</strong>, a <strong>Linguagem C</strong> foi projetada para ser uma linguagem de programação de sistemas, com foco em eficiência, portabilidade e expressividade. Essa linguagem permitiu que o <strong>UNIX</strong> fosse reescrito, de forma mais concisa e legível, facilitando a manutenção e evolução do sistema. Enquanto o <strong>Sistema Operacional</strong> era reescrito na <strong>Linguagem C</strong>, a portabilidade também aumentava, permitindo que o <strong>UNIX</strong> rodasse em diferentes arquiteturas de computador. A <strong>Linguagem C</strong> foi criada com o objetivo de mover o código do <code>Kernel</code> <strong>UNIX</strong> da <strong>Linguagem Assembly</strong> para uma linguagem de alto nível, que realizaria as mesmas tarefas com menos linhas de código. Como Dennis Ritchie construiu a <strong>Linguagem C</strong> sobre a <strong>Linguagem B</strong>, a <strong>Linguagem C</strong> herdou a sintaxe concisa de Thompson que possuía uma poderosa mistura de funcionalidades de alto nível com os recursos específicos necessários para criar um <strong>Sistema Operacional</strong> que fosse portável entre diferentes plataformas de hardware. E esta foi a vantagem competitiva do <strong>UNIX</strong>.</p>
<p>O estudo da história do <strong>UNIX</strong> destaca um princípio importante no design de sistemas: <strong>soluções pragmáticas e focadas muitas vezes ganham maior adoção do que aquelas excessivamente ambiciosas e complexas</strong>. A portabilidade do <strong>UNIX</strong>, a capacidade de rodar em hardwares diferentes, foi um divisor de águas, permitindo a disseminação deste <strong>Sistema Operacional</strong> por plataformas de hardware tão diversas quanto <em>mainframes</em> e dispositivos portáteis.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Kernel vs Sistema Operacional</strong></p>
<p>Chamamos de <code>Kernel</code> o componente central, e o mais importante do <strong>Sistema Operacional</strong>. A melhor tradução de <code>kernel</code> é núcleo. O <code>Kernel</code> será a primeira parte do <strong>Sistema Operacional</strong> que será carregada na memória durante o <code>boot</code> e conterá as funções necessárias para atuar como uma ponte entre hardware e software. O <code>Kernel</code> opera no nível mais baixo do sistema, gerenciando recursos fundamentais como: processos, decidindo qual programa usa a <code>CPU</code> e por quanto tempo; memória <code>RAM</code>, controlando alocação e proteção entre programas; dispositivos de hardware, por meio de <code>drivers</code>; e fornecendo interfaces para que aplicações solicitem serviços do sistema. O <code>Kernel</code> é essencialmente invisível ao usuário comum, operando em modo privilegiado para garantir estabilidade e segurança do sistema.</p>
<p>O <strong>Sistema Operacional</strong>, por sua vez, é o conjunto completo de software que inclui o <code>Kernel</code> mais todos os componentes que tornam o computador útil e amigável para o usuário final. Além do <code>Kernel</code>, um <strong>Sistema Operacional</strong> engloba: interfaces de usuário; ambientes para interpretação de comandos, que chamaremos de <code>shell</code>; sistema de arquivos para organização de dados; utilitários de sistema como gerenciadores de arquivos e painéis de controle; e bibliotecas de funções de sistema que fornecem APIs, em inglês <strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface, para desenvolvimento de aplicações. Todos esses componentes trabalham em conjunto, geralmente invisíveis, para criar uma experiência coesa, funcional e eficiente.</p>
<p><em>Pessoas mais inteligentes que eu dizem que a tecnologia e a civilização avançam em rampas e degraus. Existe sempre uma rampa positiva de crescimento com inclinações variáveis e diferentes. De tempos em tempos, uma inovação, descoberta significativa, ocorre criando um salto qualitativo, o degrau, na capacidade tecnológica. O par <strong>UNIX</strong> e <strong>C</strong> é, claramente, um destes degraus.</em></p>
</div>
</div>
</section>
</section>
<section id="a-democratização-da-computação-era-dos-computadores-pessoais-final-dos-1970s---presente" class="level3" data-number="2.1.5">
<h3 data-number="2.1.5" class="anchored" data-anchor-id="a-democratização-da-computação-era-dos-computadores-pessoais-final-dos-1970s---presente"><span class="header-section-number">2.1.5</span> A Democratização da Computação: Era dos Computadores Pessoais (final dos 1970s - presente)</h3>
<p>A invenção e popularização dos <strong>microprocessadores</strong>, impulsionadas pelos avanços em <strong>L</strong>arge <strong>S</strong>cale <strong>I</strong>ntegration, <strong>LSI</strong>, a expressão em inglês para integração em larga escala, e em <strong>V</strong>ery <strong>L</strong>arge <strong>S</strong>cale <strong>I</strong>ntegration, <strong>VLSI</strong>, integração em escala muito grande em inglês, levaram ao surgimento de computadores pessoais acessíveis, em quase todo o mundo. No Brasil, no final dos anos 1980, era mais fácil importar um computador que comprar um telefone.</p>
<p>As novas tecnologias permitiram a miniaturização e a redução de custos, tornando possível a criação de computadores suficientemente baratos para caberem em um gabinete pouco maior que uma caixa de sapatos e serem adquiridos por indivíduos e pequenas empresas. Esses computadores pessoais, <strong>PCs</strong> como a IBM chamava, eram, e são, milhares de vezes mais baratos que os <code>mainframes</code>. Estes computadores eram portáteis, substituíveis e capazes de evoluir muito mais rapidamente. De repente, os computadores estavam em todos segmentos da sociedade, da contabilidade à pesquisa científica, da torradeira ao avião. A popularização dos <strong>PCs</strong> levou ao desenvolvimento de <strong>Sistemas Operacionais</strong> mais acessíveis e amigáveis. Neste ponto, o laço de realimentação positiva, o hardware evolui e requer software mais sofisticado, e o software sofisticado requer hardware mais potente, se torna evidente. O ciclo de desenvolvimento de <strong>Sistemas Operacionais</strong> e hardware acelera. Tornando a computação ubíqua e quase tão indispensável quanto o ar que respiramos. Nuvens negras apareceram no horizonte. Em um dado momento, o ciclo de evolução contínua atingiu uma barreira.</p>
<p>Circuitos integrados, mais rápidos e menores, encontraram um limite físico/econômico. Máquinas menores e mais rápidas implicavam em altas velocidades de <code>clock</code>, relógio em inglês. O <code>clock</code> é o sinal que comuta todos os dispositivos da <code>CPU</code> e sincroniza as operações do sistema como um metrônomo ajuda o estudante de música a seguir o ritmo. Aumentar a frequência do <code>clock</code> aumenta o calor gerado. O calor é um inimigo mortal da eletrônica. Circuitos derretem e pegam fogo. Na virada do milênio, o aumento da temperatura exigia sistemas de resfriamento mais complexos, aumentando o custo e a complexidade dos sistemas. Neste ponto, a miniaturização dos circuitos integrados tornou-se cada vez mais difícil devido às limitações físicas dos materiais semicondutores. O limite estava próximo dos <span class="math inline">\(3 Ghz\)</span>. Uma barreira a ser transposta ou um beco sem saída? A resposta estava no horizonte, mas não era óbvia.</p>
<p>Neste ponto da história, o processamento em paralelo, várias máquinas trabalhando juntas, já era uma solução viável. No entanto, o processamento em paralelo exigia que os programas fossem escritos de forma a tirar proveito dessa capacidade, o que não era trivial. A maioria dos programas existentes não era projetada para serem executados em múltiplos processadores simultaneamente. Além disso, as máquinas precisavam ser interligadas por redes físicas o que limitava a velocidade do processamento. Alguém pensou: já que podemos integrar circuitos em uma escala tão grande, por que não colocar duas <code>CPUs</code> no mesmo chip?</p>
<p>Entram em cena os <em>chips multicore</em>.</p>
<p>Os <em>chips multicore</em>, como são popularmente conhecidos, integram dois ou mais núcleos de processamento colocados em um único circuito integrado, rodando a velocidades mais baixas, esquentando menos, porém com um <code>throughput</code> maior. Novamente, a evolução do hardware exigiu uma evolução do software mudando a forma como os programas eram escritos e executados. O software precisava ser adaptado para tirar proveito dos múltiplos núcleos de processamento, o que exigia novas técnicas de programação e algoritmos de escalonamento mais sofisticados. A <a href="#fig-multicore" class="quarto-xref">Figure&nbsp;<span>2.10</span></a> ilustra a evolução dos processadores multicore.</p>
<div id="fig-multicore" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-multicore-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/multicore_timeline.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-multicore-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.10: Evolução dos microprocessadores multi-core de 2001 a 2025, demonstrando a transição da era single-core para sistemas many-core. A linha do tempo destaca marcos tecnológicos fundamentais desde o IBM POWER4, primeiro dual-core comercial, até as tendências futuras com arquiteturas híbridas, <em>chiplet design</em> e integração de aceleradores de Inteligência Artificial. As fases evolutivas evidenciam a progressão do número de cores, redução dos processos de fabricação, de 180nm para 3nm, e o aumento exponencial da densidade de transistores, consolidando o paradigma de paralelismo em hardware moderno.
</figcaption>
</figure>
</div>
<section id="a-era-dos-multiprocessadores-paralelismo-real" class="level4" data-number="2.1.5.1">
<h4 data-number="2.1.5.1" class="anchored" data-anchor-id="a-era-dos-multiprocessadores-paralelismo-real"><span class="header-section-number">2.1.5.1</span> A Era dos Multiprocessadores: Paralelismo Real</h4>
<p>Primeiro, a IBM. Lançado em 2001, o <strong>IBM POWER4</strong> foi o primeiro microprocessador a integrar dois núcleos de processamento em um único chip de silício. Ele foi projetado para uso em servidores e sistemas de alta performance, muito antes da tecnologia se tornar padrão em desktops e notebooks. A arquitetura do <strong>POWER4</strong> apresentava características avançadas, como o suporte a multiprocessamento simétrico, em inglês <strong>S</strong>ymmetric <strong>M</strong>ulti<strong>P</strong>rocessing, <strong>SMP</strong>, no próprio circuito integrado, permitindo que os dois núcleos trabalhassem de forma conjunta e eficiente em tarefas complexas. Quando a IBM lançou esta tecnologia voltada para o mercado empresarial, sinalizou uma oportunidade para a Intel.</p>
<p>A Intel deu o primeiro passo na era da computação multicore para o consumidor final em maio de 2005, com o lançamento do processador <strong>Pentium D</strong> com o codenome <em>Smithfield</em>. O <strong>Pentium D</strong> representou a resposta da Intel à crescente demanda por maior desempenho e capacidade de multitarefa imposta por um número cada vez maior de usuários de computação. A abordagem inicial da Intel com o <strong>Pentium D</strong> consistiu em unir dois núcleos de <strong>Pentium 4</strong> em uma pastilha de silício, permitindo que o <strong>Sistema Operacional</strong> e os aplicativos executassem múltiplos processos simultaneamente. Pouco tempo depois, em janeiro de 2006, a Intel lançou a linha <strong>Core Duo</strong>, com o codinome <code>Yonah</code>. Embora lançado posteriormente, o <strong>Core Duo</strong> é frequentemente considerado o primeiro processador multicore verdadeiro da Intel, devido à sua arquitetura mais integrada e eficiente em comparação com o <strong>Pentium D</strong>. No <strong>Core Duo</strong>, os dois núcleos compartilhavam o mesmo <code>cache L2</code>, o que permitiu uma comunicação mais rápida e eficiente entre eles, resultando em um desempenho superior e menor consumo de energia. E temos o mesmo <strong>throughput</strong> das máquinas anteriores, mas com menos calor e consumo de energia.</p>
<p>Com o avanço da tecnologia de semicondutores e a busca por maior performance, surgiu uma nova dimensão na computação: <strong>multiprocessamento</strong>. Diferentemente da multiprogramação e do time-sharing, que simulam execução simultânea em processadores únicos, o multiprocessamento oferece <strong>paralelismo verdadeiro</strong> através de múltiplas unidades de processamento físicas. Neste novo paradigma temos <strong>Paralelismo real</strong>: múltiplas instruções podem executar <strong>simultaneamente</strong> em processadores diferentes, não sequencialmente como nos sistemas anteriores. Cada processo pode ter acesso exclusivo de um processador físico separado, eliminando a necessidade de compartilhamento temporal da <code>CPU</code>. Dessa forma, implicando em um aumento de performance, de forma quase linear, em relação ao número de processadores. A otimista leitora deve se segurar. Não é tão bom assim. O ganho de eficiência, velocidade e <code>throughput</code> é grande, mas existem limites arquiteturais que estudaremos depois. A <a href="#fig-coreduo" class="quarto-xref">Figure&nbsp;<span>2.11</span></a> ilustra a relação entre as tecnologias da Intel para estes circuitos integrados.</p>
<div id="fig-coreduo" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-coreduo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/evolucao_processadores.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-coreduo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.11: A figura mostra a progressão arquitetural do Pentium 4 single-core para o <strong>Pentium D</strong> dual-core e <strong>Core Duo</strong>. O <strong>Pentium D</strong> implementou multiprocessamento através de duas pastilhas de silício separadas com <em>caches L2</em> independentes e comunicação limitada à velocidade do barramento compartilhado, resultando em alta latência inter-cores e consumo energético elevado, 95-130W. Em contraste, o <strong>Core Duo</strong> introduziu uma pastilha de silício unificada com <em>Smart Cache L2</em> compartilhado de <span class="math inline">\(2 MB\)</span> e interconexão direta entre <em>cores</em>, estabelecendo os fundamentos para o multiprocessamento eficiente que exigiu novos algoritmos de agendamento e gerenciamento de memória nos <strong>Sistemas Operacionais</strong> modernos.
</figcaption>
</figure>
</div>
<p>Agora que a atenta leitora já foi apresentada ao conceito de multiprocessamento, vamos comparar os três paradigmas fundamentais: multiprogramação, time-sharing e multiprocessamento. A <a href="#tbl-multishamulti" class="quarto-xref">Table&nbsp;<span>2.3</span></a> resume as principais diferenças entre estes três paradigmas:</p>
<div id="tbl-multishamulti" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-multishamulti-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2.3: Comparação entre Multiprogramação, Time-Sharing e Multiprocessamento.
</figcaption>
<div aria-describedby="tbl-multishamulti-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 19%">
<col style="width: 24%">
<col style="width: 29%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>Aspecto</th>
<th>Multiprogramação</th>
<th>Time-Sharing</th>
<th>Multiprocessamento</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Hardware</strong></td>
<td>Processador único</td>
<td>Processador único</td>
<td>Múltiplos processadores</td>
</tr>
<tr class="even">
<td><strong>Execução</strong></td>
<td>Sequencial cooperativa</td>
<td>Sequencial preemptiva</td>
<td>Paralela real</td>
</tr>
<tr class="odd">
<td><strong>Troca de contexto</strong></td>
<td>Apenas quando bloqueado</td>
<td>Por quantum de tempo</td>
<td>Comunicação entre CPUs</td>
</tr>
<tr class="even">
<td><strong>Preempção</strong></td>
<td>Não</td>
<td>Sim</td>
<td>Sim (aplicada em cada processador)</td>
</tr>
<tr class="odd">
<td><strong>Objetivo</strong></td>
<td>Utilização eficiente de <code>CPU</code></td>
<td>Responsividade interativa</td>
<td>Máximo <code>throughput</code></td>
</tr>
<tr class="even">
<td><strong>Overhead</strong></td>
<td>Mínimo</td>
<td>Context switching frequente</td>
<td>Sincronização entre processos</td>
</tr>
<tr class="odd">
<td><strong>Aplicação</strong></td>
<td>Sistemas <code>batch</code>,com <code>E/S</code></td>
<td>Sistemas interativos multiusuário</td>
<td>Computação paralela intensiva</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Os paradigmas que vimos até o momento são didaticamente interessantes e históricos, mas não são mutuamente exclusivos. Os sistemas modernos implementam uma combinação desses paradigmas para otimizar o desempenho e a responsividade resultando em sistemas híbridos que aproveitam o melhor de cada abordagem.</p>
</section>
<section id="sistemas-híbridos-a-convergência-dos-paradigmas" class="level4" data-number="2.1.5.2">
<h4 data-number="2.1.5.2" class="anchored" data-anchor-id="sistemas-híbridos-a-convergência-dos-paradigmas"><span class="header-section-number">2.1.5.2</span> Sistemas Híbridos: A Convergência dos Paradigmas</h4>
<p>Os <strong>Sistemas Operacionais</strong> modernos combinam elementos de multiprogramação, time-sharing e multiprocessamento para otimizar o desempenho e a responsividade. Essa convergência é essencial para atender às demandas crescentes de computação em ambientes complexos que vão desde servidores de alta performance até dispositivos móveis portáveis e vestíveis.</p>
<p>A evolução dos paradigmas de computação provoca a emersão do conceito de <strong>S</strong>ymmetric <strong>M</strong>ulti<strong>P</strong>rocessing, <strong>SMP</strong>, como uma solução híbrida que combina os três paradigmas fundamentais. O <strong>SMP</strong> permite que múltiplos processadores compartilhem a mesma memória e os mesmos recursos do sistema, enquanto cada processador executa processos de forma independente e simétrica. Diferentemente de arquiteturas assimétricas onde processadores têm funções específicas, no <strong>SMP</strong> todos os processadores são funcionalmente idênticos e podem executar qualquer tarefa do <strong>Sistema Operacional</strong>, incluindo rotinas do <code>kernel</code>.</p>
<p>Esta arquitetura simétrica possibilita que o <strong>Sistema Operacional</strong> implemente tanto multiprogramação quanto <em>time-sharing</em> em cada processador individual, criando uma matriz de execução onde <span class="math inline">\(n\)</span> processadores podem simultaneamente gerenciar <span class="math inline">\(m\)</span> processos através de fatias de tempo. O resultado é uma otimização multiplicativa do uso da <code>CPU</code> que melhora dramaticamente a responsividade do sistema e o <code>throughput</code> geral. Isso, porém, cria novos desafios de software para os <strong>Sistemas Operacionais</strong>. Entre eles estão o agendamento de tarefas, o balanceamento de carga e sincronização e coerência de dados.</p>
<ol type="1">
<li><p><strong>Agendador de Tarefas em Sistemas Híbridos</strong>: o <strong>agendador de tarefas</strong>, em inglês <em>task scheduler</em> em sistemas <strong>SMP</strong> representa uma evolução significativa em relação aos agendadores que existiam nos sistemas tradicionais com apenas um núcleo de processamento. Enquanto agendadores clássicos como o <code>Round Robin</code> ou o <code>Shortest Job First</code>, expressão em inglês para o trabalho menor primeiro, operavam em uma única fila de processos prontos. Os agendadores <strong>SMP</strong> devem coordenar múltiplas filas de execução distribuídas entre processadores. Em linhas gerais, já que vamos estudar isso com profundidade mais adiante, o agendador <strong>SMP</strong> deve lidar com as seguinte hierarquia de decisões:</p>
<ul>
<li><p><strong>Escalonamento Local</strong>: cada processador mantém sua própria fila de processos prontos e aplica algoritmos de <em>time-sharing</em>, tais como <strong>C</strong>ompletely <strong>F</strong>air <strong>S</strong>cheduler, <strong>CFS</strong>, o agendador antigo do <strong>Linux</strong>, para determinar qual processo executar durante o próximo quantum de tempo;</p></li>
<li><p><strong>Escalonamento Global</strong>: o sistema periodicamente avalia a distribuição de carga entre processadores e toma decisões de migração de processos para equilibrar a utilização;</p></li>
<li><p><strong>Escalonamento de Afinidade</strong>: o agendador considera a afinidade de <code>cache</code> e memória, preferindo manter processos no mesmo processador em que foram executados recentemente para minimizar os <code>cache misses</code>. Erros que ocorrem quando o dado desejado não está no <code>cache</code>.</p></li>
</ul></li>
<li><p><strong>Balanceamento de Carga</strong>: a arquitetura <strong>SMP</strong> induziu a aplicação do conceito de <strong>balanceamento de carga</strong>, em inglês <em>load balancing</em> para distribuir processos inteligentemente entre os processadores disponíveis. O algoritmo de balanceamento opera em múltiplas dimensões. A saber:</p>
<ul>
<li><strong>Balanceamento Quantitativo</strong>: distribui o número de processos ativos uniformemente entre processadores;</li>
<li><strong>Balanceamento Qualitativo</strong>: considera a intensidade computacional dos processos, evitando concentrar tarefas <em>CPU-intensive</em>, tarefas que requerem primordialmente o uso de <code>CPU</code>, em um único processador;</li>
<li><strong>Balanceamento Temporal</strong>: ajusta dinamicamente a distribuição com base em padrões de execução históricos.</li>
</ul>
<p>No domínio do balanceamento de carga duas tecnologias prevalecem: o balanceamento pode ser <em>push-based</em>, no qual processadores sobrecarregados migram processos proativamente. Neste caso, processadores ociosos solicitam trabalho ao agendador. Sistemas modernos frequentemente implementam abordagens híbridas que combinam ambas as estratégias.</p></li>
<li><p><strong>Desafios de Sincronização e Coerência</strong>: a convergência de paradigmas em sistemas <strong>SMP</strong>, além da complexidade do agendamento de tarefas e do balanceamento de cargas, introduziu novos graus de complexidade na sincronização entre processos e dados. Quando múltiplos processadores acessam estruturas de dados compartilhadas, tais como filas de processos, tabelas de páginas, o próprio agendador, os mecanismos de sincronização requerem atenção extra. Dessa forma, os <strong>Sistemas Operacionais</strong> modernos implementam um conjunto diversificado de mecanismos de sincronização para garantir a integridade dos dados e evitar condições de corrida. Condições de corrida são estados em que dois ou mais processos acessam o mesmo dado com direito de escrita e modificação. Em condições de corrida é difícil manter a integridade e coerência do dado. Entre os métodos usados estão:</p>
<ul>
<li><p><strong>Locks de Spin</strong>: representam o mecanismo mais fundamental para proteção de seções críticas de duração extremamente curta em ambientes <strong>SMP</strong>. Estes mecanismos são Implementados por meio de operações atômicas como <em>compare-and-swap</em> ou <em>test-and-set</em>, os <code>spinlocks</code> mantêm o processador em um laço ativo verificando continuamente o estado do <code>lock</code> até que seja liberado. Esta abordagem é particularmente eficiente quando o tempo de espera é menor que o custo computacional de uma troca de contexto, tipicamente para seções críticas que executam em menos de <span class="math inline">\(100\)</span> microssegundos. Em sistemas <em>multicore</em>, os <code>spinlocks</code> aproveitam a latência reduzida da comunicação <em>inter-core</em> usando o <code>cache</code> compartilhado, evitando o custo de chamados às funções do sistema e mudanças de estado do processo. Contudo, em cenários de alta contenção ou seções críticas longas, podem causar desperdício significativo de ciclos de <code>CPU</code> e degradação de performance.</p></li>
<li><p><strong>Mutexes</strong>: constituem o mecanismo padrão para sincronização de seções críticas de duração moderada a longa, implementando semântica de exclusão mútua com semântica de propriedade em <code>threads</code>. Mutexes modernos implementam algoritmos como <code>priority inheritance</code>, herança de prioridade, em que um <code>thread</code> de baixa prioridade que detém um <code>mutex</code> temporariamente herda a prioridade do <code>thread</code> de alta prioridade que está bloqueado esperando o <code>lock</code>.</p></li>
<li><p><strong>Semáforos</strong>: implementam um mecanismo generalizado de sincronização baseado em contadores que controla o acesso a recursos limitados em quantidade específica. Introduzidos por <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Dijkstra</a>, os semáforos mantêm um contador interno que representa o número de recursos disponíveis, permitindo que múltiplos <code>threads</code> acessem simultaneamente até o limite estabelecido.</p></li>
<li><p><strong>Read-Write Locks</strong>: representam uma otimização para cenários com padrões de acesso predominantemente de leitura, permitindo concorrência entre múltiplos processos leitores enquanto garantem exclusividade para processos escritores. Esta abordagem é fundamental em sistemas <strong>SMP</strong> para estruturas de dados como tabelas de páginas e diretórios de sistemas de arquivos nos quais operações de leitura são muito mais frequentes que modificações.</p></li>
</ul></li>
<li><p><strong>Métricas de Eficiência em Sistemas Híbridos</strong>: conceitualmente podemos acreditar que os sistemas híbridos sejam mais eficientes. É até possível que a atenta leitora concorde com isso, apenas olhando sua própria máquina e verificando os processos que estão em execução. Contudo, fé e observação não definem a ciência nem garantem performance. Precisamos de métricas para análise. A eficiência total de um sistema híbrido pode ser expressa como:</p>
<p><span class="math display">\[\text{System Efficiency} = \sum_{i=1}^{n} \text{CPU}_i \times \text{utilization}_i \times (1 - \text{overhead}_i)\]</span></p>
<p>na qual <span class="math inline">\(n\)</span> é o número de processadores, <span class="math inline">\(\text{utilization}_i\)</span> é a taxa de utilização do processador <span class="math inline">\(i\)</span>, e <span class="math inline">\(\text{overhead}_i\)</span> representa o custo computacional de sincronização e gerenciamento.</p>
<p>Esta equação captura a realidade de que a eficiência não escala linearmente com o número de processadores devido aos custos computacionais da própria sincronização. O termo <span class="math inline">\((1 - \text{overhead}_i)\)</span> torna-se particularmente significativo em sistemas com muitos núcleos de processamento, nos quais a contenção por <code>locks</code> e invalidações de <code>cache</code> podem degradar a performance. Para otimizar a eficiência, sistemas modernos implementam técnicas como <strong>NUMA awareness</strong>, em inglês <strong>N</strong>on-<strong>U</strong>niform <strong>M</strong>emory <strong>A</strong>ccess, nas quais o agendador considera a topologia de memória ao tomar decisões de agendamento, e <strong>cache-affinity scheduling</strong>, expressão em inglês para agendamento por afinidade de <code>cache</code>, que minimiza migrações desnecessárias de processos entre núcleos de processamento.</p></li>
</ol>
<div id="fig-smp1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-smp1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/arquitetura_smp.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-smp1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.12: A figura ilustra quatro processadores simétricos compartilhando memória principal através de um barramento comum, onde cada <code>CPU</code> mantém sua própria fila de processos locais e implementa time-sharing com quantum de <span class="math inline">\(100 ms\)</span>, paradigmas de multiprogramação e <em>time-sharing</em>. O <em>Global Load Balancer</em>, balanceador de carga global, coordena a migração de processos entre <code>CPU</code>s com cargas desbalanceadas, <code>CPU</code> <span class="math inline">\(0\)</span> com <span class="math inline">\(80\%\)</span> vs.&nbsp;<code>CPU</code> <span class="math inline">\(3\)</span> com <span class="math inline">\(20\%\)</span>, exemplificando o paradigma de multiprocessamento. A hierarquia de <code>cache</code>, <code>L1</code>/<code>L2</code> privados, <code>L3</code> compartilhado, e os mecanismos de sincronização representam os desafios fundamentais de coerência e coordenação que <strong>Sistemas Operacionais</strong> que implementem o <strong>SMP</strong> devem gerenciar para otimizar performance mantendo a coerência dos dados entre múltiplos processadores rodando múltiplos processos.
</figcaption>
</figure>
</div>
<section id="sistemas-influentes-na-era-dos-sistemas-híbridos" class="level5" data-number="2.1.5.2.1">
<h5 data-number="2.1.5.2.1" class="anchored" data-anchor-id="sistemas-influentes-na-era-dos-sistemas-híbridos"><span class="header-section-number">2.1.5.2.1</span> Sistemas Influentes Na Era dos Sistemas Híbridos</h5>
<p>Na era dos sistemas híbridos, destacamos cinco sistemas influentes que exemplificam a convergência dos paradigmas de multiprogramação, <em>time-sharing</em> e multiprocessamento:</p>
<ol type="1">
<li><strong>CP/M (Control Program for Microcomputers)</strong>: desenvolvido por <a href="https://pt.wikipedia.org/wiki/Gary_Kildall">Gary Kildall</a> na Digital Research em 1974, o <strong>CP/M</strong> foi um marco importante na evolução dos <strong>Sistemas Operacionais</strong> de microcomputadores. Este sistema estabeleceu convenções duradouras para a organização de arquivos e comandos que influenciariam profundamente o desenvolvimento posterior de sistemas como o <strong>MS-DOS</strong>. O <strong>CP/M</strong> introduziu o conceito da <strong>B</strong>asic <strong>I</strong>nput/<strong>O</strong>utput <strong>S</strong>ystem, <strong>BIOS</strong>, uma camada de abstração entre o hardware e o <strong>Sistema Operacional</strong> que permitiu maior portabilidade entre diferentes microcomputadores baseados nos processadores <strong>Intel 8080</strong> e <strong>Zilog Z80</strong>. A estrutura modular do <strong>CP/M</strong>, com <em><strong>C</strong>ommand <strong>C</strong>onsole <strong>P</strong>rocessor,</em> <strong>CCP</strong>, _<strong>B</strong>asic <strong>D</strong>isk <strong>O</strong>perating <strong>S</strong>ystem, <strong>BDOS</strong> e a <strong>BIOS</strong>, tornou-se um modelo arquitetônico para sistemas posteriores. Durante o final dos anos 1970 e início dos 1980, o <strong>CP/M</strong> dominou o mercado de microcomputadores comerciais, estabelecendo padrões para nomenclatura de drives (<code>A:</code>, <code>B:</code>, <code>C:</code>) e comandos básicos de sistema que persistem até hoje<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</li>
</ol>
<ol start="2" type="1">
<li><strong>MS-DOS (</strong>M<strong>icro</strong>S<strong>oft </strong>D<strong>isk </strong>O<strong>perating </strong>S<strong>ystem)</strong>: originado como uma adaptação do <strong>Q</strong>uick and <strong>D</strong>irty <strong>O</strong>perating <strong>S</strong>ystem, <a href="https://en.wikipedia.org/wiki/86-DOS"><strong>QDOS</strong></a>, desenvolvido por <a href="https://pt.wikipedia.org/wiki/Tim_Paterson">Tim Paterson</a> na Seattle Computer Products. O <strong>MS-DOS</strong> foi adquirido pela Microsoft em 1981 para atender à demanda da IBM por um <strong>Sistema Operacional</strong> necessário ao seu novo <strong>P</strong>ersonal <strong>C</strong>omputer, <strong>PC</strong>. O sistema mantinha compatibilidade conceitual com o <strong>CP/M</strong>, facilitando a migração de aplicações, mas foi otimizado para o processador Intel 8086/8088. Sua interface de linha de comando, embora aparentemente simples, oferecia recursos poderosos como redirecionamento de entrada/saída, processamento em lote por meio de arquivos <code>.BAT</code>, e suporte a dispositivos por meio de drivers carregáveis. O <strong>MS-DOS</strong> evoluiu significativamente ao longo de suas versões, introduzindo suporte a discos rígidos, neste caso na versão 2.0, estruturas de diretórios hierárquicas, e eventualmente suporte limitado à memória estendida. Sua natureza monotarefa e arquitetura de <span class="math inline">\(16 bits\)</span>, embora limitantes, proporcionaram estabilidade e previsibilidade que contribuíram para o estabelecimento do padrão <strong>IBM PC</strong> como plataforma dominante na computação pessoal por mais de uma década<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</li>
</ol>
<ol start="3" type="1">
<li><p><strong>Apple Macintosh OS (Classic Mac OS)</strong>: lançado em 1984, o <strong>Sistema Operacional</strong> do Macintosh representou uma revolução na interação humano-computador, popularizando conceitos que hoje consideramos fundamentais. Inspirado no trabalho pioneiro realizado nos Laboratórios Xerox Alto e Star, o <strong>Mac OS</strong> implementou de forma comercialmente viável a metáfora da área de trabalho. Nesta metáfora arquivos eram representados como documentos físicos e pastas como contêineres organizacionais. O sistema aproveitou as ideias dos Laboratórios da Xerox e introduziu o <em>m se</em> como dispositivo primário de navegação, implementou o conceito de <strong>WYSIWYG</strong>, abreviatura do <em>What You See Is What You Get</em>, na edição de documentos, e estabeleceu padrões de interface como menus suspensos, caixas de diálogo modais, e manipulação direta de objetos gráficos. Tecnicamente, o Mac OS original baseava-se em um núcleo de processamento cooperativo que, embora não oferecesse proteção robusta de memória ou multitarefa preemptiva, proporcionava uma experiência de usuário fluida e intuitiva. Sua arquitetura de recursos permitia a incorporação de elementos gráficos, sonoros e de interface diretamente nos arquivos executáveis, facilitando a localização e personalização de aplicações.</p></li>
<li><p><strong>Microsoft Windows</strong> - Iniciado em 1985 como um ambiente gráfico executado sobre o <strong>MS-DOS</strong>, o Windows passou por três fases distintas de desenvolvimento. As versões 1.0 a 3.11 funcionavam essencialmente como ambientes gráficos e não como <strong>Sistemas Operacionais</strong>, oferecendo uma interface visual para o <strong>MS-DOS</strong> subjacente, mas mantendo as limitações fundamentais de um sistema de <span class="math inline">\(16 bits\)</span>. Nesta fase, apenas o Windows 3.11 teve sucesso comercial muito devido ao sistema de configuração de redes locais que dispensava produtos de terceiros e ao lançamento do Corel Draw que trouxe a editoração gráfica para o desktop. O Windows 95 marcou um ponto de inflexão na evolução dos <strong>Sistemas Operacionais</strong>, introduzindo multitarefa preemptiva de <span class="math inline">\(32 bits\)</span>, um sistema de arquivos mais robusto, e uma interface redesenhada que incorporava elementos como a barra de tarefas e o menu Iniciar. Paralelamente, a linha <strong>Windows NT</strong>, iniciada em 1993 sob a liderança de <a href="https://en.wikipedia.org/wiki/Dave_Cutler">Dave Cutler</a>, representou uma abordagem completamente nova: um <strong>Sistema Operacional</strong> construído desde a concepção com arquitetura de <span class="math inline">\(32 bits\)</span>, <code>microkernel</code> híbrido, e recursos avançados de segurança baseados em <em><strong>A</strong>ccess <strong>C</strong>ontrol <strong>L</strong>ists</em>, <strong>ACL</strong>s, e domínios. O <strong>NT</strong> introduziu conceitos importados do padrão <strong>POSIX</strong>, como <code>threading</code> avançado, proteção de memória, e suporte nativo a redes, estabelecendo as bases arquitetônicas que persistem nas versões modernas do Windows. Desde o Windows XP, lançado em 2001, todas as versões do Windows são baseadas no <code>kernel</code> do <strong>Windows NT 4.0</strong>.</p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>A Relação entre o Windows NT, o POSIX e o UNIX</strong> O Windows <strong>NT</strong> representou uma adaptação sofisticada de princípios estabelecidos da ciência da computação que já estavam padronizados ou implementados em sistemas <strong>UNIX</strong>. O <strong>POSIX.1</strong> foi ratificado em 1988 precisamente quando <a href="https://en.wikipedia.org/wiki/Dave_Cutler">Dave Cutler</a> iniciou o desenvolvimento do <strong>NT</strong> na Microsoft, criando uma convergência histórica única. O <strong>POSIX.1b-1993</strong>, publicado poucos meses depois do lançamento do <strong>NT</strong> em julho de 1993, já havia padronizado extensões avançadas de tempo real incluindo escalonamento de prioridade, travamento de memória, objetos de memória compartilhada, filas de mensagens e temporizadores de alta resolução, capacidades que o subsistema <strong>POSIX</strong> mínimo do <strong>NT</strong> ignorou completamente.</p>
<p>Em 1993, os padrões <strong>POSIX</strong> definiam capacidades sofisticadas de multiprocessamento com escalonamento de prioridade de <span class="math inline">\(32\)</span> níveis, arquivos mapeados em memória, semáforos e sinais de tempo real. O Windows <strong>NT</strong> implementou apenas a revisão básica <strong>POSIX.1-1990</strong> para conformidade com contratos governamentais.</p>
<p>O uso de <code>threading</code> é particularmente revelador da influência do <strong>POSIX</strong>: enquanto o <strong>NT</strong> foi lançado com <code>threading</code> nativo em 1993, o <a href="https://en.wikipedia.org/wiki/Mach_(%60Kernel%60)">Mach</a> havia introduzido <code>threads</code> em sistemas semelhantes ao <strong>UNIX</strong> em 1985, oito anos antes. Os padrões de <code>threading</code> <strong>POSIX</strong> estavam em desenvolvimento durante a criação do <strong>NT</strong> e foram publicados como <strong>POSIX.1c</strong> em 1995. O <strong>POSIX.1b-1993</strong> especificou interfaces de travamento de memória, arquivos mapeados em memória, escalonamento preemptivo de prioridade fixa com mínimo de <span class="math inline">\(32\)</span> níveis de prioridade, semáforos nomeados e não-nomeados, filas de mensagens e temporizadores de precisão de nanossegundos, tudo antes do lançamento do <strong>NT</strong>.</p>
<p>A implementação <strong>POSIX</strong> do <strong>NT</strong> foi deliberadamente mínima, suportando apenas chamadas de sistema básicas sem utilitários de <code>shell</code>, interfaces de <code>threading</code> ou extensões de tempo real. O subsistema <strong>POSIX</strong> da Microsoft foi o resultado de uma caixa de seleção para conformidades de contratos, não um esforço sério de compatibilidade com o <strong>UNIX</strong>.</p>
<p>As inovações genuínas do <strong>NT</strong> foram em integração arquitetônica em vez de avanços fundamentais. O design de <code>microKernel</code> híbrido suportando múltiplas personalidades de <strong>Sistema Operacional</strong>, <strong>Win32</strong>, <strong>POSIX</strong>, <strong>OS/2</strong>, simultaneamente foi arquitetonicamente inovador. A implementação abrangente da camada de abstração de hardware, em inglês <strong>H</strong>ardware <strong>A</strong>bstraction <strong>L</strong>ayer, <strong>HAL</strong>, excedeu as abordagens de portabilidade contemporâneas. A arquitetura de segurança integrada com controle de acesso baseado em capacidades representou um avanço genuíno sobre o modelo mais simples baseado em usuário/grupo/outros do <strong>UNIX</strong>. Finalmente, o design unificado para multiprocessamento desde a primeira versão, constituiu uma vantagem arquitetônica e competitiva. Enquanto os sistemas <strong>UNIX</strong> estavam gradualmente adaptando suporte <strong>SMP</strong>, o agendador de tarefas centrado em <code>threads</code> do <strong>NT</strong> e a preempção integrada do <code>Kernel</code> representaram engenharia superior de conceitos estabelecidos ao invés de inovação. No entanto, o <strong>UNIX</strong> mantinha vantagens significativas: <strong>os sockets BSD tiveram uma década de refinamento até 1993, fornecendo interfaces de programação de rede maduras e comprovadas</strong>. Os sistemas <strong>UNIX</strong> ofereciam ambientes de desenvolvimento sofisticados, estabilidade comprovada por meio de implantação em produção e serviços de rede abrangentes como <strong>NFS</strong> e soluções integradas de computação distribuída.</p>
</div>
</div>
<ol start="5" type="1">
<li><strong>Linux</strong>: da sua concepção em 1991, por <a href="https://pt.wikipedia.org/wiki/Linus_Torvalds">Linus Torvalds</a> como um hobby pessoal para criar um sistema semelhante ao <a href="https://www.minix3.org/">MINIX</a> para computadores pessoais usando o Intel 386, o <strong>Linux</strong> evoluiu para se tornar um dos projetos de software livre mais bem-sucedidos da história. Sua arquitetura monolítica permite a incorporação dinâmica de funcionalidades por meio de módulos carregáveis dinamicamente, oferecendo flexibilidade sem comprometer performance. O desenvolvimento do <strong>Linux</strong> seguiu um modelo colaborativo distribuído sem precedentes, conhecido como <code>bazar</code> segundo <a href="https://pt.wikipedia.org/wiki/Eric_S._Raymond">Eric Raymond</a>. Nesse modelo milhares de desenvolvedores contribuem simultaneamente para diferentes aspectos do sistema. Tecnicamente, o <strong>Linux</strong> implementa recursos avançados como gerenciamento de memória virtual, multiprocessamento simétrico (<strong>SMP</strong>), agendamento de tarefas em tempo real, e suporte extensivo a sistemas de arquivos como (<a href="https://www.%60Kernel%60.org/doc/html/latest/admin-guide/ext4.html">ext4</a>, <a href="https://btrfs.readthedocs.io/en/latest/">Btrfs</a>, <a href="https://docs.freebsd.org/en/books/handbook/zfs/">ZFS</a>). Sua natureza de código aberto, e a <strong>Linguagem C</strong>, permitiram adaptações deste código para uma variedade extraordinária de plataformas, desde supercomputadores até dispositivos embarcados, smartphones, e sistemas de tempo real.</li>
</ol>
<p>A <a href="https://www.linuxfoundation.org/">Linux Foundation</a>, criada em 2000, garante sua sustentabilidade do projeto e mantém uma história de evolução contínua. O <strong>Linux</strong> não é apenas um <strong>Sistema Operacional</strong>; é uma plataforma que impulsiona a inovação em áreas dispares que vão desde supercomputadores até dispositivos móveis. Porém, do ponto de vista do desenvolvimento de <strong>Sistemas Operacionais</strong> dizemos que o Projeto <strong>Linux</strong> desenvolve o <code>Kernel</code>, núcleo. Neste caso, um <code>Kernel</code> de arquitetura monolítica e modular.</p>
<div id="fig-doadores" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-doadores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/linus-donors.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-doadores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.13: A figura mostra uma coleção curiosa dos maiores doadores da Fundação Linux. A figura foi tirada do site da <a href="https://www.linuxfoundation.org/">Linux Foundation</a> em junho de 2025 e destaca a Microsoft como um dos maiores doadores da fundação. A Microsoft, que já foi uma das maiores concorrentes do Linux, agora é um dos principais apoiadores do projeto. Esta mudança de postura da Microsoft em relação ao <strong>Linux</strong> reflete a evolução do ecossistema de software e a crescente importância do <strong>Linux</strong> em ambientes corporativos e de nuvem.
</figcaption>
</figure>
</div>
<p>A era do <strong>IBM PC</strong> provocou a simplificação dos recursos do <strong>Sistema Operacional</strong>, <code>CPU</code>, memória, <code>E/S</code>, em comparação com os <strong>Sistemas Operacionais</strong> de <code>mainframe</code>. Entretanto, esta simplificação durou pouco. O laço de realimentação positiva que existe entre software e hardware gradualmente reintroduziu a complexidade no sistema graças às novas aplicações cada dia mais sofisticadas e exigentes.</p>
</section>
</section>
</section>
</section>
<section id="fronteiras-modernas" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="fronteiras-modernas"><span class="header-section-number">2.2</span> Fronteiras Modernas</h2>
<p>As últimas décadas foram marcadas por níveis de exigência de funcionalidades e performance e pela criação de novos paradigmas computacionais. Esta evolução transform a forma como os seres humanos interagem com a tecnologia, graças à expansão das capacidades de processamento, armazenamento e comunicação de dados, assentando os alicerces para a revolução do uso da Inteligência Artificial. Desde os dispositivos móveis que se tornaram extensões de nossas vidas cotidianas, quase como órteses vitais, até as vastas infraestruturas de computação em nuvem, os complexos sistemas distribuídos que sustentam a economia digital global, e os supercomputadores científicos. Cada avanço tecnológico representa um novo horizonte de possibilidades e tem impacto profundo nas tecnologias que usamos para desenvolver os <strong>Sistemas Operacionais</strong>.</p>
<p>Tecnologias como <strong>computação móvel</strong>, <strong>sistemas distribuídos</strong>, <strong>computação em nuvem</strong> e, mais recentemente, <strong>computação quântica</strong> e <strong>Inteligência Artificial</strong> moldam os <strong>Sistemas Operacionais</strong> modernos. Ao mesmo tempo em que só podem existir e evoluir graças à existência destes mesmos <strong>Sistemas Operacionais</strong>. Se olharmos apenas para as inovações, relacionadas à convergência entre <strong>L</strong>arge <strong>L</strong>anguage <strong>M</strong>odel, <strong>LLMs</strong>, modelos de linguagem de grande escala, representante dos avanços em Inteligência Artificial e a computação quântica veremos que existe uma urgência econômica incentivando a criação de uma nova geração de <strong>Sistemas Operacionais</strong> capaz de atender o hardware de alto desempenho que suporta estas tecnologias.</p>
<p>Nesta seção, nossa jornada nos leva às fronteiras da ciência e da tecnologia. Começando pelo campo da tecnologia que será integrada a tudo que foi desenvolvido até o momento nas nossas vidas cotidianas. Os sistemas embarcados. Aperte o cinto e respire fundo.</p>
<section id="sistemas-operacionais-embarcados-e-iot-conectando-o-mundo-físico" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="sistemas-operacionais-embarcados-e-iot-conectando-o-mundo-físico"><span class="header-section-number">2.2.1</span> Sistemas Operacionais Embarcados e IoT: Conectando o Mundo Físico</h3>
<p>Graças a internet, a capacidade de integração de dispositivos eletrônicos e as novas tecnologias que desenvolvemos em cima delas, a humanidade criou um termo para englobar todos os dispositivos conectados e portadores de alguma inteligência computacional a <strong>I</strong>nternet <strong>o</strong>f <strong>T</strong>hings, <strong>IoT</strong>, internet das coisas em português. Com a convergência entre avanço deste conjunto de tecnologias, o baixo custo, e a proliferação de dispositivos conectados, os <strong>Sistemas Operacionais</strong> embarcados, <em>embedded</em> em inglês, tornaram-se os pilares da infraestrutura tecnológica em meados da segunda década do século XXI. Esses sistemas especiais são projetados para operar em hardware com recursos limitados em memória, capacidade de processamento, velocidade e integração com o mundo externo. Do ponto de vista da arquitetura de <strong>Sistemas Operacionais</strong>, isso representa um desafio fascinante: como aplicar os princípios de abstração de hardware, gerenciamento de recursos e concorrência em um ambiente tão restritivo?</p>
<p>Esta categoria de sistemas computacionais abrange desde os sistemas baseados em microcontroladores controlando uma rede de sensores usados, como os usados em marca-passos cardíacos, até sistemas completos em um único circuito integrado usados para controlar robôs, drones, automóveis e sistemas de controle industrial rodando <a href="https://en.wikipedia.org/wiki/SCADA">SCADA</a>. Estes últimos chamados de <code>SoC</code>, em inglês <strong>S</strong>ystem <strong>o</strong>n <strong>C</strong>hip, frequentemente, operando em tempo real. A ubiquidade dos <strong>Sistemas Operacionais</strong> embarcados é um testemunho do sucesso desta tecnologia e da sua importância na era moderna.</p>
<p>As limitações do hardware e do ambiente de uso de sistemas embarcados tensionaram o desenvolvimento de <strong>Sistemas Operacionais Embarcados</strong>. Ou, em outras palavras, diferentemente dos <strong>Sistemas Operacionais</strong> criados originalmente para <em>mainframes</em>, servidores e computadores pessoais, os <strong>Sistemas Operacionais Embarcados</strong> priorizam baixo consumo de energia, tamanho reduzido de código e resposta determinística a eventos externos.</p>
<section id="características-e-desafios-dos-sistemas-operacionais-embarcados" class="level4" data-number="2.2.1.1">
<h4 data-number="2.2.1.1" class="anchored" data-anchor-id="características-e-desafios-dos-sistemas-operacionais-embarcados"><span class="header-section-number">2.2.1.1</span> Características e Desafios dos <strong>Sistemas Operacionais Embarcados</strong></h4>
<p>Os <strong>Sistemas Operacionais Embarcados</strong> distinguem-se fundamentalmente de seus congêneres tradicionais por especificidades moldadas pelas limitações de recursos e pelos requisitos operacionais únicos de seus ambientes de implantação. <em>A eficiência energética constitui uma das preocupações primordiais nestes sistemas</em>. Trata-se de uma extensão crítica da função de gerenciamento de recursos, que em um <strong>Sistema Operacional</strong> tradicional foca no tempo de <code>CPU</code> e memória, mas aqui se inclui gerenciamento ativo de consumo de energia. Adicionando um porto extra à rota da performance.</p>
<p>O gerenciamento ativo de consumo de energia é, como não poderia deixar de ser, implementado em algoritmos sofisticados de controle do hardware. Estas técnicas permitem ao sistema, por exemplo, ajustar dinamicamente a tensão e frequência de operação da <code>CPU</code> com base na carga de trabalho atual. Desligando circuitos, reduzindo a temperatura do circuito integrado e otimizando o uso do hardware. Para dispositivos alimentados por bateria, como sensores <strong>IoT</strong> distribuídos em ambientes remotos, esta capacidade de otimização energética pode representar a diferença entre operação contínua por meses ou falha prematura em dias. Em dispositivos como drones, robôs autônomos, o uso de energia define a fronteira entre útil e de volta à prancheta. O consumo de energia é um requisito recente, limitante e novo de <strong>Sistemas Operacionais Embarcados</strong>. Mas não é a única preocupação.</p>
<p>A otimização de espaço constitui outro imperativo arquitetural. Enquanto um <strong>Sistema Operacional</strong> de propósito geral utiliza mecanismos como memória virtual e paginação para gerenciar <code>gigabytes</code> de <code>RAM</code>, um <strong>Sistema Operacional Embarcado</strong> deve operar sem esses luxos, exigindo que o código seja meticulosamente refinado para ocupar apenas alguns <code>kilobytes</code> de memória. Esta compactação é uma necessidade absoluta quando operando em microcontroladores com memória limitada, frequentemente restrita a apenas <span class="math inline">\(32 KB\)</span> de <code>RAM</code> comuns em dispositivos domésticos e industriais de monitoramento e acionamento. Neste ambiente, os desenvolvedores são forçados a dominar técnicas sofisticadas de otimização, incluindo compilação agressiva, eliminação de código não utilizado e implementação de algoritmos específicos para ambientes com recursos escassos que são diferentes para plataformas diferentes. <strong>Nesse campo de desenvolvimento, o diferencial competitivo está no conhecimento profundo de linguagens formais e técnicas de compilação e otimização de código</strong>. Muitas vezes somos obrigados a trocar espaço em memória por <code>throughput</code>. Principalmente em sistemas que devem reagir ao universo físico em tempo real.</p>
<p>Em sistemas de tempo real a natureza crítica das aplicações embarcadas eleva o determinismo temporal ao status de requisito fundamental. Isso impacta diretamente o núcleo do <strong>Sistema Operacional</strong>, especificamente seu algoritmo de agendamento de tarefas, <em>scheduler</em>. O resultado desta tensão é a classificação de numerosos sistemas embarcados como <strong>R</strong>eal-<strong>T</strong>ime <strong>O</strong>perating <strong>S</strong>ystems, <strong>RTOS</strong>. Quase um sonho inatingível: um sistema computacional, composto de hardware e software, que deve responder a eventos do mundo físico no mesmo tempo em que eles ocorrem, o tempo real.</p>
<p>O termo <strong>RTOS</strong> refere-se a sistemas operacionais projetados para garantir que tarefas vitais para seres humanos e máquinas sejam executadas dentro de prazos temporais rigorosos, com previsibilidade e confiabilidade. Esses sistemas são encontrados em aplicações onde atrasos podem resultar em falhas catastróficas, como em dispositivos médicos implantáveis, controladores automotivos de sistemas de frenagem, sistemas de controle de voo e robótica em geral. Os <strong>sistemas de tempo real devem garantir respostas dentro de prazos temporais estritos, previsíveis e muitas vezes, imutáveis</strong>.</p>
<p>O determinismo temporal transcende a simples velocidade de processamento, exigindo garantias matemáticas de que operações críticas serão completadas dentro de janelas temporais específicas, mesmo sob condições de carga máxima do sistema. A <a href="#fig-rtos1" class="quarto-xref">Figure&nbsp;<span>2.14</span></a> mostra o diagrama em blocos de um sistema <strong>RTOS</strong>.</p>
<div id="fig-rtos1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rtos1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<p><img src=".\images/embedded_os_architecture.webp" class="img-fluid figure-img"></p>
<p>Um exemplo prático introdutório, sem sistema operacional, mas muito interessante, pode ser visto no desenvolvimento de softwares para <a href="https://frankalcantara.com/linefollower/">seguidores de linha</a>. Um desenvolvimento inicial obrigatório para todos os interessados em sistemas de tempo real e robótica.</p>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rtos1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.14: Arquitetura em camadas de um <strong>Sistema Operacional</strong> de Tempo Real (RTOS) para dispositivos <strong>IoT</strong> embarcados. A estrutura apresenta quatro camadas principais: aplicação, com algoritmos <a href="https://arxiv.org/abs/2403.19076">TinyML</a> e processamento determinístico, <code>kernel</code> <strong>RTOS</strong>, incluindo agendador preemptivo, gerenciamento de memória estática, e gestão de energia, camada de abstração de hardware (HAL) e plataforma física. As restrições típicas incluem <span class="math inline">\(32KBytes\)</span> de <code>RAM</code>, processador de <span class="math inline">\(80MHz\)</span> e requisitos de tempo real com latência inferior a <strong>1ms</strong> para tarefas críticas. A base de hardware abrange microcontroladores ARM Cortex-M4, sensores MEMS, módulos de comunicação (WiFi, BLE, LoRaWAN) e sistemas de energia. Os protocolos de comunicação <strong>IoT</strong> (<a href="https://mqtt.org/">MQTT</a>, <a href="https://coap.space/">CoAP</a>, <a href="https://www.ti.com/lit/wp/swry013/swry013.pdf?ts=1730905735016">6LoWPAN</a>, <a href="https://openthread.io/guides/thread-primer?hl=pt-br">Thread</a>, <a href="https://en.wikipedia.org/wiki/Zigbee">Zigbee</a>, <a href="https://www.3gpp.org/news-events/3gpp-news/nb-iot-complete">NB-IoT</a>) facilitam a integração em redes distribuídas com diferentes requisitos de largura de banda e alcance.
</figcaption>
</figure>
</div>
<p>A <a href="#fig-rtos1" class="quarto-xref">Figure&nbsp;<span>2.14</span></a> tenta apresentar que a conectividade em sistemas embarcados manifesta-se por meio de suporte a protocolos de rede especificamente projetados para ambientes com limitações em recursos e em largura de banda. Protocolos como o <a href="https://mqtt.org/">MQTT</a>, de <strong>M</strong>essage <strong>Q</strong>ueuing <strong>T</strong>elemetry <strong>T</strong>ransport, e o <a href="https://coap.space/">CoAP</a>, de <strong>Co</strong>nstrained <strong>A</strong>pplication <strong>P</strong>rotocol, foram desenvolvidos para facilitar comunicação em redes <strong>IoT</strong>, operando eficazmente mesmo com largura de banda severamente limitada e conectividade intermitente. Estes protocolos implementam mecanismos de compressão de dados, estratégias de reconexão automática e algoritmos de <code>retry</code> que permitem operação confiável em ambientes de rede hostis típicos de dispositivos <strong>IoT</strong>. Com implicação direta na arquitetura dos <strong>Sistemas Operacionais Embarcados</strong>. Se temos dispositivos conectados em rede, temos problemas de segurança. Esta matriz de conexão cria superfícies de ataque expandidas.</p>
<p>As considerações de segurança, que já são um pilar no design de qualquer <strong>Sistema Operacional</strong>, adquirem novos níveis de complexidade com a proliferação de dispositivos conectados à internet. Por exemplo, a implementação de mecanismos como inicialização segura, em inglês <em>secure boot</em>, garante que apenas código autenticado e não adulterado seja executado durante o processo de inicialização, estabelecendo a cadeia de confiança desde o primeiro momento de operação. Complementarmente, a criptografia embarcada deve ser implementada considerando os recursos limitados, e requer algoritmos adaptados e específicos. Requerendo especializações extras em performance para os arquitetos destes algoritmos. Finalmente, dispositivos remotos requerem atualização remota. Esta necessidade de atualizações <strong>o</strong>ver-<strong>t</strong>he-<strong>a</strong>ir, <strong>OTA</strong>, representa tanto uma necessidade operacional quanto um desafio de segurança, permitindo manutenção remota de dispositivos implantados em localizações inacessíveis, mas introduzindo vetores de ataque que devem ser rigorosamente protegidos por meio de assinatura digital, criptografia de canal e verificação de integridade.</p>
<p>Não bastasse os problemas de segurança, performance e conectividade, os <strong>Sistemas Operacionais Embarcados</strong> enfrentam desafios relacionados à falta de padronização de hardware, enquanto que todo o mercado de servidores e computadores pessoais está limitado a uma dezena de plataformas diferentes criadas e mantidas por meia dúzia de empresas, o mercado de <strong>Sistemas Operacionais Embarcados</strong> é caracterizado por uma diversidade extraordinária de microcontroladores, sensores e módulos de comunicação</p>
</section>
<section id="sec-desafios-arquitetura-operacao" class="level4" data-number="2.2.1.2">
<h4 data-number="2.2.1.2" class="anchored" data-anchor-id="sec-desafios-arquitetura-operacao"><span class="header-section-number">2.2.1.2</span> Desafios de Arquitetura e Operação</h4>
<p>A ausência de padrões universais, mercadológicos, de hardware em dispositivos embarcados introduz um problema fundamental de fragmentação que permeia todos os aspectos do desenvolvimento de <strong>Sistemas Operacionais Embarcados</strong>. A diversidade de plataformas de hardware força os <strong>Sistemas Operacionais Embarcados</strong> a adotar arquiteturas definitivamente modulares impondo aos projetistas uma atenção especial à camada de abstração de hardware, em inglês <strong>H</strong>ardware <strong>A</strong>bstraction <strong>L</strong>ayer, um componente do <code>kernel</code> dos <strong>Sistemas Operacionais</strong> cuja função é isolar as aplicações das especificidades da plataforma física.</p>
<p>Esta fragmentação manifesta-se na diversidade extraordinária de microcontroladores, desde arquiteturas <a href="https://www.arm.com/products/silicon-ip-cpu/cortex-m/cortex-m4"><strong>ARM Cortex-M4</strong></a> de baixo consumo até processadores <a href="https://riscv.org/">RISC-V</a> emergentes, cada um com características específicas de memória, conjuntos de instruções e periféricos integrados. A variabilidade estende-se aos sensores incorporados, abrangendo desde simples sensores de temperatura analógicos até complexos sistemas <code>MEMS</code> multi-eixo, cada um exigindo drivers específicos e protocolos de comunicação distintos.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>*<strong>O Que São MEMS Multi-eixo?</strong></p>
<p>Sistemas Microeletromecânicos (<code>MEMS</code>) multi-eixo são sensores microscópicos, integrados em um chip de silício, que medem o movimento e a orientação de um objeto no espaço. A sua capacidade é definida pelo número de eixos ou <code>graus de liberdade</code>, em inglês <strong>D</strong>egree <strong>o</strong>f <strong>F</strong>reedom, que monitoram:</p>
<ul>
<li><strong>3-Eixos</strong>: utiliza um <strong>acelerômetro</strong> para medir a aceleração linear nos eixos <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> e <span class="math inline">\(Z\)</span>, detectando inclinação e deslocamento;</li>
<li><strong>6-Eixos (IMU)</strong>: uma unidade de medição inercial, em inglês <strong>I</strong>nertial <strong>M</strong>easurement <strong>U</strong>nit, adiciona um <strong>giroscópio</strong> de 3 eixos para medir a velocidade de rotação, permitindo um rastreamento completo de movimento;</li>
<li><strong>9-Eixos (IMU)</strong>: Integra um <strong>magnetômetro</strong> de 3 eixos que atua como uma bússola digital, fornecendo uma referência de direção absoluta e corrigindo desvios para uma orientação precisa.</li>
</ul>
<p>Esses dispositivos de baixo consumo de energia são a tecnologia por trás da rotação de tela em smartphones, da estabilização de imagem em câmeras de vídeo, dos sistemas de segurança em automóveis, airbags, controle de estabilidade, e da navegação de drones. Para ficar nos poucos casos que lembrei sem muito esforço.</p>
</div>
</div>
<p>A integração crescente de capacidades de Inteligência Artificial, particularmente por meio de modelos leves como <a href="https://pll.harvard.edu/course/fundamentals-tinyml">TinyML</a>, <strong>Tiny</strong> <strong>M</strong>achine <strong>L</strong>earning*, introduz um novo porto na jornada de complexidade dos <strong>Sistemas Operacionais Embarcados</strong>. Estes modelos de aprendizado de máquina, embora otimizados para operação em ambientes com recursos limitados, ainda impõem demandas computacionais significativas que devem ser cuidadosamente balanceadas contra as limitações de processamento e energia dos dispositivos hospedeiros. Novamente destacando a necessidade de uma camada extra de especialização à formação dos arquitetos e engenheiros de inteligência artificial e <strong>Sistemas Operacionais</strong>.</p>
<p>A complexidade e os desafios dos <strong>Sistemas Operacionais Embarcados</strong> é maior e mais relevante quando voltamos nossa análise para áreas de desenvolvimento que incluem aplicações médicas, militares, aeronáutica e financeiras. Nestes setores, a confiabilidade e a segurança são não apenas desejáveis, mas absolutamente essenciais. A certificação de conformidade com normas rigorosas, como as da <strong>FDA</strong> para dispositivos médicos ou as normas de segurança automotiva <strong>ISO 26262</strong>, exige que os <strong>Sistemas Operacionais Embarcados</strong> implementem práticas de desenvolvimento rigorosas, incluindo testes extensivos, validação formal e documentação meticulosa. A complexidade adicional introduzida por estas exigências normativas não apenas aumenta o custo e o tempo de desenvolvimento, mas também eleva o nível de especialização necessário para os engenheiros envolvidos. Isso sem falar, que estas áreas da economia tem impacto social e ético.</p>
<p>O design de sistemas embarcados para estas aplicações exige um equilíbrio delicado entre inovação tecnológica e responsabilidade social que transcende considerações puramente técnicas. <em>Esta responsabilidade manifesta-se na necessidade de transparência algorítmica, especialmente em sistemas que incorporam Inteligência Artificial, auditabilidade de decisões críticas, e capacidade de operação ética mesmo em situações não previstas durante o desenvolvimento</em>. Assim, o estudo dos <strong>Sistemas Operacionais Embarcados</strong> transcende a especialização técnica, representando a fronteira moderna da teoria de <strong>Sistemas Operacionais</strong>, onde os princípios clássicos de gerenciamento e abstração são testados contra os limites da física, da conectividade e da ética</p>
</section>
<section id="exemplos-de-sistemas-operacionais-embarcados" class="level4" data-number="2.2.1.3">
<h4 data-number="2.2.1.3" class="anchored" data-anchor-id="exemplos-de-sistemas-operacionais-embarcados"><span class="header-section-number">2.2.1.3</span> Exemplos de <strong>Sistemas Operacionais Embarcados</strong></h4>
<ol type="1">
<li><p><strong>FreeRTOS</strong>: criado por Richard Barry em 2003, adquirido pela Amazon em 2017, o <a href="https://www.freertos.org/">FreeRTOS</a> é um <strong>RTOS</strong> de código aberto amplamente utilizado em dispositivos embarcados sejam eles <strong>IoT</strong> ou não. Sua arquitetura modular suporta microcontroladores de baixa potência, como os da família <strong>ARM Cortex-M</strong>. O <strong>FreeRTOS</strong> oferece escalonamento preemptivo, comunicação inter-tarefa via filas e semáforos, e integração com o <a href="https://aws.amazon.com/pt/iot-core/">AWS IoT Core</a> para conectividade em nuvem. Em 2025, é comum encontrar sistemas <strong>FreeRTOS</strong> em dispositivos como termostatos inteligentes e sensores industriais.</p></li>
<li><p><strong>Zephyr</strong>: mantido pela <strong>Linux</strong> Foundation, o <a href="https://docs.zephyrproject.org/latest/index.html">Zephyr</a> um <strong>RTOS</strong> projetado para <strong>IoT</strong>, com suporte a uma ampla gama de arquiteturas, entre elas: <strong>ARM</strong>, <strong>RISC-V</strong> e <strong>x86</strong>. Ele se destaca por sua escalabilidade, permitindo uso em dispositivos com apenas <span class="math inline">\(8 KB\)</span> de <code>RAM</code>, e por sua pilha de rede completa, incluindo <a href="https://www.bluetooth.com/learn-about-bluetooth/tech-overview/"><strong>B</strong>luetooth <strong>L</strong>ow <strong>E</strong>nergy (<strong>BLE</strong>)</a> e <strong>Thread</strong>. O <strong>Zephyr</strong> é usado em dispositivos vestíveis, como smartwatches, e em redes de sensores para cidades inteligentes.</p></li>
<li><p><strong>QNX</strong>: o <a href="https://blackberry.qnx.com/en">QNX</a> é um <strong>RTOS</strong> comercial baseado em micro<code>Kernel</code>, amplamente adotado em sistemas críticos, como automóveis e dispositivos médicos. Sua arquitetura modular e certificações de segurança (ex.: ISO 26262 para sistemas automotivos) o tornam ideal para aplicações onde falhas não são toleráveis. Em 2025, o <strong>QNX</strong> é usado em sistemas de assistência ao motorista e em dispositivos <strong>IoT</strong> industriais.</p></li>
<li><p><strong>RIOT</strong>: o <a href="https://www-riot--os-org.translate.goog/?_x_tr_sl=en&amp;_x_tr_tl=pt&amp;_x_tr_hl=pt&amp;_x_tr_pto=tc">RIOT</a> é um <strong>Sistema Operacional</strong> de código aberto voltado para dispositivos <strong>IoT</strong> de baixa potência. Ele suporta múltiplos protocolos de rede, como os citados acima, e é compatível com microcontroladores de <span class="math inline">\(8\)</span> e <span class="math inline">\(32 bits\)</span>. Sua comunidade ativa e foco em interoperabilidade o tornam popular em projetos de pesquisa e protótipos de <strong>IoT</strong>, como redes de sensores ambientais.</p></li>
</ol>
</section>
</section>
<section id="sistemas-operacionais-móveis" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="sistemas-operacionais-móveis"><span class="header-section-number">2.2.2</span> Sistemas Operacionais Móveis</h3>
<p>Anteriormente, eu falei que os dispositivos eletrônicos estão se tornando órteses para o homem moderno. A culpa disso recai na ascensão dos dispositivos móveis, como <em>smartphones</em> e <em>tablets</em>. Esses dispositivos redefiniram a computação pessoal e impulsionaram a criação de <strong>Sistemas Operacionais</strong> especializados. Diferentemente dos <strong>Sistemas Operacionais</strong> desenvolvidos para servidores e computadores pessoais, os <strong>Sistemas Operacionais Móveis</strong> são projetados para operar sobre uma camada de hardware com recursos inerentemente limitados em termos de capacidade de processamento, memória e autonomia de bateria. Por outro lado, são dispositivos que dependem inerentemente de conexões à redes. Olhando <span class="math inline">\(10\)</span> anos para trás, uma comparação com os dispositivos que temos hoje parece indicar que, versão à versão, as limitações estão diminuindo ou mudando de perfil. Esta evolução tensiona o desenvolvimento de <strong>Sistemas Operacionais Móveis</strong> forçando adaptações contínuas.</p>
<p>Desde o lançamento do Apple iPhone (2007), o foco no design dos <strong>Sistemas Operacionais Móveis</strong> centrou-se em interfaces de toque, com a introdução de comandos baseados em gestos multitoque como _swiping e <em>pinch-to-zoom</em>, transformando a experiência do usuário em um diferencial comercial definitivo. Os sistemas que não são amigáveis não atingem o ponto de equilíbrio nas vendas e são retirados do mercado, como o <a href="https://mobiforge.com/timeline/windows-phone-history">Windows Phone</a>. Estes dispositivos, e sua interface moderna têm impacto direto na criação de novos conceitos para o desenvolvimento de <strong>Sistemas Operacionais</strong>, como a introdução de <em>widgets</em> e notificações interativas, que permitem uma interação dinâmica e personalizada com cada um dos usuários. Neste mercado, a integração de sensores como acelerômetros, giroscópios e <code>GPS</code> ampliou as possibilidades de interação e personalização, permitindo que os dispositivos móveis se transformassem de ferramentas de comunicação e consulta em plataformas multifuncionais para aplicações especializadas substituindo tarefas como navegação no mundo real, monitoramento de saúde, agendamento de compromissos e sistemas de entretenimento.</p>
<p>As duas plataformas predominantes no mercado de <strong>Sistemas Operacionais Móveis</strong> são o <a href="https://www.android.com/intl/pt_br/what-is-android/">Android</a>, desenvolvido pelo Google, e o <a href="https://www.apple.com/ios/ios-18/">IoS</a>, da Apple.</p>
<p>O <strong>Android</strong> é baseado no <code>Kernel</code> <strong>Linux</strong> e ainda adota um modelo de código aberto, que permite personalizem seus dispositivos, embora essa flexibilidade também contribua para a fragmentação do ecossistema. Para a criação do <strong>Android</strong> o Google combina <code>kernels</code> <strong>Linux</strong> de suporte de longo prazo com atualizações e correções específicas para o Android, criando o que eles chamam de <strong>A</strong>ndroid <strong>C</strong>ommon <strong>K</strong>ernels, <strong>ACK</strong>s, em português <code>kernels</code> comuns do Android. Para complementar o <strong>Android</strong> utiliza o <a href="https://www.sqlite.org/">SQLite</a> para armazenamento de dados estruturados e, historicamente, a <a href="https://source.android.com/docs/core/runtime?hl=pt-br">máquina virtual Dalvik</a>, posteriormente substituída pela <a href="https://source.android.com/docs/core/ota/modular-system/art?hl=pt-br">Android Runtime - ART</a>, para a execução de aplicativos desenvolvidos primariamente em <strong>Java</strong> ou <strong>Kotlin</strong>. A diferença nas estruturas do Dalvik e o ART pode ser vista na <a href="#fig-dalvik1" class="quarto-xref">Figure&nbsp;<span>2.15</span></a>. Como a conectividade é indispensável em dispositivos móveis, o <strong>Android</strong> oferece suporte extensivo a tecnologias de conectividade, incluindo <a href="https://www.3gpp.org/">GSM/EDGE</a>, <a href="https://www.3gpp.org/">CDMA</a>, <a href="https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/ev-do-rev-a-and-b-wireless-broadband-for-the-masses-whitepaper.pdf">EV-DO</a>, <a href="https://www.3gpp.org/">UMTS</a>, LTE, <a href="https://www.3gpp.org/">5G</a>, <a href="https://www.bluetooth.com/">Bluetooth</a>, <a href="https://www.wi-fi.org/">Wi-Fi</a> e <a href="https://wimaxforum.org/">WiMAX</a>.</p>
<div id="fig-dalvik1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dalvik1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/dalvik_vs_art_comparison.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dalvik1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.15: Comparação das arquiteturas de runtime do Android: <em>Dalvik Virtual Machine</em> vs <em>Android Runtime</em>. O diagrama ilustra a evolução dos mecanismos de compilação e execução, destacando a transição da interpretação <em>Just In Time</em> do Dalvik para a estratégia híbrida <em>Ahead of Time / Just In Time</em> do <em>Android RunTime</em>, com melhorias significativas em <em>garbage collection</em> e gerenciamento de memória. Nós vamos voltar a isso tudo, com calma, no capítulo certo.
</figcaption>
</figure>
</div>
<p>O <strong>i</strong>Phone <strong>O</strong>perating <strong>S</strong>ystem, <strong>iOS</strong>, da Apple, é derivado do <a href="https://www.apple.com/br/macos/macos-sequoia/">macOS</a> e opera em um modelo de plataforma fechada, com uma integração vertical forte entre hardware e software, o que frequentemente resulta em alto desempenho e otimização de recursos. Sua arquitetura é organizada em camadas distintas: o <em>Core OS</em>, que inclui o <code>Kernel</code> do <strong>Sistema Operacional</strong>, gerenciamento de energia e segurança, o <em>Core Services</em>, responsável por serviços como acesso a arquivos, rede e banco de dados SQLite, <em>Media</em>, para áudio, vídeo e gráficos, e o <em>Cocoa Touch</em>, que gerencia as interações do usuário, incluindo gestos multitoque e acesso a sensores. A <a href="#fig-AndroidIos" class="quarto-xref">Figure&nbsp;<span>2.16</span></a>, apresenta a arquitetura do <strong>iOS</strong> e do Android.</p>
<div id="fig-AndroidIos" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-AndroidIos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/android_vs_ios_os_comparison.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-AndroidIos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.16: Comparação das arquiteturas dos <strong>Sistemas Operacionais</strong> <strong>Android</strong> e <strong>iOS</strong>. O diagrama apresenta a estrutura em camadas de cada sistema, destacando as diferenças fundamentais entre a arquitetura baseada em <strong>Linux</strong> do <strong>Android</strong> e o <code>kernel</code> Darwin (XNU) do <strong>iOS</strong>.
</figcaption>
</figure>
</div>
<p>A atenta leitora deve ter notado, observando a <a href="#fig-AndroidIos" class="quarto-xref">Figure&nbsp;<span>2.16</span></a> que estes <strong>Sistemas Operacionais</strong> não são tão diferentes como olhos puros e inocentes podem supor. Com toda certeza veremos que as diferenças são mais profundas, mas infelizmente não são perceptíveis em um diagrama de blocos tão simples. Ambos os <strong>Sistemas Operacionais Móveis</strong> compartilham princípios fundamentais de design, como a camada abstração de hardware, gerenciamento de recursos e segurança, mas implementam esses conceitos de maneiras que refletem suas filosofias e objetivos distintos. Quando olhamos o diagrama em blocos da <a href="#fig-AndroidIos" class="quarto-xref">Figure&nbsp;<span>2.16</span></a>, os sistemas parecem versões da mesma ideia. A curiosa leitora pode aproveitar a oportunidade e comparar estes dois <strong>Sistemas Operacionais</strong> com o <strong>RTOS</strong> da <a href="#fig-rtos1" class="quarto-xref">Figure&nbsp;<span>2.14</span></a>.</p>
<section id="sistemas-operacionais-móveis-desafios" class="level4" data-number="2.2.2.1">
<h4 data-number="2.2.2.1" class="anchored" data-anchor-id="sistemas-operacionais-móveis-desafios"><span class="header-section-number">2.2.2.1</span> Sistemas Operacionais Móveis: Desafios</h4>
<p>Não são poucos desafios enfrentados pelos <strong>Sistemas Operacionais Móveis</strong>. A limitação de recursos é uma preocupação constante, exigindo que os desenvolvedores criem soluções eficientes em uso de memória, processamento, conectividade, segurança e gestão de energia em ambientes muito diferentes dos que encontramos em servidores e computadores pessoais.</p>
<p>A conectividade é uma das pedras angulares dos <strong>Sistemas Operacionais Móveis</strong>. Para que um dispositivo móvel tenha sucesso no mercado ele precisa de um amplo espectro de tecnologias de rede e protocolos de comunicação, incluindo Wi-Fi, redes celulares (3G, 4G e, cada vez mais, 5G), <a href="https://www.bluetooth.com/">Bluetooth</a> e <a href="https://nfc-forum.org/">NFC</a>, garantindo comunicação constante e acesso a serviços online. A chegada do <a href="https://www.qualcomm.com/5g/what-is-5g">5G</a>, com suas promessas de velocidades significativamente mais altas e latência ultrabaixa, impõe novas demandas aos <strong>Sistemas Operacionais Móveis</strong> para gerenciar e habilitar o uso de novas classes de aplicativos, como os aplicativos de realidade aumentada e interações em tempo real mais ricas. No entanto, se removermos a diversidade de protocolos, a gestão de módulos de rede e conexão não é muito diferente em sistemas embarcados, móveis ou tradicionais. Em todos eles a solução mais adequada foi a criação de um sistema de carregamento de módulos. Assim, o <strong>Sistema Operacional</strong> pode carregar e rodar apenas os módulos necessários otimizando o consumo de energia e as camadas de segurança necessárias.</p>
<p>Segurança e privacidade também são preocupações importantes no design de <strong>Sistemas Operacionais Móveis</strong>. Estes sistemas implementam modelos de permissão granulares, exigindo consentimento explícito do usuário para que aplicativos acessem recursos sensíveis como câmera, microfone, dados de localização e contatos. O <em>sandboxing</em> de aplicativos é uma técnica comum, isolando os processos e dados de cada aplicativo para prevenir interferências maliciosas e limitar o impacto de possíveis vulnerabilidades. O <em>sandboxing</em> é implementado via restrições do <code>Kernel</code>, garantindo privacidade e estabilidade. Talvez este termo tenha sido escolhido porque nos EUA crianças pequenas brincam em caixas de areia, e não podem sair delas, tornando estas caixas um lugar seguro.</p>
<p>Para completar as funcionalidades de segurança, precisamos evidenciar a criptografia de dados, tanto para dados em repouso no dispositivo quanto em trânsito pela rede. Algoritmos de criptografia são amplamente utilizadas para proteger informações sensíveis. Apesar desses algoritmos e mecanismos, os <strong>Sistemas Operacionais Móveis</strong> enfrentam desafios contínuos devido à evolução constante de ameaças cibernéticas sofisticadas e à complexidade do ecossistema de aplicativos. A amável leitora deve ter usado um destes <strong>Sistemas Operacionais Móveis</strong> e percebido a ênfase significativa em segurança e privacidade, que estes sistemas aplicam. Novamente, o ambiente restrito e a necessidade de proteger dados sensíveis, como informações pessoais e financeiras, exigem uma abordagem rigorosa e adaptativa que não são muito diferentes das abordagens adotadas em <strong>Sistemas Operacionais Embarcados</strong>. A diferença é que, em um <strong>Sistema Operacional Móvel</strong>, o usuário é o responsável por autorizar o acesso a recursos sensíveis, enquanto que em um <strong>Sistema Operacional Embarcado</strong> o usuário não tem controle sobre o acesso a estes recursos. Nos dois casos, todos os processos, algoritmos e métodos de segurança estão limitados pelas restrições do consumo de energia o que não acontece com <strong>Sistemas Operacionais</strong> de servidores, <em>mainframes</em> e computadores pessoais.</p>
<p>Eu enfatizei as restrições de consumo de energia em dois temas consecutivos para que a atenta leitora perceba que o consumo de energia é um dos principais desafios enfrentados pelos <strong>Sistemas Operacionais Móveis</strong>. A natureza portátil desses dispositivos exige que os <strong>Sistemas Operacionais Móveis</strong> implementem técnicas avançadas de gerenciamento de energia para maximizar a vida útil da bateria. Para enfrentar essa questão, os <strong>Sistemas Operacionais Móveis</strong> empregam estratégias sofisticadas de controle e monitoramento. Estas estratégias incluem o gerenciamento dinâmico de estados de energia dos componentes de hardware, como a <code>CPU</code>, que pode operar em modos de baixo consumo ou ser colocada em estados de suspensão, <em>sleep</em>, durante períodos de inatividade.</p>
<p>As estratégias de gerenciamento de energia só são possíveis graças a relação simbiótica entre o <strong>Sistema Operacional</strong> e o hardware. Nesta relação, o <strong>Sistema Operacional</strong> é responsável por monitorar a atividade do usuário e ajustar dinamicamente o desempenho da <code>CPU</code> e outros componentes para otimizar o consumo de energia. Enquanto o hardware deve informar dados de consumo, frequência, atividade e operação ao <strong>Sistema Operacional</strong>. Novamente em um laço de realimentação positiva: há uma necessidade, cria-se um hardware que atenda a esta necessidade e o <strong>Sistema Operacional</strong> é adaptado para tirar proveito deste hardware, e voltamos ao início. Esta relação simbiótica força os arquitetos de <strong>Sistema Operacionais Móveis</strong> a criarem soluções novas e específicas.</p>
<p>O Android, por exemplo, implementa seu próprio sistema de gerenciamento de energia sobre o <a href="https://docs.%60Kernel%60.org/power/index.html">Linux Power Management</a>, utilizando <em>wake locks</em> para permitir que aplicações requisitem recursos da <code>CPU</code> apenas quando necessário, garantindo que a <code>CPU</code> não consuma energia desnecessariamente se não houver aplicações ou serviços ativos demandando processamento. Um sistema de gestão de energia de servidores e computadores pessoais modificado e otimizado para uso em dispositivos móveis.</p>
<p>É possível que a perceptiva leitora tenha notado, nos últimos anos, a evolução das técnicas de gerenciamento de energia, transcendendo os modos manuais de economia para sistemas adaptativos e preditivos baseados em Inteligência Artificial. O <strong>Android</strong> introduziu recursos como <strong>Adaptive Battery</strong>, que aprende os padrões de uso do usuário para otimizar o consumo de energia, gerenciando o desempenho e a eficiência em segundo plano. Similarmente, o mercado especula que o <strong>iOS</strong>, a partir da versão <span class="math inline">\(19\)</span>, deve introduzir otimizações de bateria baseadas em Inteligência Artificial, que aprendem os hábitos de uso de aplicativos, limitam atividades em segundo plano de forma inteligente e preveem necessidades de recarga, com todo o processamento dos algoritmos de aprendizagem de máquina ocorrendo no próprio dispositivo móvel para preservar a privacidade do usuário. Esta é uma transição importante no paradigma de gerenciamento de energia.</p>
<p>A atenta leitora deve ter em mente que esta transição para uma gestão energética proativa, na qual o <strong>Sistema Operacional</strong> antecipa e se adapta às necessidades do usuário de forma quase invisível, usando Inteligência Artificial, tenta aliviar o usuário da carga cognitiva de gerenciar manualmente essas configurações. Tirando a relação entre hardware e software do mundo determinístico da computação imperativa para o mundo probabilístico, mais fluido e adaptativo da Inteligência Artificial. Neste admirável mundo novo o sistema aprenderá e se ajustará continuamente às suas necessidades e não as necessidades de um usuário médio hipotético. Regozijai-vos! Estamos quase lá. Mas existem desafios éticos e de privacidade que devem ser considerados.</p>
<p>A crescente sofisticação dos sistemas de Inteligência Artificial no gerenciamento de energia e na personalização da experiência do usuário, embora traga benefícios evidentes em termos de usabilidade e eficiência, também levanta questões importantes sobre a privacidade dos dados de uso do dispositivo. Mesmo com o processamento ocorrendo localmente no dispositivo, como destacado para o <strong>iOS</strong>, a coleta e análise detalhada de hábitos de uso, quais aplicativos são usados, em que horários, possivelmente inferindo locais e rotinas, são inerentemente sensíveis.</p>
<p>Neste cenário, surge um dilema entre a conveniência da automação inteligente, que torna o gerenciamento de recursos invisível e contínuo, e a manutenção da transparência e do controle por parte do usuário sobre as operações do seu dispositivo. Este equilíbrio delicado entre personalização avançada, privacidade e controle do usuário continuará a ser um campo de debate e desenvolvimento para os futuros <strong>Sistemas Operacionais Móveis</strong>, podendo influenciar as preferências dos consumidores e até mesmo levar a novas regulamentações sobre os dados utilizados por sistemas de Inteligência Artificial embarcados.</p>
<p>A <a href="#tbl-androidios1" class="quarto-xref">Table&nbsp;<span>2.4</span></a> apresenta um comparativo entre as duas principais plataformas de <strong>Sistemas Operacionais Móveis</strong>, <strong>Android</strong> e <strong>iOS</strong>, destacando suas características fundamentais e abordagens recentes, especialmente no que tange ao gerenciamento de energia.</p>
<div id="tbl-androidios1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-androidios1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2.4: Comparativo entre <strong>Android</strong> e <strong>iOS</strong>, destacando suas características fundamentais e abordagens recentes, especialmente no que tange ao gerenciamento de energia.
</figcaption>
<div aria-describedby="tbl-androidios1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Característica</th>
<th style="text-align: left;"><strong>Android</strong></th>
<th style="text-align: left;"><strong>iOS</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Arquitetura Base</strong></td>
<td style="text-align: left;"><code>Kernel</code> <strong>Linux</strong></td>
<td style="text-align: left;">Derivado do macOS, arquitetura em camadas (Core OS, Core Services, Media, Cocoa Touch)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Modelo de Distribuição</strong></td>
<td style="text-align: left;">Código aberto, personalizável por fabricantes</td>
<td style="text-align: left;">Plataforma fechada, proprietária da Apple</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Interface Predominante</strong></td>
<td style="text-align: left;">Interfaces de toque, alta personalização da UI pelos fabricantes</td>
<td style="text-align: left;">Interfaces de toque (multitoque, gestos), design de UI consistente e controlado pela Apple</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Gerenciamento de Energia</strong></td>
<td style="text-align: left;"><strong>Android</strong> Power Management, wake locks, Adaptive Battery, controles granulares (One UI)</td>
<td style="text-align: left;">Gerenciamento de energia integrado, otimização de bateria baseada em Inteligência Artifical (a partir do <strong>Sistemas Operacionais Móveis</strong> 19)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Conectividade</strong></td>
<td style="text-align: left;">Amplo suporte: GSM/EDGE, CDMA, EV-DO, UMTS, LTE, 5G, Bluetooth, Wi-Fi, WiMAX</td>
<td style="text-align: left;">Amplo suporte: GSM/EDGE, CDMA, EV-DO, UMTS, LTE, 5G, Bluetooth, Wi-Fi</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Segurança</strong></td>
<td style="text-align: left;">Sandboxing de apps, modelo de permissões, criptografia, Google Play Protect</td>
<td style="text-align: left;">Sandboxing de apps, modelo de permissões, criptografia forte, Face ID/Touch ID, Secure Enclave</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ecossistema de Aplicativos</strong></td>
<td style="text-align: left;">Google Play Store, permite sideloading (instalação de apps de fora da loja oficial)</td>
<td style="text-align: left;">Apple App Store, política restrita de distribuição de apps</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>A atenta leitora deve observar que esta comparação evidencia as filosofias distintas de design e as abordagens para desafios comuns. Parecendo indicar que as duas plataformas estão convergindo para soluções mais inteligentes e adaptativas.</p>
</section>
</section>
<section id="sistemas-distribuídos" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="sistemas-distribuídos"><span class="header-section-number">2.2.3</span> Sistemas Distribuídos</h3>
<p><em>Um sistema distribuído é conceitualmente definido como uma coleção de computadores autônomos que se comunicam e cooperam por meio de uma rede, mas que se apresentam aos seus usuários como um único sistema coerente e unificado</em>. Em sistemas distribuídos a leitora usará um número indefinido de máquinas mas todas serão vistas como uma só. Os principais objetivos para a construção de sistemas distribuídos são: o compartilhamento eficiente de recursos, hardware, software ou dados; o aumento de desempenho por meio do processamento paralelo; e a obtenção de maior confiabilidade e disponibilidade.</p>
<p>Para que um sistema distribuído funcione efetivamente e seja percebido como uma entidade única, ele deve exibir algumas características. Entre elas, a observadora leitora deve considerar a <strong>transparência</strong> como uma das mais importantes. Neste caso, <em>usamos a palavra transparência para fazer referência à capacidade do sistema de ocultar a separação e a distribuição de seus componentes dos usuários e dos programadores de aplicação</em>. Existem diversas formas de transparência, sendo a <strong>transparência de localização</strong> e a <strong>transparência de acesso</strong> particularmente comuns e dignas de nota: a <strong>transparência de localização</strong> garante que usuários e aplicações não precisem conhecer a localização física dos recursos, enquanto a <strong>transparência de acesso</strong> assegura que recursos locais e remotos sejam acessados utilizando operações idênticas, abstraindo os detalhes de como o acesso é realizado. Outras formas de transparência incluem as transparências de replicação, correção de falhas, concorrência e migração, todas contribuindo para a ilusão de um sistema único.</p>
<p>A <strong>escalabilidade</strong> é outra característica importante. Neste caso, <em>a escalabilidade denota a capacidade do sistema operar de forma eficaz e eficiente em diferentes escalas, ou seja, de se adaptar ao aumento da demanda por recursos sem que haja uma degradação significativa no desempenho ou a necessidade de alterar fundamentalmente o software ou as aplicações existentes</em>. Em um mundo ideal, o céu será sempre azul, os ventos sempre justos, e o processamento será independente do tamanho da rede. No entanto, chove e a escalabilidade pode ser limitada por gargalos como algoritmos centralizados, dados centralizados ou serviços centralizados que atendem a todos os usuários e que não possam ser distribuídos por limitações técnicas, econômicas ou de segurança. O mundo ideal só existe nos nossos sonhos, planos e desejos.</p>
<p>Sistemas, independentemente do seu tamanho e função, falham. <em>A <strong>tolerância a falhas</strong> é a propriedade que permite a um sistema distribuído continuar operando corretamente, possivelmente com desempenho degradado, mesmo quando alguns de seus componentes falham</em>. Isso é geralmente alcançado por meio da redundância de hardware, software e dados, combinada com um design de software que permite a recuperação do último estado consistente após a detecção de uma falha. As falhas podem ser classificadas como transientes, ocorrem uma vez e desaparecem; intermitentes, ocorrem esporadicamente; ou permanentes, persistem até serem reparadas. Intimamente relacionada à tolerância a falhas está a <strong>disponibilidade</strong>, que em <strong>sistemas distribuídos implica que a falha de um componente deve afetar apenas a parte do sistema que utiliza diretamente aquele componente, permitindo que o restante continue funcional</strong>.</p>
<p>Atualmente, uma das tendências mais significativas no desenvolvimento de sistemas distribuídos, com impacto direto na criação de <strong>Sistemas Operacionais</strong>, é a adoção da <strong>arquitetura de microsserviços</strong>, que propõe <em>a decomposição de aplicações monolíticas complexas em um conjunto de serviços menores, independentes e fracamente acoplados</em>. Cada microsserviço executa seu próprio processo e se comunica com outros serviços por meio de <code>APIs</code> leves, frequentemente baseadas nos protocolos HTTP/REST. Esta abordagem oferece benefícios como implantação independente de cada serviço, escalabilidade granular, permitindo que apenas os serviços mais demandados sejam escalados, e a possibilidade de usar diferentes tecnologias para diferentes serviços. A integração de microsserviços com <strong>tecnologias de conteinerização</strong>, como <a href="https://www.docker.com/">Docker</a>, e orquestradores, como <a href="https://kubernetes.io/">Kubernetes</a>, tem se mostrado particularmente eficaz para aumentar a tolerância a falhas e a resiliência, pois falhas em um microsserviço podem ser isoladas sem derrubar toda a aplicação. A <a href="#fig-docker1" class="quarto-xref">Figure&nbsp;<span>2.17</span></a> mostra uma arquitetura de microsserviços utilizando containers Docker, onde cada serviço é isolado em seu próprio container, permitindo uma gestão eficiente e escalável.</p>
<div id="fig-docker1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-docker1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/docker_container_diagram.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-docker1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.17: Esta figura ilustra a estrutura hierárquica da virtualização em nível de <strong>Sistema Operacional</strong> utilizando tecnologia Docker. A arquitetura apresenta cinco camadas principais: (1) Camada de Hardware, contendo os recursos físicos fundamentais (CPU multi-core, memória RAM, armazenamento SSD/HDD, interfaces de rede e dispositivos de E/S); (2) <code>kernel</code> <strong>Linux</strong>, destacado como componente central que implementa as tecnologias essenciais para o uso de containers, Namespaces para isolamento de processos, <strong>Cgroups</strong> para limitação de recursos, SELinux para segurança, UnionFS para sistema de arquivos em camadas e Netfilter para gerenciamento de rede; (3) <strong>Sistema Operacional</strong> Ubuntu, fornecendo bibliotecas do sistema, shell, utilitários e serviços; (4) Docker Engine, implementando o daemon Docker, runtime de containers (containerd/runc), CLI e gerenciamento de rede; e (5) Containers Docker, demonstrados através de três instâncias isoladas executando aplicação web (Node.js), banco de dados (PostgreSQL) e cache em memória (Redis). As setas verticais indicam a dependência hierárquica entre camadas, enquanto a legenda lateral destaca as características fundamentais dos containers: isolamento via Namespaces, limitação de recursos via Cgroups e compartilhamento eficiente do mesmo <code>kernel</code> <strong>Linux</strong> entre todos os containers, demonstrando como esta arquitetura oferece virtualização leve com overhead computacional mínimo comparado às máquinas virtuais tradicionais.
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Containers: Virtualização no Nível do Sistema Operacional</strong></p>
<p>Os <strong>containers</strong> representam uma forma leve e eficiente de virtualização que opera no nível do <strong>Sistema Operacional</strong>, permitindo que múltiplas aplicações isoladas compartilhem o mesmo <code>Kernel</code> do sistema hospedeiro. <em>Diferentemente das máquinas virtuais tradicionais, que virtualizam hardware completo, os containers virtualizam apenas o espaço do usuário, criando ambientes isolados que compartilham recursos do <strong>Sistema Operacional</strong> subjacente</em>.</p>
<p>Graças a sua arquitetura, os containers consomem significativamente menos recursos que máquinas virtuais, com custo computacional extra típico inferior a <span class="math inline">\(2\%\)</span> permitindo:</p>
<ul>
<li><p><strong>Isolamento de Processos</strong>: cada container executa em seu próprio espaço de usuário isolado, com processos, sistema de arquivos e interfaces de rede separados;</p></li>
<li><p><strong>Compartilhamento de <code>Kernel</code></strong>: todos os containers em um sistemas hospedeiro compartilham o mesmo <code>Kernel</code> do <strong>Sistema Operacional</strong>, eliminando a sobrecarga de múltiplos sistemas operacionais;</p></li>
<li><p><strong>Portabilidade</strong>: containers encapsulam aplicações e suas dependências, garantindo execução consistente em diferentes ambientes;</p></li>
</ul>
<p>Os containers <strong>Linux</strong> baseiam-se em duas tecnologias principais do <code>Kernel</code>. os containers de <strong>Namespaces</strong>: criam isolamento de recursos como processos, rede e sistema de arquivos enquanto os de <strong>Cgroups</strong>, em inglês <strong>C</strong>ontrol <strong>groups</strong>: limitam e monitoram o uso de recursos como <code>CPU</code>, memória e <code>E/S</code>.</p>
<p>Esta combinação permite que o <strong>Sistema Operacional</strong> mantenha múltiplos ambientes isolados sem a complexidade de virtualização completa de hardware. Os containers tem aplicação direta na facilitação da implantação de aplicações, na criação e gestão de microsserviços, permitindo que cada serviço seja implantado independentemente e, como não poderia deixar de ser, na computação em nuvem: oferecendo densidade superior de aplicações por servidor físico. Plataformas como <a href="https://www.docker.com/"><strong>Docker</strong></a> popularizaram esta tecnologia, enquanto orquestradores como <a href="https://kubernetes.io/"><strong>Kubernetes</strong></a> gerenciam containers em escala empresarial.</p>
</div>
</div>
<p>Outra tendência proeminente é a arquitetura orientada a eventos, em inglês <strong>E</strong>vent-<strong>D</strong>riven <strong>A</strong>rchitecture - <strong>EDA</strong>. Em sistemas <strong>EDA</strong>, os componentes reagem a eventos. Estes eventos são caracterizados por notificações assíncronas que representam ocorrências operacionais, promovendo um baixo acoplamento entre estas ocorrências e o <strong>Sistema Operacional</strong> facilitando a escalabilidade. Por exemplo, em um sistema de comércio eletrônico, a conclusão de uma compra pode gerar um evento que é consumido por outros serviços, como o de faturamento, o de notificação ao cliente e o de expedição, sem que o serviço de compra precise conhecer diretamente esses outros serviços. O uso de servidores de mensagens, como <a href="https://kafka.apache.org/">Apache Kafka</a>, é comum em <strong>EDA</strong>s para mediar a comunicação assíncrona.</p>
<p>O <strong>modelo distribuído <a href="https://akka.io/">AKKA</a></strong>, implementado por um conjunto de ferramentas de desenvolvimento e um ambiente de execução para construir aplicações concorrentes, distribuídas e resilientes na <strong>JVM</strong>, <strong>J</strong>ava <strong>V</strong>irtual <strong>M</strong>achine, baseado no modelo de atores, também ganhououtração para a construção de sistemas concorrentes e distribuídos resilientes e escaláveis. Neste cenário, os atores são entidades computacionais leves que se comunicam exclusivamente por meio da troca de mensagens assíncronas, embora padrões síncronos como <code>ask</code> possam ser implementados sobre a comunicação assíncrona <code>tell</code>. Estes atores podem ser distribuídos em um cluster de máquinas, permitindo que aplicações complexas sejam construídas a partir da composição de múltiplos atores colaborando para um objetivo comum. Aqui há uma relação interessante entre <strong>Sistemas Operacionais</strong>, sistemas distribuídos, máquinas virtuais e linguagens de programação. O AKKA é uma implementação do modelo de atores, que foi proposto por <a href="https://en.wikipedia.org/wiki/Carl_Hewitt">Carl Hewitt</a> em 1973, e que foi inspirado no conceito de processos concorrentes do <a href="https://pt.wikipedia.org/wiki/Lisp_(linguagem_de_programa%C3%A7%C3%A3o)">Lisp</a>. O <strong>AKKA</strong> foi escrito em <a href="https://www.scala-lang.org/">Scala</a>, uma linguagem funcional que roda na JVM, e que permite a criação de aplicações distribuídas e reativas com alta performance e baixa latência.</p>
<p>A esperta leitora deve considerar que as novas tendências arquitetônicas, como microserviços e <strong>EDA</strong>, não surgem isoladamente, mas como respostas evolutivas diretas aos desafios de concretizar as características fundamentais de escalabilidade e tolerância a falhas em sistemas que se tornam progressivamente mais complexos e com demandas crescentes. Aplicações monolíticas tradicionais enfrentam dificuldades intrínsecas para escalar componentes individuais de forma granular ou para isolar falhas eficazmente; uma falha em um módulo pode comprometer todo o sistema. Em contraste, a arquitetura de microserviços, ao decompor a aplicação em unidades menores e independentes, permite que cada serviço seja escalado conforme sua necessidade específica e que falhas sejam contidas dentro do serviço afetado, preservando a funcionalidade do restante do sistema. Similarmente, a <strong>EDA</strong>, ao promover o desacoplamento por meio da comunicação assíncrona baseada em eventos, aumenta a resiliência, os serviços não dependem diretamente da disponibilidade imediata uns dos outros e a escalabilidade, os produtores de eventos podem operar independentemente dos consumidores.</p>
<p>A proliferação de componentes distribuídos, sejam eles microserviços, atores, os inúmeros dispositivos de borda em um sistema de <strong>IoT</strong>, acarreta um aumento exponencial na complexidade do gerenciamento do sistema como um todo. Manter a coerência, a eficiência, o monitoramento e a depuração em um ambiente com milhares ou milhões de partes móveis é um desafio formidável que deve ser enfrentado pelos <strong>Sistemas Operacionais</strong>. Isso aponta para uma possível evolução em direção a <strong>Sistemas Operacionais</strong> Distribuídos, camadas de gerenciamento de sistema equivalentes, que incorporem níveis mais elevados de Inteligência Artificial e aprendizado de máquina. Tais sistemas poderiam realizar auto-configuração, auto-otimização, auto-reparação e gerenciamento proativo de recursos de forma mais autônoma, uma trajetória análoga à observada nos <strong>Sistemas Operacionais Móveis</strong> com suas capacidades adaptativas de gerenciamento de energia.</p>
<p>A tabela a seguir resume as propriedades essenciais dos sistemas distribuídos e como as tendências arquitetônicas modernas se alinham e aprimoram essas propriedades.</p>
<div id="tbl-distributed-systems" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-distributed-systems-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2.5: Propriedades essenciais dos sistemas distribuídos e como as tendências arquitetônicas modernas se alinham e aprimoram essas propriedades.
</figcaption>
<div aria-describedby="tbl-distributed-systems-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Paradigma/Característica</th>
<th style="text-align: left;">Descrição</th>
<th style="text-align: left;">Tecnologias/Exemplos Chave</th>
<th style="text-align: left;">Benefícios Principais</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Transparência</strong> (Localização, Acesso)</td>
<td style="text-align: left;">Ocultar a distribuição dos componentes, permitindo acesso uniforme a recursos locais/remotos.</td>
<td style="text-align: left;">Middleware, RPC, Nomes de Serviço.</td>
<td style="text-align: left;">Simplificação do desenvolvimento, percepção de sistema único.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Escalabilidade</strong></td>
<td style="text-align: left;">Capacidade de operar eficientemente em diferentes escalas, adaptando-se ao aumento da demanda.</td>
<td style="text-align: left;">Balanceamento de Carga, Replicação, Particionamento de Dados.</td>
<td style="text-align: left;">Suporte ao crescimento, desempenho consistente.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Tolerância a Falhas</strong></td>
<td style="text-align: left;">Continuar operando corretamente mesmo com falhas em componentes, por meio de redundância e recuperação.</td>
<td style="text-align: left;">Replicação de Dados/Serviços, Checkpointing, transações Distribuídas.</td>
<td style="text-align: left;">Alta disponibilidade, resiliência.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Arquitetura de Microserviços</strong></td>
<td style="text-align: left;">Decomposição da aplicação em pequenos serviços independentes e fracamente acoplados.</td>
<td style="text-align: left;">Docker, Kubernetes, <code>APIs</code>REST/gRPC.</td>
<td style="text-align: left;">Implantação independente, escalabilidade granular, diversidade tecnológica, resiliência.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Arquitetura Orientada a Eventos (EDA)</strong></td>
<td style="text-align: left;">Sistemas reagem a eventos assíncronos, promovendo baixo acoplamento e escalabilidade.</td>
<td style="text-align: left;">Apache Kafka, RabbitMQ, Filas de Mensagens.</td>
<td style="text-align: left;">Desacoplamento, escalabilidade, resiliência, capacidade de resposta em tempo real.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Computação de Borda/Névoa</strong></td>
<td style="text-align: left;">Processamento de dados mais próximo da origem, reduzindo latência e uso de banda.</td>
<td style="text-align: left;">Dispositivos IoT, Gateways de Borda, Edge AI, Plataformas de Fog Computing.</td>
<td style="text-align: left;">Baixa latência, economia de banda, processamento em tempo real, privacidade aprimorada.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Esta visão panorâmica conecta os conceitos teóricos fundamentais dos sistemas distribuídos com as implementações práticas e as tendências que estão moldando ativamente este campo vital da computação. A evolução dos sistemas distribuidos levou a computação em nuvem.</p>
</section>
<section id="computação-em-nuvem-transformando-o-design-de-sistemas-operacionais" class="level3" data-number="2.2.4">
<h3 data-number="2.2.4" class="anchored" data-anchor-id="computação-em-nuvem-transformando-o-design-de-sistemas-operacionais"><span class="header-section-number">2.2.4</span> Computação em Nuvem: transformando o Design de Sistemas Operacionais</h3>
<p>A <a href="https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-145.pdf">computação em nuvem</a> representou uma das transformações mais profundas na arquitetura de <strong>Sistemas Operacionais</strong> desde o advento da multiprogramação. <em>Esta revolução tecnológica não apenas alterou como recursos computacionais são disponibilizados e consumidos, mas fundamentalmente redefiniu os requisitos e expectativas que recaem sobre os <strong>Sistemas Operacionais</strong> modernos</em>. A computação em nuvem é, em última instância, uma atualização da <strong>computação distribuida</strong>, que vimos antes, com algumas características de interfacemento com usuários e de demanda. A curiosa leitora pode começar a compreender impacto destas tecnologias observando como as características essenciais da computação em nuvem criaram novos paradigmas de design que os <strong>Sistemas Operacionais</strong> devem abraçar. Imagine um sistema na nuvem, a primeira coisa que vem a mente é que a própria leitora terá que configurar suas máquinas e seus serviços. Isto é <strong>autoatendimento</strong>.</p>
<p>O conceito de autoatendimento sob demanda, que permite aos usuários provisionarem recursos computacionais automaticamente sem intervenção humana de terceiros, impõe aos <strong>Sistemas Operacionais</strong> a necessidade de suportar automação extensiva por meio de interfaces de programação robustas. Esta característica elimina a configuração manual tradicional e exige que o <strong>Sistema Operacional</strong> seja capaz de responder dinamicamente a requisições de provisionamento, configurando-se automaticamente conforme demandas específicas. Simultaneamente, o amplo acesso à rede, outra característica fundamental da nuvem, demanda que <strong>Sistemas Operacionais</strong> sejam otimizados para uma heterogeneidade de plataformas e dispositivos nunca antes vista, necessitando de adaptabilidade e eficiência operacional em ambientes de rede complexos e distribuídos.</p>
<p>A implementação de agrupamento de recursos em <strong>modelos multilocatários</strong> introduz complexidades arquiteturais significativas que transcendem os desafios tradicionais de segurança e isolamento. Modelos multilocatários em inglês multitenancy, referem-se a uma arquitetura de software na qual uma única instância de uma aplicação ou sistema serve múltiplos clientes independentes, chamados de locatários ou inquilinos, no inglês tenants. Neste modelos <em>Os <strong>Sistemas Operacionais</strong> devem garantir que recursos físicos e virtuais sejam dinamicamente alocados entre múltiplos usuários sem comprometer a privacidade, a performance ou a integridade dos dados</em>.</p>
<p>Para entender este modelo multilocatário a criativa leitora pode imaginar um serviço de email como o Gmail. Milhões de usuários diferentes usam a mesma plataforma, mesmos servidores, mesmo software, mas cada usuário vê apenas seus próprios emails e configurações. Os dados do usuário <span class="math inline">\(A\)</span> nunca aparecem para o usuário <span class="math inline">\(B\)</span>, mesmo estando no mesmo sistema. Esta característica da nuvem exige mecanismos sofisticados de virtualização que vão além das implementações tradicionais, incorporando controle de acesso granular e técnicas de isolamento que permitem o compartilhamento seguro da mesma infraestrutura física entre múltiplos locatários.</p>
<p>A <strong>elasticidade</strong> emerge como o desafio mais significativo e transformador para os <strong>Sistemas Operacionais</strong> modernos. <em>Esta capacidade de ajustar dinamicamente os recursos disponíveis de acordo com a demanda representa uma mudança fundamental na forma como é concebido o gerenciamento de recursos computacionais</em>. Os <strong>Sistemas Operacionais</strong> devem ser capazes de expandir e contrair a disponibilidade de recursos como <code>CPU</code>, memória e armazenamento, em tempo real, respondendo a flutuações de demanda sem degradação perceptível de performance. Isso requer arquiteturas que suportem tanto escalonamento horizontal, adicionando mais instâncias de recursos, quanto vertical, aumentando a capacidade de recursos existentes, tudo isso acontecendo de forma automática e transparente. A eficiência da elasticidade depende da capacidade de provisionamento dos sistemas.</p>
<p>O <strong>provisionamento sob demanda</strong>, que permite a criação instantânea de recursos computacionais, impõe requisitos rigorosos de velocidade e automação aos <strong>Sistemas Operacionais</strong>. <em>Estes devem suportar inicialização extremamente rápida, configuração automática inteligente e integração perfeita com interfaces de programação</em>, permitindo que recursos sejam disponibilizados em questão de segundos por meio de portais web ou chamadas de API. Esta capacidade de resposta instantânea requer modificações e personalizações específicas para este cenário de provisionamento nos processos de <code>boot</code>, inicialização de serviços e configuração de rede.</p>
<p>Estando na nuvem ou não, recursos computacionais são caros. A precavida leitora terá que pagar pelos recursos que usar. Para que estes recursos sejam cobrados eles precisam ser medidos. Assim, o paradigma de <strong>serviço mensurado</strong> introduz uma dimensão econômica direta no design de <strong>Sistemas Operacionais</strong>. <em>Esta característica indispensável para a engenharia econômica dos sistemas em nuvem exige que os <strong>Sistemas Operacionais</strong> implementem capacidades extensivas de monitoramento e coleta de dados de utilização de recursos</em>. Deste ponto em diante, neste livro, esses dados de utilização serão chamados de métricas. Em sistemas na nuvem cada operação, cada ciclo de <code>CPU</code>, cada byte de memória ou cada byte transferido deve ser contabilizado com precisão para facilitar modelos de cobrança por uso e permitir otimizações realizadas sobre dados reais de uso e demanda. Esta necessidade de instrumentação abrangente influencia profundamente a arquitetura interna dos <strong>Sistemas Operacionais</strong>, exigindo sistemas de telemetria integrados nos <strong>Sistemas Operacionais</strong> desde a sua concepção.</p>
<section id="a-influência-dos-modelos-de-serviço" class="level4" data-number="2.2.4.1">
<h4 data-number="2.2.4.1" class="anchored" data-anchor-id="a-influência-dos-modelos-de-serviço"><span class="header-section-number">2.2.4.1</span> A Influência dos Modelos de Serviço</h4>
<p>Os modelos de serviço que emergiram como consequencia da popularização da computação em nuvem também exercem influência profunda no design de <strong>Sistemas Operacionais</strong>, cada um destes modelos cria demandas específicas e requer cuidados personalizados. Três desses modelos de serviço tem impacto relevante no projeto, desenvolvimento e operação de Sistemas Operacionais:</p>
<ol type="1">
<li><p>O <strong>Software como Serviço</strong> <strong>S</strong>oftware <strong>a</strong>s <strong>a</strong> <strong>S</strong>ervice, <strong>SaaS</strong>, representa o modelo de computação em nuvem mais próximo do usuário final, no qual aplicações completas são entregues pela internet como serviços prontos para uso, eliminando a necessidade de instalação, manutenção ou gerenciamento local de software pelos usuários. <em>Neste paradigma, exemplificado por serviços como Gmail, Salesforce ou Microsoft 365, os usuários acessam funcionalidades complexas por meio de navegadores web ou aplicativos leves, enquanto toda a infraestrutura computacional permanece centralizada e gerenciada pelo provedor do serviço</em>. Este modelo requer <strong>Sistemas Operacionais</strong> especificamente adaptados e otimizados para hospedar aplicações multi-usuário massivas com garantias rigorosas de alta disponibilidade e performance consistente, capazes de servir simultaneamente milhões de usuários concorrentes sem degradação perceptível de serviço. <em>O <strong>Sistema Operacional</strong> deve tornar-se completamente invisível e transparente ao usuário final, focando exclusivamente na eficiência de execução de aplicações</em> e na otimização de recursos para maximizar a capacidade de atendimento simultâneo. Esta invisibilidade operacional exige que o sistema abstrai completamente a complexidade da infraestrutura subjacente, incluindo gerenciamento de sessões de usuário, balanceamento de carga dinâmico, replicação de dados em tempo real e recuperação automática de falhas, tudo isso ocorrendo de forma transparente enquanto mantém a ilusão de um serviço único e coeso para cada usuário individual.</p></li>
<li><p>A <strong>Plataforma como Serviço</strong>, <strong>P</strong>latform <strong>a</strong>s <strong>a</strong> <strong>S</strong>ervice, <strong>PaaS</strong>, representa um modelo de computação em nuvem que fornece uma plataforma completa de desenvolvimento e implantação, permitindo aos desenvolvedores criar aplicações sem se preocupar com a complexidade da infraestrutura subjacente. <em>Este paradigma apresenta demandas arquiteturais diferentes mas igualmente exigentes aos <strong>Sistemas Operacionais</strong>, que devem atuar como uma fundação invisível porém robusta para ecossistemas de desenvolvimento inteiros</em>. Os ambientes <strong>PaaS</strong> requerem <strong>Sistemas Operacionais</strong> capazes de suportar uma diversidade extraordinária de linguagens de programação, desde Python e Java até linguagens emergentes, bem como suas respectivas bibliotecas, frameworks e dependências específicas, tudo isso de forma simultânea e isolada. <em>Esta flexibilidade linguística deve coexistir com capacidades robustas de isolamento entre aplicações em desenvolvimento</em>, garantindo que projetos de diferentes equipes ou organizações não interfiram uns com os outros mesmo compartilhando a mesma infraestrutura física. O gerenciamento automático de recursos de desenvolvimento constitui outro requisito fundamental, englobando a orquestração transparente de ambientes de teste, processos de compilação automatizados e pipelines de implantação contínua, todas essas funcionalidades devendo ser integradas nativamente ao <strong>Sistema Operacional</strong> para proporcionar uma experiência de desenvolvimento fluida e eficiente.</p></li>
<li><p>A Infraestrutura como Serviço, <strong>I</strong>nfrastructure <strong>a</strong>s <strong>a</strong> <strong>S</strong>ervice, <strong>IaaS</strong>, constitui o modelo mais fundamental da computação em nuvem, oferecendo recursos de computação virtualizados sob demanda, incluindo servidores virtuais, armazenamento e redes, permitindo aos usuários construir suas próprias soluções sobre uma infraestrutura física compartilhada. <em>Este modelo exige que <strong>Sistemas Operacionais</strong> funcionem eficientemente como hospedeiros de virtualização de alta performance, atuando como uma camada de orquestração sofisticada que deve maximizar a utilização do hardware físico enquanto mantém isolamento perfeito entre inquilinos</em>. Os sistemas devem suportar a criação, gerenciamento e destruição de múltiplas instâncias de <strong>Sistemas Operacionais</strong> convidados de forma dinâmica e escalável, oferecendo aos usuários a flexibilidade de provisionar desde pequenas instâncias para desenvolvimento até poderosos servidores virtuais para cargas de trabalho empresariais críticas. <em>A performance destas máquinas virtuais deve aproximar-se significativamente do hardware nativo</em>, um requisito que demanda a implementação de técnicas avançadas de virtualização assistida por hardware, como <a href="https://www.thomas-krenn.com/en/wiki/Overview_of_the_Intel_VT_Virtualization_Features">Intel VT-x</a> e <a href="https://fastneuron.com/forum/showthread.php?tid=5085">AMD-V</a>, bem como otimizações específicas para cargas de trabalho virtualizadas que minimizem a sobrecarga introduzida pelas camadas de abstração. O <strong>Sistema Operacional</strong> hospedeiro deve gerenciar eficientemente recursos como memória, <code>CPU</code> e <code>E/S</code> entre múltiplas máquinas virtuais concorrentes, implementando algoritmos de escalonamento e alocação que garantam tanto performance quanto isolamento, enquanto fornece interfaces de gerenciamento que permitam aos usuários controlar seus recursos virtuais como se fossem hardware físico dedicado.</p></li>
</ol>
<p>Esta convergência de requisitos transform fundamentalmente como <strong>Sistemas Operacionais</strong> são concebidos e implementados. <em>A computação em nuvem não representa meramente uma evolução incremental, mas uma reconfiguração fundamental dos princípios que governam o design de Sistemas Operacionais</em>. As arquiteturas resultantes devem ser mais modulares, eficientes em recursos e capazes de operação verdadeiramente autônoma em ambientes distribuídos e dinamicamente reconfiguráveis, estabelecendo novos paradigmas que continuarão a influenciar o desenvolvimento de <strong>Sistemas Operacionais</strong> nas próximas décadas.</p>
</section>
</section>
<section id="inteligência-artificial-e-modelos-de-linguagem-de-grande-escala-llms" class="level3" data-number="2.2.5">
<h3 data-number="2.2.5" class="anchored" data-anchor-id="inteligência-artificial-e-modelos-de-linguagem-de-grande-escala-llms"><span class="header-section-number">2.2.5</span> Inteligência Artificial e Modelos de Linguagem de Grande Escala (LLMs)</h3>
<p>Os LLMs, como o GPT-4 ou modelos similares, são exemplos excelentes para avaliação dos impactos que as tecnologias de Inteligência Artificial terão sobre os <strong>Sistemas Operacionais</strong>. Os LLMs requerem recursos computacionais significativos, geralmente executados em sistemas de computação de alto desempenho equipados com <a href="https://www.nvidia.com/en-us/technologies/">GPUs</a>, <a href="https://www.nvidia.com/en-us/technologies/">TPUs</a> ou <a href="https://groq.com/the-groq-lpu-explained/">LPUs</a>. Esses modelos possuem bilhões de parâmetros, exigindo processamento paralelo eficiente. Neste caso, a criativa leitora deve considerar que a execução de <strong>LLMs</strong> sobrecarrega a <code>CPU</code>, <code>GPU</code> e memória, exigindo <strong>Sistemas Operacionais</strong> que otimizem a alocação de recursos. Além disso, o treinamento e a inferência de <strong>LLMs</strong> consomem grandes quantidades de energia, com estimativas de até <a href="https://www.oneadvanced.com/resources/large-language-models-part-1-hardware-and-software-aspects/">1.287.000 kWh</a> para treinamento, gerando preocupações ambientais com emissões de carbono de cerca de <span class="math inline">\(552\)</span> toneladas e colocando pressão sobre os <strong>Sistemas Operacionais</strong> para implementar técnicas de gerenciamento de energia mais eficientes. Finalmente os <strong>Sistemas Operacionais</strong> precisam gerenciar eficientemente grandes quantidades de memória para suportar os modelos, especialmente em dispositivos de borda, dispositivos móveis e embarcados com recursos limitados.</p>
<p>A necessidade de cálculos numéricos, operações com matrizes, necessárias aos algoritmos de Inteligência Artificial, fez com que o hardware evoluísse para novas formas de processamento: as <code>GPU</code>s, <code>TPU</code>s, e <code>LPU</code>s.</p>
<p>As <code>GPU</code>s, originalmente projetadas para renderização gráfica, evoluíram para computação paralela de alta performance, exigindo drivers específicos como <a href="https://developer.nvidia.com/cuda-toolkit">CUDA</a> para NVIDIA ou <a href="https://www.amd.com/en/products/software/rocm.html">ROCm</a> para AMD, além de bibliotecas que gerenciem o paralelismo massivo. Isso requer otimizações no <strong>Sistema Operacional</strong> para lidar com tarefas de computação intensiva, como alocação de memória em <code>GPU</code> e comunicação eficiente entre <code>CPU</code> e <code>GPU</code>. Já as <code>TPUs</code>, desenvolvidas pelo Google para acelerar tarefas de aprendizado de máquina, demandam integração com frameworks como <a href="https://www.tensorflow.org/?hl=pt-br">TensorFlow</a>, necessitando que os <strong>Sistemas Operacionais</strong> suportem <code>API</code>s específicas e gerenciem a comunicação com esses chips otimizados para operações de tensor, o que pode incluir ajustes no <code>kernel</code> para chamadas de sistema ou gerenciamento de energia. As <code>LPUs</code>, como as projetadas pela Groq para processamento de linguagem natural, requerem bibliotecas especializadas e otimizações para execução de modelos de linguagem, focando em baixa latência e alta eficiência em tarefas de inferência e treinamento. A <a href="#fig-gputpulpu" class="quarto-xref">Figure&nbsp;<span>2.18</span></a> permite a comparação entre estas tecnologias de hardware especializado.</p>
<div id="fig-gputpulpu" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gputpulpu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/gpu_tpu_lpu_comparison.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gputpulpu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.18: O diagrama apresenta três colunas verticais representando as arquiteturas modernas de processadores de IA mais avançadas: GPU (NVIDIA Hopper H100), TPU (Google v6e Trillium) e LPU (Groq TSP v1). Cada coluna segue uma organização hierárquica de camadas, do nível de aplicação até o hardware físico.
</figcaption>
</figure>
</div>
<p>Estes dispositivos especiais também demandam novas abstrações de programação, com <code>API</code>s e frameworks como <a href="https://www.khronos.org/opencl/">OpenCL</a>, <a href="https://www.vulkan.org/">Vulkan</a> ou <a href="https://openxla.org/xla?hl=pt-br">XLA</a> integrados ao <strong>Sistema Operacional</strong> para facilitar o desenvolvimento de aplicações, simplificando a complexidade para os desenvolvedores. Na operação, o impacto se reflete no desempenho e eficiência. GPUs exigem que os <strong>Sistemas Operacionais</strong> gerenciem kernels gráficos e computacionais, garantindo baixa latência para aplicações como jogos ou renderização 3D e alta taxa de transferência para computação científica. <code>TPU</code>s, frequentemente usadas em data centers, requerem <strong>Sistemas Operacionais</strong> otimizados para <code>pipelines</code> de dados que alimentem grandes volumes de informações, minimizando o custo computacional extra de comunicação. <code>LPUs</code>, por sua vez, priorizam baixa latência em inferências de modelos de linguagem, essenciais para aplicações em tempo real como <em>chatbots</em> ou assistentes de Inteligência Artificial, exigindo ajustes no agendador de tarefas do sistema para priorizar essas tarefas. Exemplos práticos ilustram esses impactos:</p>
<ol type="1">
<li><p>O <strong>Linux</strong>, amplamente usado em servidores e <code>data centers</code>, suporta <code>GPU</code>s, <code>TPU</code>s e, potencialmente, <code>LPU</code>s por meio de drivers e frameworks como CUDA, ROCm e TensorFlow, beneficiando-se de um <code>kernel</code> modular que facilita a adição de suporte a novos dispositivos.</p></li>
<li><p>O Windows, otimizado para <code>GPU</code>s em jogos e aplicações gráficas, suporta <a href="https://microsoft.github.io/DirectX-Specs/">DirectX</a> e CUDA, sendo menos comum para <code>TPU</code>s, mas deve ser capaz de suportar <code>LPU</code>s via <a href="https://learn.microsoft.com/en-us/windows/wsl/about">WSL</a>.</p></li>
<li><p>Sistemas embarcados, como o Android, otimizam <code>GPU</code>s como <a href="https://www.qualcomm.com/products/technology/processors/adreno">Adreno</a> ou <a href="https://www.arm.com/products/silicon-ip-multimedia">Mali</a> para gráficos e, cada vez mais, para aprendizado de máquina com suporte a <code>TPU</code>s e <code>LPU</code>s em chips como o <a href="https://cloud.google.com/tpu">Google Tensor</a>, demonstrando a adaptação dos <strong>Sistemas Operacionais</strong> a esses dispositivos especializados.</p></li>
</ol>
<p>Existem também preocupações de segurança associadas ao uso de <strong>LLMs</strong>. Os <strong>LLMs</strong> podem ser explorados para gerar conteúdo malicioso, como e-mails de <code>phishing</code> ou código malicioso, representando riscos de segurança. Os <strong>Sistemas Operacionais</strong> precisam se adaptar para mitigar esses problemas atuando na <strong>Detecção de Conteúdo Malicioso</strong>, os <strong>Sistemas Operacionais</strong> podem e devem incorporar ferramentas de segurança avançadas para identificar e bloquear conteúdo gerado por <strong>LLMs</strong> que possa comprometer a segurança. Os <strong>Sistemas Operacionais</strong> também devem implementar medidas de <strong>Proteção de Dados</strong>, sistemas como os <strong>LLMs</strong> frequentemente requerem acesso a grandes quantidades de dados do usuário. Os <strong>Sistemas Operacionais</strong> precisam implementar medidas robustas de proteção de dados para evitar vazamentos.</p>
<section id="integração-de-llms-em-sistemas-operacionais" class="level4" data-number="2.2.5.1">
<h4 data-number="2.2.5.1" class="anchored" data-anchor-id="integração-de-llms-em-sistemas-operacionais"><span class="header-section-number">2.2.5.1</span> Integração de LLMs em Sistemas Operacionais</h4>
<p>A atenta leitora vai lembrar que já discutimos a integração de Inteligência Artificial nos <strong>Sistemas Operacionais</strong> na <a href="#sec-desafios-arquitetura-operacao" class="quarto-xref"><span>Section 2.2.1.2</span></a>. Agora precisamos voltar para a interação com os usuários e analisar qual será o impacto dos Modelos de Linguagem nos <strong>Sistemas Operacionais</strong>. Paulatinamente aparecem tendências e pesquisas indicando que os <strong>LLMs</strong> estão sendo integrados aos <strong>Sistemas Operacionais</strong>, por uma tecnologia conhecida como <strong>L</strong>arge <strong>L</strong>anguage <strong>Mo</strong>del<strong>s</strong> ou, com um pouco de marketing podemos chamar de <a href="https://medium.com/%40lucien1999s.pro/llmos-revolutionizing-operating-systems-with-large-language-models-86ff61a714a4">LLMOS Revolution</a>, com a esperança de transformar a interação entre usuários e dispositivos. Esta integração começa a ser percebida na possiblidade de integração de <strong>LLMs</strong> diretamente no <strong>Sistema Operacional</strong>, funcionando como um <code>Kernel</code> para interações em linguagem natural. Parte desta tecnologia pode ser vista no <a href="https://www.llmo.org/">LLMO</a>, um <strong>Sistema Operacional</strong> que utiliza <strong>LLMs</strong> para fornecer uma interface de usuário baseada em linguagem natural, permitindo que os usuários interajam com o sistema de forma mais intuitiva e eficiente.</p>
<p>Em <strong>Sistemas Operacionais</strong> tradicionais, como o Windows, podemos ver esta integração por meio de <strong>APIs e Plugins</strong>. Um bom exemplo pode ser visto observando os assistentes inteligentes, como o <a href="https://copilot.microsoft.com/">Windows Copilot</a>, utilizam <code>APIs</code>para integrar capacidades de <strong>LLMs</strong>, permitindo comandos simplificados e algum nível de automação. Por fim, já existem aplicações especializadas. Aplicativos que aproveitam <strong>LLM</strong>s, como ferramentas de geração de texto ou análise de dados, dependem de <strong>Sistemas Operacionais</strong> para gerenciar suas operações. Um bom exemplo de aplicação especializada é o <a href="https://github.com/features/copilot">GitHub Copilot</a>. O GitHub Copilot é uma ferramenta de programação desenvolvida pelo GitHub e pela OpenAI. Ele funciona como um assistente inteligente que se integra a editores de código, como o próprio <a href="https://code.visualstudio.com/">VS Code</a>, e sugere linhas de código ou funções inteiras em tempo real, enquanto o desenvolvedor digita.</p>
<p>Neste momento da história em que o pobre autor tem a ousadia de escrever, a integração de <strong>LLMs</strong> em <strong>Sistemas Operacionais</strong> parece ter impacto positivo na experiência do usuário por meio de interfaces mais intuitivas e inteligentes. Os assistentes de voz evoluem para compreender contexto, nuances linguísticas e intenções implícitas, permitindo conversas naturais que transcendem comandos rígidos e pré-definidos. Esta capacidade estende-se ao processamento de comandos complexos expressos em linguagem natural, na qual usuários podem descrever tarefas multifacetadas sem conhecer sintaxes específicas ou sequências de operações técnicas. Acrescente a isso, amável leitora, que a <strong>capacidade de busca e integração semântica</strong> representa uma transformação paradigmática. Um degrau de evolução. A perspicaz leitora pode quantificar este impacto focando no sistema de arquivos. Considere que a integração semântica irá permitir que <strong>Sistemas Operacionais</strong> compreendam intenções de busca independentemente de palavras-chave exatas. Usuários podem localizar arquivos, aplicações e informações por meio de descrições conceituais, relacionamentos semânticos e associações contextuais, integrando busca multimodal que correlaciona texto, imagens, áudio e vídeo de forma unificada e inteligente. Porém, há sempre um porém. <em>A implementação de <strong>LLMs</strong> em <strong>Sistemas Operacionais</strong> apresenta limitações técnicas e operacionais que afetam sua integração prática</em>. O consumo de recursos computacionais é substancial, com modelos requerendo quantidades específicas de memória e capacidade de processamento que podem impactar a performance global do sistema, particularmente em dispositivos com recursos limitados como smartphones, tablets e sistemas embarcados. Esta demanda computacional exigirá um balanceamento entre funcionalidade e capacidade computacional um pouco mais delicada do que as escolhas que já existem nos sistemas puramente determinísticos.</p>
<p>Além dos limites impostos pelos limites de memória e velociade, existem as preocupações relacionadas com a privacidade. Precisamos considerar que a operação destes modelos envolvem coleta, processamento e armazenamento de dados pessoais. Os modelos requerem acesso a padrões de uso, preferências comportamentais e dados contextuais para funcionalidade efetiva, criando requisitos específicos para conformidade regulatória, gestão de consentimento e proteção de dados. Existem perigos relacionados ao mal uso destes dados embutidos nesta integração.</p>
<p>Para terminar os desafios. Podemos falar em confiabilidade. A confiabilidade dos <strong>LLMs</strong> apresenta características operacionais específicas, incluindo variabilidade nas respostas geradas, potencial para produzir saídas imprecisas ou contextualmente inadequadas, e dependência de dados de treinamento que podem conter vieses. Esta variabilidade requer implementação de mecanismos de validação, monitoramento de saídas e sistemas de verificação para operação consistente do <strong>Sistema Operacional</strong>.</p>
<p>A tabela <a href="#tbl-llms1" class="quarto-xref">Table&nbsp;<span>2.6</span></a> resume os desafios que serão, e já estão sendo, enfrentados por desenvolvedores de sistmeas operacionais.</p>
<div id="tbl-llms1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-llms1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2.6: Desafios da Integração de LLMs em <strong>Sistemas Operacionais</strong> e seus Efeitos
</figcaption>
<div aria-describedby="tbl-llms1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 15%">
<col style="width: 43%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Aspecto</strong></th>
<th><strong>Desafio</strong></th>
<th><strong>Efeito no Sistema Operacional</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Recursos Computacionais</td>
<td>Alta demanda por GPUs/TPUs e memória</td>
<td>Necessidade de otimização de alocação de recursos</td>
</tr>
<tr class="even">
<td>Consumo de Energia</td>
<td>Uso intensivo de energia durante treinamento e inferência</td>
<td>Gestão de energia eficiente para reduzir custos e impacto ambiental</td>
</tr>
<tr class="odd">
<td>Segurança</td>
<td>Geração de conteúdo malicioso</td>
<td>Implementação de ferramentas de detecção e mitigação</td>
</tr>
<tr class="even">
<td>Privacidade</td>
<td>Acesso a grandes quantidades de dados do usuário</td>
<td>Medidas robustas de proteção de dados</td>
</tr>
<tr class="odd">
<td>Confiabilidade</td>
<td>Saídas imprevisíveis ou tendenciosas</td>
<td>Validação e monitoramento contínuos</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
</section>
<section id="o-impacto-da-computação-quântica-em-sistemas-operacionais" class="level3" data-number="2.2.6">
<h3 data-number="2.2.6" class="anchored" data-anchor-id="o-impacto-da-computação-quântica-em-sistemas-operacionais"><span class="header-section-number">2.2.6</span> O Impacto da Computação Quântica em Sistemas Operacionais</h3>
<p>A possibilidade de computação quântica efetiva e prática representa uma mudança de paradigma fundamental, utilizando como elemento fundamental os <strong>qubits</strong> que podem existir em superposição, <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span> ou combinação de ambos, e <strong>emaranhamento</strong> entre múltiplos <strong>qubits</strong>. Essas propriedades permitem explorar um espaço computacional vastamente maior e realizar alguns cálculos exponencialmente mais rápidos que os computadores clássicos, com potencial para resolver problemas NP-difíceis em otimização, simulação molecular, criptografia e aprendizado de máquina.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Problemas NP-difíceis</strong> são uma classe de problemas computacionais extremamente desafiadores que não possuem algoritmos conhecidos capazes de resolvê-los em tempo polinomial, ou de forma eficiente, em computadores clássicos. Exemplos destes problemas incluem o problema do caixeiro viajante, fatoração de números grandes e o Problema da Mochila, <em>Knapsack Problem</em>. Estes problemas são fundamentais em criptografia, logística e simulação científica. A computação quântica oferece potencial para resolver alguns destes problemas exponencialmente mais rápido que métodos clássicos, talvez instantaneamente, representando uma das principais motivações para o desenvolvimento de tecnologias quânticas.</p>
</div>
</div>
<p>Atualmente, a computação quântica encontra-se na era <strong>NISQ</strong>, <strong>N</strong>oisy <strong>I</strong>ntermediate-<strong>S</strong>cale <strong>Q</strong>uantum, com <strong>qubits</strong> limitados e suscetíveis a ruído e decoerência, restringindo a profundidade dos circuitos executáveis e a precisão dos cálculos. As características e limitações dos sistemas computacionais quânticos tornam necessária a existência de um <strong>Sistema Operacional Quântico</strong> em inglês <strong>Q</strong>uantum <strong>C</strong>omputer <strong>O</strong>perational <strong>S</strong>ystem ou <strong>QCOS</strong>.</p>
<p>Um <strong>QCOS</strong> é uma camada de software especializada que gerencia hardware quântico, coordena alocação de recursos quânticos e facilita a execução de algoritmos quânticos em <code>QPU</code>s, unidades de processamento quânticas. Enquanto <strong>Sistemas Operacionais</strong> clássicos gerenciam <code>CPU</code>, memória e <code>E/S</code>, um <strong>QCOS</strong> deve lidar com desafios únicos como gerenciamento de emaranhamento, manutenção de coerência de <strong>qubits</strong> e correção de erros quânticos. As funções primárias de um <strong>QCOS</strong> incluem: o <strong>Gerenciamento de Recursos Quânticos</strong>, a manipulação cuidadosa de qubits, garantindo inicialização correta, emaranhamento conforme necessário e medição precisa; a <strong>Correção de Erros Quânticos e Mitigação de Ruído</strong>, caracterizada pela aplicação de algoritmos de correção de erros quânticos (QEC) ou técnicas de mitigação de erros na era NISQ para aumentar a fidelidade dos resultados; o <strong>Escalonamento e Otimização de Algoritmos Quânticos</strong>, para o escalonamento eficiente de operações quânticas, otimizando execução para reduzir tempo e maximizar utilização de recursos por meio de compiladores e runtime que gerenciam execução em múltiplas <code>QPU</code>s; e, finalmente, a <strong>Abstração e Interface</strong>, o fornecimento de camada de abstração sobre complexidade do hardware quântico, como a abstração <em>Qernel</em> que expõe <code>APIs</code>transparentes para execução de jobs quânticos.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Qernel: Interface para Hardware Quântico</strong><br>
O termo <strong>Qernel</strong>, mencionado nos <strong>Sistemas Operacionais Quânticos</strong> (QCOS), refere-se a uma camada de abstração que simplifica a interação com hardware quântico. Semelhante a um <code>Kernel</code> clássico, o <strong>Qernel</strong> gerencia qubits, operações quânticas e medições, oferecendo <code>APIs</code>para desenvolvimento e conexão. Ele oculta complexidades como decoerência e conectividade de <strong>qubits</strong>, permitindo o desenvolvimento de algoritmos quânticos sem conhecimento detalhado do hardware. Plataformas como <a href="https://www.ibm.com/quantum/qiskit">Qiskit</a> e <a href="https://quantumai.google/cirq">Cirq</a> utilizam conceitos similares para facilitar a programação quântica.</p>
</div>
</div>
<p>O desenvolvimento de <strong>QCOS</strong> enfrenta uma constelação de desafios intrínsecos que emergem diretamente das propriedades fundamentais da mecânica quântica e das limitações tecnológicas atuais. A decoerência e o ruído constituem obstáculos primordiais, exigindo a implementação de mecanismos de mitigação extremamente sofisticados que devem operar continuamente para preservar a integridade dos estados quânticos. Estes fenômenos físicos inevitáveis degradam rapidamente a informação quântica, forçando os desenvolvedores de <strong>QCOS</strong> a criar estratégias de correção de erros em tempo real que frequentemente consomem recursos computacionais significativos. Simultaneamente, a escalabilidade apresenta-se como um desafio de complexidade exponencial, onde cada <strong>qubit</strong> adicional ao sistema não apenas aumenta linearmente os recursos necessários, mas multiplica exponencialmente as interações possíveis e os estados que devem ser gerenciados, criando uma barreira fundamental para sistemas quânticos de grande escala. Além disso, a integração harmoniosa com sistemas clássicos emerge como requisito indispensável para a viabilidade prática dos modelos híbridos, demandando protocolos de comunicação eficientes e sincronização precisa entre paradigmas computacionais fundamentalmente diferentes. Por fim, a confiabilidade operacional do próprio <strong>QCOS</strong> deve atingir padrões de excelência que transcendem os requisitos de sistemas clássicos, uma vez que a natureza probabilística e frágil dos estados quânticos torna qualquer falha do <strong>Sistema Operacional</strong> potencialmente catastrófica para a integridade dos cálculos em andamento.</p>
<p>As <strong>arquiteturas de computação híbrida quântica-clássica</strong> estão emergindo como abordagem promissora, nas quais computadores clássicos trabalham com <code>QPU</code>s. O <code>QPU</code> atua como acelerador especializado para partes de software que podem ser beneficiadas com o uso da computação quântica, enquanto o sistema clássico lida com conversão de código entre paradigmas, orquestração, preparação de dados e pós-processamento. Nestes sistemas, hardware especializado como <code>GPU</code>s e <code>FPGA</code>s/<code>RFSoC</code>s desempenha as funções de controle e medição de <strong>qubits</strong>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>FPGA e RFSoC: Hardware Especializado para Controle Quântico</strong></p>
<p><strong>Field-Programmable Gate Arrays (FPGAs)</strong> são circuitos integrados reconfiguráveis que podem ser programados após a fabricação para implementar qualquer função lógica digital. <em>Diferentemente de processadores tradicionais que executam instruções sequencialmente, os FPGAs permitem a criação de circuitos digitais customizados que operam em paralelo massivo</em>. Esta característica os torna ideais para aplicações que exigem processamento em tempo real de alta velocidade, baixa latência e controle preciso de timing.</p>
<p>No contexto da computação quântica, os <strong>FPGAs</strong> desempenham funções críticas de <strong>controle de qubits</strong>, gerando pulsos de micro-ondas precisos para manipulação de estados quânticos, <strong>aquisição de dados em tempo real</strong> para medição de qubits, e <strong>processamento de sinais</strong> para correção de erros e calibração do sistema. Sua capacidade de reconfiguração permite que algoritmos de controle sejam atualizados conforme necessário sem alterações de hardware.</p>
<p><strong>RF System-on-Chip (RFSoCs)</strong> representam uma evolução dos FPGAs, integrando capacidades de radiofrequência diretamente no chip. <em>Os RFSoCs combinam um FPGA com conversores analógico-digitais (ADCs) e digital-analógicos (DACs) de alta velocidade, permitindo processamento direto de sinais de RF sem necessidade de componentes externos</em>. Esta integração é particularmente valiosa em sistemas quânticos que operam em frequências de micro-ondas.</p>
<p>Em aplicações quânticas, <strong>RFSoCs</strong> oferecem vantagens significativas: <strong>geração direta de sinais de controle</strong> para qubits sem conversões intermediárias, <strong>redução de latência</strong> crítica para operações de correção de erros em tempo real, <strong>menor consumo de energia</strong> através da integração, e <strong>sincronização precisa</strong> entre múltiplos canais de controle. Empresas como Xilinx (agora AMD) desenvolveram RFSoCs especificamente otimizados para controle de sistemas quânticos, como a série Zynq UltraScale+ RFSoC.</p>
<p>A importância destes dispositivos na computação quântica está na sua capacidade de fornecer o controle de timing de nanossegundos necessário para manipular estados quânticos frágeis, processo esse que seria impossível com hardware de propósito geral devido às limitações de latência e precisão temporal.</p>
</div>
</div>
<p>O <strong>Sistema Operacional</strong> em ambiente híbrido orquestra tarefas entre componentes clássicos e quânticos, gerenciando fluxo de dados e sincronização, abstraindo complexidade do hardware quântico e facilitando algoritmos híbridos como VQE e QAOA.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>VQE e QAOA: Algoritmos Híbridos Quântico-Clássicos</strong></p>
<p><strong>Variational Quantum Eigensolver (VQE)</strong> é um algoritmo híbrido projetado para encontrar o estado fundamental de sistemas quânticos, particularmente útil para simulação molecular e problemas de química quântica. <em>O VQE combina um circuito quântico parametrizado, executado em uma QPU, com um otimizador clássico que ajusta os parâmetros do circuito para minimizar a energia do sistema</em>. Esta abordagem permite que sistemas quânticos NISQ, apesar de suas limitações de ruído e profundidade de circuito, contribuam efetivamente para resolver problemas práticos.</p>
<p>O algoritmo opera em um ciclo iterativo: o <strong>processador quântico</strong> prepara estados candidatos usando circuitos parametrizados e mede o valor esperado de energia, enquanto o <strong>processador clássico</strong> utiliza algoritmos de otimização como gradiente descendente ou métodos evolutivos para ajustar os parâmetros e minimizar a função objetivo. Esta divisão de tarefas aproveita as forças de cada paradigma computacional: a capacidade quântica de explorar espaços de estados exponenciais e a robustez clássica para otimização numérica.</p>
<p><strong>Quantum Approximate Optimization Algorithm (QAOA)</strong> é um algoritmo híbrido especificamente desenvolvido para problemas de otimização combinatória, como o problema do corte máximo em grafos ou otimização de portfólios financeiros. <em>O QAOA utiliza uma sequência alternada de operadores quânticos: um Hamiltoniano de problema que codifica a função objetivo e um Hamiltoniano de mistura que explora o espaço de soluções</em>. Os parâmetros destes operadores são otimizados classicamente para maximizar a probabilidade de medir a solução ótima.</p>
<p>A estrutura do <strong>QAOA</strong> é parametrizada por sua profundidade <span class="math inline">\(p\)</span>, onde circuitos mais profundos teoricamente oferecem melhor aproximação da solução ótima, mas requerem maior fidelidade quântica. Para <span class="math inline">\(p=1\)</span>, o algoritmo reduz-se a uma heurística simples, enquanto no limite <span class="math inline">\(p \to \infty\)</span>, reproduz o algoritmo quântico adiabático ótimo.</p>
<p><strong>Importância para Sistemas Híbridos</strong>: ambos os algoritmos exemplificam o paradigma emergente de computação híbrida, onde <strong>QPUs</strong> atuam como coprocessadores especializados para exploração de espaços quânticos, enquanto <strong>CPUs/GPUs</strong> clássicas gerenciam otimização, pré-processamento e análise de resultados. Esta abordagem híbrida é fundamental para a era NISQ, permitindo que dispositivos quânticos imperfeitos contribuam para resolução de problemas práticos através da sinergia com recursos computacionais clássicos robustos.</p>
<p>Aplicações práticas incluem descoberta de fármacos (VQE para simulação molecular), otimização logística (QAOA para roteamento de veículos), e finanças quantitativas (ambos para otimização de portfólios e gestão de risco).</p>
</div>
</div>
<p>A <a href="#tbl-quantum1" class="quarto-xref">Table&nbsp;<span>2.7</span></a> mostra um resumo dos desafios associados a criação de <strong>Sistemas Operacionais</strong> para Computadores quânticos.</p>
<div id="tbl-quantum1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-quantum1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2.7: Desafios e tecnologias da criação de <strong>Sistemas Operacionais</strong> para computadores quânticos.
</figcaption>
<div aria-describedby="tbl-quantum1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Componente/Função do <strong>QCOS</strong></th>
<th style="text-align: left;">Descrição da Função</th>
<th style="text-align: left;">Desafios Associados</th>
<th style="text-align: left;">Tecnologias/Abordagens Relevantes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Gerenciamento de Qubits</strong></td>
<td style="text-align: left;">Inicialização, manipulação de estados quânticos (superposição, emaranhamento), medição precisa de qubits.</td>
<td style="text-align: left;">Manter a coerência dos qubits, controle preciso de operações quânticas, escalabilidade para grande número de qubits.</td>
<td style="text-align: left;">Pulsos de micro-ondas/laser, armadilhas de íons, <strong>qubits</strong> supercondutores, hardware de controle (FPGAs, RFSoCs).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Correção de Erros Quânticos/Mitigação de Ruído</strong></td>
<td style="text-align: left;">Identificar e corrigir/mitigar erros devido à decoerência e ruído para manter a integridade da computação.</td>
<td style="text-align: left;">Fragilidade dos estados quânticos, overhead de <strong>qubits</strong> e operações para QEC, complexidade dos códigos corretores.</td>
<td style="text-align: left;">Códigos de correção de erros quânticos (e.g., código de superfície), técnicas de mitigação de erros (e.g., Zero Noise Extrapolation).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Escalonamento e Otimização de Circuitos</strong></td>
<td style="text-align: left;">Agendar operações quânticas eficientemente, otimizar circuitos para reduzir profundidade/contagem de portas.</td>
<td style="text-align: left;">Limitações de conectividade entre qubits, tempos de coerência finitos, heterogeneidade de QPUs.</td>
<td style="text-align: left;">Compiladores quânticos, algoritmos de roteamento e mapeamento de qubits, técnicas de otimização de circuitos, multi-programação.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Interface/Abstração de Hardware</strong> (e.g., Qernel)</td>
<td style="text-align: left;">Fornecer uma interface de alto nível para programadores, abstraindo a complexidade do hardware quântico.</td>
<td style="text-align: left;">Diversidade de arquiteturas de hardware quântico, ocultar a natureza ruidosa do hardware.</td>
<td style="text-align: left;"><code>APIs</code>de programação quântica (e.g., Qiskit, Cirq), linguagens de descrição de circuitos, abstração Qernel.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Suporte a Modelos Híbridos</strong></td>
<td style="text-align: left;">Orquestrar a execução entre processadores clássicos e quânticos, gerenciar fluxo de dados e sincronização.</td>
<td style="text-align: left;">Latência na comunicação clássico-quântica, sincronização eficiente, desenvolvimento de algoritmos híbridos.</td>
<td style="text-align: left;">Algoritmos variacionais (VQE, QAOA), plataformas de computação híbrida (Ex.: Azure Quantum).</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<section id="exemplos-de-sistemas-operacionais-quânticos" class="level4" data-number="2.2.6.1">
<h4 data-number="2.2.6.1" class="anchored" data-anchor-id="exemplos-de-sistemas-operacionais-quânticos"><span class="header-section-number">2.2.6.1</span> Exemplos de <strong>Sistemas Operacionais Quânticos</strong></h4>
<p>Um <strong>QCOS</strong> gerencia recursos quânticos, como qubits, portas quânticas e circuitos, de forma análoga a como um <strong>Sistema Operacional</strong> clássico gerencia <code>CPU</code>, memória e <code>E/S</code>. O <code>Qernel</code>, componente central, orquestra a alocação de <strong>qubits</strong>, o escalonamento de operações quânticas e a mitigação de erros causados por decoerência e ruído, desafios inerentes aos processadores quânticos atuais. Ainda que eles se distinguam dos <strong>Sistemas Operacionais</strong> clássicos, a curiosa leitora deveria prestar atenção aos seguintes sistemas:</p>
<ol type="1">
<li><p><strong>Qiskit Runtime (IBM)</strong> O <a href="https://www.ibm.com/quantum/qiskit">Qiskit</a> Runtime é uma plataforma que atua como uma camada de abstração para gerenciar computação quântica em hardware da IBM, como o <a href="https://www.ibm.com/quantum/blog/127-qubit-quantum-processor-eagle">IBM Quantum Eagle</a> (127 qubits). Ele fornece uma interface para escalonar circuitos quânticos, otimizar alocação de <strong>qubits</strong> e executar algoritmos híbridos quântico-clássicos. Em 2025, espera-se que o <a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime">Qiskit Runtime</a> seja usado em aplicações como simulação de moléculas químicas e otimização logística, demonstrando a viabilidade de um <strong>QCOS</strong> ainda que seja rudimentar.</p></li>
<li><p><strong>Cirq e TensorFlow Quantum (Google)</strong> O <a href="https://quantumai.google/cirq">Cirq</a>, combinado com o <a href="https://www.tensorflow.org/quantum?hl=pt-br">TensorFlow Quantum</a>, forma um ecossistema para desenvolver e executar programas quânticos no hardware do Google, como o processador <a href="https://quantumai.google/quantumcomputer">Sycamore</a>. Essas ferramentas gerenciam a compilação de circuitos quânticos, a alocação de recursos e a integração com algoritmos de machine learning. Um exemplo prático é a simulação de sistemas quânticos em física de matéria condensada, onde o Cirq atua como uma interface de <strong>Sistema Operacional</strong> Quântico.</p></li>
<li><p><strong>SpinQ QOS</strong> A <a href="https://www.spinquanta.com/">SpinQ</a> Technology, uma empresa chinesa, lançou em 2025 um <strong>QOS</strong>, projetado para seus processadores quânticos de pequena escala (2-20 qubits). O <strong>QOS</strong> gerencia a inicialização de qubits, a execução de circuitos e a correção de erros em tempo real, com uma interface amigável para pesquisadores. Ele é usado em educação e pesquisa, permitindo experimentos com algoritmos como <a href="https://www.classiq.io/insights/shors-algorithm-explained">Shor</a> e <a href="https://learning.quantum.ibm.com/course/fundamentals-of-quantum-algorithms/grovers-algorithm">Grover</a> em hardware acessível.</p></li>
<li><p><strong>Orca Computing PT-1</strong> A <a href="https://orcacomputing.com/">Orca Computing</a> desenvolveu um <strong>Sistema Operacional</strong> Quântico para seu processador fotônico <a href="https://orcacomputing.com/orca-pt-1/">PT-1</a>, que opera com qubits baseados em fótons. Esse sistema gerencia a multiplexação temporal de qubits e a integração com sistemas clássicos, sendo aplicado em problemas de otimização em finanças e telecomunicações.</p></li>
<li><p><strong>D-Wave Ocean SDK</strong> O <a href="https://www.dwavequantum.com/solutions-and-products/ocean/">Ocean SDK</a> da <a href="https://www.dwavequantum.com/">D-Wave</a> é um <strong>Sistema Operacional</strong> Quântico híbrido que combina recozimento quântico com computação clássica. Ele permite a modelagem de problemas de otimização complexos, como roteamento de veículos e alocação de recursos, utilizando o processador quântico Advantage. O Ocean SDK gerencia a alocação de qubits, a execução de algoritmos quânticos e a integração com sistemas clássicos.</p></li>
</ol>
<p>Estes <strong>Sistemas Operacionais Quânticos</strong>, se já pudermos chamar assim, estão em estágios iniciais de desenvolvimento. Contudo, já demonstram a viabilidade de gerenciar recursos quânticos e executar algoritmos complexos:</p>
<ul>
<li><strong>Simulação Química</strong>: O Qiskit Runtime foi usado pela <a href="https://www.ddw-online.com/how-quantum-computing-is-revolutionising-drug-development-34423-202504/">Merck em 2025</a> para simular interações moleculares, reduzindo o tempo de desenvolvimento de novos fármacos.</li>
<li><strong>Otimização Logística</strong>: A D-Wave, com seu <strong>Sistema Operacional</strong> híbrido para recozimento quântico, otimizou rotas de entrega para <a href="https://www.dwavequantum.com/media/2sof3qhz/the-pattison-food-group_case_story_v8.pdf">empresas de hortifruti</a>, integrando recursos quânticos e clássicos.</li>
<li><strong>Criptografia</strong>: O <strong>QOS</strong> da <strong>SpinQ</strong> permitiu experimentos com algoritmos quânticos resistentes a ataques, como os baseados em reticulados, em <a href="https://arxiv.org/abs/2308.06736">laboratórios acadêmicos</a>. Em <a href="http://cjc.ict.ac.cn/online/onlinepaper/wc-202458160402.pdf">um artigo</a> publicado em maio de 2024 no <em>Chinese Journal of Computers</em>, pesquisadores da Universidade de Xangai detalharam avanços significativos na fatoração de inteiros utilizando o computador quântico de recozimento <strong>D-Wave Advantage</strong>. A pesquisa demonstrou essa capacidade através de duas abordagens distintas. Primeiramente, utilizando um método que converte o problema de fatoração <span class="math inline">\(N=pq\)</span> em um problema de otimização, a equipe conseguiu fatorar o inteiro de <strong>22 bits</strong> 2.269.753 . Em um feito mais notável, a equipe realizou a primeira fatoração de um inteiro de <strong>50 bits</strong> (845.546.611.823.483) em um sistema <strong>D-Wave</strong>. Nesta abordagem híbrida, o computador quântico não resolveu o problema inteiro diretamente, mas atuou como um acelerador para um algoritmo clássico. O recozimento quântico foi usado para otimizar a solução do <strong>P</strong>roblema do <strong>V</strong>etor <strong>M</strong>ais <strong>P</strong>róximo, <strong>CVP</strong>, encontrando um vetor mais próximo do que o algoritmo clássico de Babai conseguiria sozinho, graças ao efeito de tunelamento quântico. Este trabalho não representa uma “quebra” da criptografia RSA utilizada comercialmente, que usa chaves de <span class="math inline">\(2048\)</span> bits ou mais, mas demonstra uma capacidade de ataque realista para a tecnologia de recozimento quântico, que, segundo os autores, mostra um progresso mais estável para este tipo de problema do que os computadores quânticos universais.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>O Problema do Vetor Mais Próximo</strong></p>
<p>O Problema do Vetor Mais Próximo, em inglês <strong>C</strong>losest <strong>V</strong>ector <strong>P</strong>roblem*, é uma questão importante em matemática e ciência da computação. Para entender vamos ver uma analogia com um pomar:</p>
<ol type="1">
<li><strong>A Grade (Lattice)</strong>: imagine um pomar onde as árvores foram plantadas em uma grade perfeitamente regular. Cada árvore representa um ponto, vetor, nesta grade;</li>
<li><strong>O Vetor Alvo</strong>: agora, imagine que você joga uma bola para dentro do pomar. A bola cai em um local aleatório, que não é exatamente onde uma árvore está. A posição da bola é o seu <em>vetor alvo</em>;</li>
<li><strong>O Problema</strong>: o <strong>CVP</strong> é a pergunta: “Qual é a árvore mais próxima de onde a bola caiu?”</li>
</ol>
<p>Em termos simples, dado um conjunto de pontos que formam uma grade regular e um ponto alvo qualquer no espaço, o <strong>CVP</strong> consiste em encontrar o ponto da grade mais próximo do ponto alvo. Embora pareça fácil em duas dimensões, em centenas ou milhares de dimensões, como nos problemas de criptografia, encontrar a resposta exata é um problema <strong>NP-difícil</strong>, o que significa que é computacionalmente inviável para computadores clássicos resolverem de forma eficiente à medida que o problema cresce.</p>
<p><strong>O Algoritmo de Babai</strong></p>
<p>O Algoritmo de Babai é uma solução inteligente e prática para o <strong>CVP</strong>. Como resolver o <strong>CVP</strong> perfeitamente é muito difícil, o algoritmo de Babai não tenta encontrar a resposta <em>perfeita</em>, mas sim uma resposta “boa o suficiente” e muito próxima da ideal. O Algoritmo de Babai é um algoritmo de aproximação. Vamos voltar ao pomar, mas desta vez com um mapa sobre ele.</p>
<ol type="1">
<li><strong>O Problema do Pomar Inclinado</strong>: o seu pomar pode ter sido plantado com as fileiras de árvores um pouco inclinadas, dificultando o cálculo de distâncias. Essa é a “grade” original e complexa.</li>
<li><strong>O Algoritmo “Endireita” a Grade</strong>: o Algoritmo de Babai primeiro “endireita” a grade, transformando-a em uma grade perfeitamente perpendicular, ortogonal, como uma folha de papel quadriculado. Isso é feito usando um outro algoritmo, como o <strong>LLL</strong>.</li>
<li><strong>Encontrando o Ponto Mais Próximo no Mapa</strong>: com a grade agora “quadriculada” e fácil de usar, o algoritmo simplesmente arredonda as coordenadas da sua bola para encontrar o cruzamento mais próximo no papel quadriculado.</li>
<li><strong>A Solução Aproximada</strong>: esse ponto no papel corresponde a uma árvore específica no pomar original. Essa árvore é a solução que o Algoritmo de Babai fornece.</li>
</ol>
<p>Ela pode não ser a árvore <em>exatamente</em> mais próxima, mas é garantido que será uma das mais próximas, e o cálculo é imensamente mais rápido do que tentar medir a distância para todas as árvores do pomar.</p>
<p>Em resumo, o <strong>Algoritmo de Babai</strong> é uma ferramenta prática para encontrar uma solução “boa o suficiente” para o <strong>Problema do Vetor Mais Próximo</strong>, que de outra forma seria computacionalmente inviável de resolver perfeitamente. É por isso que os pesquisadores no artigo usaram o computador quântico para tentar melhorar a resposta “boa o suficiente” do algoritmo de Babai e encontrar uma solução ainda melhor.</p>
</div>
</div>
<p>O progresso na computação quântica ocorre por meio da interdependência entre hardware, software e algoritmos. Trata-se do nosso conhecido laço de realimentação positiva. Avanços no hardware quântico permitem <strong>QCOS</strong>s mais sofisticados, que por sua vez viabilizam algoritmos mais complexos, criando um ciclo de feedback positivo. Os <strong>Sistemas Operacionais Quânticos</strong> estão no nexo dessa coevolução, atuando como elemento unificador entre hardware e software algorítmico, sendo essenciais para democratizar o acesso e operacionalizar o potencial da computação quântica.</p>


</section>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>O pobre autor começou sua vida profissional em um velho mainframe IBM 360/30, com o OS/360 rodando Cobol, PL/1 e RPG. O sistema era tão antigo que o manual de operação era um livro, com mais de <span class="math inline">\(1.000\)</span> páginas, e o computador tinha apenas <span class="math inline">\(32 KB\)</span> de memória. Era o final dos anos 1970 poucos meses antes deste 360/30 ser descomissionado e substituído por um IBM 370/138 que, usando memória virtual chegava a <span class="math inline">\(16 MBytes\)</span> de memória. Imagine! Hoje, minha máquina está rodando <span class="math inline">\(118\)</span> processos em <span class="math inline">\(2 Gbytes\)</span> de memória apenas para editar o arquivo de textos que estou escrevendo.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>O pobre autor teve que comprar uma placa de expansão para rodar o CP/M no seu Apple II. A placa tinha um processador <a href="https://www.zilog.com/docs/z80/um0080.pdf">Zilog - Z80</a>, <span class="math inline">\(64 KB\)</span> de memória e um drive de disquete de <span class="math inline">\(5.25\)</span> polegadas. O CP/M rodava em modo texto, mas permitia o uso de programas como o <a href="https://en.wikipedia.org/wiki/WordStar">WordStar</a> e o <a href="https://en.wikipedia.org/wiki/DBase">dBase II</a>, que eram muito populares na época. O <strong>CP/M</strong> foi um dos primeiros <strong>Sistemas Operacionais</strong> a permitir a execução de múltiplos programas simultaneamente, embora não fosse multitarefa no sentido moderno. Mais importante, eu tinha, em casa, à disposição, uma máquina que podia ser programada na <strong>Linguagem C</strong>. Finalmente me livrando do Basic infernal do Apple II.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Há aqui uma outra curiosidade. A pedido do meu diretor imediato que atendia uma solicitação do presidente da empresa, este pobre autor foi levado, em março de 1981 se não me falha a memória, a atender um dentista. O <a href="https://www.odontologiafaissol.com.br/historia.html">Dr.&nbsp;Olympio Faissal Pinto</a>. O objetivo era ajudar o bom Dr.&nbsp;a criar uma conexão via modem com um computador de uma universidade em Miami, na Flórida. O Dr.&nbsp;Olympio queria enviar para uma universidade na Califórnia a foto de um dente. A máquina era um TRS-80 modelo III rodando o TRS-DOS e o CP/M. O modem era um Radio Shack Modem I, com velocidade de <span class="math inline">\(300 bps\)</span>. A conexão era feita por uma linha telefônica analógica. A imagem digitalizada tinha resolução de <span class="math inline">\(640X480\)</span>. E, dada a complexidade de modens, placas de captura e protocolos, o Dr.&nbsp;precisava de ajuda. Passamos <span class="math inline">\(4\)</span> horas resolvendo problemas e mais algumas horas enviando. Este pobre autor não tem como provar, mas tem a esperança que esta tenha sido a primeira conexão internet do Brasil. O computador do Dr.&nbsp;acessou a internet usando o computador de Miami como <em>gateway</em>. Para o Dr.&nbsp;deve ter sido algo comum, mas o jovem técnico, nunca esqueceu essa tarde. Mesmo, devo admitir, sem ter a menor ideia que o que estávamos conectando era a internet.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Este, o pobre autor, rodava <strong>MS-DOS</strong> em um PC-386, com co-processador matemático, comprado em consórcio e construído pela Cobra Informática, uma empresa brasileira que importava componentes e montava computadores pessoais no Brasil. O <strong>MS-DOS</strong> era o <strong>Sistema Operacional</strong> padrão para PCs compatíveis com <strong>IBM PC</strong>, e eu o utilizava para rodar programas como o WordPerfect e o Lotus 1-2-3. Usava o Borland C++ para programar usando a <strong>Linguagem C++</strong>, e o Borland Turbo Pascal para programar em Pascal. mas este último só para atender eventuais clientes ou como forma de autopunição.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./index.html" class="pagination-link" aria-label="Apresentação">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./intro1.html" class="pagination-link" aria-label="Sistemas Operacionais: Equilibrando Recursos e Simplicidade">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Sistemas Operacionais: Equilibrando Recursos e Simplicidade</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linefollower/edit/main/intro.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linefollower/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>