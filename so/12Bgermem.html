<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sistemas Operacionais - 18&nbsp; Algoritmos de Substituição de Páginas: A Arte de Escolher a Vítima</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./12Zgermem.html" rel="next">
<link href="./12Agermem.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/styles.css">
<meta property="og:title" content="Sistemas Operacionais - 18&nbsp; Algoritmos de Substituição de Páginas: A Arte de Escolher a Vítima">
<meta property="og:description" content="">
<meta property="og:site_name" content="Sistemas Operacionais">
<meta name="twitter:title" content="Sistemas Operacionais - 18&nbsp; Algoritmos de Substituição de Páginas: A Arte de Escolher a Vítima">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./12germem.html">Gestão de Memória</a></li><li class="breadcrumb-item"><a href="./12Bgermem.html"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Algoritmos de Substituição de Páginas: A Arte de Escolher a Vítima</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Sistemas Operacionais</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Introdução</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Sistemas Operacionais: Equilibrando Recursos e Simplicidade</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Exercícios</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pr-guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Guia Completo de <em>pull request</em> em Repositório de Terceiros</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./commit-guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">A Arte da Mensagem de <em>commit</em>: Um Guia para Históricos Inteligíveis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./topo-guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">A Topologia do Fluxo de Trabalho em Git: Estratégias para Colaboração em Equipe</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Gestão de Processos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Gerenciamento de Processos: Introdução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Criando Processos de Forma Programática</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Processos de Sistema: Linux vs.&nbsp;Windows</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Controle de Processos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Agendamento de Tarefas e Escalonamento</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Atividades Práticas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Gestão de Memória</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12germem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Hierarquia de Memória: Fundamentos e Necessidade</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12Agermem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">A Arquitetura da Ilusão: Um Mergulho Profundo no Gerenciamento de Memória Virtual</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12Bgermem.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Algoritmos de Substituição de Páginas: A Arte de Escolher a Vítima</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12Zgermem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Gestão de Memória - Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13gerfiles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Gestão de Arquivos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14geres.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Gestão de Entrada/Saída</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15gerredes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Gestão de Conectividade e Comunicação</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16gerseg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Segurança</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2arqui.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Arquiteturas de Sistemas Operacionais: Estruturando a Complexidade</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3heterox.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Tendências Avançadas em Sistemas Operacionais</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18glossa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Glossário - Sistemas Operacionais: Fundamentos e Evolução</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19exerc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Exercícios Resolvidos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#o-problema-fundamental-e-suas-métricas" id="toc-o-problema-fundamental-e-suas-métricas" class="nav-link active" data-scroll-target="#o-problema-fundamental-e-suas-métricas"><span class="header-section-number">18.1</span> O Problema Fundamental e suas Métricas</a></li>
  <li><a href="#fifo-first-in-first-out-simplicidade-e-suas-armadilhas" id="toc-fifo-first-in-first-out-simplicidade-e-suas-armadilhas" class="nav-link" data-scroll-target="#fifo-first-in-first-out-simplicidade-e-suas-armadilhas"><span class="header-section-number">18.2</span> FIFO (First In, First Out): Simplicidade e suas Armadilhas</a>
  <ul class="collapse">
  <li><a href="#implementação-e-funcionamento" id="toc-implementação-e-funcionamento" class="nav-link" data-scroll-target="#implementação-e-funcionamento"><span class="header-section-number">18.2.1</span> Implementação e Funcionamento</a></li>
  <li><a href="#exemplo-prático" id="toc-exemplo-prático" class="nav-link" data-scroll-target="#exemplo-prático"><span class="header-section-number">18.2.2</span> Exemplo Prático</a></li>
  <li><a href="#a-anomalia-de-belady" id="toc-a-anomalia-de-belady" class="nav-link" data-scroll-target="#a-anomalia-de-belady"><span class="header-section-number">18.2.3</span> A Anomalia de Belady</a></li>
  </ul></li>
  <li><a href="#algoritmo-ótimo-optmin-o-padrão-impossível" id="toc-algoritmo-ótimo-optmin-o-padrão-impossível" class="nav-link" data-scroll-target="#algoritmo-ótimo-optmin-o-padrão-impossível"><span class="header-section-number">18.3</span> Algoritmo Ótimo (OPT/MIN): O Padrão Impossível</a>
  <ul class="collapse">
  <li><a href="#funcionamento-teórico" id="toc-funcionamento-teórico" class="nav-link" data-scroll-target="#funcionamento-teórico"><span class="header-section-number">18.3.1</span> Funcionamento Teórico</a></li>
  <li><a href="#exemplo-demonstrativo" id="toc-exemplo-demonstrativo" class="nav-link" data-scroll-target="#exemplo-demonstrativo"><span class="header-section-number">18.3.2</span> Exemplo Demonstrativo</a></li>
  <li><a href="#limitações-práticas" id="toc-limitações-práticas" class="nav-link" data-scroll-target="#limitações-práticas"><span class="header-section-number">18.3.3</span> Limitações Práticas</a></li>
  </ul></li>
  <li><a href="#lru-least-recently-used-aproximando-o-ótimo" id="toc-lru-least-recently-used-aproximando-o-ótimo" class="nav-link" data-scroll-target="#lru-least-recently-used-aproximando-o-ótimo"><span class="header-section-number">18.4</span> LRU (Least Recently Used): Aproximando o Ótimo</a>
  <ul class="collapse">
  <li><a href="#princípio-fundamental" id="toc-princípio-fundamental" class="nav-link" data-scroll-target="#princípio-fundamental"><span class="header-section-number">18.4.1</span> Princípio Fundamental</a></li>
  <li><a href="#implementações-práticas" id="toc-implementações-práticas" class="nav-link" data-scroll-target="#implementações-práticas"><span class="header-section-number">18.4.2</span> Implementações Práticas</a></li>
  <li><a href="#exemplo-detalhado" id="toc-exemplo-detalhado" class="nav-link" data-scroll-target="#exemplo-detalhado"><span class="header-section-number">18.4.3</span> Exemplo Detalhado</a></li>
  <li><a href="#propriedades-do-lru" id="toc-propriedades-do-lru" class="nav-link" data-scroll-target="#propriedades-do-lru"><span class="header-section-number">18.4.4</span> Propriedades do LRU</a></li>
  </ul></li>
  <li><a href="#algoritmo-do-relógio-clocksecond-chance" id="toc-algoritmo-do-relógio-clocksecond-chance" class="nav-link" data-scroll-target="#algoritmo-do-relógio-clocksecond-chance"><span class="header-section-number">18.5</span> Algoritmo do Relógio (Clock/Second Chance)</a>
  <ul class="collapse">
  <li><a href="#estrutura-e-funcionamento" id="toc-estrutura-e-funcionamento" class="nav-link" data-scroll-target="#estrutura-e-funcionamento"><span class="header-section-number">18.5.1</span> Estrutura e Funcionamento</a></li>
  <li><a href="#análise-do-comportamento" id="toc-análise-do-comportamento" class="nav-link" data-scroll-target="#análise-do-comportamento"><span class="header-section-number">18.5.2</span> Análise do Comportamento</a></li>
  <li><a href="#exemplo-ilustrativo" id="toc-exemplo-ilustrativo" class="nav-link" data-scroll-target="#exemplo-ilustrativo"><span class="header-section-number">18.5.3</span> Exemplo Ilustrativo</a></li>
  <li><a href="#variações-e-melhorias-do-algoritmo-relógio" id="toc-variações-e-melhorias-do-algoritmo-relógio" class="nav-link" data-scroll-target="#variações-e-melhorias-do-algoritmo-relógio"><span class="header-section-number">18.5.4</span> Variações e Melhorias do Algoritmo Relógio</a></li>
  </ul></li>
  <li><a href="#working-set-model-teoria-da-localidade" id="toc-working-set-model-teoria-da-localidade" class="nav-link" data-scroll-target="#working-set-model-teoria-da-localidade"><span class="header-section-number">18.6</span> Working Set Model: Teoria da Localidade</a>
  <ul class="collapse">
  <li><a href="#definição-formal" id="toc-definição-formal" class="nav-link" data-scroll-target="#definição-formal"><span class="header-section-number">18.6.1</span> Definição Formal</a></li>
  <li><a href="#princípios-operacionais" id="toc-princípios-operacionais" class="nav-link" data-scroll-target="#princípios-operacionais"><span class="header-section-number">18.6.2</span> Princípios Operacionais</a></li>
  <li><a href="#implementação-prática" id="toc-implementação-prática" class="nav-link" data-scroll-target="#implementação-prática"><span class="header-section-number">18.6.3</span> Implementação Prática</a></li>
  <li><a href="#limitações-e-desafios" id="toc-limitações-e-desafios" class="nav-link" data-scroll-target="#limitações-e-desafios"><span class="header-section-number">18.6.4</span> Limitações e Desafios</a></li>
  </ul></li>
  <li><a href="#wsclock-síntese-prática" id="toc-wsclock-síntese-prática" class="nav-link" data-scroll-target="#wsclock-síntese-prática"><span class="header-section-number">18.7</span> WSClock: Síntese Prática</a>
  <ul class="collapse">
  <li><a href="#funcionamento-híbrido" id="toc-funcionamento-híbrido" class="nav-link" data-scroll-target="#funcionamento-híbrido"><span class="header-section-number">18.7.1</span> Funcionamento Híbrido</a></li>
  <li><a href="#vantagens-integradas" id="toc-vantagens-integradas" class="nav-link" data-scroll-target="#vantagens-integradas"><span class="header-section-number">18.7.2</span> Vantagens Integradas</a></li>
  </ul></li>
  <li><a href="#algoritmos-de-aging-refinamento-temporal" id="toc-algoritmos-de-aging-refinamento-temporal" class="nav-link" data-scroll-target="#algoritmos-de-aging-refinamento-temporal"><span class="header-section-number">18.8</span> Algoritmos de <em>aging</em>: Refinamento Temporal</a>
  <ul class="collapse">
  <li><a href="#implementação-básica" id="toc-implementação-básica" class="nav-link" data-scroll-target="#implementação-básica"><span class="header-section-number">18.8.1</span> Implementação Básica</a></li>
  <li><a href="#análise-temporal" id="toc-análise-temporal" class="nav-link" data-scroll-target="#análise-temporal"><span class="header-section-number">18.8.2</span> Análise Temporal</a></li>
  <li><a href="#variações-e-otimizações" id="toc-variações-e-otimizações" class="nav-link" data-scroll-target="#variações-e-otimizações"><span class="header-section-number">18.8.3</span> Variações e Otimizações</a></li>
  </ul></li>
  <li><a href="#análise-comparativa-e-trade-offs" id="toc-análise-comparativa-e-trade-offs" class="nav-link" data-scroll-target="#análise-comparativa-e-trade-offs"><span class="header-section-number">18.9</span> Análise Comparativa e Trade-offs</a>
  <ul class="collapse">
  <li><a href="#complexidade-computacional" id="toc-complexidade-computacional" class="nav-link" data-scroll-target="#complexidade-computacional"><span class="header-section-number">18.9.1</span> Complexidade Computacional</a></li>
  <li><a href="#desempenho-relativo" id="toc-desempenho-relativo" class="nav-link" data-scroll-target="#desempenho-relativo"><span class="header-section-number">18.9.2</span> Desempenho Relativo</a></li>
  <li><a href="#implementação-em-sistemas-reais" id="toc-implementação-em-sistemas-reais" class="nav-link" data-scroll-target="#implementação-em-sistemas-reais"><span class="header-section-number">18.9.3</span> Implementação em Sistemas Reais</a></li>
  </ul></li>
  <li><a href="#substituição-de-páginas-no-kernel-linux-moderno-o-lru-multi-geracional" id="toc-substituição-de-páginas-no-kernel-linux-moderno-o-lru-multi-geracional" class="nav-link" data-scroll-target="#substituição-de-páginas-no-kernel-linux-moderno-o-lru-multi-geracional"><span class="header-section-number">18.10</span> Substituição de Páginas no <code>kernel</code> Linux Moderno: O LRU Multi-Geracional</a>
  <ul class="collapse">
  <li><a href="#evolução-arquitetônica-do-split-lru-ao-mglru" id="toc-evolução-arquitetônica-do-split-lru-ao-mglru" class="nav-link" data-scroll-target="#evolução-arquitetônica-do-split-lru-ao-mglru"><span class="header-section-number">18.10.1</span> Evolução Arquitetônica: Do Split-LRU ao MGLRU</a></li>
  <li><a href="#análise-profunda-do-framework-mglru" id="toc-análise-profunda-do-framework-mglru" class="nav-link" data-scroll-target="#análise-profunda-do-framework-mglru"><span class="header-section-number">18.10.2</span> <strong>1. Análise Profunda do Framework </strong>MGLRU****</a></li>
  <li><a href="#o-processo-de-envelhecimento-e-remoção-do-mglru" id="toc-o-processo-de-envelhecimento-e-remoção-do-mglru" class="nav-link" data-scroll-target="#o-processo-de-envelhecimento-e-remoção-do-mglru"><span class="header-section-number">18.10.3</span> <strong>1. O Processo de Envelhecimento e Remoção do </strong>MGLRU****</a></li>
  <li><a href="#daemons-do-sistema-e-ajustabilidade-o-papel-do-kswapd" id="toc-daemons-do-sistema-e-ajustabilidade-o-papel-do-kswapd" class="nav-link" data-scroll-target="#daemons-do-sistema-e-ajustabilidade-o-papel-do-kswapd"><span class="header-section-number">18.10.4</span> <strong>1. Daemons do Sistema e Ajustabilidade: O Papel do <code>kswapd</code></strong></a></li>
  </ul></li>
  <li><a href="#secção-2-substituição-de-páginas-no-windows-11-o-modelo-do-conjunto-de-trabalho" id="toc-secção-2-substituição-de-páginas-no-windows-11-o-modelo-do-conjunto-de-trabalho" class="nav-link" data-scroll-target="#secção-2-substituição-de-páginas-no-windows-11-o-modelo-do-conjunto-de-trabalho"><span class="header-section-number">18.11</span> <strong>Secção 2: Substituição de Páginas no Windows 11: O Modelo do Conjunto de Trabalho</strong></a>
  <ul class="collapse">
  <li><a href="#a-primazia-do-conjunto-de-trabalho-do-processo" id="toc-a-primazia-do-conjunto-de-trabalho-do-processo" class="nav-link" data-scroll-target="#a-primazia-do-conjunto-de-trabalho-do-processo"><span class="header-section-number">18.11.1</span> <strong>2. A Primazia do Conjunto de Trabalho do Processo</strong></a></li>
  <li><a href="#o-ciclo-de-vida-da-página-uma-viagem-pelas-listas-de-páginas" id="toc-o-ciclo-de-vida-da-página-uma-viagem-pelas-listas-de-páginas" class="nav-link" data-scroll-target="#o-ciclo-de-vida-da-página-uma-viagem-pelas-listas-de-páginas"><span class="header-section-number">18.11.2</span> <strong>2. O Ciclo de Vida da Página: Uma Viagem Pelas Listas de Páginas</strong></a></li>
  <li><a href="#o-gestor-do-conjunto-de-trabalho-e-a-lógica-de-corte" id="toc-o-gestor-do-conjunto-de-trabalho-e-a-lógica-de-corte" class="nav-link" data-scroll-target="#o-gestor-do-conjunto-de-trabalho-e-a-lógica-de-corte"><span class="header-section-number">18.11.3</span> <strong>2. O Gestor do Conjunto de Trabalho e a Lógica de Corte</strong></a></li>
  <li><a href="#gerenciamento-proativa-e-cache-superfetch-e-a-lista-de-espera" id="toc-gerenciamento-proativa-e-cache-superfetch-e-a-lista-de-espera" class="nav-link" data-scroll-target="#gerenciamento-proativa-e-cache-superfetch-e-a-lista-de-espera"><span class="header-section-number">18.11.4</span> <strong>2. Gerenciamento Proativa e Cache: SuperFetch e a Lista de Espera</strong></a></li>
  </ul></li>
  <li><a href="#análise-comparativa-e-implicações-de-desempenho" id="toc-análise-comparativa-e-implicações-de-desempenho" class="nav-link" data-scroll-target="#análise-comparativa-e-implicações-de-desempenho"><span class="header-section-number">18.12</span> Análise Comparativa e Implicações de Desempenho</a>
  <ul class="collapse">
  <li><a href="#filosofia-algorítmica-recuperação-local-vs.-global" id="toc-filosofia-algorítmica-recuperação-local-vs.-global" class="nav-link" data-scroll-target="#filosofia-algorítmica-recuperação-local-vs.-global"><span class="header-section-number">18.12.1</span> <strong>3. Filosofia Algorítmica: Recuperação Local vs.&nbsp;Global</strong></a></li>
  <li><a href="#implementação-complexidade-e-custo" id="toc-implementação-complexidade-e-custo" class="nav-link" data-scroll-target="#implementação-complexidade-e-custo"><span class="header-section-number">18.12.2</span> <strong>3. Implementação, Complexidade e Custo</strong></a></li>
  <li><a href="#observabilidade-diagnóstico-e-ajuste" id="toc-observabilidade-diagnóstico-e-ajuste" class="nav-link" data-scroll-target="#observabilidade-diagnóstico-e-ajuste"><span class="header-section-number">18.12.3</span> <strong>3. Observabilidade, Diagnóstico e Ajuste</strong></a></li>
  </ul></li>
  <li><a href="#secção-4-o-futuro-da-substituição-de-páginas-adaptação-a-novos-paradigmas" id="toc-secção-4-o-futuro-da-substituição-de-páginas-adaptação-a-novos-paradigmas" class="nav-link" data-scroll-target="#secção-4-o-futuro-da-substituição-de-páginas-adaptação-a-novos-paradigmas"><span class="header-section-number">18.13</span> <strong>Secção 4: O Futuro da Substituição de Páginas: Adaptação a Novos Paradigmas</strong></a>
  <ul class="collapse">
  <li><a href="#a-influência-do-hardware-moderno-memória-em-camadas" id="toc-a-influência-do-hardware-moderno-memória-em-camadas" class="nav-link" data-scroll-target="#a-influência-do-hardware-moderno-memória-em-camadas"><span class="header-section-number">18.13.1</span> <strong>4. A Influência do Hardware Moderno: Memória em Camadas</strong></a></li>
  <li><a href="#o-amanhecer-dos-algoritmos-aprendidos" id="toc-o-amanhecer-dos-algoritmos-aprendidos" class="nav-link" data-scroll-target="#o-amanhecer-dos-algoritmos-aprendidos"><span class="header-section-number">18.13.2</span> <strong>4. O Amanhecer dos Algoritmos Aprendidos</strong></a></li>
  </ul></li>
  <li><a href="#conclusão-sintetizando-duas-décadas-de-evolução-algorítmica" id="toc-conclusão-sintetizando-duas-décadas-de-evolução-algorítmica" class="nav-link" data-scroll-target="#conclusão-sintetizando-duas-décadas-de-evolução-algorítmica"><span class="header-section-number">18.14</span> <strong>Conclusão: Sintetizando Duas Décadas de Evolução Algorítmica</strong></a>
  <ul class="collapse">
  <li><a href="#métricas-primárias" id="toc-métricas-primárias" class="nav-link" data-scroll-target="#métricas-primárias"><span class="header-section-number">18.14.1</span> Métricas Primárias</a></li>
  <li><a href="#métricas-secundárias" id="toc-métricas-secundárias" class="nav-link" data-scroll-target="#métricas-secundárias"><span class="header-section-number">18.14.2</span> Métricas Secundárias</a></li>
  <li><a href="#metodologia-de-avaliação" id="toc-metodologia-de-avaliação" class="nav-link" data-scroll-target="#metodologia-de-avaliação"><span class="header-section-number">18.14.3</span> Metodologia de Avaliação</a></li>
  <li><a href="#tendências-emergentes" id="toc-tendências-emergentes" class="nav-link" data-scroll-target="#tendências-emergentes"><span class="header-section-number">18.14.4</span> Tendências Emergentes</a></li>
  <li><a href="#recomendações-práticas" id="toc-recomendações-práticas" class="nav-link" data-scroll-target="#recomendações-práticas"><span class="header-section-number">18.14.5</span> Recomendações Práticas</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/edit/main/12Bgermem.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./12germem.html">Gestão de Memória</a></li><li class="breadcrumb-item"><a href="./12Bgermem.html"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Algoritmos de Substituição de Páginas: A Arte de Escolher a Vítima</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Algoritmos de Substituição de Páginas: A Arte de Escolher a Vítima</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Quando um sistema operacional implementa memória virtual através de paginação, inevitavelmente surge um problema: <em>que página remover da memória física quando não há quadros livres disponíveis?</em> Esta decisão, aparentemente simples, pode determinar a diferença entre um sistema responsivo e um sistema que rasteja sob o peso de constantes acessos ao disco. Os algoritmos de substituição de páginas representam o coração desta decisão crítica, equilibrando princípios teóricos com limitações práticas de implementação.</p>
<p>O problema da substituição de páginas surge naturalmente do modelo de paginação sob demanda. Quando um processo gera uma falha de página, <em>page fault</em> e todos os quadros físicos estão ocupados, o sistema operacional deve selecionar uma página <em>vítima</em> para ser removida, liberando espaço para a nova página. A escolha da vítima impacta diretamente o desempenho futuro: uma escolha inadequada pode resultar na remoção de uma página que será acessada novamente em breve, causando outra falta de página desnecessária.</p>
<section id="o-problema-fundamental-e-suas-métricas" class="level2" data-number="18.1">
<h2 data-number="18.1" class="anchored" data-anchor-id="o-problema-fundamental-e-suas-métricas"><span class="header-section-number">18.1</span> O Problema Fundamental e suas Métricas</h2>
<p>O objetivo de qualquer algoritmo de substituição é <strong>minimizar o número total de faltas de página</strong> durante a execução de um programa ou conjunto de programas. Esta métrica, conhecida como <em>page fault rate</em>, determina diretamente quantas operações custosas de entrada/saída serão necessárias.</p>
<p>Para analisar algoritmos de substituição, utilizamos o conceito de <strong><em>string</em> de referência</strong>, uma sequência temporal de números de páginas virtuais acessados por um processo. Por exemplo, a <em>string</em> <code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code> representa um processo que acessa páginas nesta ordem específica.</p>
<p>Dado um número fixo de quadros físicos disponíveis para um processo, diferentes algoritmos produzirão diferentes números de falhas de página para a mesma <em>string</em> de referência. O algoritmo ideal seria aquele que sempre minimiza este número, mas como veremos, este <em>algoritmo ótimo</em> só é possível quando conhecemos todo o futuro da execução.</p>
</section>
<section id="fifo-first-in-first-out-simplicidade-e-suas-armadilhas" class="level2" data-number="18.2">
<h2 data-number="18.2" class="anchored" data-anchor-id="fifo-first-in-first-out-simplicidade-e-suas-armadilhas"><span class="header-section-number">18.2</span> FIFO (First In, First Out): Simplicidade e suas Armadilhas</h2>
<p>O algoritmo <strong>F</strong>irst <strong>I</strong>n, <strong>F</strong>irst <strong>O</strong>ut, <strong>FIFO</strong>, representa a abordagem mais intuitiva para substituição de páginas: <em>remover sempre a página que está há mais tempo na memória</em>. Implementado através de uma fila circular, o <strong>FIFO</strong> mantém controle sobre a ordem de chegada das páginas sem necessidade de informações sobre padrões de acesso.</p>
<section id="implementação-e-funcionamento" class="level3" data-number="18.2.1">
<h3 data-number="18.2.1" class="anchored" data-anchor-id="implementação-e-funcionamento"><span class="header-section-number">18.2.1</span> Implementação e Funcionamento</h3>
<p>A implementação do FIFO requer apenas uma estrutura de dados simples:</p>
<pre class="shell"><code>Estrutura FIFO:
- Fila circular de quadros
- Ponteiro para o próximo quadro a ser substituído
- Contador de quadros ocupados</code></pre>
<p>O algoritmo opera da seguinte forma:</p>
<ol type="1">
<li><strong>Acesso à página</strong>: Verificar se a página está na memória</li>
<li><strong>Se presente</strong>: Continuar execução (hit)</li>
<li><strong>Se ausente e há quadro livre</strong>: Carregar página no próximo quadro livre</li>
<li><strong>Se ausente e memória cheia</strong>:
<ul>
<li>Selecionar vítima usando ponteiro FIFO</li>
<li>Se página vítima está suja (<em>dirty</em>), salvá-la no disco</li>
<li>Carregar nova página no quadro liberado</li>
<li>Avançar ponteiro FIFO</li>
</ul></li>
</ol>
</section>
<section id="exemplo-prático" class="level3" data-number="18.2.2">
<h3 data-number="18.2.2" class="anchored" data-anchor-id="exemplo-prático"><span class="header-section-number">18.2.2</span> Exemplo Prático</h3>
<p>Considere a <em>string</em> de referência <code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</code> com 3 quadros disponíveis:</p>
<pre class="shell"><code>Página | Quadros    | Resultado
   7   | [7, -, -]  | MISS
   0   | [7, 0, -]  | MISS  
   1   | [7, 0, 1]  | MISS
   2   | [2, 0, 1]  | MISS (remove 7)
   0   | [2, 0, 1]  | HIT
   3   | [2, 3, 1]  | MISS (remove 0)
   0   | [2, 3, 0]  | MISS (remove 1)
   4   | [4, 3, 0]  | MISS (remove 2)
   2   | [4, 2, 0]  | MISS (remove 3)
   3   | [4, 2, 3]  | MISS (remove 0)
   ...</code></pre>
<p>O algoritmo FIFO resulta em 15 faltas de página para esta <em>string</em> com 3 quadros. Também podemos criar um código em C++ 23 para simular este comportamento. O fragmento de código abaixo ilustra a função de acesso à página dentro de uma classe <code>FifoPageManager</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> FifoPageManager<span class="op">::</span>accessPage<span class="op">(</span>DWORD page_number<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Verifica se a página está na memória (HIT)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>page_table<span class="op">.</span>contains<span class="op">(</span>page_number<span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        hits<span class="op">++;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Caso contrário, é uma falha de página (MISS)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    page_faults<span class="op">++;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Se há quadro livre, aloca a página</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>page_table<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> num_frames<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        SIZE_T free_frame_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                free_frame_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        frames<span class="op">[</span>free_frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> free_frame_index<span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        fifo_queue<span class="op">.</span>push<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Se memória cheia, remove a página mais antiga (FIFO)</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        DWORD victim_page <span class="op">=</span> fifo_queue<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        fifo_queue<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        SIZE_T frame_index_to_replace <span class="op">=</span> page_table<span class="op">.</span>at<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        frames<span class="op">[</span>frame_index_to_replace<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> frame_index_to_replace<span class="op">;</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        fifo_queue<span class="op">.</span>push<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O método <code>accessPage</code> encapsula a essência do algoritmo <strong>FIFO</strong>, que substitui a página mais antiga quando a memória está cheia. Abaixo, uma análise detalhada de cada etapa:</p>
<ol type="1">
<li><p><strong>Verificação de Acerto (Hit)</strong>:</p>
<ul>
<li><strong>Código</strong>: <code>if (page_table.contains(page_number)) { hits++; return; }</code>;</li>
<li><strong>Funcionamento</strong>: verifica se a página solicitada está na memória usando uma tabela de páginas (<code>page_table</code>, implementada como <code>unordered_map</code>). Se presente, incrementa o contador de acertos (<code>hits</code>) e retorna;</li>
<li><strong>Análise</strong>: a busca na <code>page_table</code> tem complexidade <span class="math inline">\(O(1)\)</span> em média, garantindo eficiência. O algoritmo <strong>FIFO</strong> não reordena páginas em acertos, mantendo sua simplicidade.</li>
</ul></li>
<li><p><strong>Registro de Falha (Miss)</strong>:</p>
<ul>
<li><strong>Código</strong>: <code>page_faults++;</code>;</li>
<li><strong>Funcionamento</strong>: se a página não está na memória, registra uma falha de página (<code>page_faults</code>);</li>
<li><strong>Análise</strong>: este passo é importante para rastrear o desempenho do algoritmo, permitindo calcular a taxa de acertos posteriormente.</li>
</ul></li>
<li><p><strong>Alocação em Quadro Livre</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>page_table<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> num_frames<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    SIZE_T free_frame_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            free_frame_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    frames<span class="op">[</span>free_frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> free_frame_index<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    fifo_queue<span class="op">.</span>push<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: se há quadros livres, ou seja, menos páginas que o número total de quadros, <code>num_frames</code>, encontra o primeiro quadro vazio, aloca a nova página, atualiza a <code>page_table</code> e adiciona a página à fila <strong>FIFO</strong> (<code>fifo_queue</code>).</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca linear por um quadro livre tem complexidade <span class="math inline">\(O(n)\)</span>, onde <code>n</code> é o número de quadros. Isto poderia ser otimizado com uma lista de quadros livres;</li>
<li>O uso de <code>std::optional</code> para representar quadros vazios é uma escolha moderna e segura;</li>
<li>A adição à <code>fifo_queue</code> mantém a ordem de entrada, essencial para a política <strong>FIFO</strong>.</li>
</ul></li>
</ul></li>
<li><p><strong>Substituição de Página (Memória Cheia)</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    DWORD victim_page <span class="op">=</span> fifo_queue<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    fifo_queue<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    SIZE_T frame_index_to_replace <span class="op">=</span> page_table<span class="op">.</span>at<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    frames<span class="op">[</span>frame_index_to_replace<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> frame_index_to_replace<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    fifo_queue<span class="op">.</span>push<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: Quando a memória está cheia, remove a página mais antiga (primeira da <code>fifo_queue</code>), libera seu quadro, insere a nova página no mesmo quadro e atualiza as estruturas de dados.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A escolha da vítima é <span class="math inline">\(O(1)\)</span> devido à <code>std::queue</code>, ideal para <strong>FIFO</strong>;</li>
<li>Atualizações na <code>page_table</code> são <span class="math inline">\(O(1)\)</span> em média, garantindo eficiência;</li>
<li>A substituição ignora a frequência de uso, o que pode levar a ineficiências (ex.:, a anomalia de Belady).</li>
</ul></li>
</ul></li>
</ol>
</section>
<section id="a-anomalia-de-belady" class="level3" data-number="18.2.3">
<h3 data-number="18.2.3" class="anchored" data-anchor-id="a-anomalia-de-belady"><span class="header-section-number">18.2.3</span> A Anomalia de Belady</h3>
<p>O algoritmo <strong>FIFO</strong> apresenta uma característica contraintuitiva descoberta por <a href="https://en.wikipedia.org/wiki/L%C3%A1szl%C3%B3_B%C3%A9l%C3%A1dy">László Belady</a> em 1969: <strong>aumentar o número de quadros pode paradoxalmente aumentar o número de faltas de página</strong>. Esta anomalia viola a expectativa natural de que mais memória sempre resulta em melhor desempenho.</p>
<p><strong>Exemplo da Anomalia</strong>: <em>string</em>: <code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code></p>
<p>Com <span class="math inline">\(3\)</span> quadros: <span class="math inline">\(9\)</span> faltas de página. Com <span class="math inline">\(4\)</span> quadros: <span class="math inline">\(10\)</span> faltas de página.</p>
<p>Esta anomalia ocorre porque o <strong>FIFO</strong> não considera padrões de localidade temporal, podendo remover páginas que serão acessadas novamente em breve.</p>
</section>
</section>
<section id="algoritmo-ótimo-optmin-o-padrão-impossível" class="level2" data-number="18.3">
<h2 data-number="18.3" class="anchored" data-anchor-id="algoritmo-ótimo-optmin-o-padrão-impossível"><span class="header-section-number">18.3</span> Algoritmo Ótimo (OPT/MIN): O Padrão Impossível</h2>
<p>Desenvolvido por László Belady em 1966, o <strong>algoritmo ótimo</strong> fornece a referência teórica para todos os outros algoritmos. Sua regra é elegantemente simples: <em>sempre remover a página que será acessada mais distante no futuro, ou nunca mais</em>.</p>
<section id="funcionamento-teórico" class="level3" data-number="18.3.1">
<h3 data-number="18.3.1" class="anchored" data-anchor-id="funcionamento-teórico"><span class="header-section-number">18.3.1</span> Funcionamento Teórico</h3>
<p>O algoritmo ótimo requer conhecimento completo da <em>string</em> de referência futura:</p>
<ol type="1">
<li><strong>Para cada falta de página</strong>: Examinar todas as páginas na memória</li>
<li><strong>Identificar</strong>: Qual página será referenciada mais tarde (ou nunca)</li>
<li><strong>Selecionar</strong>: Esta página como vítima</li>
</ol>
</section>
<section id="exemplo-demonstrativo" class="level3" data-number="18.3.2">
<h3 data-number="18.3.2" class="anchored" data-anchor-id="exemplo-demonstrativo"><span class="header-section-number">18.3.2</span> Exemplo Demonstrativo</h3>
<p><em>string</em>: <code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</code> com 3 quadros:</p>
<pre><code>Página | Quadros    | Análise Futura           | Resultado
   7   | [7, -, -]  | -                        | MISS
   0   | [7, 0, -]  | -                        | MISS
   1   | [7, 0, 1]  | -                        | MISS
   2   | [7, 0, 1]  | 7→pos, 0→pos, 1→pos | MISS (remove 7)
   0   | [2, 0, 1]  | -                        | HIT
   3   | [2, 0, 1]  | 2→pos, 0→pos, 1→pos   | MISS (remove 1)
   ...</code></pre>
</section>
<section id="limitações-práticas" class="level3" data-number="18.3.3">
<h3 data-number="18.3.3" class="anchored" data-anchor-id="limitações-práticas"><span class="header-section-number">18.3.3</span> Limitações Práticas</h3>
<p>O algoritmo ótimo é <strong>impraticável</strong> para implementação real porque requer conhecimento do futuro completo. No mundo real, longe da teoria e dos dados controlados, é impossível prever quais páginas serão acessadas. Além disso, a complexidade computacional de analisar a <em>string</em> futura para cada falta de página é proibitiva.</p>
<p>Contudo, serve como <strong>limite inferior teórico</strong> para comparação de algoritmos práticos e como ferramenta de análise em simulações quando a <em>string</em> de referência é conhecida a posteriori.</p>
</section>
</section>
<section id="lru-least-recently-used-aproximando-o-ótimo" class="level2" data-number="18.4">
<h2 data-number="18.4" class="anchored" data-anchor-id="lru-least-recently-used-aproximando-o-ótimo"><span class="header-section-number">18.4</span> LRU (Least Recently Used): Aproximando o Ótimo</h2>
<p>O algoritmo <strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed, <strong>LRU</strong>, baseia-se numa heurística fundamental: <em>páginas acessadas recentemente têm maior probabilidade de serem acessadas novamente em breve</em>. Esta aproximação do algoritmo ótimo substitui <em>conhecimento do futuro</em> por <em>memória do passado recente</em>.</p>
<section id="princípio-fundamental" class="level3" data-number="18.4.1">
<h3 data-number="18.4.1" class="anchored" data-anchor-id="princípio-fundamental"><span class="header-section-number">18.4.1</span> Princípio Fundamental</h3>
<p>O <strong>LRU</strong> mantém histórico de acessos e sempre remove a página que <strong>não foi acessada há mais tempo</strong>. Esta estratégia explora o princípio da localidade temporal, observando que programas tendem a reutilizar dados recentemente acessados.</p>
</section>
<section id="implementações-práticas" class="level3" data-number="18.4.2">
<h3 data-number="18.4.2" class="anchored" data-anchor-id="implementações-práticas"><span class="header-section-number">18.4.2</span> Implementações Práticas</h3>
<section id="implementação-com-lista-ligada" class="level4" data-number="18.4.2.1">
<h4 data-number="18.4.2.1" class="anchored" data-anchor-id="implementação-com-lista-ligada"><span class="header-section-number">18.4.2.1</span> Implementação com Lista Ligada</h4>
<p>A implementação clássica utiliza uma lista duplamente ligada:</p>
<pre class="shell"><code>Estrutura LRU:
- Lista duplamente ligada de páginas
- Hash table para acesso O(1) aos nós
- Cabeça = mais recentemente usado
- Cauda = menos recentemente usado

Operações:
- Acesso: Mover página para cabeça da lista
- Substituição: Remover página da cauda</code></pre>
<p><strong>Complexidade</strong>: <span class="math inline">\(O(1)\)</span> para acesso e substituição com <em>hash table</em> auxiliar.</p>
</section>
<section id="implementação-com-matriz-de-bits" class="level4" data-number="18.4.2.2">
<h4 data-number="18.4.2.2" class="anchored" data-anchor-id="implementação-com-matriz-de-bits"><span class="header-section-number">18.4.2.2</span> Implementação com Matriz de Bits</h4>
<p>Para sistemas com poucos quadros, uma matriz <span class="math inline">\(n \times n\)</span> pode rastrear ordem de acesso:</p>
<pre class="shell"><code>Algoritmo da Matriz:
- Matriz M[i][j] onde i,j são índices de quadros
- Ao acessar página no quadro k:
  * Definir linha k = 1111..
  * Definir coluna k = 0000..
- Para substituição: escolher linha com menor valor binário</code></pre>
<p><strong>Vantagem</strong>: Implementação simples para poucos quadros. <strong>Desvantagem</strong>: Espaço <span class="math inline">\(O(n^2)\)</span> e operações <span class="math inline">\(O(n)\)</span> por acesso.</p>
</section>
<section id="aproximações-hardware-assistidas" class="level4" data-number="18.4.2.3">
<h4 data-number="18.4.2.3" class="anchored" data-anchor-id="aproximações-hardware-assistidas"><span class="header-section-number">18.4.2.3</span> Aproximações Hardware-Assistidas</h4>
<p>Sistemas reais frequentemente utilizam aproximações devido ao custo de LRU completo:</p>
<p><strong>Algoritmo de Envelhecimento (<em>aging</em>)</strong>:</p>
<ul>
<li>Cada página mantém contador de <span class="math inline">\(8\)</span> a <span class="math inline">\(16\)</span> bits;</li>
<li>Periodicamente: deslocar contadores à direita;</li>
<li>Se bit de referência é igual a <span class="math inline">\(1\)</span>: definir bit mais significativo;</li>
<li>Substituir página com menor contador.</li>
</ul>
</section>
</section>
<section id="exemplo-detalhado" class="level3" data-number="18.4.3">
<h3 data-number="18.4.3" class="anchored" data-anchor-id="exemplo-detalhado"><span class="header-section-number">18.4.3</span> Exemplo Detalhado</h3>
<p><em>string</em>: <code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</code> com 3 quadros:</p>
<pre class="shell"><code>Página | Quadros (ordem LRU) | Resultado
   7   | [7]                 | MISS
   0   | [0, 7]              | MISS
   1   | [1, 0, 7]           | MISS
   2   | [2, 1, 0]           | MISS (remove 7)
   0   | [0, 2, 1]           | HIT (0 move para frente)
   3   | [3, 0, 2]           | MISS (remove 1)
   0   | [0, 3, 2]           | HIT
   4   | [4, 0, 3]           | MISS (remove 2)
   2   | [2, 4, 0]           | MISS (remove 3)
   3   | [3, 2, 4]           | MISS (remove 0)
   ...</code></pre>
</section>
<section id="propriedades-do-lru" class="level3" data-number="18.4.4">
<h3 data-number="18.4.4" class="anchored" data-anchor-id="propriedades-do-lru"><span class="header-section-number">18.4.4</span> Propriedades do LRU</h3>
<p>O <strong>LRU</strong> possui características importantes:</p>
<ul>
<li><strong>Não sofre anomalia de Belady</strong>: mais quadros sempre resulta em desempenho igual ou melhor;</li>
<li><strong>Desempenho próximo ao ótimo</strong>: em workloads com boa localidade temporal;</li>
<li><strong>Implementação complexa</strong>: requer estruturas de dados sofisticadas para eficiência.</li>
</ul>
<p>Novamente, podemos implementar o <strong>LRU</strong> em C++ 23 a partir da classe <code>LruPageManager</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> LruPageManager<span class="op">::</span>accessPage<span class="op">(</span>DWORD page_number<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Verificar se a página está na memória (HIT)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it <span class="op">=</span> page_table<span class="op">.</span>find<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> page_table<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        hits<span class="op">++;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Em um HIT, a página se torna a mais recentemente usada.</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Movemos o elemento correspondente para o início da lista.</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        lru_list<span class="op">.</span>splice<span class="op">(</span>lru_list<span class="op">.</span>begin<span class="op">(),</span> lru_list<span class="op">,</span> it<span class="op">-&gt;</span>second<span class="op">);</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Se ausente (MISS / Page Fault)</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    page_faults<span class="op">++;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Se a memória está cheia, remover a página menos recentemente usada (LRU)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>page_table<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> num_frames<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// A página LRU é a última na lista</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        DWORD victim_page <span class="op">=</span> lru_list<span class="op">.</span>back<span class="op">();</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Remove a vítima da tabela de hash e da lista</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        lru_list<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Insere a nova página na frente (agora é a MRU)</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        lru_list<span class="op">.</span>push_front<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> lru_list<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Se há quadro livre, apenas insere a nova página na frente</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        lru_list<span class="op">.</span>push_front<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> lru_list<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O método <code>accessPage</code> encapsula a lógica do algoritmo <strong>LRU</strong>, que atualiza a ordem de recenticidade das páginas a cada acesso e substitui a página menos recentemente usada quando necessário. Abaixo, uma análise detalhada de cada etapa:</p>
<ol type="1">
<li><p><strong>Verificação de Acerto (Hit)</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> page_table<span class="op">.</span>find<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> page_table<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    hits<span class="op">++;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    lru_list<span class="op">.</span>splice<span class="op">(</span>lru_list<span class="op">.</span>begin<span class="op">(),</span> lru_list<span class="op">,</span> it<span class="op">-&gt;</span>second<span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: Verifica se a página solicitada (<code>page_number</code>) está na memória usando a <code>page_table</code> (um <code>std::unordered_map</code> que mapeia números de página para iteradores na <code>lru_list</code>). Se presente, incrementa o contador de acertos (<code>hits</code>) e move a página para o início da <code>lru_list</code> (tornando-a a mais recentemente usada, ou <em>Most Recently Used</em> - MRU) usando <code>splice</code>.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca na <code>page_table</code> é <span class="math inline">\(O(1)\)</span> em média, devido ao uso de <code>unordered_map</code>;</li>
<li>A operação <code>splice</code> na <code>std::list</code> é <span class="math inline">\(O(1)\)</span>, pois apenas rearranja ponteiros internamente, sem copiar elementos;</li>
<li>Reorganizar a lista em cada hit reflete a essência do LRU, mantendo a ordem de recenticidade.</li>
</ul></li>
</ul></li>
<li><p><strong>Registro de Falha (Miss)</strong>:</p>
<ul>
<li><strong>Código</strong>: <code>page_faults++;</code>;</li>
<li><strong>Funcionamento</strong>: se a página não está na memória, registra uma falha de página (<code>page_faults</code>);</li>
<li><strong>Análise</strong>: este passo é essencial para rastrear o desempenho do algoritmo, permitindo calcular a taxa de acertos posteriormente.</li>
</ul></li>
<li><p><strong>Substituição de Página (Memória Cheia)</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>page_table<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> num_frames<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    DWORD victim_page <span class="op">=</span> lru_list<span class="op">.</span>back<span class="op">();</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    lru_list<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    lru_list<span class="op">.</span>push_front<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> lru_list<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: Se a memória está cheia, número de páginas igual a <code>num_frames</code>, remove a página menos recentemente usada, a última da <code>lru_list</code>, apaga-a da <code>page_table</code> e da lista, e insere a nova página no início da <code>lru_list</code>, atualizando a <code>page_table</code>.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A escolha da vítima (<code>lru_list.back()</code>) é <span class="math inline">\(O(1)\)</span>, assim como <code>pop_back()</code> e <code>push_front()</code> na <code>std::list</code>;</li>
<li>A remoção e inserção na <code>page_table</code> são <span class="math inline">\(O(1)\)</span> em média, garantindo alta performance;</li>
<li>Este passo reflete a política <strong>LRU</strong>, priorizando a retenção de páginas recentemente usadas.</li>
</ul></li>
</ul></li>
<li><p><strong>Alocação em Quadro Livre</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    lru_list<span class="op">.</span>push_front<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> lru_list<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: Se há quadros livres, insere a nova página no início da <code>lru_list</code>, e atualiza a <code>page_table</code>.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>As operações <code>push_front</code> e a inserção na <code>page_table</code> são <span class="math inline">\(O(1)\)</span>;</li>
<li>Não é necessária uma busca por quadros livres, pois a <code>lru_list</code> e a <code>page_table</code> gerenciam diretamente as páginas alocadas.</li>
</ul></li>
</ul></li>
</ol>
<p>Podemos destacar alguns pontos fortes do <strong>LRU</strong>:</p>
<ul>
<li><strong>Eficiência</strong>: o uso de <code>std::list</code> e <code>std::unordered_map</code> garante operações <span class="math inline">\(O(1)\)</span> para busca, movimentação e substituição de páginas, tornando a implementação eficiente;</li>
<li><strong>Aderência ao Princípio da Localidade</strong>: o <strong>LRU</strong> é mais eficaz que o <strong>FIFO</strong> em cenários com padrões de acesso repetitivos, reduzindo falhas de página;</li>
</ul>
<p>Por outro lado, comparado ao <strong>FIFO</strong>, o <strong>LRU</strong> tem a implementação mais complexa devido à necessidade de rastrear a ordem de recenticidade, exigindo estruturas como listas duplamente ligadas. Além disso, em hardware, manter a ordem de uso pode ser custoso sem suporte específico, ex.: contadores de acesso. O código assume um ambiente simulado. Finalmente, não há verificação de entradas inválidas, ex.: <code>page_number</code> ou <code>num_frames</code>, o que seria necessário em sistemas reais.</p>
</section>
</section>
<section id="algoritmo-do-relógio-clocksecond-chance" class="level2" data-number="18.5">
<h2 data-number="18.5" class="anchored" data-anchor-id="algoritmo-do-relógio-clocksecond-chance"><span class="header-section-number">18.5</span> Algoritmo do Relógio (Clock/Second Chance)</h2>
<p>O <strong>algoritmo do relógio</strong>, desenvolvido como aproximação eficiente do <strong>LRU</strong>, utiliza um bit de referência mantido pelo hardware para implementar uma política de <em>segunda chance</em>. Esta abordagem oferece desempenho próximo ao <strong>LRU</strong> com implementação significativamente mais simples.</p>
<section id="estrutura-e-funcionamento" class="level3" data-number="18.5.1">
<h3 data-number="18.5.1" class="anchored" data-anchor-id="estrutura-e-funcionamento"><span class="header-section-number">18.5.1</span> Estrutura e Funcionamento</h3>
<p>O algoritmo organiza os quadros em uma estrutura circular com ponteiro que <em>varre</em> continuamente:</p>
<pre class="shell"><code>Estrutura Clock:
- Array circular de quadros
- Bit de referência por quadro (mantido pelo hardware)
- Ponteiro de relógio (clock hand)

Algoritmo:
1. Ao acessar página: hardware define bit de referência = 1
2. Para substituição:
   a. Examinar quadro atual do ponteiro
   b. Se bit = 0: selecionar como vítima
   c. Se bit = 1: definir bit = 0, avançar ponteiro
   d. Repetir até encontrar vítima</code></pre>
</section>
<section id="análise-do-comportamento" class="level3" data-number="18.5.2">
<h3 data-number="18.5.2" class="anchored" data-anchor-id="análise-do-comportamento"><span class="header-section-number">18.5.2</span> Análise do Comportamento</h3>
<p>O algoritmo do relógio implementa efetivamente uma política de <strong>segunda chance</strong>:</p>
<ul>
<li><strong>Primeira passada</strong>: páginas com bit igual a <span class="math inline">\(1\)</span> recebem a <em>segunda chance</em>;</li>
<li><strong>Segunda passada</strong>: páginas que não foram referenciadas no intervalo são removidas;</li>
<li><strong>Convergência</strong>: em caso limite, comporta-se como <strong>FIFO</strong>.</li>
</ul>
</section>
<section id="exemplo-ilustrativo" class="level3" data-number="18.5.3">
<h3 data-number="18.5.3" class="anchored" data-anchor-id="exemplo-ilustrativo"><span class="header-section-number">18.5.3</span> Exemplo Ilustrativo</h3>
<p>Podemos ilustrar o funcionamento do algoritmo do relógio com um código em C++ a partir da classe <code>ClockPageManager</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ClockPageManager<span class="op">::</span>accessPage<span class="op">(</span>DWORD page_number<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Verificar se a página está na memória (HIT)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it <span class="op">=</span> page_table<span class="op">.</span>find<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> page_table<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        hits<span class="op">++;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Em um HIT, o hardware define o bit de referência como 1</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        reference_bits<span class="op">[</span>it<span class="op">-&gt;</span>second<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Se ausente (MISS / Page Fault)</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    page_faults<span class="op">++;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Tenta encontrar um quadro livre primeiro</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>SIZE_T<span class="op">&gt;</span> free_frame<span class="op">;</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            free_frame <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>free_frame<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        SIZE_T frame_index <span class="op">=</span> <span class="op">*</span>free_frame<span class="op">;</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        frames<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        reference_bits<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Página nova entra com bit 1</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> frame_index<span class="op">;</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Se a memória está cheia, executar o algoritmo do Relógio</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Examinar o quadro atual do ponteiro</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>reference_bits<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">==</span> <span class="kw">false</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Se bit = 0: selecionar como vítima</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>                <span class="at">const</span> DWORD victim_page <span class="op">=</span> frames<span class="op">[</span>clock_hand<span class="op">].</span>value<span class="op">();</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>                page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>                frames<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>                reference_bits<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Página nova entra com bit 1</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>                page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> clock_hand<span class="op">;</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>                clock_hand <span class="op">=</span> <span class="op">(</span>clock_hand <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> num_frames<span class="op">;</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span> <span class="co">// Vítima encontrada, sai do loop</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Se bit = 1: dar segunda chance (zerar o bit) e avançar</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>                reference_bits<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>                clock_hand <span class="op">=</span> <span class="op">(</span>clock_hand <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> num_frames<span class="op">;</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Neste caso, o método <code>accessPage</code> encapsula a lógica do algoritmo Relógio, que usa um ponteiro circular, <code>clock_hand</code>, e bits de referência para gerenciar a substituição de páginas. Abaixo, uma análise detalhada de cada etapa:</p>
<ol type="1">
<li><p><strong>Verificação de Acerto (Hit)</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> page_table<span class="op">.</span>find<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> page_table<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    hits<span class="op">++;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    reference_bits<span class="op">[</span>it<span class="op">-&gt;</span>second<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: verifica se a página solicitada, <code>page_number</code>, está na memória usando a <code>page_table</code>, um <code>std::unordered_map</code> que mapeia números de página para índices de quadros. Se presente, incrementa o contador de acertos (<code>hits</code>) e define o bit de referência do quadro correspondente como <code>true</code>, indicando que a página foi recentemente acessada.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca na <code>page_table</code> é <span class="math inline">\(O(1)\)</span> em média, garantindo eficiência;</li>
<li>Definir o bit de referência como <code>true</code> simula o comportamento de hardware que marca páginas acessadas, essencial para a política de <em>segunda chance</em>;</li>
<li>Diferentemente do <strong>LRU</strong>, o Relógio não reorganiza uma lista, reduzindo a sobrecarga computacional.</li>
</ul></li>
</ul></li>
<li><p><strong>Registro de Falha (Miss)</strong>:</p>
<ul>
<li><strong>Código</strong>: <code>page_faults++;</code>;</li>
<li><strong>Funcionamento</strong>: se a página não está na memória, registra uma falha de página, <code>page_faults</code>;</li>
<li><strong>Análise</strong>: Este passo é importante para rastrear o desempenho do algoritmo, permitindo calcular a taxa de acertos posteriormente.</li>
</ul></li>
<li><p><strong>Alocação em Quadro Livre</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>optional<span class="op">&lt;</span>SIZE_T<span class="op">&gt;</span> free_frame<span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        free_frame <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>free_frame<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    SIZE_T frame_index <span class="op">=</span> <span class="op">*</span>free_frame<span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    frames<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    reference_bits<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> frame_index<span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: verifica se há quadros livres, usando <code>std::optional</code> para identificar quadros vazios. Se encontrado, aloca a nova página no quadro, define seu bit de referência como <code>true</code>, indicando acesso recente, e atualiza a <code>page_table</code>.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca linear por um quadro livre é <span class="math inline">\(O(n)\)</span>, onde <code>n</code> é o número de quadros, <code>num_frames</code>. Isto poderia ser otimizado com uma lista de quadros livres;</li>
<li>Definir o bit de referência como <code>true</code> para novas páginas é consistente com a política do Relógio, garantindo que elas tenham uma <em>segunda</em> chance inicial.</li>
</ul></li>
</ul></li>
<li><p><strong>Substituição de Página (Memória Cheia)</strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>reference_bits<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">==</span> <span class="kw">false</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> DWORD victim_page <span class="op">=</span> frames<span class="op">[</span>clock_hand<span class="op">].</span>value<span class="op">();</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>            frames<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>            reference_bits<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> clock_hand<span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>            clock_hand <span class="op">=</span> <span class="op">(</span>clock_hand <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> num_frames<span class="op">;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>            reference_bits<span class="op">[</span>clock_hand<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>            clock_hand <span class="op">=</span> <span class="op">(</span>clock_hand <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> num_frames<span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: se a memória está cheia, o algoritmo Relógio usa o ponteiro <code>clock_hand</code> para varrer os quadros em ordem circular. Se o bit de referência do quadro atual é <code>false</code>, a página é selecionada como vítima, substituída pela nova página, com bit <code>true</code>, e o ponteiro avança. Se o bit é <code>true</code>, ele é zerado, dando uma <em>segunda chance</em>, e o ponteiro avança para o próximo quadro.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca linear por um quadro livre é <span class="math inline">\(O(n)\)</span> no pior caso, pois pode ser necessário varrer todos os quadros se todos tiverem bit de referência <code>true</code>;</li>
<li>A escolha da vítima é <span class="math inline">\(O(n)\)</span> no pior caso, pois pode ser necessário varrer todos os quadros se todos tiverem bit de referência <code>true</code>;</li>
<li>Operações na <code>page_table</code>, remoção e inserção, são <span class="math inline">\(O(1)\)</span> em média;</li>
<li>O avanço circular do <code>clock_hand</code> (<code>% num_frames</code>) simula a estrutura de relógio, mantendo a simplicidade e eficiência em relação ao <strong>LRU</strong> puro.</li>
</ul></li>
</ul></li>
</ol>
<p>Finalmente podemos ver que o algoritmo Relógio é mais simples que o <strong>LRU</strong> puro, pois usa bits de referência em vez de reordenar listas, reduzindo a sobrecarga computacional. Uma vantagem significativa é que a política de “segunda chance” mantém páginas recentemente usadas, aproveitando a localidade temporal com menos custo que o <strong>LRU</strong>.</p>
<p>O exemplo em código C++23 reflete implementações reais em sistemas operacionais, nas quais bits de referência são suportados por hardware.</p>
<p>Existem algumas limitações e considerações práticas na implementação:</p>
<ul>
<li><strong>Busca por Quadro Livre</strong>: a busca linear por quadros livres (<span class="math inline">\(O(n)\)</span>) poderia ser otimizada com uma estrutura auxiliar, como uma lista de quadros disponíveis.</li>
<li><strong>Complexidade no Pior Caso</strong>: a substituição pode exigir várias iterações (<span class="math inline">\(O(n)\)</span>) se todos os bits de referência forem <code>true</code>, embora isto seja raro em cenários com localidade.</li>
<li><strong>Validação de Entrada</strong>: o código não valida <code>page_number</code> ou <code>num_frames</code>, o que seria necessário em sistemas reais.</li>
<li><strong>Dependência de Hardware</strong>: em sistemas reais, o algoritmo depende de suporte para bits de referência, que não é simulado diretamente aqui.</li>
</ul>
</section>
<section id="variações-e-melhorias-do-algoritmo-relógio" class="level3" data-number="18.5.4">
<h3 data-number="18.5.4" class="anchored" data-anchor-id="variações-e-melhorias-do-algoritmo-relógio"><span class="header-section-number">18.5.4</span> Variações e Melhorias do Algoritmo Relógio</h3>
<section id="relógio-melhorado-enhanced-clock" class="level4" data-number="18.5.4.1">
<h4 data-number="18.5.4.1" class="anchored" data-anchor-id="relógio-melhorado-enhanced-clock"><span class="header-section-number">18.5.4.1</span> Relógio Melhorado (<em>Enhanced Clock</em>)</h4>
<p>Utiliza tanto bit de referência quanto bit de modificação:</p>
<pre class="shell"><code>Prioridades de substituição:
1. (referência=0, modificação=0) - Melhor candidato
2. (referência=0, modificação=1) - Segundo melhor  
3. (referência=1, modificação=0) - Terceiro melhor
4. (referência=1, modificação=1) - Último recurso</code></pre>
<p>Esta variação reduz operações de I/O ao preferir páginas limpas.</p>
</section>
<section id="wsclock-working-set-clock" class="level4" data-number="18.5.4.2">
<h4 data-number="18.5.4.2" class="anchored" data-anchor-id="wsclock-working-set-clock"><span class="header-section-number">18.5.4.2</span> WSClock (Working Set Clock)</h4>
<p>Combina conceitos do modelo Working Set com eficiência do algoritmo clock, considerando tanto idade quanto frequência de acesso.</p>
</section>
</section>
</section>
<section id="working-set-model-teoria-da-localidade" class="level2" data-number="18.6">
<h2 data-number="18.6" class="anchored" data-anchor-id="working-set-model-teoria-da-localidade"><span class="header-section-number">18.6</span> Working Set Model: Teoria da Localidade</h2>
<p>O <strong>modelo Working Set</strong>, proposto por Peter Denning em 1968, fundamenta-se numa observação empírica: <em>programas exibem fases distintas de execução, acessando conjuntos relativamente pequenos de páginas em cada fase</em>.</p>
<section id="definição-formal" class="level3" data-number="18.6.1">
<h3 data-number="18.6.1" class="anchored" data-anchor-id="definição-formal"><span class="header-section-number">18.6.1</span> Definição Formal</h3>
<p>O <strong>Working Set</strong> <span class="math inline">\(W(t, \tau)\)</span> de um processo no tempo <span class="math inline">\(t\)</span> com janela <span class="math inline">\(\tau\)</span> é:</p>
<p><span class="math display">\[W(t, \tau) = \{páginas\ referenciadas\ no\ intervalo\ [t-\tau+1, t]\}\]</span></p>
<p>Onde:</p>
<ul>
<li><span class="math inline">\(t\)</span> = tempo virtual atual (número de referências);</li>
<li><span class="math inline">\(\tau\)</span> = tamanho da janela temporal;</li>
<li><span class="math inline">\(|W(t, \tau)|\)</span> igual ao tamanho do <em>working set</em>.</li>
</ul>
</section>
<section id="princípios-operacionais" class="level3" data-number="18.6.2">
<h3 data-number="18.6.2" class="anchored" data-anchor-id="princípios-operacionais"><span class="header-section-number">18.6.2</span> Princípios Operacionais</h3>
<p>O modelo <em>Working Set</em> sugere que:</p>
<ol type="1">
<li><strong>Páginas no working set</strong>: devem permanecer na memória;</li>
<li><strong>Páginas fora do working set</strong>: são candidatas à substituição;</li>
<li><strong>Transições de fase</strong>: causam mudanças dramáticas no <em>working set</em>.</li>
</ol>
</section>
<section id="implementação-prática" class="level3" data-number="18.6.3">
<h3 data-number="18.6.3" class="anchored" data-anchor-id="implementação-prática"><span class="header-section-number">18.6.3</span> Implementação Prática</h3>
<p>A implementação exata do <em>Working Set</em> é computacionalmente intensiva, mas aproximações são viáveis:</p>
<pre class="shell"><code>Algoritmo Working Set Aproximado:
- Manter timestamp da última referência para cada página
- Definir parâmetro τ (idade máxima)
- Para substituição:
  * Varrer todas as páginas
  * Identificar páginas com idade &gt; τ
  * Selecionar mais antiga fora do working set</code></pre>
</section>
<section id="limitações-e-desafios" class="level3" data-number="18.6.4">
<h3 data-number="18.6.4" class="anchored" data-anchor-id="limitações-e-desafios"><span class="header-section-number">18.6.4</span> Limitações e Desafios</h3>
<ul>
<li><strong>Overhead computacional</strong>: requer varredura periódica de todas as páginas;</li>
<li><strong>Escolha de τ</strong>: parâmetro crítico que afeta significativamente o desempenho;</li>
<li><strong>Variabilidade temporal</strong>: <em>working sets</em> mudam dinamicamente.</li>
</ul>
</section>
</section>
<section id="wsclock-síntese-prática" class="level2" data-number="18.7">
<h2 data-number="18.7" class="anchored" data-anchor-id="wsclock-síntese-prática"><span class="header-section-number">18.7</span> WSClock: Síntese Prática</h2>
<p>O <strong>WSClock</strong> representa uma síntese elegante entre a teoria do <em>Working Set</em> e a eficiência prática do algoritmo <em>clock</em>. Desenvolvido para aproximar o comportamento ideal do <em>Working Set</em> com overhead computacional aceitável.</p>
<section id="funcionamento-híbrido" class="level3" data-number="18.7.1">
<h3 data-number="18.7.1" class="anchored" data-anchor-id="funcionamento-híbrido"><span class="header-section-number">18.7.1</span> Funcionamento Híbrido</h3>
<p>O WSClock mantém:</p>
<ul>
<li><strong>Estrutura circular</strong>: como algoritmo clock básico;</li>
<li><strong>Timestamps</strong>: para cada página, momento da última referência;</li>
<li><strong>Parâmetro τ</strong>: define limite de idade para <em>working set</em>.</li>
</ul>
<pre class="shell"><code>Algoritmo WSClock:

1. Varrer páginas com ponteiro circular
2. Para cada página examinada:
   a. Se bit_referência = 1:
      * Atualizar timestamp
      * Definir bit_referência = 0
      * Continuar varredura
   b. Se bit_referência = 0:
      * Calcular idade = tempo_atual - timestamp
      * Se idade &gt; τ: selecionar como vítima
      * Senão: continuar varredura
3. Se varredura completa sem vítima: usar critério FIFO</code></pre>
</section>
<section id="vantagens-integradas" class="level3" data-number="18.7.2">
<h3 data-number="18.7.2" class="anchored" data-anchor-id="vantagens-integradas"><span class="header-section-number">18.7.2</span> Vantagens Integradas</h3>
<ul>
<li><strong>Eficiência</strong>: <span class="math inline">\(O(1)\)</span> amortizado como <em>clock</em>;</li>
<li><strong>Teoria sólida</strong>: baseado em <em>Working Set</em>;</li>
<li><strong>Adaptabilidade</strong>: ajusta-se automaticamente aos padrões de acesso;</li>
<li><strong>Implementação simples</strong>: requer apenas <em>timestamps</em> e bit de referência.</li>
</ul>
</section>
</section>
<section id="algoritmos-de-aging-refinamento-temporal" class="level2" data-number="18.8">
<h2 data-number="18.8" class="anchored" data-anchor-id="algoritmos-de-aging-refinamento-temporal"><span class="header-section-number">18.8</span> Algoritmos de <em>aging</em>: Refinamento Temporal</h2>
<p>Os <strong>algoritmos de <em>aging</em></strong>, envelhecimento, implementam aproximações sofisticadas do <strong>LRU</strong> utilizando contadores de múltiplos bits para rastrear história de acessos. Esta abordagem oferece granularidade temporal superior aos algoritmos baseados em bit único.</p>
<section id="implementação-básica" class="level3" data-number="18.8.1">
<h3 data-number="18.8.1" class="anchored" data-anchor-id="implementação-básica"><span class="header-section-number">18.8.1</span> Implementação Básica</h3>
<pre class="shell"><code>Estrutura aging:
- Contador de n bits por página (tipicamente 8-16 bits)
- Timer periódico (ex: a cada 20ms)

Algoritmo:
1. Periodicamente (timer interrupt):
   a. Para cada página: deslocar contador 1 bit à direita
   b. Se bit_referência = 1: definir bit mais significativo = 1
   c. Limpar bit_referência</code></pre>
</section>
<section id="análise-temporal" class="level3" data-number="18.8.2">
<h3 data-number="18.8.2" class="anchored" data-anchor-id="análise-temporal"><span class="header-section-number">18.8.2</span> Análise Temporal</h3>
<p>O <em>aging</em> captura <strong>história ponderada</strong> de acessos:</p>
<ul>
<li><strong>Bits mais significativos</strong>: Acessos recentes, maior peso;</li>
<li><strong>Bits menos significativos</strong>: Acessos antigos, menor peso;</li>
<li><strong>Granularidade</strong>: Depende do número de bits e frequência do timer.</li>
</ul>
<p><strong>Exemplo com contadores de 8 bits e timer de 20ms</strong>:</p>
<pre class="shell"><code>Tempo | Página A | Página B | Bit Ref A | Bit Ref B
  0   | 00000000 | 00000000 |     0     |     0
 20ms | 00000000 | 10000000 |     0     |     1
 40ms | 00000000 | 01000000 |     0     |     0
 60ms | 10000000 | 00100000 |     1     |     0
 80ms | 01000000 | 00010000 |     0     |     0</code></pre>
<p>Página A seria selecionada para substituição (contador menor).</p>
<section id="simulador" class="level4" data-number="18.8.2.1">
<h4 data-number="18.8.2.1" class="anchored" data-anchor-id="simulador"><span class="header-section-number">18.8.2.1</span> Simulador</h4>
<p>Assim como fizemos com os outros algoritmos, podemos implementar o algoritmo de <em>aging</em> em C++ 23 a partir da classe <code>AgingPageManager</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> AgingPageManager<span class="op">::</span>accessPage<span class="op">(</span>DWORD page_number<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Verificar se a página está na memória (HIT)</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it <span class="op">=</span> page_table<span class="op">.</span>find<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> page_table<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        hits<span class="op">++;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        reference_bits<span class="op">[</span>it<span class="op">-&gt;</span>second<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Marca como referenciada</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Se ausente (MISS / Page Fault)</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    page_faults<span class="op">++;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Tenta encontrar um quadro livre</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>SIZE_T<span class="op">&gt;</span> free_frame<span class="op">;</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>            free_frame <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Se há quadro livre</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>free_frame<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>        SIZE_T frame_index <span class="op">=</span> <span class="op">*</span>free_frame<span class="op">;</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>        frames<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>        reference_bits<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>        age_counters<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Reseta o contador</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> frame_index<span class="op">;</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Se a memória está cheia, encontrar a vítima com o menor contador</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint8_t</span> min_age <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>        SIZE_T victim_frame_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>age_counters<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> min_age<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>                min_age <span class="op">=</span> age_counters<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>                victim_frame_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> DWORD victim_page <span class="op">=</span> frames<span class="op">[</span>victim_frame_index<span class="op">].</span>value<span class="op">();</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a>        frames<span class="op">[</span>victim_frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>        reference_bits<span class="op">[</span>victim_frame_index<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>        age_counters<span class="op">[</span>victim_frame_index<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>        page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> victim_frame_index<span class="op">;</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> AgingPageManager<span class="op">::</span>timerTick<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">uint8_t</span> msb_mask <span class="op">=</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>AGING_COUNTER_BITS <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Deslocar contador 1 bit à direita</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a>            age_counters<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;&gt;=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Se bit_referência = 1: definir bit mais significativo = 1</span></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>reference_bits<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true" tabindex="-1"></a>                age_counters<span class="op">[</span>i<span class="op">]</span> <span class="op">|=</span> msb_mask<span class="op">;</span></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Limpar bit_referência</span></span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true" tabindex="-1"></a>            reference_bits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O algoritmo <em>Aging</em> combina dois métodos principais: <code>accessPage</code>, que gerencia acessos a páginas e substituições, e <code>timerTick</code>, que simula a passagem do tempo, atualizando os contadores de envelhecimento. Abaixo, uma análise detalhada de cada etapa:</p>
<ol type="1">
<li><p><strong>Verificação de Acerto (Hit) em <code>accessPage</code></strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> page_table<span class="op">.</span>find<span class="op">(</span>page_number<span class="op">);</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> page_table<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    hits<span class="op">++;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    reference_bits<span class="op">[</span>it<span class="op">-&gt;</span>second<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: verifica se a página solicitada (<code>page_number</code>) está na memória usando a <code>page_table</code> (um <code>std::unordered_map</code> que mapeia números de página para índices de quadros). Se presente, incrementa o contador de acertos (<code>hits</code>) e define o bit de referência do quadro como <code>true</code>, indicando acesso recente.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca na <code>page_table</code> é O(1) em média, garantindo eficiência;</li>
<li>Definir o bit de referência como <code>true</code> prepara a página para ter seu contador atualizado no próximo <em>timer tick</em>, aumentando seu valor e priorizando sua permanência na memória;</li>
<li>Diferentemente do LRU, o Aging não reordena imediatamente, adiando a atualização do “peso” da página para o <code>timerTick</code>.</li>
</ul></li>
</ul></li>
<li><p><strong>Registro de Falha (Miss) em <code>accessPage</code></strong>:</p>
<ul>
<li><strong>Código</strong>: <code>page_faults++;</code>;</li>
<li><strong>Funcionamento</strong>: Se a página não está na memória, registra uma falha de página (<code>page_faults</code>);</li>
<li><strong>Análise</strong>: Este passo é essencial para rastrear o desempenho do algoritmo, permitindo calcular a taxa de acertos posteriormente.</li>
</ul></li>
<li><p><strong>Alocação em Quadro Livre em <code>accessPage</code></strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>optional<span class="op">&lt;</span>SIZE_T<span class="op">&gt;</span> free_frame<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        free_frame <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>free_frame<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    SIZE_T frame_index <span class="op">=</span> <span class="op">*</span>free_frame<span class="op">;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    frames<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    reference_bits<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    age_counters<span class="op">[</span>frame_index<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> frame_index<span class="op">;</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: verifica se há quadros livres (usando <code>std::optional</code> para identificar quadros vazios). Se encontrado, aloca a nova página no quadro, define seu bit de referência como <code>true</code> (acesso recente) e reseta seu contador de envelhecimento, <code>age_counters</code>, para <span class="math inline">\(0\)</span>, atualizando a <code>page_table</code>;</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca linear por um quadro livre é <span class="math inline">\(O(n)\)</span>, onde <code>n</code> é o número de quadros, <code>num_frames</code>. Isto poderia ser otimizado com uma lista de quadros livres;</li>
<li>Zerar o contador, <span class="math inline">\(0\)</span> reflete que a nova página ainda não foi <em>envelhecida</em>, enquanto o bit de referência <code>true</code> garante que ela ganhará prioridade no próximo <em>timer tick</em>.</li>
</ul></li>
</ul></li>
<li><p><strong>Substituição de Página (Memória Cheia) em <code>accessPage</code></strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> min_age <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    SIZE_T victim_frame_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>age_counters<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> min_age<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>            min_age <span class="op">=</span> age_counters<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>            victim_frame_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> DWORD victim_page <span class="op">=</span> frames<span class="op">[</span>victim_frame_index<span class="op">].</span>value<span class="op">();</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">.</span>erase<span class="op">(</span>victim_page<span class="op">);</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    frames<span class="op">[</span>victim_frame_index<span class="op">]</span> <span class="op">=</span> page_number<span class="op">;</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    reference_bits<span class="op">[</span>victim_frame_index<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    age_counters<span class="op">[</span>victim_frame_index<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    page_table<span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> victim_frame_index<span class="op">;</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: se a memória está cheia, seleciona a página com o menor contador de envelhecimento, <code>age_counters</code>, como <em>vítima</em>, remove-a da <code>page_table</code> e do quadro, insere a nova página no mesmo quadro, define seu bit de referência como <code>true</code>, zera seu contador e atualiza a <code>page_table</code>.</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>A busca pelo menor contador é <span class="math inline">\(O(n)\)</span>, pois requer varrer todos os quadros;</li>
<li>Operações na <code>page_table</code>, remoção e inserção, são <span class="math inline">\(O(1)\)</span> em média;</li>
<li>A escolha da vítima com base no menor contador reflete a política do <em>Aging</em>, que prioriza páginas com menos acessos recentes, aproximando-se do <strong>LRU</strong>.</li>
</ul></li>
</ul></li>
<li><p><strong>Envelhecimento em <code>timerTick</code></strong>:</p>
<ul>
<li><p><strong>Código</strong>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> AgingPageManager<span class="op">::</span>timerTick<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">uint8_t</span> msb_mask <span class="op">=</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>AGING_COUNTER_BITS <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>SIZE_T i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_frames<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>frames<span class="op">[</span>i<span class="op">].</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>            age_counters<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;&gt;=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>reference_bits<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                age_counters<span class="op">[</span>i<span class="op">]</span> <span class="op">|=</span> msb_mask<span class="op">;</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>            reference_bits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Funcionamento</strong>: simula a passagem do tempo, deslocando todos os contadores de envelhecimento (<code>age_counters</code>) um bit à direita (reduzindo seu valor pela metade). Se o bit de referência de uma página é <code>true</code>, define o bit mais significativo do contador como <span class="math inline">\(1\)</span>. Finalmente, limpa o bit de referência;</p></li>
<li><p><strong>Análise</strong>:</p>
<ul>
<li>O deslocamento à direita (<code>&gt;&gt;= 1</code>) reduz o peso de acessos antigos, enquanto o bit de referência adicionado ao contador (<code>|= msb_mask</code>) reflete acessos recentes, mantendo a localidade temporal;</li>
<li>A operação é <span class="math inline">\(O(n)\)</span> devido ao laço sobre todos os quadros;</li>
<li>Este passo é importante para diferenciar o <em>Aging</em> de outros algoritmos, pois permite rastrear o histórico de acessos com maior granularidade que o algoritmo Relógio.</li>
</ul></li>
</ul></li>
</ol>
<p>O <em>Aging</em> oferece uma boa aproximação do <strong>LRU</strong> com contadores de múltiplos bits, capturando um histórico de acesso mais detalhado que o bit único do Relógio; No código a combinação de <code>std::unordered_map</code> (<span class="math inline">\(O(1)\)</span> para buscas) e vetores para contadores e bits garante uma implementação robusta. Além disso, neste código o número de bits do contador (<code>AGING_COUNTER_BITS</code>) pode ser ajustado para maior ou menor granularidade.</p>
<p>O algoritmo é apenas uma versão de simulação para que a esforçada leitora possa entender o algoritmo e não deve ser usado em produção sem melhorias. As buscas lineares por quadros livres e pelo menor contador (ambas <span class="math inline">\(O(n)\)</span>) podem ser otimizadas com estruturas auxiliares, como uma <em>heap</em> para contadores. Além disso, não há verificação de entradas inválidas, o que seria necessário em sistemas reais. Finalmente, em sistemas reais, o <em>Aging</em> depende de suporte para contadores de envelhecimento, que não está simulado no nosso código.</p>
</section>
</section>
<section id="variações-e-otimizações" class="level3" data-number="18.8.3">
<h3 data-number="18.8.3" class="anchored" data-anchor-id="variações-e-otimizações"><span class="header-section-number">18.8.3</span> Variações e Otimizações</h3>
<section id="aging-com-múltiplas-classes" class="level4" data-number="18.8.3.1">
<h4 data-number="18.8.3.1" class="anchored" data-anchor-id="aging-com-múltiplas-classes"><span class="header-section-number">18.8.3.1</span> <em>Aging</em> com Múltiplas Classes</h4>
<p>Separar páginas em classes baseadas em tipos de uso:</p>
<ul>
<li><strong>Classe 0</strong>: Páginas de código (executável);</li>
<li><strong>Classe 1</strong>: Páginas de dados privados;</li>
<li><strong>Classe 2</strong>: Páginas compartilhadas;</li>
<li><strong>Classe 3</strong>: Páginas de sistema.</li>
</ul>
<p>Cada classe mantém contadores independentes, permitindo políticas diferenciadas.</p>
</section>
<section id="aging-adaptativo" class="level4" data-number="18.8.3.2">
<h4 data-number="18.8.3.2" class="anchored" data-anchor-id="aging-adaptativo"><span class="header-section-number">18.8.3.2</span> <em>aging</em> Adaptativo</h4>
<p>Ajustar frequência do timer baseado na carga do sistema:</p>
<ul>
<li><strong>Carga baixa</strong>: Timer mais lento (economia de energia);</li>
<li><strong>Carga alta</strong>: Timer mais rápido (precisão temporal);</li>
<li><strong>Pressão de memória</strong>: Aumentar granularidade.</li>
</ul>
</section>
</section>
</section>
<section id="análise-comparativa-e-trade-offs" class="level2" data-number="18.9">
<h2 data-number="18.9" class="anchored" data-anchor-id="análise-comparativa-e-trade-offs"><span class="header-section-number">18.9</span> Análise Comparativa e Trade-offs</h2>
<section id="complexidade-computacional" class="level3" data-number="18.9.1">
<h3 data-number="18.9.1" class="anchored" data-anchor-id="complexidade-computacional"><span class="header-section-number">18.9.1</span> Complexidade Computacional</h3>
<table class="table">
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Acesso</th>
<th>Substituição</th>
<th>Espaço</th>
<th>Hardware</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FIFO</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>$O(n)</td>
<td>Nenhum</td>
</tr>
<tr class="even">
<td>OPT</td>
<td>-</td>
<td><span class="math inline">\(O(n·m)\)</span></td>
<td><span class="math inline">\(O(n·m)\)</span></td>
<td>Impossible</td>
</tr>
<tr class="odd">
<td>LRU</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Timestamps</td>
</tr>
<tr class="even">
<td>Clock</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span> worst</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(1\)</span> bit</td>
</tr>
<tr class="odd">
<td>WSClock</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span> worst</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Timer</td>
</tr>
<tr class="even">
<td><em>aging</em></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(n\)</span> bits</td>
</tr>
</tbody>
</table>
</section>
<section id="desempenho-relativo" class="level3" data-number="18.9.2">
<h3 data-number="18.9.2" class="anchored" data-anchor-id="desempenho-relativo"><span class="header-section-number">18.9.2</span> Desempenho Relativo</h3>
<p><strong>Workloads com boa localidade temporal</strong>: <span class="math inline">\(\text{OPT} &gt; \text{LRU} ≈ \text{aging} &gt; \text{WSClock} &gt; \text{Clock} &gt; \text{FIFO}\)</span>; <strong>Workloads com padrões sequenciais</strong>: <span class="math inline">\(\text{OPT} &gt; \text{FIFO} ≈ \text{Clock} &gt; \text{LRU} &gt; \text{aging}\)</span></p>
<p><strong>Workloads aleatórios</strong>: diferenças mínimas entre algoritmos</p>
</section>
<section id="implementação-em-sistemas-reais" class="level3" data-number="18.9.3">
<h3 data-number="18.9.3" class="anchored" data-anchor-id="implementação-em-sistemas-reais"><span class="header-section-number">18.9.3</span> Implementação em Sistemas Reais</h3>
</section>
</section>
<section id="substituição-de-páginas-no-kernel-linux-moderno-o-lru-multi-geracional" class="level2" data-number="18.10">
<h2 data-number="18.10" class="anchored" data-anchor-id="substituição-de-páginas-no-kernel-linux-moderno-o-lru-multi-geracional"><span class="header-section-number">18.10</span> Substituição de Páginas no <code>kernel</code> Linux Moderno: O LRU Multi-Geracional</h2>
<p>O subsistema de gerenciamento de memória do Linux passou por uma evolução significativa, culminando numa reformulação arquitetônica que aborda as deficiências das abordagens anteriores em face do hardware moderno. Esta secção analisa essa evolução, aprofunda a mecânica do novo <em>framework Multi-Generational LRU (<strong>MGLRU</strong>)</em> e explora a sua interação com os daemons do sistema.</p>
<section id="evolução-arquitetônica-do-split-lru-ao-mglru" class="level3" data-number="18.10.1">
<h3 data-number="18.10.1" class="anchored" data-anchor-id="evolução-arquitetônica-do-split-lru-ao-mglru"><span class="header-section-number">18.10.1</span> Evolução Arquitetônica: Do Split-LRU ao MGLRU</h3>
<p>A história da substituição de páginas no Linux é uma história de aproximações cada vez mais sofisticadas ao ideal do <strong>LRU</strong>. As primeiras implementações dependiam de variantes do <em>algoritmo do Relógio (Clock)</em>, que usava um bit de acesso para dar uma <em>segunda oportunidade</em> às páginas antes de sua remoção, oferecendo uma aproximação de baixo custo ao <strong>LRU</strong>. Durante muitos anos, a estratégia dominante foi o sistema <em>split-LRU</em> com duas listas, uma ativa e outra inativa. Neste modelo, as páginas eram mantidas em duas listas: uma lista ativa para páginas acessadas recentemente e uma lista inativa para páginas candidatas à remoção. As páginas moviam-se da lista ativa para a inativa após um período de inatividade e eram promovidas de volta para a ativa se fossem acessadas enquanto estavam na lista inativa. No entanto, com o advento de sistemas com centenas de gigabytes ou mesmo terabytes de RAM e processadores massivamente multi-core, as limitações deste modelo tornaram-se evidentes:</p>
<ol type="1">
<li><p><strong>Elevado Custo de CPU</strong>: sob forte pressão de memória, o <em>daemon</em> do <code>kernel</code> <code>kswapd</code>, responsável pela recuperação de páginas em segundo plano, e os caminhos de recuperação direta eram forçados a realizar varreduras exaustivas das listas <strong>LRU</strong> para encontrar páginas candidatas à remoção. Este processo consumia uma quantidade significativa de tempo de <code>CPU</code>, podendo levar a uma falta de resposta do sistema em cenários de carga elevada;</p></li>
<li><p><strong>Informação de Idade Grosseira</strong>: a classificação binária de uma página como <em>ativa</em> ou <em>inativa</em> era excessivamente simplista e não conseguia distinguir entre uma página acessada há um segundo e uma acessada há uma hora, resultando frequentemente em decisões de remoção ruins. Graças a essa simplicidade, páginas importantes podiam ser desativadas prematuramente, enquanto páginas verdadeiramente <em>frias</em> permaneciam na memória;</p></li>
<li><p><strong>Baixa Escalabilidade</strong>: a contenção de bloqueios, <em>locks</em>, necessários para manipular as listas <strong>LRU</strong> e o custo das varreduras das lista não escalavam bem com o aumento do número de núcleos de <code>CPU</code> e da capacidade de memória, tornando-se um gargalo de desempenho em hardware moderno.</p></li>
</ol>
<p>A resposta a estes desafios foi o <em>framework Multi-Generational LRU (<strong>MGLRU</strong>)</em>, uma implementação alternativa desenvolvida pelo Google e integrada na linha principal do <code>kernel</code> por volta da versão 6.0. O <strong>MGLRU</strong> foi explicitamente concebido para otimizar a recuperação de páginas, melhorar o desempenho sob pressão de memória e reduzir o consumo de <code>CPU</code> do <code>kswapd</code>. A primeira <em>patch</em> submetida publicamente foi em março de 2021, com versões revisadas e discutidas ao longo de 2021 e 2022. O <em>merge</em> deste mecanismo foi realizado no <code>kernel</code> principal do Linux a partir da versão 6.1 (2022). A modificação introduzida por este <em>patch</em> não foi apenas uma otimização, mas sim uma mudança filosófica fundamental nos processos de gerenciamento de memória do Linux. Em vez de um modelo reativo, o <strong>MGLRU</strong> introduziu um sistema proativo, orientado por dados e baseado no tempo. O sistema de duas listas simplesmente reagia à falta de acesso. O <strong>MGLRU</strong> classifica ativamente as páginas numa escala contínua de <em>idade</em>.</p>
<p>Funcionalidades como a prevenção de <em>thrashing</em> e a recuperação proativa demonstram uma mudança para uma gerenciamento antecipada, onde o sistema pode ser configurado para proteger conjuntos de trabalho temporais ou limpar páginas frias em preparação para novas cargas de trabalho, tornando-o mais adequado para a diversidade de cenários de uso modernos, desde dispositivos móveis a grandes centros de dados</p>
</section>
<section id="análise-profunda-do-framework-mglru" class="level3" data-number="18.10.2">
<h3 data-number="18.10.2" class="anchored" data-anchor-id="análise-profunda-do-framework-mglru"><span class="header-section-number">18.10.2</span> <strong>1. Análise Profunda do Framework </strong>MGLRU****</h3>
<p>O <strong>MGLRU</strong> opera com base em vários objetivos de design claros: obter uma boa representação da recenticidade de acesso, tirar partido da localidade espacial, usar caminhos rápidos para decisões óbvias e empregar heurísticas simples e autocorretivas</p>
<p>O conceito central do <strong>MGLRU</strong> são as <strong>gerações</strong>. Em vez de duas listas, o <strong>MGLRU</strong> divide as páginas elegíveis para remoção em múltiplas gerações, onde cada geração representa um grupo de páginas com uma recenticidade de acesso semelhante Uma página recém-acessada é colocada na geração mais jovem. Com o tempo, se uma página não for acessada, envelhece e é movida para gerações progressivamente mais antigas. Isto fornece uma visão muito mais granular e baseada no tempo do quão “quente” ou “fria” uma página é, permitindo decisões de remoção muito mais inteligentes</p>
<p>As principais estruturas de dados que suportam este <em>framework</em> incluem:</p>
<ul>
<li>lruvec: Uma estrutura por-nó e por-<code>cgroup</code> que contém a informação LRU.<br>
</li>
<li>lrugen: Uma subestrutura dentro da <code>lruvec</code> que armazena os dados específicos do <strong>MGLRU</strong>. Contém max_seq, o número da geração mais jovem, e min_seq, os números das gerações mais antigas, que são rastreados separadamente para páginas anônimas e de arquivos<br>
</li>
<li>folios: A estrutura de memória subjacente que representa uma ou mais páginas físicas contíguas. O folio contém um “contador de geração” (<em>gen counter</em>) nos seus <em>flags</em>, que indica a que geração pertence</li>
</ul>
<p>Para além das gerações, o <strong>MGLRU</strong> introduz o conceito de <strong>níveis</strong> (<em>tiers</em>). Os níveis são usados especificamente para páginas de arquivos para rastrear a frequência de acesso, adicionando uma dimensão de informação para além da recenticidade. Uma página acessada N vezes através de descritores de arquivo é colocada no nível order_base_2(N), permitindo que o sistema distinga entre páginas de uso único (como as de uma grande varredura de arquivo) e páginas acessadas repetidamente</p>
<p>Uma observação arquitetônica fundamental é que, embora o <strong>MGLRU</strong> seja um novo <em>framework</em>, ele retém e refina a separação fundamental entre páginas anônimas (memória de processo, como <em>heap</em> e <em>stack</em>) e páginas de arquivos (conteúdo de arquivos em cache). O sistema split-LRU anterior já separava as listas ativa/inativa para estes dois tipos para evitar varrer páginas anônimas dispendiosas quando páginas de arquivos limpas e baratas podiam ser simplesmente descartadas O <strong>MGLRU</strong> continua esta prática, mantendo contadores</p>
<p>min_seq separados para os tipos anónimo e de arquivo A lógica de remoção reconhece explicitamente que “páginas de arquivos limpas podem ser expulsas independentemente das restrições de</p>
<p><em>swap</em>” Isto demonstra que o princípio económico central — que expulsar uma página que requer uma escrita para o</p>
<p><em>swap</em> (anónima) é muito mais caro do que descartar uma página limpa que já existe em disco (de arquivo) — permanece um pilar central da estratégia de substituição de páginas.</p>
</section>
<section id="o-processo-de-envelhecimento-e-remoção-do-mglru" class="level3" data-number="18.10.3">
<h3 data-number="18.10.3" class="anchored" data-anchor-id="o-processo-de-envelhecimento-e-remoção-do-mglru"><span class="header-section-number">18.10.3</span> <strong>1. O Processo de Envelhecimento e Remoção do </strong>MGLRU****</h3>
<p>O fluxo de trabalho do <strong>MGLRU</strong> pode ser dividido em dois processos principais: envelhecimento e remoção.</p>
<p>O processo de <strong>envelhecimento</strong> é responsável por criar novas gerações mais jovens e, consequentemente, por fazer com que as páginas não referenciadas envelheçam e se movam para gerações mais antigas Este processo funciona varrendo periodicamente a memória para detetar páginas acessadas. O acesso é detetado através de dois canais principais:</p>
<ol type="1">
<li><strong>Tabelas de Páginas</strong>: Para memória anónima e de processo, o envelhecimento percorre as tabelas de páginas dos processos para verificar o bit de acesso, que é definido pelo hardware da MMU quando uma página é lida ou escrita.<br>
</li>
<li><strong>Descritores de Arquivos</strong>: Para páginas de arquivos, o acesso também pode ser inferido através de chamadas de sistema como read() e write().</li>
</ol>
<p>Quando uma página é encontrada com o bit de acesso definido, ela é “promovida” para a geração mais jovem O próprio ato de criar uma nova geração mais jovem (incrementando</p>
<p>max_seq) faz com que todas as outras gerações se tornem relativamente mais antigas, efetivamente “rebaixando” as páginas frias</p>
<p>O processo de <strong>remoção</strong> é ativado quando o sistema precisa de libertar memória. A lógica de remoção do <strong>MGLRU</strong> visa as gerações mais antigas primeiro, pois contêm as páginas que, com maior probabilidade, não são utilizadas. A decisão de remoção é inteligente e distingue entre os tipos de página. Como as páginas de arquivos limpas são as mais baratas de expulsar (não requerem escrita em disco), são frequentemente candidatas prioritárias. Se as gerações mais antigas de páginas anônimas e de arquivos tiverem a mesma idade, o sistema utiliza mecanismos de feedback, como uma percentagem de novas falhas de página (<em>refault</em>), para decidir qual tipo expulsar Um controlador PID (Proporcional-Integral-Derivativo) é usado para monitorizar as nova falhas (páginas que são expulsas e rapidamente solicitadas de novo) e ajustar dinamicamente as heurísticas para equilibrar a agressividade da remoção entre memória anónima e de arquivos, evitando assim o</p>
<p><em>thrashing</em></p>
</section>
<section id="daemons-do-sistema-e-ajustabilidade-o-papel-do-kswapd" class="level3" data-number="18.10.4">
<h3 data-number="18.10.4" class="anchored" data-anchor-id="daemons-do-sistema-e-ajustabilidade-o-papel-do-kswapd"><span class="header-section-number">18.10.4</span> <strong>1. Daemons do Sistema e Ajustabilidade: O Papel do <code>kswapd</code></strong></h3>
<p>A interação entre o <code>kswapd</code> e o <strong>MGLRU</strong> é fundamental para a eficiência do sistema. O <code>kswapd</code> é um <em>thread</em> do <code>kernel</code> que corre em segundo plano, um por cada nó NUMA, e é responsável pela recuperação assíncrona de páginas Ele é acordado pelo alocador de memória quando a quantidade de memória livre num nó desce abaixo de uma marca de água baixa (</p>
<p><em>watermark</em>), pages_low A sua tarefa é então recuperar páginas até que a memória livre atinja uma marca de água alta,</p>
<p>pages_high</p>
<p>O <strong>MGLRU</strong> foi explicitamente concebido para tornar o trabalho do <code>kswapd</code> mais eficiente. Ao organizar as páginas numa hierarquia clara de gerações de recenticidade, o <strong>MGLRU</strong> fornece ao <code>kswapd</code> uma lista pré-ordenada de candidatas à remoção: as páginas nas gerações mais antigas. Isto permite que o <code>kswapd</code> identifique e recupere rapidamente as páginas vítimas com um varrimento mínimo, reduzindo diretamente o seu consumo de CPU e melhorando a capacidade de resposta do sistema sob pressão de memória</p>
<p>Para além da sua operação automática, o <strong>MGLRU</strong> oferece um grau significativo de controlo e observabilidade ao administrador do sistema. O <em>framework</em> pode ser ativado e ajustado através do arquivo /sys/<code>kernel</code>/mm/lru_gen/enabled, que aceita uma máscara de bits para ativar diferentes componentes Funcionalidades importantes podem ser configuradas, como a</p>
<p><strong>prevenção de <em>thrashing</em></strong>, que pode ser ativada escrevendo um valor em milissegundos para min_ttl_ms. Isto instrui o <code>kernel</code> a proteger da remoção qualquer conjunto de trabalho (páginas acessadas) dentro dessa janela de tempo, acionando o OOM killer se não for possível manter esse conjunto de trabalho na memória Funcionalidades avançadas, como a estimativa de conjuntos de trabalho e a recuperação proativa, são expostas através de</p>
<p>/sys/<code>kernel</code>/debug/lru_gen, fornecendo ferramentas poderosas para agendadores de tarefas em centros de dados otimizarem a colocação de cargas de trabalho</p>
</section>
</section>
<section id="secção-2-substituição-de-páginas-no-windows-11-o-modelo-do-conjunto-de-trabalho" class="level2" data-number="18.11">
<h2 data-number="18.11" class="anchored" data-anchor-id="secção-2-substituição-de-páginas-no-windows-11-o-modelo-do-conjunto-de-trabalho"><span class="header-section-number">18.11</span> <strong>Secção 2: Substituição de Páginas no Windows 11: O Modelo do Conjunto de Trabalho</strong></h2>
<p>O subsistema de gerenciamento de memória do Windows, refinado ao longo de décadas, opera com base num paradigma fundamentalmente diferente do Linux. Em vez de uma política de recuperação global, o Windows centra a sua estratégia em torno do <strong>conjunto de trabalho</strong> (<em>working set</em>) de cada processo individual. Esta secção explora este modelo, detalha o complexo ciclo de vida de uma página de memória e analisa os mecanismos, tanto reativos como proativos, que governam o desempenho da memória no Windows 11.</p>
<section id="a-primazia-do-conjunto-de-trabalho-do-processo" class="level3" data-number="18.11.1">
<h3 data-number="18.11.1" class="anchored" data-anchor-id="a-primazia-do-conjunto-de-trabalho-do-processo"><span class="header-section-number">18.11.1</span> <strong>2. A Primazia do Conjunto de Trabalho do Processo</strong></h3>
<p>O conceito central da gerenciamento de memória do Windows é o <strong>conjunto de trabalho do processo</strong>. Este é definido como o conjunto de páginas no espaço de endereçamento virtual de um processo que estão atualmente residentes na memória física Esta arquitetura implementa uma</p>
<p><strong>política de substituição de páginas local</strong>, o que significa que, quando a memória se torna escassa, as decisões de substituição são tomadas principalmente dentro do contexto de um único processo, em vez de uma perspetiva global de todo o sistema</p>
<p>Cada processo no Windows tem associado um <strong>tamanho mínimo e máximo do conjunto de trabalho</strong>. O gestor de memória tenta manter pelo menos o número mínimo de páginas de um processo na memória enquanto este está ativo. Se um processo exceder o seu tamanho máximo, ou se houver uma pressão de memória em todo o sistema, o gestor de memória iniciará um processo de “corte” (<em>trimming</em>), removendo páginas do seu conjunto de trabalho Estes limites podem ser consultados e modificados programaticamente através de funções da API do Win32 como</p>
<p>GetProcessWorkingSetSize e SetProcessWorkingSetSize, embora a manipulação direta destes valores seja geralmente desaconselhada, pois pode degradar o desempenho do sistema</p>
</section>
<section id="o-ciclo-de-vida-da-página-uma-viagem-pelas-listas-de-páginas" class="level3" data-number="18.11.2">
<h3 data-number="18.11.2" class="anchored" data-anchor-id="o-ciclo-de-vida-da-página-uma-viagem-pelas-listas-de-páginas"><span class="header-section-number">18.11.2</span> <strong>2. O Ciclo de Vida da Página: Uma Viagem Pelas Listas de Páginas</strong></h3>
<p>O estado de uma página de memória no Windows é muito mais complexo do que simplesmente estar “residente” ou “não residente”. Uma página passa por um ciclo de vida bem definido, movendo-se entre várias listas geridas pelo gestor de memória. A compreensão deste fluxo é permite entender a estratégia de substituição de páginas do Windows, e a fonte definitiva para estes detalhes é a série de livros “Windows Internals”</p>
<p>As principais listas e estados de página são 33:</p>
<ul>
<li><strong>Ativa/Válida</strong>: A página está no conjunto de trabalho de um processo e tem uma Entrada de Tabela de Páginas (PTE) válida que mapeia o seu endereço virtual para um endereço físico.<br>
</li>
<li><strong>Transição</strong>: Um estado temporário para uma página que foi removida de um conjunto de trabalho mas que ainda está na memória. Pode estar a sofrer uma operação de E/S ou a ser movida para outra lista<br>
</li>
<li><strong>Lista de Espera (Standby List)</strong>: Esta é talvez a estrutura de dados mais importante na estratégia de cache do Windows. Contém páginas que foram removidas de um conjunto de trabalho mas que estão “limpas”, ou seja, o seu conteúdo na memória corresponde ao que está em disco (seja no arquivo original ou no arquivo de paginação). Estas páginas são essencialmente uma cache. Se um processo precisar de uma página que está na lista de espera, pode recuperá-la através de uma “falha de página suave” (<em>soft page fault</em>) muito rápida, sem necessidade de aceder ao disco A lista de espera é priorizada; quando o sistema precisa de memória, as páginas de processos de baixa prioridade são reutilizadas primeiro<br>
</li>
<li><strong>Lista Modificada (Modified List)</strong>: Contém páginas “sujas” que foram removidas de um conjunto de trabalho. Estas páginas foram alteradas na memória e o seu novo conteúdo deve ser escrito no arquivo de paginação antes de poderem ser reutilizadas. Um <em>thread</em> do sistema, o “escritor de páginas modificadas”, é responsável por esta tarefa, movendo as páginas para a lista de espera assim que a escrita é concluída<br>
</li>
<li><strong>Lista Zerada (Zeroed List)</strong>: Uma lista de páginas que foram preenchidas com zeros e estão prontas para serem alocadas imediatamente a um processo para dados privados. Estas satisfazem as “falhas de demanda-zero” (<em>demand-zero faults</em>)<br>
</li>
<li><strong>Lista Livre (Free List)</strong>: Contém páginas que foram libertadas mas que ainda contêm dados antigos. Por razões de segurança, estas páginas devem ser movidas para a lista zerada antes de serem entregues a um processo em modo de utilizador</li>
</ul>
<p><strong>Tabela 2: Transições de Estado de uma Página de Memória no Windows 11</strong></p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Lista/Estado da Página</th>
<th style="text-align: left;">Descrição</th>
<th style="text-align: left;">Gatilho de Transição de Entrada</th>
<th style="text-align: left;">Gatilho de Transição de Saída</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Livre</strong></td>
<td style="text-align: left;">Páginas não utilizadas que contêm dados residuais.</td>
<td style="text-align: left;">Processo termina e liberta as suas páginas.</td>
<td style="text-align: left;"><em>Thread</em> de zeragem do sistema move a página para a lista Zerada.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Zerada</strong></td>
<td style="text-align: left;">Páginas preenchidas com zeros, prontas para alocação.</td>
<td style="text-align: left;"><em>Thread</em> de zeragem limpa uma página da lista Livre.</td>
<td style="text-align: left;">Alocação para um processo (falha de demanda-zero).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ativa (Conjunto de Trabalho)</strong></td>
<td style="text-align: left;">Páginas atualmente em uso por um processo.</td>
<td style="text-align: left;">Falha de página (dura ou suave) resolvida.</td>
<td style="text-align: left;">Corte do conjunto de trabalho pelo gestor de memória.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Espera (Standby)</strong></td>
<td style="text-align: left;">Cache de páginas limpas recentemente removidas dos conjuntos de trabalho.</td>
<td style="text-align: left;">Corte do conjunto de trabalho de uma página limpa; escritor de páginas modificadas termina a escrita de uma página.</td>
<td style="text-align: left;">Falha de página suave por um processo; reutilizada para uma nova alocação quando a memória é necessária.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Modificada</strong></td>
<td style="text-align: left;">Páginas “sujas” removidas dos conjuntos de trabalho que precisam ser escritas em disco.</td>
<td style="text-align: left;">Corte do conjunto de trabalho de uma página modificada.</td>
<td style="text-align: left;">Escritor de páginas modificadas move a página para a lista de Espera após a escrita.</td>
</tr>
</tbody>
</table>
</section>
<section id="o-gestor-do-conjunto-de-trabalho-e-a-lógica-de-corte" class="level3" data-number="18.11.3">
<h3 data-number="18.11.3" class="anchored" data-anchor-id="o-gestor-do-conjunto-de-trabalho-e-a-lógica-de-corte"><span class="header-section-number">18.11.3</span> <strong>2. O Gestor do Conjunto de Trabalho e a Lógica de Corte</strong></h3>
<p>O <strong>Gestor do Conjunto de Trabalho</strong> (<em>Working Set Manager</em>) é o componente do <code>kernel</code> responsável por aplicar as políticas de memória, incluindo a aplicação das quotas do conjunto de trabalho e o corte de páginas quando a memória disponível no sistema se torna escassa</p>
<p>Quando o gestor decide cortar o conjunto de trabalho de um processo, ele não escolhe as páginas aleatoriamente. A implementação real é uma variação do <strong>algoritmo do Relógio</strong>. O gestor varre as tabelas de páginas do processo. Para cada página, ele verifica o bit de “acessado” na sua PTE. Se o bit estiver definido (indicando que a página foi acessada recentemente), o gestor simplesmente limpa o bit e passa para a página seguinte, dando-lhe uma “segunda oportunidade”. Se o gestor encontrar uma página cujo bit de acessado já está limpo (o que significa que não foi acessada desde o último varrimento), essa página torna-se uma candidata principal para ser removida do conjunto de trabalho e movida para a lista de Espera ou Modificada Este método fornece uma aproximação eficiente e de baixo custo ao LRU, evitando a necessidade de manter carimbos de tempo ou listas ordenadas para cada acesso à memória.</p>
</section>
<section id="gerenciamento-proativa-e-cache-superfetch-e-a-lista-de-espera" class="level3" data-number="18.11.4">
<h3 data-number="18.11.4" class="anchored" data-anchor-id="gerenciamento-proativa-e-cache-superfetch-e-a-lista-de-espera"><span class="header-section-number">18.11.4</span> <strong>2. Gerenciamento Proativa e Cache: SuperFetch e a Lista de Espera</strong></h3>
<p>A gerenciamento de memória do Windows não é puramente reativa. Tecnologias como o <strong>SuperFetch</strong> (agora integrado no serviço SysMain) desempenham um papel proativo. O SuperFetch analisa os padrões de utilização históricos do utilizador para prever que aplicações e dados serão provavelmente necessários em breve. Em seguida, carrega proativamente esses dados do disco para a</p>
<p><strong>Lista de Espera</strong> durante os períodos de inatividade do sistema</p>
<p>Este mecanismo de cache proativa é um pilar do desempenho percebido do Windows. Quando um utilizador inicia uma aplicação frequentemente utilizada, é muito provável que as suas páginas de código e dados já estejam na Lista de Espera. O que seriam falhas de página “duras” e lentas (que requerem leitura do disco) transformam-se em falhas de página “suaves” e quase instantâneas (que apenas requerem a re-mapeação de uma página já na RAM) Esta estratégia é uma otimização clara para o desempenho interativo do utilizador em ambientes de</p>
<p><em>desktop</em>, onde os padrões de lançamento de aplicações são relativamente previsíveis. A filosofia subjacente é que a RAM vazia é RAM desperdiçada; é mais benéfico usar qualquer memória disponível para armazenar em cache dados que possam ser necessários, em vez de a deixar ociosa</p>
<p>A própria Lista de Espera funciona como uma cache global de segunda oportunidade, do tipo LRU. Uma página cortada do conjunto de trabalho de um processo não é imediatamente perdida. Permanece na Lista de Espera, disponível para ser rapidamente recuperada pelo mesmo processo ou, no caso de DLLs partilhadas, por qualquer outro processo que necessite dela, tudo sem E/S de disco Este design é uma solução arquitetônica elegante que liga a política de substituição local (por processo) à necessidade de eficiência global (em todo o sistema). A decisão de corte é local, mas o destino da página é gerido numa cache global e priorizada, mitigando as desvantagens de uma política puramente local e transformando uma simples remoção local numa decisão de cache global diferida.</p>
</section>
</section>
<section id="análise-comparativa-e-implicações-de-desempenho" class="level2" data-number="18.12">
<h2 data-number="18.12" class="anchored" data-anchor-id="análise-comparativa-e-implicações-de-desempenho"><span class="header-section-number">18.12</span> Análise Comparativa e Implicações de Desempenho</h2>
<p>As abordagens do Linux e do Windows à substituição de páginas, embora ambas visem o objetivo comum de uma gerenciamento de memória eficiente, divergem em filosofia, implementação e implicações de desempenho. Esta secção contrasta diretamente estas duas estratégias, analisando as suas filosofias de recuperação, complexidade de implementação e as ferramentas disponíveis para a sua observação e diagnóstico.</p>
<section id="filosofia-algorítmica-recuperação-local-vs.-global" class="level3" data-number="18.12.1">
<h3 data-number="18.12.1" class="anchored" data-anchor-id="filosofia-algorítmica-recuperação-local-vs.-global"><span class="header-section-number">18.12.1</span> <strong>3. Filosofia Algorítmica: Recuperação Local vs.&nbsp;Global</strong></h3>
<p>A diferença mais fundamental entre os dois sistemas reside no âmbito da sua política de substituição.</p>
<ul>
<li><strong>Windows (Local)</strong>: A abordagem do Windows, centrada no conjunto de trabalho, é inerentemente <strong>local</strong> Quando a memória é necessária, o Gestor do Conjunto de Trabalho visa principalmente os processos que excedem as suas quotas ou o sistema como um todo sob pressão. A decisão de qual página remover é tomada dentro do contexto de um processo específico A principal vantagem desta abordagem é o<br>
<strong>forte isolamento entre processos</strong>. Um processo com uso intensivo de memória terá principalmente as <em>suas próprias</em> páginas cortadas, protegendo o desempenho de outras aplicações bem-comportadas. Isto proporciona uma maior justiça e previsibilidade no comportamento entre processos, uma característica desejável em ambientes de <em>desktop</em> multi-tarefa.<br>
</li>
<li><strong>Linux (Global)</strong>: Em contraste, a política do Linux com <strong>MGLRU</strong> é fundamentalmente <strong>global</strong> (ou, mais precisamente, por nó NUMA e por <code>cgroup</code>) Quando a memória precisa de ser recuperada, o <strong>MGLRU</strong> procura a página mais fria em todo o sistema (dentro dos limites de um nó/<code>cgroup</code>), independentemente do processo a que pertence O objetivo é a<br>
<strong>eficiência máxima a nível do sistema</strong>. Ao expulsar a página globalmente menos útil, o sistema otimiza a utilização da RAM como um todo. A desvantagem é que isto pode levar a cenários em que a memória de um processo de baixa prioridade mas ativo é recuperada para beneficiar um processo de alta prioridade, o que pode parecer menos “justo” do ponto de vista de um único processo. A introdução de <em>memory <code>cgroup</code>s</em> no Linux mitiga isto, permitindo aos administradores criar limites de memória e hierarquias, aproximando o modelo global de um comportamento mais localizado quando necessário</li>
</ul>
</section>
<section id="implementação-complexidade-e-custo" class="level3" data-number="18.12.2">
<h3 data-number="18.12.2" class="anchored" data-anchor-id="implementação-complexidade-e-custo"><span class="header-section-number">18.12.2</span> <strong>3. Implementação, Complexidade e Custo</strong></h3>
<p>As filosofias contrastantes refletem-se na complexidade e no custo das suas implementações.</p>
<ul>
<li><strong>Linux (</strong>MGLRU<strong>)</strong>: O processo de envelhecimento do <strong>MGLRU</strong> depende de <strong>varrimentos periódicos das tabelas de páginas</strong> para detetar bits de acesso Embora concebido para ser muito mais eficiente do que os varrimentos<br>
rmap do sistema split-LRU anterior 16, esta atividade de fundo tem um custo de CPU não trivial. As estruturas de dados, com múltiplas listas geracionais por nó e por <code>cgroup</code>, juntamente com níveis e mecanismos de feedback, representam uma complexidade considerável, otimizada para escalabilidade e tomada de decisão granular.<br>
</li>
<li><strong>Windows (Conjunto de Trabalho)</strong>: A abordagem do Windows utiliza um <strong>algoritmo do tipo Relógio</strong> para cortar os conjuntos de trabalho O custo deste varrimento é localizado no evento de corte e no processo específico que está a ser cortado. No entanto, a complexidade do Windows reside na intrincada rede de listas de páginas globais (Espera, Modificada, Zerada, Livre) e nas transições entre elas. A gerenciamento desta “cadeia de abastecimento” de páginas, juntamente com serviços proativos como o SuperFetch, constitui a maior parte da complexidade do seu gestor de memória.</li>
</ul>
</section>
<section id="observabilidade-diagnóstico-e-ajuste" class="level3" data-number="18.12.3">
<h3 data-number="18.12.3" class="anchored" data-anchor-id="observabilidade-diagnóstico-e-ajuste"><span class="header-section-number">18.12.3</span> <strong>3. Observabilidade, Diagnóstico e Ajuste</strong></h3>
<p>Para administradores de sistemas e programadores, compreender como monitorizar estas estratégias permite o diagnóstico de problemas de desempenho.</p>
<ul>
<li><strong>Windows</strong>: As ferramentas principais são o <strong>Gestor de Tarefas</strong> e, para uma análise mais detalhada, o <strong>Monitor de Recursos (resmon.exe)</strong> A métrica mais importante a observar no separador Memória do Monitor de Recursos é<br>
<strong>“Falhas Graves/s” (Hard Faults/sec)</strong>. Uma falha grave ocorre quando o sistema tem de ir ao arquivo de paginação em disco para recuperar uma página, porque esta não foi encontrada nem no conjunto de trabalho do processo nem na Lista de Espera Um número consistentemente elevado de falhas graves é um indicador inequívoco de pressão de memória, significando que o sistema está a depender fortemente do disco para satisfazer as necessidades de memória das aplicações<br>
</li>
<li><strong>Linux</strong>: A ferramenta de linha de comandos padrão para este fim é o vmstat As colunas críticas a observar são<br>
si (<em>swap-in</em>) e so (<em>swap-out</em>). Valores diferentes de zero nestas colunas indicam que o sistema está ativamente a mover páginas anônimas de e para o dispositivo de <em>swap</em> A atividade de<br>
<em>swap-out</em> (so) é uma consequência direta do algoritmo de substituição de páginas a expulsar páginas anônimas sob pressão de memória. Outras ferramentas, como o sar do pacote sysstat, também fornecem estatísticas detalhadas de paginação e <em>swapping</em> ao longo do tempo</li>
</ul>
<p><strong>Tabela 3: Contadores de Desempenho Chave para Análise de Substituição de Páginas</strong></p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Métrica/Contador</th>
<th style="text-align: left;">Sistema Operativo</th>
<th style="text-align: left;">Ferramenta(s)</th>
<th style="text-align: left;">Interpretação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Falhas Graves/s</strong></td>
<td style="text-align: left;">Windows 11</td>
<td style="text-align: left;">Monitor de Recursos, Monitor de Desempenho</td>
<td style="text-align: left;">Indica páginas a serem lidas do pagefile.sys porque não foram encontradas no conjunto de trabalho de um processo ou na Lista de Espera. Um valor elevado e sustentado indica uma pressão de memória significativa.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>si / so</strong></td>
<td style="text-align: left;">Linux</td>
<td style="text-align: left;">vmstat</td>
<td style="text-align: left;">si: Páginas movidas do <em>swap</em> para a memória (KB/s). so: Páginas movidas da memória para o <em>swap</em> (KB/s). Um valor so consistentemente diferente de zero indica que o sistema está a expulsar ativamente páginas anônimas devido a pressão de memória.</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4: Comparação Arquitetônica do </strong>MGLRU** do Linux e do Modelo de Conjunto de Trabalho do Windows**</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Aspeto Arquitetónico</th>
<th style="text-align: left;">Linux (<strong>MGLRU</strong>)</th>
<th style="text-align: left;">Windows 11 (Conjunto de Trabalho)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Âmbito da Substituição</strong></td>
<td style="text-align: left;">Global (por nó/<code>cgroup</code>)</td>
<td style="text-align: left;">Local (por processo)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Objetivo Principal</strong></td>
<td style="text-align: left;">Eficiência a nível do sistema</td>
<td style="text-align: left;">Isolamento de processos e desempenho interativo</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Conceito Central</strong></td>
<td style="text-align: left;">Gerações de recenticidade</td>
<td style="text-align: left;">Conjunto de trabalho do processo</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Estruturas de Dados Chave</strong></td>
<td style="text-align: left;">lrugen com múltiplas listas de <em>folios</em></td>
<td style="text-align: left;">Tabelas de páginas por processo + listas globais de Espera/Modificada</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Gatilho de Remoção</strong></td>
<td style="text-align: left;">Envelhecimento da página para a geração mais antiga</td>
<td style="text-align: left;">Corte do conjunto de trabalho sob pressão de memória</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="secção-4-o-futuro-da-substituição-de-páginas-adaptação-a-novos-paradigmas" class="level2" data-number="18.13">
<h2 data-number="18.13" class="anchored" data-anchor-id="secção-4-o-futuro-da-substituição-de-páginas-adaptação-a-novos-paradigmas"><span class="header-section-number">18.13</span> <strong>Secção 4: O Futuro da Substituição de Páginas: Adaptação a Novos Paradigmas</strong></h2>
<p>Os algoritmos de substituição de páginas não são estáticos; evoluem continuamente para se adaptarem a novas tecnologias de hardware e a avanços em software. O campo está à beira de mudanças paradigmáticas impulsionadas por hierarquias de memória mais complexas e pela aplicação de inteligência artificial aos problemas centrais dos sistemas operativos.</p>
<section id="a-influência-do-hardware-moderno-memória-em-camadas" class="level3" data-number="18.13.1">
<h3 data-number="18.13.1" class="anchored" data-anchor-id="a-influência-do-hardware-moderno-memória-em-camadas"><span class="header-section-number">18.13.1</span> <strong>4. A Influência do Hardware Moderno: Memória em Camadas</strong></h3>
<p>O panorama do hardware de memória está a mudar fundamentalmente. Durante décadas, o modelo foi simples: uma camada de DRAM rápida e volátil e uma camada de armazenamento em disco lento e persistente. No entanto, o surgimento de <strong>sistemas de memória em camadas</strong> (<em>tiered memory</em>) está a quebrar este binário. Estes sistemas combinam DRAM rápida mas cara com tecnologias mais lentas mas de maior capacidade e mais baratas, como a <strong>Memória Não-Volátil (NVM)</strong> ligada através de NVMe, ou memória adicional ligada através do barramento <strong>Compute Express Link (CXL)</strong></p>
<p>Isto transforma o problema da substituição de páginas. Não se trata apenas de decidir se uma página deve estar na RAM ou em disco. Em vez disso, torna-se um problema mais geral de <strong>colocação ou migração de páginas</strong> entre múltiplas camadas de memória com diferentes características de latência e largura de banda O objetivo é manter os dados mais “quentes” (acessados com mais frequência) na camada mais rápida (DRAM) e mover os dados mais “frios” para as camadas mais lentas (NVM/CXL), usando o disco apenas como último recurso.</p>
<p>A investigação nesta área está a explorar novas políticas adaptadas a esta realidade. Um exemplo é a política de <strong>“promoção rápida e despromoção lenta”</strong> proposta no <em>framework</em> MTM (<em>Multi-Tiered memory Management</em>) Nesta abordagem, as páginas quentes identificadas em qualquer camada inferior são promovidas diretamente para a camada mais rápida, contornando as camadas intermédias para minimizar a latência. Em contrapartida, quando uma página precisa de ser despromovida da camada mais rápida, é movida cautelosamente para a camada imediatamente inferior. Esta estratégia cria uma gerenciamento hierárquica muito mais sofisticada do que o simples binário memória/disco, e é provável que os futuros gestores de memória do <code>kernel</code> incorporem lógicas semelhantes.</p>
</section>
<section id="o-amanhecer-dos-algoritmos-aprendidos" class="level3" data-number="18.13.2">
<h3 data-number="18.13.2" class="anchored" data-anchor-id="o-amanhecer-dos-algoritmos-aprendidos"><span class="header-section-number">18.13.2</span> <strong>4. O Amanhecer dos Algoritmos Aprendidos</strong></h3>
<p>Talvez a fronteira mais excitante na investigação de substituição de páginas seja a aplicação de <strong>aprendizagem automática (Machine Learning - ML)</strong> ao problema A lógica por trás desta abordagem é que os algoritmos baseados em heurísticas, como o LRU e as suas aproximações, são, na melhor das hipóteses, uma tentativa de adivinhar o futuro com base no passado. Um modelo de ML, no entanto, poderia potencialmente</p>
<p><em>aprender</em> os padrões de acesso específicos de uma carga de trabalho e fazer previsões muito mais precisas.</p>
<p>A investigação de vanguarda está a explorar o uso de modelos como redes neuronais de <strong>Memória de Curto e Longo Prazo (LSTM - Long Short-Term Memory)</strong> para analisar o histórico de acessos a páginas de uma aplicação Ao treinar com este histórico, o modelo pode aprender as dependências temporais complexas nos padrões de acesso de um programa. Quando uma substituição de página é necessária, o modelo treinado pode então prever qual das páginas atualmente na memória tem a menor probabilidade de ser acessada no futuro próximo, aproximando-se assim do desempenho do algoritmo Ótimo teórico para essa carga de trabalho específica</p>
<p>Esta abordagem representa uma potencial mudança de paradigma, passando de heurísticas criadas manualmente e de aplicação geral para políticas orientadas por dados e aprendidas dinamicamente. No entanto, os desafios são significativos. A execução de modelos de ML complexos dentro do <em>path</em> crítico do gestor de memória do <code>kernel</code> impõe um custo computacional considerável. A investigação está focada em desenvolver modelos leves e eficientes e em encontrar formas de realizar o treino e a inferência online sem impactar negativamente o desempenho do sistema. À medida que o hardware de IA se torna mais integrado nos processadores, a viabilidade de “algoritmos de substituição de páginas aprendidos” aumenta, prometendo um futuro onde o sistema operativo se adapta inteligentemente ao comportamento único de cada aplicação</p>
</section>
</section>
<section id="conclusão-sintetizando-duas-décadas-de-evolução-algorítmica" class="level2" data-number="18.14">
<h2 data-number="18.14" class="anchored" data-anchor-id="conclusão-sintetizando-duas-décadas-de-evolução-algorítmica"><span class="header-section-number">18.14</span> <strong>Conclusão: Sintetizando Duas Décadas de Evolução Algorítmica</strong></h2>
<p>A análise detalhada dos mecanismos de substituição de páginas no Windows 11 e nos kernels Linux mais recentes revela dois sistemas altamente sofisticados que evoluíram muito para além dos algoritmos de manual. Ambos representam soluções maduras e robustas para o desafio fundamental da gerenciamento de memória virtual, embora tenham chegado a esse ponto através de filosofias de design distintas, moldadas por diferentes prioridades e histórias evolutivas.</p>
<p>A abordagem do <strong>Windows 11</strong> pode ser caracterizada como um sistema maduro, focado localmente e fortemente otimizado para o desempenho interativo do utilizador. O seu modelo de conjunto de trabalho por processo fornece um forte isolamento e previsibilidade, enquanto a sua complexa rede de listas de páginas — em particular a Lista de Espera — funciona como uma camada de cache global extremamente eficaz. Tecnologias proativas como o SuperFetch sublinham uma filosofia de design que prioriza a capacidade de resposta percebida em cenários de <em>desktop</em>, antecipando as necessidades do utilizador e utilizando agressivamente a RAM disponível para acelerar as operações comuns.</p>
<p>Por outro lado, a abordagem do <strong>Linux moderno</strong> é a de um sistema focado globalmente que passou recentemente por uma grande evolução arquitetônica com a introdução do ****MGLRU****. Esta mudança foi uma resposta direta aos desafios de escalabilidade e eficiência impostos pelo hardware moderno de grande escala, como servidores com terabytes de RAM e um grande número de núcleos de CPU. Ao substituir o sistema grosseiro de duas listas por uma hierarquia granular de gerações baseada no tempo, o Linux melhorou drasticamente a sua capacidade de tomar decisões de remoção inteligentes com um custo de CPU muito menor, tornando-o excecionalmente adequado para centros de dados e cargas de trabalho de alto desempenho onde a eficiência a nível do sistema é primordial.</p>
<p>Em última análise, tanto o Windows 11 como o Linux demonstram um profundo entendimento dos compromissos inerentes à gerenciamento de memória. Não existe uma solução única “correta”; em vez disso, cada sistema operativo otimizou a sua estratégia para o seu ecossistema e casos de uso alvo. Olhando para o futuro, é claro que esta evolução está longe de terminar. A proliferação de hardware de memória em camadas e os avanços promissores em algoritmos orientados por aprendizagem automática garantirão que a arte e a ciência da substituição de páginas continuarão a ser um campo dinâmico e crítico da ciência da computação, com ambos os sistemas a adaptarem-se para enfrentar os desafios da próxima geração de computação. ## Métricas de Avaliação</p>
<section id="métricas-primárias" class="level3" data-number="18.14.1">
<h3 data-number="18.14.1" class="anchored" data-anchor-id="métricas-primárias"><span class="header-section-number">18.14.1</span> Métricas Primárias</h3>
<p><strong>Page Fault Rate</strong>: <span class="math inline">\(PFR = \frac{\text{número de faltas}}{\text{número total de acessos}}\)</span></p>
<p><strong>Working Set Size</strong>: <span class="math inline">\(WSS = |W(t, \tau)|\)</span> - número de páginas únicas acessadas</p>
<p><strong>Thrashing Indicator</strong>: <span class="math inline">\(TI = \frac{\text{tempo em I/O}}{\text{tempo total de CPU}}\)</span></p>
</section>
<section id="métricas-secundárias" class="level3" data-number="18.14.2">
<h3 data-number="18.14.2" class="anchored" data-anchor-id="métricas-secundárias"><span class="header-section-number">18.14.2</span> Métricas Secundárias</h3>
<p><strong>Temporal Locality</strong>: Medida de reutilização recente <strong>Spatial Locality</strong>: Medida de acessos sequenciais<br>
<strong>Phase Behavior</strong>: Estabilidade do working set</p>
</section>
<section id="metodologia-de-avaliação" class="level3" data-number="18.14.3">
<h3 data-number="18.14.3" class="anchored" data-anchor-id="metodologia-de-avaliação"><span class="header-section-number">18.14.3</span> Metodologia de Avaliação</h3>
<p>Para avaliar algoritmos de substituição:</p>
<ol type="1">
<li><strong>Trace collection</strong>: Capturar _string_s de referência reais</li>
<li><strong>Simulation</strong>: Executar algoritmos com parâmetros variados</li>
<li><strong>Statistical analysis</strong>: Médias, variâncias, distribuições</li>
<li><strong>Workload characterization</strong>: Identificar padrões de acesso</li>
</ol>
</section>
<section id="tendências-emergentes" class="level3" data-number="18.14.4">
<h3 data-number="18.14.4" class="anchored" data-anchor-id="tendências-emergentes"><span class="header-section-number">18.14.4</span> Tendências Emergentes</h3>
<section id="algoritmos-learning-based" class="level4" data-number="18.14.4.1">
<h4 data-number="18.14.4.1" class="anchored" data-anchor-id="algoritmos-learning-based"><span class="header-section-number">18.14.4.1</span> Algoritmos Learning-Based</h4>
<p>Utilização de machine learning para prever padrões de acesso:</p>
<ul>
<li><strong>Neural networks</strong>: Para predição de working sets</li>
<li><strong>Reinforcement learning</strong>: Otimização adaptativa de parâmetros</li>
<li><strong>Statistical models</strong>: Análise de comportamento temporal</li>
</ul>
</section>
<section id="memory-disaggregation" class="level4" data-number="18.14.4.2">
<h4 data-number="18.14.4.2" class="anchored" data-anchor-id="memory-disaggregation"><span class="header-section-number">18.14.4.2</span> Memory Disaggregation</h4>
<p>Separação física entre computação e memória:</p>
<ul>
<li><strong>Remote memory access</strong>: Latências variáveis</li>
<li><strong>Tiered memory</strong>: Múltiplos níveis de velocidade</li>
<li><strong>Network-attached memory</strong>: Novos modelos de custo</li>
</ul>
</section>
<section id="non-volatile-memory" class="level4" data-number="18.14.4.3">
<h4 data-number="18.14.4.3" class="anchored" data-anchor-id="non-volatile-memory"><span class="header-section-number">18.14.4.3</span> Non-Volatile Memory</h4>
<p>Integração de memórias persistentes:</p>
<ul>
<li><strong>Hybrid algorithms</strong>: Combinando volátil e não-volátil</li>
<li><strong>Wear leveling</strong>: Distribuição de escritas</li>
<li><strong>Persistence-aware</strong>: Políticas que consideram durabilidade</li>
</ul>
</section>
</section>
<section id="recomendações-práticas" class="level3" data-number="18.14.5">
<h3 data-number="18.14.5" class="anchored" data-anchor-id="recomendações-práticas"><span class="header-section-number">18.14.5</span> Recomendações Práticas</h3>
<p>Para sistemas contemporâneos:</p>
<ol type="1">
<li><strong>Clock com enhancements</strong>: Para maioria dos workloads</li>
<li><strong>WSClock</strong>: Para sistemas com fases bem definidas<br>
</li>
<li><strong><em>aging</em></strong>: Para aplicações críticas com overhead aceitável</li>
<li><strong>Algoritmos híbridos</strong>: Combinando múltiplas estratégias</li>
</ol>
<p>A evolução dos algoritmos de substituição continua driven pela necessidade de adaptar-se a novos padrões de hardware, workloads emergentes e restrições energéticas. O futuro provavelmente verá algoritmos ainda mais sofisticados que aproveitam inteligência artificial e características específicas de hardware para otimizar decisões de substituição em tempo real.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./12Agermem.html" class="pagination-link" aria-label="A Arquitetura da Ilusão: Um Mergulho Profundo no Gerenciamento de Memória Virtual">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">A Arquitetura da Ilusão: Um Mergulho Profundo no Gerenciamento de Memória Virtual</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./12Zgermem.html" class="pagination-link" aria-label="Gestão de Memória - Referências">
        <span class="nav-page-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Gestão de Memória - Referências</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/edit/main/12Bgermem.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>