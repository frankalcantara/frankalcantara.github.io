<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sistemas Operacionais - Gerenciamento de Processos: Introdução</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./gerproc1.html" rel="next">
<link href="./intro3.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/styles.css">
<meta property="og:title" content="Sistemas Operacionais - Gerenciamento de Processos: Introdução">
<meta property="og:description" content="">
<meta property="og:site_name" content="Sistemas Operacionais">
<meta name="twitter:title" content="Sistemas Operacionais - Gerenciamento de Processos: Introdução">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./gerproc.html">Gerenciamento de Processos: Introdução</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Sistemas Operacionais</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linefollower" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Sistemas Operacionais: Equilibrando Recursos e Simplicidade</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Exercícios</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Introdução: Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./gerproc.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Gerenciamento de Processos: Introdução</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Criando Processos de Forma Programática: O Modelo Linux</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Processos de Sistema: <strong>Linux</strong> vs.&nbsp;Windows</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Controle de Processos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Untitled</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Simuladores e Projetos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12germem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Gestão de Memória</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13gerfiles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Gestão de Arquivos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14geres.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Gestão de Entrada/Saída</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15gerredes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Gestão de Conectividade e Comunicação</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16gerseg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Segurança</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2arqui.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Arquiteturas de Sistemas Operacionais: Estruturando a Complexidade</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3heterox.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Tendências Avançadas em Sistemas Operacionais</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18glossa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Glossário - Sistemas Operacionais: Fundamentos e Evolução</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19exerc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Exercícios Resolvidos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#fundamentos-da-arquitetura-de-processos-e-threads" id="toc-fundamentos-da-arquitetura-de-processos-e-threads" class="nav-link active" data-scroll-target="#fundamentos-da-arquitetura-de-processos-e-threads">Fundamentos da arquitetura de processos e threads</a>
  <ul class="collapse">
  <li><a href="#sec-processos1" id="toc-sec-processos1" class="nav-link" data-scroll-target="#sec-processos1">Processos</a></li>
  <li><a href="#sec-thread1" id="toc-sec-thread1" class="nav-link" data-scroll-target="#sec-thread1">Threads</a></li>
  </ul></li>
  <li><a href="#processos-a-nível-de-usuário-nascimento-vida-e-morte-de-tarefas" id="toc-processos-a-nível-de-usuário-nascimento-vida-e-morte-de-tarefas" class="nav-link" data-scroll-target="#processos-a-nível-de-usuário-nascimento-vida-e-morte-de-tarefas">Processos a Nível de Usuário: Nascimento, Vida e Morte de Tarefas</a>
  <ul class="collapse">
  <li><a href="#meu-primeiro-processo-windows-11" id="toc-meu-primeiro-processo-windows-11" class="nav-link" data-scroll-target="#meu-primeiro-processo-windows-11">Meu primeiro Processo Windows 11</a></li>
  <li><a href="#meu-primeiro-processo-linux" id="toc-meu-primeiro-processo-linux" class="nav-link" data-scroll-target="#meu-primeiro-processo-linux">Meu Primeiro Processo Linux</a></li>
  <li><a href="#clico-de-vida-de-um-processo" id="toc-clico-de-vida-de-um-processo" class="nav-link" data-scroll-target="#clico-de-vida-de-um-processo">Clico de vida de um Processo</a></li>
  <li><a href="#modelos-teóricos-do-ciclo-de-vida-do-processo" id="toc-modelos-teóricos-do-ciclo-de-vida-do-processo" class="nav-link" data-scroll-target="#modelos-teóricos-do-ciclo-de-vida-do-processo">Modelos Teóricos do Ciclo de Vida do Processo</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linefollower/edit/main/gerproc.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linefollower/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-gerproc" class="quarto-section-identifier">Gerenciamento de Processos: Introdução</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\gerproc-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>Como a atenta leitora deve lembrar, os <strong>Sistemas Operacionais</strong> evoluíram de módulos de controle para gerenciar programas a fim de otimizar o uso das <code>CPU</code>s que eram muito, muito, muito caras. Ao longo de mais de <span class="math inline">\(70\)</span> anos de desenvolvimento de <strong>Sistemas Operacionais</strong> as técnicas de execução de programas em sistemas computacionais mudaram muito. Hoje, na terceira década do século XXI, <strong>o gerenciamento eficaz de processos requer coordenação sofisticada da organização de memória, algoritmos de escalonamento, comunicação entre processos e mecanismos de sincronização</strong>. Ainda assim, o gerenciamento tradicional de processos e <code>threads</code> representa apenas uma das dimensões da execução concorrente em sistemas computacionais modernos. As aplicações contemporâneas dependem de abstrações sofisticadas de execução que oferecem abordagens fundamentalmente diferentes para gerenciar concorrência, paralelismo e utilização de recursos. Essas abstrações, incluindo <code>coroutines</code>, <code>green threads</code>, <code>fibers</code>, o <code>actor model</code> e arquiteturas orientadas a eventos, emergiram de décadas de pesquisa acadêmica e representam inovações críticas em como projetamos e implementamos <strong>Sistemas Operacionais</strong>.</p>
<p>Começando com processos e <code>threads</code>, vamos explorar os fundamentos do gerenciamento de processos, desde a criação até a finalização, passando por conceitos essenciais como espaço de endereçamento virtual, tabelas de páginas e o ciclo de vida de um processo. Em seguida, vamos analisar as abstrações modernas de execução concorrente, como <code>coroutines</code>, <code>green threads</code>, <code>fibers</code>, o <code>actor model</code> e arquiteturas orientadas a eventos, destacando suas vantagens e desvantagens em relação ao modelo tradicional de processos e <code>threads</code>.</p>
<p>A afoita leitora, se segure, a jornada será longa e trabalhosa. Começamos com processos e <code>threads</code> em <strong>Sistemas Operacionais</strong> Modernos.</p>
<section id="fundamentos-da-arquitetura-de-processos-e-threads" class="level2">
<h2 class="anchored" data-anchor-id="fundamentos-da-arquitetura-de-processos-e-threads">Fundamentos da arquitetura de processos e threads</h2>
<p>Vamos começar com os conceitos fundamentais de processos e <code>threads</code>, que são essenciais para entender como os <strong>Sistemas Operacionais</strong> modernos gerenciam a execução de programas. Esses conceitos formam a base sobre a qual as abstrações mais avançadas de concorrência serão construídas.</p>
<section id="sec-processos1" class="level3">
<h3 class="anchored" data-anchor-id="sec-processos1">Processos</h3>
<p><em>Os processos, as vezes chamados de tarefas, <code>tasks</code>, são unidades fundamentais de execução em <strong>Sistemas Operacionais</strong>, definidos como instâncias de programas em execução ativa com alocações dedicadas de recursos</em>.</p>
<p>Se o arquivo executável é a planta de uma casa, o processo é a casa sendo construída, habitada e mantida. Um processo é muito mais que apenas código em memória; é um ecossistema dinâmico que possui seu próprio espaço de endereçamento, recursos alocados, como arquivos abertos e conexões de rede, e um estado de execução gerenciado pelo <code>kernel</code>. Para tanto, cada processo opera em um espaço de memória isolado, que chamaremos de <code>espaço de endereçamento</code>, organizado em quatro segmentos principais:</p>
<ul>
<li><strong>Segmento de texto</strong>: contém o código executável do programa.</li>
<li><strong>Segmento de dados</strong>: armazena variáveis globais e estáticas.</li>
<li><strong>Heap</strong>: utilizado para alocação dinâmica de memória durante a execução.</li>
<li><strong>Stack</strong>: gerencia chamadas de função e variáveis locais.</li>
</ul>
<p>Esse layout de memória garante segurança por meio do isolamento entre processos e eficiência por meio de uma organização estruturada. Nós adotaremos esta estrutura como padrão. Entretanto, a esperta leitora não deve se deixar enganar. nem todos os processos em todos os <strong>Sistemas Operacionais</strong> possuem exatamente a estrutura descrita como padrão, embora o modelo seja amplamente adotado em <strong>Sistemas Operacionais</strong> modernos, como os baseados em UNIX (Linux, macOS) e Windows. A estrutura de um processo pode variar dependendo do <strong>Sistema Operacional</strong>, da arquitetura de hardware e do design específico do sistema. Antes de prosseguirmos, abaixo estão alguns pontos que devem ser considerados sobre estas variações:</p>
<ol type="1">
<li><p><strong>Segmentos de Memória</strong>: a divisão em segmentos de texto, dados, <code>heap</code> e <code>stack</code> é comum em <strong>Sistemas Operacionais</strong> que utilizam um modelo de memória virtual, tais como <strong>Linux</strong> e Windows. No entanto, <strong>Sistemas Operacionais</strong> mais simples ou embarcados podem usar modelos mais rudimentares, como uma única região de memória para código e dados, sem separação clara.</p></li>
<li><p><strong>Sistemas Operacionais Especiais</strong>: em <strong>Sistemas Operacionais</strong> de tempo real, <strong>RTOS</strong> como o <a href="https://blackberry.qnx.com/en">QNX</a>, sistemas embarcados, como <a href="https://www.freertos.org/">FreeRTOS</a> ou <a href="https://www.windriver.com/products/vxworks">VxWorks</a>, a estrutura de processos pode ser mais simplificada, com menos camadas de abstração, devido a restrições de recursos ou requisitos de desempenho.</p></li>
<li><p><strong>Gerenciamento de Memória</strong>: em alguns <strong>Sistemas Operacionais</strong> legados ou minimalistas, como o MS-DOS, não há suporte robusto para isolamento de memória ou segmentação, o que resulta em processos com estruturas mais rudimentares, sem separação clara entre código, dados e pilha.</p></li>
<li><p><strong>Arquiteturas de Hardware</strong>: a estrutura de um processo também depende da arquitetura subjacente. Por exemplo, em arquiteturas como <strong>ARM</strong> ou <strong>RISC-V</strong>, a organização de memória pode ser adaptada para otimizar o desempenho em hardware específico.</p></li>
<li><p><strong>Sistemas Operacionais Experimentais</strong>: alguns <strong>Sistemas Operacionais</strong> experimentais ou acadêmicos podem adotar modelos de processos completamente diferentes, como microkernels, como o <a href="https://www.minix3.org/">MINIX</a>, no qual processos são mais leves e serviços do sistema são executados como processos de usuário, sistemas monolíticos com estruturas de memória personalizadas.</p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Sistemas Operacionais Experimentais</strong> Alguns <strong>Sistemas Operacionais</strong> experimentais e acadêmicos adotam modelos de processos que diferem significativamente do modelo tradicional. Aqui estão alguns exemplos notáveis:</p>
<ul>
<li><p><strong>Singularity</strong>: um <strong>Sistema Operacional</strong> experimental desenvolvido pela <a href="https://www.microsoft.com/en-us/research/">Microsoft Research</a>. O Singularity usa um modelo monolítico, mas com uma abordagem única chamada <strong>S</strong>oftware-<strong>I</strong>solated <strong>P</strong>rocesses, <strong>SIP</strong>s. Em vez de confiar em isolamento de memória baseado em hardware, como em sistemas tradicionais, o Singularity utiliza verificação de tipo em tempo de compilação e um modelo de memória personalizado para garantir isolamento entre processos. Isso elimina a necessidade de segmentação tradicional em alguns casos, já que os processos compartilham um espaço de endereçamento seguro definido pelo sistema.</p></li>
<li><p><strong>Barrelfish</strong>: um <strong>Sistema Operacional</strong> acadêmico projetado para arquiteturas multicore e heterogêneas. O <a href="https://barrelfish.org/">Barrelfish</a> adota um modelo híbrido, mas com uma estrutura de memória altamente personalizada para seus processos, chamada <code>multikernel</code>. Nesse modelo, cada núcleo do processador pode gerenciar processos de maneira independente, com estruturas de memória adaptadas ao hardware subjacente, em vez de seguir o layout clássico de segmentos de memória.</p></li>
<li><p><strong>L4</strong>: uma família de <code>microkernels</code> que enfatiza processos extremamente leves e isolamento rigoroso. No <strong>seL4</strong>, um dos sistemas desta família, os processos, <code>threads</code>, em alguns contextos, têm uma estrutura minimalista, com gerenciamento de memória projetado para segurança formalmente verificada, em vez de seguir a organização tradicional de processos.</p></li>
<li><p><strong>Plan 9</strong>: Desenvolvido pela Bell Labs, o <a href="https://p9f.org/">Plan 9</a> é um <strong>Sistema Operacional</strong> experimental que adota um modelo monolítico, mas com uma abordagem única para processos e memória. Ele utiliza um espaço de nomes por processo, no inglês per-process namespace, permitindo que cada processo tenha uma visão personalizada do sistema de arquivos e outros recursos, o que altera a forma como a memória é estruturada e acessada.</p></li>
</ul>
</div>
</div>
<div id="fig-espacoend1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-espacoend1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/memory_process_comparison.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-espacoend1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Comparação entre estruturas de processos em memória: espaço de endereçamento. À esquerda, layout típico de um <strong>Sistema Operacional</strong> moderno (Linux/UNIX) em arquitetura 64-bit, mostrando segmentação clara com stack crescendo a partir de endereços altos, <code>heap</code> com alocação dinâmica, e segmentos de dados e código em posições fixas. À direita, estrutura simplificada de sistema embarcado (FreeRTOS) em microcontrolador 32-bit, apresentando layout determinado pelo hardware com memory-mapped <code>E/S</code>, SRAM unificada para dados e stacks de tarefas, e flash separada para código. As setas indicam direções de crescimento da memória, e as áreas tracejadas representam espaços não mapeados ou livres para expansão. Note-se a ausência de MMU no sistema embarcado, resultando em acesso direto à memória física, contrastando com o modelo de memória virtual do sistema moderno.
</figcaption>
</figure>
</div>
<p>A <a href="#fig-espacoend1" class="quarto-xref">Figure&nbsp;<span>1</span></a> mostra a estrutura de memória tradicional e mais comum com a estrutura do <strong>RTOS</strong>. O processo de gestão de projetos não é trivial. O <strong>Sistema Operacional</strong> é o principal ator na gestão de processos, sendo responsável por:</p>
<ol type="1">
<li><strong>Criação e exclusão</strong>: gerencia processos de usuário, processos iniciados exclusivamente por usuários, e processos de sistema, iniciados pelo próprio <strong>Sistema Operacional</strong>.</li>
<li><strong>Suspensão e retomada</strong>: controla a pausa e retomada de processos, preservando seu estado, incluindo registradores, contador de programa e pilha.</li>
<li><strong>Sincronização de processos</strong>: coordena o acesso a recursos compartilhados para evitar condições de corrida e garantir consistência de dados.</li>
<li><strong>Comunicação entre processos</strong>: facilita a troca de informações por meio de mecanismos como pipes, sockets, memória compartilhada, mensagens ou sinais. Em inglês, a comunicação entre processos é chamada de <strong>I</strong>nter <strong>P</strong>rocess <strong>C</strong>ommunication, <strong>IPC</strong>.</li>
<li><strong>Tratamento de deadlocks</strong>: detecta e resolve situações em que processos ficam permanentemente bloqueados, assegurando a continuidade da operação do sistema.</li>
</ol>
<section id="processos-muito-além-do-executável" class="level4">
<h4 class="anchored" data-anchor-id="processos-muito-além-do-executável">Processos: muito além do executável</h4>
<p>Processo é um executável em memória usando tempo de processamento da <code>CPU</code>, mas é muito mais do que isso. É uma entidade dinâmica que encapsula a execução de um programa, incluindo seu estado, recursos alocados e contexto de execução. E aqui há um problema de semântica. Quando pensamos em executáveis esquecemos os drivers, as bibliotecas de ligação dinâmica, os processos de sistema e outros componentes que são executados pelo <strong>Sistema Operacional</strong>. No coração de cada programa e aplicativo que utilizamos, existe um arquivo executável, um conjunto de instruções que o <strong>Sistema Operacional</strong> pode entender e executar. No entanto, o formato desses arquivos varia consideravelmente entre os diferentes <strong>Sistemas Operacionais</strong>, cada um com sua própria arquitetura e filosofia de design e com a finalidade do arquivo executável. Compreender esses tipos de executáveis é fundamental para entender como o software funciona em plataformas modernas como Windows, macOS, <strong>Linux</strong> e Android.</p>
<p>Cada <strong>Sistema Operacional</strong> possui um formato primário de arquivo executável, além de outros tipos que servem a propósitos específicos.</p>
<ol type="1">
<li><p><strong>Windows</strong>: o formato mais onipresente no universo <strong>Windows</strong> é o <code>.exe</code>, em inglês <em>executable</em>. Este arquivo no formato <strong>P</strong>ortable <strong>E</strong>xecutable, <strong>PE</strong> contém o código do programa, dados, e recursos necessários para a sua execução. Além do <code>.exe</code>, tros formatos executáveis comuns incluem:</p>
<ul>
<li><code>.msi</code> (Microsoft Installer): Usado para a instalação, manutenção e remoção de software;</li>
<li><code>.bat</code> (Batch): Scripts de texto simples contendo uma série de comandos a serem executados pelo interpretador de comandos do Windows;</li>
<li><code>.com</code> (Command): Um tipo mais simples e antigo de executável, geralmente menor que um <code>.exe</code>;</li>
<li><code>.dll</code> (Dynamic Link Library): Embora não sejam executáveis diretamente pelo usuário, são bibliotecas de código que os arquivos <code>.exe</code> podem carregar e executar em tempo de execução;</li>
<li><code>.scr</code> (Screen Saver): Arquivos de proteção de tela, que são essencialmente programas <code>.exe</code> com uma extensão diferente.</li>
</ul></li>
<li><p><strong>No macOS</strong>: o sistema da Apple utiliza uma abordagem diferente. As aplicações são geralmente distribuídas como pacotes <code>.app</code>.trata-se de um diretório que encapsula todos os arquivos necessários para a aplicação funcionar, incluindo o executável principal, recursos, bibliotecas e metadados. O formato do executável binário subjacente no macOS é o <strong>Mach-O (Mach Object)</strong>. Arquivos Mach-O, muitas vezes não possuem extensão, e sua natureza executável é definida pelas permissões do sistema de arquivos, de forma similar ao Linux.</p>
<ul>
<li><code>.app</code> (Application Bundle): O formato de distribuição padrão para aplicações macOS.</li>
<li><code>.dmg</code> (Disk Image): Embora não seja um executável por si só, é um formato de contêiner comum para distribuir aplicações <code>.app</code>.</li>
<li>Scripts de Shell: Assim como no <strong>Linux</strong>, scripts com extensões como <code>.sh</code> ou sem extensão podem ser tornados executáveis.</li>
</ul></li>
<li><p><strong>No Linux</strong>: no <strong>Linux</strong>, a base para quase todo código compilado é o formato <strong>E</strong>xecutable and <strong>L</strong>inkable <strong>F</strong>ormat, <strong>ELF</strong>. No entanto, assim como no Windows, existem diferentes tipos de arquivos e componentes que utilizam este formato para propósitos distintos. A executabilidade é primariamente definida por permissões de arquivo, e não pela extensão.</p>
<ul>
<li><code>so</code> (Shared Object): Embora não sejam executáveis diretamente pelo usuário, são bibliotecas de código no formato ELF que múltiplos programas podem carregar e usar em tempo de execução para compartilhar funcionalidades comuns, de forma análoga aos arquivos <code>.dll</code> do Windows.</li>
<li><code>.ko</code> (Kernel Object): Arquivos de driver, módulos do <code>kernel</code>. São arquivos especiais em formato ELF que são carregados diretamente no núcleo (kernel) do <strong>Sistema Operacional</strong> para permitir a comunicação com o hardware. Não são executáveis no espaço do usuário.</li>
<li><strong>Scripts</strong>: Arquivos de texto (ex: <code>.sh</code>, <code>.py</code>) que se tornam executáveis através de permissões e da especificação de um interpretador (ex: <code>#!/bin/bash</code>). O <strong>Sistema Operacional</strong> executa o interpretador, que por sua vez lê e executa os comandos do script.</li>
</ul></li>
<li><p><strong>No Android</strong>: o <strong>Sistema Operacional</strong> móvel do Google, baseado no <code>kernel</code> <strong>Linux</strong>, tem seus próprios formatos de executáveis específicos para aplicações.</p>
<ul>
<li><code>.apk</code> (Android Package Kit): O formato de arquivo usado para distribuir e instalar aplicativos móveis. Um arquivo <code>.apk</code> contém o código do programa (em formato DEX), recursos, assets e o manifesto do aplicativo.</li>
<li>DEX (Dalvik Executable): Os arquivos <code>.dex</code> contêm o código de byte compilado que é executado pela <strong>Android</strong> Runtime (ART).</li>
<li>ELF: Para código nativo (C/C++), o <strong>Android</strong> utiliza o formato ELF, da mesma forma que o Linux.</li>
<li><code>.aab</code> (Android App Bundle): O formato de publicação de aplicativos na Google Play Store. O AAB inclui todo o código e recursos do aplicativo, mas a Google Play o utiliza para gerar e servir APKs otimizados para a configuração de cada dispositivo.</li>
</ul></li>
</ol>
</section>
<section id="a-sociedade-dos-processos-tipos-e-funções-no-sistema-operacional" class="level4">
<h4 class="anchored" data-anchor-id="a-sociedade-dos-processos-tipos-e-funções-no-sistema-operacional">A Sociedade dos Processos: Tipos e Funções no Sistema Operacional</h4>
<p>Compreender que nem todos os processos são criados iguais é essencial para diagnosticar problemas, gerenciar o desempenho e entender a segurança do sistema. Eles podem ser classificados de acordo com seu propósito, privilégio e interação com o usuário. A seguir, apresentamos os principais tipos de processos encontrados nos <strong>Sistemas Operacionais</strong> modernos que interagem diretamente com as tarefas definidas pelo usuário.</p>
<ol type="1">
<li><p><strong>Processos de Usuário (User Processes)</strong>: são processos iniciados direta ou indiretamente por um usuário logado no <strong>Sistema Operacional</strong>. Processos de usuário rodam no espaço do usuário, em inglês <em>user space</em>, uma área da memória com privilégios limitados, o que significa que não podem acessar diretamente o hardware ou interferir com processos críticos do sistema.</p></li>
<li><p><strong>Processos de Primeiro Plano (Foreground)</strong>: são os processos com os quais o usuário interage diretamente. Eles possuem uma interface gráfica (ou estão atrelados a um terminal de comando ativo, <code>shell</code>. São os aplicativos que você “vê” em execução. Um navegador web (Chrome, Firefox), um editor de texto (VS Code, Bloco de Notas), um player de música ou um jogo são exemplos de processos de primeiro plano.</p></li>
<li><p><strong>Processos de Segundo Plano (Background)</strong>: são processos que rodam sem uma interface direta, muitas vezes iniciados por um aplicativo de primeiro plano para executar uma tarefa específica. Neste caso, os exemplos incluem: um cliente de e-mail sincronizando suas mensagens, um programa antivírus realizando uma varredura agendada, o processo que um navegador cria para baixar um arquivo grande enquanto você continua a navegar.</p></li>
</ol>
<p>Além dos processos definidos diretamente pelas ações e necessidades do usuário, existem os processos de sistema. Estes são processos iniciados pelo próprio <strong>Sistema Operacional</strong> durante a inicialização, para funções de manutenção e integração, e que podem rodar de forma contínua para manter o sistema funcional provendo serviços essenciais. Processos de sistema existem independentemente de haver um usuário logado. Entre eles, destacamos:</p>
<ol type="1">
<li><p><strong>Daemons (Linux/macOS) e Serviços (Windows)</strong>: esta é a categoria mais importante de processos de sistema. Eles operam em segundo plano para realizar tarefas fundamentais. Nos sistemas Linux/macOS são chamados de <code>daemons</code>. Estes processos gerenciam a rede (<code>sshd</code>), agendam tarefas (<code>cron</code> ou <code>launchd</code>), gerenciam a interface gráfica, entre muitas outras coisas. O processo <code>systemd</code>, em muitas distribuições <strong>Linux</strong>, e o <code>launchd</code>, no macOS, são os “pais” de quase todos os outros <code>daemons</code> e processos do sistema. No <strong>Windows</strong> estes processos são chamados de <em>Serviços</em>. Estes processos realizam funções análogas. O processo <code>svchost.exe</code> é um anfitrião genérico que pode executar múltiplos serviços para economizar recursos. Outros exemplos incluem <code>lsass.exe</code> que gerencia a segurança e o login e o <code>services.exe</code>, o gerenciador de controle de serviços.</p></li>
<li><p><strong>Threads do Kernel</strong>:: em um nível ainda mais baixo, o próprio <code>kernel</code> executa <code>threads</code> especiais que não são processos de usuário completos. Eles lidam com tarefas internas de baixo nível, como gerenciamento de memória, operações de <code>E/S</code> e agendamento e despacho de outros processos. No <strong>Linux</strong>, por exemplo, o processo <code>kthreadd</code> é responsável por criar essas outras <code>threads</code> do <code>kernel</code>. Os <code>threads</code> serão estudados mais adiante, mas é importante notar que eles são uma parte fundamental do funcionamento interno do <strong>Sistema Operacional</strong>.</p></li>
</ol>
<section id="a-hierarquia-e-o-relacionamento-entre-processos" class="level5">
<h5 class="anchored" data-anchor-id="a-hierarquia-e-o-relacionamento-entre-processos">A Hierarquia e o Relacionamento entre Processos</h5>
<p>Os processos em sistemas como <strong>Linux</strong> e macOS existem em uma hierarquia clara, uma árvore genealógica onde cada processo tem um pai. Esta estrutura é importante por motivos de segurança e políticas de segurança. Nesta genealogia de execução temos:</p>
<ol type="1">
<li><p><strong>Processo Pai e Processo Filho (Parent/Child)</strong>: quando um processo cria outro, por exemplo, quando você digita um comando no terminal ou dá um clique duplo em um ícone, o processo original é o Pai e o novo é o Filho. O processo filho herda muitas propriedades do pai, como variáveis de ambiente e permissões. Este modelo é a base dos processos de multitarefa nesses sistemas.</p></li>
<li><p><strong>Processos Órfãos (Orphan Processes)</strong>: se um processo pai termina antes de seu processo filho, o filho se torna um órfão. Para evitar que ele fique perdido, o <strong>Sistema Operacional</strong> o adota automaticamente. No <strong>Linux</strong>, o processo <code>systemd</code> (PID 1) se torna o novo pai desses órfãos.</p></li>
<li><p><strong>Processos Zumbis (Zombie Processes)</strong>: quando um processo filho termina, ele não desaparece completamente. Ele se torna um zumbi. Sua entrada na tabela de processos do sistema é mantida para que o processo pai possa ler seu status de saída, se terminou com sucesso ou com erro. O processo pai deve ler o zumbi para liberá-lo completamente. Zumbis são normais por um curto período, mas um grande acúmulo pode indicar um problema no programa pai.</p></li>
</ol>
<p>A criação de processos, a genealogia de processos e toda estrutura de criação de processos é gerenciada pelo <strong>Sistema Operacional</strong>. O processo de criação de um novo processo é chamado de <code>fork</code>, que cria uma cópia do processo pai, e o processo filho pode então executar um programa diferente usando a chamada <code>exec</code>. O <code>fork</code> cria uma cópia exata do processo pai, incluindo seu espaço de endereçamento, mas com um novo identificador de processo (PID). A seguir, o filho pode substituir seu espaço de endereçamento com um novo programa usando <code>exec</code>, que carrega um novo executável no espaço do processo filho. Contudo, antes de nos aprofundarmos nos processos, a curiosa leitora precisa conhecer os <code>threads</code>.</p>
</section>
</section>
</section>
<section id="sec-thread1" class="level3">
<h3 class="anchored" data-anchor-id="sec-thread1">Threads</h3>
<p>os <code>threads</code> são uma evolução no conceito de execução concorrente, permitindo que múltiplas linhas de execução operem dentro de um mesmo processo, compartilhando o mesmo espaço de endereçamento de memória. Diferentemente dos processos, que exigem trocas de contexto computacionalmente caras, envolvendo atualizações completas de gerenciamento de memória, os <code>threads</code> compartilham o segmento de texto, dados e <code>heap</code>, requerendo apenas atualizações de registradores e ponteiros de <code>stack</code> durante trocas de contexto. A <a href="#tbl-threads2" class="quarto-xref">Table&nbsp;<span>1</span></a> mostra uma comparação entre processos e <code>threads</code>.</p>
<div id="tbl-threads2" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-threads2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Comparação entre as características entre processos e <code>threads</code>.
</figcaption>
<div aria-describedby="tbl-threads2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Característica</th>
<th>Processo</th>
<th>Thread</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Compartilhamento de Recursos</strong></td>
<td>Não compartilha memória diretamente com outros processos; cada um tem seu próprio espaço de endereço virtual.</td>
<td>Compartilha o espaço de endereço (código, dados, <code>heap</code>) e outros recursos (arquivos abertos) com outras threads do mesmo processo.</td>
</tr>
<tr class="even">
<td><strong>Tempo de Criação</strong></td>
<td>Leva mais tempo para ser criado, pois envolve a alocação de um novo espaço de endereço e estruturas de dados.</td>
<td>Leva menos tempo para ser criada, pois utiliza o espaço de endereço existente do processo pai.</td>
</tr>
<tr class="odd">
<td><strong>Sobrecarga de Troca de Contexto</strong></td>
<td>Maior sobrecarga, pois a troca de contexto envolve a mudança de todo o espaço de endereço virtual e do estado do hardware.</td>
<td>Menor sobrecarga, pois a troca de contexto ocorre dentro do mesmo espaço de endereço, exigindo apenas a troca de registradores e da pilha.</td>
</tr>
<tr class="even">
<td><strong>Independência</strong></td>
<td>Processos são independentes; a falha de um processo geralmente não afeta outros.</td>
<td>Threads não são completamente independentes; a falha de uma thread pode afetar outras threads do mesmo processo.</td>
</tr>
<tr class="odd">
<td><strong>Comunicação</strong></td>
<td>A comunicação entre processos (IPC) é mais complexa e requer mecanismos específicos.</td>
<td>A comunicação entre threads é mais simples, pois elas compartilham a memória, permitindo acesso direto aos dados.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>A criação de threads é geralmente mais rápida que a criação de processos, pois threads compartilham o mesmo espaço de memória. Um estudo de 2018 mediu o tempo de criação de processos em <span class="math inline">\(35 µs\)</span>$ e de <code>threads</code> em <span class="math inline">\(5 µs\)</span> para um <code>heap</code> de <span class="math inline">\(2 MB\)</span>, resultando em <code>threads</code> <span class="math inline">\(7\)</span> vezes mais rápidos. Outro benchmark de 2017 indicou que a criação de threads é <span class="math inline">\(2\)</span> a <span class="math inline">\(3\)</span> vezes mais rápida que a criação de processos. O mesmo benchmark de 2017 mostrou que a criação de threads é <span class="math inline">\(7\)</span> a <span class="math inline">\(8\)</span> vezes mais rápida que a de processos.A diferença no tempo de criação varia devido ao tamanho do contexto de execução e à implementação específica do <strong>Sistema Operacional</strong>. A <a href="#tbl-thread1" class="quarto-xref">Table&nbsp;<span>2</span></a> mostra alguns benchmarks de criação de processos e threads em diferentes <strong>Sistemas Operacionais</strong>.</p>
<div id="tbl-thread1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-thread1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Benchmarks comparativos de criação de processos e threads.
</figcaption>
<div aria-describedby="tbl-thread1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 17%">
<col style="width: 29%">
<col style="width: 27%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Sistema Operacional</strong></th>
<th>Tempo de Criação de Processo (µs)</th>
<th>Tempo de Criação de <code>Thread</code> (µs)</th>
<th>Razão (<code>Thread</code> mais rápido)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Linux</strong> (2018, 2 MB)</td>
<td>35</td>
<td>5</td>
<td>7</td>
</tr>
<tr class="even">
<td><strong>Linux</strong> (2017)</td>
<td>não indicado no estudo</td>
<td>não indicado no estudo</td>
<td>2-3</td>
</tr>
<tr class="odd">
<td>macOS (2017)</td>
<td>não indicado no estudo</td>
<td>não indicado no estudo</td>
<td>7-8</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>O conceito de <code>threads</code> surgiu para atender à necessidade de maior eficiência na execução concorrente, especialmente em sistemas com múltiplos processadores. Inicialmente, a concorrência era alcançada por meio de processos separados, mas os altos custos de troca de contexto e o isolamento de memória limitavam a performance. Na década de 1980, com o avanço dos <strong>Sistemas Operacionais</strong> e arquiteturas de hardware, as <code>threads</code> começaram a ser implementadas como uma solução leve, permitindo que múltiplas tarefas fossem executadas simultaneamente dentro de um mesmo processo. Essa abordagem ganhou tração com sistemas como <a href="https://hpc-tutorials.llnl.gov/posix/">POSIX Threads</a>, <code>Pthreads</code> e a popularização de modelos <code>multithreading</code> em <strong>Sistemas Operacionais</strong> modernos.</p>
<section id="modelos-de-multithreading" class="level4">
<h4 class="anchored" data-anchor-id="modelos-de-multithreading">Modelos de Multithreading</h4>
<p>A evolução dos modelos de <code>multithreading</code> reflete o esforço contínuo para equilibrar desempenho, paralelismo e complexidade de implementação. Os principais modelos incluem:</p>
<ol type="1">
<li><strong>Many-to-One</strong>: nesse modelo, várias <code>threads</code> de usuário são mapeadas para uma única <code>thread</code> do <code>Kernel</code> . Ele é eficiente, pois o gerenciamento ocorre no espaço do usuário, mas apresenta limitações: uma chamada de sistema bloqueante pode travar todas as <code>threads</code> do processo, reduzindo o paralelismo.</li>
<li><strong>One-to-One</strong>: cada <code>thread</code> de usuário é mapeada para uma <code>thread</code> do <code>Kernel</code>, permitindo verdadeiro paralelismo, especialmente em sistemas com múltiplos núcleos. No entanto, o envolvimento do <code>Kernel</code> aumenta o <em>overhead</em> de gerenciamento.</li>
<li><strong>Many-to-Many</strong>: considerado o modelo mais avançado, mapeia dinamicamente <code>threads</code> de usuário para <code>threads</code> do <code>Kernel</code> , combinando eficiência e paralelismo. Apesar de sua sofisticação, a complexidade de implementação ainda restringe sua adoção em larga escala.</li>
</ol>
<p>Essa evolução demonstra como as <code>threads</code> transformaram a computação moderna, oferecendo uma solução flexível e eficiente para a execução concorrente, adaptada às demandas de <strong>Sistemas Operacionais</strong> e aplicações cada vez mais complexas.</p>
</section>
</section>
</section>
<section id="processos-a-nível-de-usuário-nascimento-vida-e-morte-de-tarefas" class="level2">
<h2 class="anchored" data-anchor-id="processos-a-nível-de-usuário-nascimento-vida-e-morte-de-tarefas">Processos a Nível de Usuário: Nascimento, Vida e Morte de Tarefas</h2>
<p>Um processo é a unidade fundamental de execução de sistemas computacionais gerenciados por um <strong>Sistema Operacional</strong>, representando uma instância de um programa em andamento.</p>
<p>Como vamos começar estudando processos de usuário. Para criar um processo a esforçada leitora pode, simplesmente, dar dois cliques rápidos com o m se em um ícone de aplicativo na tela da sua máquina. Ou, se for um pouco mais audaciosa, pode abrir um terminal e digitar um comando como <code>./meu_programa</code> e teclar <code>Enter</code>. Nestes dois casos existem duas possibilidades, o <strong>Sistema Operacional</strong> entende o clique duplo e o comando e cria um processo, ele indica um erro. Nos dois casos restam algumas dúvidas. A mais importante delas é: como o <strong>Sistema Operacional</strong> transforma esse comando em uma tarefa em execução? Vamos explorar os fundamentos do gerenciamento de processos, desde a criação até a finalização, passando por conceitos essenciais como espaço de endereçamento virtual, tabelas de páginas e o ciclo de vida de um processo.</p>
<p>Se a corajosa leitora desejar pode tentar criar o seu próprio processo do zero. Para isso precisará ter configurado o seu próprio ambiente de desenvolvimento. Eu recomendo que, no <strong>Linux</strong>, você use o <a href="https://code.visualstudio.com/">Visual Studio Code</a> como editor de código, o <a href="https://cmake.org/">CMake</a> como sistema de construção e o <a href="https://llvm.org/">LLVM</a> como compilador. No Windows, você pode montar um ambiente parecido com esse ou, simplesmente usar o Visual Studio com o <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio Build Tools</a> e o <a href="https://cmake.org/">CMake</a>. No macOS, você pode usar o Visual Studio Code com o <a href="https://developer.apple.com/xcode/features/">Xcode Command Line Tools</a> e o <a href="https://cmake.org/">CMake</a>.</p>
<section id="meu-primeiro-processo-windows-11" class="level3">
<h3 class="anchored" data-anchor-id="meu-primeiro-processo-windows-11">Meu primeiro Processo Windows 11</h3>
<p>Os programas <strong>Windows</strong> são executados como processos, e o <strong>Sistema Operacional</strong> <strong>Windows</strong> 11 fornece uma API rica para criar e gerenciar esses processos. Fazer um <em>Hello World</em> seria denegrir a capacidade da esforçada leitora. Sendo assim, a seguir está um exemplo de como listar os processos que estão em execução em uma máquina rodando <strong>Windows</strong> 11, usando a API do <strong>Windows</strong> em C++23:</p>
<div id="lst-cppwindows1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-cppwindows1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;1
</figcaption>
<div aria-describedby="lst-cppwindows1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-cppwindows1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-cppwindows1-1"><a href="#lst-cppwindows1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cppwindows1-2"><a href="#lst-cppwindows1-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@file</span><span class="co"> </span><span class="cv">process_lister.cpp</span></span>
<span id="lst-cppwindows1-3"><a href="#lst-cppwindows1-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Programa para listar processos em execução no **Windows** 11</span></span>
<span id="lst-cppwindows1-4"><a href="#lst-cppwindows1-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@author</span><span class="co"> Livro de Sistemas Operacionais</span></span>
<span id="lst-cppwindows1-5"><a href="#lst-cppwindows1-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@version</span><span class="co"> </span><span class="cv">1</span><span class="co">.</span></span>
<span id="lst-cppwindows1-6"><a href="#lst-cppwindows1-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@date</span><span class="co"> 2025</span></span>
<span id="lst-cppwindows1-7"><a href="#lst-cppwindows1-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cppwindows1-8"><a href="#lst-cppwindows1-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * Este programa demonstra como enumerar processos em execução usando</span></span>
<span id="lst-cppwindows1-9"><a href="#lst-cppwindows1-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * a **Windows** API em C++23. </span></span>
<span id="lst-cppwindows1-10"><a href="#lst-cppwindows1-10" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cppwindows1-11"><a href="#lst-cppwindows1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-12"><a href="#lst-cppwindows1-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span><span class="pp">    </span><span class="co">// API principal do **Windows** - fornece tipos básicos (DWORD, HANDLE) </span></span>
<span id="lst-cppwindows1-13"><a href="#lst-cppwindows1-13" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// e funções do sistema como OpenProcess(), CloseHandle()</span></span>
<span id="lst-cppwindows1-14"><a href="#lst-cppwindows1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-15"><a href="#lst-cppwindows1-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;psapi.h&gt;</span><span class="pp">      </span><span class="co">// Process Status API - funções específicas para enumeração de processos:</span></span>
<span id="lst-cppwindows1-16"><a href="#lst-cppwindows1-16" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// EnumProcesses(), EnumProcessModules(), GetModuleBaseNameW(),</span></span>
<span id="lst-cppwindows1-17"><a href="#lst-cppwindows1-17" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// GetProcessMemoryInfo(), QueryFullProcessImageNameW()</span></span>
<span id="lst-cppwindows1-18"><a href="#lst-cppwindows1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-19"><a href="#lst-cppwindows1-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span><span class="pp">     </span><span class="co">// Fluxos de entrada/saída padrão - std::wcout, std::wcerr, std::wcin</span></span>
<span id="lst-cppwindows1-20"><a href="#lst-cppwindows1-20" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// para exibição de texto Unicode na console</span></span>
<span id="lst-cppwindows1-21"><a href="#lst-cppwindows1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-22"><a href="#lst-cppwindows1-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span><span class="pp">       </span><span class="co">// Contêiner dinâmico std::vector para armazenar listas de ProcessInfo</span></span>
<span id="lst-cppwindows1-23"><a href="#lst-cppwindows1-23" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// e arrays de IDs de processos retornados pela API</span></span>
<span id="lst-cppwindows1-24"><a href="#lst-cppwindows1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-25"><a href="#lst-cppwindows1-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span><span class="pp">       </span><span class="co">// std::wstring para manipulação de strings Unicode (nomes e caminhos</span></span>
<span id="lst-cppwindows1-26"><a href="#lst-cppwindows1-26" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// de processos que podem conter caracteres especiais)</span></span>
<span id="lst-cppwindows1-27"><a href="#lst-cppwindows1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-28"><a href="#lst-cppwindows1-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;format&gt;</span><span class="pp">       </span><span class="co">// std::format (C++20) - formatação moderna de strings tipo printf</span></span>
<span id="lst-cppwindows1-29"><a href="#lst-cppwindows1-29" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// mas type-safe para criar tabelas e exibições formatadas</span></span>
<span id="lst-cppwindows1-30"><a href="#lst-cppwindows1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-31"><a href="#lst-cppwindows1-31" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span><span class="pp">       </span><span class="co">// std::ranges (C++20) - algoritmos funcionais modernos como</span></span>
<span id="lst-cppwindows1-32"><a href="#lst-cppwindows1-32" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// ranges::sort(), ranges::copy_if() para manipulação de dados</span></span>
<span id="lst-cppwindows1-33"><a href="#lst-cppwindows1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-34"><a href="#lst-cppwindows1-34" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span><span class="pp">    </span><span class="co">// Algoritmos STL complementares e std::back_inserter para</span></span>
<span id="lst-cppwindows1-35"><a href="#lst-cppwindows1-35" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// operações auxiliares de manipulação de contêineres</span></span>
<span id="lst-cppwindows1-36"><a href="#lst-cppwindows1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-37"><a href="#lst-cppwindows1-37" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span><span class="pp">       </span><span class="co">// Smart pointers e utilitários de gerenciamento de memória</span></span>
<span id="lst-cppwindows1-38"><a href="#lst-cppwindows1-38" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// (incluído para possíveis extensões futuras do código)</span></span>
<span id="lst-cppwindows1-39"><a href="#lst-cppwindows1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-40"><a href="#lst-cppwindows1-40" aria-hidden="true" tabindex="-1"></a><span class="co">// não espere que eu vá comentar as bibliotecas novamente. Esta foi uma concessão por ser </span></span>
<span id="lst-cppwindows1-41"><a href="#lst-cppwindows1-41" aria-hidden="true" tabindex="-1"></a><span class="co">// nosso primeiro código.</span></span>
<span id="lst-cppwindows1-42"><a href="#lst-cppwindows1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-43"><a href="#lst-cppwindows1-43" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cppwindows1-44"><a href="#lst-cppwindows1-44" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Estrutura para armazenar informações de um processo</span></span>
<span id="lst-cppwindows1-45"><a href="#lst-cppwindows1-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cppwindows1-46"><a href="#lst-cppwindows1-46" aria-hidden="true" tabindex="-1"></a><span class="co"> * Esta estrutura encapsula as informações básicas de um processo</span></span>
<span id="lst-cppwindows1-47"><a href="#lst-cppwindows1-47" aria-hidden="true" tabindex="-1"></a><span class="co"> * que serão coletadas e exibidas pelo programa.</span></span>
<span id="lst-cppwindows1-48"><a href="#lst-cppwindows1-48" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cppwindows1-49"><a href="#lst-cppwindows1-49" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ProcessInfo <span class="op">{</span></span>
<span id="lst-cppwindows1-50"><a href="#lst-cppwindows1-50" aria-hidden="true" tabindex="-1"></a>    DWORD processId<span class="op">;</span>           <span class="co">///&lt; ID do processo (PID)</span></span>
<span id="lst-cppwindows1-51"><a href="#lst-cppwindows1-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wstring processName<span class="op">;</span>  <span class="co">///&lt; Nome do executável do processo</span></span>
<span id="lst-cppwindows1-52"><a href="#lst-cppwindows1-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wstring fullPath<span class="op">;</span>     <span class="co">///&lt; Caminho completo do executável</span></span>
<span id="lst-cppwindows1-53"><a href="#lst-cppwindows1-53" aria-hidden="true" tabindex="-1"></a>    SIZE_T workingSetSize<span class="op">;</span>     <span class="co">///&lt; Tamanho do working set em bytes</span></span>
<span id="lst-cppwindows1-54"><a href="#lst-cppwindows1-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-55"><a href="#lst-cppwindows1-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-56"><a href="#lst-cppwindows1-56" aria-hidden="true" tabindex="-1"></a><span class="co">    O Tamanho do working representa a quantidade de memória física (RAM) que está atualmente sendo utilizada por um processo específico. Em **Sistemas Operacionais** com memória virtual como o Windows, o working set é o conjunto de páginas de memória que estão fisicamente residentes na `RAM` para aquele processo em um determinado momento</span></span>
<span id="lst-cppwindows1-57"><a href="#lst-cppwindows1-57" aria-hidden="true" tabindex="-1"></a><span class="co">    **/</span></span>
<span id="lst-cppwindows1-58"><a href="#lst-cppwindows1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-59"><a href="#lst-cppwindows1-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-60"><a href="#lst-cppwindows1-60" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor padrão</span></span>
<span id="lst-cppwindows1-61"><a href="#lst-cppwindows1-61" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-62"><a href="#lst-cppwindows1-62" aria-hidden="true" tabindex="-1"></a>    ProcessInfo<span class="op">()</span> <span class="op">:</span> processId<span class="op">(</span><span class="dv">0</span><span class="op">),</span> workingSetSize<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="lst-cppwindows1-63"><a href="#lst-cppwindows1-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-64"><a href="#lst-cppwindows1-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-65"><a href="#lst-cppwindows1-65" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor com parâmetros</span></span>
<span id="lst-cppwindows1-66"><a href="#lst-cppwindows1-66" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">**PID**</span><span class="co"> ID do processo</span></span>
<span id="lst-cppwindows1-67"><a href="#lst-cppwindows1-67" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">name</span><span class="co"> Nome do processo</span></span>
<span id="lst-cppwindows1-68"><a href="#lst-cppwindows1-68" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">path</span><span class="co"> Caminho completo</span></span>
<span id="lst-cppwindows1-69"><a href="#lst-cppwindows1-69" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">memSize</span><span class="co"> Tamanho da memória em uso</span></span>
<span id="lst-cppwindows1-70"><a href="#lst-cppwindows1-70" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-71"><a href="#lst-cppwindows1-71" aria-hidden="true" tabindex="-1"></a>    ProcessInfo<span class="op">(</span>DWORD pid<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>wstring<span class="op">&amp;</span> name<span class="op">,</span> </span>
<span id="lst-cppwindows1-72"><a href="#lst-cppwindows1-72" aria-hidden="true" tabindex="-1"></a>                <span class="at">const</span> <span class="bu">std::</span>wstring<span class="op">&amp;</span> path<span class="op">,</span> SIZE_T memSize<span class="op">)</span></span>
<span id="lst-cppwindows1-73"><a href="#lst-cppwindows1-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> processId<span class="op">(</span>pid<span class="op">),</span> processName<span class="op">(</span>name<span class="op">),</span> fullPath<span class="op">(</span>path<span class="op">),</span> workingSetSize<span class="op">(</span>memSize<span class="op">)</span> <span class="op">{}</span></span>
<span id="lst-cppwindows1-74"><a href="#lst-cppwindows1-74" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-cppwindows1-75"><a href="#lst-cppwindows1-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-76"><a href="#lst-cppwindows1-76" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cppwindows1-77"><a href="#lst-cppwindows1-77" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Classe responsável por enumerar e gerenciar informações de processos</span></span>
<span id="lst-cppwindows1-78"><a href="#lst-cppwindows1-78" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cppwindows1-79"><a href="#lst-cppwindows1-79" aria-hidden="true" tabindex="-1"></a><span class="co"> * Esta classe encapsula toda a funcionalidade relacionada à coleta</span></span>
<span id="lst-cppwindows1-80"><a href="#lst-cppwindows1-80" aria-hidden="true" tabindex="-1"></a><span class="co"> * de informações sobre processos em execução no sistema Windows.</span></span>
<span id="lst-cppwindows1-81"><a href="#lst-cppwindows1-81" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cppwindows1-82"><a href="#lst-cppwindows1-82" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ProcessEnumerator <span class="op">{</span></span>
<span id="lst-cppwindows1-83"><a href="#lst-cppwindows1-83" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="lst-cppwindows1-84"><a href="#lst-cppwindows1-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> processes<span class="op">;</span> <span class="co">///&lt; Lista de processos coletados</span></span>
<span id="lst-cppwindows1-85"><a href="#lst-cppwindows1-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-86"><a href="#lst-cppwindows1-86" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-87"><a href="#lst-cppwindows1-87" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém o nome do processo a partir de seu handle</span></span>
<span id="lst-cppwindows1-88"><a href="#lst-cppwindows1-88" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">hProcess</span><span class="co"> Handle do processo</span></span>
<span id="lst-cppwindows1-89"><a href="#lst-cppwindows1-89" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Nome do processo ou string vazia em caso de erro</span></span>
<span id="lst-cppwindows1-90"><a href="#lst-cppwindows1-90" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-91"><a href="#lst-cppwindows1-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wstring getProcessName<span class="op">(</span>HANDLE hProcess<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-92"><a href="#lst-cppwindows1-92" aria-hidden="true" tabindex="-1"></a>        <span class="dt">wchar_t</span> processName<span class="op">[</span>MAX_PATH<span class="op">]</span> <span class="op">=</span> <span class="st">L"&lt;desconhecido&gt;"</span><span class="op">;</span></span>
<span id="lst-cppwindows1-93"><a href="#lst-cppwindows1-93" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-94"><a href="#lst-cppwindows1-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>hProcess <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-95"><a href="#lst-cppwindows1-95" aria-hidden="true" tabindex="-1"></a>            HMODULE hMod<span class="op">;</span></span>
<span id="lst-cppwindows1-96"><a href="#lst-cppwindows1-96" aria-hidden="true" tabindex="-1"></a>            DWORD cbNeeded<span class="op">;</span></span>
<span id="lst-cppwindows1-97"><a href="#lst-cppwindows1-97" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cppwindows1-98"><a href="#lst-cppwindows1-98" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>EnumProcessModules<span class="op">(</span>hProcess<span class="op">,</span> <span class="op">&amp;</span>hMod<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>hMod<span class="op">),</span> <span class="op">&amp;</span>cbNeeded<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-99"><a href="#lst-cppwindows1-99" aria-hidden="true" tabindex="-1"></a>                GetModuleBaseNameW<span class="op">(</span>hProcess<span class="op">,</span> hMod<span class="op">,</span> processName<span class="op">,</span> </span>
<span id="lst-cppwindows1-100"><a href="#lst-cppwindows1-100" aria-hidden="true" tabindex="-1"></a>                                   <span class="kw">sizeof</span><span class="op">(</span>processName<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">wchar_t</span><span class="op">));</span></span>
<span id="lst-cppwindows1-101"><a href="#lst-cppwindows1-101" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-cppwindows1-102"><a href="#lst-cppwindows1-102" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-103"><a href="#lst-cppwindows1-103" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-104"><a href="#lst-cppwindows1-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>wstring<span class="op">(</span>processName<span class="op">);</span></span>
<span id="lst-cppwindows1-105"><a href="#lst-cppwindows1-105" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-106"><a href="#lst-cppwindows1-106" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-107"><a href="#lst-cppwindows1-107" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-108"><a href="#lst-cppwindows1-108" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém o caminho completo do executável do processo</span></span>
<span id="lst-cppwindows1-109"><a href="#lst-cppwindows1-109" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">hProcess</span><span class="co"> Handle do processo</span></span>
<span id="lst-cppwindows1-110"><a href="#lst-cppwindows1-110" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Caminho completo ou string vazia em caso de erro</span></span>
<span id="lst-cppwindows1-111"><a href="#lst-cppwindows1-111" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-112"><a href="#lst-cppwindows1-112" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wstring getProcessPath<span class="op">(</span>HANDLE hProcess<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-113"><a href="#lst-cppwindows1-113" aria-hidden="true" tabindex="-1"></a>        <span class="dt">wchar_t</span> processPath<span class="op">[</span>MAX_PATH<span class="op">]</span> <span class="op">=</span> <span class="st">L"&lt;caminho não disponível&gt;"</span><span class="op">;</span></span>
<span id="lst-cppwindows1-114"><a href="#lst-cppwindows1-114" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-115"><a href="#lst-cppwindows1-115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>hProcess <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-116"><a href="#lst-cppwindows1-116" aria-hidden="true" tabindex="-1"></a>            DWORD pathLength <span class="op">=</span> MAX_PATH<span class="op">;</span></span>
<span id="lst-cppwindows1-117"><a href="#lst-cppwindows1-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>QueryFullProcessImageNameW<span class="op">(</span>hProcess<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> processPath<span class="op">,</span> <span class="op">&amp;</span>pathLength<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-118"><a href="#lst-cppwindows1-118" aria-hidden="true" tabindex="-1"></a>                wcscpy_s<span class="op">(</span>processPath<span class="op">,</span> <span class="st">L"&lt;acesso negado&gt;"</span><span class="op">);</span></span>
<span id="lst-cppwindows1-119"><a href="#lst-cppwindows1-119" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-cppwindows1-120"><a href="#lst-cppwindows1-120" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-121"><a href="#lst-cppwindows1-121" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-122"><a href="#lst-cppwindows1-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>wstring<span class="op">(</span>processPath<span class="op">);</span></span>
<span id="lst-cppwindows1-123"><a href="#lst-cppwindows1-123" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-124"><a href="#lst-cppwindows1-124" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-125"><a href="#lst-cppwindows1-125" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-126"><a href="#lst-cppwindows1-126" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém informações de memória do processo</span></span>
<span id="lst-cppwindows1-127"><a href="#lst-cppwindows1-127" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">hProcess</span><span class="co"> Handle do processo</span></span>
<span id="lst-cppwindows1-128"><a href="#lst-cppwindows1-128" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Tamanho do working set em bytes</span></span>
<span id="lst-cppwindows1-129"><a href="#lst-cppwindows1-129" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-130"><a href="#lst-cppwindows1-130" aria-hidden="true" tabindex="-1"></a>    SIZE_T getProcessMemoryInfo<span class="op">(</span>HANDLE hProcess<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-131"><a href="#lst-cppwindows1-131" aria-hidden="true" tabindex="-1"></a>        PROCESS_MEMORY_COUNTERS pmc<span class="op">;</span></span>
<span id="lst-cppwindows1-132"><a href="#lst-cppwindows1-132" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-133"><a href="#lst-cppwindows1-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>hProcess <span class="op">!=</span> <span class="kw">nullptr</span> <span class="op">&amp;&amp;</span> GetProcessMemoryInfo<span class="op">(</span>hProcess<span class="op">,</span> <span class="op">&amp;</span>pmc<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>pmc<span class="op">)))</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-134"><a href="#lst-cppwindows1-134" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pmc<span class="op">.</span>WorkingSetSize<span class="op">;</span></span>
<span id="lst-cppwindows1-135"><a href="#lst-cppwindows1-135" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-136"><a href="#lst-cppwindows1-136" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-137"><a href="#lst-cppwindows1-137" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-cppwindows1-138"><a href="#lst-cppwindows1-138" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-139"><a href="#lst-cppwindows1-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-140"><a href="#lst-cppwindows1-140" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="lst-cppwindows1-141"><a href="#lst-cppwindows1-141" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-142"><a href="#lst-cppwindows1-142" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Enumera todos os processos em execução no sistema</span></span>
<span id="lst-cppwindows1-143"><a href="#lst-cppwindows1-143" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se a enumeração foi bem-sucedida, false caso contrário</span></span>
<span id="lst-cppwindows1-144"><a href="#lst-cppwindows1-144" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span></span>
<span id="lst-cppwindows1-145"><a href="#lst-cppwindows1-145" aria-hidden="true" tabindex="-1"></a><span class="co">     * Este método coleta informações sobre todos os processos em execução</span></span>
<span id="lst-cppwindows1-146"><a href="#lst-cppwindows1-146" aria-hidden="true" tabindex="-1"></a><span class="co">     * usando as `APIs`EnumProcesses e OpenProcess do Windows.</span></span>
<span id="lst-cppwindows1-147"><a href="#lst-cppwindows1-147" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-148"><a href="#lst-cppwindows1-148" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> enumerateProcesses<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-149"><a href="#lst-cppwindows1-149" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Limpa a lista anterior</span></span>
<span id="lst-cppwindows1-150"><a href="#lst-cppwindows1-150" aria-hidden="true" tabindex="-1"></a>        processes<span class="op">.</span>clear<span class="op">();</span></span>
<span id="lst-cppwindows1-151"><a href="#lst-cppwindows1-151" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-152"><a href="#lst-cppwindows1-152" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Buffer para armazenar os IDs dos processos</span></span>
<span id="lst-cppwindows1-153"><a href="#lst-cppwindows1-153" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span>DWORD<span class="op">&gt;</span> processIds<span class="op">(</span><span class="dv">1024</span><span class="op">);</span></span>
<span id="lst-cppwindows1-154"><a href="#lst-cppwindows1-154" aria-hidden="true" tabindex="-1"></a>        DWORD bytesReturned<span class="op">;</span></span>
<span id="lst-cppwindows1-155"><a href="#lst-cppwindows1-155" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-156"><a href="#lst-cppwindows1-156" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Enumera todos os processos</span></span>
<span id="lst-cppwindows1-157"><a href="#lst-cppwindows1-157" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>EnumProcesses<span class="op">(</span>processIds<span class="op">.</span>data<span class="op">(),</span> </span>
<span id="lst-cppwindows1-158"><a href="#lst-cppwindows1-158" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">static_cast</span><span class="op">&lt;</span>DWORD<span class="op">&gt;(</span>processIds<span class="op">.</span>size<span class="op">()</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>DWORD<span class="op">)),</span> </span>
<span id="lst-cppwindows1-159"><a href="#lst-cppwindows1-159" aria-hidden="true" tabindex="-1"></a>                          <span class="op">&amp;</span>bytesReturned<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-160"><a href="#lst-cppwindows1-160" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>wcerr <span class="op">&lt;&lt;</span> <span class="st">L"Erro ao enumerar processos: "</span> <span class="op">&lt;&lt;</span> GetLastError<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cppwindows1-161"><a href="#lst-cppwindows1-161" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="lst-cppwindows1-162"><a href="#lst-cppwindows1-162" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-163"><a href="#lst-cppwindows1-163" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-164"><a href="#lst-cppwindows1-164" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calcula o número de processos retornados</span></span>
<span id="lst-cppwindows1-165"><a href="#lst-cppwindows1-165" aria-hidden="true" tabindex="-1"></a>        DWORD processCount <span class="op">=</span> bytesReturned <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>DWORD<span class="op">);</span></span>
<span id="lst-cppwindows1-166"><a href="#lst-cppwindows1-166" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-167"><a href="#lst-cppwindows1-167" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Processa cada ID de processo</span></span>
<span id="lst-cppwindows1-168"><a href="#lst-cppwindows1-168" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>DWORD i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> processCount<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-169"><a href="#lst-cppwindows1-169" aria-hidden="true" tabindex="-1"></a>            DWORD processId <span class="op">=</span> processIds<span class="op">[</span>i<span class="op">];</span></span>
<span id="lst-cppwindows1-170"><a href="#lst-cppwindows1-170" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cppwindows1-171"><a href="#lst-cppwindows1-171" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Abre o processo com permissões limitadas</span></span>
<span id="lst-cppwindows1-172"><a href="#lst-cppwindows1-172" aria-hidden="true" tabindex="-1"></a>            HANDLE hProcess <span class="op">=</span> OpenProcess<span class="op">(</span>PROCESS_QUERY_INFORMATION <span class="op">|</span> PROCESS_VM_READ<span class="op">,</span> </span>
<span id="lst-cppwindows1-173"><a href="#lst-cppwindows1-173" aria-hidden="true" tabindex="-1"></a>                                        FALSE<span class="op">,</span> processId<span class="op">);</span></span>
<span id="lst-cppwindows1-174"><a href="#lst-cppwindows1-174" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cppwindows1-175"><a href="#lst-cppwindows1-175" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>hProcess <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-176"><a href="#lst-cppwindows1-176" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Coleta informações do processo</span></span>
<span id="lst-cppwindows1-177"><a href="#lst-cppwindows1-177" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> name <span class="op">=</span> getProcessName<span class="op">(</span>hProcess<span class="op">);</span></span>
<span id="lst-cppwindows1-178"><a href="#lst-cppwindows1-178" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> path <span class="op">=</span> getProcessPath<span class="op">(</span>hProcess<span class="op">);</span></span>
<span id="lst-cppwindows1-179"><a href="#lst-cppwindows1-179" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> memSize <span class="op">=</span> getProcessMemoryInfo<span class="op">(</span>hProcess<span class="op">);</span></span>
<span id="lst-cppwindows1-180"><a href="#lst-cppwindows1-180" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="lst-cppwindows1-181"><a href="#lst-cppwindows1-181" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Adiciona à lista usando emplace_back (C++ 11+)</span></span>
<span id="lst-cppwindows1-182"><a href="#lst-cppwindows1-182" aria-hidden="true" tabindex="-1"></a>                processes<span class="op">.</span>emplace_back<span class="op">(</span>processId<span class="op">,</span> name<span class="op">,</span> path<span class="op">,</span> memSize<span class="op">);</span></span>
<span id="lst-cppwindows1-183"><a href="#lst-cppwindows1-183" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="lst-cppwindows1-184"><a href="#lst-cppwindows1-184" aria-hidden="true" tabindex="-1"></a>                CloseHandle<span class="op">(</span>hProcess<span class="op">);</span></span>
<span id="lst-cppwindows1-185"><a href="#lst-cppwindows1-185" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-186"><a href="#lst-cppwindows1-186" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Processo sem acesso - adiciona informações básicas</span></span>
<span id="lst-cppwindows1-187"><a href="#lst-cppwindows1-187" aria-hidden="true" tabindex="-1"></a>                processes<span class="op">.</span>emplace_back<span class="op">(</span>processId<span class="op">,</span> <span class="st">L"&lt;acesso negado&gt;"</span><span class="op">,</span> </span>
<span id="lst-cppwindows1-188"><a href="#lst-cppwindows1-188" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">L"&lt;acesso negado&gt;"</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="lst-cppwindows1-189"><a href="#lst-cppwindows1-189" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-cppwindows1-190"><a href="#lst-cppwindows1-190" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-191"><a href="#lst-cppwindows1-191" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-192"><a href="#lst-cppwindows1-192" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="lst-cppwindows1-193"><a href="#lst-cppwindows1-193" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-194"><a href="#lst-cppwindows1-194" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-195"><a href="#lst-cppwindows1-195" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-196"><a href="#lst-cppwindows1-196" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Exibe a lista de processos formatada</span></span>
<span id="lst-cppwindows1-197"><a href="#lst-cppwindows1-197" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span></span>
<span id="lst-cppwindows1-198"><a href="#lst-cppwindows1-198" aria-hidden="true" tabindex="-1"></a><span class="co">     * Utiliza std::format (C++ 20) e ranges (C++ 20) para formatação</span></span>
<span id="lst-cppwindows1-199"><a href="#lst-cppwindows1-199" aria-hidden="true" tabindex="-1"></a><span class="co">     * e manipulação dos dados de forma moderna.</span></span>
<span id="lst-cppwindows1-200"><a href="#lst-cppwindows1-200" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-201"><a href="#lst-cppwindows1-201" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> displayProcesses<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-202"><a href="#lst-cppwindows1-202" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Cabeçalho da tabela</span></span>
<span id="lst-cppwindows1-203"><a href="#lst-cppwindows1-203" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"</span><span class="sc">{:&gt;8}</span><span class="st"> | </span><span class="sc">{:30}</span><span class="st"> | </span><span class="sc">{:10}</span><span class="st"> | </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cppwindows1-204"><a href="#lst-cppwindows1-204" aria-hidden="true" tabindex="-1"></a>                                 <span class="st">L"PID"</span><span class="op">,</span> <span class="st">L"Nome do Processo"</span><span class="op">,</span> <span class="st">L"Memória (KB)"</span><span class="op">,</span> <span class="st">L"Caminho"</span><span class="op">);</span></span>
<span id="lst-cppwindows1-205"><a href="#lst-cppwindows1-205" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>wstring<span class="op">(</span><span class="dv">80</span><span class="op">,</span> <span class="ch">L'-'</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cppwindows1-206"><a href="#lst-cppwindows1-206" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-207"><a href="#lst-cppwindows1-207" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Ordena os processos por **PID** usando ranges (C++ 20)</span></span>
<span id="lst-cppwindows1-208"><a href="#lst-cppwindows1-208" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sortedProcesses <span class="op">=</span> processes<span class="op">;</span></span>
<span id="lst-cppwindows1-209"><a href="#lst-cppwindows1-209" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ranges::sort<span class="op">(</span>sortedProcesses<span class="op">,</span> </span>
<span id="lst-cppwindows1-210"><a href="#lst-cppwindows1-210" aria-hidden="true" tabindex="-1"></a>                         <span class="op">[](</span><span class="at">const</span> ProcessInfo<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> ProcessInfo<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-211"><a href="#lst-cppwindows1-211" aria-hidden="true" tabindex="-1"></a>                             <span class="cf">return</span> a<span class="op">.</span>processId <span class="op">&lt;</span> b<span class="op">.</span>processId<span class="op">;</span></span>
<span id="lst-cppwindows1-212"><a href="#lst-cppwindows1-212" aria-hidden="true" tabindex="-1"></a>                         <span class="op">});</span></span>
<span id="lst-cppwindows1-213"><a href="#lst-cppwindows1-213" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-214"><a href="#lst-cppwindows1-214" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Exibe cada processo</span></span>
<span id="lst-cppwindows1-215"><a href="#lst-cppwindows1-215" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> proc <span class="op">:</span> sortedProcesses<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-216"><a href="#lst-cppwindows1-216" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Converte bytes para KB</span></span>
<span id="lst-cppwindows1-217"><a href="#lst-cppwindows1-217" aria-hidden="true" tabindex="-1"></a>            SIZE_T memoryKB <span class="op">=</span> proc<span class="op">.</span>workingSetSize <span class="op">/</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="lst-cppwindows1-218"><a href="#lst-cppwindows1-218" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cppwindows1-219"><a href="#lst-cppwindows1-219" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"</span><span class="sc">{:8}</span><span class="st"> | </span><span class="sc">{:30}</span><span class="st"> | </span><span class="sc">{:10}</span><span class="st"> | </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-cppwindows1-220"><a href="#lst-cppwindows1-220" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>processId<span class="op">,</span></span>
<span id="lst-cppwindows1-221"><a href="#lst-cppwindows1-221" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>processName<span class="op">.</span>substr<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">30</span><span class="op">),</span></span>
<span id="lst-cppwindows1-222"><a href="#lst-cppwindows1-222" aria-hidden="true" tabindex="-1"></a>                                     memoryKB<span class="op">,</span></span>
<span id="lst-cppwindows1-223"><a href="#lst-cppwindows1-223" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>fullPath<span class="op">);</span></span>
<span id="lst-cppwindows1-224"><a href="#lst-cppwindows1-224" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-225"><a href="#lst-cppwindows1-225" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-226"><a href="#lst-cppwindows1-226" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"</span><span class="sc">\n</span><span class="st">Total de processos: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> processes<span class="op">.</span>size<span class="op">());</span></span>
<span id="lst-cppwindows1-227"><a href="#lst-cppwindows1-227" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-228"><a href="#lst-cppwindows1-228" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-229"><a href="#lst-cppwindows1-229" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-230"><a href="#lst-cppwindows1-230" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém estatísticas dos processos</span></span>
<span id="lst-cppwindows1-231"><a href="#lst-cppwindows1-231" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Par contendo número total de processos e uso total de memória</span></span>
<span id="lst-cppwindows1-232"><a href="#lst-cppwindows1-232" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-233"><a href="#lst-cppwindows1-233" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> SIZE_T<span class="op">&gt;</span> getStatistics<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-234"><a href="#lst-cppwindows1-234" aria-hidden="true" tabindex="-1"></a>        SIZE_T totalMemory <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-cppwindows1-235"><a href="#lst-cppwindows1-235" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-236"><a href="#lst-cppwindows1-236" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Usa ranges::fold_left (C++23) para somar a memória total</span></span>
<span id="lst-cppwindows1-237"><a href="#lst-cppwindows1-237" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> proc <span class="op">:</span> processes<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-238"><a href="#lst-cppwindows1-238" aria-hidden="true" tabindex="-1"></a>            totalMemory <span class="op">+=</span> proc<span class="op">.</span>workingSetSize<span class="op">;</span></span>
<span id="lst-cppwindows1-239"><a href="#lst-cppwindows1-239" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-240"><a href="#lst-cppwindows1-240" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-241"><a href="#lst-cppwindows1-241" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>processes<span class="op">.</span>size<span class="op">(),</span> totalMemory<span class="op">};</span></span>
<span id="lst-cppwindows1-242"><a href="#lst-cppwindows1-242" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-243"><a href="#lst-cppwindows1-243" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-244"><a href="#lst-cppwindows1-244" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cppwindows1-245"><a href="#lst-cppwindows1-245" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Filtra processos por nome</span></span>
<span id="lst-cppwindows1-246"><a href="#lst-cppwindows1-246" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">namePattern</span><span class="co"> Padrão do nome para filtrar</span></span>
<span id="lst-cppwindows1-247"><a href="#lst-cppwindows1-247" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Vetor com processos que correspondem ao padrão</span></span>
<span id="lst-cppwindows1-248"><a href="#lst-cppwindows1-248" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cppwindows1-249"><a href="#lst-cppwindows1-249" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> filterByName<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>wstring<span class="op">&amp;</span> namePattern<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-250"><a href="#lst-cppwindows1-250" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> filtered<span class="op">;</span></span>
<span id="lst-cppwindows1-251"><a href="#lst-cppwindows1-251" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-252"><a href="#lst-cppwindows1-252" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Usa ranges::copy_if (C++ 20) para filtragem</span></span>
<span id="lst-cppwindows1-253"><a href="#lst-cppwindows1-253" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ranges::copy_if<span class="op">(</span>processes<span class="op">,</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>filtered<span class="op">),</span></span>
<span id="lst-cppwindows1-254"><a href="#lst-cppwindows1-254" aria-hidden="true" tabindex="-1"></a>                            <span class="op">[&amp;</span>namePattern<span class="op">](</span><span class="at">const</span> ProcessInfo<span class="op">&amp;</span> proc<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-255"><a href="#lst-cppwindows1-255" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">return</span> proc<span class="op">.</span>processName<span class="op">.</span>find<span class="op">(</span>namePattern<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>wstring::npos<span class="op">;</span></span>
<span id="lst-cppwindows1-256"><a href="#lst-cppwindows1-256" aria-hidden="true" tabindex="-1"></a>                            <span class="op">});</span></span>
<span id="lst-cppwindows1-257"><a href="#lst-cppwindows1-257" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cppwindows1-258"><a href="#lst-cppwindows1-258" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filtered<span class="op">;</span></span>
<span id="lst-cppwindows1-259"><a href="#lst-cppwindows1-259" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-260"><a href="#lst-cppwindows1-260" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-cppwindows1-261"><a href="#lst-cppwindows1-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cppwindows1-262"><a href="#lst-cppwindows1-262" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cppwindows1-263"><a href="#lst-cppwindows1-263" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Função principal do programa</span></span>
<span id="lst-cppwindows1-264"><a href="#lst-cppwindows1-264" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co"> Código de saída (0 para sucesso)</span></span>
<span id="lst-cppwindows1-265"><a href="#lst-cppwindows1-265" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cppwindows1-266"><a href="#lst-cppwindows1-266" aria-hidden="true" tabindex="-1"></a><span class="co"> * Demonstra o uso da classe ProcessEnumerator para listar</span></span>
<span id="lst-cppwindows1-267"><a href="#lst-cppwindows1-267" aria-hidden="true" tabindex="-1"></a><span class="co"> * processos em execução no sistema Windows.</span></span>
<span id="lst-cppwindows1-268"><a href="#lst-cppwindows1-268" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cppwindows1-269"><a href="#lst-cppwindows1-269" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-270"><a href="#lst-cppwindows1-270" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Configura a saída para suportar caracteres Unicode</span></span>
<span id="lst-cppwindows1-271"><a href="#lst-cppwindows1-271" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout<span class="op">.</span>imbue<span class="op">(</span><span class="bu">std::</span>locale<span class="op">(</span><span class="st">""</span><span class="op">));</span></span>
<span id="lst-cppwindows1-272"><a href="#lst-cppwindows1-272" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-273"><a href="#lst-cppwindows1-273" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="st">L"=== Listador de Processos **Windows** - C++23 ==="</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cppwindows1-274"><a href="#lst-cppwindows1-274" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="st">L"Coletando informações dos processos..."</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cppwindows1-275"><a href="#lst-cppwindows1-275" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-276"><a href="#lst-cppwindows1-276" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cria o enumerador de processos</span></span>
<span id="lst-cppwindows1-277"><a href="#lst-cppwindows1-277" aria-hidden="true" tabindex="-1"></a>    ProcessEnumerator enumerator<span class="op">;</span></span>
<span id="lst-cppwindows1-278"><a href="#lst-cppwindows1-278" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-279"><a href="#lst-cppwindows1-279" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Enumera os processos</span></span>
<span id="lst-cppwindows1-280"><a href="#lst-cppwindows1-280" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>enumerator<span class="op">.</span>enumerateProcesses<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-281"><a href="#lst-cppwindows1-281" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>wcerr <span class="op">&lt;&lt;</span> <span class="st">L"Falha ao enumerar processos!"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cppwindows1-282"><a href="#lst-cppwindows1-282" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="lst-cppwindows1-283"><a href="#lst-cppwindows1-283" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-284"><a href="#lst-cppwindows1-284" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-285"><a href="#lst-cppwindows1-285" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exibe os processos</span></span>
<span id="lst-cppwindows1-286"><a href="#lst-cppwindows1-286" aria-hidden="true" tabindex="-1"></a>    enumerator<span class="op">.</span>displayProcesses<span class="op">();</span></span>
<span id="lst-cppwindows1-287"><a href="#lst-cppwindows1-287" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-288"><a href="#lst-cppwindows1-288" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exibe estatísticas</span></span>
<span id="lst-cppwindows1-289"><a href="#lst-cppwindows1-289" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">[</span>processCount<span class="op">,</span> totalMemory<span class="op">]</span> <span class="op">=</span> enumerator<span class="op">.</span>getStatistics<span class="op">();</span></span>
<span id="lst-cppwindows1-290"><a href="#lst-cppwindows1-290" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"</span><span class="sc">\n</span><span class="st">Estatísticas:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="lst-cppwindows1-291"><a href="#lst-cppwindows1-291" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"- Processos em execução: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> processCount<span class="op">);</span></span>
<span id="lst-cppwindows1-292"><a href="#lst-cppwindows1-292" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"- Memória total em uso: {:.f} MB</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cppwindows1-293"><a href="#lst-cppwindows1-293" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>totalMemory<span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="dv">1024</span> <span class="op">*</span> <span class="dv">1024</span><span class="op">));</span></span>
<span id="lst-cppwindows1-294"><a href="#lst-cppwindows1-294" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-295"><a href="#lst-cppwindows1-295" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exemplo de filtragem (opcional)</span></span>
<span id="lst-cppwindows1-296"><a href="#lst-cppwindows1-296" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="st">L"</span><span class="sc">\n</span><span class="st">Pressione Enter para ver exemplo de filtragem..."</span><span class="op">;</span></span>
<span id="lst-cppwindows1-297"><a href="#lst-cppwindows1-297" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcin<span class="op">.</span>get<span class="op">();</span></span>
<span id="lst-cppwindows1-298"><a href="#lst-cppwindows1-298" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-299"><a href="#lst-cppwindows1-299" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> svcProcesses <span class="op">=</span> enumerator<span class="op">.</span>filterByName<span class="op">(</span><span class="st">L"svc"</span><span class="op">);</span></span>
<span id="lst-cppwindows1-300"><a href="#lst-cppwindows1-300" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>svcProcesses<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-301"><a href="#lst-cppwindows1-301" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"</span><span class="sc">\n</span><span class="st">Processos com 'svc' no nome (</span><span class="sc">{}</span><span class="st"> encontrados):</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cppwindows1-302"><a href="#lst-cppwindows1-302" aria-hidden="true" tabindex="-1"></a>                                 svcProcesses<span class="op">.</span>size<span class="op">());</span></span>
<span id="lst-cppwindows1-303"><a href="#lst-cppwindows1-303" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> proc <span class="op">:</span> svcProcesses<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cppwindows1-304"><a href="#lst-cppwindows1-304" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>wcout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">L"- **PID** </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cppwindows1-305"><a href="#lst-cppwindows1-305" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>processId<span class="op">,</span> proc<span class="op">.</span>processName<span class="op">);</span></span>
<span id="lst-cppwindows1-306"><a href="#lst-cppwindows1-306" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cppwindows1-307"><a href="#lst-cppwindows1-307" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cppwindows1-308"><a href="#lst-cppwindows1-308" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cppwindows1-309"><a href="#lst-cppwindows1-309" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-cppwindows1-310"><a href="#lst-cppwindows1-310" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p>O código listado em <a href="#lst-cppwindows1" class="quarto-xref">Listing&nbsp;<span>1</span></a>, implementa um sistema para enumerar e exibir informações sobre processos em execução no <strong>Windows</strong> 11, utilizando uma abordagem orientada a objetos. A estrutura principal está organizada em torno da classe <code>ProcessEnumerator</code>, que encapsula toda a funcionalidade de coleta e manipulação de dados dos processos. O programa também define uma estrutura <code>ProcessInfo</code> que serve como contêiner para as informações essenciais de cada processo, incluindo a identificação do processo, em inglês <strong>P</strong>rocess <strong>ID</strong>entification, <strong>PID</strong> do processo (<code>processId</code>), nome do executável (<code>processName</code>), caminho completo (<code>fullPath</code>) e uso de memória (<code>workingSetSize</code>). Neste código, o objetivo é permitir uma separação de responsabilidades e facilitar o entendimento, a manutenção e, se a audaciosa leitora desejar, a extensão do código.</p>
<p>A coleta das informações dos processos será realizada pelo método <code>enumerateProcesses()</code>, que utiliza a API <code>EnumProcesses()</code> do <strong>Windows</strong> para obter uma lista de todos os IDs de processos ativos no sistema. Para cada processo encontrado, o programa tenta abrir um <code>handle</code> usando <code>OpenProcess()</code> com permissões específicas (<code>PROCESS_QUERY_INFORMATION | PROCESS_VM_READ</code>) e então extrai informações detalhadas por meio de três métodos auxiliares: <code>getProcessName()</code> usa <code>EnumProcessModules()</code> e <code>GetModuleBaseNameW()</code> para obter o nome do executável, <code>getProcessPath()</code> utiliza <code>QueryFullProcessImageNameW()</code> para recuperar o caminho completo, e <code>getProcessMemoryInfo()</code> emprega <code>GetProcessMemoryInfo()</code> para coletar estatísticas de uso de memória. O programa implementa algum tratamento de erros, e tenta lidar adequadamente com processos que podem ter acesso restrito devido a permissões do sistema.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>O que é um handle?</strong> Um handle (manipulador) é um identificador opaco retornado pelo <strong>Sistema Operacional</strong> que representa um recurso do sistema, como processos, arquivos, threads, objetos de sincronização. No contexto deste programa, o handle obtido através de <code>OpenProcess()</code> funciona como uma “chave de acesso” que permite ao programa interagir com um processo específico através das <code>APIs</code>do Windows.</p>
</div>
</div>
<p>Quando chamamos <code>OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId)</code>, o <strong>Sistema Operacional</strong> verifica as permissões e, se aprovadas, retorna um valor do tipo <code>HANDLE</code> que referencia internamente as estruturas de dados do <code>kernel</code> relacionadas àquele processo. Este <code>handle</code> não é um ponteiro direto, é um índice para uma tabela interna do <strong>Sistema Operacional</strong> que mapeia o objeto real.</p>
<p>É fundamental fechar todo <code>handle</code> obtido usando <code>CloseHandle()</code> ao final de sua utilização, pois handles são recursos limitados do sistema. Falhar em liberá-los pode causar vazamentos de recursos, <em>resource leaks</em> que, em casos extremos, podem esgotar a capacidade do sistema de criar novos <code>handles</code>. O padrão <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization, <strong>RAII</strong> do C++ pode ser usado com classes <em>wrapper</em> para garantir liberação automática de <code>handles</code>.</p>
<p>A exibição dos dados coletados será feita pelo método <code>displayProcesses()</code>, que demonstra o uso de recursos modernos do C++ como <code>std::format</code> para formatação elegante de <em>strings</em> e <code>std::ranges::sort</code> para ordenação funcional dos processos por <strong>PID</strong>. O programa também oferece o método <code>getStatistics()</code> que calcula estatísticas gerais do sistema usando <em>structured bindings</em>, e o método <code>filterByName()</code> que implementa filtragem de processos usando <code>std::ranges::copy_if</code>. A função <code>main()</code> orquestra todo o fluxo do programa, configurando adequadamente a saída Unicode com <code>std::wcout.imbue(std::locale(""))</code>, não me preocupei com saídas corretamente acentuadas em português, e demonstrando o uso prático de todas as funcionalidades implementadas.</p>
<p>O código utiliza características avançadas do C++ disponíveis a partir do C++20. A implementação garante que <code>handles</code> de processos sejam adequadamente fechados com <code>CloseHandle()</code>, evitando vazamentos de recursos, e usa técnicas modernas como <code>emplace_back()</code> para construção eficiente de objetos diretamente no contêiner. Este programa serve como uma demonstração de como interfaces de sistema de baixo nível podem ser encapsuladas em código C++ moderno, mantendo tanto a eficiência quanto a legibilidade e manutenibilidade. Ao executar este código a leitora verá, no terminal uma lista de processos algo como:</p>
<div id="lst-shell1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-shell1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;2
</figcaption>
<div aria-describedby="lst-shell1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="lst-shell1" class="shell"><code>     **PID** | Nome do Processo               | Memória (KB) | Caminho
--------------------------------------------------------------------------------
   ...
   ...
   ...
   27664 | &lt;acesso negado&gt;                |          0 | &lt;acesso negado&gt;
   27836 | CrossDeviceResume.exe          |       5056 | C:\Windows\SystemApps\MicrosoftWindows.Client...DeviceResume.exe
   27964 | FileCoAuth.exe                 |      14016 | C:\Program Files\Microsoft ...\FileCoAuth.exe
   28008 | AdobeCollabSync.exe            |      19808 | C:\Program Files\Adobe\Acrobat DC\Acrobat\AdobeCollabSync.exe
   28088 | PerfWatson2.exe                |      58092 | C:\Program Files\Microsoft Visual Studio\2022\... d.exe
   28120 | ServiceHub.IndexingService.exe |      61888 | C:\Program ...o\2022\Community\...IndexingService.exe
   28288 | msedge.exe                     |      10240 | C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe
   28520 | &lt;acesso negado&gt;                |          0 | &lt;acesso negado&gt;
   28556 | msedge.exe                     |       6832 | C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe

Total de processos: 322

Estatísticas:
- Processos em execução: 322
- Memória total em uso: 7293. MB</code></pre>
</div>
</figure>
</div>
<p>A listagem <a href="#lst-shell1" class="quarto-xref">Listing&nbsp;<span>2</span></a> foi manualmente editada, eu encurtei os caminhos, paths em inglês, para que coubessem na página e também limitei a listagem aos últimos processos que estão rodando na minha máquina <strong>Windows</strong> 11, neste momento em que escrevo, rodo códigos de teste faço buscas na web e em sistemas de inteligência artificial. Como a atenta leitora percebeu, neste momento minha máquina está rodando <span class="math inline">\(322\)</span> processos usando um quarto da capacidade de memória da minha máquina. Observe também que alguns dos processos estão com o <code>acesso negado</code>, isso acontece porque o programa não tem permissão para acessar os detalhes desses processos. Outros processos, como o <code>msedge.exe</code>, são executáveis comuns que a leitora pode reconhecer como parte do navegador Microsoft Edge.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Você pode ver um resumo do <a href="#lst-cppwindows1" class="quarto-xref">Listing&nbsp;<span>1</span></a> no <a href=".\ex\gerproc1-expresso.html">Expresso</a>.</p>
</div>
</div>
</section>
<section id="meu-primeiro-processo-linux" class="level3">
<h3 class="anchored" data-anchor-id="meu-primeiro-processo-linux">Meu Primeiro Processo Linux</h3>
<p>Os programas nos <strong>Sistemas Operacionais</strong> que rodam o <code>Kernel</code> <strong>Linux</strong> são executados como processos, e o <strong>Sistema Operacional</strong> também <strong>Linux</strong> fornece uma API rica para criar e gerenciar esses processos. Sendo assim, a seguir está um exemplo de como listar os processos que estão em execução em uma máquina rodando <strong>Linux</strong>, usando a API do <strong>Linux</strong> em C++23.</p>
<div id="lst-cpplinux1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-cpplinux1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;3
</figcaption>
<div aria-describedby="lst-cpplinux1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-cpplinux1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-cpplinux1-1"><a href="#lst-cpplinux1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cpplinux1-2"><a href="#lst-cpplinux1-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@file</span><span class="co"> </span><span class="cv">process_lister_linux.cpp</span></span>
<span id="lst-cpplinux1-3"><a href="#lst-cpplinux1-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Programa para listar processos em execução no Ubuntu/Linux</span></span>
<span id="lst-cpplinux1-4"><a href="#lst-cpplinux1-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@author</span><span class="co"> Livro de Sistemas Operacionais</span></span>
<span id="lst-cpplinux1-5"><a href="#lst-cpplinux1-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@version</span><span class="co"> </span><span class="cv">1</span><span class="co">.</span></span>
<span id="lst-cpplinux1-6"><a href="#lst-cpplinux1-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@date</span><span class="co"> 2025</span></span>
<span id="lst-cpplinux1-7"><a href="#lst-cpplinux1-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cpplinux1-8"><a href="#lst-cpplinux1-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * Este programa demonstra como enumerar processos em execução usando</span></span>
<span id="lst-cpplinux1-9"><a href="#lst-cpplinux1-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * o filesystem /proc do **Linux** em C++23. É adequado para estudo de </span></span>
<span id="lst-cpplinux1-10"><a href="#lst-cpplinux1-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * **Sistemas Operacionais** e demonstra conceitos de gerenciamento de processos.</span></span>
<span id="lst-cpplinux1-11"><a href="#lst-cpplinux1-11" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cpplinux1-12"><a href="#lst-cpplinux1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-13"><a href="#lst-cpplinux1-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span><span class="pp">     </span><span class="co">// Fluxos de entrada/saída padrão - std::cout, std::cerr, std::cin</span></span>
<span id="lst-cpplinux1-14"><a href="#lst-cpplinux1-14" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// para exibição de texto na console (sem Unicode como no Windows)</span></span>
<span id="lst-cpplinux1-15"><a href="#lst-cpplinux1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-16"><a href="#lst-cpplinux1-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span><span class="pp">       </span><span class="co">// Contêiner dinâmico std::vector para armazenar listas de ProcessInfo</span></span>
<span id="lst-cpplinux1-17"><a href="#lst-cpplinux1-17" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// e manipular coleções de processos de forma eficiente</span></span>
<span id="lst-cpplinux1-18"><a href="#lst-cpplinux1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-19"><a href="#lst-cpplinux1-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span><span class="pp">       </span><span class="co">// std::string para manipulação de strings ASCII (nomes de processos,</span></span>
<span id="lst-cpplinux1-20"><a href="#lst-cpplinux1-20" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// caminhos, linhas de comando lidas dos arquivos /proc)</span></span>
<span id="lst-cpplinux1-21"><a href="#lst-cpplinux1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-22"><a href="#lst-cpplinux1-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;format&gt;</span><span class="pp">       </span><span class="co">// std::format (C++20) - formatação moderna type-safe para criar</span></span>
<span id="lst-cpplinux1-23"><a href="#lst-cpplinux1-23" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// tabelas e exibições formatadas dos dados dos processos</span></span>
<span id="lst-cpplinux1-24"><a href="#lst-cpplinux1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-25"><a href="#lst-cpplinux1-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span><span class="pp">       </span><span class="co">// std::ranges (C++20) - algoritmos funcionais como ranges::sort(),</span></span>
<span id="lst-cpplinux1-26"><a href="#lst-cpplinux1-26" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// ranges::copy_if(), ranges::partial_sort() para manipulação de dados</span></span>
<span id="lst-cpplinux1-27"><a href="#lst-cpplinux1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-28"><a href="#lst-cpplinux1-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span><span class="pp">    </span><span class="co">// Algoritmos STL complementares e std::back_inserter para operações</span></span>
<span id="lst-cpplinux1-29"><a href="#lst-cpplinux1-29" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// auxiliares de manipulação de contêineres</span></span>
<span id="lst-cpplinux1-30"><a href="#lst-cpplinux1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-31"><a href="#lst-cpplinux1-31" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;filesystem&gt;</span><span class="pp">   </span><span class="co">// std::filesystem (C++17) - navegação pelo diretório /proc para</span></span>
<span id="lst-cpplinux1-32"><a href="#lst-cpplinux1-32" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// enumerar processos através do sistema de arquivos</span></span>
<span id="lst-cpplinux1-33"><a href="#lst-cpplinux1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-34"><a href="#lst-cpplinux1-34" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span><span class="pp">      </span><span class="co">// std::ifstream para leitura de arquivos como /proc/[pid]/comm,</span></span>
<span id="lst-cpplinux1-35"><a href="#lst-cpplinux1-35" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// /proc/[pid]/cmdline, /proc/[pid]/status</span></span>
<span id="lst-cpplinux1-36"><a href="#lst-cpplinux1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-37"><a href="#lst-cpplinux1-37" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span><span class="pp">      </span><span class="co">// std::istringstream para parsing de linhas dos arquivos /proc/[pid]/status</span></span>
<span id="lst-cpplinux1-38"><a href="#lst-cpplinux1-38" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// extraindo campos específicos como Uid, VmSize, VmRSS</span></span>
<span id="lst-cpplinux1-39"><a href="#lst-cpplinux1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-40"><a href="#lst-cpplinux1-40" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span><span class="pp">     </span><span class="co">// Funções POSIX do sistema - getpid() para obter **PID** atual,</span></span>
<span id="lst-cpplinux1-41"><a href="#lst-cpplinux1-41" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// getuid() para obter UID do usuário atual</span></span>
<span id="lst-cpplinux1-42"><a href="#lst-cpplinux1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-43"><a href="#lst-cpplinux1-43" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span><span class="pp">  </span><span class="co">// Tipos de dados do sistema POSIX - pid_t para IDs de processo,</span></span>
<span id="lst-cpplinux1-44"><a href="#lst-cpplinux1-44" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// uid_t para IDs de usuário</span></span>
<span id="lst-cpplinux1-45"><a href="#lst-cpplinux1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-46"><a href="#lst-cpplinux1-46" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;dirent.h&gt;</span><span class="pp">     </span><span class="co">// Interface para manipulação de diretórios (incluído mas não usado</span></span>
<span id="lst-cpplinux1-47"><a href="#lst-cpplinux1-47" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// diretamente - std::filesystem é usado no lugar)</span></span>
<span id="lst-cpplinux1-48"><a href="#lst-cpplinux1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-49"><a href="#lst-cpplinux1-49" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span><span class="pp">       </span><span class="co">// Funções de classificação de caracteres - ::isdigit() para verificar</span></span>
<span id="lst-cpplinux1-50"><a href="#lst-cpplinux1-50" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// se strings representam números (PIDs) nos nomes de diretórios</span></span>
<span id="lst-cpplinux1-51"><a href="#lst-cpplinux1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-52"><a href="#lst-cpplinux1-52" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span><span class="pp">     </span><span class="co">// std::optional (C++17) para valores opcionais (incluído para possíveis</span></span>
<span id="lst-cpplinux1-53"><a href="#lst-cpplinux1-53" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// extensões futuras que podem retornar valores nulos)</span></span>
<span id="lst-cpplinux1-54"><a href="#lst-cpplinux1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-55"><a href="#lst-cpplinux1-55" aria-hidden="true" tabindex="-1"></a><span class="co">// deleite-se, esta foi a última vez que comentei as bibliotecas.</span></span>
<span id="lst-cpplinux1-56"><a href="#lst-cpplinux1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-57"><a href="#lst-cpplinux1-57" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cpplinux1-58"><a href="#lst-cpplinux1-58" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Estrutura para armazenar informações de um processo</span></span>
<span id="lst-cpplinux1-59"><a href="#lst-cpplinux1-59" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cpplinux1-60"><a href="#lst-cpplinux1-60" aria-hidden="true" tabindex="-1"></a><span class="co"> * Esta estrutura encapsula as informações básicas de um processo</span></span>
<span id="lst-cpplinux1-61"><a href="#lst-cpplinux1-61" aria-hidden="true" tabindex="-1"></a><span class="co"> * que serão coletadas através do filesystem /proc do Linux.</span></span>
<span id="lst-cpplinux1-62"><a href="#lst-cpplinux1-62" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cpplinux1-63"><a href="#lst-cpplinux1-63" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ProcessInfo <span class="op">{</span></span>
<span id="lst-cpplinux1-64"><a href="#lst-cpplinux1-64" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> processId<span class="op">;</span>              <span class="co">///&lt; ID do processo (PID)</span></span>
<span id="lst-cpplinux1-65"><a href="#lst-cpplinux1-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string processName<span class="op">;</span>      <span class="co">///&lt; Nome do processo</span></span>
<span id="lst-cpplinux1-66"><a href="#lst-cpplinux1-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string commandLine<span class="op">;</span>      <span class="co">///&lt; Linha de comando completa</span></span>
<span id="lst-cpplinux1-67"><a href="#lst-cpplinux1-67" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string state<span class="op">;</span>            <span class="co">///&lt; Estado do processo (R, S, Z, etc.)</span></span>
<span id="lst-cpplinux1-68"><a href="#lst-cpplinux1-68" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> virtualMemory<span class="op">;</span>         <span class="co">///&lt; Memória virtual em KB</span></span>
<span id="lst-cpplinux1-69"><a href="#lst-cpplinux1-69" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> residentMemory<span class="op">;</span>        <span class="co">///&lt; Memória residente (RSS) em KB</span></span>
<span id="lst-cpplinux1-70"><a href="#lst-cpplinux1-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uid_t</span> userId<span class="op">;</span>                 <span class="co">///&lt; ID do usuário dono do processo</span></span>
<span id="lst-cpplinux1-71"><a href="#lst-cpplinux1-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-72"><a href="#lst-cpplinux1-72" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-73"><a href="#lst-cpplinux1-73" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor padrão</span></span>
<span id="lst-cpplinux1-74"><a href="#lst-cpplinux1-74" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-75"><a href="#lst-cpplinux1-75" aria-hidden="true" tabindex="-1"></a>    ProcessInfo<span class="op">()</span> <span class="op">:</span> processId<span class="op">(</span><span class="dv">0</span><span class="op">),</span> virtualMemory<span class="op">(</span><span class="dv">0</span><span class="op">),</span> residentMemory<span class="op">(</span><span class="dv">0</span><span class="op">),</span> userId<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="lst-cpplinux1-76"><a href="#lst-cpplinux1-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-77"><a href="#lst-cpplinux1-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-78"><a href="#lst-cpplinux1-78" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor com parâmetros</span></span>
<span id="lst-cpplinux1-79"><a href="#lst-cpplinux1-79" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">**PID**</span><span class="co"> ID do processo</span></span>
<span id="lst-cpplinux1-80"><a href="#lst-cpplinux1-80" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">name</span><span class="co"> Nome do processo</span></span>
<span id="lst-cpplinux1-81"><a href="#lst-cpplinux1-81" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">cmdline</span><span class="co"> Linha de comando</span></span>
<span id="lst-cpplinux1-82"><a href="#lst-cpplinux1-82" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">st</span><span class="co"> Estado do processo</span></span>
<span id="lst-cpplinux1-83"><a href="#lst-cpplinux1-83" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">vmem</span><span class="co"> Memória virtual</span></span>
<span id="lst-cpplinux1-84"><a href="#lst-cpplinux1-84" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">rmem</span><span class="co"> Memória residente</span></span>
<span id="lst-cpplinux1-85"><a href="#lst-cpplinux1-85" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">uid</span><span class="co"> ID do usuário</span></span>
<span id="lst-cpplinux1-86"><a href="#lst-cpplinux1-86" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-87"><a href="#lst-cpplinux1-87" aria-hidden="true" tabindex="-1"></a>    ProcessInfo<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> name<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> cmdline<span class="op">,</span></span>
<span id="lst-cpplinux1-88"><a href="#lst-cpplinux1-88" aria-hidden="true" tabindex="-1"></a>                <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> st<span class="op">,</span> <span class="dt">size_t</span> vmem<span class="op">,</span> <span class="dt">size_t</span> rmem<span class="op">,</span> <span class="dt">uid_t</span> uid<span class="op">)</span></span>
<span id="lst-cpplinux1-89"><a href="#lst-cpplinux1-89" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> processId<span class="op">(</span>pid<span class="op">),</span> processName<span class="op">(</span>name<span class="op">),</span> commandLine<span class="op">(</span>cmdline<span class="op">),</span> </span>
<span id="lst-cpplinux1-90"><a href="#lst-cpplinux1-90" aria-hidden="true" tabindex="-1"></a>          state<span class="op">(</span>st<span class="op">),</span> virtualMemory<span class="op">(</span>vmem<span class="op">),</span> residentMemory<span class="op">(</span>rmem<span class="op">),</span> userId<span class="op">(</span>uid<span class="op">)</span> <span class="op">{}</span></span>
<span id="lst-cpplinux1-91"><a href="#lst-cpplinux1-91" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-cpplinux1-92"><a href="#lst-cpplinux1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-93"><a href="#lst-cpplinux1-93" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cpplinux1-94"><a href="#lst-cpplinux1-94" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Classe responsável por enumerar e gerenciar informações de processos no Linux</span></span>
<span id="lst-cpplinux1-95"><a href="#lst-cpplinux1-95" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cpplinux1-96"><a href="#lst-cpplinux1-96" aria-hidden="true" tabindex="-1"></a><span class="co"> * Esta classe encapsula toda a funcionalidade relacionada à coleta</span></span>
<span id="lst-cpplinux1-97"><a href="#lst-cpplinux1-97" aria-hidden="true" tabindex="-1"></a><span class="co"> * de informações sobre processos através do filesystem /proc.</span></span>
<span id="lst-cpplinux1-98"><a href="#lst-cpplinux1-98" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cpplinux1-99"><a href="#lst-cpplinux1-99" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LinuxProcessEnumerator <span class="op">{</span></span>
<span id="lst-cpplinux1-100"><a href="#lst-cpplinux1-100" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="lst-cpplinux1-101"><a href="#lst-cpplinux1-101" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> processes<span class="op">;</span> <span class="co">///&lt; Lista de processos coletados</span></span>
<span id="lst-cpplinux1-102"><a href="#lst-cpplinux1-102" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-103"><a href="#lst-cpplinux1-103" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-104"><a href="#lst-cpplinux1-104" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Verifica se uma string representa um número (PID)</span></span>
<span id="lst-cpplinux1-105"><a href="#lst-cpplinux1-105" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">str</span><span class="co"> String a ser verificada</span></span>
<span id="lst-cpplinux1-106"><a href="#lst-cpplinux1-106" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se a string contém apenas dígitos</span></span>
<span id="lst-cpplinux1-107"><a href="#lst-cpplinux1-107" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-108"><a href="#lst-cpplinux1-108" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isNumeric<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> str<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-109"><a href="#lst-cpplinux1-109" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">!</span>str<span class="op">.</span>empty<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>ranges::all_of<span class="op">(</span>str<span class="op">,</span> <span class="op">::</span>isdigit<span class="op">);</span></span>
<span id="lst-cpplinux1-110"><a href="#lst-cpplinux1-110" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-111"><a href="#lst-cpplinux1-111" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-112"><a href="#lst-cpplinux1-112" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-113"><a href="#lst-cpplinux1-113" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Lê o nome do processo do arquivo /proc/[pid]/comm</span></span>
<span id="lst-cpplinux1-114"><a href="#lst-cpplinux1-114" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">**PID**</span><span class="co"> ID do processo</span></span>
<span id="lst-cpplinux1-115"><a href="#lst-cpplinux1-115" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Nome do processo ou string vazia em caso de erro</span></span>
<span id="lst-cpplinux1-116"><a href="#lst-cpplinux1-116" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-117"><a href="#lst-cpplinux1-117" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string getProcessName<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-118"><a href="#lst-cpplinux1-118" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ifstream commFile<span class="op">(</span><span class="bu">std::</span>format<span class="op">(</span><span class="st">"/proc/</span><span class="sc">{}</span><span class="st">/comm"</span><span class="op">,</span> pid<span class="op">));</span></span>
<span id="lst-cpplinux1-119"><a href="#lst-cpplinux1-119" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="lst-cpplinux1-120"><a href="#lst-cpplinux1-120" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-121"><a href="#lst-cpplinux1-121" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>commFile<span class="op">.</span>is_open<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-122"><a href="#lst-cpplinux1-122" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>getline<span class="op">(</span>commFile<span class="op">,</span> name<span class="op">);</span></span>
<span id="lst-cpplinux1-123"><a href="#lst-cpplinux1-123" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Remove quebra de linha se presente</span></span>
<span id="lst-cpplinux1-124"><a href="#lst-cpplinux1-124" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>name<span class="op">.</span>empty<span class="op">()</span> <span class="op">&amp;&amp;</span> name<span class="op">.</span>back<span class="op">()</span> <span class="op">==</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-125"><a href="#lst-cpplinux1-125" aria-hidden="true" tabindex="-1"></a>                name<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="lst-cpplinux1-126"><a href="#lst-cpplinux1-126" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-cpplinux1-127"><a href="#lst-cpplinux1-127" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cpplinux1-128"><a href="#lst-cpplinux1-128" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-129"><a href="#lst-cpplinux1-129" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> name<span class="op">.</span>empty<span class="op">()</span> <span class="op">?</span> <span class="st">"&lt;desconhecido&gt;"</span> <span class="op">:</span> name<span class="op">;</span></span>
<span id="lst-cpplinux1-130"><a href="#lst-cpplinux1-130" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-131"><a href="#lst-cpplinux1-131" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-132"><a href="#lst-cpplinux1-132" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-133"><a href="#lst-cpplinux1-133" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Lê a linha de comando do processo do arquivo /proc/[pid]/cmdline</span></span>
<span id="lst-cpplinux1-134"><a href="#lst-cpplinux1-134" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">**PID**</span><span class="co"> ID do processo</span></span>
<span id="lst-cpplinux1-135"><a href="#lst-cpplinux1-135" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Linha de comando ou string vazia em caso de erro</span></span>
<span id="lst-cpplinux1-136"><a href="#lst-cpplinux1-136" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-137"><a href="#lst-cpplinux1-137" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string getCommandLine<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-138"><a href="#lst-cpplinux1-138" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ifstream cmdlineFile<span class="op">(</span><span class="bu">std::</span>format<span class="op">(</span><span class="st">"/proc/</span><span class="sc">{}</span><span class="st">/cmdline"</span><span class="op">,</span> pid<span class="op">));</span></span>
<span id="lst-cpplinux1-139"><a href="#lst-cpplinux1-139" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string cmdline<span class="op">;</span></span>
<span id="lst-cpplinux1-140"><a href="#lst-cpplinux1-140" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-141"><a href="#lst-cpplinux1-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cmdlineFile<span class="op">.</span>is_open<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-142"><a href="#lst-cpplinux1-142" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>string fullCmdline<span class="op">;</span></span>
<span id="lst-cpplinux1-143"><a href="#lst-cpplinux1-143" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>getline<span class="op">(</span>cmdlineFile<span class="op">,</span> fullCmdline<span class="op">,</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">);</span></span>
<span id="lst-cpplinux1-144"><a href="#lst-cpplinux1-144" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cpplinux1-145"><a href="#lst-cpplinux1-145" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Substitui caracteres nulos por espaços para legibilidade</span></span>
<span id="lst-cpplinux1-146"><a href="#lst-cpplinux1-146" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c <span class="op">:</span> fullCmdline<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-147"><a href="#lst-cpplinux1-147" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">)</span> c <span class="op">=</span> <span class="ch">' '</span><span class="op">;</span></span>
<span id="lst-cpplinux1-148"><a href="#lst-cpplinux1-148" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-cpplinux1-149"><a href="#lst-cpplinux1-149" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cpplinux1-150"><a href="#lst-cpplinux1-150" aria-hidden="true" tabindex="-1"></a>            cmdline <span class="op">=</span> fullCmdline<span class="op">;</span></span>
<span id="lst-cpplinux1-151"><a href="#lst-cpplinux1-151" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cpplinux1-152"><a href="#lst-cpplinux1-152" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-153"><a href="#lst-cpplinux1-153" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cmdline<span class="op">.</span>empty<span class="op">()</span> <span class="op">?</span> <span class="st">"&lt;não disponível&gt;"</span> <span class="op">:</span> cmdline<span class="op">;</span></span>
<span id="lst-cpplinux1-154"><a href="#lst-cpplinux1-154" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-155"><a href="#lst-cpplinux1-155" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-156"><a href="#lst-cpplinux1-156" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-157"><a href="#lst-cpplinux1-157" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém informações de status do processo do arquivo /proc/[pid]/status</span></span>
<span id="lst-cpplinux1-158"><a href="#lst-cpplinux1-158" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">**PID**</span><span class="co"> ID do processo</span></span>
<span id="lst-cpplinux1-159"><a href="#lst-cpplinux1-159" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Tupla com estado, UID, VmSize e VmRSS</span></span>
<span id="lst-cpplinux1-160"><a href="#lst-cpplinux1-160" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-161"><a href="#lst-cpplinux1-161" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">uid_t</span><span class="op">,</span> <span class="dt">size_t</span><span class="op">,</span> <span class="dt">size_t</span><span class="op">&gt;</span> getProcessStatus<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-162"><a href="#lst-cpplinux1-162" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ifstream statusFile<span class="op">(</span><span class="bu">std::</span>format<span class="op">(</span><span class="st">"/proc/</span><span class="sc">{}</span><span class="st">/status"</span><span class="op">,</span> pid<span class="op">));</span></span>
<span id="lst-cpplinux1-163"><a href="#lst-cpplinux1-163" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string line<span class="op">;</span></span>
<span id="lst-cpplinux1-164"><a href="#lst-cpplinux1-164" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string state <span class="op">=</span> <span class="st">"?"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-165"><a href="#lst-cpplinux1-165" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uid_t</span> uid <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-cpplinux1-166"><a href="#lst-cpplinux1-166" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> vmSize <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> vmRSS <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-cpplinux1-167"><a href="#lst-cpplinux1-167" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-168"><a href="#lst-cpplinux1-168" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>statusFile<span class="op">.</span>is_open<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>getline<span class="op">(</span>statusFile<span class="op">,</span> line<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-169"><a href="#lst-cpplinux1-169" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>istringstream iss<span class="op">(</span>line<span class="op">);</span></span>
<span id="lst-cpplinux1-170"><a href="#lst-cpplinux1-170" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>string key<span class="op">;</span></span>
<span id="lst-cpplinux1-171"><a href="#lst-cpplinux1-171" aria-hidden="true" tabindex="-1"></a>            iss <span class="op">&gt;&gt;</span> key<span class="op">;</span></span>
<span id="lst-cpplinux1-172"><a href="#lst-cpplinux1-172" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cpplinux1-173"><a href="#lst-cpplinux1-173" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>key <span class="op">==</span> <span class="st">"State:"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-174"><a href="#lst-cpplinux1-174" aria-hidden="true" tabindex="-1"></a>                iss <span class="op">&gt;&gt;</span> state<span class="op">;</span></span>
<span id="lst-cpplinux1-175"><a href="#lst-cpplinux1-175" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>key <span class="op">==</span> <span class="st">"Uid:"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-176"><a href="#lst-cpplinux1-176" aria-hidden="true" tabindex="-1"></a>                iss <span class="op">&gt;&gt;</span> uid<span class="op">;</span></span>
<span id="lst-cpplinux1-177"><a href="#lst-cpplinux1-177" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>key <span class="op">==</span> <span class="st">"VmSize:"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-178"><a href="#lst-cpplinux1-178" aria-hidden="true" tabindex="-1"></a>                iss <span class="op">&gt;&gt;</span> vmSize<span class="op">;</span></span>
<span id="lst-cpplinux1-179"><a href="#lst-cpplinux1-179" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>key <span class="op">==</span> <span class="st">"VmRSS:"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-180"><a href="#lst-cpplinux1-180" aria-hidden="true" tabindex="-1"></a>                iss <span class="op">&gt;&gt;</span> vmRSS<span class="op">;</span></span>
<span id="lst-cpplinux1-181"><a href="#lst-cpplinux1-181" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-cpplinux1-182"><a href="#lst-cpplinux1-182" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cpplinux1-183"><a href="#lst-cpplinux1-183" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-184"><a href="#lst-cpplinux1-184" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>state<span class="op">,</span> uid<span class="op">,</span> vmSize<span class="op">,</span> vmRSS<span class="op">};</span></span>
<span id="lst-cpplinux1-185"><a href="#lst-cpplinux1-185" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-186"><a href="#lst-cpplinux1-186" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-187"><a href="#lst-cpplinux1-187" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-188"><a href="#lst-cpplinux1-188" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Converte estado do processo para descrição legível</span></span>
<span id="lst-cpplinux1-189"><a href="#lst-cpplinux1-189" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">state</span><span class="co"> Código do estado (R, S, D, Z, etc.)</span></span>
<span id="lst-cpplinux1-190"><a href="#lst-cpplinux1-190" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Descrição do estado</span></span>
<span id="lst-cpplinux1-191"><a href="#lst-cpplinux1-191" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-192"><a href="#lst-cpplinux1-192" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string getStateDescription<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> state<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-193"><a href="#lst-cpplinux1-193" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>state <span class="op">==</span> <span class="st">"R"</span><span class="op">)</span> <span class="cf">return</span> <span class="st">"Executando"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-194"><a href="#lst-cpplinux1-194" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>state <span class="op">==</span> <span class="st">"S"</span><span class="op">)</span> <span class="cf">return</span> <span class="st">"Dormindo"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-195"><a href="#lst-cpplinux1-195" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>state <span class="op">==</span> <span class="st">"D"</span><span class="op">)</span> <span class="cf">return</span> <span class="st">"Espera `E/S`"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-196"><a href="#lst-cpplinux1-196" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>state <span class="op">==</span> <span class="st">"Z"</span><span class="op">)</span> <span class="cf">return</span> <span class="st">"Zumbi"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-197"><a href="#lst-cpplinux1-197" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>state <span class="op">==</span> <span class="st">"T"</span><span class="op">)</span> <span class="cf">return</span> <span class="st">"Parado"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-198"><a href="#lst-cpplinux1-198" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>state <span class="op">==</span> <span class="st">"X"</span><span class="op">)</span> <span class="cf">return</span> <span class="st">"Morto"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-199"><a href="#lst-cpplinux1-199" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"Desconhecido"</span><span class="op">;</span></span>
<span id="lst-cpplinux1-200"><a href="#lst-cpplinux1-200" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-201"><a href="#lst-cpplinux1-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-202"><a href="#lst-cpplinux1-202" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="lst-cpplinux1-203"><a href="#lst-cpplinux1-203" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-204"><a href="#lst-cpplinux1-204" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Enumera todos os processos em execução no sistema Linux</span></span>
<span id="lst-cpplinux1-205"><a href="#lst-cpplinux1-205" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se a enumeração foi bem-sucedida, false caso contrário</span></span>
<span id="lst-cpplinux1-206"><a href="#lst-cpplinux1-206" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span></span>
<span id="lst-cpplinux1-207"><a href="#lst-cpplinux1-207" aria-hidden="true" tabindex="-1"></a><span class="co">     * Este método lê o diretório /proc para encontrar todos os processos</span></span>
<span id="lst-cpplinux1-208"><a href="#lst-cpplinux1-208" aria-hidden="true" tabindex="-1"></a><span class="co">     * e coleta informações detalhadas de cada um.</span></span>
<span id="lst-cpplinux1-209"><a href="#lst-cpplinux1-209" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-210"><a href="#lst-cpplinux1-210" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> enumerateProcesses<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-211"><a href="#lst-cpplinux1-211" aria-hidden="true" tabindex="-1"></a>        processes<span class="op">.</span>clear<span class="op">();</span></span>
<span id="lst-cpplinux1-212"><a href="#lst-cpplinux1-212" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-213"><a href="#lst-cpplinux1-213" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-214"><a href="#lst-cpplinux1-214" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Itera sobre todos os diretórios em /proc</span></span>
<span id="lst-cpplinux1-215"><a href="#lst-cpplinux1-215" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> entry <span class="op">:</span> <span class="bu">std::</span>filesystem::directory_iterator<span class="op">(</span><span class="st">"/proc"</span><span class="op">))</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-216"><a href="#lst-cpplinux1-216" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>entry<span class="op">.</span>is_directory<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-217"><a href="#lst-cpplinux1-217" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>string dirname <span class="op">=</span> entry<span class="op">.</span>path<span class="op">().</span>filename<span class="op">().</span>string<span class="op">();</span></span>
<span id="lst-cpplinux1-218"><a href="#lst-cpplinux1-218" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="lst-cpplinux1-219"><a href="#lst-cpplinux1-219" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// Verifica se o nome do diretório é um **PID** (número)</span></span>
<span id="lst-cpplinux1-220"><a href="#lst-cpplinux1-220" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>isNumeric<span class="op">(</span>dirname<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-221"><a href="#lst-cpplinux1-221" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">pid_t</span> <span class="op">**</span>PID<span class="op">**</span> <span class="op">=</span> <span class="bu">std::</span>stoi<span class="op">(</span>dirname<span class="op">);</span></span>
<span id="lst-cpplinux1-222"><a href="#lst-cpplinux1-222" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="lst-cpplinux1-223"><a href="#lst-cpplinux1-223" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// Coleta informações do processo</span></span>
<span id="lst-cpplinux1-224"><a href="#lst-cpplinux1-224" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">auto</span> name <span class="op">=</span> getProcessName<span class="op">(</span>pid<span class="op">);</span></span>
<span id="lst-cpplinux1-225"><a href="#lst-cpplinux1-225" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">auto</span> cmdline <span class="op">=</span> getCommandLine<span class="op">(</span>pid<span class="op">);</span></span>
<span id="lst-cpplinux1-226"><a href="#lst-cpplinux1-226" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">auto</span> <span class="op">[</span>state<span class="op">,</span> uid<span class="op">,</span> vmSize<span class="op">,</span> vmRSS<span class="op">]</span> <span class="op">=</span> getProcessStatus<span class="op">(</span>pid<span class="op">);</span></span>
<span id="lst-cpplinux1-227"><a href="#lst-cpplinux1-227" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="lst-cpplinux1-228"><a href="#lst-cpplinux1-228" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// Adiciona à lista</span></span>
<span id="lst-cpplinux1-229"><a href="#lst-cpplinux1-229" aria-hidden="true" tabindex="-1"></a>                        processes<span class="op">.</span>emplace_back<span class="op">(</span>pid<span class="op">,</span> name<span class="op">,</span> cmdline<span class="op">,</span> state<span class="op">,</span> </span>
<span id="lst-cpplinux1-230"><a href="#lst-cpplinux1-230" aria-hidden="true" tabindex="-1"></a>                                             vmSize<span class="op">,</span> vmRSS<span class="op">,</span> uid<span class="op">);</span></span>
<span id="lst-cpplinux1-231"><a href="#lst-cpplinux1-231" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="lst-cpplinux1-232"><a href="#lst-cpplinux1-232" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="lst-cpplinux1-233"><a href="#lst-cpplinux1-233" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-cpplinux1-234"><a href="#lst-cpplinux1-234" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cpplinux1-235"><a href="#lst-cpplinux1-235" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="lst-cpplinux1-236"><a href="#lst-cpplinux1-236" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cpplinux1-237"><a href="#lst-cpplinux1-237" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>filesystem::filesystem_error<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-238"><a href="#lst-cpplinux1-238" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">"Erro ao acessar /proc: "</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cpplinux1-239"><a href="#lst-cpplinux1-239" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="lst-cpplinux1-240"><a href="#lst-cpplinux1-240" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cpplinux1-241"><a href="#lst-cpplinux1-241" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-242"><a href="#lst-cpplinux1-242" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-243"><a href="#lst-cpplinux1-243" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-244"><a href="#lst-cpplinux1-244" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Exibe a lista de processos formatada</span></span>
<span id="lst-cpplinux1-245"><a href="#lst-cpplinux1-245" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span></span>
<span id="lst-cpplinux1-246"><a href="#lst-cpplinux1-246" aria-hidden="true" tabindex="-1"></a><span class="co">     * Utiliza std::format (C++ 20) e ranges (C++ 20) para formatação</span></span>
<span id="lst-cpplinux1-247"><a href="#lst-cpplinux1-247" aria-hidden="true" tabindex="-1"></a><span class="co">     * e manipulação dos dados.</span></span>
<span id="lst-cpplinux1-248"><a href="#lst-cpplinux1-248" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-249"><a href="#lst-cpplinux1-249" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> displayProcesses<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-250"><a href="#lst-cpplinux1-250" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Cabeçalho da tabela</span></span>
<span id="lst-cpplinux1-251"><a href="#lst-cpplinux1-251" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">{:&gt;8}</span><span class="st"> | </span><span class="sc">{:20}</span><span class="st"> | </span><span class="sc">{:8}</span><span class="st"> | </span><span class="sc">{:10}</span><span class="st"> | </span><span class="sc">{:10}</span><span class="st"> | </span><span class="sc">{:6}</span><span class="st"> | </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cpplinux1-252"><a href="#lst-cpplinux1-252" aria-hidden="true" tabindex="-1"></a>                                 <span class="st">"PID"</span><span class="op">,</span> <span class="st">"Nome"</span><span class="op">,</span> <span class="st">"Estado"</span><span class="op">,</span> <span class="st">"VM (KB)"</span><span class="op">,</span> <span class="st">"RSS (KB)"</span><span class="op">,</span> <span class="st">"UID"</span><span class="op">,</span> <span class="st">"Comando"</span><span class="op">);</span></span>
<span id="lst-cpplinux1-253"><a href="#lst-cpplinux1-253" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>string<span class="op">(</span><span class="dv">100</span><span class="op">,</span> <span class="ch">'-'</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cpplinux1-254"><a href="#lst-cpplinux1-254" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-255"><a href="#lst-cpplinux1-255" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Ordena os processos por **PID** usando ranges (C++ 20)</span></span>
<span id="lst-cpplinux1-256"><a href="#lst-cpplinux1-256" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sortedProcesses <span class="op">=</span> processes<span class="op">;</span></span>
<span id="lst-cpplinux1-257"><a href="#lst-cpplinux1-257" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ranges::sort<span class="op">(</span>sortedProcesses<span class="op">,</span> </span>
<span id="lst-cpplinux1-258"><a href="#lst-cpplinux1-258" aria-hidden="true" tabindex="-1"></a>                         <span class="op">[](</span><span class="at">const</span> ProcessInfo<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> ProcessInfo<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-259"><a href="#lst-cpplinux1-259" aria-hidden="true" tabindex="-1"></a>                             <span class="cf">return</span> a<span class="op">.</span>processId <span class="op">&lt;</span> b<span class="op">.</span>processId<span class="op">;</span></span>
<span id="lst-cpplinux1-260"><a href="#lst-cpplinux1-260" aria-hidden="true" tabindex="-1"></a>                         <span class="op">});</span></span>
<span id="lst-cpplinux1-261"><a href="#lst-cpplinux1-261" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-262"><a href="#lst-cpplinux1-262" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Exibe cada processo</span></span>
<span id="lst-cpplinux1-263"><a href="#lst-cpplinux1-263" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> proc <span class="op">:</span> sortedProcesses<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-264"><a href="#lst-cpplinux1-264" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>string truncatedCmd <span class="op">=</span> proc<span class="op">.</span>commandLine<span class="op">.</span>substr<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">30</span><span class="op">);</span></span>
<span id="lst-cpplinux1-265"><a href="#lst-cpplinux1-265" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>string stateDesc <span class="op">=</span> getStateDescription<span class="op">(</span>proc<span class="op">.</span>state<span class="op">);</span></span>
<span id="lst-cpplinux1-266"><a href="#lst-cpplinux1-266" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="lst-cpplinux1-267"><a href="#lst-cpplinux1-267" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">{:8}</span><span class="st"> | </span><span class="sc">{:20}</span><span class="st"> | </span><span class="sc">{:8}</span><span class="st"> | </span><span class="sc">{:10}</span><span class="st"> | </span><span class="sc">{:10}</span><span class="st"> | </span><span class="sc">{:6}</span><span class="st"> | </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-cpplinux1-268"><a href="#lst-cpplinux1-268" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>processId<span class="op">,</span></span>
<span id="lst-cpplinux1-269"><a href="#lst-cpplinux1-269" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>processName<span class="op">.</span>substr<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">20</span><span class="op">),</span></span>
<span id="lst-cpplinux1-270"><a href="#lst-cpplinux1-270" aria-hidden="true" tabindex="-1"></a>                                     stateDesc<span class="op">.</span>substr<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">8</span><span class="op">),</span></span>
<span id="lst-cpplinux1-271"><a href="#lst-cpplinux1-271" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>virtualMemory<span class="op">,</span></span>
<span id="lst-cpplinux1-272"><a href="#lst-cpplinux1-272" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>residentMemory<span class="op">,</span></span>
<span id="lst-cpplinux1-273"><a href="#lst-cpplinux1-273" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>userId<span class="op">,</span></span>
<span id="lst-cpplinux1-274"><a href="#lst-cpplinux1-274" aria-hidden="true" tabindex="-1"></a>                                     truncatedCmd<span class="op">);</span></span>
<span id="lst-cpplinux1-275"><a href="#lst-cpplinux1-275" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cpplinux1-276"><a href="#lst-cpplinux1-276" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-277"><a href="#lst-cpplinux1-277" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Total de processos: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> processes<span class="op">.</span>size<span class="op">());</span></span>
<span id="lst-cpplinux1-278"><a href="#lst-cpplinux1-278" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-279"><a href="#lst-cpplinux1-279" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-280"><a href="#lst-cpplinux1-280" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-281"><a href="#lst-cpplinux1-281" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém estatísticas dos processos</span></span>
<span id="lst-cpplinux1-282"><a href="#lst-cpplinux1-282" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Tupla com número total, memória virtual e residente total</span></span>
<span id="lst-cpplinux1-283"><a href="#lst-cpplinux1-283" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-284"><a href="#lst-cpplinux1-284" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> <span class="dt">size_t</span><span class="op">,</span> <span class="dt">size_t</span><span class="op">&gt;</span> getStatistics<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-285"><a href="#lst-cpplinux1-285" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> totalVirtualMemory <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> totalResidentMemory <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-cpplinux1-286"><a href="#lst-cpplinux1-286" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-287"><a href="#lst-cpplinux1-287" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> proc <span class="op">:</span> processes<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-288"><a href="#lst-cpplinux1-288" aria-hidden="true" tabindex="-1"></a>            totalVirtualMemory <span class="op">+=</span> proc<span class="op">.</span>virtualMemory<span class="op">;</span></span>
<span id="lst-cpplinux1-289"><a href="#lst-cpplinux1-289" aria-hidden="true" tabindex="-1"></a>            totalResidentMemory <span class="op">+=</span> proc<span class="op">.</span>residentMemory<span class="op">;</span></span>
<span id="lst-cpplinux1-290"><a href="#lst-cpplinux1-290" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cpplinux1-291"><a href="#lst-cpplinux1-291" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-292"><a href="#lst-cpplinux1-292" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>processes<span class="op">.</span>size<span class="op">(),</span> totalVirtualMemory<span class="op">,</span> totalResidentMemory<span class="op">};</span></span>
<span id="lst-cpplinux1-293"><a href="#lst-cpplinux1-293" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-294"><a href="#lst-cpplinux1-294" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-295"><a href="#lst-cpplinux1-295" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-296"><a href="#lst-cpplinux1-296" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Filtra processos por nome</span></span>
<span id="lst-cpplinux1-297"><a href="#lst-cpplinux1-297" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">namePattern</span><span class="co"> Padrão do nome para filtrar</span></span>
<span id="lst-cpplinux1-298"><a href="#lst-cpplinux1-298" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Vetor com processos que correspondem ao padrão</span></span>
<span id="lst-cpplinux1-299"><a href="#lst-cpplinux1-299" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-300"><a href="#lst-cpplinux1-300" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> filterByName<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> namePattern<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-301"><a href="#lst-cpplinux1-301" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> filtered<span class="op">;</span></span>
<span id="lst-cpplinux1-302"><a href="#lst-cpplinux1-302" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-303"><a href="#lst-cpplinux1-303" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ranges::copy_if<span class="op">(</span>processes<span class="op">,</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>filtered<span class="op">),</span></span>
<span id="lst-cpplinux1-304"><a href="#lst-cpplinux1-304" aria-hidden="true" tabindex="-1"></a>                            <span class="op">[&amp;</span>namePattern<span class="op">](</span><span class="at">const</span> ProcessInfo<span class="op">&amp;</span> proc<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-305"><a href="#lst-cpplinux1-305" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">return</span> proc<span class="op">.</span>processName<span class="op">.</span>find<span class="op">(</span>namePattern<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="lst-cpplinux1-306"><a href="#lst-cpplinux1-306" aria-hidden="true" tabindex="-1"></a>                            <span class="op">});</span></span>
<span id="lst-cpplinux1-307"><a href="#lst-cpplinux1-307" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-308"><a href="#lst-cpplinux1-308" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filtered<span class="op">;</span></span>
<span id="lst-cpplinux1-309"><a href="#lst-cpplinux1-309" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-310"><a href="#lst-cpplinux1-310" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-311"><a href="#lst-cpplinux1-311" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-312"><a href="#lst-cpplinux1-312" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Filtra processos por usuário</span></span>
<span id="lst-cpplinux1-313"><a href="#lst-cpplinux1-313" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">uid</span><span class="co"> ID do usuário</span></span>
<span id="lst-cpplinux1-314"><a href="#lst-cpplinux1-314" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Vetor com processos do usuário especificado</span></span>
<span id="lst-cpplinux1-315"><a href="#lst-cpplinux1-315" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-316"><a href="#lst-cpplinux1-316" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> filterByUser<span class="op">(</span><span class="dt">uid_t</span> uid<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-317"><a href="#lst-cpplinux1-317" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> filtered<span class="op">;</span></span>
<span id="lst-cpplinux1-318"><a href="#lst-cpplinux1-318" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-319"><a href="#lst-cpplinux1-319" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ranges::copy_if<span class="op">(</span>processes<span class="op">,</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>filtered<span class="op">),</span></span>
<span id="lst-cpplinux1-320"><a href="#lst-cpplinux1-320" aria-hidden="true" tabindex="-1"></a>                            <span class="op">[</span>uid<span class="op">](</span><span class="at">const</span> ProcessInfo<span class="op">&amp;</span> proc<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-321"><a href="#lst-cpplinux1-321" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">return</span> proc<span class="op">.</span>userId <span class="op">==</span> uid<span class="op">;</span></span>
<span id="lst-cpplinux1-322"><a href="#lst-cpplinux1-322" aria-hidden="true" tabindex="-1"></a>                            <span class="op">});</span></span>
<span id="lst-cpplinux1-323"><a href="#lst-cpplinux1-323" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-324"><a href="#lst-cpplinux1-324" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filtered<span class="op">;</span></span>
<span id="lst-cpplinux1-325"><a href="#lst-cpplinux1-325" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-326"><a href="#lst-cpplinux1-326" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-327"><a href="#lst-cpplinux1-327" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-cpplinux1-328"><a href="#lst-cpplinux1-328" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém processos com maior uso de memória</span></span>
<span id="lst-cpplinux1-329"><a href="#lst-cpplinux1-329" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">count</span><span class="co"> Número de processos a retornar</span></span>
<span id="lst-cpplinux1-330"><a href="#lst-cpplinux1-330" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Vetor com os processos que mais consomem memória</span></span>
<span id="lst-cpplinux1-331"><a href="#lst-cpplinux1-331" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-cpplinux1-332"><a href="#lst-cpplinux1-332" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;</span> getTopMemoryConsumers<span class="op">(</span><span class="dt">size_t</span> count <span class="op">=</span> <span class="dv">10</span><span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-333"><a href="#lst-cpplinux1-333" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sortedByMemory <span class="op">=</span> processes<span class="op">;</span></span>
<span id="lst-cpplinux1-334"><a href="#lst-cpplinux1-334" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-335"><a href="#lst-cpplinux1-335" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ranges::partial_sort<span class="op">(</span>sortedByMemory<span class="op">,</span> </span>
<span id="lst-cpplinux1-336"><a href="#lst-cpplinux1-336" aria-hidden="true" tabindex="-1"></a>                                 sortedByMemory<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> <span class="bu">std::</span>min<span class="op">(</span>count<span class="op">,</span> sortedByMemory<span class="op">.</span>size<span class="op">()),</span></span>
<span id="lst-cpplinux1-337"><a href="#lst-cpplinux1-337" aria-hidden="true" tabindex="-1"></a>                                 <span class="op">[](</span><span class="at">const</span> ProcessInfo<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> ProcessInfo<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-338"><a href="#lst-cpplinux1-338" aria-hidden="true" tabindex="-1"></a>                                     <span class="cf">return</span> a<span class="op">.</span>residentMemory <span class="op">&gt;</span> b<span class="op">.</span>residentMemory<span class="op">;</span></span>
<span id="lst-cpplinux1-339"><a href="#lst-cpplinux1-339" aria-hidden="true" tabindex="-1"></a>                                 <span class="op">});</span></span>
<span id="lst-cpplinux1-340"><a href="#lst-cpplinux1-340" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="lst-cpplinux1-341"><a href="#lst-cpplinux1-341" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>ProcessInfo<span class="op">&gt;(</span>sortedByMemory<span class="op">.</span>begin<span class="op">(),</span> </span>
<span id="lst-cpplinux1-342"><a href="#lst-cpplinux1-342" aria-hidden="true" tabindex="-1"></a>                                       sortedByMemory<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> <span class="bu">std::</span>min<span class="op">(</span>count<span class="op">,</span> sortedByMemory<span class="op">.</span>size<span class="op">()));</span></span>
<span id="lst-cpplinux1-343"><a href="#lst-cpplinux1-343" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-344"><a href="#lst-cpplinux1-344" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-cpplinux1-345"><a href="#lst-cpplinux1-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-cpplinux1-346"><a href="#lst-cpplinux1-346" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-cpplinux1-347"><a href="#lst-cpplinux1-347" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Função principal do programa</span></span>
<span id="lst-cpplinux1-348"><a href="#lst-cpplinux1-348" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co"> Código de saída (0 para sucesso)</span></span>
<span id="lst-cpplinux1-349"><a href="#lst-cpplinux1-349" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="lst-cpplinux1-350"><a href="#lst-cpplinux1-350" aria-hidden="true" tabindex="-1"></a><span class="co"> * Demonstra o uso da classe LinuxProcessEnumerator para listar</span></span>
<span id="lst-cpplinux1-351"><a href="#lst-cpplinux1-351" aria-hidden="true" tabindex="-1"></a><span class="co"> * processos em execução no sistema Linux.</span></span>
<span id="lst-cpplinux1-352"><a href="#lst-cpplinux1-352" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-cpplinux1-353"><a href="#lst-cpplinux1-353" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-354"><a href="#lst-cpplinux1-354" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"=== Listador de Processos **Linux** - C++23 ==="</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cpplinux1-355"><a href="#lst-cpplinux1-355" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Coletando informações dos processos via /proc..."</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cpplinux1-356"><a href="#lst-cpplinux1-356" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-357"><a href="#lst-cpplinux1-357" aria-hidden="true" tabindex="-1"></a>    LinuxProcessEnumerator enumerator<span class="op">;</span></span>
<span id="lst-cpplinux1-358"><a href="#lst-cpplinux1-358" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-359"><a href="#lst-cpplinux1-359" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>enumerator<span class="op">.</span>enumerateProcesses<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-360"><a href="#lst-cpplinux1-360" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">"Falha ao enumerar processos!"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="lst-cpplinux1-361"><a href="#lst-cpplinux1-361" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="lst-cpplinux1-362"><a href="#lst-cpplinux1-362" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-363"><a href="#lst-cpplinux1-363" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-364"><a href="#lst-cpplinux1-364" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exibe os processos</span></span>
<span id="lst-cpplinux1-365"><a href="#lst-cpplinux1-365" aria-hidden="true" tabindex="-1"></a>    enumerator<span class="op">.</span>displayProcesses<span class="op">();</span></span>
<span id="lst-cpplinux1-366"><a href="#lst-cpplinux1-366" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-367"><a href="#lst-cpplinux1-367" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exibe estatísticas</span></span>
<span id="lst-cpplinux1-368"><a href="#lst-cpplinux1-368" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">[</span>processCount<span class="op">,</span> totalVirtualMem<span class="op">,</span> totalResidentMem<span class="op">]</span> <span class="op">=</span> enumerator<span class="op">.</span>getStatistics<span class="op">();</span></span>
<span id="lst-cpplinux1-369"><a href="#lst-cpplinux1-369" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Estatísticas do Sistema:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="lst-cpplinux1-370"><a href="#lst-cpplinux1-370" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"- Processos em execução: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> processCount<span class="op">);</span></span>
<span id="lst-cpplinux1-371"><a href="#lst-cpplinux1-371" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"- Memória virtual total: {:.f} MB</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cpplinux1-372"><a href="#lst-cpplinux1-372" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>totalVirtualMem<span class="op">)</span> <span class="op">/</span> <span class="dv">1024</span><span class="op">);</span></span>
<span id="lst-cpplinux1-373"><a href="#lst-cpplinux1-373" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"- Memória residente total: {:.f} MB</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cpplinux1-374"><a href="#lst-cpplinux1-374" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>totalResidentMem<span class="op">)</span> <span class="op">/</span> <span class="dv">1024</span><span class="op">);</span></span>
<span id="lst-cpplinux1-375"><a href="#lst-cpplinux1-375" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"- **PID** do processo atual: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> getpid<span class="op">());</span></span>
<span id="lst-cpplinux1-376"><a href="#lst-cpplinux1-376" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-377"><a href="#lst-cpplinux1-377" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exemplo de análises adicionais</span></span>
<span id="lst-cpplinux1-378"><a href="#lst-cpplinux1-378" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Pressione Enter para ver análises adicionais..."</span><span class="op">;</span></span>
<span id="lst-cpplinux1-379"><a href="#lst-cpplinux1-379" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>get<span class="op">();</span></span>
<span id="lst-cpplinux1-380"><a href="#lst-cpplinux1-380" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-381"><a href="#lst-cpplinux1-381" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Top 5 processos por uso de memória</span></span>
<span id="lst-cpplinux1-382"><a href="#lst-cpplinux1-382" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> topMemory <span class="op">=</span> enumerator<span class="op">.</span>getTopMemoryConsumers<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="lst-cpplinux1-383"><a href="#lst-cpplinux1-383" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>topMemory<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-384"><a href="#lst-cpplinux1-384" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Top 5 processos por uso de memória:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="lst-cpplinux1-385"><a href="#lst-cpplinux1-385" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> proc <span class="op">:</span> topMemory<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-386"><a href="#lst-cpplinux1-386" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"- **PID** </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="st"> (</span><span class="sc">{}</span><span class="st"> KB RSS)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cpplinux1-387"><a href="#lst-cpplinux1-387" aria-hidden="true" tabindex="-1"></a>                                     proc<span class="op">.</span>processId<span class="op">,</span> proc<span class="op">.</span>processName<span class="op">,</span> proc<span class="op">.</span>residentMemory<span class="op">);</span></span>
<span id="lst-cpplinux1-388"><a href="#lst-cpplinux1-388" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-cpplinux1-389"><a href="#lst-cpplinux1-389" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-390"><a href="#lst-cpplinux1-390" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-391"><a href="#lst-cpplinux1-391" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Processos do usuário atual</span></span>
<span id="lst-cpplinux1-392"><a href="#lst-cpplinux1-392" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> userProcesses <span class="op">=</span> enumerator<span class="op">.</span>filterByUser<span class="op">(</span>getuid<span class="op">());</span></span>
<span id="lst-cpplinux1-393"><a href="#lst-cpplinux1-393" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Processos do usuário atual (UID </span><span class="sc">{}</span><span class="st">): </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cpplinux1-394"><a href="#lst-cpplinux1-394" aria-hidden="true" tabindex="-1"></a>                             getuid<span class="op">(),</span> userProcesses<span class="op">.</span>size<span class="op">());</span></span>
<span id="lst-cpplinux1-395"><a href="#lst-cpplinux1-395" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-396"><a href="#lst-cpplinux1-396" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exemplo de filtragem por nome</span></span>
<span id="lst-cpplinux1-397"><a href="#lst-cpplinux1-397" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> systemdProcesses <span class="op">=</span> enumerator<span class="op">.</span>filterByName<span class="op">(</span><span class="st">"systemd"</span><span class="op">);</span></span>
<span id="lst-cpplinux1-398"><a href="#lst-cpplinux1-398" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>systemdProcesses<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="lst-cpplinux1-399"><a href="#lst-cpplinux1-399" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Processos relacionados ao systemd: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="lst-cpplinux1-400"><a href="#lst-cpplinux1-400" aria-hidden="true" tabindex="-1"></a>                                 systemdProcesses<span class="op">.</span>size<span class="op">());</span></span>
<span id="lst-cpplinux1-401"><a href="#lst-cpplinux1-401" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-cpplinux1-402"><a href="#lst-cpplinux1-402" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="lst-cpplinux1-403"><a href="#lst-cpplinux1-403" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-cpplinux1-404"><a href="#lst-cpplinux1-404" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p>O código <a href="#lst-cpplinux1" class="quarto-xref">Listing&nbsp;<span>3</span></a> implementa um sistema para enumerar e exibir informações sobre processos em execução no Ubuntu/Linux, utilizando uma abordagem fundamentalmente diferente do <strong>Windows</strong> através do <em>filesystem virtual</em> <code>/proc</code>. A estrutura principal continua organizada em torno de uma classe. Neste caso, a classe <code>LinuxProcessEnumerator</code>, que encapsula toda a funcionalidade de coleta de dados, mas agora opera lendo arquivos do sistema de arquivos especial <code>/proc</code> ao invés de chamar <code>APIs</code>diretas do <code>kernel</code>. A estrutura <code>ProcessInfo</code> foi adaptada para refletir as informações específicas disponíveis no <strong>Linux</strong>, incluindo estados de processo mais detalhados (<code>state</code>), separação entre memória virtual (<code>virtualMemory</code>) e residente (<code>residentMemory</code>), e identificação do usuário proprietário (<code>userId</code>). Esta organização mantém os princípios de orientação a objetos enquanto se adapta às características únicas do sistema Linux.</p>
<p>A coleta de informações é realizada através do método <code>enumerateProcesses()</code>, que utiliza <code>std::filesystem::directory_iterator</code> para percorrer o diretório <code>/proc</code> e identificar subdiretórios com nomes numéricos que correspondem aos <strong>PID</strong>s dos processos. Para cada processo encontrado, o programa lê sistematicamente três arquivos principais: <code>/proc/[pid]/comm</code> através de <code>getProcessName()</code> para obter o nome do executável, <code>/proc/[pid]/cmdline</code> via <code>getCommandLine()</code> para recuperar a linha de comando completa com argumentos, e <code>/proc/[pid]/status</code> usando <code>getProcessStatus()</code> para extrair informações detalhadas como estado do processo, UID do proprietário, tamanho da memória virtual e memória residente. O método <code>getProcessStatus()</code> implementa parsing sofisticado usando <code>std::istringstream</code> para extrair campos específicos do arquivo de status, demonstrando como interfaces textuais podem ser processadas de forma robusta.</p>
<p>A exibição dos dados mantém a elegância do código <strong>Windows</strong> através do método <code>displayProcesses()</code>, que continua utilizando <code>std::format</code> para formatação e <code>std::ranges::sort</code> para ordenação, mas agora inclui informações específicas do <strong>Linux</strong> como estados de processo traduzidos através de <code>getStateDescription()</code> que converte códigos como “R”, “S”, “D”, “Z” em descrições legíveis. O programa oferece funcionalidades estendidas como <code>filterByUser()</code> que permite filtrar processos por <strong>UID</strong>. No <strong>Linux</strong> o <strong>U</strong>ser <strong>ID</strong>entifier, <strong>UID</strong>, é um número inteiro único atribuído pelo <strong>Sistema Operacional</strong> para identificar cada usuário no sistema. Quando um usuário é criado, o sistema automaticamente lhe atribui um <strong>UID</strong> que permanece constante durante toda a existência daquela conta de usuário. No <a href="#lst-cpplinux1" class="quarto-xref">Listing&nbsp;<span>3</span></a> filtramos processos por <strong>UID</strong> usando <code>std::ranges::copy_if</code>, e <code>getTopMemoryConsumers()</code> que implementa esta análise com <code>std::ranges::partial_sort</code> para identificar os processos que mais consomem memória. Novamente, a função <code>main()</code> demonstra o uso prático dessas funcionalidades, incluindo análises estatísticas que mostram tanto memória virtual quanto residente, e utiliza funções POSIX como <code>getpid()</code> e <code>getuid()</code> para contextualizar as informações.</p>
<p>O código exemplifica como os mesmos conceitos fundamentais de <strong>Sistemas Operacionais</strong> podem ser implementados através de interfaces completamente diferentes, contrastando as chamadas diretas de API do <strong>Windows</strong> com a filosofia Unix de <em>tudo é arquivo</em>. Finalmente, esta nova implementação garante tratamento de erros através de blocos <code>try-catch</code> para <code>std::filesystem::filesystem_error</code> e verificações de validade ao abrir arquivos com <code>std::ifstream</code>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Tudo é arquivo, mas nem sempre</strong> A filosofia tudo é arquivo, em inglês <em>everything is a file</em> é um princípio fundamental dos sistemas Unix/Linux nos quais recursos do sistema, dispositivos, processos e informações são expostos como arquivos no sistema de arquivos. No contexto do nosso primeiro programa, esta filosofia se manifesta através do diretório <code>/proc</code>, que é um sistema de arquivos virtual em que o <code>kernel</code> expõe informações sobre processos em execução como arquivos de texto legíveis. Quando acessamos <code>/proc/1234/status</code> ou <code>/proc/1234/comm</code>, não estamos lendo arquivos físicos do disco, mas interfaces textuais que o <code>kernel</code> gera dinamicamente para representar o estado interno dos processos.</p>
<p>Esta abordagem contrasta fundamentalmente com o <strong>Windows</strong> 11, que utiliza <code>APIs</code>binárias diretas através de chamadas de sistema como <code>OpenProcess()</code>, <code>EnumProcesses()</code> e <code>GetProcessMemoryInfo()</code>. No Windows, para obter informações de um processo, o programa deve fazer chamadas específicas que retornam estruturas de dados em formato binário, exigindo conhecimento detalhado dos tipos de dados e handles do sistema. O acesso é controlado através de permissões específicas passadas para <code>OpenProcess()</code>, e cada tipo de informação requer uma chamada de API diferente.</p>
<p>A filosofia Unix oferece uniformidade, o mesmo conjunto de operações de arquivo (<code>open()</code>, <code>read()</code>, <code>close()</code>) pode ser usado para interagir com processos, dispositivos de hardware, configurações do <code>kernel</code> e arquivos reais. Isso permite que ferramentas simples como <code>cat /proc/cpuinfo</code> ou <code>cat /proc/meminfo</code> forneçam informações do sistema sem necessidade de programas especializados. Por outro lado, o <strong>Windows</strong> oferece interfaces mais tipadas e estruturadas que podem ser mais eficientes e menos ambíguas, mas requerem conhecimento específico de cada API.</p>
<p>O sistema de arquivo <code>/proc</code> é uma camada de abstração, a ativa leitora não estará lendo arquivos reais do disco, mas sim interfaces que o <code>kernel</code> gera dinamicamente na memória com dados que estão também na memória. Por exemplo, se a leitora executar <code>cat /proc/1234/status</code>, o <code>kernel</code> intercepta essa operação de leitura e constrói o conteúdo do arquivo em tempo real consultando suas estruturas internas de dados sobre aquele processo. Tecnicamente, <code>/proc</code> é classificado como um sistema de arquivos virtual, pseudo sistema de arquivos, que existe apenas na memória <code>RAM</code>. O <code>kernel</code> mantém uma tabela de funções <em>callback</em> que são executadas quando alguém tenta ler esses arquivos virtuais. Por exemplo, quando você lê <code>/proc/meminfo</code>, o <code>kernel</code> executa uma função específica que coleta estatísticas atuais de memória de suas estruturas de dados internas e formata essa informação como texto legível. Para deixar claro lembr-se que funções <em>callback são ponteiros para funções que são passados como parâmetros para outras funções e executados em momentos específicos durante a execução do programa</em>.</p>
<p>Esta abstração é poderosa porque permite que ferramentas existentes de manipulação de arquivos (<code>cat</code>, <code>grep</code>, <code>awk</code>, editores de texto) sejam usadas para inspecionar o estado do sistema sem precisar de <code>APIs</code>especiais. O custo computacional extra é mínimo, não há <code>E/S</code> de disco envolvido, apenas a conversão de estruturas binárias do <code>kernel</code> para representação textual na memória todo o custo está em converter o binário para texto no formato correto, movendo dados de um bloco de memória para outro. Quando nosso programa C++ faz <code>std::ifstream commFile("/proc/1234/comm")</code>, está realmente solicitando ao <code>kernel</code> que formate o nome do processo em um <em>string</em> e a retorne através da interface familiar de arquivos.</p>
<p>Isso explica por que arquivos em <code>/proc</code> sempre mostram tamanho zero quando você executa <code>ls -l</code>. Estes arquivos não ocupam espaço em disco, existem apenas como pontos de entrada para funções do <code>kernel</code> que geram conteúdo sob demanda.</p>
<p>Ambas as abordagens têm vantagens: a interface textual do <strong>Linux</strong> é mais acessível para scripts e ferramentas de linha de comando, enquanto as <code>APIs</code>binárias do <strong>Windows</strong> oferecem mais performance e verificação de tipos em tempo de compilação. Os custos computacionais são diferentes, mas a verdadeira diferença está no público alvo: administradores de sistemas, desenvolvedores de sistemas.</p>
</div>
</div>
<p>Agora que a ansiosa leitora já sabe criar processos manualmente, precisamos entender o seu ciclo de vida. Já passamos pelo processo de gestão de processos, superficialmente na seção <a href="#sec-processos1" class="quarto-xref"><span>Processos</span></a>. Na próxima seção, mergulharemos fundo.</p>
</section>
<section id="clico-de-vida-de-um-processo" class="level3">
<h3 class="anchored" data-anchor-id="clico-de-vida-de-um-processo">Clico de vida de um Processo</h3>
<p>A capacidade de um <strong>Sistema Operacional</strong> de gerenciar múltiplos processos simultaneamente, que a atenta leitora deve chamar de multitarefa, multiprograma, é a quilha que suporta toda a estrutura que permite que um usuário navegue na web enquanto ouve música, receba notificações por e-mail e escreva um livro sobre <strong>Sistemas Operacionais</strong>. Em sistemas com um único processador, essa simultaneidade é uma ilusão cuidadosamente orquestrada, denominada pseudo-paralelismo. O <strong>Sistema Operacional</strong> alterna a Unidade Central de Processamento, <code>CPU</code> entre vários processos em intervalos de tempo muito curtos, criando a percepção de que eles estão sendo executados em paralelo e ao mesmo tempo. Apenas em sistemas multiprocessador, o verdadeiro paralelismo é alcançado, com diferentes processos sendo executados em diferentes núcleos de <code>CPU</code> ao mesmo tempo.</p>
<p>Para gerenciar essa complexa dança de tarefas concorrentes, o <strong>Sistema Operacional</strong> abstrai o ciclo de vida de cada processo em um conjunto de estados discretos. Este é o mecanismo central pelo qual o <strong>Sistema Operacional</strong> aloca recursos, garante a justiça, impõe a proteção e mantém a estabilidade do sistema. a transição de um processo entre esses estados é um evento que dita quando um processo pode usar a <code>CPU</code>, quando deve esperar por recursos e quando deve ceder o controle.</p>
<p>Nesta parte da nossa jornada, iniciaremos explorando a evolução dos modelos teóricos, desde os mais simples até os mais complexos que incorporam o gerenciamento de memória virtual. Ao chegarmos o porto termos uma compreensão abrangente de como um processo nasce, vive e morre dentro do ecossistema de um <strong>Sistema Operacional</strong>.</p>
</section>
<section id="modelos-teóricos-do-ciclo-de-vida-do-processo" class="level3">
<h3 class="anchored" data-anchor-id="modelos-teóricos-do-ciclo-de-vida-do-processo">Modelos Teóricos do Ciclo de Vida do Processo</h3>
<p>O modelo mais rudimentar do ciclo de vida de um processo é o <strong>modelo de dois estados</strong>. Neste modelo, um processo pode estar em apenas um de dois estados: <strong><em>Executando</em></strong>, em inglês <em>Running</em>, <strong>Não-Executando</strong>, em inglês <em>Not-running</em>. Quando o <strong>Sistema Operacional</strong> cria um novo processo, ele o coloca em uma fila no estado <strong>Não-Executando</strong>. Quando o processo em execução atual é pausado, o despachante, em inglês <em>dispatcher</em>, do <strong>Sistema Operacional</strong> seleciona um processo da fila de <strong>Não-Executando</strong> e o move para o estado <strong><em>Executando</em></strong>. Simples, limpo e fácil de implementar. Tudo que precisamos é olhar a fila e executar o processo que estiver há mais tempo como <strong>Não-Executando</strong>. Este modelo é adequado para sistemas muito simples, nos quais não exista necessidade de distinguir entre processos prontos para serem executados e aqueles que estão esperando por recursos externos, como Entrada/Saída, <code>E/S</code>. Talvez para um sistema embarcado.</p>
<p>A simplicidade deste modelo, no entanto, esconde uma falha fundamental que o torna inadequado para qualquer sistema de multitarefa real. O estado <strong>Não-Executando</strong> agrupa indiscriminadamente duas categorias de processos fundamentalmente diferentes: aqueles que estão prontos para serem executados e apenas aguardam a disponibilidade da <code>CPU</code>, e aqueles que estão bloqueados, esperando pela conclusão de uma operação de Entrada/Saída. Esta falta de distinção é problemática. O despachante não pode simplesmente selecionar o processo que está há mais tempo na fila de <strong>Não-Executando</strong>. Esse processo que está há mais tempo na fila pode estar bloqueado esperando por uma leitura de disco e, portanto, incapaz de utilizar a <code>CPU</code>. Escolher tal processo resultaria em desperdício de ciclos de <code>CPU</code> e em uma utilização ineficiente do sistema. A necessidade de um agendamento mais inteligente e eficiente impulsionou o desenvolvimento de modelos mais granulares. Um tanto mais complexos. A <a href="#fig-twoprocess" class="quarto-xref">Figure&nbsp;<span>2</span></a> representa esse modelo de dois estados.</p>
<div id="fig-twoprocess" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-twoprocess-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/modelo_dois_estados.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-twoprocess-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Modelo de dois estados do ciclo de vida do processo mostrando uma representação da fila de processos <strong>Não-Executando</strong> e o processo <strong>Executando</strong>. O modelo de dois estados é simples, mas não distingue entre processos prontos e bloqueados, levando a ineficiências no agendamento.
</figcaption>
</figure>
</div>
<section id="o-modelo-canônico-de-cinco-estados" class="level4">
<h4 class="anchored" data-anchor-id="o-modelo-canônico-de-cinco-estados">O Modelo Canônico de Cinco Estados</h4>
<p>Para resolver as deficiências do modelo de dois estados, o estado <strong>Não-Executando</strong> foi dividido em dois novos estados: <strong><em>Pronto</em></strong>, em inglês <em>Ready</em> e <strong><em>Bloqueado</em></strong>, <em>Blocked</em>. Essa separação é o avanço chave do <strong>modelo de cinco estados</strong>, que se tornou o modelo canônico para descrever o ciclo de vida de um processo na teoria dos <strong>Sistemas Operacionais</strong>. Este modelo, como vimos anteriormente na <a href="#sec-processos1" class="quarto-xref"><span>Processos</span></a> é composto pelos seguintes estados:</p>
<ul>
<li><p><strong>Novo (<em>New</em>)</strong>: este é o estado inicial de um processo. O <strong>Sistema Operacional</strong> realizou as etapas preliminares para criar o processo, como a alocação de um identificador de processo (<strong>PID</strong>) e a criação de suas estruturas de dados internas, notadamente o Bloco de Controle de Processo (<strong>PCB</strong>). No entanto, o processo ainda não foi admitido no conjunto de processos que competem pela <code>CPU</code> e pode ainda não ter seu espaço de memória principal alocado.</p></li>
<li><p><strong>Pronto (<em>Ready</em>)</strong>: um processo no estado <strong>Pronto</strong> está totalmente preparado para ser executado. Ele possui todos os recursos necessários, reside na memória principal e aguarda apenas uma oportunidade para ser alocado à <code>CPU</code> pelo agendador de tarefas, em inglês <em>scheduler</em>. Processos neste estado são mantidos em uma fila, comumente chamada de fila de prontos.</p></li>
<li><p><strong>Executando (<em>Running</em>)</strong>: neste estado, as instruções do processo estão sendo ativamente executadas pela <code>CPU</code>. Em um sistema com um único processador, apenas um processo pode estar no estado <strong>Executando</strong> a qualquer momento.</p></li>
<li><p><strong>Bloqueado/Esperando (<em>Blocked/Waiting</em>)</strong>: um processo transita para o estado <strong>Bloqueado</strong> quando não pode continuar sua execução, mesmo que a <code>CPU</code> esteja disponível. Isso ocorre porque ele precisa esperar por algum evento externo. Os exemplos mais comuns são a espera pela conclusão de uma operação de <code>E/S</code>, tais como ler dados de um disco ou receber um pacote de rede, a espera para adquirir um <strong>semáforo</strong> ou, o pior dos casos, a espera por um período de tempo específico.</p></li>
<li><p><strong>Terminado (Terminated/Exit)</strong>: Este é o estado final de um processo. Ele chegou a este estado porque concluiu sua execução normal (e.g., chamando a função exit()) ou foi encerrado de forma anormal pelo <strong>Sistema Operacional</strong> devido a um erro irrecuperável ou a um comando externo. Neste ponto, o <strong>Sistema Operacional</strong> recupera todos os recursos que haviam sido alocados ao processo.</p></li>
</ul>
<p>As transições entre esses estados são tão importantes quanto os próprios estados e são acionadas por eventos específicos gerenciados pelo Sistema Operacional:</p>
<ul>
<li><p><strong>Novo <span class="math inline">\(\rightarrow\)</span> Pronto (Admissão)</strong>: o <strong>Sistema Operacional</strong>, por meio de seu agendador de longo ou médio prazo, decide admitir o processo recém-criado no conjunto de processos ativos. Isso geralmente envolve alocar a memória principal para o processo e colocar seu PCB na fila de prontos. Mantenha o foco, vamos falar destes agendadores diferentes em futuro próximo. Ainda neste capítulo.</p></li>
<li><p><strong>Pronto <span class="math inline">\(\rightarrow\)</span> Executando (Despacho)</strong>: o agendador de curto prazo, agendador de <code>CPU</code> seleciona um processo da fila de prontos e aloca este processo à <code>CPU</code>. Esta ação é chamada de despacho, em inglês <em>dispatch</em>.</p></li>
<li><p><strong>Executando <span class="math inline">\(\rightarrow\)</span> Pronto (Preempção/Time t)</strong>: a transição mais comum em sistemas de tempo compartilhado, veja a seção <a href="intro.html#sec-timesharing" class="quarto-xref"><span>Era da Interatividade: Sistemas de Tempo Compartilhado (final dos 1960s - 1980s)</span></a>. O processo em execução é interrompido pelo <strong>Sistema Operacional</strong> e movido de volta para a fila de prontos. Isso pode ocorrer porque o processo esgotou sua fatia de tempo, chamada de <em>timeslice</em> ou quantum, alocada, um processo de prioridade mais alta tornou-se pronto para executar, chamamos isso de preempção.</p></li>
<li><p><strong>Executando <span class="math inline">\(\rightarrow\)</span> Bloqueado (Espera por Evento)</strong>: o processo em execução inicia uma operação que não pode ser concluída imediatamente. Por exemplo, ele faz uma chamada de sistema para ler um arquivo. Como o processo não pode prosseguir até que os dados estejam disponíveis, o <strong>Sistema Operacional</strong> o move para o estado <strong>Bloqueado</strong> e agenda outro processo para execução.</p></li>
<li><p><strong>Bloqueado <span class="math inline">\(\rightarrow\)</span> Pronto (Ocorrência de Evento)</strong>: O evento pelo qual o processo estava esperando finalmente ocorre. Por exemplo, a operação de <code>E/S</code> é concluída e o hardware gera uma interrupção. O <strong>Sistema Operacional</strong> processa a interrupção e move o processo correspondente da fila de bloqueados de volta para a fila de prontos, tornando-o novamente elegível para competir pela <code>CPU</code>.</p></li>
<li><p><strong>Executando <span class="math inline">\(\rightarrow\)</span> Terminado (Término)</strong>: O processo finaliza sua tarefa e solicita ao <strong>Sistema Operacional</strong> para ser encerrado, é forçadamente encerrado. Seus recursos são desalocados e ele deixa de existir como uma entidade ativa.</p></li>
</ul>
<p>A <a href="#fig-cincoprocessos" class="quarto-xref">Figure&nbsp;<span>3</span></a> resume os estados e as transições do modelo de cinco estados. Este modelo é fundamental para entender como os <strong>Sistemas Operacionais</strong> modernos gerenciam a concorrência e a alocação de recursos.</p>
<div id="fig-cincoprocessos" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cincoprocessos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/modelo_cinco_estados.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cincoprocessos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: O diagrama ilustra os cinco estados fundamentais pelos quais um processo pode transitar durante sua execução: Novo (New), Pronto (Ready), Executando (Running), Bloqueado (Blocked/Waiting) e Terminado (Terminated). As setas indicam as transições possíveis entre estados, controladas pelos agendadores de longo prazo (long-term scheduler) e curto prazo (short-term scheduler/dispatcher). As filas de prontos e bloqueados representam as estruturas de dados utilizadas pelo <strong>Sistema Operacional</strong> para gerenciar processos em cada estado. Este modelo resolve as limitações do modelo de dois estados ao distinguir explicitamente processos prontos para execução daqueles aguardando eventos externos.
</figcaption>
</figure>
</div>
</section>
<section id="expandindo-o-modelo-a-introdução-de-estados-suspensos" class="level4">
<h4 class="anchored" data-anchor-id="expandindo-o-modelo-a-introdução-de-estados-suspensos">Expandindo o Modelo: A Introdução de Estados Suspensos</h4>
<p>O modelo de cinco estados, embora robusto, opera sob uma suposição implícita: todos os processos, sejam eles <strong>Prontos</strong> ou <strong>Bloqueados</strong>, residem na memória principal, a <code>RAM</code>. No entanto, a realidade do hardware introduz uma complicação. A velocidade da <code>CPU</code> é ordens de magnitude maior que a velocidade dos dispositivos de <code>E/S</code>, como os discos rígidos. Isso pode levar a um cenário de gargalo de <code>E/S</code>, no qual a maioria ou todos os processos na memória principal estão no estado <strong>Bloqueado</strong>, aguardando a conclusão de operações de <code>E/S</code>. Nesse ínterim, a <code>CPU</code> fica ociosa, e a memória principal, um recurso caro e limitado, fica ocupada por processos que não podem ser executados. Isso é mau, muito mau.</p>
<p>Para combater essa ineficiência e aumentar o grau de multiprogramação, o número de processos na memória, os <strong>Sistemas Operacionais</strong> introduziram o conceito de <strong>swapping</strong>, o termo em inglês para troca, e memória virtual. O sistema pode mover um processo inteiro, partes dele, da memória principal para um armazenamento secundário mais lento, como o disco, liberando assim a <code>RAM</code> para outros processos. Esse ato de mover um processo para o disco é geralmente chamado de <strong>suspensão</strong>.</p>
<p>A introdução da suspensão torna o modelo de cinco estados inadequado, pois ele não consegue distinguir entre um processo que está pronto para executar e está na memória e um que está pronto para executar, mas foi movido para o disco. Para capturar essa nova dimensão, o <strong>modelo de sete estados</strong> foi desenvolvido, adicionando dois estados suspensos:</p>
<ul>
<li><p><strong>Bloqueado/Suspenso (Blocked/Suspended)</strong>: Um processo que estava no estado <strong>Bloqueado</strong> (na memória principal, esperando por um evento) foi movido para o armazenamento secundário. Para que possa ser executado, ele precisa que duas condições sejam satisfeitas: o evento pelo qual estava esperando deve ocorrer, e ele deve ser trazido de volta para a memória principal.</p></li>
<li><p><strong>Pronto/Suspenso (Ready/Suspended)</strong>: Um processo neste estado está pronto para ser executado, mas reside no armazenamento secundário. Ele pode ter chegado a este estado de duas maneiras: estava no estado <strong>Pronto</strong> e foi suspenso para liberar memória, estava no estado <strong>Bloqueado/Suspenso</strong> e o evento que esperava ocorreu. A única barreira para sua execução é ser carregado de volta para a memória principal.</p></li>
</ul>
<p>Este modelo mais complexo introduz um novo conjunto de transições, geralmente gerenciadas por um agendador de médio prazo:</p>
<ul>
<li><strong>Bloqueado → Bloqueado/Suspenso (Suspender)</strong>: O <strong>Sistema Operacional</strong> seleciona um processo bloqueado e o move para o disco para liberar memória.<br>
</li>
<li><strong>Pronto → Pronto/Suspenso (Suspender)</strong>: Menos comum, mas possível, o sistema pode suspender um processo pronto de baixa prioridade.<br>
</li>
<li><strong>Bloqueado/Suspenso → Pronto/Suspenso (Ocorrência de Evento)</strong>: O evento que o processo esperava ocorre enquanto ele está no disco. Seu estado muda, mas ele permanece no armazenamento secundário.<br>
</li>
<li><strong>Pronto/Suspenso → Pronto (Ativar)</strong>: O <strong>Sistema Operacional</strong> decide que há memória suficiente ou que o processo tem prioridade alta, e o move do disco de volta para a memória principal, colocando-o na fila de prontos.<br>
</li>
<li><strong>Novo → Pronto/Suspenso</strong>: Um novo processo pode ser criado e imediatamente colocado no estado suspenso se não houver memória principal disponível no momento da criação.</li>
</ul>
<p>A evolução do modelo de dois para o de sete estados não é um mero acréscimo de complexidade teórica. Ela demonstra como os modelos de gerenciamento de processos são moldados pelas realidades e limitações da arquitetura de hardware subjacente. Cada camada de complexidade no modelo de estados corresponde a uma solução de engenharia para um problema real de gerenciamento de recursos, primeiro, o problema de agendamento ineficiente, e depois, o problema do gargalo de <code>E/S</code> e da escassez de memória principal. Este modelo pode ser visto na <a href="#fig-seteestados" class="quarto-xref">Figure&nbsp;<span>4</span></a>.</p>
<div id="fig-seteestados" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-seteestados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/modelo_sete_estados.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-seteestados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: O diagrama ilustra a evolução do modelo canônico pela introdução de dois novos estados suspensos: Pronto/Suspenso (Ready/Suspended) e Bloqueado/Suspenso (Blocked/Suspended). A separação visual entre memória principal (RAM) e armazenamento secundário (disco) destaca o conceito fundamental do swapping. O agendador de médio prazo (medium-term scheduler) gerencia as operações de suspensão e ativação, movendo processos entre memória e disco para resolver o gargalo de <code>E/S</code>e aumentar o grau de multiprogramação. Este modelo permite que o <strong>Sistema Operacional</strong> mantenha mais processos ativos no sistema total, mesmo quando a memória principal é limitada, otimizando a utilização da <code>CPU</code> ao evitar que ela permaneça ociosa durante operações de <code>E/S</code>.
</figcaption>
</figure>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./intro3.html" class="pagination-link" aria-label="Introdução: Referências">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Introdução: Referências</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./gerproc1.html" class="pagination-link" aria-label="Criando Processos de Forma Programática: O Modelo Linux">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Criando Processos de Forma Programática: O Modelo Linux</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linefollower/edit/main/gerproc.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linefollower/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>