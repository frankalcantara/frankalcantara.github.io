<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sistemas Operacionais - 10&nbsp; Controle de Processos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./gerproc4.html" rel="next">
<link href="./gerproc2.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/styles.css">
<meta property="og:title" content="Sistemas Operacionais - 10&nbsp; Controle de Processos">
<meta property="og:description" content="">
<meta property="og:site_name" content="Sistemas Operacionais">
<meta name="twitter:title" content="Sistemas Operacionais - 10&nbsp; Controle de Processos">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./gerproc.html">Gestão de Processos</a></li><li class="breadcrumb-item"><a href="./gerproc3.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Controle de Processos</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Sistemas Operacionais</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Introdução</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Desvendando o Invisível: Uma Introdução aos Sistemas Operacionais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Sistemas Operacionais: Equilibrando Recursos e Simplicidade</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Exercícios</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introdução: Referências</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pr-guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Guia Completo de <em>pull request</em> em Repositório de Terceiros</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Gestão de Processos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Gerenciamento de Processos: Introdução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Criando Processos de Forma Programática</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Processos de Sistema: Linux vs.&nbsp;Windows</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Controle de Processos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Agendamento de Tarefas e Escalonamento</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Atividades Práticas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gerproc6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">Gestão de Memória - 12germem.qmd</span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13gerfiles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Gestão de Arquivos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14geres.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Gestão de Entrada/Saída</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15gerredes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Gestão de Conectividade e Comunicação</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16gerseg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Segurança</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2arqui.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Arquiteturas de Sistemas Operacionais: Estruturando a Complexidade</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3heterox.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Tendências Avançadas em Sistemas Operacionais</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18glossa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Glossário - Sistemas Operacionais: Fundamentos e Evolução</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19exerc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Exercícios Resolvidos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#a-anatomia-do-controle-de-processos" id="toc-a-anatomia-do-controle-de-processos" class="nav-link active" data-scroll-target="#a-anatomia-do-controle-de-processos"><span class="header-section-number">10.1</span> A Anatomia do Controle de Processos</a>
  <ul class="collapse">
  <li><a href="#o-bloco-de-controle-de-processo-pcb-o-repositório-de-estado" id="toc-o-bloco-de-controle-de-processo-pcb-o-repositório-de-estado" class="nav-link" data-scroll-target="#o-bloco-de-controle-de-processo-pcb-o-repositório-de-estado"><span class="header-section-number">10.1.1</span> O Bloco de Controle de Processo (PCB): O Repositório de Estado</a></li>
  <li><a href="#kernel-stack-e-context-switch" id="toc-kernel-stack-e-context-switch" class="nav-link" data-scroll-target="#kernel-stack-e-context-switch"><span class="header-section-number">10.1.2</span> <code>kernel</code> Stack e Context Switch</a></li>
  </ul></li>
  <li><a href="#simulador-1-arquitetura-e-hierarquia-do-process-control-block-linux" id="toc-simulador-1-arquitetura-e-hierarquia-do-process-control-block-linux" class="nav-link" data-scroll-target="#simulador-1-arquitetura-e-hierarquia-do-process-control-block-linux"><span class="header-section-number">10.2</span> Simulador 1: Arquitetura e Hierarquia do Process Control Block Linux</a>
  <ul class="collapse">
  <li><a href="#análise-dos-conceitos-demonstrados" id="toc-análise-dos-conceitos-demonstrados" class="nav-link" data-scroll-target="#análise-dos-conceitos-demonstrados"><span class="header-section-number">10.2.1</span> Análise dos Conceitos Demonstrados</a></li>
  </ul></li>
  <li><a href="#arquitetura-do-pcb-no-windows-eprocesskthread" id="toc-arquitetura-do-pcb-no-windows-eprocesskthread" class="nav-link" data-scroll-target="#arquitetura-do-pcb-no-windows-eprocesskthread"><span class="header-section-number">10.3</span> Arquitetura do PCB no Windows: EPROCESS/KTHREAD</a>
  <ul class="collapse">
  <li><a href="#filosofia-de-design" id="toc-filosofia-de-design" class="nav-link" data-scroll-target="#filosofia-de-design"><span class="header-section-number">10.3.1</span> Filosofia de Design</a></li>
  <li><a href="#context-switch-no-windows" id="toc-context-switch-no-windows" class="nav-link" data-scroll-target="#context-switch-no-windows"><span class="header-section-number">10.3.2</span> Context Switch no Windows</a></li>
  </ul></li>
  <li><a href="#comparação-arquitetural" id="toc-comparação-arquitetural" class="nav-link" data-scroll-target="#comparação-arquitetural"><span class="header-section-number">10.4</span> Comparação Arquitetural</a>
  <ul class="collapse">
  <li><a href="#filosofias-de-design" id="toc-filosofias-de-design" class="nav-link" data-scroll-target="#filosofias-de-design"><span class="header-section-number">10.4.1</span> Filosofias de Design</a></li>
  <li><a href="#implicações-de-performance" id="toc-implicações-de-performance" class="nav-link" data-scroll-target="#implicações-de-performance"><span class="header-section-number">10.4.2</span> Implicações de Performance</a></li>
  <li><a href="#vantagens-e-trade-offs" id="toc-vantagens-e-trade-offs" class="nav-link" data-scroll-target="#vantagens-e-trade-offs"><span class="header-section-number">10.4.3</span> Vantagens e trade-offs</a></li>
  </ul></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão"><span class="header-section-number">10.5</span> Conclusão</a>
  <ul class="collapse">
  <li><a href="#gerenciamento-de-estados-através-de-filas" id="toc-gerenciamento-de-estados-através-de-filas" class="nav-link" data-scroll-target="#gerenciamento-de-estados-através-de-filas"><span class="header-section-number">10.5.1</span> Gerenciamento de Estados Através de Filas</a></li>
  <li><a href="#o-mecanismo-de-troca-de-contexto-context-switch" id="toc-o-mecanismo-de-troca-de-contexto-context-switch" class="nav-link" data-scroll-target="#o-mecanismo-de-troca-de-contexto-context-switch"><span class="header-section-number">10.5.2</span> O Mecanismo de Troca de Contexto (Context Switch)</a></li>
  </ul></li>
  <li><a href="#implementações-em-sistemas-operacionais-reais" id="toc-implementações-em-sistemas-operacionais-reais" class="nav-link" data-scroll-target="#implementações-em-sistemas-operacionais-reais"><span class="header-section-number">10.6</span> Implementações em <strong>Sistemas Operacionais</strong> Reais</a>
  <ul class="collapse">
  <li><a href="#o-ecossistema-unixlinux" id="toc-o-ecossistema-unixlinux" class="nav-link" data-scroll-target="#o-ecossistema-unixlinux"><span class="header-section-number">10.6.1</span> <strong>3. O Ecossistema UNIX/Linux</strong></a></li>
  <li><a href="#a-arquitetura-do-windows" id="toc-a-arquitetura-do-windows" class="nav-link" data-scroll-target="#a-arquitetura-do-windows"><span class="header-section-number">10.6.2</span> <strong>3. A Arquitetura do Windows</strong></a></li>
  </ul></li>
  <li><a href="#secção-4-tópicos-avançados-e-implicações-de-desempenho" id="toc-secção-4-tópicos-avançados-e-implicações-de-desempenho" class="nav-link" data-scroll-target="#secção-4-tópicos-avançados-e-implicações-de-desempenho"><span class="header-section-number">10.7</span> <strong>Secção 4: Tópicos Avançados e Implicações de Desempenho</strong></a>
  <ul class="collapse">
  <li><a href="#suspensão-swapping-e-memória-virtual" id="toc-suspensão-swapping-e-memória-virtual" class="nav-link" data-scroll-target="#suspensão-swapping-e-memória-virtual"><span class="header-section-number">10.7.1</span> <strong>4. Suspensão, Swapping e Memória Virtual</strong></a></li>
  <li><a href="#o-fenômeno-do-thrashing" id="toc-o-fenômeno-do-thrashing" class="nav-link" data-scroll-target="#o-fenômeno-do-thrashing"><span class="header-section-number">10.7.2</span> <strong>4. O Fenômeno do Thrashing</strong></a></li>
  </ul></li>
  <li><a href="#conclusão-1" id="toc-conclusão-1" class="nav-link" data-scroll-target="#conclusão-1"><span class="header-section-number">10.8</span> <strong>Conclusão</strong></a>
  <ul class="collapse">
  <li><a href="#a-abstração-de-processo-uma-instância-de-um-programa-em-execução" id="toc-a-abstração-de-processo-uma-instância-de-um-programa-em-execução" class="nav-link" data-scroll-target="#a-abstração-de-processo-uma-instância-de-um-programa-em-execução"><span class="header-section-number">10.8.1</span> A Abstração de Processo: Uma Instância de um Programa em Execução</a></li>
  <li><a href="#memória-virtual-o-universo-privado-de-um-processo" id="toc-memória-virtual-o-universo-privado-de-um-processo" class="nav-link" data-scroll-target="#memória-virtual-o-universo-privado-de-um-processo"><span class="header-section-number">10.8.2</span> Memória Virtual: O Universo Privado de um Processo</a></li>
  </ul></li>
  <li><a href="#simulador-2-simulando-um-tlb" id="toc-simulador-2-simulando-um-tlb" class="nav-link" data-scroll-target="#simulador-2-simulando-um-tlb"><span class="header-section-number">10.9</span> Simulador 2: Simulando um TLB</a>
  <ul class="collapse">
  <li><a href="#sec-vasproc1" id="toc-sec-vasproc1" class="nav-link" data-scroll-target="#sec-vasproc1"><span class="header-section-number">10.9.1</span> Anatomia do Espaço de Endereçamento de um Processo</a></li>
  </ul></li>
  <li><a href="#parte-ii-o-modelo-linux-um-estudo-em-composição" id="toc-parte-ii-o-modelo-linux-um-estudo-em-composição" class="nav-link" data-scroll-target="#parte-ii-o-modelo-linux-um-estudo-em-composição"><span class="header-section-number">10.10</span> <strong>Parte II: O Modelo Linux: Um Estudo em Composição</strong></a>
  <ul class="collapse">
  <li><a href="#o-layout-de-memória-virtual-do-linux-x86-64" id="toc-o-layout-de-memória-virtual-do-linux-x86-64" class="nav-link" data-scroll-target="#o-layout-de-memória-virtual-do-linux-x86-64"><span class="header-section-number">10.10.1</span> <strong>2. O Layout de Memória Virtual do </strong>Linux** (x86-64)**</a></li>
  <li><a href="#de-arquivo-para-memória-o-formato-executável-e-ligável-elf" id="toc-de-arquivo-para-memória-o-formato-executável-e-ligável-elf" class="nav-link" data-scroll-target="#de-arquivo-para-memória-o-formato-executável-e-ligável-elf"><span class="header-section-number">10.10.2</span> <strong>2. De Arquivo para Memória: O Formato Executável e Ligável (ELF)</strong></a></li>
  <li><a href="#criação-de-processos-o-paradigma-fork-e-exec-1" id="toc-criação-de-processos-o-paradigma-fork-e-exec-1" class="nav-link" data-scroll-target="#criação-de-processos-o-paradigma-fork-e-exec-1"><span class="header-section-number">10.10.3</span> <strong>2. Criação de Processos: O Paradigma fork() e exec()</strong></a></li>
  <li><a href="#implementação-prática-em-c23-linux" id="toc-implementação-prática-em-c23-linux" class="nav-link" data-scroll-target="#implementação-prática-em-c23-linux"><span class="header-section-number">10.10.4</span> <strong>2. Implementação Prática em C++23 (Linux)</strong></a></li>
  </ul></li>
  <li><a href="#parte-iii-o-modelo-windows-um-estudo-em-configuração" id="toc-parte-iii-o-modelo-windows-um-estudo-em-configuração" class="nav-link" data-scroll-target="#parte-iii-o-modelo-windows-um-estudo-em-configuração"><span class="header-section-number">10.11</span> <strong>Parte III: O Modelo Windows: Um Estudo em Configuração</strong></a>
  <ul class="collapse">
  <li><a href="#o-layout-de-memória-virtual-do-windows" id="toc-o-layout-de-memória-virtual-do-windows" class="nav-link" data-scroll-target="#o-layout-de-memória-virtual-do-windows"><span class="header-section-number">10.11.1</span> <strong>3. O Layout de Memória Virtual do Windows</strong></a></li>
  <li><a href="#de-arquivo-para-memória-o-formato-portable-executable-pe" id="toc-de-arquivo-para-memória-o-formato-portable-executable-pe" class="nav-link" data-scroll-target="#de-arquivo-para-memória-o-formato-portable-executable-pe"><span class="header-section-number">10.11.2</span> <strong>3. De Arquivo para Memória: O Formato Portable Executable (PE)</strong></a></li>
  <li><a href="#criação-de-processos-a-api-createprocess" id="toc-criação-de-processos-a-api-createprocess" class="nav-link" data-scroll-target="#criação-de-processos-a-api-createprocess"><span class="header-section-number">10.11.3</span> <strong>3. Criação de Processos: A API CreateProcess</strong></a></li>
  <li><a href="#implementação-prática-em-c23-windows" id="toc-implementação-prática-em-c23-windows" class="nav-link" data-scroll-target="#implementação-prática-em-c23-windows"><span class="header-section-number">10.11.4</span> <strong>3. Implementação Prática em C++23 (Windows)</strong></a></li>
  </ul></li>
  <li><a href="#parte-iv-análise-comparativa-e-síntese" id="toc-parte-iv-análise-comparativa-e-síntese" class="nav-link" data-scroll-target="#parte-iv-análise-comparativa-e-síntese"><span class="header-section-number">10.12</span> <strong>Parte IV: Análise Comparativa e Síntese</strong></a>
  <ul class="collapse">
  <li><a href="#filosofias-de-design-forkexec-vs.-createprocess" id="toc-filosofias-de-design-forkexec-vs.-createprocess" class="nav-link" data-scroll-target="#filosofias-de-design-forkexec-vs.-createprocess"><span class="header-section-number">10.12.1</span> <strong>4. Filosofias de Design: fork/exec vs.&nbsp;CreateProcess</strong></a></li>
  <li><a href="#formatos-executáveis-uma-comparação-direta-entre-elf-e-pe" id="toc-formatos-executáveis-uma-comparação-direta-entre-elf-e-pe" class="nav-link" data-scroll-target="#formatos-executáveis-uma-comparação-direta-entre-elf-e-pe"><span class="header-section-number">10.12.2</span> <strong>4. Formatos Executáveis: Uma Comparação Direta entre ELF e PE</strong></a></li>
  <li><a href="#resumo-das-distinções" id="toc-resumo-das-distinções" class="nav-link" data-scroll-target="#resumo-das-distinções"><span class="header-section-number">10.12.3</span> <strong>4. Resumo das Distinções</strong></a></li>
  </ul></li>
  <li><a href="#conclusão-e-perspectivas-futuras" id="toc-conclusão-e-perspectivas-futuras" class="nav-link" data-scroll-target="#conclusão-e-perspectivas-futuras"><span class="header-section-number">10.13</span> <strong>Conclusão e Perspectivas Futuras</strong></a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/edit/main/gerproc3.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./gerproc.html">Gestão de Processos</a></li><li class="breadcrumb-item"><a href="./gerproc3.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Controle de Processos</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Controle de Processos</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="a-anatomia-do-controle-de-processos" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="a-anatomia-do-controle-de-processos"><span class="header-section-number">10.1</span> A Anatomia do Controle de Processos</h2>
<p>Os modelos teóricos de estados, que a persistente leitora viu até o momento, fornecem o o quê e o porquê do ciclo de vida de um processo. Esta seção foca no como: as estruturas de dados e os mecanismos concretos que os <strong>Sistemas Operacionais</strong> empregam para implementar e gerenciar esses estados. a transição da teoria para a prática é mediada por uma estrutura de dados fundamental, o Bloco de Controle de Processo, e por mecanismos essenciais como a organização em filas e a troca de contexto.</p>
<section id="o-bloco-de-controle-de-processo-pcb-o-repositório-de-estado" class="level3" data-number="10.1.1">
<h3 data-number="10.1.1" class="anchored" data-anchor-id="o-bloco-de-controle-de-processo-pcb-o-repositório-de-estado"><span class="header-section-number">10.1.1</span> O Bloco de Controle de Processo (PCB): O Repositório de Estado</h3>
<p>Se um processo é uma entidade ativa, o Bloco de Controle de Processo, em inglês <strong>P</strong>rocess <strong>C</strong>ontrol <strong>B</strong>lock, <strong>PCB</strong> é sua personificação dentro do <code>Kernel</code> do <strong>Sistema Operacional</strong>. O <strong>PCB</strong>, também conhecido como descritor de processo, é uma estrutura de dados que armazena todas as informações essenciais que o <strong>Sistema Operacional</strong> precisa para gerenciar um processo específico. Para cada processo existente no sistema, há um <strong>PCB</strong> correspondente. Sem o <strong>PCB</strong>, um processo simplesmente não existe do ponto de vista do gerenciamento do sistema. O <strong>PCB</strong> é a âncora que transforma um fluxo de execução volátil em uma entidade concreta e controlável.</p>
<p>O conteúdo de um <strong>PCB</strong> é abrangente, pois deve encapsular todo o contexto do processo. Embora a implementação exata varie entre os <strong>Sistemas Operacionais</strong>, os componentes de informação essenciais podem ser categorizados como mostrado na <a href="#tbl-pcb1" class="quarto-xref">Table&nbsp;<span>10.1</span></a>.</p>
<div id="tbl-pcb1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-pcb1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;10.1: Anatomia do Bloco de Controle de Processo (<strong>PCB</strong>)
</figcaption>
<div aria-describedby="tbl-pcb1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Categoria da Informação</th>
<th style="text-align: left;">Elemento de Dados</th>
<th style="text-align: left;">Descrição</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Identificação</strong></td>
<td style="text-align: left;">ID do Processo (<strong>PID</strong>), ID do Processo Pai (<strong>PPID</strong>), ID do Usuário (), ID do Grupo (<strong>GID</strong>)</td>
<td style="text-align: left;">Identificadores numéricos únicos que definem o processo, sua linhagem e seus privilégios de proprietário.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Estado do Processador</strong></td>
<td style="text-align: left;">Contador de Programa (PC), Ponteiro de Pilha (SP), Registradores da <code>CPU</code></td>
<td style="text-align: left;">Uma captura instantânea, <em>snapshot</em> do estado do hardware no momento em que o processo foi interrompido. Essencial para retomar a execução exatamente de onde parou.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Controle de Estado e Agendamento</strong></td>
<td style="text-align: left;">Estado do Processo, Prioridade, Ponteiros para Filas de Agendamento, Quantum de Tempo</td>
<td style="text-align: left;">Informações utilizadas pelo agendador de <code>CPU</code> para tomar decisões, como qual processo executar a seguir e por quanto tempo.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Gerenciamento de Memória</strong></td>
<td style="text-align: left;">Ponteiros para Tabela de Páginas ou Tabela de Segmentos, Registradores de Base/Limite</td>
<td style="text-align: left;">Define o espaço de endereço virtual do processo e como ele é mapeado para a memória física.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Gerenciamento de Recursos</strong></td>
<td style="text-align: left;">Lista de Arquivos Abertos, Dispositivos de <code>E/S</code> Alocados</td>
<td style="text-align: left;">Rastreia os recursos do sistema (além da <code>CPU</code> e memória) que o processo está utilizando no momento.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Contabilidade</strong></td>
<td style="text-align: left;">Tempo de <code>CPU</code> utilizado, Limites de tempo, ID da Conta</td>
<td style="text-align: left;">Coleta dados sobre o consumo de recursos para fins de faturamento, limitação ou análise de desempenho.</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>A existência e a riqueza do <strong>PCB</strong> são o que tornam possível interromper um processo em execução e, posteriormente, retomar sua execução como se nada tivesse acontecido. O <strong>PCB</strong> é a informação de referência e ancoragem que permite mover processos entre filas de agendamento e retomar sua execução com precisão. Sem essa estrutura, a abstração do processo concorrente simplesmente não seria viável. A curiosa leitora deve estar curiosa com relação as filas. A <a href="#fig-pcb1" class="quarto-xref">Figure&nbsp;<span>10.1</span></a> ilustra a estrutura do <strong>PCB</strong> indicando sua posição no campo <em>Direct Map</em> do espaço do <code>kernel</code> em cada Processo no <strong>Linux</strong>.</p>
<div id="fig-pcb1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pcb1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/pcb_memory_architecture.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pcb1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.1: Arquitetura do PCB Linux: representação detalhada da task_struct com endereços de memória reais, estruturas auxiliares para gerenciamento de memória virtual (mm_struct), descritores de arquivo (files_struct),tratamento de sinais (signal_struct), contexto de <code>CPU</code> (thread_struct) e organização da <code>kernel</code> stack, ilustrando a implementação concreta dos mecanismos de troca de contexto.
</figcaption>
</figure>
</div>
<section id="análise-detalhada-da-arquitetura-do-pcb-linux-vs-windows" class="level4" data-number="10.1.1.1">
<h4 data-number="10.1.1.1" class="anchored" data-anchor-id="análise-detalhada-da-arquitetura-do-pcb-linux-vs-windows"><span class="header-section-number">10.1.1.1</span> Análise Detalhada da Arquitetura do PCB: <strong>Linux</strong> vs Windows</h4>
<p>Este é um tema árido, quase tão cruel quanto cruzar o deserto. Longe das brisas do mar e da tranquilidade da teoria. A estrutura que veremos é quase código puro. Além disso, teremos muitas informações que incluirão os conceitos de <code>thread</code>. Se a amável leitora não está familiarizada com <code>threads</code>deve ler a <a href="gerproc.html#sec-thread1" class="quarto-xref"><span>Section 7.1.2</span></a> antes. Além disso, fique ciente que pequenas variações em <em>offsets</em> ou tamanhos de campos e dados podem ocorrer devido a configurações específicas do <code>kernel</code> esta análise assume um <code>kernel</code> <span class="math inline">\(x86_64\)</span> moderno. Dito isso, a <a href="#fig-pcblinuxwindows" class="quarto-xref">Figure&nbsp;<span>10.2</span></a> permite uma prévia, na forma de uma visão panorâmica do <strong>PCB</strong>.</p>
<div id="fig-pcblinuxwindows" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pcblinuxwindows-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/pcb_memory_architecture.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pcblinuxwindows-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.2: Um Diagrama do <strong>PCB</strong> destacando as estrutura de dados que o compõem e sua localização no espaço de endereçamento de um processo.
</figcaption>
</figure>
</div>
<p>O <strong>Process Control Block (PCB)</strong> representa a materialização concreta dos conceitos teóricos de gerenciamento de processos em <strong>Sistemas Operacionais</strong> modernos. Vamos examinar as implementações específicas do <strong>PCB</strong> no <code>kernel</code> <strong>Linux</strong> através da <code>task_struct</code> e no <strong>Windows</strong> usando as estruturas <code>EPROCESS</code>/<code>KTHREAD</code>, demonstrando como diferentes filosofias de design resultam em organizações distintas de dados na memória.</p>
<p>Tudo começa na <code>task_struct</code>, a estrutura central que representa um processo ou thread no <code>kernel</code> <strong>Linux</strong>. Esta estrutura é o coração do gerenciamento de processos, contendo todos os dados necessários para o agendamento, controle de estado e interação com outros componentes do sistema. A <code>task_struct</code> está tipicamente localizada em endereços como <code>0xffff888012345000</code> na região de <strong>direct mapping</strong> do <code>kernel</code> space (ver <code>arch/x86/include/asm/page_64.h</code>). Este endereço é o endereço básico da estrutura no qual está o <em>offset</em> <code>+0x00</code>. A estrutura <code>task_struct</code> é alocada via <code>kmalloc()</code> ou <strong>slab allocator</strong> e contém aproximadamente <span class="math inline">\(1728\)</span> bytes em sistemas <span class="math inline">\(x86_64\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>O Que É o Slab Allocator</strong> O <strong>slab allocator</strong> é um sistema de gerenciamento de memória especializado do <code>kernel</code> <strong>Linux</strong> que otimiza a alocação de objetos de tamanho fixo e frequentemente utilizados(ver <code>mm/slab.h</code>). Este allocator mantém caches pré-alocados de estruturas comuns como <code>task_struct</code>, <code>inode</code>, <code>dentry</code> e outras, evitando a fragmentação e reduzindo o overhead de alocação/desalocação. O <strong>slab allocator</strong> organiza a memória em três níveis: <strong>caches</strong>, conjuntos de <em>slabs</em> para um tipo específico de objeto, <strong>slabs</strong>, páginas contíguas contendo múltiplos objetos do mesmo tipo e <strong>objetos</strong>, as estruturas individuais como <code>task_struct</code>. Esta abordagem permite que o <code>kernel</code> mantenha objetos inicializados em <code>cache</code>, reutilize rapidamente estruturas liberadas e minimize a fragmentação interna, resultando em melhor performance para operações críticas como criação e destruição de processos.</p>
</div>
</div>
<p>A <code>task_struct</code> é uma estrutura de dados complexa com algum espaço para variações que contém os seguintes campos básicos:</p>
<ol type="1">
<li><p><strong>Estado do Processo (<code>+0x00</code>)</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">volatile</span> <span class="dt">long</span> state<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O <code>kernel</code> utiliza este campo para controlar o ciclo de vida do processo e determinar quais operações são permitidas em cada momento, além de otimizar o escalonamento ao manter apenas processos executáveis nas filas de pronto. Este campo está localizado no offset <code>+0x00</code>, é um campo de <span class="math inline">\(8 bytes\)</span> que armazena o estado atual do processo usando algumas constantes definidas em <code>include/linux/sched.h</code>, a saber:</p>
<ul>
<li><p><code>TASK_RUNNING (0)</code>: processo executando ou na fila de prontos. Este estado indica que o processo está ativo e pode ser escalonado pelo agendador de tarefas, <em>scheduler</em> em inglês, a qualquer momento. <strong>Processos neste estado competem por tempo de <code>CPU</code></strong> e podem estar sendo executados ou aguardando sua vez na fila de processos prontos.</p></li>
<li><p><code>TASK_INTERRUPTIBLE (1)</code>: dormindo, pode ser acordado por sinais. O processo está bloqueado aguardando algum evento, como <code>E/S</code>, semáforo, algum temporizador, mas pode ser interrompido por sinais do sistema. <strong>Processos neste estado não consomem <code>CPU</code></strong> e são removidos das filas de escalonamento até que a condição de espera seja satisfeita ou um sinal seja recebido.</p></li>
<li><p><code>TASK_UNINTERRUPTIBLE (2)</code>: dormindo, não pode ser interrompido. Similar ao estado anterior, mas o processo não responde a sinais até que a operação em andamento seja concluída. Este estado é usado durante operações críticas de <code>E/S</code> no qual a interrupção poderia causar corrupção de dados ou inconsistências no sistema.</p></li>
<li><p><code>TASK_ZOMBIE (32)</code>: processo terminou, aguardando coleta pelo pai. O processo finalizou sua execução mas ainda mantém uma entrada na tabela de processos para que o processo pai possa coletar seu código de saída via método <code>wait()</code>. <strong>Processos zumbi não consomem recursos além da entrada na tabela de processos</strong> e devem ser coletados para evitar vazamentos de PIDs.</p></li>
<li><p><code>TASK_STOPPED (4)</code>: processo parado por sinal de debugging. O processo foi suspenso por um sinal como <code>SIGSTOP</code> ou <code>SIGTSTP</code> e permanece neste estado até receber um sinal <code>SIGCONT</code>. Este estado é utilizado por debuggers e shells para controle de jobs, permitindo pausar e retomar a execução de processos conforme necessário.</p></li>
</ul>
<p>O modificador <code>volatile</code> indica que este campo pode ser alterado assincronamente por outros cores da CPU, evitando otimizações inadequadas do compilador.</p></li>
<li><p><strong>Identificadores de Processo (<code>+0x08</code>)</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">pid_t</span> pid<span class="op">;</span>      <span class="co">/* Process ID */</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">pid_t</span> tgid<span class="op">;</span>     <span class="co">/* Thread Group ID */</span>  </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">pid_t</span> ppid<span class="op">;</span>     <span class="co">/* Parent Process ID */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estes identificadores de <span class="math inline">\(4 bytes\)</span> cada implementam a hierarquia de processos(ver <code>include/linux/pid.h</code>):</p>
<ul>
<li><strong><code>pid</code></strong>: Identificador único da tarefa, usado pelo agendador de processos;</li>
<li><strong><code>tgid</code></strong>: <code>Thread</code> Group ID, expressão em inglês para identificador de grupo de <code>thread</code>. Igual ao <strong>PID</strong> da thread principal do processo;</li>
<li><strong><code>ppid</code></strong>: <strong>PID</strong> do processo pai na árvore de processos.</li>
</ul></li>
<li><p><strong>Ponteiro para Gerenciamento de Memória (<code>+0x10</code>)</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> mm_struct <span class="op">*</span>mm<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro de <span class="math inline">\(8 bytes\)</span> para a estrutura de gerenciamento de memória virtual(ver <code>include/linux/mm_types.h</code>). Para threads que compartilham espaço de endereçamento, múltiplas <code>task_struct</code> apontam para a mesma <code>mm_struct</code>.</p></li>
<li><p><strong>Ponteiro para Descritores de Arquivo (<code>+0x18</code>)</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> files_struct <span class="op">*</span>files<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro de <span class="math inline">\(8 bytes\)</span> para a tabela de <em>file desciptors</em>(ver <code>include/linux/fdtable.h</code>), expressão em inglês para descritores de arquivos. O <code>flag</code> <code>CLONE_FILES</code> é uma opção específica da chamada de sistema <code>clone()</code> que determina se o processo filho compartilhará a mesma tabela de <em>file desciptors</em> com o processo pai. Quando <code>CLONE_FILES</code> é especificado, tanto o pai quanto o filho apontam para a mesma estrutura <code>files_struct</code>, significando que operações como <code>open()</code>, <code>close()</code>, <code>dup()</code> e mudanças na posição de leitura/escrita de arquivos serão visíveis em ambos os processos. <strong>Este comportamento é fundamental para a implementação de <code>threads</code> no padrão POSIX, no qual threads do mesmo processo devem compartilhar todos os <em>file desciptors</em> abertos.</strong> Sem <code>CLONE_FILES</code>, o filho receberia uma cópia independente da tabela de <em>file desciptors</em> no momento da criação, permitindo que cada processo gerencie seus próprios arquivos de forma isolada. <strong>O compartilhamento de <em>file desciptors</em> através de <code>CLONE_FILES</code> requer sincronização cuidadosa para evitar condições de corrida ao acessar ou modificar a tabela simultaneamente.</strong></p>
<p>::: callout-note <strong>Condições de corrida</strong> são situações nas quais o resultado de uma operação depende da ordem temporal específica na qual múltiplas <code>threads</code> ou processos acessam recursos compartilhados. Estas condições ocorrem quando dois ou mais fluxos de execução tentam modificar simultaneamente a mesma região de memória, estrutura de dados ou recurso do sistema, sem sincronização adequada.</p>
<p>Em condições de corrida o resultado final torna-se não-determinístico, podendo variar entre execuções mesmo com as mesmas entradas, causando comportamentos inesperados, corrupção de dados ou falhas do sistema. :::</p></li>
<li><p><strong>Ponteiro para tratamento de Sinais (<code>+0x20</code>)</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> signal_struct <span class="op">*</span>signal<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro de <span class="math inline">\(8 bytes\)</span> para informações de sinais compartilhadas entre todas as threads do mesmo processo(ver <code>include/linux/signal.h</code>).</p></li>
<li><p><strong>Contexto de <code>CPU</code> (<code>+0x28</code>)</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> thread_struct thread<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estrutura embedded contendo contexto específico da arquitetura, aproximadamente <span class="math inline">\(576 bytes\)</span> em <span class="math inline">\(x86_64\)</span> (ver <code>arch/x86/include/asm/processor.h</code>).</p>
<p>Em arquiteturas <span class="math inline">\(x86_64\)</span>, a <code>thread_struct</code> inclui os registradores de propósito geral (<code>RAX</code>, <code>RBX</code>, <code>RCX</code>, etc.), ponteiros de pilha (<code>RSP</code>, <code>RBP</code>), registradores de segmento, flags de estado (<code>RFLAGS</code>), e o contexto completo das unidades <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html"><strong>SSE/AVX</strong></a> para operações <strong>SIMD</strong>. <strong>Durante uma mudança de contexto, o <code>kernel</code> salva o estado atual da <code>CPU</code> nesta estrutura antes de carregar o contexto da próxima <code>thread</code> a ser executada</strong>. Esta operação é crítica para o multitasking preemptivo, garantindo que cada <code>thread</code> possa ser suspensa a qualquer momento e posteriormente retomar sua execução exatamente no ponto em que foi interrompida, mantendo a ilusão de execução simultânea em sistemas com múltiplas <code>threads</code>. O tamanho substancial desta estrutura (<span class="math inline">\(576 bytes\)</span>) reflete a complexidade das <code>CPUs</code> modernas e a quantidade de estado que deve ser preservado para manter a corretude da execução.</p></li>
<li><p><strong>Informações de Escalonamento (<code>+0x30</code>)</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> prio<span class="op">,</span> static_prio<span class="op">,</span> normal_prio<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sched_entity se<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sched_rt_entity rt<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sched_dl_entity dl<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Campos para o <strong>C</strong>ompletely <strong>F</strong>air <strong>S</strong>cheduler, <strong>CFS</strong>: o agendador de tarefas padrão do <code>kernel</code> <strong>Linux</strong> desde a versão 2.6.23 (outubro de 2007) até a versão 6.6 que implementa uma abordagem baseada em tempo virtual para garantir distribuição justa de <code>CPU</code> entre processos (ver <code>kernel/sched/fair.c</code>). O <strong>CFS</strong> utiliza uma <a href="https://pages.cs.wisc.edu/~jinc/"><strong>red-black tree</strong></a> para organizar processos executáveis, priorizando sempre o processo com menor tempo virtual acumulado (leftmost node). Este agendador abandona o conceito tradicional de <em>time slices fixos</em>, substituindo-o por um modelo que considera o tempo de execução relativo e prioridades dos processos para determinar quando realizar a preempção, resultando em latências mais baixas e melhor responsividade interativa.</p>
<p>A partir do <code>kernel</code> <strong>Linux</strong> 6.6, o CFS foi substituído pelo <strong>E</strong>arliest <strong>E</strong>ligible <strong>EEVDF</strong>irtual <strong>EEVDF</strong>eadline <strong>EEVDF</strong>irst, <strong>EEVDF</strong>(ver <code>kernel/sched/eevdf.c</code>). O <strong>EEVDF</strong> mantém o objetivo de distribuir tempo de <code>CPU</code> igualmente entre tarefas executáveis de mesma prioridade, mas utiliza uma abordagem mais refinada com conceitos de <em>lag</em> e <em>virtual deadlines</em>. Enquanto o <strong>CFS</strong> usava apenas um parâmetro de peso, o <strong>EEVDF</strong> emprega dois parâmetros: <em>deadline</em> relativo e peso, resultando em uma política de agendamento melhor definida com menos heurísticas.</p>
<p><strong>Estrutura da <code>sched_entity</code> no CFS (até versão 6.5)</strong>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sched_entity <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    u64 vruntime<span class="op">;</span>                  <span class="co">// Tempo virtual de execução</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> load_weight load<span class="op">;</span>       <span class="co">// Peso para cálculos de prioridade  </span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> rb_node run_node<span class="op">;</span>       <span class="co">// Nó da red-black tree</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> on_rq<span class="op">;</span>           <span class="co">// Flag indicando se está na runqueue</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    u64 sum_exec_runtime<span class="op">;</span>         <span class="co">// Tempo total de execução</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    u64 prev_sum_exec_runtime<span class="op">;</span>    <span class="co">// Tempo anterior para delta</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outros campos do CFS...</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Estrutura da <code>sched_entity</code> no EEVDF (a partir da versão 6.6)</strong>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sched_entity <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    u64 vruntime<span class="op">;</span>                  <span class="co">// Tempo virtual de execução (mantido)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    u64 deadline<span class="op">;</span>                  <span class="co">// Virtual _deadline_ calculado (NOVO)</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    u64 slice<span class="op">;</span>                     <span class="co">// Fatia de tempo alocada (NOVO)  </span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    s64 vlag<span class="op">;</span>                      <span class="co">// Lag virtual para fairness (NOVO)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> load_weight load<span class="op">;</span>       <span class="co">// Peso para cálculos de prioridade</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> rb_node run_node<span class="op">;</span>       <span class="co">// Nó da red-black tree</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    u64 min_deadline<span class="op">;</span>              <span class="co">// _deadline_ mínimo p/ árvore augmented (NOVO)</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> on_rq<span class="op">;</span>           <span class="co">// Flag indicando se está na runqueue</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    u64 sum_exec_runtime<span class="op">;</span>         <span class="co">// Tempo total de execução</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outros campos do EEVDF...</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Os campos principais desta seção da <code>task_struct</code> incluem:</p>
<ul>
<li><strong><code>prio</code></strong>: Prioridade dinâmica atual do processo, variando de <span class="math inline">\(0\)</span> a <span class="math inline">\(139\)</span>.</li>
<li><strong><code>static_prio</code></strong>: Prioridade estática do processo, que é um valor fixo entre <span class="math inline">\(100\)</span> e <span class="math inline">\(139\)</span> usado para determinar a prioridade base do processo.</li>
<li><strong><code>normal_prio</code></strong>: Prioridade sem boost de herança, usada para determinar a prioridade efetiva do processo sem considerar heranças de prioridade.</li>
<li><strong><code>se</code></strong>: Entidade de escalonamento que contém campos específicos do <strong>CFS</strong> ou <strong>EEVDF</strong></li>
</ul>
<p><strong>Campos introduzidos pelo EEVDF</strong>:</p>
<ul>
<li><p><strong><code>deadline</code></strong>: virtual <em>deadline</em> calculado como <code>vruntime + calc_delta_fair(slice, se)</code>. Representa o momento virtual em que a tarefa deveria terminar sua fatia atual de tempo. O <strong>EEVDF</strong> sempre seleciona a tarefa elegível com o <em>deadline</em> mais próximo para execução, priorizando naturalmente tarefas mais sensíveis a problemas de latência elevada com fatias menores.</p></li>
<li><p><strong><code>slice</code></strong>: fatia de tempo alocada à tarefa, determinada pelo valor <code>latency-nice</code> através de <code>sched_slice()</code>. Tarefas classificadas como críticas em relação a latência, <code>latency-critical</code>, recebem fatias menores, range de <span class="math inline">\(100µs\)</span> a <span class="math inline">\(100ms\)</span>, resultando em deadlines mais próximos e maior frequência de agendamento. Este campo substitui os cálculos dinâmicos de fatiamento de tempo do <strong>CFS</strong>.</p></li>
<li><p><strong><code>vlag</code></strong>: <code>Lag</code> virtual que indica se uma tarefa recebeu sua parcela justa de <code>CPU</code>, calculado como diferença entre o tempo virtual médio do sistema e o <code>vruntime</code> da tarefa. Valores positivos indicam que a tarefa está devendo tempo de <code>CPU</code>, valores negativos indicam que excedeu sua cota. Apenas tarefas com <code>vlag ≥ 0</code> são elegíveis para agendamento, garantindo justiça sem as heurísticas complexas do <strong>CFS</strong>.</p></li>
<li><p><strong><code>min_deadline</code></strong>: Campo usado pela árvore red-black augmented para otimizar a busca pela tarefa com <em>deadline</em> mais próximo. Permite que o algoritmo de seleção <code>pick_eevdf()</code> encontre eficientemente a próxima tarefa sem percorrer toda a árvore, melhorando a performance do agendador.</p></li>
</ul></li>
</ol>
<section id="estruturas-auxiliares-especializadas" class="level5" data-number="10.1.1.1.1">
<h5 data-number="10.1.1.1.1" class="anchored" data-anchor-id="estruturas-auxiliares-especializadas"><span class="header-section-number">10.1.1.1.1</span> Estruturas Auxiliares Especializadas</h5>
<p>Como a perspicaz leitora deve ter percebido na <a href="#fig-pcb1" class="quarto-xref">Figure&nbsp;<span>10.1</span></a>, a <code>task_struct</code> é uma estrutura complexa que contém referências a outras estruturas especializadas que implementam funcionalidades específicas. Vamos explorar essas estruturas auxiliares que compõem o <strong>PCB</strong> no <code>kernel</code> <strong>Linux</strong>.</p>
<ol type="1">
<li><p><strong>Gerenciamento de Memória</strong>: <code>mm_struct</code></p>
<p>A <code>mm_struct</code> está Localizada em endereços como <code>0xffff888012346000</code>, encapsulando todo o contexto de memória virtual(ver <code>include/linux/mm_types.h</code>). Esta estrutura de dados está dividida em tês áreas importantes:</p>
<ol type="a">
<li><strong>Árvore de VMAs (<code>+0x00</code>)</strong></li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> vm_area_struct <span class="op">*</span>mmap<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> rb_root mm_rb<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong><code>mmap</code></strong>: Lista ligada de <strong>V</strong>irtual <strong>M</strong>emory <strong>A</strong>reas, <strong>VMAs</strong>;</li>
<li><strong><code>mm_rb</code></strong>: Árvore red-black para busca rápida de VMAs por endereço virtual. Cada <strong>VMA</strong> representa uma região contígua de memória virtual com atributos específicos, como permissões de leitura/escrita/executável, e pode estar associada a um arquivo ou ser anônima.</li>
</ul>
<ol start="2" type="a">
<li><strong>Page Global Directory (<code>+0x08</code>)</strong></li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">pgd_t</span> <span class="op">*</span>pgd<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro para a raiz da árvore de tradução de páginas (ver <code>arch/x86/include/asm/pgtable.h</code>). Em <code>x86_64</code>, aponta para o <strong>Page Map Level 4 (PML4)</strong> que implementa paginação de <span class="math inline">\(4\)</span> níveis.</p>
<ol start="3" type="a">
<li><strong>Contadores de Referência (<code>+0x10</code>)</strong></li>
</ol>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">atomic_t</span> mm_users<span class="op">;</span>   <span class="co">/* Quantos usuários ativos */</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">atomic_t</span> mm_count<span class="op">;</span>   <span class="co">/* Referências à mm_struct */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong><code>mm_users</code></strong>: Conta <code>threads</code> ativas usando este espaço de endereçamento;</li>
<li><strong><code>mm_count</code></strong>: Conta referências totais, incluindo <code>lazy TLB</code>. O <code>lazy TLB</code> é uma otimização na qual <code>kernel threads</code> ou processos sem espaço de endereçamento próprio reutilizam temporariamente o <code>mm_struct</code> do último processo de usuário que executou na CPU, evitando invalidações desnecessárias do <strong>T</strong>ranslation <strong>L</strong>ookaside <strong>B</strong>uffer, <strong>TLB</strong> e melhorando a performance do sistema ao reduzir o overhead de context switching para threads do <code>kernel</code>.</li>
</ul>
<p>::: callout-note <strong>Processos sem espaço de endereçamento próprio</strong></p>
<p>Estes processos são os <code>kernel threads</code>, que existem exclusivamente no <code>kernel space</code> e não possuem componentes de espaço de usuário. Estes <code>threads</code> têm <code>mm = NULL</code> na <code>task_struct</code> porque não precisam de mapeamentos de memória virtual, <code>heap</code>, <code>stack</code> de usuário ou segmentos de código/dados de aplicação. Exemplos incluem <code>kthreadd</code>, criador de <code>kernel threads</code>, <code>ksoftirqd</code>, processamento de soft <code>IRQ</code>s, <code>migration threads</code>, balanceamento de <code>CPU</code> e <code>kworker threads</code>, filas de trabalho. Como executam apenas código do <code>kernel</code>, eles operam diretamente no espaço de endereçamento do <code>kernel</code>, compartilhando implicitamente o mesmo contexto de memória entre todos os <code>kernel threads</code>. Quando um <code>kernel thread</code> é escalonado, o sistema utiliza <code>lazy TLB</code> para manter o <code>mm_struct</code> do último processo de usuário que executou na <code>CPU</code>, evitando invalidações custosas do <strong>TLB</strong> já que o <code>kernel thread</code> não acessará memória de usuário. :::</p>
<ol start="4" type="a">
<li><strong>Limites das Seções (<code>+0x18</code> a <code>+0x38</code>)</strong></li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> start_code<span class="op">,</span> end_code<span class="op">;</span>   <span class="co">/* Seção .text */</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> start_data<span class="op">,</span> end_data<span class="op">;</span>   <span class="co">/* Seção .data */</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> start_brk<span class="op">,</span> brk<span class="op">;</span>         <span class="co">/* Heap management */</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> start_stack<span class="op">;</span>            <span class="co">/* Stack inicial */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estes campos definem o <strong>layout do espaço de endereçamento</strong> conforme estabelecido pelo <code>execve()</code> e modificado por <code>brk()</code>/<code>sbrk()</code>.</p></li>
</ol>
</section>
<section id="descritores-de-arquivo-files_struct" class="level5" data-number="10.1.1.1.2">
<h5 data-number="10.1.1.1.2" class="anchored" data-anchor-id="descritores-de-arquivo-files_struct"><span class="header-section-number">10.1.1.1.2</span> Descritores de Arquivo: <code>files_struct</code></h5>
<p>Estrutura no endereço <code>0xffff888012347000</code> implementando a tabela de descritores de arquivos do processo, utilizando arrays dinâmicos <strong>RCU-protected</strong> para acesso concorrente sem <code>locks</code> e <code>bitmaps</code> para controle eficiente de estado(ver <code>include/linux/fdtable.h</code>). Esta estrutura fundamental do <strong>VFS</strong> mantém o mapeamento entre números inteiros (<strong>FD</strong>s) e ponteiros para a <code>struct file</code>, suportando compartilhamento entre <code>threads</code> via <code>CLONE_FILES</code> e redimensionamento automático conforme necessário. O design emprega <strong>R</strong>ead-<strong>C</strong>opy-<strong>U</strong>pdate <strong>RCU</strong> para permitir leituras simultâneas durante operações de redimensionamento de arquivos, enquanto <code>bitmaps</code> especializados otimizam a localização de <strong>FD</strong>s livres e gerenciam <code>flags</code> como <code>close-on-exec</code> para controle preciso durante <code>execve()</code>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Bitmaps</strong> são estruturas de dados que utilizam arrays de bits para representar estados booleanos de forma extremamente eficiente em termos de memória e performance. No contexto da <code>files_struct</code>, cada bit nos arrays <code>close_on_exec</code> e <code>open_fds</code> corresponde a um file descriptor específico: o bit na posição <span class="math inline">\(n\)</span> representa o estado do FD <span class="math inline">\(n\)</span>. Um bit em <code>1</code> no bitmap <code>open_fds</code> indica que o FD está atualmente aberto, enquanto um bit em <code>1</code> em <code>close_on_exec</code> marca o FD para ser fechado automaticamente durante <code>execve()</code>. Esta abordagem permite operações O(1) para verificar o estado de qualquer FD através de operações bitwise simples (<code>test_bit()</code>, <code>set_bit()</code>, <code>clear_bit()</code>), além de otimizar a busca por FDs livres usando instruções como <code>find_next_zero_bit()</code>. Com cada bit ocupando apenas 1 bit de memória (versus 8 bytes para um ponteiro), os bitmaps oferecem compactação significativa e melhor localidade de cache para operações frequentes de gerenciamento de FDs.</p>
</div>
</div>
<p>A <code>files_struct</code> organiza seus componentes em campos estrategicamente posicionados para otimizar acesso sequencial e alinhamento de memória. Os campos fundamentais incluem contadores atômicos para sincronização, ponteiros <strong>RCU</strong> para acesso seguro em concorrência à tabela de descritores, arrays dinâmicos para armazenamento dos ponteiros de arquivo, e bitmaps especializados para controle eficiente de estado e operações de busca:</p>
<ol type="1">
<li><p><strong>Contador de Referências (<code>+0x00</code>)</strong>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">atomic_t</span> count<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Contador atômico para compartilhamento entre threads via <code>CLONE_FILES</code>. Esse contador é incrementado quando uma nova referência à <code>files_struct</code> é criada, como ao clonar um processo, e decrementado quando a estrutura é liberada. Isso garante que a estrutura permaneça válida enquanto houver referências ativas.</p></li>
<li><p><strong>Tabela de File Descriptors (<code>+0x08</code>)</strong>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> fdtable __rcu <span class="op">*</span>fdt<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro <strong>RCU-protected</strong> para a tabela atual de <strong>FD</strong>s. <strong>RCU</strong> permite leituras concorrentes sem <code>locks</code> durante resize da tabela.</p></li>
<li><p><strong>Array de Ponteiros (<code>+0x10</code>)</strong>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> file __rcu <span class="op">**</span>fd_array<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Array redimensionável de ponteiros para estruturas <code>file</code>. Cada entrada corresponde a um descritor de arquivo.</p></li>
<li><p><strong>Controle de Execução (<code>+0x18</code>)</strong>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="op">*</span>close_on_exec<span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="op">*</span>open_fds<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong><code>close_on_exec</code></strong>: <code>Bitmap</code> indicando <strong>FD</strong>s para fechar no <code>execve()</code>;</li>
<li><strong><code>open_fds</code></strong>: <code>Bitmap</code> de <strong>FD</strong>s atualmente abertos.</li>
</ul></li>
</ol>
<p>#####tratamento de Sinais: <code>signal_struct</code></p>
<p>Estrutura compartilhada em <code>0xffff888012348000</code> que centraliza o gerenciamento de sinais para todo o grupo de <code>threads</code>(ver <code>include/linux/signal.h</code>), mantendo <code>handlers</code> comuns, sinais pendentes compartilhados e contadores de estado do grupo. Esta estrutura implementa a semântica <strong>POSIX</strong> na qual sinais direcionados ao processo, como <code>SIGTERM</code>, <code>SIGKILL</code>, afetam todas as <code>threads</code> do grupo, enquanto <code>handlers</code> registrados via <code>sigaction()</code> são compartilhados entre todas as <code>threads</code>, garantindo comportamento consistente independentemente de qual <code>thread</code> recebe ou processa o sinal:</p>
<ol type="1">
<li><p><strong>Contadores de Vida (<code>+0x00</code>)</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">atomic_t</span> count<span class="op">;</span>     <span class="co">/* Referências à estrutura */</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">atomic_t</span> live<span class="op">;</span>      <span class="co">/* Threads vivas no grupo */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Handlers de Sinais (<code>+0x08</code>)</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> k_sigaction action<span class="op">[</span>_NSIG<span class="op">];</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Array de <span class="math inline">\(64\)</span> entradas (sinais <span class="math inline">\(1\)</span> a <span class="math inline">\(64\)</span>) contendo:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> k_sigaction <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sigaction sa<span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> sa_flags<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">sigset_t</span> sa_mask<span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Nesta estrutura temos:</p>
<ul>
<li><strong><code>sa</code></strong>: Estrutura <code>sigaction</code> com o <code>handler</code> do sinal;</li>
<li><strong><code>sa_flags</code></strong>: Flags adicionais como <code>SA_RESTART</code>, <code>SA_NOCLDSTOP</code>;</li>
<li><strong><code>sa_mask</code></strong>: Máscara de sinais bloqueados durante a execução do <code>handler</code>.</li>
</ul>
<p>O array é inicializado com handlers padrão para cada sinal, podendo ser modificado por chamadas como <code>sigaction()</code>.</p></li>
<li><p><strong>Sinais Pendentes Compartilhados (<code>+0x400</code>)</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sigpending shared_pending<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estrutura contendo:</p>
<ul>
<li><strong><code>signal</code></strong>: <code>bitmask</code> de sinais pendentes para todo o grupo;</li>
<li><strong><code>list</code></strong>: fila de estruturas <code>siginfo_t</code> com informações detalhadas.</li>
</ul></li>
</ol>
</section>
<section id="contexto-de-cpu-thread_struct" class="level5" data-number="10.1.1.1.3">
<h5 data-number="10.1.1.1.3" class="anchored" data-anchor-id="contexto-de-cpu-thread_struct"><span class="header-section-number">10.1.1.1.3</span> Contexto de CPU: <code>thread_struct</code></h5>
<p>Estrutura embedded na <code>task_struct</code> em <code>+0x38</code> que preserva o estado completo da <code>CPU</code> durante <em>context switching</em>, permitindo que <code>threads</code> sejam suspensas e posteriormente restauradas exatamente no ponto de interrupção. Esta estrutura específica da arquitetura <span class="math inline">\(x86_64\)</span> encapsula registradores, ponteiros de <code>stack</code>, <em>segment selectors</em> e estado de unidades de ponto flutuante, fornecendo ao <code>kernel</code> todas as informações necessárias para implementar multitasking preemptivo transparente. O design reflete a complexidade das <code>CPU</code>s modernas:</p>
<ol type="1">
<li><p><strong>Stack Pointers (<code>+0x38</code>)</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> sp0<span class="op">;</span>    <span class="co">/* `kernel` stack para TSS */</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> sp<span class="op">;</span>     <span class="co">/* SP salvo no context switch */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong><code>sp0</code></strong>: Carregado no <strong>Task State Segment (TSS)</strong> para privilege level transitions;</li>
<li><strong><code>sp</code></strong>: Valor de <code>RSP</code> salvo durante preempção, indispensável para chaveamento de contexto.</li>
</ul>
<p>::: callout-note <strong>Privilege Level transitions</strong> são mudanças automáticas entre diferentes níveis de privilégio da <code>CPU</code> <span class="math inline">\(x86_64\)</span>, implementadas via hardware para garantir isolamento e segurança. A arquitetura <span class="math inline">\(x86_64\)</span> define quatro anéis de proteção (rings 0-3), sendo <code>ring 0</code> o mais privilegiado, <code>kernel mode</code> e <code>ring 3</code> o menos privilegiado, <code>user mode</code>. Quando ocorre uma transição de <code>user mode</code> para <code>kernel mode</code>, via <code>system calls</code>, interrupções ou exceções, a <code>CPU</code> automaticamente consulta o <strong>T</strong>ask <strong>S</strong>tate <strong>S</strong>egment, <strong>TSS</strong> para obter o endereço da <code>stack</code> do <code>kernel</code> (<code>sp0</code>), garantindo que o código privilegiado execute com uma <code>stack</code> isolada e protegida. Esta transição é indispensável para manter a integridade do sistema: se o <code>kernel</code> usasse a <code>stack</code> do usuário, processos maliciosos poderiam corromper dados críticos ou explorar vulnerabilidades. O campo <code>sp0</code> na <code>thread_struct</code> é carregado no <strong>TSS</strong> a cada chaveamento de contexto, <em>constext switch</em>, assegurando que cada <code>thread</code> tenha sua própria <code>stack</code> de <code>kernel</code> exclusiva durante operações privilegiadas. :::</p></li>
<li><p><strong>Segment Selectors (<code>+0x48</code>)</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">short</span> es<span class="op">,</span> ds<span class="op">,</span> fsindex<span class="op">,</span> gsindex<span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> fsbase<span class="op">,</span> gsbase<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estado dos registradores de segmentos e suas bases, especialmente <code>FS</code> e <code>GS</code> que são utilizados para implementar <strong>T</strong>hread <strong>L</strong>ocal <strong>S</strong>torage, <strong>TLS</strong>, em bibliotecas de <code>threading</code> como a biblioteca <code>pthread</code>(ver <code>arch/x86/include/asm/processor.h</code>). O registrador <code>FS</code> tipicamente aponta para a estrutura de dados da <code>thread</code> atual (como <code>pthread_t</code>), permitindo acesso eficiente a variáveis <code>thread-local</code> através de instruções como <code>mov %fs:offset, %rax</code>. As bases <code>fsbase</code> e <code>gsbase</code> contêm os endereços lineares reais nos quais os segmentos <code>FS</code> e <code>GS</code> são mapeados, permitindo que cada <code>thread</code> tenha sua própria região de memória específica para <code>threads</code> sem necessidade de <code>locks</code> ou sincronização. Durante chaveamento de contexto, esses valores devem ser preservados e restaurados para manter a integridade do <strong>TLS</strong> de cada <code>thread</code>.</p></li>
<li><p><strong>Estado da FPU (<code>+0x58</code>)</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> fpu fpu<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estrutura de <span class="math inline">\(4096\)</span> bytes contendo:</p>
<ul>
<li><strong>xsave area</strong>: Estado completo <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">FPU/SSE/AVX/AVX-512</a>(ver <code>arch/x86/include/asm/fpu/api.h</code>). Esta área é usada para preservar o estado da unidade de ponto flutuante e das extensões <strong>SIMD</strong> durante o contexto de troca, permitindo que as <code>threads</code> continuem suas operações matemáticas complexas sem perda de precisão ou performance. O uso de <code>xsave</code> permite que o <code>kernel</code> salve e restaure eficientemente o estado da <strong>FPU</strong>, incluindo registradores <code>x87</code>, <code>XMM</code>, <code>YMM</code> e <code>ZMM</code>, além de flags de controle e status;</li>
<li><strong>Lazy switching</strong>: Salvo apenas quando necessário para performance.</li>
</ul></li>
</ol>
</section>
</section>
</section>
<section id="kernel-stack-e-context-switch" class="level3" data-number="10.1.2">
<h3 data-number="10.1.2" class="anchored" data-anchor-id="kernel-stack-e-context-switch"><span class="header-section-number">10.1.2</span> <code>kernel</code> Stack e Context Switch</h3>
<section id="organização-da-kernel-stack" class="level4" data-number="10.1.2.1">
<h4 data-number="10.1.2.1" class="anchored" data-anchor-id="organização-da-kernel-stack"><span class="header-section-number">10.1.2.1</span> Organização da <code>kernel</code> Stack</h4>
<p>Cada process possui uma <strong>kernel stack</strong> de <span class="math inline">\(8\)</span> KB alocada em <code>0xffffc90000120000</code> (vmalloc area):</p>
<p><strong>Thread Info (<code>stack_bottom</code>)</strong></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> thread_info <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> flags<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    u32 status<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    u32 cpu<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Localizada no <strong>final da stack</strong> (endereço mais baixo), contém metadados da thread.</p>
<p><strong>Registros Salvos (<code>pt_regs</code>)</strong> Durante system calls e interrupções, a estrutura <code>pt_regs</code> é empurrada na stack:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> pt_regs <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> r15<span class="op">,</span> r14<span class="op">,</span> r13<span class="op">,</span> r12<span class="op">,</span> rbp<span class="op">,</span> rbx<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> r11<span class="op">,</span> r10<span class="op">,</span> r9<span class="op">,</span> r8<span class="op">,</span> rax<span class="op">,</span> rcx<span class="op">,</span> rdx<span class="op">,</span> rsi<span class="op">,</span> rdi<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> orig_rax<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> rip<span class="op">,</span> cs<span class="op">,</span> eflags<span class="op">,</span> rsp<span class="op">,</span> ss<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mecanismo-de-context-switch" class="level4" data-number="10.1.2.2">
<h4 data-number="10.1.2.2" class="anchored" data-anchor-id="mecanismo-de-context-switch"><span class="header-section-number">10.1.2.2</span> Mecanismo de Context Switch</h4>
<p>O context switch no <strong>Linux</strong> envolve a função <code>switch_to()</code> definida em <code>arch/x86/include/asm/switch_to.h</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define switch_to</span><span class="op">(</span>prev<span class="op">,</span><span class="pp"> </span>next<span class="op">,</span><span class="pp"> </span>last<span class="op">)</span><span class="pp">                     </span><span class="op">\</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span><span class="pp"> </span><span class="op">{</span><span class="pp">                                                    </span><span class="op">\</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="pp">    </span>prepare_switch_to<span class="op">(</span>prev<span class="op">,</span><span class="pp"> </span>next<span class="op">);</span><span class="pp">                      </span><span class="op">\</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="pp">                                                        </span><span class="op">\</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="pp">    </span><span class="kw">asm</span><span class="pp"> </span><span class="at">volatile</span><span class="op">(</span>SAVE_CONTEXT<span class="pp">                           </span><span class="op">\</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="pp">                 </span><span class="st">"movq </span><span class="sc">%%</span><span class="st">rsp,%P[threadrsp](%[prev])</span><span class="sc">\n\t</span><span class="st">"</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="pp">                 </span><span class="st">"movq %P[threadrsp](%[next]),</span><span class="sc">%%</span><span class="st">rsp</span><span class="sc">\n\t</span><span class="st">"</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="pp">                 </span>RESTORE_CONTEXT<span class="pp">                         </span><span class="op">\</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="pp">                 </span><span class="op">:</span><span class="pp"> </span><span class="op">[</span>last<span class="op">]</span><span class="pp"> </span><span class="st">"=a"</span><span class="pp"> </span><span class="op">(</span>last<span class="op">)</span><span class="pp">                    </span><span class="op">\</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="pp">                 </span><span class="op">:</span><span class="pp"> </span><span class="op">[</span>next<span class="op">]</span><span class="pp"> </span><span class="st">"S"</span><span class="pp"> </span><span class="op">(</span>next<span class="op">),</span><span class="pp"> </span><span class="op">[</span>prev<span class="op">]</span><span class="pp"> </span><span class="st">"D"</span><span class="pp"> </span><span class="op">(</span>prev<span class="op">),</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="pp">                   </span><span class="op">[</span>threadrsp<span class="op">]</span><span class="pp"> </span><span class="st">"i"</span><span class="pp"> </span><span class="op">(</span>offsetof<span class="op">(</span><span class="kw">struct</span><span class="pp"> </span>task_struct<span class="op">,</span><span class="pp"> </span>thread<span class="op">.</span>sp<span class="op">))</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="pp">                 </span><span class="op">:</span><span class="pp"> </span><span class="st">"memory"</span><span class="op">,</span><span class="pp"> </span><span class="st">"cc"</span><span class="op">);</span><span class="pp">                      </span><span class="op">\</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="pp"> </span><span class="cf">while</span><span class="pp"> </span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Este assembly:</p>
<ol type="1">
<li>Salva <code>RSP</code> atual em <code>prev-&gt;thread.sp</code></li>
<li>Carrega <code>next-&gt;thread.sp</code> em <code>RSP</code></li>
<li>Troca page tables via <code>CR3</code> se necessário</li>
<li>Preserva registros <strong>callee-saved</strong> conforme ABI</li>
</ol>
</section>
</section>
</section>
<section id="simulador-1-arquitetura-e-hierarquia-do-process-control-block-linux" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="simulador-1-arquitetura-e-hierarquia-do-process-control-block-linux"><span class="header-section-number">10.2</span> Simulador 1: Arquitetura e Hierarquia do Process Control Block Linux</h2>
<p>A <code>task_struct</code> representa o coração do gerenciamento de processos no <code>kernel</code> <strong>Linux</strong>, funcionando como o <strong>Process Control Block (PCB)</strong> que mantém todas as informações necessárias sobre cada processo ou thread no sistema. Para que a dedicada leitora compreenda profundamente essa arquitetura complexa, desenvolvemos um simulador que demonstra a criação, modificação e relacionamento entre as estruturas fundamentais do kernel, sem adentrar nos algoritmos de escalonamento.</p>
<p>O <strong>Process Control Block</strong> no <strong>Linux</strong> é implementado através da estrutura <code>task_struct</code>, que contém dezenas de campos organizados logicamente para representar diferentes aspectos de um processo: identificação (PID, TGID, PPID), estado atual, ponteiros para estruturas auxiliares, informações de memória, arquivos abertos, sinais pendentes, e relacionamentos hierárquicos. Esta estrutura não é um bloco monolítico, mas sim um conjunto interconectado de ponteiros para estruturas especializadas que podem ser compartilhadas entre múltiplos processos.</p>
<p>O simulador demonstra como operações fundamentais como <code>fork()</code> e <code>clone()</code> manipulam essas estruturas. Enquanto <code>fork()</code> cria cópias independentes de todas as estruturas auxiliares, <code>clone()</code> permite compartilhamento seletivo através dos <strong>CLONE_* flags</strong>. Por exemplo, <code>CLONE_VM</code> compartilha o espaço de endereçamento (<code>mm_struct</code>), <code>CLONE_FILES</code> compartilha a tabela de file descriptors (<code>files_struct</code>), e <code>CLONE_SIGHAND</code> compartilha os handlers de sinais (<code>signal_struct</code>). Esta flexibilidade permite que threads compartilhem recursos enquanto processos mantêm isolamento.</p>
<p>A <strong>hierarquia de processos</strong> emerge naturalmente através dos campos PID (Process ID), PPID (Parent Process ID) e TGID (Thread Group ID). Processos criados via <code>fork()</code> recebem novo PID e TGID idênticos, estabelecendo-se como líderes de grupo. Threads criadas via <code>clone()</code> com <code>CLONE_THREAD</code> mantêm o TGID do processo pai, formando um grupo coeso. O simulador visualiza essa hierarquia através de árvores de processos e demonstra como operações afetam a topologia dessas relações.</p>
<p>O conceito de <strong>contadores de referência</strong> é fundamental para o gerenciamento seguro de recursos compartilhados. Cada estrutura auxiliar mantém contadores atômicos que rastreiam quantos processos a referenciam. Quando um processo termina via <code>exit()</code>, os contadores são decrementados, e estruturas sem referências são liberadas automaticamente. O simulador demonstra esse mecanismo através de visualização em tempo real dos contadores, evidenciando como o <code>kernel</code> evita vazamentos de memória e liberação prematura de recursos.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@file</span><span class="co"> </span><span class="cv">pcb_architecture_simulator.cpp</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Simulador da arquitetura do Process Control Block Linux</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@author</span><span class="co"> Livro de Sistemas Operacionais</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@version</span><span class="co"> </span><span class="cv">1.0</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@date</span><span class="co"> 2025</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * Este programa demonstra a arquitetura interna da task_struct e suas</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * estruturas auxiliares (mm_struct, files_struct, signal_struct),</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * focando na hierarquia de processos, compartilhamento de recursos</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * via CLONE_* flags, e gerenciamento de referências sem abordar</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * algoritmos de escalonamento.</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * O simulador permite visualizar como operações do sistema (fork, clone, exit)</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * afetam as estruturas de dados do `kernel` e como recursos são compartilhados</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * entre processos e threads de forma segura através de contadores atômicos.</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;atomic&gt;</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;format&gt;</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;variant&gt;</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;expected&gt;</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bitset&gt;</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;map&gt;</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Estados possíveis de um processo conforme definido no kernel</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> TaskState <span class="op">{</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>    TASK_RUNNING<span class="op">,</span>        <span class="co">///&lt; Processo ativo ou pronto para execução</span></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>    TASK_INTERRUPTIBLE<span class="op">,</span>  <span class="co">///&lt; Dormindo, pode ser acordado por sinais</span></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>    TASK_UNINTERRUPTIBLE<span class="op">,</span><span class="co">///&lt; Dormindo, não pode ser interrompido</span></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>    TASK_ZOMBIE<span class="op">,</span>         <span class="co">///&lt; Processo terminou, aguardando wait()</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>    TASK_STOPPED<span class="op">,</span>        <span class="co">///&lt; Processo parado por debugging/job control</span></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>    TASK_TRACED          <span class="co">///&lt; Processo sendo rastreado por debugger</span></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Flags para clone() que determinam compartilhamento de recursos</span></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> CloneFlags <span class="op">:</span> <span class="dt">uint32_t</span> <span class="op">{</span></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>    CLONE_VM      <span class="op">=</span> <span class="bn">0x00000100</span><span class="op">,</span>  <span class="co">///&lt; Compartilha espaço de endereçamento</span></span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>    CLONE_FS      <span class="op">=</span> <span class="bn">0x00000200</span><span class="op">,</span>  <span class="co">///&lt; Compartilha informações de filesystem</span></span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>    CLONE_FILES   <span class="op">=</span> <span class="bn">0x00000400</span><span class="op">,</span>  <span class="co">///&lt; Compartilha tabela de file descriptors</span></span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>    CLONE_SIGHAND <span class="op">=</span> <span class="bn">0x00000800</span><span class="op">,</span>  <span class="co">///&lt; Compartilha handlers de sinais</span></span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a>    CLONE_PARENT  <span class="op">=</span> <span class="bn">0x00002000</span><span class="op">,</span>  <span class="co">///&lt; Filho tem mesmo pai que o chamador</span></span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a>    CLONE_THREAD  <span class="op">=</span> <span class="bn">0x00010000</span><span class="op">,</span>  <span class="co">///&lt; Cria thread no mesmo grupo</span></span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>    CLONE_NEWNS   <span class="op">=</span> <span class="bn">0x00020000</span><span class="op">,</span>  <span class="co">///&lt; Novo namespace de m nt</span></span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a>    CLONE_SYSVSEM <span class="op">=</span> <span class="bn">0x00040000</span><span class="op">,</span>  <span class="co">///&lt; Compartilha semáforos System V</span></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>    CLONE_SETTLS  <span class="op">=</span> <span class="bn">0x00080000</span><span class="op">,</span>  <span class="co">///&lt; Configura Thread Local Storage</span></span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a>    CLONE_CHILD_SETTID <span class="op">=</span> <span class="bn">0x01000000</span>  <span class="co">///&lt; Escreve TID no espaço do filho</span></span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Representação de uma Virtual Memory Area</span></span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> VirtualMemoryArea <span class="op">{</span></span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> vm_start<span class="op">;</span>           <span class="co">///&lt; Endereço inicial da VMA</span></span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> vm_end<span class="op">;</span>             <span class="co">///&lt; Endereço final da VMA</span></span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> vm_flags<span class="op">;</span>           <span class="co">///&lt; Flags de proteção (read/write/exec)</span></span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string vm_name<span class="op">;</span>         <span class="co">///&lt; Nome da região (heap, stack, etc.)</span></span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> vm_offset<span class="op">;</span>          <span class="co">///&lt; Offset no arquivo (se mapeado)</span></span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-75"><a href="#cb28-75" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor inicializando VMA</span></span>
<span id="cb28-76"><a href="#cb28-76" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-77"><a href="#cb28-77" aria-hidden="true" tabindex="-1"></a>    VirtualMemoryArea<span class="op">(</span><span class="dt">uint64_t</span> start<span class="op">,</span> <span class="dt">uint64_t</span> end<span class="op">,</span> <span class="dt">uint32_t</span> flags<span class="op">,</span> </span>
<span id="cb28-78"><a href="#cb28-78" aria-hidden="true" tabindex="-1"></a>                     <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> name<span class="op">,</span> <span class="dt">uint64_t</span> offset <span class="op">=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb28-79"><a href="#cb28-79" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> vm_start<span class="op">(</span>start<span class="op">),</span> vm_end<span class="op">(</span>end<span class="op">),</span> vm_flags<span class="op">(</span>flags<span class="op">),</span> </span>
<span id="cb28-80"><a href="#cb28-80" aria-hidden="true" tabindex="-1"></a>          vm_name<span class="op">(</span>name<span class="op">),</span> vm_offset<span class="op">(</span>offset<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-81"><a href="#cb28-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-82"><a href="#cb28-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-83"><a href="#cb28-83" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Calcula tamanho da VMA em bytes</span></span>
<span id="cb28-84"><a href="#cb28-84" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-85"><a href="#cb28-85" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> size<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> vm_end <span class="op">-</span> vm_start<span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-86"><a href="#cb28-86" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-87"><a href="#cb28-87" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-88"><a href="#cb28-88" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Verifica se endereço está dentro da VMA</span></span>
<span id="cb28-89"><a href="#cb28-89" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-90"><a href="#cb28-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> contains<span class="op">(</span><span class="dt">uint64_t</span> addr<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-91"><a href="#cb28-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> addr <span class="op">&gt;=</span> vm_start <span class="op">&amp;&amp;</span> addr <span class="op">&lt;</span> vm_end<span class="op">;</span></span>
<span id="cb28-92"><a href="#cb28-92" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-93"><a href="#cb28-93" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-94"><a href="#cb28-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-95"><a href="#cb28-95" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-96"><a href="#cb28-96" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Simulação da mm_struct - descritor de memória do processo</span></span>
<span id="cb28-97"><a href="#cb28-97" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-98"><a href="#cb28-98" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MemoryDescriptor <span class="op">{</span></span>
<span id="cb28-99"><a href="#cb28-99" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb28-100"><a href="#cb28-100" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">mm_users_</span><span class="op">;</span>      <span class="co">///&lt; Número de tasks usando este espaço</span></span>
<span id="cb28-101"><a href="#cb28-101" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">mm_count_</span><span class="op">;</span>      <span class="co">///&lt; Contador de referências total</span></span>
<span id="cb28-102"><a href="#cb28-102" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>VirtualMemoryArea<span class="op">&gt;</span> <span class="va">vma_list_</span><span class="op">;</span> <span class="co">///&lt; Lista de VMAs</span></span>
<span id="cb28-103"><a href="#cb28-103" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">pgd_</span><span class="op">;</span>                   <span class="co">///&lt; Endereço da tabela de páginas raiz</span></span>
<span id="cb28-104"><a href="#cb28-104" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">start_code_</span><span class="op">;</span>            <span class="co">///&lt; Início da seção de código</span></span>
<span id="cb28-105"><a href="#cb28-105" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">end_code_</span><span class="op">;</span>              <span class="co">///&lt; Fim da seção de código</span></span>
<span id="cb28-106"><a href="#cb28-106" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">start_data_</span><span class="op">;</span>            <span class="co">///&lt; Início da seção de dados</span></span>
<span id="cb28-107"><a href="#cb28-107" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">end_data_</span><span class="op">;</span>              <span class="co">///&lt; Fim da seção de dados</span></span>
<span id="cb28-108"><a href="#cb28-108" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">start_brk_</span><span class="op">;</span>             <span class="co">///&lt; Início do heap</span></span>
<span id="cb28-109"><a href="#cb28-109" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">brk_</span><span class="op">;</span>                   <span class="co">///&lt; Fim atual do heap</span></span>
<span id="cb28-110"><a href="#cb28-110" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">start_stack_</span><span class="op">;</span>           <span class="co">///&lt; Base da stack</span></span>
<span id="cb28-111"><a href="#cb28-111" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-112"><a href="#cb28-112" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-113"><a href="#cb28-113" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-114"><a href="#cb28-114" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor criando layout de memória padrão</span></span>
<span id="cb28-115"><a href="#cb28-115" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-116"><a href="#cb28-116" aria-hidden="true" tabindex="-1"></a>    MemoryDescriptor<span class="op">()</span> <span class="op">:</span> <span class="va">mm_users_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">mm_count_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">pgd_</span><span class="op">(</span><span class="bn">0x1000000</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-117"><a href="#cb28-117" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Layout típico de processo x86_64</span></span>
<span id="cb28-118"><a href="#cb28-118" aria-hidden="true" tabindex="-1"></a>        <span class="va">start_code_</span> <span class="op">=</span> <span class="bn">0x400000</span><span class="op">;</span></span>
<span id="cb28-119"><a href="#cb28-119" aria-hidden="true" tabindex="-1"></a>        <span class="va">end_code_</span> <span class="op">=</span> <span class="bn">0x401000</span><span class="op">;</span></span>
<span id="cb28-120"><a href="#cb28-120" aria-hidden="true" tabindex="-1"></a>        <span class="va">start_data_</span> <span class="op">=</span> <span class="bn">0x600000</span><span class="op">;</span></span>
<span id="cb28-121"><a href="#cb28-121" aria-hidden="true" tabindex="-1"></a>        <span class="va">end_data_</span> <span class="op">=</span> <span class="bn">0x601000</span><span class="op">;</span></span>
<span id="cb28-122"><a href="#cb28-122" aria-hidden="true" tabindex="-1"></a>        <span class="va">start_brk_</span> <span class="op">=</span> <span class="bn">0x602000</span><span class="op">;</span></span>
<span id="cb28-123"><a href="#cb28-123" aria-hidden="true" tabindex="-1"></a>        <span class="va">brk_</span> <span class="op">=</span> <span class="bn">0x602000</span><span class="op">;</span></span>
<span id="cb28-124"><a href="#cb28-124" aria-hidden="true" tabindex="-1"></a>        <span class="va">start_stack_</span> <span class="op">=</span> <span class="bn">0x7fffffffe000</span><span class="op">;</span></span>
<span id="cb28-125"><a href="#cb28-125" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-126"><a href="#cb28-126" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Cria VMAs iniciais</span></span>
<span id="cb28-127"><a href="#cb28-127" aria-hidden="true" tabindex="-1"></a>        <span class="va">vma_list_</span><span class="op">.</span>emplace_back<span class="op">(</span><span class="va">start_code_</span><span class="op">,</span> <span class="va">end_code_</span><span class="op">,</span> <span class="bn">0x5</span><span class="op">,</span> <span class="st">"text"</span><span class="op">);</span>     <span class="co">// r-x</span></span>
<span id="cb28-128"><a href="#cb28-128" aria-hidden="true" tabindex="-1"></a>        <span class="va">vma_list_</span><span class="op">.</span>emplace_back<span class="op">(</span><span class="va">start_data_</span><span class="op">,</span> <span class="va">end_data_</span><span class="op">,</span> <span class="bn">0x3</span><span class="op">,</span> <span class="st">"data"</span><span class="op">);</span>     <span class="co">// rw-</span></span>
<span id="cb28-129"><a href="#cb28-129" aria-hidden="true" tabindex="-1"></a>        <span class="va">vma_list_</span><span class="op">.</span>emplace_back<span class="op">(</span><span class="va">start_brk_</span><span class="op">,</span> <span class="va">brk_</span><span class="op">,</span> <span class="bn">0x3</span><span class="op">,</span> <span class="st">"heap"</span><span class="op">);</span>           <span class="co">// rw-</span></span>
<span id="cb28-130"><a href="#cb28-130" aria-hidden="true" tabindex="-1"></a>        <span class="va">vma_list_</span><span class="op">.</span>emplace_back<span class="op">(</span><span class="va">start_stack_</span><span class="op">,</span> <span class="va">start_stack_</span> <span class="op">+</span> <span class="bn">0x200000</span><span class="op">,</span> <span class="bn">0x3</span><span class="op">,</span> <span class="st">"stack"</span><span class="op">);</span> <span class="co">// rw-</span></span>
<span id="cb28-131"><a href="#cb28-131" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-132"><a href="#cb28-132" aria-hidden="true" tabindex="-1"></a>        <span class="co">// VMA para bibliotecas compartilhadas</span></span>
<span id="cb28-133"><a href="#cb28-133" aria-hidden="true" tabindex="-1"></a>        <span class="va">vma_list_</span><span class="op">.</span>emplace_back<span class="op">(</span><span class="bn">0x7ffff7000000</span><span class="op">,</span> <span class="bn">0x7ffff7200000</span><span class="op">,</span> <span class="bn">0x5</span><span class="op">,</span> <span class="st">"libc"</span><span class="op">);</span></span>
<span id="cb28-134"><a href="#cb28-134" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-135"><a href="#cb28-135" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-136"><a href="#cb28-136" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-137"><a href="#cb28-137" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor de cópia para fork()</span></span>
<span id="cb28-138"><a href="#cb28-138" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-139"><a href="#cb28-139" aria-hidden="true" tabindex="-1"></a>    MemoryDescriptor<span class="op">(</span><span class="at">const</span> MemoryDescriptor<span class="op">&amp;</span> other<span class="op">)</span> </span>
<span id="cb28-140"><a href="#cb28-140" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">mm_users_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">mm_count_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">vma_list_</span><span class="op">(</span>other<span class="op">.</span><span class="va">vma_list_</span><span class="op">),</span></span>
<span id="cb28-141"><a href="#cb28-141" aria-hidden="true" tabindex="-1"></a>          <span class="va">pgd_</span><span class="op">(</span>other<span class="op">.</span><span class="va">pgd_</span> <span class="op">+</span> <span class="bn">0x1000</span><span class="op">),</span> <span class="va">start_code_</span><span class="op">(</span>other<span class="op">.</span><span class="va">start_code_</span><span class="op">),</span></span>
<span id="cb28-142"><a href="#cb28-142" aria-hidden="true" tabindex="-1"></a>          <span class="va">end_code_</span><span class="op">(</span>other<span class="op">.</span><span class="va">end_code_</span><span class="op">),</span> <span class="va">start_data_</span><span class="op">(</span>other<span class="op">.</span><span class="va">start_data_</span><span class="op">),</span></span>
<span id="cb28-143"><a href="#cb28-143" aria-hidden="true" tabindex="-1"></a>          <span class="va">end_data_</span><span class="op">(</span>other<span class="op">.</span><span class="va">end_data_</span><span class="op">),</span> <span class="va">start_brk_</span><span class="op">(</span>other<span class="op">.</span><span class="va">start_brk_</span><span class="op">),</span></span>
<span id="cb28-144"><a href="#cb28-144" aria-hidden="true" tabindex="-1"></a>          <span class="va">brk_</span><span class="op">(</span>other<span class="op">.</span><span class="va">brk_</span><span class="op">),</span> <span class="va">start_stack_</span><span class="op">(</span>other<span class="op">.</span><span class="va">start_stack_</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-145"><a href="#cb28-145" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-146"><a href="#cb28-146" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-147"><a href="#cb28-147" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Adiciona usuário (para CLONE_VM)</span></span>
<span id="cb28-148"><a href="#cb28-148" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-149"><a href="#cb28-149" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> addUser<span class="op">()</span> <span class="op">{</span> </span>
<span id="cb28-150"><a href="#cb28-150" aria-hidden="true" tabindex="-1"></a>        <span class="va">mm_users_</span><span class="op">++;</span> </span>
<span id="cb28-151"><a href="#cb28-151" aria-hidden="true" tabindex="-1"></a>        <span class="va">mm_count_</span><span class="op">++;</span></span>
<span id="cb28-152"><a href="#cb28-152" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-153"><a href="#cb28-153" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-154"><a href="#cb28-154" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-155"><a href="#cb28-155" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Remove usuário</span></span>
<span id="cb28-156"><a href="#cb28-156" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se não há mais usuários</span></span>
<span id="cb28-157"><a href="#cb28-157" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-158"><a href="#cb28-158" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> removeUser<span class="op">()</span> <span class="op">{</span> </span>
<span id="cb28-159"><a href="#cb28-159" aria-hidden="true" tabindex="-1"></a>        <span class="va">mm_users_</span><span class="op">--;</span></span>
<span id="cb28-160"><a href="#cb28-160" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">mm_users_</span><span class="op">.</span>load<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-161"><a href="#cb28-161" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-162"><a href="#cb28-162" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-163"><a href="#cb28-163" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-164"><a href="#cb28-164" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula expansão do heap via brk()</span></span>
<span id="cb28-165"><a href="#cb28-165" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">new_brk</span><span class="co"> Novo fim do heap</span></span>
<span id="cb28-166"><a href="#cb28-166" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se bem-sucedido</span></span>
<span id="cb28-167"><a href="#cb28-167" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-168"><a href="#cb28-168" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> expandHeap<span class="op">(</span><span class="dt">uint64_t</span> new_brk<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-169"><a href="#cb28-169" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>new_brk <span class="op">&gt;</span> <span class="va">brk_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-170"><a href="#cb28-170" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Encontra VMA do heap e expande</span></span>
<span id="cb28-171"><a href="#cb28-171" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> heap_vma <span class="op">=</span> <span class="bu">std::</span>ranges::find_if<span class="op">(</span><span class="va">vma_list_</span><span class="op">,</span> </span>
<span id="cb28-172"><a href="#cb28-172" aria-hidden="true" tabindex="-1"></a>                <span class="op">[</span><span class="kw">this</span><span class="op">](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> vma<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb28-173"><a href="#cb28-173" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> vma<span class="op">.</span>vm_name <span class="op">==</span> <span class="st">"heap"</span><span class="op">;</span> </span>
<span id="cb28-174"><a href="#cb28-174" aria-hidden="true" tabindex="-1"></a>                <span class="op">});</span></span>
<span id="cb28-175"><a href="#cb28-175" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>heap_vma <span class="op">!=</span> <span class="va">vma_list_</span><span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-176"><a href="#cb28-176" aria-hidden="true" tabindex="-1"></a>                heap_vma<span class="op">-&gt;</span>vm_end <span class="op">=</span> new_brk<span class="op">;</span></span>
<span id="cb28-177"><a href="#cb28-177" aria-hidden="true" tabindex="-1"></a>                <span class="va">brk_</span> <span class="op">=</span> new_brk<span class="op">;</span></span>
<span id="cb28-178"><a href="#cb28-178" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb28-179"><a href="#cb28-179" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-180"><a href="#cb28-180" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-181"><a href="#cb28-181" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-182"><a href="#cb28-182" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-183"><a href="#cb28-183" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-184"><a href="#cb28-184" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-185"><a href="#cb28-185" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Adiciona nova VMA (simulando mmap)</span></span>
<span id="cb28-186"><a href="#cb28-186" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">start</span><span class="co"> Endereço inicial</span></span>
<span id="cb28-187"><a href="#cb28-187" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">size</span><span class="co"> Tamanho da região</span></span>
<span id="cb28-188"><a href="#cb28-188" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">flags</span><span class="co"> Flags de proteção</span></span>
<span id="cb28-189"><a href="#cb28-189" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">name</span><span class="co"> Nome da região</span></span>
<span id="cb28-190"><a href="#cb28-190" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-191"><a href="#cb28-191" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> addVMA<span class="op">(</span><span class="dt">uint64_t</span> start<span class="op">,</span> <span class="dt">uint64_t</span> size<span class="op">,</span> <span class="dt">uint32_t</span> flags<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-192"><a href="#cb28-192" aria-hidden="true" tabindex="-1"></a>        <span class="va">vma_list_</span><span class="op">.</span>emplace_back<span class="op">(</span>start<span class="op">,</span> start <span class="op">+</span> size<span class="op">,</span> flags<span class="op">,</span> name<span class="op">);</span></span>
<span id="cb28-193"><a href="#cb28-193" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-194"><a href="#cb28-194" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-195"><a href="#cb28-195" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-196"><a href="#cb28-196" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém estatísticas de memória</span></span>
<span id="cb28-197"><a href="#cb28-197" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-198"><a href="#cb28-198" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> getMemoryStats<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-199"><a href="#cb28-199" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint64_t</span> total_size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-200"><a href="#cb28-200" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> vma <span class="op">:</span> <span class="va">vma_list_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-201"><a href="#cb28-201" aria-hidden="true" tabindex="-1"></a>            total_size <span class="op">+=</span> vma<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb28-202"><a href="#cb28-202" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-203"><a href="#cb28-203" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(</span><span class="va">mm_users_</span><span class="op">.</span>load<span class="op">(),</span> <span class="va">mm_count_</span><span class="op">.</span>load<span class="op">(),</span> </span>
<span id="cb28-204"><a href="#cb28-204" aria-hidden="true" tabindex="-1"></a>                              <span class="va">vma_list_</span><span class="op">.</span>size<span class="op">(),</span> total_size<span class="op">);</span></span>
<span id="cb28-205"><a href="#cb28-205" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-206"><a href="#cb28-206" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-207"><a href="#cb28-207" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-208"><a href="#cb28-208" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Lista todas as VMAs</span></span>
<span id="cb28-209"><a href="#cb28-209" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-210"><a href="#cb28-210" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>VirtualMemoryArea<span class="op">&gt;&amp;</span> getVMAs<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">vma_list_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-211"><a href="#cb28-211" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-212"><a href="#cb28-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-213"><a href="#cb28-213" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-214"><a href="#cb28-214" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Representação de arquivo aberto</span></span>
<span id="cb28-215"><a href="#cb28-215" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-216"><a href="#cb28-216" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> OpenFile <span class="op">{</span></span>
<span id="cb28-217"><a href="#cb28-217" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string path<span class="op">;</span>            <span class="co">///&lt; Caminho do arquivo</span></span>
<span id="cb28-218"><a href="#cb28-218" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> flags<span class="op">;</span>             <span class="co">///&lt; Flags de abertura (O_RDONLY, etc.)</span></span>
<span id="cb28-219"><a href="#cb28-219" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> pos<span class="op">;</span>               <span class="co">///&lt; Posição atual no arquivo</span></span>
<span id="cb28-220"><a href="#cb28-220" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> close_on_exec<span class="op">;</span>         <span class="co">///&lt; Flag FD_CLOEXEC</span></span>
<span id="cb28-221"><a href="#cb28-221" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string mode<span class="op">;</span>           <span class="co">///&lt; Modo de abertura legível</span></span>
<span id="cb28-222"><a href="#cb28-222" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-223"><a href="#cb28-223" aria-hidden="true" tabindex="-1"></a>    OpenFile<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> p<span class="op">,</span> <span class="dt">uint32_t</span> f<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> m <span class="op">=</span> <span class="st">"r"</span><span class="op">)</span></span>
<span id="cb28-224"><a href="#cb28-224" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> path<span class="op">(</span>p<span class="op">),</span> flags<span class="op">(</span>f<span class="op">),</span> pos<span class="op">(</span><span class="dv">0</span><span class="op">),</span> close_on_exec<span class="op">(</span><span class="kw">false</span><span class="op">),</span> mode<span class="op">(</span>m<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-225"><a href="#cb28-225" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-226"><a href="#cb28-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-227"><a href="#cb28-227" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-228"><a href="#cb28-228" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Simulação da files_struct - tabela de file descriptors</span></span>
<span id="cb28-229"><a href="#cb28-229" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-230"><a href="#cb28-230" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FileDescriptorTable <span class="op">{</span></span>
<span id="cb28-231"><a href="#cb28-231" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb28-232"><a href="#cb28-232" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">count_</span><span class="op">;</span>                           <span class="co">///&lt; Contador de referências</span></span>
<span id="cb28-233"><a href="#cb28-233" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>optional<span class="op">&lt;</span>OpenFile<span class="op">&gt;&gt;</span> <span class="va">fd_array_</span><span class="op">;</span>   <span class="co">///&lt; Array de file descriptors</span></span>
<span id="cb28-234"><a href="#cb28-234" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">1024</span><span class="op">&gt;</span> <span class="va">open_fds_</span><span class="op">;</span>                      <span class="co">///&lt; Bitmap de FDs abertos</span></span>
<span id="cb28-235"><a href="#cb28-235" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">1024</span><span class="op">&gt;</span> <span class="va">close_on_exec_</span><span class="op">;</span>                 <span class="co">///&lt; Bitmap FD_CLOEXEC</span></span>
<span id="cb28-236"><a href="#cb28-236" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">next_fd_</span><span class="op">;</span>                                     <span class="co">///&lt; Próximo FD livre</span></span>
<span id="cb28-237"><a href="#cb28-237" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-238"><a href="#cb28-238" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-239"><a href="#cb28-239" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-240"><a href="#cb28-240" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor inicializando FDs padrão</span></span>
<span id="cb28-241"><a href="#cb28-241" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-242"><a href="#cb28-242" aria-hidden="true" tabindex="-1"></a>    FileDescriptorTable<span class="op">()</span> <span class="op">:</span> <span class="va">count_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">next_fd_</span><span class="op">(</span><span class="dv">3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-243"><a href="#cb28-243" aria-hidden="true" tabindex="-1"></a>        <span class="va">fd_array_</span><span class="op">.</span>resize<span class="op">(</span><span class="dv">1024</span><span class="op">);</span></span>
<span id="cb28-244"><a href="#cb28-244" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-245"><a href="#cb28-245" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Inicializa stdin, stdout, stderr</span></span>
<span id="cb28-246"><a href="#cb28-246" aria-hidden="true" tabindex="-1"></a>        <span class="va">fd_array_</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> OpenFile<span class="op">(</span><span class="st">"/dev/stdin"</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="st">"r"</span><span class="op">);</span></span>
<span id="cb28-247"><a href="#cb28-247" aria-hidden="true" tabindex="-1"></a>        <span class="va">fd_array_</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> OpenFile<span class="op">(</span><span class="st">"/dev/stdout"</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="st">"w"</span><span class="op">);</span></span>
<span id="cb28-248"><a href="#cb28-248" aria-hidden="true" tabindex="-1"></a>        <span class="va">fd_array_</span><span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> OpenFile<span class="op">(</span><span class="st">"/dev/stderr"</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="st">"w"</span><span class="op">);</span></span>
<span id="cb28-249"><a href="#cb28-249" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-250"><a href="#cb28-250" aria-hidden="true" tabindex="-1"></a>        <span class="va">open_fds_</span><span class="op">.</span>set<span class="op">(</span><span class="dv">0</span><span class="op">);</span> <span class="va">open_fds_</span><span class="op">.</span>set<span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="va">open_fds_</span><span class="op">.</span>set<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb28-251"><a href="#cb28-251" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-252"><a href="#cb28-252" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-253"><a href="#cb28-253" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-254"><a href="#cb28-254" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor de cópia para fork()</span></span>
<span id="cb28-255"><a href="#cb28-255" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-256"><a href="#cb28-256" aria-hidden="true" tabindex="-1"></a>    FileDescriptorTable<span class="op">(</span><span class="at">const</span> FileDescriptorTable<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb28-257"><a href="#cb28-257" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">count_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">fd_array_</span><span class="op">(</span>other<span class="op">.</span><span class="va">fd_array_</span><span class="op">),</span> <span class="va">open_fds_</span><span class="op">(</span>other<span class="op">.</span><span class="va">open_fds_</span><span class="op">),</span></span>
<span id="cb28-258"><a href="#cb28-258" aria-hidden="true" tabindex="-1"></a>          <span class="va">close_on_exec_</span><span class="op">(</span>other<span class="op">.</span><span class="va">close_on_exec_</span><span class="op">),</span> <span class="va">next_fd_</span><span class="op">(</span>other<span class="op">.</span><span class="va">next_fd_</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-259"><a href="#cb28-259" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-260"><a href="#cb28-260" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-261"><a href="#cb28-261" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Compartilha tabela (CLONE_FILES)</span></span>
<span id="cb28-262"><a href="#cb28-262" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-263"><a href="#cb28-263" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> share<span class="op">()</span> <span class="op">{</span> <span class="va">count_</span><span class="op">++;</span> <span class="op">}</span></span>
<span id="cb28-264"><a href="#cb28-264" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-265"><a href="#cb28-265" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-266"><a href="#cb28-266" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Remove referência</span></span>
<span id="cb28-267"><a href="#cb28-267" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se não há mais referências</span></span>
<span id="cb28-268"><a href="#cb28-268" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-269"><a href="#cb28-269" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> release<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">--</span><span class="va">count_</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-270"><a href="#cb28-270" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-271"><a href="#cb28-271" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-272"><a href="#cb28-272" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Aloca novo file descriptor</span></span>
<span id="cb28-273"><a href="#cb28-273" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">file</span><span class="co"> Arquivo a ser aberto</span></span>
<span id="cb28-274"><a href="#cb28-274" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> FD alocado ou erro</span></span>
<span id="cb28-275"><a href="#cb28-275" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-276"><a href="#cb28-276" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>expected<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> openFile<span class="op">(</span><span class="at">const</span> OpenFile<span class="op">&amp;</span> file<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-277"><a href="#cb28-277" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Busca primeiro FD livre</span></span>
<span id="cb28-278"><a href="#cb28-278" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> fd <span class="op">=</span> <span class="va">next_fd_</span><span class="op">;</span> fd <span class="op">&lt;</span> <span class="dv">1024</span><span class="op">;</span> <span class="op">++</span>fd<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-279"><a href="#cb28-279" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span><span class="va">open_fds_</span><span class="op">[</span>fd<span class="op">])</span> <span class="op">{</span></span>
<span id="cb28-280"><a href="#cb28-280" aria-hidden="true" tabindex="-1"></a>                <span class="va">fd_array_</span><span class="op">[</span>fd<span class="op">]</span> <span class="op">=</span> file<span class="op">;</span></span>
<span id="cb28-281"><a href="#cb28-281" aria-hidden="true" tabindex="-1"></a>                <span class="va">open_fds_</span><span class="op">.</span>set<span class="op">(</span>fd<span class="op">);</span></span>
<span id="cb28-282"><a href="#cb28-282" aria-hidden="true" tabindex="-1"></a>                <span class="va">next_fd_</span> <span class="op">=</span> fd <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-283"><a href="#cb28-283" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> fd<span class="op">;</span></span>
<span id="cb28-284"><a href="#cb28-284" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-285"><a href="#cb28-285" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-286"><a href="#cb28-286" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>unexpected<span class="op">(</span><span class="st">"Too many open files"</span><span class="op">);</span></span>
<span id="cb28-287"><a href="#cb28-287" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-288"><a href="#cb28-288" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-289"><a href="#cb28-289" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-290"><a href="#cb28-290" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Fecha file descriptor</span></span>
<span id="cb28-291"><a href="#cb28-291" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">fd</span><span class="co"> File descriptor a fechar</span></span>
<span id="cb28-292"><a href="#cb28-292" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-293"><a href="#cb28-293" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> closeFile<span class="op">(</span><span class="dt">int</span> fd<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-294"><a href="#cb28-294" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>fd <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> fd <span class="op">&lt;</span> <span class="dv">1024</span> <span class="op">&amp;&amp;</span> <span class="va">open_fds_</span><span class="op">[</span>fd<span class="op">])</span> <span class="op">{</span></span>
<span id="cb28-295"><a href="#cb28-295" aria-hidden="true" tabindex="-1"></a>            <span class="va">fd_array_</span><span class="op">[</span>fd<span class="op">].</span>reset<span class="op">();</span></span>
<span id="cb28-296"><a href="#cb28-296" aria-hidden="true" tabindex="-1"></a>            <span class="va">open_fds_</span><span class="op">.</span>reset<span class="op">(</span>fd<span class="op">);</span></span>
<span id="cb28-297"><a href="#cb28-297" aria-hidden="true" tabindex="-1"></a>            <span class="va">close_on_exec_</span><span class="op">.</span>reset<span class="op">(</span>fd<span class="op">);</span></span>
<span id="cb28-298"><a href="#cb28-298" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>fd <span class="op">&lt;</span> <span class="va">next_fd_</span><span class="op">)</span> <span class="va">next_fd_</span> <span class="op">=</span> fd<span class="op">;</span></span>
<span id="cb28-299"><a href="#cb28-299" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb28-300"><a href="#cb28-300" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-301"><a href="#cb28-301" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-302"><a href="#cb28-302" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-303"><a href="#cb28-303" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-304"><a href="#cb28-304" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-305"><a href="#cb28-305" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Define flag close-on-exec</span></span>
<span id="cb28-306"><a href="#cb28-306" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-307"><a href="#cb28-307" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setCloseOnExec<span class="op">(</span><span class="dt">int</span> fd<span class="op">,</span> <span class="dt">bool</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-308"><a href="#cb28-308" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>fd <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> fd <span class="op">&lt;</span> <span class="dv">1024</span> <span class="op">&amp;&amp;</span> <span class="va">open_fds_</span><span class="op">[</span>fd<span class="op">])</span> <span class="op">{</span></span>
<span id="cb28-309"><a href="#cb28-309" aria-hidden="true" tabindex="-1"></a>            <span class="va">close_on_exec_</span><span class="op">.</span>set<span class="op">(</span>fd<span class="op">,</span> value<span class="op">);</span></span>
<span id="cb28-310"><a href="#cb28-310" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-311"><a href="#cb28-311" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-312"><a href="#cb28-312" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-313"><a href="#cb28-313" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-314"><a href="#cb28-314" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém estatísticas da tabela</span></span>
<span id="cb28-315"><a href="#cb28-315" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-316"><a href="#cb28-316" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> getStats<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-317"><a href="#cb28-317" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(</span><span class="va">count_</span><span class="op">.</span>load<span class="op">(),</span> <span class="va">open_fds_</span><span class="op">.</span>count<span class="op">(),</span> </span>
<span id="cb28-318"><a href="#cb28-318" aria-hidden="true" tabindex="-1"></a>                              <span class="va">close_on_exec_</span><span class="op">.</span>count<span class="op">(),</span> <span class="va">next_fd_</span><span class="op">);</span></span>
<span id="cb28-319"><a href="#cb28-319" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-320"><a href="#cb28-320" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-321"><a href="#cb28-321" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-322"><a href="#cb28-322" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Lista arquivos abertos</span></span>
<span id="cb28-323"><a href="#cb28-323" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-324"><a href="#cb28-324" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> OpenFile<span class="op">&gt;&gt;</span> listOpenFiles<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-325"><a href="#cb28-325" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> OpenFile<span class="op">&gt;&gt;</span> files<span class="op">;</span></span>
<span id="cb28-326"><a href="#cb28-326" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> fd <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> fd <span class="op">&lt;</span> <span class="dv">1024</span><span class="op">;</span> <span class="op">++</span>fd<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-327"><a href="#cb28-327" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="va">open_fds_</span><span class="op">[</span>fd<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="va">fd_array_</span><span class="op">[</span>fd<span class="op">])</span> <span class="op">{</span></span>
<span id="cb28-328"><a href="#cb28-328" aria-hidden="true" tabindex="-1"></a>                files<span class="op">.</span>emplace_back<span class="op">(</span>fd<span class="op">,</span> <span class="op">*</span><span class="va">fd_array_</span><span class="op">[</span>fd<span class="op">]);</span></span>
<span id="cb28-329"><a href="#cb28-329" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-330"><a href="#cb28-330" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-331"><a href="#cb28-331" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> files<span class="op">;</span></span>
<span id="cb28-332"><a href="#cb28-332" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-333"><a href="#cb28-333" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-334"><a href="#cb28-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-335"><a href="#cb28-335" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-336"><a href="#cb28-336" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Informações sobre signal handler</span></span>
<span id="cb28-337"><a href="#cb28-337" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-338"><a href="#cb28-338" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SignalAction <span class="op">{</span></span>
<span id="cb28-339"><a href="#cb28-339" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="dt">handler_type</span><span class="op">;</span>    <span class="co">///&lt; Tipo: "default", "ignore", "custom"</span></span>
<span id="cb28-340"><a href="#cb28-340" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> handler_addr<span class="op">;</span>       <span class="co">///&lt; Endereço do handler (se custom)</span></span>
<span id="cb28-341"><a href="#cb28-341" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> sa_flags<span class="op">;</span>          <span class="co">///&lt; Flags do sigaction</span></span>
<span id="cb28-342"><a href="#cb28-342" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-343"><a href="#cb28-343" aria-hidden="true" tabindex="-1"></a>    SignalAction<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> type <span class="op">=</span> <span class="st">"default"</span><span class="op">,</span> <span class="dt">uint64_t</span> addr <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">uint32_t</span> flags <span class="op">=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb28-344"><a href="#cb28-344" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="dt">handler_type</span><span class="op">(</span>type<span class="op">),</span> handler_addr<span class="op">(</span>addr<span class="op">),</span> sa_flags<span class="op">(</span>flags<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-345"><a href="#cb28-345" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-346"><a href="#cb28-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-347"><a href="#cb28-347" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-348"><a href="#cb28-348" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Simulação da signal_struct - gerenciamento de sinais</span></span>
<span id="cb28-349"><a href="#cb28-349" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-350"><a href="#cb28-350" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SignalDescriptor <span class="op">{</span></span>
<span id="cb28-351"><a href="#cb28-351" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb28-352"><a href="#cb28-352" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">count_</span><span class="op">;</span>                     <span class="co">///&lt; Contador de referências</span></span>
<span id="cb28-353"><a href="#cb28-353" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>array<span class="op">&lt;</span>SignalAction<span class="op">,</span> <span class="dv">64</span><span class="op">&gt;</span> <span class="va">sig_handlers_</span><span class="op">;</span> <span class="co">///&lt; Handlers para cada sinal</span></span>
<span id="cb28-354"><a href="#cb28-354" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">64</span><span class="op">&gt;</span> <span class="va">pending_signals_</span><span class="op">;</span>           <span class="co">///&lt; Sinais pendentes para o grupo</span></span>
<span id="cb28-355"><a href="#cb28-355" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">64</span><span class="op">&gt;</span> <span class="va">blocked_signals_</span><span class="op">;</span>           <span class="co">///&lt; Sinais bloqueados</span></span>
<span id="cb28-356"><a href="#cb28-356" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> <span class="va">session_</span><span class="op">;</span>                             <span class="co">///&lt; ID da sessão</span></span>
<span id="cb28-357"><a href="#cb28-357" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> <span class="va">pgrp_</span><span class="op">;</span>                               <span class="co">///&lt; ID do process group</span></span>
<span id="cb28-358"><a href="#cb28-358" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-359"><a href="#cb28-359" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-360"><a href="#cb28-360" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-361"><a href="#cb28-361" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor inicializando handlers padrão</span></span>
<span id="cb28-362"><a href="#cb28-362" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-363"><a href="#cb28-363" aria-hidden="true" tabindex="-1"></a>    SignalDescriptor<span class="op">(</span><span class="dt">pid_t</span> session_id<span class="op">,</span> <span class="dt">pid_t</span> pgrp_id<span class="op">)</span> </span>
<span id="cb28-364"><a href="#cb28-364" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">count_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">session_</span><span class="op">(</span>session_id<span class="op">),</span> <span class="va">pgrp_</span><span class="op">(</span>pgrp_id<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-365"><a href="#cb28-365" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Inicializa handlers padrão</span></span>
<span id="cb28-366"><a href="#cb28-366" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">64</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-367"><a href="#cb28-367" aria-hidden="true" tabindex="-1"></a>            <span class="va">sig_handlers_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> SignalAction<span class="op">(</span><span class="st">"default"</span><span class="op">);</span></span>
<span id="cb28-368"><a href="#cb28-368" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-369"><a href="#cb28-369" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-370"><a href="#cb28-370" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Alguns sinais com comportamento especial</span></span>
<span id="cb28-371"><a href="#cb28-371" aria-hidden="true" tabindex="-1"></a>        <span class="va">sig_handlers_</span><span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> SignalAction<span class="op">(</span><span class="st">"terminate"</span><span class="op">);</span>  <span class="co">// SIGINT</span></span>
<span id="cb28-372"><a href="#cb28-372" aria-hidden="true" tabindex="-1"></a>        <span class="va">sig_handlers_</span><span class="op">[</span><span class="dv">9</span><span class="op">]</span> <span class="op">=</span> SignalAction<span class="op">(</span><span class="st">"kill"</span><span class="op">);</span>       <span class="co">// SIGKILL</span></span>
<span id="cb28-373"><a href="#cb28-373" aria-hidden="true" tabindex="-1"></a>        <span class="va">sig_handlers_</span><span class="op">[</span><span class="dv">15</span><span class="op">]</span> <span class="op">=</span> SignalAction<span class="op">(</span><span class="st">"terminate"</span><span class="op">);</span> <span class="co">// SIGTERM</span></span>
<span id="cb28-374"><a href="#cb28-374" aria-hidden="true" tabindex="-1"></a>        <span class="va">sig_handlers_</span><span class="op">[</span><span class="dv">17</span><span class="op">]</span> <span class="op">=</span> SignalAction<span class="op">(</span><span class="st">"stop"</span><span class="op">);</span>      <span class="co">// SIGSTOP</span></span>
<span id="cb28-375"><a href="#cb28-375" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-376"><a href="#cb28-376" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-377"><a href="#cb28-377" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-378"><a href="#cb28-378" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor de cópia para fork()</span></span>
<span id="cb28-379"><a href="#cb28-379" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-380"><a href="#cb28-380" aria-hidden="true" tabindex="-1"></a>    SignalDescriptor<span class="op">(</span><span class="at">const</span> SignalDescriptor<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb28-381"><a href="#cb28-381" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">count_</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="va">sig_handlers_</span><span class="op">(</span>other<span class="op">.</span><span class="va">sig_handlers_</span><span class="op">),</span> </span>
<span id="cb28-382"><a href="#cb28-382" aria-hidden="true" tabindex="-1"></a>          <span class="va">blocked_signals_</span><span class="op">(</span>other<span class="op">.</span><span class="va">blocked_signals_</span><span class="op">),</span></span>
<span id="cb28-383"><a href="#cb28-383" aria-hidden="true" tabindex="-1"></a>          <span class="va">session_</span><span class="op">(</span>other<span class="op">.</span><span class="va">session_</span><span class="op">),</span> <span class="va">pgrp_</span><span class="op">(</span>other<span class="op">.</span><span class="va">pgrp_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-384"><a href="#cb28-384" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sinais pendentes não são herdados</span></span>
<span id="cb28-385"><a href="#cb28-385" aria-hidden="true" tabindex="-1"></a>        <span class="va">pending_signals_</span><span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb28-386"><a href="#cb28-386" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-387"><a href="#cb28-387" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-388"><a href="#cb28-388" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-389"><a href="#cb28-389" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Compartilha handlers (CLONE_SIGHAND)</span></span>
<span id="cb28-390"><a href="#cb28-390" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-391"><a href="#cb28-391" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> share<span class="op">()</span> <span class="op">{</span> <span class="va">count_</span><span class="op">++;</span> <span class="op">}</span></span>
<span id="cb28-392"><a href="#cb28-392" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-393"><a href="#cb28-393" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-394"><a href="#cb28-394" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Remove referência</span></span>
<span id="cb28-395"><a href="#cb28-395" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-396"><a href="#cb28-396" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> release<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">--</span><span class="va">count_</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-397"><a href="#cb28-397" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-398"><a href="#cb28-398" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-399"><a href="#cb28-399" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Registra handler para sinal</span></span>
<span id="cb28-400"><a href="#cb28-400" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">signum</span><span class="co"> Número do sinal</span></span>
<span id="cb28-401"><a href="#cb28-401" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">action</span><span class="co"> Nova ação</span></span>
<span id="cb28-402"><a href="#cb28-402" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-403"><a href="#cb28-403" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setSignalAction<span class="op">(</span><span class="dt">int</span> signum<span class="op">,</span> <span class="at">const</span> SignalAction<span class="op">&amp;</span> action<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-404"><a href="#cb28-404" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>signum <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> signum <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">&amp;&amp;</span> signum <span class="op">!=</span> <span class="dv">9</span> <span class="op">&amp;&amp;</span> signum <span class="op">!=</span> <span class="dv">19</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-405"><a href="#cb28-405" aria-hidden="true" tabindex="-1"></a>            <span class="co">// SIGKILL e SIGSTOP não podem ser alterados</span></span>
<span id="cb28-406"><a href="#cb28-406" aria-hidden="true" tabindex="-1"></a>            <span class="va">sig_handlers_</span><span class="op">[</span>signum<span class="op">]</span> <span class="op">=</span> action<span class="op">;</span></span>
<span id="cb28-407"><a href="#cb28-407" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-408"><a href="#cb28-408" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-409"><a href="#cb28-409" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-410"><a href="#cb28-410" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-411"><a href="#cb28-411" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Envia sinal para o process group</span></span>
<span id="cb28-412"><a href="#cb28-412" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">signum</span><span class="co"> Número do sinal</span></span>
<span id="cb28-413"><a href="#cb28-413" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-414"><a href="#cb28-414" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> sendSignal<span class="op">(</span><span class="dt">int</span> signum<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-415"><a href="#cb28-415" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>signum <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> signum <span class="op">&lt;</span> <span class="dv">64</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-416"><a href="#cb28-416" aria-hidden="true" tabindex="-1"></a>            <span class="va">pending_signals_</span><span class="op">.</span>set<span class="op">(</span>signum<span class="op">);</span></span>
<span id="cb28-417"><a href="#cb28-417" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-418"><a href="#cb28-418" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-419"><a href="#cb28-419" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-420"><a href="#cb28-420" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-421"><a href="#cb28-421" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Bloqueia sinal</span></span>
<span id="cb28-422"><a href="#cb28-422" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-423"><a href="#cb28-423" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> blockSignal<span class="op">(</span><span class="dt">int</span> signum<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-424"><a href="#cb28-424" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>signum <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> signum <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">&amp;&amp;</span> signum <span class="op">!=</span> <span class="dv">9</span> <span class="op">&amp;&amp;</span> signum <span class="op">!=</span> <span class="dv">19</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-425"><a href="#cb28-425" aria-hidden="true" tabindex="-1"></a>            <span class="va">blocked_signals_</span><span class="op">.</span>set<span class="op">(</span>signum<span class="op">);</span></span>
<span id="cb28-426"><a href="#cb28-426" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-427"><a href="#cb28-427" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-428"><a href="#cb28-428" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-429"><a href="#cb28-429" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-430"><a href="#cb28-430" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém estatísticas de sinais</span></span>
<span id="cb28-431"><a href="#cb28-431" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-432"><a href="#cb28-432" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> getSignalStats<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-433"><a href="#cb28-433" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(</span><span class="va">count_</span><span class="op">.</span>load<span class="op">(),</span> <span class="va">pending_signals_</span><span class="op">.</span>count<span class="op">(),</span> </span>
<span id="cb28-434"><a href="#cb28-434" aria-hidden="true" tabindex="-1"></a>                              <span class="va">blocked_signals_</span><span class="op">.</span>count<span class="op">(),</span> <span class="va">session_</span><span class="op">,</span> <span class="va">pgrp_</span><span class="op">);</span></span>
<span id="cb28-435"><a href="#cb28-435" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-436"><a href="#cb28-436" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-437"><a href="#cb28-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-438"><a href="#cb28-438" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-439"><a href="#cb28-439" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Credenciais de segurança do processo</span></span>
<span id="cb28-440"><a href="#cb28-440" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-441"><a href="#cb28-441" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Credentials <span class="op">{</span></span>
<span id="cb28-442"><a href="#cb28-442" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uid_t</span> real_uid<span class="op">;</span>        <span class="co">///&lt; Real user ID</span></span>
<span id="cb28-443"><a href="#cb28-443" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uid_t</span> effective_uid<span class="op">;</span>   <span class="co">///&lt; Effective user ID</span></span>
<span id="cb28-444"><a href="#cb28-444" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uid_t</span> saved_uid<span class="op">;</span>       <span class="co">///&lt; Saved user ID</span></span>
<span id="cb28-445"><a href="#cb28-445" aria-hidden="true" tabindex="-1"></a>    <span class="dt">gid_t</span> real_gid<span class="op">;</span>        <span class="co">///&lt; Real group ID</span></span>
<span id="cb28-446"><a href="#cb28-446" aria-hidden="true" tabindex="-1"></a>    <span class="dt">gid_t</span> effective_gid<span class="op">;</span>   <span class="co">///&lt; Effective group ID</span></span>
<span id="cb28-447"><a href="#cb28-447" aria-hidden="true" tabindex="-1"></a>    <span class="dt">gid_t</span> saved_gid<span class="op">;</span>       <span class="co">///&lt; Saved group ID</span></span>
<span id="cb28-448"><a href="#cb28-448" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">gid_t</span><span class="op">&gt;</span> supplementary_groups<span class="op">;</span> <span class="co">///&lt; Grupos suplementares</span></span>
<span id="cb28-449"><a href="#cb28-449" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-450"><a href="#cb28-450" aria-hidden="true" tabindex="-1"></a>    Credentials<span class="op">(</span><span class="dt">uid_t</span> uid <span class="op">=</span> <span class="dv">1000</span><span class="op">,</span> <span class="dt">gid_t</span> gid <span class="op">=</span> <span class="dv">1000</span><span class="op">)</span> </span>
<span id="cb28-451"><a href="#cb28-451" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> real_uid<span class="op">(</span>uid<span class="op">),</span> effective_uid<span class="op">(</span>uid<span class="op">),</span> saved_uid<span class="op">(</span>uid<span class="op">),</span></span>
<span id="cb28-452"><a href="#cb28-452" aria-hidden="true" tabindex="-1"></a>          real_gid<span class="op">(</span>gid<span class="op">),</span> effective_gid<span class="op">(</span>gid<span class="op">),</span> saved_gid<span class="op">(</span>gid<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-453"><a href="#cb28-453" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-454"><a href="#cb28-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-455"><a href="#cb28-455" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-456"><a href="#cb28-456" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Simulação completa da task_struct</span></span>
<span id="cb28-457"><a href="#cb28-457" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-458"><a href="#cb28-458" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TaskStruct <span class="op">{</span></span>
<span id="cb28-459"><a href="#cb28-459" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb28-460"><a href="#cb28-460" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> <span class="va">next_pid_</span><span class="op">;</span>     <span class="co">///&lt; Gerador global de PIDs</span></span>
<span id="cb28-461"><a href="#cb28-461" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-462"><a href="#cb28-462" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-463"><a href="#cb28-463" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Identificadores únicos</span></span>
<span id="cb28-464"><a href="#cb28-464" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> pid<span class="op">;</span>                               <span class="co">///&lt; Process ID único</span></span>
<span id="cb28-465"><a href="#cb28-465" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> tgid<span class="op">;</span>                             <span class="co">///&lt; Thread Group ID</span></span>
<span id="cb28-466"><a href="#cb28-466" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> ppid<span class="op">;</span>                             <span class="co">///&lt; Parent Process ID</span></span>
<span id="cb28-467"><a href="#cb28-467" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> sid<span class="op">;</span>                              <span class="co">///&lt; Session ID</span></span>
<span id="cb28-468"><a href="#cb28-468" aria-hidden="true" tabindex="-1"></a>    <span class="dt">pid_t</span> pgid<span class="op">;</span>                             <span class="co">///&lt; Process Group ID</span></span>
<span id="cb28-469"><a href="#cb28-469" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-470"><a href="#cb28-470" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Estado e flags</span></span>
<span id="cb28-471"><a href="#cb28-471" aria-hidden="true" tabindex="-1"></a>    TaskState state<span class="op">;</span>                         <span class="co">///&lt; Estado atual da task</span></span>
<span id="cb28-472"><a href="#cb28-472" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> flags<span class="op">;</span>                         <span class="co">///&lt; Flags da task (PF_*)</span></span>
<span id="cb28-473"><a href="#cb28-473" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-474"><a href="#cb28-474" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ponteiros para estruturas auxiliares</span></span>
<span id="cb28-475"><a href="#cb28-475" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MemoryDescriptor<span class="op">&gt;</span> mm<span class="op">;</span>    <span class="co">///&lt; Descritor de memória</span></span>
<span id="cb28-476"><a href="#cb28-476" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>FileDescriptorTable<span class="op">&gt;</span> files<span class="op">;</span> <span class="co">///&lt; Tabela de FDs</span></span>
<span id="cb28-477"><a href="#cb28-477" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>SignalDescriptor<span class="op">&gt;</span> signal<span class="op">;</span>   <span class="co">///&lt; Gerenciamento de sinais</span></span>
<span id="cb28-478"><a href="#cb28-478" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-479"><a href="#cb28-479" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Credenciais de segurança</span></span>
<span id="cb28-480"><a href="#cb28-480" aria-hidden="true" tabindex="-1"></a>    Credentials cred<span class="op">;</span>                        <span class="co">///&lt; Credenciais da task</span></span>
<span id="cb28-481"><a href="#cb28-481" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-482"><a href="#cb28-482" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Hierarquia de processos</span></span>
<span id="cb28-483"><a href="#cb28-483" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;&gt;</span> children<span class="op">;</span> <span class="co">///&lt; Processos filhos</span></span>
<span id="cb28-484"><a href="#cb28-484" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>weak_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;</span> parent<span class="op">;</span>        <span class="co">///&lt; Processo pai</span></span>
<span id="cb28-485"><a href="#cb28-485" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>weak_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;</span> group_leader<span class="op">;</span>  <span class="co">///&lt; Líder do thread group</span></span>
<span id="cb28-486"><a href="#cb28-486" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-487"><a href="#cb28-487" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Informações de tempo</span></span>
<span id="cb28-488"><a href="#cb28-488" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>chrono::system_clock::time_point start_time<span class="op">;</span> <span class="co">///&lt; Tempo de criação</span></span>
<span id="cb28-489"><a href="#cb28-489" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-490"><a href="#cb28-490" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Nome do processo</span></span>
<span id="cb28-491"><a href="#cb28-491" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string comm<span class="op">;</span>                        <span class="co">///&lt; Nome do comando (16 chars max)</span></span>
<span id="cb28-492"><a href="#cb28-492" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-493"><a href="#cb28-493" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-494"><a href="#cb28-494" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor principal para criar nova task</span></span>
<span id="cb28-495"><a href="#cb28-495" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">is_thread</span><span class="co"> Se é thread ou processo</span></span>
<span id="cb28-496"><a href="#cb28-496" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">parent_task</span><span class="co"> Processo pai</span></span>
<span id="cb28-497"><a href="#cb28-497" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">command</span><span class="co"> Nome do comando</span></span>
<span id="cb28-498"><a href="#cb28-498" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-499"><a href="#cb28-499" aria-hidden="true" tabindex="-1"></a>    TaskStruct<span class="op">(</span><span class="dt">bool</span> is_thread <span class="op">=</span> <span class="kw">false</span><span class="op">,</span> </span>
<span id="cb28-500"><a href="#cb28-500" aria-hidden="true" tabindex="-1"></a>               <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;</span> parent_task <span class="op">=</span> <span class="kw">nullptr</span><span class="op">,</span></span>
<span id="cb28-501"><a href="#cb28-501" aria-hidden="true" tabindex="-1"></a>               <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> command <span class="op">=</span> <span class="st">"unknown"</span><span class="op">)</span> </span>
<span id="cb28-502"><a href="#cb28-502" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> pid<span class="op">(</span><span class="va">next_pid_</span><span class="op">++),</span> state<span class="op">(</span>TaskState<span class="op">::</span>TASK_RUNNING<span class="op">),</span> flags<span class="op">(</span><span class="dv">0</span><span class="op">),</span></span>
<span id="cb28-503"><a href="#cb28-503" aria-hidden="true" tabindex="-1"></a>          cred<span class="op">(),</span> start_time<span class="op">(</span><span class="bu">std::</span>chrono::system_clock::now<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-504"><a href="#cb28-504" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-505"><a href="#cb28-505" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Trunca nome do comando para 15 caracteres (como no kernel)</span></span>
<span id="cb28-506"><a href="#cb28-506" aria-hidden="true" tabindex="-1"></a>        comm <span class="op">=</span> command<span class="op">.</span>substr<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">15</span><span class="op">);</span></span>
<span id="cb28-507"><a href="#cb28-507" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-508"><a href="#cb28-508" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>parent_task<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-509"><a href="#cb28-509" aria-hidden="true" tabindex="-1"></a>            ppid <span class="op">=</span> parent_task<span class="op">-&gt;</span>pid<span class="op">;</span></span>
<span id="cb28-510"><a href="#cb28-510" aria-hidden="true" tabindex="-1"></a>            sid <span class="op">=</span> parent_task<span class="op">-&gt;</span>sid<span class="op">;</span></span>
<span id="cb28-511"><a href="#cb28-511" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-512"><a href="#cb28-512" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>is_thread<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-513"><a href="#cb28-513" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Thread: compartilha TGID e PGID</span></span>
<span id="cb28-514"><a href="#cb28-514" aria-hidden="true" tabindex="-1"></a>                tgid <span class="op">=</span> parent_task<span class="op">-&gt;</span>tgid<span class="op">;</span></span>
<span id="cb28-515"><a href="#cb28-515" aria-hidden="true" tabindex="-1"></a>                pgid <span class="op">=</span> parent_task<span class="op">-&gt;</span>pgid<span class="op">;</span></span>
<span id="cb28-516"><a href="#cb28-516" aria-hidden="true" tabindex="-1"></a>                group_leader <span class="op">=</span> parent_task<span class="op">-&gt;</span>group_leader<span class="op">.</span>lock<span class="op">()</span> <span class="op">?</span> </span>
<span id="cb28-517"><a href="#cb28-517" aria-hidden="true" tabindex="-1"></a>                              parent_task<span class="op">-&gt;</span>group_leader <span class="op">:</span> parent_task<span class="op">;</span></span>
<span id="cb28-518"><a href="#cb28-518" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-519"><a href="#cb28-519" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Processo: novo TGID e PGID</span></span>
<span id="cb28-520"><a href="#cb28-520" aria-hidden="true" tabindex="-1"></a>                tgid <span class="op">=</span> pid<span class="op">;</span></span>
<span id="cb28-521"><a href="#cb28-521" aria-hidden="true" tabindex="-1"></a>                pgid <span class="op">=</span> pid<span class="op">;</span></span>
<span id="cb28-522"><a href="#cb28-522" aria-hidden="true" tabindex="-1"></a>                group_leader <span class="op">=</span> <span class="bu">std::</span>weak_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;();</span> <span class="co">// Será self</span></span>
<span id="cb28-523"><a href="#cb28-523" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-524"><a href="#cb28-524" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-525"><a href="#cb28-525" aria-hidden="true" tabindex="-1"></a>            parent <span class="op">=</span> parent_task<span class="op">;</span></span>
<span id="cb28-526"><a href="#cb28-526" aria-hidden="true" tabindex="-1"></a>            parent_task<span class="op">-&gt;</span>children<span class="op">.</span>push_back<span class="op">(</span>shared_from_this<span class="op">());</span></span>
<span id="cb28-527"><a href="#cb28-527" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-528"><a href="#cb28-528" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Herda credenciais do pai</span></span>
<span id="cb28-529"><a href="#cb28-529" aria-hidden="true" tabindex="-1"></a>            cred <span class="op">=</span> parent_task<span class="op">-&gt;</span>cred<span class="op">;</span></span>
<span id="cb28-530"><a href="#cb28-530" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-531"><a href="#cb28-531" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Processo init ou `kernel` threads</span></span>
<span id="cb28-532"><a href="#cb28-532" aria-hidden="true" tabindex="-1"></a>            ppid <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-533"><a href="#cb28-533" aria-hidden="true" tabindex="-1"></a>            tgid <span class="op">=</span> pid<span class="op">;</span></span>
<span id="cb28-534"><a href="#cb28-534" aria-hidden="true" tabindex="-1"></a>            sid <span class="op">=</span> pid<span class="op">;</span></span>
<span id="cb28-535"><a href="#cb28-535" aria-hidden="true" tabindex="-1"></a>            pgid <span class="op">=</span> pid<span class="op">;</span></span>
<span id="cb28-536"><a href="#cb28-536" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-537"><a href="#cb28-537" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-538"><a href="#cb28-538" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Inicializa estruturas auxiliares</span></span>
<span id="cb28-539"><a href="#cb28-539" aria-hidden="true" tabindex="-1"></a>        mm <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MemoryDescriptor<span class="op">&gt;();</span></span>
<span id="cb28-540"><a href="#cb28-540" aria-hidden="true" tabindex="-1"></a>        files <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>FileDescriptorTable<span class="op">&gt;();</span></span>
<span id="cb28-541"><a href="#cb28-541" aria-hidden="true" tabindex="-1"></a>        signal <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>SignalDescriptor<span class="op">&gt;(</span>sid<span class="op">,</span> pgid<span class="op">);</span></span>
<span id="cb28-542"><a href="#cb28-542" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-543"><a href="#cb28-543" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-544"><a href="#cb28-544" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-545"><a href="#cb28-545" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém estatísticas completas da task</span></span>
<span id="cb28-546"><a href="#cb28-546" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-547"><a href="#cb28-547" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> getTaskStatistics<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-548"><a href="#cb28-548" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">[</span>mm_users<span class="op">,</span> mm_count<span class="op">,</span> vma_count<span class="op">,</span> mem_size<span class="op">]</span> <span class="op">=</span> mm<span class="op">-&gt;</span>getMemoryStats<span class="op">();</span></span>
<span id="cb28-549"><a href="#cb28-549" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">[</span>files_count<span class="op">,</span> open_files<span class="op">,</span> cloexec_files<span class="op">,</span> next_fd<span class="op">]</span> <span class="op">=</span> files<span class="op">-&gt;</span>getStats<span class="op">();</span></span>
<span id="cb28-550"><a href="#cb28-550" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">[</span>sig_count<span class="op">,</span> pending_sigs<span class="op">,</span> blocked_sigs<span class="op">,</span> session<span class="op">,</span> pgroup<span class="op">]</span> <span class="op">=</span> signal<span class="op">-&gt;</span>getSignalStats<span class="op">();</span></span>
<span id="cb28-551"><a href="#cb28-551" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-552"><a href="#cb28-552" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(</span></span>
<span id="cb28-553"><a href="#cb28-553" aria-hidden="true" tabindex="-1"></a>            pid<span class="op">,</span> tgid<span class="op">,</span> ppid<span class="op">,</span> sid<span class="op">,</span> pgid<span class="op">,</span>                    <span class="co">// IDs</span></span>
<span id="cb28-554"><a href="#cb28-554" aria-hidden="true" tabindex="-1"></a>            <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>state<span class="op">),</span> children<span class="op">.</span>size<span class="op">(),</span>      <span class="co">// Estado e filhos</span></span>
<span id="cb28-555"><a href="#cb28-555" aria-hidden="true" tabindex="-1"></a>            mm_users<span class="op">,</span> mm_count<span class="op">,</span> vma_count<span class="op">,</span> mem_size<span class="op">,</span>       <span class="co">// Memória</span></span>
<span id="cb28-556"><a href="#cb28-556" aria-hidden="true" tabindex="-1"></a>            files_count<span class="op">,</span> open_files<span class="op">,</span> cloexec_files<span class="op">,</span>        <span class="co">// Arquivos</span></span>
<span id="cb28-557"><a href="#cb28-557" aria-hidden="true" tabindex="-1"></a>            sig_count<span class="op">,</span> pending_sigs<span class="op">,</span> blocked_sigs          <span class="co">// Sinais</span></span>
<span id="cb28-558"><a href="#cb28-558" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="cb28-559"><a href="#cb28-559" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-560"><a href="#cb28-560" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-561"><a href="#cb28-561" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-562"><a href="#cb28-562" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém informações hierárquicas</span></span>
<span id="cb28-563"><a href="#cb28-563" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-564"><a href="#cb28-564" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> getChildrenPIDs<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-565"><a href="#cb28-565" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> pids<span class="op">;</span></span>
<span id="cb28-566"><a href="#cb28-566" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> child <span class="op">:</span> children<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-567"><a href="#cb28-567" aria-hidden="true" tabindex="-1"></a>            pids<span class="op">.</span>push_back<span class="op">(</span>child<span class="op">-&gt;</span>pid<span class="op">);</span></span>
<span id="cb28-568"><a href="#cb28-568" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-569"><a href="#cb28-569" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pids<span class="op">;</span></span>
<span id="cb28-570"><a href="#cb28-570" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-571"><a href="#cb28-571" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-572"><a href="#cb28-572" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-573"><a href="#cb28-573" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Verifica se é thread (TGID != PID)</span></span>
<span id="cb28-574"><a href="#cb28-574" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-575"><a href="#cb28-575" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isThread<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> tgid <span class="op">!=</span> pid<span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-576"><a href="#cb28-576" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-577"><a href="#cb28-577" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-578"><a href="#cb28-578" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Verifica se é leader do grupo</span></span>
<span id="cb28-579"><a href="#cb28-579" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-580"><a href="#cb28-580" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isGroupLeader<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> tgid <span class="op">==</span> pid<span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-581"><a href="#cb28-581" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-582"><a href="#cb28-582" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-583"><a href="#cb28-583" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Verifica se é leader de sessão</span></span>
<span id="cb28-584"><a href="#cb28-584" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-585"><a href="#cb28-585" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isSessionLeader<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> sid <span class="op">==</span> pid<span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-586"><a href="#cb28-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-587"><a href="#cb28-587" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-588"><a href="#cb28-588" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Para permitir shared_from_this</span></span>
<span id="cb28-589"><a href="#cb28-589" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-590"><a href="#cb28-590" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> enableSharedFromThis<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;</span> self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-591"><a href="#cb28-591" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Técnica para permitir shared_from_this em construtores</span></span>
<span id="cb28-592"><a href="#cb28-592" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>group_leader<span class="op">.</span>lock<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-593"><a href="#cb28-593" aria-hidden="true" tabindex="-1"></a>            group_leader <span class="op">=</span> self<span class="op">;</span> <span class="co">// Self é group leader</span></span>
<span id="cb28-594"><a href="#cb28-594" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-595"><a href="#cb28-595" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-596"><a href="#cb28-596" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-597"><a href="#cb28-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-598"><a href="#cb28-598" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> TaskStruct<span class="op">::</span><span class="va">next_pid_</span><span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb28-599"><a href="#cb28-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-600"><a href="#cb28-600" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-601"><a href="#cb28-601" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Simulador da arquitetura PCB do `kernel` Linux</span></span>
<span id="cb28-602"><a href="#cb28-602" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-603"><a href="#cb28-603" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PCBArchitectureSimulator <span class="op">{</span></span>
<span id="cb28-604"><a href="#cb28-604" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb28-605"><a href="#cb28-605" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;&gt;</span> <span class="va">task_table_</span><span class="op">;</span> <span class="co">///&lt; Tabela de processos</span></span>
<span id="cb28-606"><a href="#cb28-606" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">,</span> <span class="bu">std::</span>set<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;&gt;</span> <span class="va">process_groups_</span><span class="op">;</span>        <span class="co">///&lt; Mapeamento PGID -&gt; PIDs</span></span>
<span id="cb28-607"><a href="#cb28-607" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">,</span> <span class="bu">std::</span>set<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;&gt;</span> <span class="va">sessions_</span><span class="op">;</span>              <span class="co">///&lt; Mapeamento SID -&gt; PIDs</span></span>
<span id="cb28-608"><a href="#cb28-608" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-609"><a href="#cb28-609" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-610"><a href="#cb28-610" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-611"><a href="#cb28-611" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor inicializando processo init</span></span>
<span id="cb28-612"><a href="#cb28-612" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-613"><a href="#cb28-613" aria-hidden="true" tabindex="-1"></a>    PCBArchitectureSimulator<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-614"><a href="#cb28-614" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Cria processo init (PID 1)</span></span>
<span id="cb28-615"><a href="#cb28-615" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> init_task <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>TaskStruct<span class="op">&gt;(</span><span class="kw">false</span><span class="op">,</span> <span class="kw">nullptr</span><span class="op">,</span> <span class="st">"init"</span><span class="op">);</span></span>
<span id="cb28-616"><a href="#cb28-616" aria-hidden="true" tabindex="-1"></a>        init_task<span class="op">-&gt;</span>enableSharedFromThis<span class="op">(</span>init_task<span class="op">);</span></span>
<span id="cb28-617"><a href="#cb28-617" aria-hidden="true" tabindex="-1"></a>        <span class="va">task_table_</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> init_task<span class="op">;</span></span>
<span id="cb28-618"><a href="#cb28-618" aria-hidden="true" tabindex="-1"></a>        <span class="va">process_groups_</span><span class="op">[</span><span class="dv">1</span><span class="op">].</span>insert<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb28-619"><a href="#cb28-619" aria-hidden="true" tabindex="-1"></a>        <span class="va">sessions_</span><span class="op">[</span><span class="dv">1</span><span class="op">].</span>insert<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb28-620"><a href="#cb28-620" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-621"><a href="#cb28-621" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Simulador inicializado com processo init (PID 1)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-622"><a href="#cb28-622" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-623"><a href="#cb28-623" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-624"><a href="#cb28-624" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-625"><a href="#cb28-625" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula fork() - cria novo processo</span></span>
<span id="cb28-626"><a href="#cb28-626" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">parent_pid</span><span class="co"> PID do processo pai</span></span>
<span id="cb28-627"><a href="#cb28-627" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">command</span><span class="co"> Nome do comando para o novo processo</span></span>
<span id="cb28-628"><a href="#cb28-628" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> PID do processo criado ou erro</span></span>
<span id="cb28-629"><a href="#cb28-629" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-630"><a href="#cb28-630" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>expected<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> fork<span class="op">(</span><span class="dt">pid_t</span> parent_pid<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> command <span class="op">=</span> <span class="st">"child"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-631"><a href="#cb28-631" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> parent_it <span class="op">=</span> <span class="va">task_table_</span><span class="op">.</span>find<span class="op">(</span>parent_pid<span class="op">);</span></span>
<span id="cb28-632"><a href="#cb28-632" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>parent_it <span class="op">==</span> <span class="va">task_table_</span><span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-633"><a href="#cb28-633" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>unexpected<span class="op">(</span><span class="st">"Parent process not found"</span><span class="op">);</span></span>
<span id="cb28-634"><a href="#cb28-634" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-635"><a href="#cb28-635" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-636"><a href="#cb28-636" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> parent <span class="op">=</span> parent_it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="cb28-637"><a href="#cb28-637" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> child <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>TaskStruct<span class="op">&gt;(</span><span class="kw">false</span><span class="op">,</span> parent<span class="op">,</span> command<span class="op">);</span></span>
<span id="cb28-638"><a href="#cb28-638" aria-hidden="true" tabindex="-1"></a>        child<span class="op">-&gt;</span>enableSharedFromThis<span class="op">(</span>child<span class="op">);</span></span>
<span id="cb28-639"><a href="#cb28-639" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-640"><a href="#cb28-640" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fork cria cópias independentes das estruturas</span></span>
<span id="cb28-641"><a href="#cb28-641" aria-hidden="true" tabindex="-1"></a>        child<span class="op">-&gt;</span>mm <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MemoryDescriptor<span class="op">&gt;(*</span>parent<span class="op">-&gt;</span>mm<span class="op">);</span></span>
<span id="cb28-642"><a href="#cb28-642" aria-hidden="true" tabindex="-1"></a>        child<span class="op">-&gt;</span>files <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>FileDescriptorTable<span class="op">&gt;(*</span>parent<span class="op">-&gt;</span>files<span class="op">);</span></span>
<span id="cb28-643"><a href="#cb28-643" aria-hidden="true" tabindex="-1"></a>        child<span class="op">-&gt;</span>signal <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>SignalDescriptor<span class="op">&gt;(*</span>parent<span class="op">-&gt;</span>signal<span class="op">);</span></span>
<span id="cb28-644"><a href="#cb28-644" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-645"><a href="#cb28-645" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Registra nas tabelas do sistema</span></span>
<span id="cb28-646"><a href="#cb28-646" aria-hidden="true" tabindex="-1"></a>        <span class="va">task_table_</span><span class="op">[</span>child<span class="op">-&gt;</span>pid<span class="op">]</span> <span class="op">=</span> child<span class="op">;</span></span>
<span id="cb28-647"><a href="#cb28-647" aria-hidden="true" tabindex="-1"></a>        <span class="va">process_groups_</span><span class="op">[</span>child<span class="op">-&gt;</span>pgid<span class="op">].</span>insert<span class="op">(</span>child<span class="op">-&gt;</span>pid<span class="op">);</span></span>
<span id="cb28-648"><a href="#cb28-648" aria-hidden="true" tabindex="-1"></a>        <span class="va">sessions_</span><span class="op">[</span>child<span class="op">-&gt;</span>sid<span class="op">].</span>insert<span class="op">(</span>child<span class="op">-&gt;</span>pid<span class="op">);</span></span>
<span id="cb28-649"><a href="#cb28-649" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-650"><a href="#cb28-650" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> child<span class="op">-&gt;</span>pid<span class="op">;</span></span>
<span id="cb28-651"><a href="#cb28-651" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-652"><a href="#cb28-652" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-653"><a href="#cb28-653" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-654"><a href="#cb28-654" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula clone() com flags específicas</span></span>
<span id="cb28-655"><a href="#cb28-655" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">parent_pid</span><span class="co"> PID do processo pai</span></span>
<span id="cb28-656"><a href="#cb28-656" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">flags</span><span class="co"> Flags de clone determinando compartilhamento</span></span>
<span id="cb28-657"><a href="#cb28-657" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">command</span><span class="co"> Nome do comando</span></span>
<span id="cb28-658"><a href="#cb28-658" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> PID da nova task ou erro</span></span>
<span id="cb28-659"><a href="#cb28-659" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-660"><a href="#cb28-660" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>expected<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> clone<span class="op">(</span><span class="dt">pid_t</span> parent_pid<span class="op">,</span> <span class="dt">uint32_t</span> flags<span class="op">,</span> </span>
<span id="cb28-661"><a href="#cb28-661" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> command <span class="op">=</span> <span class="st">"thread"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-662"><a href="#cb28-662" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> parent_it <span class="op">=</span> <span class="va">task_table_</span><span class="op">.</span>find<span class="op">(</span>parent_pid<span class="op">);</span></span>
<span id="cb28-663"><a href="#cb28-663" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>parent_it <span class="op">==</span> <span class="va">task_table_</span><span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-664"><a href="#cb28-664" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>unexpected<span class="op">(</span><span class="st">"Parent process not found"</span><span class="op">);</span></span>
<span id="cb28-665"><a href="#cb28-665" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-666"><a href="#cb28-666" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-667"><a href="#cb28-667" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> parent <span class="op">=</span> parent_it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="cb28-668"><a href="#cb28-668" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> is_thread <span class="op">=</span> flags <span class="op">&amp;</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_THREAD<span class="op">);</span></span>
<span id="cb28-669"><a href="#cb28-669" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> child <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>TaskStruct<span class="op">&gt;(</span>is_thread<span class="op">,</span> parent<span class="op">,</span> command<span class="op">);</span></span>
<span id="cb28-670"><a href="#cb28-670" aria-hidden="true" tabindex="-1"></a>        child<span class="op">-&gt;</span>enableSharedFromThis<span class="op">(</span>child<span class="op">);</span></span>
<span id="cb28-671"><a href="#cb28-671" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-672"><a href="#cb28-672" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Compartilhamento baseado em flags</span></span>
<span id="cb28-673"><a href="#cb28-673" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>flags <span class="op">&amp;</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_VM<span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-674"><a href="#cb28-674" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>mm <span class="op">=</span> parent<span class="op">-&gt;</span>mm<span class="op">;</span></span>
<span id="cb28-675"><a href="#cb28-675" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>mm<span class="op">-&gt;</span>addUser<span class="op">();</span></span>
<span id="cb28-676"><a href="#cb28-676" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-677"><a href="#cb28-677" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>mm <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MemoryDescriptor<span class="op">&gt;(*</span>parent<span class="op">-&gt;</span>mm<span class="op">);</span></span>
<span id="cb28-678"><a href="#cb28-678" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-679"><a href="#cb28-679" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-680"><a href="#cb28-680" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>flags <span class="op">&amp;</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_FILES<span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-681"><a href="#cb28-681" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>files <span class="op">=</span> parent<span class="op">-&gt;</span>files<span class="op">;</span></span>
<span id="cb28-682"><a href="#cb28-682" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>files<span class="op">-&gt;</span>share<span class="op">();</span></span>
<span id="cb28-683"><a href="#cb28-683" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-684"><a href="#cb28-684" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>files <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>FileDescriptorTable<span class="op">&gt;(*</span>parent<span class="op">-&gt;</span>files<span class="op">);</span></span>
<span id="cb28-685"><a href="#cb28-685" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-686"><a href="#cb28-686" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-687"><a href="#cb28-687" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>flags <span class="op">&amp;</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_SIGHAND<span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-688"><a href="#cb28-688" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>signal <span class="op">=</span> parent<span class="op">-&gt;</span>signal<span class="op">;</span></span>
<span id="cb28-689"><a href="#cb28-689" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>signal<span class="op">-&gt;</span>share<span class="op">();</span></span>
<span id="cb28-690"><a href="#cb28-690" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-691"><a href="#cb28-691" aria-hidden="true" tabindex="-1"></a>            child<span class="op">-&gt;</span>signal <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>SignalDescriptor<span class="op">&gt;(*</span>parent<span class="op">-&gt;</span>signal<span class="op">);</span></span>
<span id="cb28-692"><a href="#cb28-692" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-693"><a href="#cb28-693" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-694"><a href="#cb28-694" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Registra nas tabelas do sistema</span></span>
<span id="cb28-695"><a href="#cb28-695" aria-hidden="true" tabindex="-1"></a>        <span class="va">task_table_</span><span class="op">[</span>child<span class="op">-&gt;</span>pid<span class="op">]</span> <span class="op">=</span> child<span class="op">;</span></span>
<span id="cb28-696"><a href="#cb28-696" aria-hidden="true" tabindex="-1"></a>        <span class="va">process_groups_</span><span class="op">[</span>child<span class="op">-&gt;</span>pgid<span class="op">].</span>insert<span class="op">(</span>child<span class="op">-&gt;</span>pid<span class="op">);</span></span>
<span id="cb28-697"><a href="#cb28-697" aria-hidden="true" tabindex="-1"></a>        <span class="va">sessions_</span><span class="op">[</span>child<span class="op">-&gt;</span>sid<span class="op">].</span>insert<span class="op">(</span>child<span class="op">-&gt;</span>pid<span class="op">);</span></span>
<span id="cb28-698"><a href="#cb28-698" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-699"><a href="#cb28-699" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> child<span class="op">-&gt;</span>pid<span class="op">;</span></span>
<span id="cb28-700"><a href="#cb28-700" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-701"><a href="#cb28-701" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-702"><a href="#cb28-702" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-703"><a href="#cb28-703" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula exec() - substitui imagem do processo</span></span>
<span id="cb28-704"><a href="#cb28-704" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">pid</span><span class="co"> PID do processo</span></span>
<span id="cb28-705"><a href="#cb28-705" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">new_command</span><span class="co"> Novo comando</span></span>
<span id="cb28-706"><a href="#cb28-706" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se bem-sucedido</span></span>
<span id="cb28-707"><a href="#cb28-707" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-708"><a href="#cb28-708" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> exec<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> new_command<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-709"><a href="#cb28-709" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> task_it <span class="op">=</span> <span class="va">task_table_</span><span class="op">.</span>find<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-710"><a href="#cb28-710" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task_it <span class="op">==</span> <span class="va">task_table_</span><span class="op">.</span>end<span class="op">())</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-711"><a href="#cb28-711" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-712"><a href="#cb28-712" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> task <span class="op">=</span> task_it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="cb28-713"><a href="#cb28-713" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-714"><a href="#cb28-714" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Exec substitui imagem mas mantém PID e relacionamentos</span></span>
<span id="cb28-715"><a href="#cb28-715" aria-hidden="true" tabindex="-1"></a>        task<span class="op">-&gt;</span>comm <span class="op">=</span> new_command<span class="op">.</span>substr<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">15</span><span class="op">);</span></span>
<span id="cb28-716"><a href="#cb28-716" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-717"><a href="#cb28-717" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fecha arquivos com FD_CLOEXEC</span></span>
<span id="cb28-718"><a href="#cb28-718" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> open_files <span class="op">=</span> task<span class="op">-&gt;</span>files<span class="op">-&gt;</span>listOpenFiles<span class="op">();</span></span>
<span id="cb28-719"><a href="#cb28-719" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>fd<span class="op">,</span> file<span class="op">]</span> <span class="op">:</span> open_files<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-720"><a href="#cb28-720" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>file<span class="op">.</span>close_on_exec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-721"><a href="#cb28-721" aria-hidden="true" tabindex="-1"></a>                task<span class="op">-&gt;</span>files<span class="op">-&gt;</span>closeFile<span class="op">(</span>fd<span class="op">);</span></span>
<span id="cb28-722"><a href="#cb28-722" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-723"><a href="#cb28-723" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-724"><a href="#cb28-724" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-725"><a href="#cb28-725" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Redefine handlers de sinais para default</span></span>
<span id="cb28-726"><a href="#cb28-726" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> sig <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> sig <span class="op">&lt;</span> <span class="dv">64</span><span class="op">;</span> <span class="op">++</span>sig<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-727"><a href="#cb28-727" aria-hidden="true" tabindex="-1"></a>            task<span class="op">-&gt;</span>signal<span class="op">-&gt;</span>setSignalAction<span class="op">(</span>sig<span class="op">,</span> SignalAction<span class="op">(</span><span class="st">"default"</span><span class="op">));</span></span>
<span id="cb28-728"><a href="#cb28-728" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-729"><a href="#cb28-729" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-730"><a href="#cb28-730" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb28-731"><a href="#cb28-731" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-732"><a href="#cb28-732" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-733"><a href="#cb28-733" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-734"><a href="#cb28-734" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula exit() - termina processo</span></span>
<span id="cb28-735"><a href="#cb28-735" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">pid</span><span class="co"> PID do processo</span></span>
<span id="cb28-736"><a href="#cb28-736" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-737"><a href="#cb28-737" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> exit<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-738"><a href="#cb28-738" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> task_it <span class="op">=</span> <span class="va">task_table_</span><span class="op">.</span>find<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-739"><a href="#cb28-739" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task_it <span class="op">==</span> <span class="va">task_table_</span><span class="op">.</span>end<span class="op">())</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb28-740"><a href="#cb28-740" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-741"><a href="#cb28-741" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> task <span class="op">=</span> task_it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="cb28-742"><a href="#cb28-742" aria-hidden="true" tabindex="-1"></a>        task<span class="op">-&gt;</span>state <span class="op">=</span> TaskState<span class="op">::</span>TASK_ZOMBIE<span class="op">;</span></span>
<span id="cb28-743"><a href="#cb28-743" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-744"><a href="#cb28-744" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Libera recursos compartilhados</span></span>
<span id="cb28-745"><a href="#cb28-745" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>mm<span class="op">-&gt;</span>removeUser<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-746"><a href="#cb28-746" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Último usuário do mm_struct - seria liberado</span></span>
<span id="cb28-747"><a href="#cb28-747" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-748"><a href="#cb28-748" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-749"><a href="#cb28-749" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>files<span class="op">-&gt;</span>release<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-750"><a href="#cb28-750" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Última referência aos file descriptors - seria liberado</span></span>
<span id="cb28-751"><a href="#cb28-751" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-752"><a href="#cb28-752" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-753"><a href="#cb28-753" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>signal<span class="op">-&gt;</span>release<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-754"><a href="#cb28-754" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Última referência aos signal handlers - seria liberado</span></span>
<span id="cb28-755"><a href="#cb28-755" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-756"><a href="#cb28-756" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-757"><a href="#cb28-757" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Remove das tabelas de grupos</span></span>
<span id="cb28-758"><a href="#cb28-758" aria-hidden="true" tabindex="-1"></a>        <span class="va">process_groups_</span><span class="op">[</span>task<span class="op">-&gt;</span>pgid<span class="op">].</span>erase<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-759"><a href="#cb28-759" aria-hidden="true" tabindex="-1"></a>        <span class="va">sessions_</span><span class="op">[</span>task<span class="op">-&gt;</span>sid<span class="op">].</span>erase<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-760"><a href="#cb28-760" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-761"><a href="#cb28-761" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Orfana processos filhos (reparenting para init)</span></span>
<span id="cb28-762"><a href="#cb28-762" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> child <span class="op">:</span> task<span class="op">-&gt;</span>children<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-763"><a href="#cb28-763" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>child<span class="op">-&gt;</span>state <span class="op">!=</span> TaskState<span class="op">::</span>TASK_ZOMBIE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-764"><a href="#cb28-764" aria-hidden="true" tabindex="-1"></a>                child<span class="op">-&gt;</span>ppid <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-765"><a href="#cb28-765" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> init_task <span class="op">=</span> <span class="va">task_table_</span><span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb28-766"><a href="#cb28-766" aria-hidden="true" tabindex="-1"></a>                init_task<span class="op">-&gt;</span>children<span class="op">.</span>push_back<span class="op">(</span>child<span class="op">);</span></span>
<span id="cb28-767"><a href="#cb28-767" aria-hidden="true" tabindex="-1"></a>                child<span class="op">-&gt;</span>parent <span class="op">=</span> init_task<span class="op">;</span></span>
<span id="cb28-768"><a href="#cb28-768" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-769"><a href="#cb28-769" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-770"><a href="#cb28-770" aria-hidden="true" tabindex="-1"></a>        task<span class="op">-&gt;</span>children<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb28-771"><a href="#cb28-771" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-772"><a href="#cb28-772" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-773"><a href="#cb28-773" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-774"><a href="#cb28-774" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula wait() - coleta processo zombie</span></span>
<span id="cb28-775"><a href="#cb28-775" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">pid</span><span class="co"> PID do processo zombie</span></span>
<span id="cb28-776"><a href="#cb28-776" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se coletado com sucesso</span></span>
<span id="cb28-777"><a href="#cb28-777" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-778"><a href="#cb28-778" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> wait<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-779"><a href="#cb28-779" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> task_it <span class="op">=</span> <span class="va">task_table_</span><span class="op">.</span>find<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-780"><a href="#cb28-780" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task_it <span class="op">==</span> <span class="va">task_table_</span><span class="op">.</span>end<span class="op">())</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-781"><a href="#cb28-781" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-782"><a href="#cb28-782" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> task <span class="op">=</span> task_it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="cb28-783"><a href="#cb28-783" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>state <span class="op">!=</span> TaskState<span class="op">::</span>TASK_ZOMBIE<span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-784"><a href="#cb28-784" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-785"><a href="#cb28-785" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Remove da tabela de processos</span></span>
<span id="cb28-786"><a href="#cb28-786" aria-hidden="true" tabindex="-1"></a>        <span class="va">task_table_</span><span class="op">.</span>erase<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-787"><a href="#cb28-787" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb28-788"><a href="#cb28-788" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-789"><a href="#cb28-789" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-790"><a href="#cb28-790" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-791"><a href="#cb28-791" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém informações de um processo específico</span></span>
<span id="cb28-792"><a href="#cb28-792" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-793"><a href="#cb28-793" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;&gt;</span> getTask<span class="op">(</span><span class="dt">pid_t</span> pid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-794"><a href="#cb28-794" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> <span class="va">task_table_</span><span class="op">.</span>find<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-795"><a href="#cb28-795" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> it <span class="op">!=</span> <span class="va">task_table_</span><span class="op">.</span>end<span class="op">()</span> <span class="op">?</span> <span class="bu">std::</span>optional<span class="op">{</span>it<span class="op">-&gt;</span>second<span class="op">}</span> <span class="op">:</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb28-796"><a href="#cb28-796" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-797"><a href="#cb28-797" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-798"><a href="#cb28-798" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-799"><a href="#cb28-799" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Lista todos os processos no sistema</span></span>
<span id="cb28-800"><a href="#cb28-800" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-801"><a href="#cb28-801" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;&gt;</span> listAllTasks<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-802"><a href="#cb28-802" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;&gt;</span> tasks<span class="op">;</span></span>
<span id="cb28-803"><a href="#cb28-803" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>pid<span class="op">,</span> task<span class="op">]</span> <span class="op">:</span> <span class="va">task_table_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-804"><a href="#cb28-804" aria-hidden="true" tabindex="-1"></a>            tasks<span class="op">.</span>push_back<span class="op">(</span>task<span class="op">);</span></span>
<span id="cb28-805"><a href="#cb28-805" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-806"><a href="#cb28-806" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tasks<span class="op">;</span></span>
<span id="cb28-807"><a href="#cb28-807" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-808"><a href="#cb28-808" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-809"><a href="#cb28-809" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-810"><a href="#cb28-810" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Visualiza hierarquia de processos</span></span>
<span id="cb28-811"><a href="#cb28-811" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-812"><a href="#cb28-812" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> printProcessHierarchy<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-813"><a href="#cb28-813" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">=== Hierarquia de Processos ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-814"><a href="#cb28-814" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-815"><a href="#cb28-815" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Encontra processos raiz (sem pai ou pai é init)</span></span>
<span id="cb28-816"><a href="#cb28-816" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;&gt;</span> roots<span class="op">;</span></span>
<span id="cb28-817"><a href="#cb28-817" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>pid<span class="op">,</span> task<span class="op">]</span> <span class="op">:</span> <span class="va">task_table_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-818"><a href="#cb28-818" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>ppid <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> task<span class="op">-&gt;</span>ppid <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-819"><a href="#cb28-819" aria-hidden="true" tabindex="-1"></a>                roots<span class="op">.</span>push_back<span class="op">(</span>task<span class="op">);</span></span>
<span id="cb28-820"><a href="#cb28-820" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-821"><a href="#cb28-821" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-822"><a href="#cb28-822" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-823"><a href="#cb28-823" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Imprime árvore recursivamente</span></span>
<span id="cb28-824"><a href="#cb28-824" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> root <span class="op">:</span> roots<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-825"><a href="#cb28-825" aria-hidden="true" tabindex="-1"></a>            printTaskTree<span class="op">(</span>root<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb28-826"><a href="#cb28-826" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-827"><a href="#cb28-827" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-828"><a href="#cb28-828" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-829"><a href="#cb28-829" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-830"><a href="#cb28-830" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Imprime árvore de processos recursivamente</span></span>
<span id="cb28-831"><a href="#cb28-831" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-832"><a href="#cb28-832" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> printTaskTree<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>TaskStruct<span class="op">&gt;</span> task<span class="op">,</span> <span class="dt">int</span> level<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-833"><a href="#cb28-833" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string indent<span class="op">(</span>level <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> <span class="ch">' '</span><span class="op">);</span></span>
<span id="cb28-834"><a href="#cb28-834" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string type <span class="op">=</span> task<span class="op">-&gt;</span>isThread<span class="op">()</span> <span class="op">?</span> <span class="st">"T"</span> <span class="op">:</span> <span class="st">"P"</span><span class="op">;</span></span>
<span id="cb28-835"><a href="#cb28-835" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string state <span class="op">=</span> getStateString<span class="op">(</span>task<span class="op">-&gt;</span>state<span class="op">);</span></span>
<span id="cb28-836"><a href="#cb28-836" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-837"><a href="#cb28-837" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">├─ [</span><span class="sc">{}</span><span class="st">] PID:</span><span class="sc">{}</span><span class="st"> TGID:</span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}</span><span class="st"> '</span><span class="sc">{}</span><span class="st">' (</span><span class="sc">{}</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> </span>
<span id="cb28-838"><a href="#cb28-838" aria-hidden="true" tabindex="-1"></a>                                indent<span class="op">,</span> type<span class="op">,</span> task<span class="op">-&gt;</span>pid<span class="op">,</span> task<span class="op">-&gt;</span>tgid<span class="op">,</span> </span>
<span id="cb28-839"><a href="#cb28-839" aria-hidden="true" tabindex="-1"></a>                                state<span class="op">,</span> task<span class="op">-&gt;</span>comm<span class="op">,</span> </span>
<span id="cb28-840"><a href="#cb28-840" aria-hidden="true" tabindex="-1"></a>                                task<span class="op">-&gt;</span>isGroupLeader<span class="op">()</span> <span class="op">?</span> <span class="st">"leader"</span> <span class="op">:</span> <span class="st">"member"</span><span class="op">);</span></span>
<span id="cb28-841"><a href="#cb28-841" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-842"><a href="#cb28-842" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Imprime filhos</span></span>
<span id="cb28-843"><a href="#cb28-843" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> child <span class="op">:</span> task<span class="op">-&gt;</span>children<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-844"><a href="#cb28-844" aria-hidden="true" tabindex="-1"></a>            printTaskTree<span class="op">(</span>child<span class="op">,</span> level <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb28-845"><a href="#cb28-845" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-846"><a href="#cb28-846" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-847"><a href="#cb28-847" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-848"><a href="#cb28-848" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-849"><a href="#cb28-849" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Converte estado para string</span></span>
<span id="cb28-850"><a href="#cb28-850" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-851"><a href="#cb28-851" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string getStateString<span class="op">(</span>TaskState state<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-852"><a href="#cb28-852" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>state<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-853"><a href="#cb28-853" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> TaskState<span class="op">::</span>TASK_RUNNING<span class="op">:</span> <span class="cf">return</span> <span class="st">"RUN"</span><span class="op">;</span></span>
<span id="cb28-854"><a href="#cb28-854" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> TaskState<span class="op">::</span>TASK_INTERRUPTIBLE<span class="op">:</span> <span class="cf">return</span> <span class="st">"INT"</span><span class="op">;</span></span>
<span id="cb28-855"><a href="#cb28-855" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> TaskState<span class="op">::</span>TASK_UNINTERRUPTIBLE<span class="op">:</span> <span class="cf">return</span> <span class="st">"UNI"</span><span class="op">;</span></span>
<span id="cb28-856"><a href="#cb28-856" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> TaskState<span class="op">::</span>TASK_ZOMBIE<span class="op">:</span> <span class="cf">return</span> <span class="st">"ZOM"</span><span class="op">;</span></span>
<span id="cb28-857"><a href="#cb28-857" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> TaskState<span class="op">::</span>TASK_STOPPED<span class="op">:</span> <span class="cf">return</span> <span class="st">"STP"</span><span class="op">;</span></span>
<span id="cb28-858"><a href="#cb28-858" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> TaskState<span class="op">::</span>TASK_TRACED<span class="op">:</span> <span class="cf">return</span> <span class="st">"TRC"</span><span class="op">;</span></span>
<span id="cb28-859"><a href="#cb28-859" aria-hidden="true" tabindex="-1"></a>            <span class="cf">default</span><span class="op">:</span> <span class="cf">return</span> <span class="st">"UNK"</span><span class="op">;</span></span>
<span id="cb28-860"><a href="#cb28-860" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-861"><a href="#cb28-861" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-862"><a href="#cb28-862" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-863"><a href="#cb28-863" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-864"><a href="#cb28-864" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Exibe estatísticas detalhadas do sistema</span></span>
<span id="cb28-865"><a href="#cb28-865" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-866"><a href="#cb28-866" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> printSystemStatistics<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-867"><a href="#cb28-867" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">=== Estatísticas do Sistema ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-868"><a href="#cb28-868" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Total de tasks: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> <span class="va">task_table_</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="cb28-869"><a href="#cb28-869" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Process groups ativos: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> <span class="va">process_groups_</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="cb28-870"><a href="#cb28-870" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Sessões ativas: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> <span class="va">sessions_</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="cb28-871"><a href="#cb28-871" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-872"><a href="#cb28-872" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Contadores por estado</span></span>
<span id="cb28-873"><a href="#cb28-873" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>map<span class="op">&lt;</span>TaskState<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> state_counts<span class="op">;</span></span>
<span id="cb28-874"><a href="#cb28-874" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>pid<span class="op">,</span> task<span class="op">]</span> <span class="op">:</span> <span class="va">task_table_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-875"><a href="#cb28-875" aria-hidden="true" tabindex="-1"></a>            state_counts<span class="op">[</span>task<span class="op">-&gt;</span>state<span class="op">]++;</span></span>
<span id="cb28-876"><a href="#cb28-876" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-877"><a href="#cb28-877" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-878"><a href="#cb28-878" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Distribuição por estado:</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-879"><a href="#cb28-879" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>state<span class="op">,</span> count<span class="op">]</span> <span class="op">:</span> state_counts<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-880"><a href="#cb28-880" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"  </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="st"> tasks</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> getStateString<span class="op">(</span>state<span class="op">),</span> count<span class="op">);</span></span>
<span id="cb28-881"><a href="#cb28-881" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-882"><a href="#cb28-882" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-883"><a href="#cb28-883" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Análise de compartilhamento</span></span>
<span id="cb28-884"><a href="#cb28-884" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">void</span><span class="op">*,</span> <span class="dt">int</span><span class="op">&gt;</span> mm_sharing<span class="op">,</span> files_sharing<span class="op">,</span> signal_sharing<span class="op">;</span></span>
<span id="cb28-885"><a href="#cb28-885" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>pid<span class="op">,</span> task<span class="op">]</span> <span class="op">:</span> <span class="va">task_table_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-886"><a href="#cb28-886" aria-hidden="true" tabindex="-1"></a>            mm_sharing<span class="op">[</span>task<span class="op">-&gt;</span>mm<span class="op">.</span>get<span class="op">()]++;</span></span>
<span id="cb28-887"><a href="#cb28-887" aria-hidden="true" tabindex="-1"></a>            files_sharing<span class="op">[</span>task<span class="op">-&gt;</span>files<span class="op">.</span>get<span class="op">()]++;</span></span>
<span id="cb28-888"><a href="#cb28-888" aria-hidden="true" tabindex="-1"></a>            signal_sharing<span class="op">[</span>task<span class="op">-&gt;</span>signal<span class="op">.</span>get<span class="op">()]++;</span></span>
<span id="cb28-889"><a href="#cb28-889" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-890"><a href="#cb28-890" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-891"><a href="#cb28-891" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> shared_mm <span class="op">=</span> <span class="bu">std::</span>ranges::count_if<span class="op">(</span>mm_sharing<span class="op">,</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">.</span>second <span class="op">&gt;</span> <span class="dv">1</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb28-892"><a href="#cb28-892" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> shared_files <span class="op">=</span> <span class="bu">std::</span>ranges::count_if<span class="op">(</span>files_sharing<span class="op">,</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">.</span>second <span class="op">&gt;</span> <span class="dv">1</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb28-893"><a href="#cb28-893" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> shared_signals <span class="op">=</span> <span class="bu">std::</span>ranges::count_if<span class="op">(</span>signal_sharing<span class="op">,</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">.</span>second <span class="op">&gt;</span> <span class="dv">1</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb28-894"><a href="#cb28-894" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-895"><a href="#cb28-895" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Compartilhamento de recursos:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb28-896"><a href="#cb28-896" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"  mm_struct compartilhados: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> shared_mm<span class="op">);</span></span>
<span id="cb28-897"><a href="#cb28-897" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"  files_struct compartilhados: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> shared_files<span class="op">);</span></span>
<span id="cb28-898"><a href="#cb28-898" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"  signal_struct compartilhados: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> shared_signals<span class="op">);</span></span>
<span id="cb28-899"><a href="#cb28-899" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-900"><a href="#cb28-900" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-901"><a href="#cb28-901" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-902"><a href="#cb28-902" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula operações aleatórias do sistema</span></span>
<span id="cb28-903"><a href="#cb28-903" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">operations</span><span class="co"> Número de operações a executar</span></span>
<span id="cb28-904"><a href="#cb28-904" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-905"><a href="#cb28-905" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> runRandomOperations<span class="op">(</span><span class="dt">int</span> operations <span class="op">=</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-906"><a href="#cb28-906" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>random_device rd<span class="op">;</span></span>
<span id="cb28-907"><a href="#cb28-907" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>mt19937 gen<span class="op">(</span>rd<span class="op">());</span></span>
<span id="cb28-908"><a href="#cb28-908" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>uniform_int_distribution<span class="op">&lt;&gt;</span> op_dist<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb28-909"><a href="#cb28-909" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-910"><a href="#cb28-910" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> operations<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-911"><a href="#cb28-911" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">--- Operação </span><span class="sc">{}</span><span class="st"> ---</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb28-912"><a href="#cb28-912" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-913"><a href="#cb28-913" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> pids <span class="op">=</span> getAllPIDs<span class="op">();</span></span>
<span id="cb28-914"><a href="#cb28-914" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>pids<span class="op">.</span>empty<span class="op">())</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb28-915"><a href="#cb28-915" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-916"><a href="#cb28-916" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>uniform_int_distribution<span class="op">&lt;&gt;</span> pid_dist<span class="op">(</span><span class="dv">0</span><span class="op">,</span> pids<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb28-917"><a href="#cb28-917" aria-hidden="true" tabindex="-1"></a>            <span class="dt">pid_t</span> selected_pid <span class="op">=</span> pids<span class="op">[</span>pid_dist<span class="op">(</span>gen<span class="op">)];</span></span>
<span id="cb28-918"><a href="#cb28-918" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-919"><a href="#cb28-919" aria-hidden="true" tabindex="-1"></a>            <span class="cf">switch</span> <span class="op">(</span>op_dist<span class="op">(</span>gen<span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-920"><a href="#cb28-920" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> <span class="co">// fork</span></span>
<span id="cb28-921"><a href="#cb28-921" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> result <span class="op">=</span> fork<span class="op">(</span>selected_pid<span class="op">,</span> <span class="st">"fork_child"</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-922"><a href="#cb28-922" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"fork(</span><span class="sc">{}</span><span class="st">) -&gt; PID </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> selected_pid<span class="op">,</span> <span class="op">*</span>result<span class="op">);</span></span>
<span id="cb28-923"><a href="#cb28-923" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-924"><a href="#cb28-924" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"fork(</span><span class="sc">{}</span><span class="st">) failed: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> selected_pid<span class="op">,</span> result<span class="op">.</span>error<span class="op">());</span></span>
<span id="cb28-925"><a href="#cb28-925" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb28-926"><a href="#cb28-926" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-927"><a href="#cb28-927" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb28-928"><a href="#cb28-928" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> <span class="co">// clone thread</span></span>
<span id="cb28-929"><a href="#cb28-929" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> result <span class="op">=</span> clone<span class="op">(</span>selected_pid<span class="op">,</span> </span>
<span id="cb28-930"><a href="#cb28-930" aria-hidden="true" tabindex="-1"></a>                                      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_VM<span class="op">)</span> <span class="op">|</span></span>
<span id="cb28-931"><a href="#cb28-931" aria-hidden="true" tabindex="-1"></a>                                      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_FILES<span class="op">)</span> <span class="op">|</span></span>
<span id="cb28-932"><a href="#cb28-932" aria-hidden="true" tabindex="-1"></a>                                      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_SIGHAND<span class="op">)</span> <span class="op">|</span></span>
<span id="cb28-933"><a href="#cb28-933" aria-hidden="true" tabindex="-1"></a>                                      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_THREAD<span class="op">),</span></span>
<span id="cb28-934"><a href="#cb28-934" aria-hidden="true" tabindex="-1"></a>                                      <span class="st">"thread"</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-935"><a href="#cb28-935" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"clone(</span><span class="sc">{}</span><span class="st">) -&gt; TID </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> selected_pid<span class="op">,</span> <span class="op">*</span>result<span class="op">);</span></span>
<span id="cb28-936"><a href="#cb28-936" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-937"><a href="#cb28-937" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"clone(</span><span class="sc">{}</span><span class="st">) failed: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> selected_pid<span class="op">,</span> result<span class="op">.</span>error<span class="op">());</span></span>
<span id="cb28-938"><a href="#cb28-938" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb28-939"><a href="#cb28-939" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-940"><a href="#cb28-940" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb28-941"><a href="#cb28-941" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> <span class="co">// exec</span></span>
<span id="cb28-942"><a href="#cb28-942" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>exec<span class="op">(</span>selected_pid<span class="op">,</span> <span class="st">"new_program"</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-943"><a href="#cb28-943" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"exec(</span><span class="sc">{}</span><span class="st">) -&gt; 'new_program'</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> selected_pid<span class="op">);</span></span>
<span id="cb28-944"><a href="#cb28-944" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb28-945"><a href="#cb28-945" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"exec(</span><span class="sc">{}</span><span class="st">) failed</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> selected_pid<span class="op">);</span></span>
<span id="cb28-946"><a href="#cb28-946" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb28-947"><a href="#cb28-947" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-948"><a href="#cb28-948" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb28-949"><a href="#cb28-949" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> <span class="co">// exit</span></span>
<span id="cb28-950"><a href="#cb28-950" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>selected_pid <span class="op">!=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> <span class="co">// Protege init</span></span>
<span id="cb28-951"><a href="#cb28-951" aria-hidden="true" tabindex="-1"></a>                    exit<span class="op">(</span>selected_pid<span class="op">);</span></span>
<span id="cb28-952"><a href="#cb28-952" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"exit(</span><span class="sc">{}</span><span class="st">) -&gt; ZOMBIE</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> selected_pid<span class="op">);</span></span>
<span id="cb28-953"><a href="#cb28-953" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb28-954"><a href="#cb28-954" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-955"><a href="#cb28-955" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb28-956"><a href="#cb28-956" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> <span class="co">// wait (coleta zombies)</span></span>
<span id="cb28-957"><a href="#cb28-957" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span></span>
<span id="cb28-958"><a href="#cb28-958" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">auto</span> zombies <span class="op">=</span> getZombiePIDs<span class="op">();</span></span>
<span id="cb28-959"><a href="#cb28-959" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(!</span>zombies<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-960"><a href="#cb28-960" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">pid_t</span> zombie_pid <span class="op">=</span> zombies<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb28-961"><a href="#cb28-961" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="op">(</span>wait<span class="op">(</span>zombie_pid<span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-962"><a href="#cb28-962" aria-hidden="true" tabindex="-1"></a>                            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"wait(</span><span class="sc">{}</span><span class="st">) -&gt; reaped</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> zombie_pid<span class="op">);</span></span>
<span id="cb28-963"><a href="#cb28-963" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span></span>
<span id="cb28-964"><a href="#cb28-964" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb28-965"><a href="#cb28-965" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb28-966"><a href="#cb28-966" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-967"><a href="#cb28-967" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-968"><a href="#cb28-968" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-969"><a href="#cb28-969" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-970"><a href="#cb28-970" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-971"><a href="#cb28-971" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb28-972"><a href="#cb28-972" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-973"><a href="#cb28-973" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém todos os PIDs ativos</span></span>
<span id="cb28-974"><a href="#cb28-974" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-975"><a href="#cb28-975" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> getAllPIDs<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-976"><a href="#cb28-976" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> pids<span class="op">;</span></span>
<span id="cb28-977"><a href="#cb28-977" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>pid<span class="op">,</span> task<span class="op">]</span> <span class="op">:</span> <span class="va">task_table_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-978"><a href="#cb28-978" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>state <span class="op">!=</span> TaskState<span class="op">::</span>TASK_ZOMBIE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-979"><a href="#cb28-979" aria-hidden="true" tabindex="-1"></a>                pids<span class="op">.</span>push_back<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-980"><a href="#cb28-980" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-981"><a href="#cb28-981" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-982"><a href="#cb28-982" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pids<span class="op">;</span></span>
<span id="cb28-983"><a href="#cb28-983" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-984"><a href="#cb28-984" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-985"><a href="#cb28-985" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb28-986"><a href="#cb28-986" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém PIDs de processos zombie</span></span>
<span id="cb28-987"><a href="#cb28-987" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb28-988"><a href="#cb28-988" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> getZombiePIDs<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb28-989"><a href="#cb28-989" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">pid_t</span><span class="op">&gt;</span> zombies<span class="op">;</span></span>
<span id="cb28-990"><a href="#cb28-990" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>pid<span class="op">,</span> task<span class="op">]</span> <span class="op">:</span> <span class="va">task_table_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-991"><a href="#cb28-991" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>state <span class="op">==</span> TaskState<span class="op">::</span>TASK_ZOMBIE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-992"><a href="#cb28-992" aria-hidden="true" tabindex="-1"></a>                zombies<span class="op">.</span>push_back<span class="op">(</span>pid<span class="op">);</span></span>
<span id="cb28-993"><a href="#cb28-993" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-994"><a href="#cb28-994" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-995"><a href="#cb28-995" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> zombies<span class="op">;</span></span>
<span id="cb28-996"><a href="#cb28-996" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-997"><a href="#cb28-997" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-998"><a href="#cb28-998" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-999"><a href="#cb28-999" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-1000"><a href="#cb28-1000" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Função principal demonstrando o simulador</span></span>
<span id="cb28-1001"><a href="#cb28-1001" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-1002"><a href="#cb28-1002" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-1003"><a href="#cb28-1003" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"=== Simulador de Arquitetura PCB **Linux** - C++23 ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1004"><a href="#cb28-1004" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Demonstração da task_struct e estruturas auxiliares</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1005"><a href="#cb28-1005" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Foco em hierarquia, compartilhamento e gerenciamento de recursos</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1006"><a href="#cb28-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-1007"><a href="#cb28-1007" aria-hidden="true" tabindex="-1"></a>    PCBArchitectureSimulator simulator<span class="op">;</span></span>
<span id="cb28-1008"><a href="#cb28-1008" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-1009"><a href="#cb28-1009" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Estado inicial</span></span>
<span id="cb28-1010"><a href="#cb28-1010" aria-hidden="true" tabindex="-1"></a>    simulator<span class="op">.</span>printSystemStatistics<span class="op">();</span></span>
<span id="cb28-1011"><a href="#cb28-1011" aria-hidden="true" tabindex="-1"></a>    simulator<span class="op">.</span>printProcessHierarchy<span class="op">();</span></span>
<span id="cb28-1012"><a href="#cb28-1012" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-1013"><a href="#cb28-1013" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Demonstra operações específicas</span></span>
<span id="cb28-1014"><a href="#cb28-1014" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">=== Demonstrações Específicas ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1015"><a href="#cb28-1015" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-1016"><a href="#cb28-1016" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cria processo shell</span></span>
<span id="cb28-1017"><a href="#cb28-1017" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> shell_result <span class="op">=</span> simulator<span class="op">.</span>fork<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="st">"shell"</span><span class="op">);</span></span>
<span id="cb28-1018"><a href="#cb28-1018" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>shell_result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-1019"><a href="#cb28-1019" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Criado processo shell: PID </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> <span class="op">*</span>shell_result<span class="op">);</span></span>
<span id="cb28-1020"><a href="#cb28-1020" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-1021"><a href="#cb28-1021" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Cria threads no shell</span></span>
<span id="cb28-1022"><a href="#cb28-1022" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> thread1 <span class="op">=</span> simulator<span class="op">.</span>clone<span class="op">(*</span>shell_result<span class="op">,</span> </span>
<span id="cb28-1023"><a href="#cb28-1023" aria-hidden="true" tabindex="-1"></a>                                     <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_VM<span class="op">)</span> <span class="op">|</span></span>
<span id="cb28-1024"><a href="#cb28-1024" aria-hidden="true" tabindex="-1"></a>                                     <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_FILES<span class="op">)</span> <span class="op">|</span></span>
<span id="cb28-1025"><a href="#cb28-1025" aria-hidden="true" tabindex="-1"></a>                                     <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_THREAD<span class="op">),</span></span>
<span id="cb28-1026"><a href="#cb28-1026" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">"shell_thread1"</span><span class="op">);</span></span>
<span id="cb28-1027"><a href="#cb28-1027" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-1028"><a href="#cb28-1028" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> thread2 <span class="op">=</span> simulator<span class="op">.</span>clone<span class="op">(*</span>shell_result<span class="op">,</span></span>
<span id="cb28-1029"><a href="#cb28-1029" aria-hidden="true" tabindex="-1"></a>                                     <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_VM<span class="op">)</span> <span class="op">|</span></span>
<span id="cb28-1030"><a href="#cb28-1030" aria-hidden="true" tabindex="-1"></a>                                     <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_FILES<span class="op">)</span> <span class="op">|</span></span>
<span id="cb28-1031"><a href="#cb28-1031" aria-hidden="true" tabindex="-1"></a>                                     <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;(</span>CloneFlags<span class="op">::</span>CLONE_THREAD<span class="op">),</span></span>
<span id="cb28-1032"><a href="#cb28-1032" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">"shell_thread2"</span><span class="op">);</span></span>
<span id="cb28-1033"><a href="#cb28-1033" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-1034"><a href="#cb28-1034" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>thread1 <span class="op">&amp;&amp;</span> thread2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-1035"><a href="#cb28-1035" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Criadas threads: TID </span><span class="sc">{}</span><span class="st"> e TID </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> <span class="op">*</span>thread1<span class="op">,</span> <span class="op">*</span>thread2<span class="op">);</span></span>
<span id="cb28-1036"><a href="#cb28-1036" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-1037"><a href="#cb28-1037" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-1038"><a href="#cb28-1038" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Cria processo filho do shell</span></span>
<span id="cb28-1039"><a href="#cb28-1039" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> child_result <span class="op">=</span> simulator<span class="op">.</span>fork<span class="op">(*</span>shell_result<span class="op">,</span> <span class="st">"child_process"</span><span class="op">);</span></span>
<span id="cb28-1040"><a href="#cb28-1040" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>child_result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-1041"><a href="#cb28-1041" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Criado processo filho: PID </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> <span class="op">*</span>child_result<span class="op">);</span></span>
<span id="cb28-1042"><a href="#cb28-1042" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-1043"><a href="#cb28-1043" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-1044"><a href="#cb28-1044" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-1045"><a href="#cb28-1045" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exibe estado após operações específicas</span></span>
<span id="cb28-1046"><a href="#cb28-1046" aria-hidden="true" tabindex="-1"></a>    simulator<span class="op">.</span>printProcessHierarchy<span class="op">();</span></span>
<span id="cb28-1047"><a href="#cb28-1047" aria-hidden="true" tabindex="-1"></a>    simulator<span class="op">.</span>printSystemStatistics<span class="op">();</span></span>
<span id="cb28-1048"><a href="#cb28-1048" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-1049"><a href="#cb28-1049" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Executa operações aleatórias</span></span>
<span id="cb28-1050"><a href="#cb28-1050" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">=== Simulação de Operações Aleatórias ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1051"><a href="#cb28-1051" aria-hidden="true" tabindex="-1"></a>    simulator<span class="op">.</span>runRandomOperations<span class="op">(</span><span class="dv">8</span><span class="op">);</span></span>
<span id="cb28-1052"><a href="#cb28-1052" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-1053"><a href="#cb28-1053" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Estado final</span></span>
<span id="cb28-1054"><a href="#cb28-1054" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">=== Estado Final do Sistema ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1055"><a href="#cb28-1055" aria-hidden="true" tabindex="-1"></a>    simulator<span class="op">.</span>printProcessHierarchy<span class="op">();</span></span>
<span id="cb28-1056"><a href="#cb28-1056" aria-hidden="true" tabindex="-1"></a>    simulator<span class="op">.</span>printSystemStatistics<span class="op">();</span></span>
<span id="cb28-1057"><a href="#cb28-1057" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-1058"><a href="#cb28-1058" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Demonstra estruturas específicas</span></span>
<span id="cb28-1059"><a href="#cb28-1059" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">=== Análise de Estruturas Específicas ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1060"><a href="#cb28-1060" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> all_tasks <span class="op">=</span> simulator<span class="op">.</span>listAllTasks<span class="op">();</span></span>
<span id="cb28-1061"><a href="#cb28-1061" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> task <span class="op">:</span> all_tasks<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-1062"><a href="#cb28-1062" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>state <span class="op">!=</span> TaskState<span class="op">::</span>TASK_ZOMBIE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-1063"><a href="#cb28-1063" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> <span class="op">[</span>pid<span class="op">,</span> tgid<span class="op">,</span> ppid<span class="op">,</span> sid<span class="op">,</span> pgid<span class="op">,</span> state<span class="op">,</span> children_count<span class="op">,</span></span>
<span id="cb28-1064"><a href="#cb28-1064" aria-hidden="true" tabindex="-1"></a>                  mm_users<span class="op">,</span> mm_count<span class="op">,</span> vma_count<span class="op">,</span> mem_size<span class="op">,</span></span>
<span id="cb28-1065"><a href="#cb28-1065" aria-hidden="true" tabindex="-1"></a>                  files_count<span class="op">,</span> open_files<span class="op">,</span> cloexec_files<span class="op">,</span></span>
<span id="cb28-1066"><a href="#cb28-1066" aria-hidden="true" tabindex="-1"></a>                  sig_count<span class="op">,</span> pending_sigs<span class="op">,</span> blocked_sigs<span class="op">]</span> <span class="op">=</span> task<span class="op">-&gt;</span>getTaskStatistics<span class="op">();</span></span>
<span id="cb28-1067"><a href="#cb28-1067" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-1068"><a href="#cb28-1068" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"PID </span><span class="sc">{}</span><span class="st"> '</span><span class="sc">{}</span><span class="st">': mm_users=</span><span class="sc">{}</span><span class="st">, files_refs=</span><span class="sc">{}</span><span class="st">, sig_refs=</span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="cb28-1069"><a href="#cb28-1069" aria-hidden="true" tabindex="-1"></a>                                    pid<span class="op">,</span> task<span class="op">-&gt;</span>comm<span class="op">,</span> mm_users<span class="op">,</span> files_count<span class="op">,</span> sig_count<span class="op">);</span></span>
<span id="cb28-1070"><a href="#cb28-1070" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-1071"><a href="#cb28-1071" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-1072"><a href="#cb28-1072" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-1073"><a href="#cb28-1073" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">💡 Conceitos Demonstrados:</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1074"><a href="#cb28-1074" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Arquitetura completa da task_struct</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1075"><a href="#cb28-1075" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Hierarquia de processos (PID, TGID, PPID, SID, PGID)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1076"><a href="#cb28-1076" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Compartilhamento seletivo via CLONE_* flags</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1077"><a href="#cb28-1077" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Gerenciamento de recursos com contadores de referência</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1078"><a href="#cb28-1078" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Estados de processo e transições de ciclo de vida</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1079"><a href="#cb28-1079" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Estruturas auxiliares (mm_struct, files_struct, signal_struct)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1080"><a href="#cb28-1080" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Operações fundamentais (fork, clone, exec, exit, wait)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1081"><a href="#cb28-1081" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Process groups e sessions para job control</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb28-1082"><a href="#cb28-1082" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-1083"><a href="#cb28-1083" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-1084"><a href="#cb28-1084" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="análise-dos-conceitos-demonstrados" class="level3" data-number="10.2.1">
<h3 data-number="10.2.1" class="anchored" data-anchor-id="análise-dos-conceitos-demonstrados"><span class="header-section-number">10.2.1</span> Análise dos Conceitos Demonstrados</h3>
<p>O simulador implementado oferece uma representação fidedigna da arquitetura interna do <strong>Process Control Block</strong> do <strong>Linux</strong> através da classe <code>TaskStruct</code>, que encapsula todos os elementos fundamentais da <code>task_struct</code> real. A estrutura de identificadores demonstra como o <code>kernel</code> mantém múltiplas perspectivas de identidade: PID para identificação única, TGID para agrupamento de threads, PPID para hierarquia, SID para sessões e PGID para process groups, criando uma rica taxonomia que suporta job control e gerenciamento hierárquico.</p>
<p>O mecanismo de <strong>compartilhamento de recursos</strong> através dos <code>CLONE_*</code> flags representa um dos aspectos mais elegantes do design do Linux. O simulador demonstra como <code>CLONE_VM</code> permite que threads compartilhem o mesmo espaço de endereçamento através de ponteiros compartilhados para <code>MemoryDescriptor</code>, while <code>CLONE_FILES</code> compartilha a tabela de file descriptors via <code>FileDescriptorTable</code>, e <code>CLONE_SIGHAND</code> compartilha handlers de sinais através de <code>SignalDescriptor</code>. Esta granularidade permite que o <code>kernel</code> implemente tanto processos tradicionais (sem compartilhamento) quanto threads POSIX (compartilhamento total) usando a mesma interface <code>clone()</code>.</p>
<p>Os <strong>contadores de referência atômicos</strong> em cada estrutura auxiliar (<code>mm_users_</code>, <code>count_</code>) implementam garbage collection automático que previne vazamentos de memória e liberação prematura de recursos. Quando um processo termina via <code>exit()</code>, os contadores são decrementados atomicamente, e estruturas órfãs são liberadas automaticamente. Esta abordagem elimina a necessidade de garbage collection explícito enquanto garante que recursos compartilhados entre múltiplos processos permaneçam válidos até que o último usuário termine.</p>
<p>A <strong>hierarquia de processos</strong> materializa-se através de ponteiros <code>parent</code> e <code>children</code>, criando uma árvore dinâmica que reflete as relações de criação. O simulador demonstra como processos órfãos são automaticamente reparented para o processo init, mantendo a integridade da árvore mesmo quando processos intermediários terminam. Esta estrutura suporta operações como <code>kill -TERM -pgid</code> que afetam grupos inteiros de processos relacionados, e é fundamental para implementação de shells e job control.</p>
<p>O sistema de <strong>estados de processo</strong> (<code>TaskState</code>) captura o ciclo de vida completo desde criação até coleta final. a transição para <code>TASK_ZOMBIE</code> após <code>exit()</code> permite que informações de saída sejam coletadas pelo pai via <code>wait()</code>, implementando o protocolo fundamental de sincronização entre processos. O simulador visualiza essas transições e demonstra como o <code>kernel</code> mantém metadados mesmo após término do processo, evidenciando a diferença crucial entre término e limpeza final.</p>
</section>
</section>
<section id="arquitetura-do-pcb-no-windows-eprocesskthread" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="arquitetura-do-pcb-no-windows-eprocesskthread"><span class="header-section-number">10.3</span> Arquitetura do PCB no Windows: EPROCESS/KTHREAD</h2>
<section id="filosofia-de-design" class="level3" data-number="10.3.1">
<h3 data-number="10.3.1" class="anchored" data-anchor-id="filosofia-de-design"><span class="header-section-number">10.3.1</span> Filosofia de Design</h3>
<p>O Windows adota uma <strong>arquitetura orientada a objetos</strong> com separação rigorosa entre <code>kernel</code> e user space, implementada através de múltiplas estruturas especializadas.</p>
<section id="estrutura-principal-eprocess" class="level4" data-number="10.3.1.1">
<h4 data-number="10.3.1.1" class="anchored" data-anchor-id="estrutura-principal-eprocess"><span class="header-section-number">10.3.1.1</span> Estrutura Principal: EPROCESS</h4>
<p>Localizada em endereços como <code>0xfffffa8012345000</code>, a <code>EPROCESS</code> representa o processo no kernel:</p>
<p><strong>Object Header (<code>+0x00</code>)</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>OBJECT_HEADER <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    LONG PointerCount<span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    LONG HandleCount<span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    UCHAR TypeIndex<span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    UCHAr outraceFlags<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    UCHAR InfoMask<span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    UCHAR Flags<span class="op">;</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    PVOID QuotaInfoOffset<span class="op">;</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Todos os objetos Windows herdam este header para <strong>reference counting</strong> e <strong>handle management</strong>.</p>
<p><strong>Identificadores de Processo (<code>+0x30</code>)</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>HANDLE UniqueProcessId<span class="op">;</span>     <span class="co">/* Process ID */</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>HANDLE ParentProcessId<span class="op">;</span>     <span class="co">/* Parent **PID** */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Virtual Address Descriptors (<code>+0x40</code>)</strong></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>PMMVAD VadRoot<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro para árvore <strong>AVL</strong> de <strong>Virtual Address Descriptors</strong>, equivalente às VMAs do <strong>Linux</strong> mas com estrutura hierárquica.</p>
<p><strong>Process Environment Block (<code>+0x50</code>)</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>PPEB Peb<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro para estrutura no <strong>user space</strong> contendo informações acessíveis ao processo.</p>
<p><strong>Handle Table (<code>+0x60</code>)</strong></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>PHANDLE_TABLE ObjectTable<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Tabela de handles para objetos do sistema (files, threads, semaphores, etc).</p>
<p><strong>Lista de Threads (<code>+0x70</code>)</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>LIST_ENTRY ThreadListHead<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Lista ligada de todas as <code>KTHREAD</code> structures pertencentes ao processo.</p>
<p><strong>Token de Segurança (<code>+0x80</code>)</strong></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>PACCESS_TOKEN Token<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Contexto de segurança contendo <strong>Security Identifier (SID)</strong>, privilégios e <strong>Access Control Lists (ACLs)</strong>.</p>
<p><strong>Job Object (<code>+0x90</code>)</strong></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>PEJOB Job<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro para Job Object que permite agrupamento hierárquico de processos com limites de recursos compartilhados.</p>
</section>
<section id="estrutura-de-thread-kthread" class="level4" data-number="10.3.1.2">
<h4 data-number="10.3.1.2" class="anchored" data-anchor-id="estrutura-de-thread-kthread"><span class="header-section-number">10.3.1.2</span> Estrutura de Thread: KTHREAD</h4>
<p>Cada thread é representada por uma <code>KTHREAD</code> em endereços como <code>0xfffffa8012400000</code>:</p>
<p><strong>Contexto de <code>CPU</code> (<code>+0x00</code>)</strong></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>CONTEXT SavedContext<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estrutura de <span class="math inline">\(1232\)</span> bytes contendo: - <strong>Registros de propósito geral</strong>: RAX, RBX, RCX, etc. - <strong>Registros de controle</strong>: CR0, CR2, CR3, CR4 - <strong>Registros de debug</strong>: DR0-DR7 - <strong>Estado FPU/SSE</strong>: XMM registers e estado x87</p>
<p><strong>Stack <code>kernel</code> (<code>+0x500</code>)</strong></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>PVOID KernelStack<span class="op">;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>PVOID StackBase<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>PVOID StackLimit<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiros para <code>kernel</code> stack alocada separadamente, tipicamente <span class="math inline">\(12\)</span> KB no Windows.</p>
<p><strong>Prioridade e Escalonamento (<code>+0x520</code>)</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>UCHAR Priority<span class="op">;</span>           <span class="co">/* Prioridade atual (0-31) */</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>UCHAR BasePriority<span class="op">;</span>       <span class="co">/* Prioridade base */</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>UCHAR PriorityDecrement<span class="op">;</span>  <span class="co">/* Decremento por aging */</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>UCHAR Quantum<span class="op">;</span>            <span class="co">/* Time slice restante */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Estado da Thread (<code>+0x530</code>)</strong></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>UCHAR State<span class="op">;</span>    <span class="co">/* Ready, Running, Waiting, etc */</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>UCHAR WaitReason<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>UCHAR WaitMode<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estados definidos em <code>ntoskrnl.h</code>: - <strong>Ready (1)</strong>: Na fila de prontos - <strong>Running (2)</strong>: Executando atualmente - <strong>Waiting (5)</strong>: Aguardando objeto</p>
<p><strong>Thread Environment Block (<code>+0x540</code>)</strong></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>PVOID Teb<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro para <strong>Thread Environment Block</strong> no user space.</p>
<p><strong>Filas de APC (<code>+0x550</code>)</strong></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>KAPC_STATE ApcState<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>LIST_ENTRY ApcQueueable<span class="op">[</span><span class="dv">2</span><span class="op">];</span>  <span class="co">/* Normal e Special APCs */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Asynchronous Procedure Calls</strong> para execução assíncrona no contexto da thread.</p>
</section>
<section id="process-environment-block-peb" class="level4" data-number="10.3.1.3">
<h4 data-number="10.3.1.3" class="anchored" data-anchor-id="process-environment-block-peb"><span class="header-section-number">10.3.1.3</span> Process Environment Block (PEB)</h4>
<p>Estrutura no <strong>user space</strong> em <code>0x000007fffffd0000</code>:</p>
<p><strong>Image Information (<code>+0x00</code>)</strong></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>UCHAR InheritedAddressSpace<span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>UCHAR ReadImageFileExecOptions<span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>UCHAR BeingDebugged<span class="op">;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>UCHAR ImageBaseAddress<span class="op">[</span><span class="dv">8</span><span class="op">];</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Loader Data (<code>+0x18</code>)</strong></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>PPEB_LDR_DATA Ldr<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro para estrutura contendo: - <strong>InLoadOrderModuleList</strong>: Módulos na ordem de carregamento - <strong>InMemoryOrderModuleList</strong>: Módulos na ordem de endereço - <strong>InInitializationOrderModuleList</strong>: Ordem de inicialização</p>
<p><strong>Heap Management (<code>+0x30</code>)</strong></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>PVOID ProcessHeap<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>PVOID HeapList<span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>ULONG NumberOfHeaps<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Environment Variables (<code>+0x60</code>)</strong></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>PWSTR Environment<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ponteiro para block de variáveis de ambiente no formato <code>VAR=VALUE\0</code>.</p>
<p><strong>Command Line (<code>+0x70</code>)</strong></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>RTL_USER_PROCESS_PARAMETERS <span class="op">*</span>ProcessParameters<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Estrutura contendo: - <strong>CommandLine</strong>: Linha de comando original - <strong>ImagePathName</strong>: Caminho do executável - <strong>CurrentDirectory</strong>: Diretório de trabalho</p>
</section>
</section>
<section id="context-switch-no-windows" class="level3" data-number="10.3.2">
<h3 data-number="10.3.2" class="anchored" data-anchor-id="context-switch-no-windows"><span class="header-section-number">10.3.2</span> Context Switch no Windows</h3>
<p>O Windows implementa context switch através de <code>SwapContext()</code> em <code>ntoskrnl.exe</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>VOID SwapContext<span class="op">(</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    IN PKTHREAD CurrentThread<span class="op">,</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    IN PKTHREAD NewThread</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 1. Salvar contexto FPU se necessário</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>CurrentThread<span class="op">-&gt;</span>Header<span class="op">.</span>DebugActive <span class="op">&amp;</span> <span class="bn">0x1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        KeSaveFloatingPointState<span class="op">(&amp;</span>CurrentThread<span class="op">-&gt;</span>NpxState<span class="op">);</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 2. Salvar contexto `CPU` em CONTEXT structure  </span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    RtlCopyMemory<span class="op">(&amp;</span>CurrentThread<span class="op">-&gt;</span>SavedContext<span class="op">,</span> </span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;</span>TrapFrame<span class="op">,</span> </span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">sizeof</span><span class="op">(</span>CONTEXT<span class="op">));</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 3. Trocar address space se necessário</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>CurrentThread<span class="op">-&gt;</span>ApcState<span class="op">.</span>Process <span class="op">!=</span> NewThread<span class="op">-&gt;</span>ApcState<span class="op">.</span>Process<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>        KeAttachProcess<span class="op">(</span>NewThread<span class="op">-&gt;</span>ApcState<span class="op">.</span>Process<span class="op">);</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 4. Carregar novo contexto</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>    RtlCopyMemory<span class="op">(&amp;</span>TrapFrame<span class="op">,</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;</span>NewThread<span class="op">-&gt;</span>SavedContext<span class="op">,</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">sizeof</span><span class="op">(</span>CONTEXT<span class="op">));</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>                  </span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 5. Restaurar estado FPU</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>NewThread<span class="op">-&gt;</span>Header<span class="op">.</span>DebugActive <span class="op">&amp;</span> <span class="bn">0x1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>        KeRestoreFloatingPointState<span class="op">(&amp;</span>NewThread<span class="op">-&gt;</span>NpxState<span class="op">);</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="comparação-arquitetural" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="comparação-arquitetural"><span class="header-section-number">10.4</span> Comparação Arquitetural</h2>
<section id="filosofias-de-design" class="level3" data-number="10.4.1">
<h3 data-number="10.4.1" class="anchored" data-anchor-id="filosofias-de-design"><span class="header-section-number">10.4.1</span> Filosofias de Design</h3>
<p><strong>Linux: Estrutura Unificada</strong> - <strong>task_struct</strong> como núcleo central com ponteiros para subsistemas - <strong>Embedded structures</strong> para dados frequentemente acessados - <strong>Copy-on-write</strong> e <strong>lazy allocation</strong> para otimização - <strong>RCU</strong> para proteção de estruturas compartilhadas</p>
<p><strong>Windows: Separação Kernel/User</strong> - <strong>Multiple structures</strong> com responsabilidades bem definidas - <strong>Object-oriented approach</strong> com inheritance hierarchy - <strong>Reference counting</strong> consistente via Object Manager - <strong>Security-first design</strong> com tokens e ACLs integrados</p>
</section>
<section id="implicações-de-performance" class="level3" data-number="10.4.2">
<h3 data-number="10.4.2" class="anchored" data-anchor-id="implicações-de-performance"><span class="header-section-number">10.4.2</span> Implicações de Performance</h3>
<p><strong>Context Switch Speed</strong> - <strong>Linux</strong>: <span class="math inline">\(\sim 0.5-2.0\)</span> μs (estrutura unificada, menos copying) - <strong>Windows</strong>: <span class="math inline">\(\sim 2.0-5.0\)</span> μs (múltiplas estruturas, mais overhead)</p>
<p><strong>Memory Footprint</strong> - <strong>Linux task_struct</strong>: <span class="math inline">\(\sim 1728\)</span> bytes - <strong>Windows EPROCESS+KTHREAD+PEB</strong>: <span class="math inline">\(\sim 3000+\)</span> bytes</p>
<p><strong>Scalability</strong> - <strong>Linux</strong>: Otimizado para <strong>high-throughput</strong> server workloads - <strong>Windows</strong>: Otimizado para <strong>desktop responsiveness</strong> e <strong>rich user experience</strong></p>
</section>
<section id="vantagens-e-trade-offs" class="level3" data-number="10.4.3">
<h3 data-number="10.4.3" class="anchored" data-anchor-id="vantagens-e-trade-offs"><span class="header-section-number">10.4.3</span> Vantagens e trade-offs</h3>
<p><strong>Linux Advantages</strong> - <strong>Lower latency</strong> para context switches - <strong>Better cache locality</strong> com estruturas embeded - <strong>Simpler debugging</strong> com estrutura centralizada - <strong>More efficient</strong> para workloads compute-intensive</p>
<p><strong>Windows Advantages</strong><br>
- <strong>Better security isolation</strong> kernel/user - <strong>More granular access control</strong> via ACLs - <strong>Richer debugging support</strong> via structured exception handling - <strong>Better suited</strong> para complex GUI applications</p>
</section>
</section>
<section id="conclusão" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="conclusão"><span class="header-section-number">10.5</span> Conclusão</h2>
<p>As implementações do PCB no <strong>Linux</strong> e Windows refletem <strong>trade-offs fundamentais</strong> entre simplicidade/performance (Linux) e segurança/funcionalidade (Windows). O <strong>Linux</strong> prioriza <code>throughput</code> e <strong>low latency</strong> através de sua task_struct unificada, enquanto o Windows enfatiza <strong>security</strong> e <strong>rich functionality</strong> através de sua arquitetura multi-structure.</p>
<p>Ambas as abordagens representam <strong>soluções engineering</strong> maduras para os desafios de gerenciamento de processos, cada uma otimizada para seus <strong>target workloads</strong> e <strong>design philosophies</strong> específicos. A compreensão dessas diferenças arquiteturais é uma vantagem competitiva para desenvolvedores de sistemas e administradores que precisam otimizar performance em ambientes específicos.</p>
<section id="gerenciamento-de-estados-através-de-filas" class="level3" data-number="10.5.1">
<h3 data-number="10.5.1" class="anchored" data-anchor-id="gerenciamento-de-estados-através-de-filas"><span class="header-section-number">10.5.1</span> Gerenciamento de Estados Através de Filas</h3>
<p>Um <strong>Sistema Operacional</strong> gerencia centenas, eventualmente milhares de processos simultaneamente. Manter o controle de qual processo está em qual estado seria caótico, talvez impossível, sem uma organização sistemática. A solução é organizar os <strong>PCB</strong>s em várias <strong>filas de agendamento</strong>. De tal forma que cada fila corresponde a um estado específico ou a uma condição de espera. a transição de um processo de um estado para outro é implementada desvinculando seu <strong>PCB</strong> de uma fila e vinculando-o a outra</p>
<p>Nem precisamos pensar muito para inferir que estas filas são diferentes em <strong>Sistemas Operacionais</strong> diferentes. Entretanto, algumas filas são comuns, mesmo que tenham nomes diferentes. Entre elas detacamos duas:</p>
<ul>
<li><p><strong>Fila de Prontos (Ready Queue)</strong>: esta fila contém os <strong>PCB</strong>s de todos os processos que estão no estado <strong>Pronto</strong>. São processos que residem na memória principal e estão prontos e aptos a serem executados, aguardando apenas a alocação da <code>CPU</code>. O agendador de <code>CPU</code> seleciona processos desta fila.</p></li>
<li><p><strong>Filas de Dispositivos (Device Queues)</strong>: em vez de uma única fila para todos os processos bloqueados, <strong>Sistemas Operacionais</strong> eficientes mantêm uma fila separada para cada dispositivo de <code>E/S</code>. Quando um processo solicita uma operação de um disco específico, seu <strong>PCB</strong> é colocado na fila daquele disco. Quando o disco conclui a operação e gera uma interrupção, o <strong>Sistema Operacional</strong> sabe exatamente qual fila inspecionar para encontrar o <strong>PCB</strong> do processo que agora pode ser movido para a fila de prontos. Isso é muito mais eficiente do que percorrer uma lista monolítica de todos os processos bloqueados. Este conceitos de um uma fila por dispositivo ilustra a integração entre o hardware e o <strong>Sistema Operacional</strong>.</p></li>
</ul>
</section>
<section id="o-mecanismo-de-troca-de-contexto-context-switch" class="level3" data-number="10.5.2">
<h3 data-number="10.5.2" class="anchored" data-anchor-id="o-mecanismo-de-troca-de-contexto-context-switch"><span class="header-section-number">10.5.2</span> O Mecanismo de Troca de Contexto (Context Switch)</h3>
<p>A <strong>troca de contexto</strong>, em inglês <em>Context Switch</em>, é o mecanismo pelo qual o <strong>Sistema Operacional</strong> alterna a <code>CPU</code> de um processo para outro. É o coração da multitarefa preemptiva e o ato que dá vida aos modelos de estado. O processo é pode ser resumido em três etapas com cinco funções principais:</p>
<ol type="1">
<li><p>Uma interrupção, seja de hardware, como um temporizador, de software, como uma chamada de sistema, ocorre, fazendo com que o processo atualmente em execução seja pausado.</p></li>
<li><p>O <strong>Sistema Operacional</strong> assume o controle e executa uma troca de contexto. Em dois passos:</p>
<ul>
<li><p><strong>Salvar Contexto</strong>: o estado volátil do processo atual, que reside nos registradores da <code>CPU</code>, incluindo o contador de programa, em inglês <em>program counter</em>, é salvo em seu respectivo <strong>PCB</strong> na memória. O processo, como uma entidade viva, agora está “congelado” e encapsulado em seu <strong>PCB</strong>.</p></li>
<li><p><strong>Carregar Contexto</strong>: O <strong>Sistema Operacional</strong> então seleciona o próximo processo a ser executado, geralmente da fila de prontos. Ele carrega o estado salvo do <strong>PCB</strong> deste novo processo para os registradores da <code>CPU</code>.</p></li>
</ul></li>
<li><p>A execução do novo processo começa, recomeça, a partir do ponto exato em que foi interrompido anteriormente.</p></li>
</ol>
<p>É importante manter em mente que a troca de contexto representa um <em>overhead</em>, na forma de custo computacional extra, de desempenho. Este custo existe porque durante o tempo em que o sistema está salvando e carregando contextos, nenhum trabalho útil do usuário está sendo realizado. A frequência das trocas de contexto em sistemas de tempo compartilhado pode ser muito alta, na ordem de <span class="math inline">\(100\)</span> a <span class="math inline">\(1000\)</span> vezes por segundo. Portanto, a eficiência desse mecanismo é crítica para o desempenho geral do sistema. O tempo necessário para uma troca de contexto depende da complexidade do <strong>PCB</strong> e do suporte de hardware; algumas arquiteturas de <code>CPU</code> modernas, como <a href="https://www.arm.com/products/silicon-ip-cpu/cortex-m/cortex-m4">ARM Cortex-M</a> com seus registradores bancados, em inglês <em>banked registers</em>, para diferentes níveis de exceção, <a href="https://riscv.org/">RISC-V</a> com implementações que possuem múltiplos conjuntos de registradores para sistemas embarcados, e <a href="https://www.arm.com/technologies/trustzone-for-cortex-a">ARM TrustZone</a> com registradores separados para os mundos seguro e não-seguro, aceleram significativamente essa operação.</p>
<p>Em suma, <em>o gerenciamento de estados de processo é uma operação de manipulação de estruturas de dados</em>. O <strong>PCB</strong> é o objeto de dados, as filas são os contêineres organizacionais e a troca de contexto é a operação fundamental que move o foco da <code>CPU</code> de um <strong>PCB</strong> para outro, dando vida à abstração do processo concorrente.</p>
</section>
</section>
<section id="implementações-em-sistemas-operacionais-reais" class="level2" data-number="10.6">
<h2 data-number="10.6" class="anchored" data-anchor-id="implementações-em-sistemas-operacionais-reais"><span class="header-section-number">10.6</span> Implementações em <strong>Sistemas Operacionais</strong> Reais</h2>
<p>A teoria dos estados de processo e as estruturas de dados como o PCB fornecem uma base universal. No entanto, a implementação concreta desses conceitos varia significativamente entre os <strong>Sistemas Operacionais</strong>, refletindo suas diferentes filosofias de design, legados históricos e objetivos de arquitetura. Analisar como sistemas proeminentes como <strong>Linux</strong> e <strong>Windows</strong> lidam com o ciclo de vida do processo revela a transição da teoria para a prática de engenharia de software.</p>
<section id="o-ecossistema-unixlinux" class="level3" data-number="10.6.1">
<h3 data-number="10.6.1" class="anchored" data-anchor-id="o-ecossistema-unixlinux"><span class="header-section-number">10.6.1</span> <strong>3. O Ecossistema UNIX/Linux</strong></h3>
<p>O modelo de processo no UNIX e em seus descendentes, como o <strong>Linux</strong>, é caracterizado por sua elegância e pela composição de primitivas simples para alcançar comportamentos complexos.</p>
<section id="criação-de-processos-o-paradigma-fork-e-exec" class="level4" data-number="10.6.1.1">
<h4 data-number="10.6.1.1" class="anchored" data-anchor-id="criação-de-processos-o-paradigma-fork-e-exec"><span class="header-section-number">10.6.1.1</span> <strong>Criação de Processos: O Paradigma fork() e exec()</strong></h4>
<p>A criação de processos no mundo UNIX é um processo distinto de duas etapas.</p>
<ol type="1">
<li><strong>fork()</strong>: A chamada de sistema fork() cria um novo processo, chamado de processo filho, que é uma cópia quase exata do processo que o cham , o processo pai. O filho herda o espaço de endereço do pai (código, dados, pilha), descritores de arquivos abertos e outras informações de contexto. A principal diferença é o valor de retorno da chamada<br>
fork(): no processo pai, ela retorna o ID do processo (PID) do filho recém-criado, enquanto no processo filho, ela retorna 0. Isso permite que o código diferencie se está sendo executado no contexto do pai ou do filho.<br>
</li>
<li><strong>exec()</strong>: Após o fork(), o processo filho geralmente executa uma chamada de sistema da família exec() (como execv ou execlp). Esta chamada substitui completamente o espaço de memória do processo atual (código, dados e pilha) pelo de um novo programa carregado de um arquivo executável. O <strong>PID</strong> e muitas outras propriedades do processo, no entanto, são preservados.</li>
</ol>
<p>Essa abordagem de duas etapas é poderosa. Ela permite que o processo pai modifique o ambiente do filho (por exemplo, redirecionando a entrada/saída padrão) antes que o novo programa seja executado pela chamada exec().</p>
</section>
<section id="o-task_struct-e-os-estados-do-kernel-do-linux" class="level4" data-number="10.6.1.2">
<h4 data-number="10.6.1.2" class="anchored" data-anchor-id="o-task_struct-e-os-estados-do-kernel-do-linux"><span class="header-section-number">10.6.1.2</span> <strong>O task_struct e os Estados do <code>Kernel</code> do Linux</strong></h4>
<p>No <code>Kernel</code> do <strong>Linux</strong>, o Bloco de Controle de Processo é implementado pela estrutura de dados task_struct, definida no arquivo de cabeçalho sched.h. Esta é uma estrutura de dados massiva que contém todos os detalhes imagináveis sobre uma tarefa (o termo do <strong>Linux</strong> para processo ou thread), incluindo estado, informações de agendamento, identificadores, links para processos pai e filho, informações de memória virtual e arquivos abertos.</p>
<p>Os estados de processo no <strong>Linux</strong> são mais granulares e refletem as necessidades de baixo nível do <code>kernel</code>. Eles não mapeiam um-para-um com o modelo teórico de cinco estados. A Tabela 3 detalha os principais estados.</p>
<p><strong>Tabela 3: Dicionário de Estados do <code>Kernel</code> do Linux</strong></p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Estado (#define)</th>
<th style="text-align: left;">Descrição Detalhada</th>
<th style="text-align: left;">Causa Comum / Evento de transição</th>
<th style="text-align: left;">Fontes de Referência</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">TASK_RUNNING</td>
<td style="text-align: left;">O processo está executando na <code>CPU</code> ou está na fila de execução (runqueue) esperando para ser executado. Corresponde tanto ao estado <strong>Executando</strong> quanto ao <strong>Pronto</strong> do modelo teórico.</td>
<td style="text-align: left;">Admissão no sistema; conclusão de E/S; preempção por time t ou por uma tarefa de maior prioridade.</td>
<td style="text-align: left;">26</td>
</tr>
<tr class="even">
<td style="text-align: left;">TASK_INTERRUPTIBLE</td>
<td style="text-align: left;">O processo está “dormindo” (bloqueado), aguardando que uma condição se torne verdadeira (e.g., conclusão de <code>E/S</code>, disponibilidade de um recurso). Pode ser despertado tanto pela condição esperada quanto por um sinal.</td>
<td style="text-align: left;">Espera por <code>E/S</code>, semáforos, outras primitivas de sincronização.</td>
<td style="text-align: left;">26</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TASK_UNINTERRUPTIBLE</td>
<td style="text-align: left;">Similar ao estado anterior, mas o processo não pode ser despertado por sinais. Usado para esperas críticas (geralmente por <code>E/S</code> de hardware) que não devem ser interrompidas para evitar estados inconsistentes.</td>
<td style="text-align: left;">Espera por operações de <code>E/S</code> em drivers de dispositivo que não podem ser interrompidas com segurança.</td>
<td style="text-align: left;">26</td>
</tr>
<tr class="even">
<td style="text-align: left;">TASK_STOPPED</td>
<td style="text-align: left;">A execução do processo foi parada, tipicamente por um sinal como SIGSTOP ou SIGTSTP. Ele pode ser retomado por um sinal SIGCONT.</td>
<td style="text-align: left;">Utilizado para controle de jobs (e.g., Ctrl+Z no shell) e depuração.</td>
<td style="text-align: left;">26</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TASK_TRACED</td>
<td style="text-align: left;">O processo está sendo monitorado por outro processo, como um depurador, através da chamada de sistema ptrace.</td>
<td style="text-align: left;">Um depurador se anexa ao processo para inspecionar sua execução passo a passo.</td>
<td style="text-align: left;">27</td>
</tr>
<tr class="even">
<td style="text-align: left;">EXIT_ZOMBIE</td>
<td style="text-align: left;">O processo terminou sua execução, mas seu task_struct é mantido no sistema porque o processo pai ainda não coletou seu status de saída através de uma chamada wait().</td>
<td style="text-align: left;">Processo filho termina antes do pai chamar wait().</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">EXIT_DEAD</td>
<td style="text-align: left;">O estado final. O processo pai coletou o status do filho zumbi, e agora o task_struct e todos os recursos restantes podem ser liberados.</td>
<td style="text-align: left;">Processo pai executa uma chamada wait() em um filho zumbi.</td>
<td style="text-align: left;">27</td>
</tr>
</tbody>
</table>
</section>
<section id="filas-de-agendamento-no-linux" class="level4" data-number="10.6.1.3">
<h4 data-number="10.6.1.3" class="anchored" data-anchor-id="filas-de-agendamento-no-linux"><span class="header-section-number">10.6.1.3</span> <strong>Filas de Agendamento no Linux</strong></h4>
<p>O <code>Kernel</code> do <strong>Linux</strong> gerencia esses estados usando um sistema de filas implementado com listas duplamente encadeadas. A</p>
<p><strong>runqueue</strong> é a estrutura de dados central do agendador; ela contém todos os processos no estado TASK_RUNNING que estão competindo pela <code>CPU</code>. Processos que estão bloqueados (</p>
<p>TASK_INTERRUPTIBLE ou TASK_UNINTERRUPTIBLE) são colocados em <strong>wait queues</strong> (filas de espera), que estão associadas ao evento específico que o processo está aguardando.</p>
</section>
</section>
<section id="a-arquitetura-do-windows" class="level3" data-number="10.6.2">
<h3 data-number="10.6.2" class="anchored" data-anchor-id="a-arquitetura-do-windows"><span class="header-section-number">10.6.2</span> <strong>3. A Arquitetura do Windows</strong></h3>
<p>O <strong>Windows</strong> adota uma abordagem arquitetônica diferente, que é mais orientada a componentes e abstrações de alto nível.</p>
<section id="criação-de-processos-e-foco-em-threads" class="level4" data-number="10.6.2.1">
<h4 data-number="10.6.2.1" class="anchored" data-anchor-id="criação-de-processos-e-foco-em-threads"><span class="header-section-number">10.6.2.1</span> <strong>Criação de Processos e Foco em Threads</strong></h4>
<p>Em contraste com o paradigma fork()/exec(), o <strong>Windows</strong> utiliza uma abordagem de “spawn” (geração). A criação de um processo é tipicamente realizada por uma única chamada de função, como CreateProcess. Esta função lida com a criação do novo processo e o carregamento do programa especificado em uma única etapa, o que pode ser conceitualmente mais simples para o programador de aplicativos.</p>
<p>Além disso, a arquitetura do <strong>Windows</strong> coloca uma ênfase maior na <strong>thread</strong> como a unidade fundamental de agendamento. Um processo no <strong>Windows</strong> é primariamente um contêiner que fornece um ambiente de execução (como um espaço de endereço virtual e recursos) para uma ou mais threads. É a thread, e não o processo, que o <code>Kernel</code> realmente agenda para execução na <code>CPU</code>.</p>
</section>
<section id="modelo-de-gerenciamento-por-componentes" class="level4" data-number="10.6.2.2">
<h4 data-number="10.6.2.2" class="anchored" data-anchor-id="modelo-de-gerenciamento-por-componentes"><span class="header-section-number">10.6.2.2</span> <strong>Modelo de Gerenciamento por Componentes</strong></h4>
<p>A documentação técnica da Microsoft não descreve o ciclo de vida do processo através de um diagrama de estados simples como os modelos teóricos. Em vez disso, a arquitetura é apresentada como um conjunto de <strong>gerentes (managers)</strong> de modo <code>kernel</code>. O <strong>Kernel-Mode Process and Thread Manager</strong> é o componente executivo responsável por criar, gerenciar e encerrar processos e threads. Outros gerentes, como o <code>E/S</code> Manager e o Memory Manager, interagem com o Process and Thread Manager para fornecer os recursos necessários. a transição de um processo (ou mais precisamente, de uma de suas threads) para um estado de espera, por exemplo, é vista como a thread aguardando por um objeto de sincronização (como um evento ou um mutex) que é gerenciado pelo <code>kernel</code>.</p>
<p>A maneira como um <strong>Sistema Operacional</strong> modela seus processos é um reflexo direto de sua filosofia de design. O modelo do <strong>Linux</strong>, com seus estados TASK_INTERRUPTIBLE vs.&nbsp;UNINTERRUPTIBLE e o estado ZOMBIE, expõe detalhes de baixo nível e as consequências de seu modelo de herança fork()/wait(). É um sistema construído a partir de primitivas simples e poderosas. A abordagem do Windows, por outro lado, abstrai muitos desses detalhes por trás de <code>APIs</code>de componentes de alto nível, como o Process and Thread Manager, refletindo uma filosofia de design mais de cima para baixo e orientada a objetos. A Tabela 2 abaixo oferece uma comparação conceitual.</p>
<p><strong>Tabela 2: Mapeamento Comparativo de Estados de Processo</strong></p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Estado Teórico (Modelo de 5 Estados)</th>
<th style="text-align: left;">Estado do <code>Kernel</code> do <strong>Linux</strong></th>
<th style="text-align: left;">Análogo Conceitual do <strong>Windows</strong></th>
<th style="text-align: left;">Análise Comparativa</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong><em>Pronto</em></strong></td>
<td style="text-align: left;">TASK_RUNNING (na runqueue, não na CPU)</td>
<td style="text-align: left;">Thread em uma das filas de prontos do dispatcher, aguardando para ser agendada.</td>
<td style="text-align: left;"><strong>Linux</strong> funde <strong>Pronto</strong> e <strong>Executando</strong> em um único estado (TASK_RUNNING). No Windows, o estado é uma propriedade da thread, e sua posição em uma fila de prontos determina sua elegibilidade.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong><em>Executando</em></strong></td>
<td style="text-align: left;">TASK_RUNNING (atualmente na CPU)</td>
<td style="text-align: left;">Thread em estado de execução, com seu contexto carregado em um processador.</td>
<td style="text-align: left;">Conceitualmente similar, mas no Windows, a entidade agendada é a thread.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Bloqueado/Esperando</strong></td>
<td style="text-align: left;">TASK_INTERRUPTIBLE ou TASK_UNINTERRUPTIBLE</td>
<td style="text-align: left;">Thread em estado de espera, aguardando por um ou mais objetos de despacho do <code>Kernel</code> (e.g., eventos, semáforos, mutexes).</td>
<td style="text-align: left;"><strong>Linux</strong> expõe a distinção crítica entre espera interrompível e não interrompível no próprio estado. O <strong>Windows</strong> abstrai a espera como um mecanismo de sincronização de objetos genérico.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Terminado</strong></td>
<td style="text-align: left;">EXIT_ZOMBIE → EXIT_DEAD</td>
<td style="text-align: left;">O objeto do processo é sinalizado e seus recursos são liberados gradualmente à medida que as contagens de referência chegam a zero.</td>
<td style="text-align: left;">O estado ZOMBIE do <strong>Linux</strong> é um estado explícito e visível, uma consequência direta do modelo de paternidade fork()/wait(). No Windows, o processo de término é mais um desmantelamento gerenciado por contagem de referências.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="secção-4-tópicos-avançados-e-implicações-de-desempenho" class="level2" data-number="10.7">
<h2 data-number="10.7" class="anchored" data-anchor-id="secção-4-tópicos-avançados-e-implicações-de-desempenho"><span class="header-section-number">10.7</span> <strong>Secção 4: Tópicos Avançados e Implicações de Desempenho</strong></h2>
<p>O gerenciamento de estados de processo não opera em um vácuo. Ele está intrinsecamente ligado a outros subsistemas críticos, mais notavelmente o gerenciamento de memória. A interação entre esses dois domínios define o teto de desempenho de um <strong>Sistema Operacional</strong>, especialmente sob condições de alta carga. Fenômenos como a suspensão de processos e o <em>thrashing</em> não são meras curiosidades acadêmicas; são desafios de engenharia do mundo real cuja gestão eficaz é responsável pela estabilidade e responsividade do sistema.</p>
<section id="suspensão-swapping-e-memória-virtual" class="level3" data-number="10.7.1">
<h3 data-number="10.7.1" class="anchored" data-anchor-id="suspensão-swapping-e-memória-virtual"><span class="header-section-number">10.7.1</span> <strong>4. Suspensão, Swapping e Memória Virtual</strong></h3>
<p>Como introduzido no modelo de sete estados, a <strong>suspensão</strong> de um processo é fundamentalmente um mecanismo de gerenciamento de memória. O ato de mover um processo (ou partes dele) da memória principal para o disco — uma operação conhecida como</p>
<p><strong>swapping</strong> — é uma resposta direta à escassez de RAM. Este mecanismo está no coração da <strong>memória virtual</strong>, um conceito que permite que um sistema execute processos que são maiores que a memória física disponível e que aumente o grau de multiprogramação.</p>
<p>A forma mais comum de memória virtual é a <strong>paginação por demanda (demand paging)</strong>. Em vez de carregar um programa inteiro na memória no momento da sua criação, o <strong>Sistema Operacional</strong>, através de um componente chamado <em>pager</em>, carrega apenas as “páginas” (blocos de memória de tamanho fixo) que são imediatamente necessárias. Quando o processo tenta acessar uma página que não está na memória principal, ocorre uma interrupção de hardware chamada <strong>falha de página (page fault)</strong>. Neste ponto, o <strong>Sistema Operacional</strong> intervém:</p>
<ol type="1">
<li>O processo que causou a falha é movido para o estado <strong>Bloqueado</strong>.<br>
</li>
<li>O <strong>Sistema Operacional</strong> localiza a página necessária no armazenamento secundário (disco).<br>
</li>
<li>A página é carregada do disco para um quadro (frame) livre na memória principal.<br>
</li>
<li>O processo é movido de volta para o estado <strong>Pronto</strong>.</li>
</ol>
<p>Essa abordagem “preguiçosa” (<em>lazy swapper</em>) é eficiente, pois evita carregar partes de um programa que talvez nunca sejam usadas. No entanto, ela introduz um custo de desempenho significativo: o acesso ao disco é ordens de magnitude mais lento que o acesso à <code>RAM</code> (milissegundos vs.&nbsp;nanossegundos). Portanto, o desempenho de um sistema com memória virtual depende criticamente de uma baixa taxa de falhas de página, um princípio possibilitado pela</p>
<p><strong>localidade de referência</strong> — a tendência dos programas de acessar repetidamente um pequeno subconjunto de suas páginas por um período de tempo.</p>
</section>
<section id="o-fenômeno-do-thrashing" class="level3" data-number="10.7.2">
<h3 data-number="10.7.2" class="anchored" data-anchor-id="o-fenômeno-do-thrashing"><span class="header-section-number">10.7.2</span> <strong>4. O Fenômeno do Thrashing</strong></h3>
<p>A interação entre o gerenciamento de processos e a memória virtual pode levar a uma condição de falha catastrófica de desempenho conhecida como <strong>thrashing</strong>. Um sistema está em <em>thrashing</em> quando seus processos passam mais tempo paginando (movendo páginas entre a <code>RAM</code> e o disco) do que executando trabalho útil.</p>
<p>O <em>thrashing</em> ocorre quando os processos no sistema não têm quadros de memória suficientes para manter seu <strong>conjunto de trabalho (working set)</strong> — o conjunto de páginas que estão sendo ativamente referenciadas. Isso leva a uma cascata de falhas de página. Um processo precisa da página A, causa uma falha de página. Para liberar um quadro para A, o sistema move a página B para o disco. Logo em seguida, o processo precisa da página B, causando outra falha de página, que pode levar à remoção da página C, e assim por diante.</p>
<p>Isso cria um ciclo vicioso de desempenho. A alta taxa de falhas de página significa que os processos estão quase sempre no estado <strong>Bloqueado</strong>, esperando por <code>E/S</code> de disco. Isso leva a uma baixa utilização da <code>CPU</code>. Um <strong>Sistema Operacional</strong> ingênuo, ao observar a baixa utilização da<code>CPU</code>, pode concluir que o grau de multiprogramação está baixo e, portanto, admitir ainda mais processos no sistema. No entanto, isso apenas aumenta a competição pela memória já escassa, exacerbando o <em>thrashing</em> e fazendo com que a utilização da <code>CPU</code> caia ainda mais. O sistema efetivamente “para”, gastando todo o seu tempo em sobrecarga de paginação em vez de progresso computacional.</p>
<p>A <strong>suspensão de processos</strong> é a válvula de segurança do <strong>Sistema Operacional</strong> contra o <em>thrashing</em>. Para mitigar essa condição, o <strong>Sistema Operacional</strong> deve reduzir o grau de multiprogramação. Ele faz isso selecionando um ou mais processos e suspendendo-os — movendo-os completamente para fora da memória principal e colocando-os em um estado como <em>Pronto/Suspenso</em>. Isso libera todos os quadros de memória do processo suspenso, que podem então ser distribuídos entre os processos restantes, permitindo que eles mantenham seus conjuntos de trabalho na memória e continuem a execução com uma taxa de falhas de página muito menor. A escolha de qual processo suspender é uma decisão de agendamento de médio prazo e pode ser baseada em vários critérios, como a prioridade do processo, qual processo está causando mais falhas de página ou qual processo foi ativado por último.</p>
<p>Esta análise revela que o gerenciamento de estados de processo e o gerenciamento de memória são dois subsistemas profundamente interdependentes. O objetivo do gerenciamento de processos de maximizar a utilização da <code>CPU</code> e o objetivo do gerenciamento de memória de maximizar a multiprogramação estão em tensão inerente. O <em>thrashing</em> é a manifestação de uma falha nessa interação. Os estados suspensos e o ato de suspender um processo não são apenas extensões do modelo de estados, mas mecanismos de controle essenciais que permitem ao <strong>Sistema Operacional</strong> navegar nessa tensão e manter a estabilidade sob pressão de recursos.</p>
</section>
</section>
<section id="conclusão-1" class="level2" data-number="10.8">
<h2 data-number="10.8" class="anchored" data-anchor-id="conclusão-1"><span class="header-section-number">10.8</span> <strong>Conclusão</strong></h2>
<p>Este relatório outraçou a jornada do conceito de processo desde modelos teóricos abstratos até as complexas e multifacetadas implementações encontradas em <strong>Sistemas Operacionais</strong> do mundo real. A análise demonstrou que o gerenciamento de estados de processo é muito mais do que uma simples tarefa de contabilidade; é o mecanismo central que orquestra a alocação dos recursos mais críticos de um computador: o tempo da <code>CPU</code> e a memória.</p>
<p>A evolução dos modelos de estado, do simplista modelo de dois estados ao sofisticado modelo de sete estados, não foi um exercício acadêmico, mas uma resposta de engenharia direta às realidades do hardware. Cada nova camada de complexidade — a separação entre <strong>Pronto</strong> e <strong>Bloqueado</strong>, e a posterior introdução dos estados <em>Suspensos</em> — foi uma solução necessária para superar as limitações impostas pela disparidade de velocidade entre a <code>CPU</code> e os dispositivos de <code>E/S</code> e pela finitude da memória principal.</p>
<p>A dissecação do Bloco de Controle de Processo (PCB) revelou-o como a personificação de um processo dentro do <code>kernel</code>. O PCB transforma a noção efêmera de um “programa em execução” em um objeto de dados concreto e gerenciável, servindo como o nexo de informações para o agendador, o gerenciador de memória e os subsistemas de <code>E/S</code>. As transições de estado, em sua essência mecânica, são as operações de salvar e restaurar o contexto de hardware de e para esta estrutura de dados fundamental, enquanto ela migra entre as filas de gerenciamento do <code>kernel</code>.</p>
<p>O exame das implementações em <strong>Linux</strong> e <strong>Windows</strong> destacou como as filosofias de design de um <strong>Sistema Operacional</strong> se manifestam em seus modelos de processo. A abordagem do <strong>Linux</strong>, com seu paradigma fork()/exec() e estados de <code>Kernel</code> granulares como TASK_UNINTERRUPTIBLE e EXIT_ZOMBIE, reflete uma filosofia de compor primitivas simples e poderosas. Em contraste, a arquitetura do Windows, com suas <code>APIs</code>de componentes como o Process and Thread Manager, demonstra uma preferência por abstrações de serviço mais abrangentes e de alto nível.</p>
<p>Finalmente, a exploração de tópicos avançados, como o <em>thrashing</em>, solidificou a tese de que o gerenciamento de processos e o gerenciamento de memória são subsistemas interdependentes cuja interação define a estabilidade e o desempenho de um sistema sob carga. O <em>thrashing</em> representa a falha dessa interação, e a suspensão de processos emerge como a válvula de segurança que permite ao <strong>Sistema Operacional</strong> resolver a tensão inerente entre maximizar a utilização da <code>CPU</code> e maximizar a multiprogramação.</p>
<p>Em suma, um gerenciamento de estados de processo robusto e eficiente é indispensável para a performance, responsividade e estabilidade dos sistemas computacionais modernos. É a dança complexa de mecanismos e políticas em torno do ciclo de vida do processo que permite que nossos dispositivos executem uma miríade de tarefas simultaneamente, fornecendo os ambientes de computação poderosos e fluidos que hoje consideramos garantidos.</p>
<section id="a-abstração-de-processo-uma-instância-de-um-programa-em-execução" class="level3" data-number="10.8.1">
<h3 data-number="10.8.1" class="anchored" data-anchor-id="a-abstração-de-processo-uma-instância-de-um-programa-em-execução"><span class="header-section-number">10.8.1</span> A Abstração de Processo: Uma Instância de um Programa em Execução</h3>
<p><strong>Um processo é uma abstração de uma tarefa, representada por um programa em execução.</strong> Esta abstração é mais do que apenas um conjunto de instruções de máquina. O conceito de processo engloba a memória que o programa utiliza, seu estado atual e os recursos do sistema que acessa, como descritores de arquivo e conexões de rede. Para que esta abstração seja possível o <strong>Sistema Operacional</strong> mantém uma estrutura de dados para cada processo, comumente conhecida como Bloco de Controle de Processo, que em inglês é escrito como <strong>P</strong>rocess <strong>C</strong>ontrol <strong>B</strong>lock, <strong>PCB</strong>. Este bloco de memória específico para controle de processos armazena as informações indispensáveis para a criação, execução e remoção de processos. O <strong>PCB</strong>, tipicamente, contém o estado atual do processo da lista de estados possíveis, Novo, Pronto, Em Execução, Esperando ou Terminado, identificadores de processo, informações de agendamento e detalhes de gerenciamento de memória.</p>
<p><em>Para que o processo possa ser executado de forma eficiente, o <strong>Sistema Operacional</strong> fornece a cada processo a ilusão de que ele está sendo executado em sua própria máquina</em>. Ou seja, cada processo tem acesso a todo espaço de endereçamento disponível pela <code>CPU</code>. Para que isso seja possível, cada processo roda na sua própria máquina virtual privada. Essa virtualização permite que vários processos coexistam e executem concorrentemente em um único conjunto de hardware físico. Além isso, cada processo possui seu próprio fluxo de controle lógico, e seu contexto privado, incluindo os registradores de programa e um conjunto de recursos gerenciados pelo <code>Kernel</code>. De forma que esta máquina virtual, o contexto do processo e o seu espaço de endereçamento virtual, estejam isolados dos outros processos em execução.</p>
</section>
<section id="memória-virtual-o-universo-privado-de-um-processo" class="level3" data-number="10.8.2">
<h3 data-number="10.8.2" class="anchored" data-anchor-id="memória-virtual-o-universo-privado-de-um-processo"><span class="header-section-number">10.8.2</span> Memória Virtual: O Universo Privado de um Processo</h3>
<p>O conceito de memória virtual é a pedra angular tanto do gerenciamento de memória moderno quanto da proteção de processos. Cada processo opera dentro de seu próprio Espaço de Endereçamento Virtual, em inglês <strong>V</strong>irtual <strong>A</strong>ddress <strong>S</strong>pace, <strong>VAS</strong>, privado, que se apresenta como um grande e contíguo intervalo de endereços de memória, por exemplo, de <span class="math inline">\(0\)</span> a <span class="math inline">\(2^64−1\)</span> em um sistema de <span class="math inline">\(64 bits\)</span>. <strong>Este espaço de endereçamento é uma abstração</strong>; os endereços que o programa manipula são <em>virtuais</em>, não correspondendo diretamente a localizações físicas na <code>RAM</code>.</p>
<p>O <strong>Sistema Operacional</strong> e o hardware colaboram para traduzir esses endereços virtuais em endereços físicos reais. Essa tradução é realizada em tempo de execução para cada acesso à memória por uma unidade de hardware especializada chamada Unidade de Gerenciamento de Memória, em inglês <strong>M</strong>emory <strong>M</strong>anagement <strong>U</strong>nit, <strong>MMU</strong>. Para realizar essa tarefa, a <strong>MMU</strong> consulta uma estrutura de dados mantida pelo <strong>Sistema Operacional</strong> chamada <strong>tabela de páginas</strong>, em inglês <em>page table</em>. Assim, cada processo possui sua própria tabela de páginas, que mapeia as páginas virtuais de seu <strong>VAS</strong>, o espaço de endereçamento virtual, para quadros de página, em inglês <em>page frames</em> físicos na <code>RAM</code>. A <a href="#fig-mmu1" class="quarto-xref">Figure&nbsp;<span>10.3</span></a> ilustra esse processo de tradução de endereços virtuais para físicos.</p>
<div id="fig-mmu1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mmu1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/memoria_virtual_svg.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mmu1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.3: Arquitetura de memória virtual mostrando a tradução de endereços virtuais para físicos. Cada processo possui seu próprio Espaço de Endereçamento Virtual, <strong>VAS</strong>, privado, enquanto a <strong>MMU</strong> utiliza tabelas de páginas para mapear endereços virtuais para <em>page frames</em> físicos na <code>RAM</code>, garantindo isolamento entre processos.
</figcaption>
</figure>
</div>
<p>Essa camada de abstração e mapeamento oferece alguns benefícios importantes para a segurança e performance dos processos:</p>
<ul>
<li><strong>Isolamento e Proteção de Processos</strong>: como cada processo possui um <strong>VAS</strong> e uma tabela de páginas distintos, é efetivamente impossível para um processo em modo de usuário acessar a memória de outro processo, a memória do <code>Kernel</code>. Isso fornece um mecanismo de proteção que previne que um processo defeituoso ou malicioso corrompa o sistema.<br>
</li>
<li><strong>Uso Eficiente da Memória</strong>: a memória virtual permite que o espaço de endereçamento de um programa seja muito maior do que a <code>RAM</code> física disponível. O <strong>Sistema Operacional</strong> pode manter apenas as partes ativamente utilizadas, páginas, de um processo na memória física, movendo as partes inativas para um armazenamento secundário, como um disco rígido, em um processo conhecido como paginação por demanda, em inglês <em>demand paging</em>. Isso melhora a utilização da <code>CPU</code> permitindo que mais processos residam na memória e estejam prontos para serem executados.<br>
</li>
<li><strong>Compartilhamento de Memória e Bibliotecas</strong>: essa abstração facilita o compartilhamento eficiente de código e dados. A mesma memória física, como o código de uma biblioteca compartilhada, por exemplo, <code>libc.so</code> no <strong>Linux</strong> ou uma <code>DLL</code> no Windows, pode ser mapeada nos espaços de endereço virtuais de múltiplos processos. Isso evita a necessidade de carregar cópias redundantes da mesma biblioteca na <code>RAM</code>, economizando memória.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Um Mergulho Técnico na tradução de Endereços x86-64</strong></p>
<p>Resta uma pergunta interessante: como a <strong>MMU</strong>, em uma arquitetura moderna como a x86-64, realiza essa mágica em hardware? O processo é uma caminhada determinística através de uma hierarquia de tabelas de páginas de quatro níveis.</p>
<p>Um endereço virtual de <span class="math inline">\(64 bits\)</span> em um sistema <span class="math inline">\(x86-64\)</span> é, na prática, um endereço canônico de <span class="math inline">\(48 bits\)</span>. Os <span class="math inline">\(16 bits\)</span> superiores são uma extensão de sinal do <span class="math inline">\(48º bit\)</span>. Vale notar que, embora o padrão <span class="math inline">\(x86-64\)</span> suporte até <span class="math inline">\(48 bits\)</span> para endereços virtuais, implementações específicas podem usar menos bits. Alguns processadores implementam apenas <span class="math inline">\(39\)</span> ou <span class="math inline">\(42 bits\)</span> efetivos para endereçamento virtual, dependendo do modelo e configuração. A <strong>MMU</strong> utiliza esses bits para navegar nas tabelas de páginas. A estrutura de um endereço virtual de <span class="math inline">\(48 bits\)</span> é a seguinte:</p>
<p><span class="math display">\[V_{addr} = [ \text{Índice PML4 (9 bits)} | \text{Índice PDPT (9 bits)} | \text{Índice PD (9 bits)} | \text{Índice PT (9 bits)} | \text{Offset (12 bits)} ]\]</span></p>
<p>Cada um dos quatro campos de índice de <span class="math inline">\(9 bits\)</span> seleciona uma entrada dentre as <span class="math inline">\(2^9 = 512\)</span> entradas possíveis em cada nível da tabela de páginas. O campo de offset de <span class="math inline">\(12 bits\)</span> especifica a localização do byte dentro da página final de <span class="math inline">\(2^{12} = 4096\)</span> bytes (<span class="math inline">\(4KB\)</span>).</p>
<p>A <strong>MMU</strong> para encontrar o endereço físico correspondente a um endereço virtual segue os seguintes passos:</p>
<p><strong>Passo 1: Encontrar a Tabela PML4.</strong> O ponto de partida é o registrador <strong>CR3</strong> da CPU, que armazena o endereço físico base da tabela de primeiro nível, a <strong>P</strong>age <strong>M</strong>ap <strong>L</strong>evel 4, <strong>PML4</strong>.</p>
<p><strong>Passo 2: Consultar a PML4.</strong> A <strong>MMU</strong> utiliza os <span class="math inline">\(9 bits\)</span> do <strong>Índice PML4</strong> do endereço virtual para selecionar uma das <span class="math inline">\(512\)</span> entradas na tabela <strong>PML4</strong>. Essa entrada, a <em>PML4 Entry</em> (<strong>PML4E</strong>), contém não apenas o endereço físico base da tabela do próximo nível (a <strong>P</strong>age <strong>D</strong>irectory <strong>P</strong>ointer <strong>T</strong>able* ou <strong>PDPT</strong>), mas também bits de controle que indicam se a entrada está presente, se permite escrita, se é executável, e outros atributos de proteção.</p>
<p><strong>Passo 3: Consultar a PDPT.</strong> Com o endereço base da <strong>PDPT</strong> em mãos, a <strong>MMU</strong> utiliza os <span class="math inline">\(9 bits\)</span> do <strong>Índice PDPT</strong> do endereço virtual para selecionar uma entrada naquela tabela. Essa <em>PDPT Entry</em> (<strong>PDPTE</strong>) aponta para o endereço físico base da <strong>P</strong>age <strong>D</strong>irectory* (<strong>PD</strong>) e também carrega seus próprios bits de controle.</p>
<p><strong>Passo 4: Consultar a PD.</strong> A <strong>MMU</strong>, agora conhecendo a localização da <strong>PD</strong>, usa os <span class="math inline">\(9 bits\)</span> do Índice <strong>PD</strong> do endereço virtual para selecionar a <strong>P</strong>age <strong>D</strong>irectory <strong>E</strong>ntry (<strong>PDE</strong>). Essa entrada, por sua vez, contém o endereço físico base da tabela final, a <strong>P</strong>age <strong>T</strong>able* (<strong>PT</strong>), junto com bits de controle relevantes.</p>
<p><strong>Passo 5: Consultar a PT.</strong> Finalmente, a <strong>MMU</strong> utiliza os <span class="math inline">\(9 bits\)</span> do Índice <strong>PT</strong> do endereço virtual para selecionar a <strong>P</strong>age <strong>T</strong>able <strong>E</strong>ntry (<strong>PTE</strong>). Esta é a entrada que contém a informação que realmente importa: o endereço físico base do <em>page frame</em> na <code>RAM</code> no qual os dados residem, além dos bits de controle finais que determinam as permissões efetivas da página (leitura, escrita, execução, etc.).</p>
<p><strong>Passo 6: Calcular o Endereço Físico Final.</strong> A <strong>MMU</strong> pega o endereço físico base do <em>page frame</em> obtido na <strong>PTE</strong> e adiciona o <strong>Offset</strong> de <span class="math inline">\(12 bits\)</span> do endereço virtual original. O resultado é o endereço físico exato do dado solicitado.</p>
<p>Matematicamente, o endereço físico final é calculado da seguinte forma:</p>
<p><span class="math display">\[\text{Endereço Físico} = (\text{Endereço Base do Page Frame (do PTE)}) + \text{Offset}\]</span></p>
<p>Todo este processo ocorre em hardware. Para acelerar ainda mais, a <strong>MMU</strong> utiliza a <strong>TLB</strong>, <strong>T</strong>ranslation <strong>L</strong>ookaside <strong>B</strong>uffer*, um cache que armazena asoutraduções de endereço virtual para físico mais recentes. Se a tradução necessária já estiver na <strong>TLB</strong>, temos um <em>TLB hit</em>, e os passos de <span class="math inline">\(2\)</span> a <span class="math inline">\(5\)</span> são pulados, melhorando drasticamente a performance. Um <em>TLB miss</em> força a <span class="math inline">\(MMU\)</span> a realizar todos os passos descritos acima.</p>
<p>É importante notar que cada nível da hierarquia pode falhar se uma entrada não estiver presente, <span class="math inline">\(bit P = 0\)</span>, se as permissões forem violadas, resultando em erro <em>page fault</em> que deve ser tratado pelo <strong>Sistema Operacional</strong>.</p>
</div>
</div>
<section id="a-mmu-não-é-uma-panaceia-universal" class="level4" data-number="10.8.2.1">
<h4 data-number="10.8.2.1" class="anchored" data-anchor-id="a-mmu-não-é-uma-panaceia-universal"><span class="header-section-number">10.8.2.1</span> A MMU não é uma Panaceia Universal</h4>
<p>Embora a <strong>MMU</strong> e a memória virtual ofereçam muitos benefícios, elas não são uma solução universal. As <a href="#tbl-mmuuso1" class="quarto-xref">Table&nbsp;<span>10.2</span></a> e <a href="#tbl-mmuuso2" class="quarto-xref">Table&nbsp;<span>10.3</span></a> resumem as arquiteturas que não adotam, adotam soluções baseadas em <strong>MMU</strong>.</p>
<div id="tbl-mmuuso1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-mmuuso1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;10.2: Arquiteturas que optaram por não usar <strong>MMU</strong>
</figcaption>
<div aria-describedby="tbl-mmuuso1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 14%">
<col style="width: 13%">
<col style="width: 33%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Categoria</th>
<th>Exemplos</th>
<th>Espaço de Endereçamento</th>
<th>Características Principais</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Microcontroladores 8/16-bit</td>
<td>PIC, AVR, 8051</td>
<td><span class="math inline">\(2^8\)</span> a <span class="math inline">\(2^{16}\)</span> bytes</td>
<td>Acesso direto à memória física, execução <em>bare-metal</em> ou RTOS simples</td>
</tr>
<tr class="even">
<td>ARM Cortex-M0/M0+</td>
<td>STM32F0, LPC800</td>
<td><span class="math inline">\(2^{32}\)</span> bytes</td>
<td>Sem MMU nem MPU, arquitetura minimalista</td>
</tr>
<tr class="odd">
<td>ARM Cortex-M3/M4/M7</td>
<td>STM32F4, Kinetis K</td>
<td><span class="math inline">\(2^{32}\)</span> bytes</td>
<td>MPU opcional, suporte a TrustZone-M em versões recentes</td>
</tr>
<tr class="even">
<td>DSP básicos</td>
<td>TI C2000/C5000, ADI SHARC</td>
<td>Variável</td>
<td>Processamento de sinais com acesso determinístico</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<div id="tbl-mmuuso2" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-mmuuso2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;10.3: Arquiteturas que optaram por usar <strong>MMU</strong>
</figcaption>
<div aria-describedby="tbl-mmuuso2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 19%">
<col style="width: 10%">
<col style="width: 28%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Arquitetura</th>
<th>Desde</th>
<th>Tamanhos de Página</th>
<th>Características Especiais</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x86/x86-64</td>
<td>Intel 80386 (1985)</td>
<td><span class="math inline">\(4KB\)</span>, <span class="math inline">\(2MB\)</span>, <span class="math inline">\(1GB\)</span></td>
<td>TLB hierárquico, SMEP/SMAP, EPT para virtualização</td>
</tr>
<tr class="even">
<td>ARM Cortex-A</td>
<td>ARMv6 (2001)</td>
<td><span class="math inline">\(4KB\)</span>, <span class="math inline">\(16KB\)</span>, <span class="math inline">\(64KB\)</span></td>
<td>VMSA, <em>two-stage translation</em>, ASID para otimização</td>
</tr>
<tr class="odd">
<td>RISC-V</td>
<td>Extensão S-mode</td>
<td><span class="math inline">\(4KB\)</span> (Sv32/39/48)</td>
<td>Sv32: <span class="math inline">\(2^{32}\)</span> bytes, Sv39: <span class="math inline">\(2^{39}\)</span> bytes virtuais</td>
</tr>
<tr class="even">
<td>PowerPC/SPARC</td>
<td>Décadas de 1980-90</td>
<td><span class="math inline">\(4KB\)</span>, <span class="math inline">\(64KB\)</span>, <span class="math inline">\(16MB\)</span></td>
<td>Múltiplos <em>address spaces</em>, <em>hardware tablewalk</em></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<section id="unidades-de-proteção-alternativas" class="level5" data-number="10.8.2.1.1">
<h5 data-number="10.8.2.1.1" class="anchored" data-anchor-id="unidades-de-proteção-alternativas"><span class="header-section-number">10.8.2.1.1</span> Unidades de Proteção Alternativas</h5>
<p>Ao longo do desenvolvimento das tecnologias de computação, surgiram alternativas à MMU para atender a diferentes necessidades de sistemas embarcados e de tempo real. A mais notável é a <em><strong>M</strong>emory <strong>P</strong>rotection <strong>U</strong>nit</em>, <strong>MPU</strong>, que oferece uma abordagem simplificada para proteção de memória sem a complexidade da tradução de endereços virtuais.</p>
<p>A <em><strong>M</strong>emory <strong>P</strong>rotection <strong>U</strong>nit</em>, <strong>MPU</strong> representa a principal alternativa à <strong>MMU</strong> em sistemas que necessitam de proteção de memória sem a complexidade da tradução de endereços virtuais. Diferentemente da <strong>MMU</strong>, a <strong>MPU</strong> opera definindo regiões fixas de memória, tipicamente entre <span class="math inline">\(8\)</span> e <span class="math inline">\(16\)</span> regiões, cada uma com atributos específicos de acesso. Estes atributos incluem permissões de leitura, escrita e execução, além de características de cache como <em>cacheable</em>, <em>bufferable</em> e <em>shareable</em>. O sistema permite sobreposição de regiões, nas quais a prioridade é determinada pelo número da região, proporcionando flexibilidade na definição de políticas de acesso. O custo computacional extra de verificação é mínimo, pois a validação ocorre diretamente em hardware sem necessidade de consulta a estruturas de dados complexas como tabelas de páginas.</p>
<p>A <strong>segmentação</strong>, técnica utilizada historicamente em arquiteturas <span class="math inline">\(x86\)</span> antes da popularização da paginação, constitui outro mecanismo de proteção de memória interessante e digno da nossa atenção. Este sistema empregava registradores de segmento, <strong>CS</strong> para código, <strong>DS</strong> para dados, <strong>ES</strong>/<strong>FS</strong>/<strong>GS</strong> para propósitos extras, e <strong>SS</strong> para pilha, que referenciam descritores de segmento contendo endereço base, limite e atributos de acesso. As <em>Global Descriptor Tables</em> (GDT) e <em>Local Descriptor Tables</em> (LDT) mantêm estes descritores, permitindo ao processador verificar privilégios e limites em hardware durante cada acesso à memória. Embora eficaz para proteção básica, a segmentação apresenta limitações de flexibilidade comparada aos sistemas modernos de paginação.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Registradores da Arquitetura de Segmentação x86</strong></p>
<ol type="1">
<li><p><strong>Registradores de Segmento</strong></p>
<ul>
<li><strong>CS (Code Segment)</strong> - Segmento de código/instruções;</li>
<li><strong>DS (Data Segment)</strong> - Segmento de dados padrão;<br>
</li>
<li><strong>ES (Extra Segment)</strong> - Segmento extra para operações de string;</li>
<li><strong>FS (F Segment)</strong> - Segmento adicional (80386+);</li>
<li><strong>GS (G Segment)</strong> - Segmento adicional (80386+);</li>
<li><strong>SS (Stack Segment)</strong> - Segmento de pilha.</li>
</ul></li>
<li><p><strong>Registradores de Índice Associados</strong></p>
<ul>
<li><strong>SI (Source Index)</strong> - Índice fonte (usado com DS por padrão);</li>
<li><strong>DI (Destination Index)</strong> - Índice destino (usado com ES por padrão);</li>
<li><strong>BP (Base Pointer)</strong> - Ponteiro base (usado com SS por padrão);</li>
<li><strong>SP (Stack Pointer)</strong> - Ponteiro de pilha (usado com SS sempre).</li>
</ul></li>
<li><p><strong>Registradores de Tabelas de Descritores (Hardware Real)</strong></p>
<p>3.1 <strong>GDTR (Global Descriptor Table Register)</strong></p>
<ul>
<li>Registrador de hardware de 48 bits (16 bits limite + 32/64 bits base);</li>
<li>Contém endereço físico e tamanho da GDT na memória <code>RAM</code>;</li>
<li>Ainda usado em x86-64 para TSS, call gates e verificações de privilégio;</li>
<li>Carregado via instrução <code>lgdt</code> - usando para o <code>boot</code> do sistema.</li>
</ul>
<p>3.2 <strong>LDTR (Local Descriptor Table Register)</strong></p>
<ul>
<li>Registrador de 16 bits contendo seletor para entrada LDT na GDT;</li>
<li>Cache interno mantém base/limite da LDT atual;</li>
<li>Legado: raramente usado em <strong>Sistemas Operacionais</strong> modernos;</li>
<li>Carregado via instrução <code>lldt</code>.</li>
</ul>
<p>3.3 <strong>IDTR (Interrupt Descriptor Table Register)</strong></p>
<ul>
<li>Registrador de 48 bits similar ao GDTR;</li>
<li>Contém endereço da tabela de vetores de interrupção na <code>RAM</code>;</li>
<li><strong>Não relacionado à segmentação</strong> - usado para tratamento de interrupções;</li>
<li>Amplamente usado mesmo em x86-64;</li>
<li>Carregado via instrução <code>lidt</code>.</li>
</ul></li>
</ol>
<p><strong>Nota</strong>: Todos estes são registradores de hardware reais que ainda existem em processadores <span class="math inline">\(x86-64\)</span> modernos. Eles apontam para estruturas, tabelas de dados, que residem na memória <code>RAM</code>. Em <span class="math inline">\(x86-64\)</span>, a segmentação foi praticamente desabilitada, mas estes registradores mantêm funções do sistema.</p>
</div>
</div>
</section>
</section>
<section id="modelos-de-programação-com-e-sem-mmu" class="level4" data-number="10.8.2.2">
<h4 data-number="10.8.2.2" class="anchored" data-anchor-id="modelos-de-programação-com-e-sem-mmu"><span class="header-section-number">10.8.2.2</span> Modelos de Programação: Com e Sem MMU</h4>
<p>Os modelos de programação diferem substancialmente entre sistemas com e sem <strong>MMU</strong>. Em sistemas equipados com <strong>MMU</strong>, o <em>virtual memory management</em> permite alocação dinâmica sofisticada através de <code>malloc()</code> e <code>free()</code>, com o <code>Kernel</code> gerenciando transparentemente a tradução entre espaços virtuais e físicos. O <em>memory-mapped <code>E/S</code></em> torna-se possível através de system calls como <code>mmap()</code>, permitindo que aplicaçõesoutratem arquivos e dispositivos como regiões de memória. A semântica <em>copy-on-write</em> otimiza operações <code>fork()</code> ao compartilhar páginas entre processos até que modificações sejam necessárias, momento em que cópias são criadas. <em>Demand paging</em> e <em>swapping</em> estendem efetivamente a memória disponível ao utilizar armazenamento secundário. A <a href="#tbl-sommu1" class="quarto-xref">Table&nbsp;<span>10.4</span></a> lista alguns <strong>Sistemas Operacionais</strong> e suas relações com a <strong>MMU</strong>.</p>
<div id="tbl-sommu1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-sommu1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;10.4: <strong>Sistemas Operacionais</strong> e suas relações com a <strong>MMU</strong>
</figcaption>
<div aria-describedby="tbl-sommu1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th>Requer MMU</th>
<th>Funciona sem MMU</th>
<th>Suporte Híbrido</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Linux</strong> padrão</td>
<td>μClinux</td>
<td>Zephyr RTOS</td>
</tr>
<tr class="even">
<td><strong>Windows</strong> NT family</td>
<td>FreeRTOS</td>
<td>ThreadX</td>
</tr>
<tr class="odd">
<td>macOS/Darwin</td>
<td>μC/OS-II/III</td>
<td>Azure RTOS</td>
</tr>
<tr class="even">
<td>BSD variants</td>
<td>eCos</td>
<td>RT-Thread</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Sistemas sem <strong>MMU</strong> adotam estratégias fundamentalmente diferentes. A alocação de memória ocorre predominantemente em <em>compile-time</em>, com estruturas de dados estaticamente dimensionadas. <em>Memory pools</em> pré-alocados substituem a alocação dinâmica tradicional, oferecendo previsibilidade temporal essencial para sistemas de tempo real. O acesso direto a registradores de hardware elimina camadas de abstração, proporcionando controle determinístico sobre periféricos. Modelos de <em>cooperative multitasking</em> ou <em>run-to-completion</em> predominam, em sistemas nos quais tarefas voluntariamente cedem controle ou executam até conclusão antes de permitir escalonamento de outras tarefas.</p>
<p>Sistemas com <strong>MMU</strong> dependem criticamente da eficiência da <strong>T</strong>ranslation <strong>L</strong>ookaside <strong>B</strong>uffer, <strong>TLB</strong>, para minimizar o overhead de tradução de endereços. A <strong>TLB</strong> é um cache de alta velocidade que armazena asoutraduções mais recentes de endereços virtuais para físicos, reduzindo significativamente o número de acessos à tabela de páginas. O tempo de acesso à <strong>TLB</strong> é tipicamente de <span class="math inline">\(1\)</span> a <span class="math inline">\(2\)</span> ciclos de <em>clock</em>, enquanto um <em>page table walk</em> completo pode levar dezenas a centenas de ciclos, dependendo da profundidade da tabela e da arquitetura. A <a href="#tbl-tbl1" class="quarto-xref">Table&nbsp;<span>10.5</span></a> apresenta alguns tamanhos e latências típicas.</p>
<div id="tbl-tbl1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tbl1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;10.5: Tamanhos e latências típicas de TLB
</figcaption>
<div aria-describedby="tbl-tbl1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 19%">
<col style="width: 31%">
<col style="width: 33%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>Nível TLB</th>
<th>Entradas Típicas</th>
<th>Latência de Acesso</th>
<th>Função</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>L1 TLB</td>
<td>32-128</td>
<td>1-2 ciclos</td>
<td>Cache primário para traduções frequentes</td>
</tr>
<tr class="even">
<td>L2 TLB</td>
<td>512-1024</td>
<td>10-20 ciclos</td>
<td>Cache secundário para working set estendido</td>
</tr>
<tr class="odd">
<td>Unified TLB</td>
<td>256-512</td>
<td>5-10 ciclos</td>
<td>Cache unificado para instruções e dados</td>
</tr>
<tr class="even">
<td>Split TLB</td>
<td>64-128 cada</td>
<td>2-5 ciclos</td>
<td>Caches separados para instruções (ITLB) e dados (DTLB)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>O impacto da <strong>TLB</strong> na performance do sistema pode ser quantificado através de uma fórmula que relaciona o tempo efetivo de acesso à memória com as características da TLB:</p>
<p><span class="math display">\[\text{Tempo Efetivo de Acesso} = \text{Tempo de TLB Hit} + \text{Taxa de TLB Miss} \times \text{Tempo de Acesso à Tabela de Páginas}\]</span></p>
<p>Esta equação revela por que a eficiência da <strong>TLB</strong> tem peso na performance geral do sistema. Considerando valores típicos de uma arquitetura <span class="math inline">\(x86-64\)</span> moderna, teríamos:</p>
<ul>
<li><strong>Tempo de TLB Hit</strong>: 1-2 ciclos de clock;</li>
<li><strong>Tempo de Acesso à Tabela de Páginas</strong>: 100-200 ciclos, incluindo múltiplos acessos à memória;</li>
<li><strong>Taxa de TLB Miss aceitável</strong>: <span class="math inline">\(\lt 1\%\)</span> para aplicações bem otimizadas.</li>
</ul>
<p>Um exemplo numérico pode ilustrar o impacto dramático: considerando um <strong>TLB</strong> com <em>hit time</em> de <span class="math inline">\(2\)</span> ciclos, tempo de acesso a <em>page table</em> <span class="math inline">\(150\)</span> ciclos, e <em>miss rate</em> de apenas <span class="math inline">\(5\%\)</span>, o tempo efetivo de acesso será dados por <span class="math inline">\(2 + 0,05 \times 150 = 9,5\)</span> ciclos. Ou seja, nesta situação hipotética, teremos <strong>um custo extra de <span class="math inline">\(375\%\)</span></strong> comparado ao caso ideal. <strong>Este efeito multiplicativo explica por que algoritmos com boa localidade espacial e temporal são fundamentalmente mais eficientes</strong>, e por que o conceito de <em>working set</em> é tão importante para o design de software de alto desempenho.</p>
<p>A análise desta fórmula também revela o dilema de design das <strong>TLB</strong>s modernas: aumentar o tamanho da <strong>TLB</strong> reduz a taxa de erros, mas incrementa o tempo de acerto. Arquiteturas modernas resolvem este compromisso através de hierarquias de <strong>TLB</strong>, L1, L2, similares às hierarquias de <code>cache</code>, balanceando capacidade com latência de acesso.</p>
<p>O custo computacional extra devido a tradução representa um fator <em>sine qua non</em> em sistemas com <strong>MMU</strong>. Durante <em>context switching</em>, operações de <em>TLB flush</em> completo podem consumir entre <span class="math inline">\(100\)</span> e <span class="math inline">\(1000\)</span> ciclos dependendo do tamanho da <strong>TLB</strong> e da arquitetura. Otimizações como o <strong>A</strong>ddress <strong>S</strong>pace <strong>ID</strong>entifier, <strong>ASID</strong>, na tecnologia ARM e o <strong>P</strong>rocess <strong>C</strong>ontext <strong>ID</strong>entifier, <strong>PCID</strong> em tecnologia x86 eliminam <em>flushes</em> de memória desnecessários ao permitir que entradas de diferentes processos coexistam na <strong>TLB</strong>. O <em>page table walking</em> em arquiteturas modernas como <span class="math inline">\(ARMv8\)</span> e <span class="math inline">\(x86-64\)</span> requerem, tipicamente, de <span class="math inline">\(4\)</span> a <span class="math inline">\(5\)</span> acessos sequenciais à memória para completar uma tradução, representando custo computacional significativo em casos de <strong>TLB</strong>. Situações em que a <em>page table</em> não está na <strong>TLB</strong>. Um erro que chamaremos de <em>TLB miss</em>.</p>
<p>Para entendermos a <strong>TLB</strong> precisamos entender que o <em>working set</em> é o conjunto de páginas de memória que um processo acessa ativamente durante um determinado período de tempo. É um conceito fundamental para entender o comportamento de localidade dos programas. Se atenta leitora observar um processo por uma janela de tempo, por exemplo, os últimos <span class="math inline">\(1000\)</span> acessos à memória, o <em>working set</em> será formado por todas as páginas distintas que foram referenciadas nesse período. Este é um conjunto dinâmico de acessos a memória que muda de acordo com as necessidades do programa. Para tornar isso mais claro, considere um programa que processa uma matriz de <span class="math inline">\(100MB\)</span>. Neste caso, ele poderia ter um <em>working set</em> pequeno (2-3 páginas) ao processar linha por linha sequencialmente, um working set grande (centenas de páginas) ao acessar elementos aleatoriamente. Se o <em>working set</em> cabe na <strong>TLB</strong> teremos uma taxa alta de acertos, <em>hits</em> em inglês, implicando em uma performance excelente. Por outro lado, se o <em>working set</em> for menor que o tamanho da <strong>TLB</strong> isso implicará em muitos erros de acesso, em inglês <em>misses</em>, degradando a performance do sistema.</p>
<p>A taxa de acertos da <strong>TLB</strong> é um indicador de eficiência, com valores típicos variando entre <span class="math inline">\(90\%\)</span> e <span class="math inline">\(99\%\)</span> em sistemas bem projetados. Ou seja, a fragmentação e o tamanho das páginas influenciam diretamente a eficácia da <strong>TLB</strong>. Páginas pequenas de <span class="math inline">\(4KB\)</span> oferecem máxima flexibilidade de mapeamento mas aumentam a número de acessos a <strong>TLB</strong> devido ao maior número de traduções necessárias com páginas de <span class="math inline">\(4KB\)</span> e <em>working set</em> de 32MB teremos <span class="math inline">\(8.2\)</span> entradas <strong>TLB</strong>. Por outro lado, páginas grandes de <span class="math inline">\(2MB\)</span> e o mesmo mesmo working set teremos apenas <span class="math inline">\(16\)</span> entradas <strong>TLB</strong>. O working set explica por que a <strong>TLB</strong> é tão importante: programas com boa localidade temporal, reusam as mesmas páginas, e espacial, acessam páginas próximas, têm <em>working sets</em> pequenos e se beneficiam enormemente de <strong>TLB</strong>s eficientes.</p>
</section>
<section id="tendências-em-arquiteturas-modernas" class="level4" data-number="10.8.2.3">
<h4 data-number="10.8.2.3" class="anchored" data-anchor-id="tendências-em-arquiteturas-modernas"><span class="header-section-number">10.8.2.3</span> Tendências em Arquiteturas Modernas</h4>
<p>A virtualização moderna demanda extensões sofisticadas às <strong>MMU</strong>s tradicionais. <em>Nested page tables</em> permitem que hypervisors gerenciem múltiplas camadas de tradução simultaneamente, com tecnologias como Intel <strong>E</strong>xtended <strong>P</strong>age <strong>T</strong>ables, <strong>EPT</strong> e AMD _<strong>N</strong>ested <strong>P</strong>age <strong>T</strong>ables, <strong>NPT</strong> e ARM <em>Stage 2 translation tables</em> oferecendo suporte nativo para tradução de endereços <em>guest-virtual</em> para <em>guest-physical</em> e subsequentemente para <em>host-physical</em>. Esta capacidade elimina a necessidade de <em>shadow page tables</em> em software, reduzindo substancialmente os custos computacionais extras de virtualização.</p>
<p><em><strong>I</strong>nput/<strong>O</strong>utput <strong>M</strong>emory <strong>M</strong>anagement <strong>U</strong>nits</em>, <strong>IOMMU</strong>s, estendem os conceitos de proteção de memória para dispositivos periféricos. <a href="https://www.intel.com/content/www/us/en/content-details/774206/intel-virtualization-technology-for-directed-i-o-architecture-specification.html">Intel VT-d</a> e <a href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/specifications/48882_IOMMU.pdf">AMD-Vi</a> proporcionam proteção contra <em>DMA attacks</em> ao requerer que dispositivos utilizem tradução de endereços similar aos processadores principais. Esta arquitetura habilita <em>device passthrough</em> seguro em hypervisores, permitindo que máquinas virtuais acessem diretamente hardware específico mantendo isolamento entre domínios.</p>
<p>A <strong>computação heterogênea</strong> introduz novos desafios para arquiteturas de memória. <a href="https://www.amd.com/content/dam/amd/en/documents/instinct-tech-docs/data-sheets/amd-instinct-mi300a-data-sheet.pdf">AMD APU</a>s com <em><strong>h</strong>eterogene s <strong>U</strong>nified <strong>M</strong>emory <strong>A</strong>ccess</em>, <strong>hUMA</strong>, permitem que <code>CPU</code>s e <code>GPU</code>s compartilhem espaços de endereçamento virtual idênticos, simplificando programação de aplicações que utilizam ambos os tipos de processador. As arquiteturas ARM <a href="https://www.arm.com/technologies/big-little"><em>big.LITTLE</em></a> gerenciam domínios de coerência entre <em>clusters</em> de processadores com diferentes características de performance e consumo. Já a tecnologia RISC-V incorpora extensões para aceleradores específicos de domínio, permitindo que coprocessadores especializados participem do mesmo framework de gerenciamento de memória virtual dos processadores principais.</p>
<p>A presença ou ausência de <strong>MMU</strong> determina fundamentalmente o modelo de programação, as garantias de isolamento e as possibilidades de otimização do sistema, representando uma das decisões arquiteturais mais impactantes no design de processadores e, consequentemente, no desenvolvimento de <strong>Sistemas Operacionais</strong>. A escolha entre uma arquitetura com <strong>MMU</strong> ou sem ela afeta diretamente a forma como os programas são escritos, como os recursos são gerenciados e como o desempenho é otimizado.</p>
</section>
</section>
</section>
<section id="simulador-2-simulando-um-tlb" class="level2" data-number="10.9">
<h2 data-number="10.9" class="anchored" data-anchor-id="simulador-2-simulando-um-tlb"><span class="header-section-number">10.9</span> Simulador 2: Simulando um TLB</h2>
<p>Trabalhar com <strong>Sistemas Operacionais</strong> n é a coisa mais simples que você pode escolher para fazer. Além disso, entender como a memória virtual e a <strong>MMU</strong> funcionam é desafiador, especialmente quando se trata de conceitos como <strong>TLB</strong>. Para ajudar a atenta leitora a visualizar esses conceitos, vamos criar um simulador que demonstra o funcionamento de um <strong>TLB</strong>. Eu optei por usar o <strong>Windows</strong> 11 porque, quis.</p>
<p>A <strong>TLB</strong> opera em nível de hardware de forma transparente ao software, tornando seus efeitos invisíveis ao programador comum. Um simulador permite visualizar e quantificar esse comportamento oculto, demonstrando como diferentes padrões de acesso à memória impactam dramaticamente a performance.</p>
<p>A fórmula:</p>
<p><span class="math display">\[\text{Tempo Efetivo de Acesso} = \text{Tempo de TLB Hit} + \text{Taxa de TLB Miss} \times \text{Tempo de Acesso à Tabela de Páginas}\]</span></p>
<p>é matematicamente elegante. Porém, o simulador converte teoria abstrata em resultados tangíveis. A criativa leitora poderá experimentar com diferentes parâmetros e observar como pequenas mudanças na taxa de <em>miss</em> causam impactos exponenciais na performance.</p>
<p>O conceito de <em>working set</em> é difícil de intuir. O simulador demonstrará concretamente como <em>working sets</em> maiores que o tamanho da <strong>TLB</strong> causam degeneração da performance, permitindo que desenvolvedores compreendam por que algoritmos que sejam adequados ao uso de <code>cache</code> são superiores. O simulador também irá permitir a exploração de políticas de diferentes tamanhos de <strong>TLB</strong>, políticas de substituição e hierarquias analisando os custos extras criados por estas políticas. Finalmente, desenvolvedores de software de alto desempenho precisam entender como suas decisões algorítmicas afetam o hardware subjacente. O simulador servirá como um laboratório seguro para experimentar técnicas de otimização antes de aplicá-las em sistemas de produção. A <a href="#fig-simul1" class="quarto-xref">Figure&nbsp;<span>10.4</span></a> ilustra o fluxograma do simulador.</p>
<div id="fig-simul1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-simul1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/tlb_simulator_flowchart.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-simul1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.4: Fluxograma do simulador TLB demonstrando o fluxo de execução completo e análise de performance.
</figcaption>
</figure>
</div>
<p>O diagrama da <a href="#fig-simul1" class="quarto-xref">Figure&nbsp;<span>10.4</span></a> ilustra como cada acesso à memória virtual percorre o processo de tradução de endereços, desde a extração do número da página virtual até a decisão crítica de <strong>TLB hit/miss</strong>. O caminho verde (<strong>TLB Hit</strong>) representa o acesso rápido de <span class="math inline">\(1\)</span>-<span class="math inline">\(2\)</span> ciclos quando a tradução está presente na <strong>TLB</strong>, enquanto o caminho vermelho (<strong>TLB Miss</strong>) mostra o processo custoso de <span class="math inline">\(100\)</span>-<span class="math inline">\(200\)</span> ciclos envolvendo <em>page table walk</em> e atualização da <strong>TLB</strong>. Os elementos informativos laterais destacam o impacto do <em>working set</em> na taxa de <em>hit</em>, <em>working sets</em> pequenos vs.&nbsp;grandes, e as características técnicas da <strong>TLB</strong>, tamanho, estrutura, política de substituição. A fórmula implementada está demonstrada com exemplo numérico real, evidenciando como uma taxa de <em>miss</em> de apenas <span class="math inline">\(5\%\)</span> resulta em custos computacionais extras de <span class="math inline">\(375\%\)</span> comparado ao cenário ideal. O laço de controle representa a iteração sobre o vetor de endereços gerados pelos diferentes padrões de acesso, sequencial, aleatório, <em>stride</em>, culminando na análise final que calcula as métricas de performance e valida a fórmula teórica através de simulação prática. Este fluxograma está implantado no <a href="#lst-simul1" class="quarto-xref">Listing&nbsp;<span>10.1</span></a>.</p>
<div id="lst-simul1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-simul1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;10.1
</figcaption>
<div aria-describedby="lst-simul1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-simul1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="lst-simul1-1"><a href="#lst-simul1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-simul1-2"><a href="#lst-simul1-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@file</span><span class="co"> </span><span class="cv">tlb_performance_simulator.cpp</span></span>
<span id="lst-simul1-3"><a href="#lst-simul1-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Simulador de performance da translation Lookaside Buffer (TLB)</span></span>
<span id="lst-simul1-4"><a href="#lst-simul1-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@author</span><span class="co"> Livro de Sistemas Operacionais</span></span>
<span id="lst-simul1-5"><a href="#lst-simul1-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@version</span><span class="co"> </span><span class="cv">1</span><span class="co">.</span></span>
<span id="lst-simul1-6"><a href="#lst-simul1-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@date</span><span class="co"> 2025</span></span>
<span id="lst-simul1-7"><a href="#lst-simul1-7" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="lst-simul1-8"><a href="#lst-simul1-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * Este programa demonstra como calcular o tempo efetivo de acesso à memória</span></span>
<span id="lst-simul1-9"><a href="#lst-simul1-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * considerando a performance da TLB usando a fórmula:</span></span>
<span id="lst-simul1-10"><a href="#lst-simul1-10" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="lst-simul1-11"><a href="#lst-simul1-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * Effective Access Time = TLB Hit Time + TLB Miss Rate × Page Table Access Time</span></span>
<span id="lst-simul1-12"><a href="#lst-simul1-12" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="lst-simul1-13"><a href="#lst-simul1-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * O programa simula diferentes cenários de carga de trabalho e analisa</span></span>
<span id="lst-simul1-14"><a href="#lst-simul1-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * o impacto da TLB na performance geral do sistema.</span></span>
<span id="lst-simul1-15"><a href="#lst-simul1-15" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-simul1-16"><a href="#lst-simul1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-17"><a href="#lst-simul1-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="lst-simul1-18"><a href="#lst-simul1-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="lst-simul1-19"><a href="#lst-simul1-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="lst-simul1-20"><a href="#lst-simul1-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="lst-simul1-21"><a href="#lst-simul1-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;format&gt;</span></span>
<span id="lst-simul1-22"><a href="#lst-simul1-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="lst-simul1-23"><a href="#lst-simul1-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="lst-simul1-24"><a href="#lst-simul1-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="lst-simul1-25"><a href="#lst-simul1-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="lst-simul1-26"><a href="#lst-simul1-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="lst-simul1-27"><a href="#lst-simul1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-28"><a href="#lst-simul1-28" aria-hidden="true" tabindex="-1"></a><span class="co">//eu avisei que não iria fazer outra vez... :)</span></span>
<span id="lst-simul1-29"><a href="#lst-simul1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-30"><a href="#lst-simul1-30" aria-hidden="true" tabindex="-1"></a> <span class="co">/**</span></span>
<span id="lst-simul1-31"><a href="#lst-simul1-31" aria-hidden="true" tabindex="-1"></a><span class="co">  * </span><span class="an">@brief</span><span class="co"> Estrutura para armazenar métricas de performance da TLB</span></span>
<span id="lst-simul1-32"><a href="#lst-simul1-32" aria-hidden="true" tabindex="-1"></a><span class="co">  */</span></span>
<span id="lst-simul1-33"><a href="#lst-simul1-33" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TLBMetrics <span class="op">{</span></span>
<span id="lst-simul1-34"><a href="#lst-simul1-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tlb_hit_time<span class="op">;</span>           <span class="co">///&lt; Tempo de acesso em caso de TLB hit (ciclos)</span></span>
<span id="lst-simul1-35"><a href="#lst-simul1-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> page_table_access_time<span class="op">;</span> <span class="co">///&lt; Tempo de acesso à tabela de páginas (ciclos)</span></span>
<span id="lst-simul1-36"><a href="#lst-simul1-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> total_accesses<span class="op">;</span>         <span class="co">///&lt; Total de acessos à memória</span></span>
<span id="lst-simul1-37"><a href="#lst-simul1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> tlb_hits<span class="op">;</span>              <span class="co">///&lt; Número de TLB hits</span></span>
<span id="lst-simul1-38"><a href="#lst-simul1-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> tlb_misses<span class="op">;</span>            <span class="co">///&lt; Número de TLB misses</span></span>
<span id="lst-simul1-39"><a href="#lst-simul1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-40"><a href="#lst-simul1-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-41"><a href="#lst-simul1-41" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Calcula a taxa de TLB miss</span></span>
<span id="lst-simul1-42"><a href="#lst-simul1-42" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Taxa de miss como valor entre 0. e 1.</span></span>
<span id="lst-simul1-43"><a href="#lst-simul1-43" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-44"><a href="#lst-simul1-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> getMissRate<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-simul1-45"><a href="#lst-simul1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total_accesses <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>tlb_misses<span class="op">)</span> <span class="op">/</span> total_accesses <span class="op">:</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="lst-simul1-46"><a href="#lst-simul1-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-47"><a href="#lst-simul1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-48"><a href="#lst-simul1-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-49"><a href="#lst-simul1-49" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Calcula a taxa de TLB hit</span></span>
<span id="lst-simul1-50"><a href="#lst-simul1-50" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Taxa de hit como valor entre 0. e 1.</span></span>
<span id="lst-simul1-51"><a href="#lst-simul1-51" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-52"><a href="#lst-simul1-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> getHitRate<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-simul1-53"><a href="#lst-simul1-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total_accesses <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>tlb_hits<span class="op">)</span> <span class="op">/</span> total_accesses <span class="op">:</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="lst-simul1-54"><a href="#lst-simul1-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-55"><a href="#lst-simul1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-56"><a href="#lst-simul1-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-57"><a href="#lst-simul1-57" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Calcula o tempo efetivo de acesso usando a fórmula fundamental</span></span>
<span id="lst-simul1-58"><a href="#lst-simul1-58" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Tempo efetivo de acesso em ciclos de clock</span></span>
<span id="lst-simul1-59"><a href="#lst-simul1-59" aria-hidden="true" tabindex="-1"></a><span class="co">     *</span></span>
<span id="lst-simul1-60"><a href="#lst-simul1-60" aria-hidden="true" tabindex="-1"></a><span class="co">     * Implementa a fórmula:</span></span>
<span id="lst-simul1-61"><a href="#lst-simul1-61" aria-hidden="true" tabindex="-1"></a><span class="co">     * Effective Access Time = TLB Hit Time + TLB Miss Rate × Page Table Access Time</span></span>
<span id="lst-simul1-62"><a href="#lst-simul1-62" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-63"><a href="#lst-simul1-63" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> getEffectiveAccessTime<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-simul1-64"><a href="#lst-simul1-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tlb_hit_time <span class="op">+</span> <span class="op">(</span>getMissRate<span class="op">()</span> <span class="op">*</span> page_table_access_time<span class="op">);</span></span>
<span id="lst-simul1-65"><a href="#lst-simul1-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-66"><a href="#lst-simul1-66" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-simul1-67"><a href="#lst-simul1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-68"><a href="#lst-simul1-68" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-simul1-69"><a href="#lst-simul1-69" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Enumeração dos tipos de padrão de acesso à memória</span></span>
<span id="lst-simul1-70"><a href="#lst-simul1-70" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-simul1-71"><a href="#lst-simul1-71" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> AccessPattern <span class="op">{</span></span>
<span id="lst-simul1-72"><a href="#lst-simul1-72" aria-hidden="true" tabindex="-1"></a>    SEQUENTIAL<span class="op">,</span>    <span class="co">///&lt; Acesso sequencial (boa localidade)</span></span>
<span id="lst-simul1-73"><a href="#lst-simul1-73" aria-hidden="true" tabindex="-1"></a>    RANDOM<span class="op">,</span>        <span class="co">///&lt; Acesso aleatório (localidade pobre)</span></span>
<span id="lst-simul1-74"><a href="#lst-simul1-74" aria-hidden="true" tabindex="-1"></a>    STRIDE<span class="op">,</span>        <span class="co">///&lt; Acesso com stride fixo</span></span>
<span id="lst-simul1-75"><a href="#lst-simul1-75" aria-hidden="true" tabindex="-1"></a>    MIXED          <span class="co">///&lt; Padrão misto de acesso</span></span>
<span id="lst-simul1-76"><a href="#lst-simul1-76" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-simul1-77"><a href="#lst-simul1-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-78"><a href="#lst-simul1-78" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-simul1-79"><a href="#lst-simul1-79" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Classe que simula o comportamento de uma TLB</span></span>
<span id="lst-simul1-80"><a href="#lst-simul1-80" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-simul1-81"><a href="#lst-simul1-81" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TLBSimulator <span class="op">{</span></span>
<span id="lst-simul1-82"><a href="#lst-simul1-82" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="lst-simul1-83"><a href="#lst-simul1-83" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> <span class="va">tlb_size_</span><span class="op">;</span>                              <span class="co">///&lt; Tamanho da TLB em entradas</span></span>
<span id="lst-simul1-84"><a href="#lst-simul1-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> <span class="va">tlb_cache_</span><span class="op">;</span> <span class="co">///&lt; Cache simulado da TLB</span></span>
<span id="lst-simul1-85"><a href="#lst-simul1-85" aria-hidden="true" tabindex="-1"></a>    TLBMetrics <span class="va">metrics_</span><span class="op">;</span>                           <span class="co">///&lt; Métricas coletadas</span></span>
<span id="lst-simul1-86"><a href="#lst-simul1-86" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>mt19937 <span class="va">generator_</span><span class="op">;</span>                       <span class="co">///&lt; Gerador de números aleatórios</span></span>
<span id="lst-simul1-87"><a href="#lst-simul1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-88"><a href="#lst-simul1-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-89"><a href="#lst-simul1-89" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Remove entrada mais antiga da TLB (LRU simples)</span></span>
<span id="lst-simul1-90"><a href="#lst-simul1-90" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-91"><a href="#lst-simul1-91" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> evictOldestEntry<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-simul1-92"><a href="#lst-simul1-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">tlb_cache_</span><span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> <span class="va">tlb_size_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-93"><a href="#lst-simul1-93" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Simula política LRU removendo primeira entrada</span></span>
<span id="lst-simul1-94"><a href="#lst-simul1-94" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> it <span class="op">=</span> <span class="va">tlb_cache_</span><span class="op">.</span>begin<span class="op">();</span></span>
<span id="lst-simul1-95"><a href="#lst-simul1-95" aria-hidden="true" tabindex="-1"></a>            <span class="va">tlb_cache_</span><span class="op">.</span>erase<span class="op">(</span>it<span class="op">);</span></span>
<span id="lst-simul1-96"><a href="#lst-simul1-96" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-97"><a href="#lst-simul1-97" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-98"><a href="#lst-simul1-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-99"><a href="#lst-simul1-99" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="lst-simul1-100"><a href="#lst-simul1-100" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-101"><a href="#lst-simul1-101" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Construtor do simulador TLB</span></span>
<span id="lst-simul1-102"><a href="#lst-simul1-102" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">tlb_size</span><span class="co"> Tamanho da TLB em entradas</span></span>
<span id="lst-simul1-103"><a href="#lst-simul1-103" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">tlb_hit_time</span><span class="co"> Tempo de acesso em caso de hit (ciclos)</span></span>
<span id="lst-simul1-104"><a href="#lst-simul1-104" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">page_table_time</span><span class="co"> Tempo de acesso à tabela de páginas (ciclos)</span></span>
<span id="lst-simul1-105"><a href="#lst-simul1-105" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-106"><a href="#lst-simul1-106" aria-hidden="true" tabindex="-1"></a>    TLBSimulator<span class="op">(</span><span class="dt">size_t</span> tlb_size<span class="op">,</span> <span class="dt">double</span> tlb_hit_time<span class="op">,</span> <span class="dt">double</span> page_table_time<span class="op">)</span></span>
<span id="lst-simul1-107"><a href="#lst-simul1-107" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">tlb_size_</span><span class="op">(</span>tlb_size<span class="op">),</span> <span class="va">generator_</span><span class="op">(</span><span class="bu">std::</span>random_device<span class="op">{}())</span> <span class="op">{</span></span>
<span id="lst-simul1-108"><a href="#lst-simul1-108" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>tlb_hit_time <span class="op">=</span> tlb_hit_time<span class="op">;</span></span>
<span id="lst-simul1-109"><a href="#lst-simul1-109" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>page_table_access_time <span class="op">=</span> page_table_time<span class="op">;</span></span>
<span id="lst-simul1-110"><a href="#lst-simul1-110" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>total_accesses <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-simul1-111"><a href="#lst-simul1-111" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>tlb_hits <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-simul1-112"><a href="#lst-simul1-112" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>tlb_misses <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-simul1-113"><a href="#lst-simul1-113" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-114"><a href="#lst-simul1-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-115"><a href="#lst-simul1-115" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-116"><a href="#lst-simul1-116" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Simula um acesso à memória virtual</span></span>
<span id="lst-simul1-117"><a href="#lst-simul1-117" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">virtual_address</span><span class="co"> Endereço virtual sendo acessado</span></span>
<span id="lst-simul1-118"><a href="#lst-simul1-118" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> true se foi TLB hit, false se foi TLB miss</span></span>
<span id="lst-simul1-119"><a href="#lst-simul1-119" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-120"><a href="#lst-simul1-120" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> accessMemory<span class="op">(</span><span class="dt">uint64_t</span> virtual_address<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-121"><a href="#lst-simul1-121" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Extrai número da página virtual (assumindo páginas de 4KB)</span></span>
<span id="lst-simul1-122"><a href="#lst-simul1-122" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint64_t</span> page_number <span class="op">=</span> virtual_address <span class="op">&gt;&gt;</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="lst-simul1-123"><a href="#lst-simul1-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-124"><a href="#lst-simul1-124" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>total_accesses<span class="op">++;</span></span>
<span id="lst-simul1-125"><a href="#lst-simul1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-126"><a href="#lst-simul1-126" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Verifica se a página está na TLB</span></span>
<span id="lst-simul1-127"><a href="#lst-simul1-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">tlb_cache_</span><span class="op">.</span>contains<span class="op">(</span>page_number<span class="op">))</span> <span class="op">{</span></span>
<span id="lst-simul1-128"><a href="#lst-simul1-128" aria-hidden="true" tabindex="-1"></a>            <span class="va">metrics_</span><span class="op">.</span>tlb_hits<span class="op">++;</span></span>
<span id="lst-simul1-129"><a href="#lst-simul1-129" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// TLB hit</span></span>
<span id="lst-simul1-130"><a href="#lst-simul1-130" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-131"><a href="#lst-simul1-131" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="lst-simul1-132"><a href="#lst-simul1-132" aria-hidden="true" tabindex="-1"></a>            <span class="va">metrics_</span><span class="op">.</span>tlb_misses<span class="op">++;</span></span>
<span id="lst-simul1-133"><a href="#lst-simul1-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-134"><a href="#lst-simul1-134" aria-hidden="true" tabindex="-1"></a>            <span class="co">// TLB miss: precisa acessar tabela de páginas</span></span>
<span id="lst-simul1-135"><a href="#lst-simul1-135" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Adiciona entrada na TLB</span></span>
<span id="lst-simul1-136"><a href="#lst-simul1-136" aria-hidden="true" tabindex="-1"></a>            evictOldestEntry<span class="op">();</span></span>
<span id="lst-simul1-137"><a href="#lst-simul1-137" aria-hidden="true" tabindex="-1"></a>            <span class="va">tlb_cache_</span><span class="op">[</span>page_number<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="lst-simul1-138"><a href="#lst-simul1-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-139"><a href="#lst-simul1-139" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// TLB miss</span></span>
<span id="lst-simul1-140"><a href="#lst-simul1-140" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-141"><a href="#lst-simul1-141" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-142"><a href="#lst-simul1-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-143"><a href="#lst-simul1-143" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-144"><a href="#lst-simul1-144" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Gera padrão de acesso sequencial</span></span>
<span id="lst-simul1-145"><a href="#lst-simul1-145" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">start_address</span><span class="co"> Endereço inicial</span></span>
<span id="lst-simul1-146"><a href="#lst-simul1-146" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">num_accesses</span><span class="co"> Número de acessos</span></span>
<span id="lst-simul1-147"><a href="#lst-simul1-147" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">stride</span><span class="co"> Tamanho do stride em bytes</span></span>
<span id="lst-simul1-148"><a href="#lst-simul1-148" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Vetor de endereços virtuais</span></span>
<span id="lst-simul1-149"><a href="#lst-simul1-149" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-150"><a href="#lst-simul1-150" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> generateSequentialPattern<span class="op">(</span><span class="dt">uint64_t</span> start_address<span class="op">,</span></span>
<span id="lst-simul1-151"><a href="#lst-simul1-151" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> num_accesses<span class="op">,</span></span>
<span id="lst-simul1-152"><a href="#lst-simul1-152" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> stride <span class="op">=</span> <span class="dv">4096</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-153"><a href="#lst-simul1-153" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> addresses<span class="op">;</span></span>
<span id="lst-simul1-154"><a href="#lst-simul1-154" aria-hidden="true" tabindex="-1"></a>        addresses<span class="op">.</span>reserve<span class="op">(</span>num_accesses<span class="op">);</span></span>
<span id="lst-simul1-155"><a href="#lst-simul1-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-156"><a href="#lst-simul1-156" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_accesses<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-157"><a href="#lst-simul1-157" aria-hidden="true" tabindex="-1"></a>            addresses<span class="op">.</span>push_back<span class="op">(</span>start_address <span class="op">+</span> <span class="op">(</span>i <span class="op">*</span> stride<span class="op">));</span></span>
<span id="lst-simul1-158"><a href="#lst-simul1-158" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-159"><a href="#lst-simul1-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-160"><a href="#lst-simul1-160" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> addresses<span class="op">;</span></span>
<span id="lst-simul1-161"><a href="#lst-simul1-161" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-162"><a href="#lst-simul1-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-163"><a href="#lst-simul1-163" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-164"><a href="#lst-simul1-164" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Gera padrão de acesso aleatório</span></span>
<span id="lst-simul1-165"><a href="#lst-simul1-165" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">num_accesses</span><span class="co"> Número de acessos</span></span>
<span id="lst-simul1-166"><a href="#lst-simul1-166" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">address_range</span><span class="co"> Faixa de endereços</span></span>
<span id="lst-simul1-167"><a href="#lst-simul1-167" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Vetor de endereços virtuais aleatórios</span></span>
<span id="lst-simul1-168"><a href="#lst-simul1-168" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-169"><a href="#lst-simul1-169" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> generateRandomPattern<span class="op">(</span><span class="dt">size_t</span> num_accesses<span class="op">,</span></span>
<span id="lst-simul1-170"><a href="#lst-simul1-170" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint64_t</span> address_range <span class="op">=</span> <span class="bn">0x100000000</span><span class="bu">ULL</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-171"><a href="#lst-simul1-171" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> addresses<span class="op">;</span></span>
<span id="lst-simul1-172"><a href="#lst-simul1-172" aria-hidden="true" tabindex="-1"></a>        addresses<span class="op">.</span>reserve<span class="op">(</span>num_accesses<span class="op">);</span></span>
<span id="lst-simul1-173"><a href="#lst-simul1-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-174"><a href="#lst-simul1-174" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>uniform_int_distribution<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> dist<span class="op">(</span><span class="dv">0</span><span class="op">,</span> address_range<span class="op">);</span></span>
<span id="lst-simul1-175"><a href="#lst-simul1-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-176"><a href="#lst-simul1-176" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_accesses<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-177"><a href="#lst-simul1-177" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Alinha endereços em limites de página</span></span>
<span id="lst-simul1-178"><a href="#lst-simul1-178" aria-hidden="true" tabindex="-1"></a>            <span class="dt">uint64_t</span> addr <span class="op">=</span> dist<span class="op">(</span><span class="va">generator_</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">~</span><span class="bn">0xFFF</span><span class="bu">ULL</span><span class="op">;</span></span>
<span id="lst-simul1-179"><a href="#lst-simul1-179" aria-hidden="true" tabindex="-1"></a>            addresses<span class="op">.</span>push_back<span class="op">(</span>addr<span class="op">);</span></span>
<span id="lst-simul1-180"><a href="#lst-simul1-180" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-181"><a href="#lst-simul1-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-182"><a href="#lst-simul1-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> addresses<span class="op">;</span></span>
<span id="lst-simul1-183"><a href="#lst-simul1-183" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-184"><a href="#lst-simul1-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-185"><a href="#lst-simul1-185" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-186"><a href="#lst-simul1-186" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Executa simulação com padrão específico de acesso</span></span>
<span id="lst-simul1-187"><a href="#lst-simul1-187" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">addresses</span><span class="co"> Vetor de endereços para acessar</span></span>
<span id="lst-simul1-188"><a href="#lst-simul1-188" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-189"><a href="#lst-simul1-189" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> runSimulation<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;&amp;</span> addresses<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-190"><a href="#lst-simul1-190" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">uint64_t</span> addr <span class="op">:</span> addresses<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-191"><a href="#lst-simul1-191" aria-hidden="true" tabindex="-1"></a>            accessMemory<span class="op">(</span>addr<span class="op">);</span></span>
<span id="lst-simul1-192"><a href="#lst-simul1-192" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-193"><a href="#lst-simul1-193" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-194"><a href="#lst-simul1-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-195"><a href="#lst-simul1-195" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-196"><a href="#lst-simul1-196" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Reset de estatísticas do simulador</span></span>
<span id="lst-simul1-197"><a href="#lst-simul1-197" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-198"><a href="#lst-simul1-198" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> reset<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-simul1-199"><a href="#lst-simul1-199" aria-hidden="true" tabindex="-1"></a>        <span class="va">tlb_cache_</span><span class="op">.</span>clear<span class="op">();</span></span>
<span id="lst-simul1-200"><a href="#lst-simul1-200" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>total_accesses <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-simul1-201"><a href="#lst-simul1-201" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>tlb_hits <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-simul1-202"><a href="#lst-simul1-202" aria-hidden="true" tabindex="-1"></a>        <span class="va">metrics_</span><span class="op">.</span>tlb_misses <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-simul1-203"><a href="#lst-simul1-203" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-204"><a href="#lst-simul1-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-205"><a href="#lst-simul1-205" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-206"><a href="#lst-simul1-206" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Obtém métricas atuais</span></span>
<span id="lst-simul1-207"><a href="#lst-simul1-207" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@return</span><span class="co"> Estrutura com métricas de performance</span></span>
<span id="lst-simul1-208"><a href="#lst-simul1-208" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-209"><a href="#lst-simul1-209" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> TLBMetrics<span class="op">&amp;</span> getMetrics<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="lst-simul1-210"><a href="#lst-simul1-210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">metrics_</span><span class="op">;</span></span>
<span id="lst-simul1-211"><a href="#lst-simul1-211" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-212"><a href="#lst-simul1-212" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-simul1-213"><a href="#lst-simul1-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-214"><a href="#lst-simul1-214" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-simul1-215"><a href="#lst-simul1-215" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Classe para análise comparativa de diferentes configurações</span></span>
<span id="lst-simul1-216"><a href="#lst-simul1-216" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-simul1-217"><a href="#lst-simul1-217" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TLBAnalyzer <span class="op">{</span></span>
<span id="lst-simul1-218"><a href="#lst-simul1-218" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="lst-simul1-219"><a href="#lst-simul1-219" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>TLBSimulator<span class="op">&gt;&gt;</span> <span class="va">simulators_</span><span class="op">;</span> <span class="co">///&lt; Simuladores para comparar</span></span>
<span id="lst-simul1-220"><a href="#lst-simul1-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-221"><a href="#lst-simul1-221" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="lst-simul1-222"><a href="#lst-simul1-222" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-223"><a href="#lst-simul1-223" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Adiciona simulador à análise</span></span>
<span id="lst-simul1-224"><a href="#lst-simul1-224" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">simulator</span><span class="co"> Simulador único para análise</span></span>
<span id="lst-simul1-225"><a href="#lst-simul1-225" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-226"><a href="#lst-simul1-226" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> addSimulator<span class="op">(</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>TLBSimulator<span class="op">&gt;</span> simulator<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-227"><a href="#lst-simul1-227" aria-hidden="true" tabindex="-1"></a>        <span class="va">simulators_</span><span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>simulator<span class="op">));</span></span>
<span id="lst-simul1-228"><a href="#lst-simul1-228" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-229"><a href="#lst-simul1-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-230"><a href="#lst-simul1-230" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="lst-simul1-231"><a href="#lst-simul1-231" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@brief</span><span class="co"> Executa análise comparativa</span></span>
<span id="lst-simul1-232"><a href="#lst-simul1-232" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">pattern</span><span class="co"> Padrão de acesso à memória</span></span>
<span id="lst-simul1-233"><a href="#lst-simul1-233" aria-hidden="true" tabindex="-1"></a><span class="co">     * </span><span class="an">@param</span><span class="co"> </span><span class="cv">num_accesses</span><span class="co"> Número de acessos para simular</span></span>
<span id="lst-simul1-234"><a href="#lst-simul1-234" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="lst-simul1-235"><a href="#lst-simul1-235" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> runComparison<span class="op">(</span>AccessPattern pattern<span class="op">,</span> <span class="dt">size_t</span> num_accesses <span class="op">=</span> <span class="dv">10000</span><span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-236"><a href="#lst-simul1-236" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">=== Análise Comparativa de TLB ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="lst-simul1-237"><a href="#lst-simul1-237" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Padrão de acesso: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-simul1-238"><a href="#lst-simul1-238" aria-hidden="true" tabindex="-1"></a>            pattern <span class="op">==</span> AccessPattern<span class="op">::</span>SEQUENTIAL <span class="op">?</span> <span class="st">"Sequencial"</span> <span class="op">:</span></span>
<span id="lst-simul1-239"><a href="#lst-simul1-239" aria-hidden="true" tabindex="-1"></a>            pattern <span class="op">==</span> AccessPattern<span class="op">::</span>RANDOM <span class="op">?</span> <span class="st">"Aleatório"</span> <span class="op">:</span></span>
<span id="lst-simul1-240"><a href="#lst-simul1-240" aria-hidden="true" tabindex="-1"></a>            pattern <span class="op">==</span> AccessPattern<span class="op">::</span>STRIDE <span class="op">?</span> <span class="st">"Stride"</span> <span class="op">:</span> <span class="st">"Misto"</span><span class="op">);</span></span>
<span id="lst-simul1-241"><a href="#lst-simul1-241" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Número de acessos: </span><span class="sc">{}\n\n</span><span class="st">"</span><span class="op">,</span> num_accesses<span class="op">);</span></span>
<span id="lst-simul1-242"><a href="#lst-simul1-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-243"><a href="#lst-simul1-243" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">simulators_</span><span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-244"><a href="#lst-simul1-244" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span><span class="op">&amp;</span> sim <span class="op">=</span> <span class="va">simulators_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="lst-simul1-245"><a href="#lst-simul1-245" aria-hidden="true" tabindex="-1"></a>            sim<span class="op">-&gt;</span>reset<span class="op">();</span></span>
<span id="lst-simul1-246"><a href="#lst-simul1-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-247"><a href="#lst-simul1-247" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Gera padrão de acesso apropriado</span></span>
<span id="lst-simul1-248"><a href="#lst-simul1-248" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> addresses<span class="op">;</span></span>
<span id="lst-simul1-249"><a href="#lst-simul1-249" aria-hidden="true" tabindex="-1"></a>            <span class="cf">switch</span> <span class="op">(</span>pattern<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-250"><a href="#lst-simul1-250" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> AccessPattern<span class="op">::</span>SEQUENTIAL<span class="op">:</span></span>
<span id="lst-simul1-251"><a href="#lst-simul1-251" aria-hidden="true" tabindex="-1"></a>                addresses <span class="op">=</span> sim<span class="op">-&gt;</span>generateSequentialPattern<span class="op">(</span><span class="bn">0x10000000</span><span class="op">,</span> num_accesses<span class="op">);</span></span>
<span id="lst-simul1-252"><a href="#lst-simul1-252" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="lst-simul1-253"><a href="#lst-simul1-253" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> AccessPattern<span class="op">::</span>RANDOM<span class="op">:</span></span>
<span id="lst-simul1-254"><a href="#lst-simul1-254" aria-hidden="true" tabindex="-1"></a>                addresses <span class="op">=</span> sim<span class="op">-&gt;</span>generateRandomPattern<span class="op">(</span>num_accesses<span class="op">);</span></span>
<span id="lst-simul1-255"><a href="#lst-simul1-255" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="lst-simul1-256"><a href="#lst-simul1-256" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> AccessPattern<span class="op">::</span>STRIDE<span class="op">:</span></span>
<span id="lst-simul1-257"><a href="#lst-simul1-257" aria-hidden="true" tabindex="-1"></a>                addresses <span class="op">=</span> sim<span class="op">-&gt;</span>generateSequentialPattern<span class="op">(</span><span class="bn">0x10000000</span><span class="op">,</span> num_accesses<span class="op">,</span> <span class="dv">8192</span><span class="op">);</span></span>
<span id="lst-simul1-258"><a href="#lst-simul1-258" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="lst-simul1-259"><a href="#lst-simul1-259" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> AccessPattern<span class="op">::</span>MIXED<span class="op">:</span></span>
<span id="lst-simul1-260"><a href="#lst-simul1-260" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Metade sequencial, metade aleatória</span></span>
<span id="lst-simul1-261"><a href="#lst-simul1-261" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> seq <span class="op">=</span> sim<span class="op">-&gt;</span>generateSequentialPattern<span class="op">(</span><span class="bn">0x10000000</span><span class="op">,</span> num_accesses <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="lst-simul1-262"><a href="#lst-simul1-262" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> rand <span class="op">=</span> sim<span class="op">-&gt;</span>generateRandomPattern<span class="op">(</span>num_accesses <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="lst-simul1-263"><a href="#lst-simul1-263" aria-hidden="true" tabindex="-1"></a>                addresses<span class="op">.</span>insert<span class="op">(</span>addresses<span class="op">.</span>end<span class="op">(),</span> seq<span class="op">.</span>begin<span class="op">(),</span> seq<span class="op">.</span>end<span class="op">());</span></span>
<span id="lst-simul1-264"><a href="#lst-simul1-264" aria-hidden="true" tabindex="-1"></a>                addresses<span class="op">.</span>insert<span class="op">(</span>addresses<span class="op">.</span>end<span class="op">(),</span> rand<span class="op">.</span>begin<span class="op">(),</span> rand<span class="op">.</span>end<span class="op">());</span></span>
<span id="lst-simul1-265"><a href="#lst-simul1-265" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="lst-simul1-266"><a href="#lst-simul1-266" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-simul1-267"><a href="#lst-simul1-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-268"><a href="#lst-simul1-268" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Executa simulação</span></span>
<span id="lst-simul1-269"><a href="#lst-simul1-269" aria-hidden="true" tabindex="-1"></a>            sim<span class="op">-&gt;</span>runSimulation<span class="op">(</span>addresses<span class="op">);</span></span>
<span id="lst-simul1-270"><a href="#lst-simul1-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-271"><a href="#lst-simul1-271" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Coleta e exibe resultados</span></span>
<span id="lst-simul1-272"><a href="#lst-simul1-272" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> metrics <span class="op">=</span> sim<span class="op">-&gt;</span>getMetrics<span class="op">();</span></span>
<span id="lst-simul1-273"><a href="#lst-simul1-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-274"><a href="#lst-simul1-274" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"--- Simulador </span><span class="sc">{}</span><span class="st"> ---</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="lst-simul1-275"><a href="#lst-simul1-275" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Total de acessos: </span><span class="sc">{}\n</span><span class="st">"</span><span class="op">,</span> metrics<span class="op">.</span>total_accesses<span class="op">);</span></span>
<span id="lst-simul1-276"><a href="#lst-simul1-276" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"TLB Hits: </span><span class="sc">{}</span><span class="st"> ({:.f}%)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-simul1-277"><a href="#lst-simul1-277" aria-hidden="true" tabindex="-1"></a>                metrics<span class="op">.</span>tlb_hits<span class="op">,</span> metrics<span class="op">.</span>getHitRate<span class="op">()</span> <span class="op">*</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="lst-simul1-278"><a href="#lst-simul1-278" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"TLB Misses: </span><span class="sc">{}</span><span class="st"> ({:.f}%)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-simul1-279"><a href="#lst-simul1-279" aria-hidden="true" tabindex="-1"></a>                metrics<span class="op">.</span>tlb_misses<span class="op">,</span> metrics<span class="op">.</span>getMissRate<span class="op">()</span> <span class="op">*</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="lst-simul1-280"><a href="#lst-simul1-280" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Tempo TLB Hit: {:.f} ciclos</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> metrics<span class="op">.</span>tlb_hit_time<span class="op">);</span></span>
<span id="lst-simul1-281"><a href="#lst-simul1-281" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Tempo Page Table: {:.f} ciclos</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> metrics<span class="op">.</span>page_table_access_time<span class="op">);</span></span>
<span id="lst-simul1-282"><a href="#lst-simul1-282" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Tempo Efetivo de Acesso: {:.f} ciclos</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-simul1-283"><a href="#lst-simul1-283" aria-hidden="true" tabindex="-1"></a>                metrics<span class="op">.</span>getEffectiveAccessTime<span class="op">());</span></span>
<span id="lst-simul1-284"><a href="#lst-simul1-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-285"><a href="#lst-simul1-285" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Calcula impacto da performance</span></span>
<span id="lst-simul1-286"><a href="#lst-simul1-286" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> ideal_time <span class="op">=</span> metrics<span class="op">.</span>tlb_hit_time<span class="op">;</span></span>
<span id="lst-simul1-287"><a href="#lst-simul1-287" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> overhead <span class="op">=</span> <span class="op">(</span>metrics<span class="op">.</span>getEffectiveAccessTime<span class="op">()</span> <span class="op">-</span> ideal_time<span class="op">)</span> <span class="op">/</span> ideal_time <span class="op">*</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="lst-simul1-288"><a href="#lst-simul1-288" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Custo computacional extra devido a TLB misses: {:.f}%</span><span class="sc">\n\n</span><span class="st">"</span><span class="op">,</span> overhead<span class="op">);</span></span>
<span id="lst-simul1-289"><a href="#lst-simul1-289" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-290"><a href="#lst-simul1-290" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-291"><a href="#lst-simul1-291" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="lst-simul1-292"><a href="#lst-simul1-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-293"><a href="#lst-simul1-293" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-simul1-294"><a href="#lst-simul1-294" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Demonstra diferentes cenários de working set</span></span>
<span id="lst-simul1-295"><a href="#lst-simul1-295" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-simul1-296"><a href="#lst-simul1-296" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> demonstrateWorkingSetImpact<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-simul1-297"><a href="#lst-simul1-297" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> === Demonstração: Impacto do Working Set ===</span><span class="sc">\n\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-298"><a href="#lst-simul1-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-299"><a href="#lst-simul1-299" aria-hidden="true" tabindex="-1"></a>    <span class="co">// TLB pequena com 64 entradas</span></span>
<span id="lst-simul1-300"><a href="#lst-simul1-300" aria-hidden="true" tabindex="-1"></a>    TLBSimulator small_tlb<span class="op">(</span><span class="dv">64</span><span class="op">,</span> <span class="fl">1.</span><span class="op">,</span> <span class="fl">100.</span><span class="op">);</span></span>
<span id="lst-simul1-301"><a href="#lst-simul1-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-302"><a href="#lst-simul1-302" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">&gt;</span> working_set_sizes <span class="op">=</span> <span class="op">{</span> <span class="dv">32</span><span class="op">,</span> <span class="dv">64</span><span class="op">,</span> <span class="dv">128</span><span class="op">,</span> <span class="dv">256</span><span class="op">,</span> <span class="dv">512</span> <span class="op">};</span></span>
<span id="lst-simul1-303"><a href="#lst-simul1-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-304"><a href="#lst-simul1-304" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> ws_size <span class="op">:</span> working_set_sizes<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-305"><a href="#lst-simul1-305" aria-hidden="true" tabindex="-1"></a>        small_tlb<span class="op">.</span>reset<span class="op">();</span></span>
<span id="lst-simul1-306"><a href="#lst-simul1-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-307"><a href="#lst-simul1-307" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Gera working set: acessa as mesmas páginas repetidamente</span></span>
<span id="lst-simul1-308"><a href="#lst-simul1-308" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> addresses<span class="op">;</span></span>
<span id="lst-simul1-309"><a href="#lst-simul1-309" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iteration <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iteration <span class="op">&lt;</span> <span class="dv">100</span><span class="op">;</span> <span class="op">++</span>iteration<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-310"><a href="#lst-simul1-310" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> page <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> page <span class="op">&lt;</span> ws_size<span class="op">;</span> <span class="op">++</span>page<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-311"><a href="#lst-simul1-311" aria-hidden="true" tabindex="-1"></a>                addresses<span class="op">.</span>push_back<span class="op">(</span>page <span class="op">*</span> <span class="dv">4096</span><span class="op">);</span> <span class="co">// Páginas de 4KB</span></span>
<span id="lst-simul1-312"><a href="#lst-simul1-312" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst-simul1-313"><a href="#lst-simul1-313" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="lst-simul1-314"><a href="#lst-simul1-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-315"><a href="#lst-simul1-315" aria-hidden="true" tabindex="-1"></a>        small_tlb<span class="op">.</span>runSimulation<span class="op">(</span>addresses<span class="op">);</span></span>
<span id="lst-simul1-316"><a href="#lst-simul1-316" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> metrics <span class="op">=</span> small_tlb<span class="op">.</span>getMetrics<span class="op">();</span></span>
<span id="lst-simul1-317"><a href="#lst-simul1-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-318"><a href="#lst-simul1-318" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"Working Set: </span><span class="sc">{}</span><span class="st"> páginas | TLB Hit Rate: {:.f}% | "</span></span>
<span id="lst-simul1-319"><a href="#lst-simul1-319" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Tempo Efetivo: {:.f} ciclos</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-simul1-320"><a href="#lst-simul1-320" aria-hidden="true" tabindex="-1"></a>            ws_size<span class="op">,</span> metrics<span class="op">.</span>getHitRate<span class="op">()</span> <span class="op">*</span> <span class="dv">100</span><span class="op">,</span></span>
<span id="lst-simul1-321"><a href="#lst-simul1-321" aria-hidden="true" tabindex="-1"></a>            metrics<span class="op">.</span>getEffectiveAccessTime<span class="op">());</span></span>
<span id="lst-simul1-322"><a href="#lst-simul1-322" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-323"><a href="#lst-simul1-323" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="lst-simul1-324"><a href="#lst-simul1-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-325"><a href="#lst-simul1-325" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="lst-simul1-326"><a href="#lst-simul1-326" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@brief</span><span class="co"> Função principal demonstrando o uso do simulador</span></span>
<span id="lst-simul1-327"><a href="#lst-simul1-327" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="lst-simul1-328"><a href="#lst-simul1-328" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="lst-simul1-329"><a href="#lst-simul1-329" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"=== Simulador de Performance TLB - C++23 ===</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-330"><a href="#lst-simul1-330" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Implementação da fórmula: Effective Access Time = TLB Hit Time + TLB Miss Rate × Page Table Access Time</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-331"><a href="#lst-simul1-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-332"><a href="#lst-simul1-332" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cria analisador</span></span>
<span id="lst-simul1-333"><a href="#lst-simul1-333" aria-hidden="true" tabindex="-1"></a>    TLBAnalyzer analyzer<span class="op">;</span></span>
<span id="lst-simul1-334"><a href="#lst-simul1-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-335"><a href="#lst-simul1-335" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Adiciona diferentes configurações de TLB</span></span>
<span id="lst-simul1-336"><a href="#lst-simul1-336" aria-hidden="true" tabindex="-1"></a>    analyzer<span class="op">.</span>addSimulator<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>TLBSimulator<span class="op">&gt;(</span><span class="dv">64</span><span class="op">,</span> <span class="fl">1.</span><span class="op">,</span> <span class="fl">100.</span><span class="op">));</span>   <span class="co">// TLB pequena</span></span>
<span id="lst-simul1-337"><a href="#lst-simul1-337" aria-hidden="true" tabindex="-1"></a>    analyzer<span class="op">.</span>addSimulator<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>TLBSimulator<span class="op">&gt;(</span><span class="dv">256</span><span class="op">,</span> <span class="fl">2.</span><span class="op">,</span> <span class="fl">100.</span><span class="op">));</span>  <span class="co">// TLB média</span></span>
<span id="lst-simul1-338"><a href="#lst-simul1-338" aria-hidden="true" tabindex="-1"></a>    analyzer<span class="op">.</span>addSimulator<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>TLBSimulator<span class="op">&gt;(</span><span class="dv">1024</span><span class="op">,</span> <span class="fl">5.</span><span class="op">,</span> <span class="fl">100.</span><span class="op">));</span> <span class="co">// TLB grande</span></span>
<span id="lst-simul1-339"><a href="#lst-simul1-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-340"><a href="#lst-simul1-340" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Testa diferentes padrões</span></span>
<span id="lst-simul1-341"><a href="#lst-simul1-341" aria-hidden="true" tabindex="-1"></a>    analyzer<span class="op">.</span>runComparison<span class="op">(</span>AccessPattern<span class="op">::</span>SEQUENTIAL<span class="op">,</span> <span class="dv">5000</span><span class="op">);</span></span>
<span id="lst-simul1-342"><a href="#lst-simul1-342" aria-hidden="true" tabindex="-1"></a>    analyzer<span class="op">.</span>runComparison<span class="op">(</span>AccessPattern<span class="op">::</span>RANDOM<span class="op">,</span> <span class="dv">5000</span><span class="op">);</span></span>
<span id="lst-simul1-343"><a href="#lst-simul1-343" aria-hidden="true" tabindex="-1"></a>    analyzer<span class="op">.</span>runComparison<span class="op">(</span>AccessPattern<span class="op">::</span>MIXED<span class="op">,</span> <span class="dv">5000</span><span class="op">);</span></span>
<span id="lst-simul1-344"><a href="#lst-simul1-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-345"><a href="#lst-simul1-345" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Demonstra impacto do working set</span></span>
<span id="lst-simul1-346"><a href="#lst-simul1-346" aria-hidden="true" tabindex="-1"></a>    demonstrateWorkingSetImpact<span class="op">();</span></span>
<span id="lst-simul1-347"><a href="#lst-simul1-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-348"><a href="#lst-simul1-348" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Análise matemática da fórmula</span></span>
<span id="lst-simul1-349"><a href="#lst-simul1-349" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">=== Análise Matemática da Fórmula ===</span><span class="sc">\n\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-350"><a href="#lst-simul1-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-351"><a href="#lst-simul1-351" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tlb_hit_time <span class="op">=</span> <span class="fl">2.</span><span class="op">;</span></span>
<span id="lst-simul1-352"><a href="#lst-simul1-352" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> page_table_time <span class="op">=</span> <span class="fl">100.</span><span class="op">;</span></span>
<span id="lst-simul1-353"><a href="#lst-simul1-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-354"><a href="#lst-simul1-354" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> miss_rates <span class="op">=</span> <span class="op">{</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">0.</span> <span class="op">};</span></span>
<span id="lst-simul1-355"><a href="#lst-simul1-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-356"><a href="#lst-simul1-356" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Miss Rate | Effective Time | Overhead</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-357"><a href="#lst-simul1-357" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"----------|----------------|----------</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-358"><a href="#lst-simul1-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-359"><a href="#lst-simul1-359" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">double</span> miss_rate <span class="op">:</span> miss_rates<span class="op">)</span> <span class="op">{</span></span>
<span id="lst-simul1-360"><a href="#lst-simul1-360" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> effective_time <span class="op">=</span> tlb_hit_time <span class="op">+</span> <span class="op">(</span>miss_rate <span class="op">*</span> page_table_time<span class="op">);</span></span>
<span id="lst-simul1-361"><a href="#lst-simul1-361" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> overhead <span class="op">=</span> <span class="op">((</span>effective_time <span class="op">-</span> tlb_hit_time<span class="op">)</span> <span class="op">/</span> tlb_hit_time<span class="op">)</span> <span class="op">*</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="lst-simul1-362"><a href="#lst-simul1-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-363"><a href="#lst-simul1-363" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">"{:8.f}% | {:13.f} | {:7.f}%</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="lst-simul1-364"><a href="#lst-simul1-364" aria-hidden="true" tabindex="-1"></a>            miss_rate <span class="op">*</span> <span class="dv">100</span><span class="op">,</span> effective_time<span class="op">,</span> overhead<span class="op">);</span></span>
<span id="lst-simul1-365"><a href="#lst-simul1-365" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst-simul1-366"><a href="#lst-simul1-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-367"><a href="#lst-simul1-367" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">💡 Conclusões:</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-368"><a href="#lst-simul1-368" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• TLB miss rate tem impacto dramático na performance</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-369"><a href="#lst-simul1-369" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Working sets pequenos maximizam TLB hit rate</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-370"><a href="#lst-simul1-370" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• TLBs maiores reduzem miss rate mas aumentam hit time</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-371"><a href="#lst-simul1-371" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"• Localidade de acesso é fundamental para eficiência</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="lst-simul1-372"><a href="#lst-simul1-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-simul1-373"><a href="#lst-simul1-373" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="lst-simul1-374"><a href="#lst-simul1-374" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p>O simulador <strong>TLB</strong> implementado no código <a href="#lst-simul1" class="quarto-xref">Listing&nbsp;<span>10.1</span></a> implementa uma representação simplificada, mas funcionalmente precisa do comportamento de uma <em><strong>T</strong>ranslation <strong>L</strong>ookaside <strong>B</strong>uffer</em>, <strong>TLB</strong>. A classe <code>TLBSimulator</code> encapsula toda a lógica necessária através de uma estrutura de dados <code>std::unordered_map&lt;uint64_t, bool&gt;</code> que simula o cache da <strong>TLB</strong>, no qual as chaves representam números de páginas virtuais e os valores indicam presença no <code>cache</code>. O construtor inicializa os parâmetros fundamentais: <code>tlb_size_</code> define o número máximo de entradas que a <strong>TLB</strong> pode armazenar, <code>tlb_hit_time</code> especifica a latência em ciclos para acessos bem-sucedidos, e <code>page_table_access_time</code> determina o custo temporal de um <em>page table walk</em> completo. A política de substituição <strong>LRU</strong> é implementada de forma simplificada através do método <code>evictOldestEntry()</code>, que remove a primeira entrada quando o <code>cache</code> atinge capacidade máxima.</p>
<p>A simulação processa vetores de endereços virtuais gerados por diferentes padrões de acesso através do método <code>runSimulation()</code>. Para cada endereço no vetor, o método <code>accessMemory()</code> extrai o número da página virtual usando operação de <em>bit shift</em> <code>virtual_address &gt;&gt; 12</code>, assumindo páginas de <span class="math inline">\(4KB\)</span> conforme padrão em arquiteturas <span class="math inline">\(x86-64\)</span>. A decisão crítica ocorre na verificação <code>tlb_cache_.contains(page_number)</code>: se a página está presente na <strong>TLB</strong>, incrementa-se o contador de <em>hits</em> e retorna-se <code>true</code> indicando acesso rápido; caso contrário, incrementa-se o contador de <em>misses</em>, simula-se o acesso à tabela de páginas, e adiciona-se a nova entrada na <strong>TLB</strong> após possível remoção. Este processo replica fielmente o comportamento de hardware real, no qual cada acesso à memória virtual deve ser outraduzido para endereço físico.</p>
<section id="sec-vasproc1" class="level3" data-number="10.9.1">
<h3 data-number="10.9.1" class="anchored" data-anchor-id="sec-vasproc1"><span class="header-section-number">10.9.1</span> Anatomia do Espaço de Endereçamento de um Processo</h3>
<p>O Espaço de Endereçamento Virtual disponível para um determinado processo não é um bloco monolítico; ele é convencionalmente organizado em segmentos distintos, cada um com um propósito específico e atributos de proteção de memória, permissões de leitura, escrita e execução. O Espaço de Endereçamento mais comum é chamado de <strong>V</strong>irtual <strong>A</strong>ddress <strong>S</strong>pace<strong>, </strong>VAS<strong>. O </strong>VAS** é a visão do processo sobre a memória e é dividido em várias regiões, cada uma com características específicas:</p>
<ol type="1">
<li><p><strong>Segmento de Texto (.text)</strong>: contém as instruções de máquina executáveis do programa. Esta região é quase universalmente marcada como somente leitura e executável. A permissão de somente leitura impede que um programa modifique acidentalmente ou maliciosamente seu próprio código durante a execução.</p></li>
<li><p><strong>Segmento de Dados (.data)</strong>: armazena variáveis globais e estáticas que são explicitamente inicializadas pelo programador no código-fonte. Os valores iniciais para essas variáveis são lidos do arquivo executável pelo carregador do <strong>Sistema Operacional</strong> quando o processo é iniciado. Este segmento é tipicamente marcado como leitura/escrita.</p></li>
<li><p><strong>Segmento BSS (.bss)</strong>: o nome deste segmento vem de uma antiga diretiva de montador, <em><strong>B</strong>lock <strong>S</strong>tarted by <strong>S</strong>ymbol</em>. Este segmento detém variáveis globais e estáticas não inicializadas. O carregador aloca espaço para este segmento na memória, mas como otimização, não carrega nenhum dado do arquivo executável. Em vez disso, o <strong>Sistema Operacional</strong> garante que toda essa região de memória seja preenchida com zeros antes que a função <em>main</em> do programa seja chamada. Isso reduz o tamanho do arquivo executável no disco.</p></li>
<li><p><strong>Heap</strong>: É uma região de memória para alocação dinâmica. A memória no <code>heap</code> é solicitada em tempo de execução pelo programa usando funções como <code>malloc()</code> em C ou o operador <code>new</code> em C++. O <code>heap</code> geralmente cresce para cima, a partir de endereços mais baixos em direção a endereços mais altos. A memória alocada no <code>heap</code> persiste entre as chamadas de função e deve ser explicitamente liberada pelo programador, usando <code>free()</code> ou <code>delete</code>, respectivamente, para evitar vazamentos de memória.</p></li>
<li><p><strong>Pilha (<code>Stack</code>)</strong>: É usada para gerenciar chamadas de função. Cada vez que uma função é invocada, um <em>stack frame</em> é empurrado para a pilha. Este quadro contém as variáveis locais da função, os parâmetros passados para ela e o endereço de retorno, o local no código para o qual a execução deve voltar quando a função terminar. A pilha geralmente cresce para baixo, de endereços altos para endereços mais baixos, em direção ao <code>heap</code>. A memória na pilha é gerenciada automaticamente; ela é alocada quando as funções são chamadas e liberada quando elas retornam. <em>É importante notar que cada <code>thread</code> dentro de um processo possui sua própria pilha privada</em>.</p></li>
</ol>
<p>A organização do <strong>VAS</strong> não é uma convenção arbitrária, mas sim um contrato fundamental que permite que a cadeia de ferramentas de desenvolvimento e o <strong>Sistema Operacional</strong> colaborem de forma eficaz. tradicionalmente o processo começa com o compilador, que gera o código objeto e posiciona as instruções e variáveis nas seções apropriadas, <code>.text</code>, <code>.data</code>, <code>.bss</code>, com base em sua natureza. Em seguida, o <em>linker</em> combina múltiplos arquivos objeto, resolve referências simbólicas e organiza as seções finais em um layout de memória que adere ao mapa convencional, codificando essa estrutura no formato de arquivo executável, <strong>ELF</strong> para o <strong>Windows</strong> ou <strong>PE</strong> para o Linux. Finalmente, o carregador do <strong>Sistema Operacional</strong> lê este arquivo executável. Ele interpreta a estrutura do arquivo para mapear o segmento de texto como somente leitura e executável, o segmento de dados como leitura/escrita, e para alocar e zerar o segmento <strong>BSS</strong>. Enquanto isso, a biblioteca de tempo de execução e a lógica do próprio programa gerenciam o <code>heap</code> e a pilha dentro das regiões designadas pelo <strong>Sistema Operacional</strong>, cientes de sua direção de crescimento oposta. Essa separação de responsabilidades, formalizada no layout do <strong>VAS</strong> e no formato do arquivo executável, permite que cada componente execute sua função de forma independente, usando o layout do <strong>VAS</strong> como uma linguagem comum.</p>
</section>
</section>
<section id="parte-ii-o-modelo-linux-um-estudo-em-composição" class="level2" data-number="10.10">
<h2 data-number="10.10" class="anchored" data-anchor-id="parte-ii-o-modelo-linux-um-estudo-em-composição"><span class="header-section-number">10.10</span> <strong>Parte II: O Modelo Linux: Um Estudo em Composição</strong></h2>
<section id="o-layout-de-memória-virtual-do-linux-x86-64" class="level3" data-number="10.10.1">
<h3 data-number="10.10.1" class="anchored" data-anchor-id="o-layout-de-memória-virtual-do-linux-x86-64"><span class="header-section-number">10.10.1</span> <strong>2. O Layout de Memória Virtual do </strong>Linux** (x86-64)**</h3>
<p>Em sistemas <strong>Linux</strong> modernos em execução na arquitetura x86-64, o espaço de endereçamento virtual é vasto, mas rigidamente estruturado. Os processadores x86-64 atuais usam endereçamento virtual de 48 bits, não os 64 bits completos. Os endereços válidos dentro deste esquema de 48 bits são chamados de “endereços canônicos”. O espaço de endereço é dividido em duas regiões distintas, separadas por um grande “buraco” não canônico:</p>
<ul>
<li><strong>Espaço do Usuário (Endereços Canônicos Baixos)</strong>: Esta região se estende de <code>0x0000'0000'0000'0000</code> a <code>0x0000'7FFF'FFFF'FFFF</code>, oferecendo um espaço de endereço teórico de 128 TB para cada processo de usuário. Este é o espaço privado no qual o código, os dados, o <code>heap</code> e a pilha do aplicativo residem.<br>
</li>
<li><strong>Espaço do <code>Kernel</code> (Endereços Canônicos Altos)</strong>: Esta região vai de <code>0xFFFF'8000'0000'0000</code> a <code>0xFFFF'FFFF'FFFF'FFFF</code>. Embora este espaço seja mapeado no espaço de endereço de cada processo, ele só pode ser acessado quando a <code>CPU</code> está em modo <code>Kernel</code> (privilegiado). Ele contém o código do <code>Kernel</code>, dados, drivers e outras estruturas do sistema. O buraco entre essas duas regiões é inválido, e qualquer tentativa de acessá-lo resultará em uma falha de proteção geral.</li>
</ul>
<p>Para aumentar a segurança, o <strong>Linux</strong> implementa a Randomização do Layout do Espaço de Endereçamento do <code>Kernel</code> (KASLR). Se habilitado (CONFIG_RANDOMIZE_MEMORY), o endereço base das principais regiões do <code>Kernel</code>, como o mapeamento direto da memória física e o espaço vmalloc, é randomizado a cada inicialização. Isso torna significativamente mais difícil para um invasor prever a localização de código ou dados do <code>Kernel</code> para explorar vulnerabilidades.</p>
<p>Além disso, o <code>Kernel</code> mapeia duas regiões especiais no espaço do usuário para otimizar certas operações:</p>
<ul>
<li><strong>vDSO (virtual Dynamic Shared Object)</strong>: Uma pequena biblioteca compartilhada que o <code>Kernel</code> mapeia no espaço de endereço de cada processo. Ela contém implementações de chamadas de sistema selecionadas (como<br>
gettimeofday) que podem ser executadas inteiramente no espaço do usuário, evitando o custo de uma transição de modo de sistema.<br>
</li>
<li><strong>[vsyscall]</strong>: Um mecanismo legado para chamadas de sistema rápidas, agora amplamente preterido em favor do vDSO mais flexível e seguro. Ele geralmente aparece como uma única página em um endereço fixo.</li>
</ul>
</section>
<section id="de-arquivo-para-memória-o-formato-executável-e-ligável-elf" class="level3" data-number="10.10.2">
<h3 data-number="10.10.2" class="anchored" data-anchor-id="de-arquivo-para-memória-o-formato-executável-e-ligável-elf"><span class="header-section-number">10.10.2</span> <strong>2. De Arquivo para Memória: O Formato Executável e Ligável (ELF)</strong></h3>
<p>O Executable and Linkable Format (ELF) é o formato de arquivo binário padrão para executáveis, código objeto, bibliotecas compartilhadas e core dumps no <strong>Linux</strong> e na maioria dos outros sistemas do tipo <strong>UNIX</strong>. Desenvolvido pela UNIX System Laboratories (USL), ele foi projetado para ser mais poderoso e flexível do que formatos mais antigos, como o</p>
<p>a.out.</p>
<p>Uma característica de design fundamental do ELF é sua “visão dupla” do conteúdo do arquivo, que atende a dois propósitos distintos: ligação e execução.</p>
<ul>
<li><strong>Visão de Ligação (<em>Linking View</em>)</strong>: Para o ligador (como o ld), um arquivo ELF é uma coleção de <strong>seções</strong> (<em>sections</em>). As seções contêm blocos discretos de informações, como código executável (.text), dados inicializados (.data), dados somente leitura (.rodata), a tabela de símbolos (.symtab) e informações de relocação (.rel.text). O ligador usa essas seções para combinar múltiplos arquivos objeto em um único executável ou biblioteca compartilhada. As informações sobre todas as seções são armazenadas na<br>
<strong>Tabela de Cabeçalhos de Seção</strong> (<em>Section Header Table</em>).<br>
</li>
<li><strong>Visão de Execução (<em>Execution View</em>)</strong>: Para o carregador do <strong>Sistema Operacional</strong>, um arquivo ELF é uma coleção de <strong>segmentos</strong> (<em>segments</em>). Um segmento é uma coleção de uma ou mais seções que são tratadas como uma única unidade para fins de carregamento na memória. O carregador está interessado em como mapear partes do arquivo na memória e definir suas permissões. Por exemplo, um segmento LOAD executável pode conter as seções .text, .rodata e outras seções somente leitura. As informações sobre os segmentos são armazenadas na Tabela de Cabeçalhos de Programa, em inglês Program Header Table.</li>
</ul>
<p>A estrutura de um arquivo ELF é definida por seus cabeçalhos:</p>
<ul>
<li><strong>Cabeçalho ELF</strong>: Localizado no início do arquivo, ele atua como um “mapa rodoviário”. Começa com o número mágico<br>
<code>0x7F</code> seguido pelos caracteres ASCII “ELF”. Ele especifica a arquitetura (32 ou 64 bits), a ordenação de bytes (<br>
<em>endianness</em>), o tipo de arquivo (ET_EXEC para executável, ET_DYN para biblioteca compartilhada, ET_REL para arquivo relocável), o endereço do ponto de entrada do programa e os deslocamentos no arquivo para as Tabelas de Cabeçalhos de Programa e de Seção.<br>
</li>
<li><strong>Tabela de Cabeçalhos de Programa (PHT)</strong>: Essencial para a execução, esta tabela é uma série de entradas que descrevem os segmentos do arquivo. A entrada mais importante é do tipo<br>
PT_LOAD, que instrui o carregador a mapear uma porção do arquivo para a memória. Cada entrada PT_LOAD especifica o deslocamento do segmento no arquivo (p_offset), o endereço virtual de destino (p_vaddr), o tamanho no arquivo (p_filesz), o tamanho na memória (p_memsz — que pode ser maior que p_filesz para acomodar o segmento .bss), e as permissões de memória (p_flags: Leitura, Escrita, Execução).<br>
</li>
<li><strong>Ligação Dinâmica</strong>: Para executáveis ligados dinamicamente, a PHT contém uma entrada PT_INTERP que especifica o caminho para o ligador dinâmico (por exemplo, /lib64/ld-linux-x86-64.so.). O <code>Kernel</code> primeiro carrega e executa este interpretador. O ligador dinâmico então usa as informações contidas na seção .dynamic do executável para carregar todas as bibliotecas compartilhadas (.so) necessárias e realizar as relocações de tempo de execução para resolver os endereços dos símbolos.</li>
</ul>
</section>
<section id="criação-de-processos-o-paradigma-fork-e-exec-1" class="level3" data-number="10.10.3">
<h3 data-number="10.10.3" class="anchored" data-anchor-id="criação-de-processos-o-paradigma-fork-e-exec-1"><span class="header-section-number">10.10.3</span> <strong>2. Criação de Processos: O Paradigma fork() e exec()</strong></h3>
<p>O modelo de criação de processos no <strong>Linux</strong>, herdado do UNIX, é um processo de duas etapas que separa a criação de um novo processo da execução de um novo programa. Este modelo é realizado por meio de um conjunto de chamadas de sistema fundamentais.</p>
<ul>
<li><strong>fork() - Clonando um Processo</strong>: A chamada de sistema fork() cria um novo processo (o filho) que é uma cópia quase idêntica do processo que o cham (o pai). O processo filho herda uma cópia do espaço de endereço virtual do pai, descritores de arquivo abertos, diretório de trabalho atual e outros atributos de contexto. Para tornar essa operação eficiente, os sistemas modernos implementam<br>
fork() usando uma técnica de otimização chamada <strong>Copy-on-Write (COW)</strong>. Com COW, o espaço de endereço não é fisicamente duplicado no momento do fork(). Em vez disso, pai e filho compartilham as mesmas páginas de memória física, que são marcadas como somente leitura. Uma cópia física da página só é criada quando um dos processos tenta escrever nela, tornando o fork() extremamente rápido. A chamada<br>
fork() é única, pois retorna duas vezes: retorna 0 no processo filho e o ID do processo (PID) do filho recém-criado no processo pai. Um valor de retorno negativo indica que a criação do processo falhou.<br>
</li>
<li><strong>Família exec() - Substituindo a Imagem do Processo</strong>: Após um fork(), o processo filho geralmente precisa executar um programa diferente. A família de chamadas de sistema exec (incluindo execv, execl, execvp, etc.) serve a este propósito. Uma chamada exec substitui a imagem de memória do processo atual pelo novo programa especificado. Ela descarta os segmentos de texto, dados, BSS, <code>heap</code> e pilha existentes e carrega novos a partir do arquivo executável. O <strong>PID</strong> do processo não muda, pois nenhum novo processo é criado; o processo existente é simplesmente transformado. Se uma chamada<br>
exec for bem-sucedida, ela <em>nunca retorna</em> ao código que a cham , pois esse código foi substituído.<br>
</li>
<li><strong>Família wait() - Sincronização e Coleta</strong>: As chamadas de sistema wait() e waitpid() são os principais mecanismos para um processo pai gerenciar seus filhos. Elas permitem que um pai suspenda sua própria execução até que um de seus filhos termine. Isso serve a dois propósitos: sincronização e coleta do status de saída do filho. Também é essencial para “coletar” (<br>
<em>reaping</em>) processos filhos terminados. Um processo que terminou mas cujo pai ainda não cham wait() entra em um estado “zumbi”. Ele não está mais em execução, mas sua entrada na tabela de processos do <code>Kernel</code> persiste até que o pai a colete, liberando o <strong>PID</strong> e os recursos associados.<br>
</li>
<li><strong>kill() - Enviando Sinais</strong>: A chamada de sistema kill() é usada para enviar um sinal (uma forma de interrupção de software) para um processo ou grupo de processos, identificado por seu PID. Os sinais são um mecanismo fundamental de comunicação e controle entre processos, usados para tarefas como solicitar a terminação (<br>
SIGTERM) ou forçar a terminação (SIGKILL).</li>
</ul>
<p>A separação entre fork() e exec() é a base do poder e da flexibilidade do shell UNIX e de seus scripts. Essa abordagem não é apenas um detalhe de implementação, mas uma escolha de design fundamental que permite uma composição elegante de programas. Para ilustrar, considere como um shell executa um comando como ls -l &gt; output.txt. Primeiro, o processo do shell lê a linha de comando. Em seguida, ele chama</p>
<p>fork() para criar um processo filho que é um clone de si mesmo. Neste ponto, o filho existe e está executando o mesmo código do shell, criando uma janela de oportunidade importante antes de executar o novo programa. Dentro desta janela, o processo filho pode manipular seu próprio ambiente sem afetar o shell pai. Para implementar a redireção de saída</p>
<p>&gt; , o filho fecha seu descritor de arquivo de saída padrão (stdout, descritor 1) e abre o arquivo output.txt. A chamada de sistema open() retorna o menor descritor de arquivo disponível, que agora é 1. Consequentemente, qualquer escrita subsequente no stdout pelo filho será direcionada para output.txt. Essa manipulação é feita com chamadas de sistema como close() e open(), mais eficientemente com dup2(). Somente após essa configuração do ambiente estar completa é que o filho chama execvp(“ls”,…). O novo programa ls herda os descritores de arquivo modificados e, sem saber, envia sua saída para o arquivo. Enquanto isso, o shell pai chama waitpid() para aguardar a conclusão do comando ls antes de apresentar um novo prompt. Essa etapa intermediária entre</p>
<p>fork() e exec() nas quais todas as características poderosas do shell—redirecionamento de <code>E/S</code> (&gt;, &lt;), pipes (|) e trabalhos em segundo plano (&amp;)—são implementadas. Um modelo monolítico de criação de processos exigiria uma API muito mais complexa e menos extensível para especificar todas essas possibilidades de antemão, demonstrando a elegância da filosofia UNIX de ferramentas simples e componíveis.</p>
</section>
<section id="implementação-prática-em-c23-linux" class="level3" data-number="10.10.4">
<h3 data-number="10.10.4" class="anchored" data-anchor-id="implementação-prática-em-c23-linux"><span class="header-section-number">10.10.4</span> <strong>2. Implementação Prática em C++23 (Linux)</strong></h3>
<p>O exemplo a seguir demonstra o ciclo fork-exec-wait no <strong>Linux</strong> usando C++23. O programa pai cria um processo filho. O filho então se substitui pelo comando ls -l / usando execvp. O pai espera que o filho termine e imprime seu status de saída.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co">// process\_linux.cpp  </span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Compilar com: g++ \-std=c++23 \-o process\_linux process\_linux.cpp</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;iostream\&gt;  </span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;vector\&gt;  </span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;string\&gt;  </span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;unistd.h\&gt;      // Para fork(), execvp(), getpid()  </span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;sys/wait.h\&gt;    // Para waitpid()  </span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;system\_error\&gt;  // Para std::error\_code  </span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;cstring\&gt;       // Para strerror</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span>  </span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Processo pai (PID: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> getpid<span class="op">()</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">") iniciando..."</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    pid\_t <span class="op">**</span>PID<span class="op">**</span> \<span class="op">=</span> fork<span class="op">();</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pid \<span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span>  </span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Erro ao criar o processo filho  </span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cerr \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Falha no fork: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>strerror<span class="op">(</span>errno<span class="op">)</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span>  </span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pid \<span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span>  </span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// \--- Código do Processo Filho \---  </span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Processo filho (PID: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> getpid<span class="op">()</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">") executando."</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Prepara os argumentos para execvp.  </span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// O primeiro argumento é o nome do programa.  </span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// A lista deve ser terminada com um ponteiro nulo.  </span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector\<span class="op">&lt;</span><span class="dt">char</span>\<span class="op">*</span>\<span class="op">&gt;</span> args<span class="op">;</span>  </span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>        args<span class="op">.</span>push\_back<span class="op">(</span><span class="at">const</span>\_cast\<span class="op">&lt;</span><span class="dt">char</span>\<span class="op">*</span>\<span class="op">&gt;(</span><span class="st">"/bin/ls"</span><span class="op">));</span>  </span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>        args<span class="op">.</span>push\_back<span class="op">(</span><span class="at">const</span>\_cast\<span class="op">&lt;</span><span class="dt">char</span>\<span class="op">*</span>\<span class="op">&gt;(</span><span class="st">"-l"</span><span class="op">));</span>  </span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>        args<span class="op">.</span>push\_back<span class="op">(</span><span class="at">const</span>\_cast\<span class="op">&lt;</span><span class="dt">char</span>\<span class="op">*</span>\<span class="op">&gt;(</span><span class="st">"/"</span><span class="op">));</span>  </span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>        args<span class="op">.</span>push\_back<span class="op">(</span><span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// execvp substitui a imagem do processo atual pelo novo programa.  </span></span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Se for bem-sucedido, esta função nunca retorna.  </span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>        execvp<span class="op">(</span>args<span class="op">,</span> args<span class="op">.</span>data<span class="op">());</span></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Este código só é executado se execvp falhar.  </span></span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cerr \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Falha no execvp no processo filho: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>strerror<span class="op">(</span>errno<span class="op">)</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// É necessário sair em caso de falha para não continuar executando o código do pai.  </span></span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>        \_exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span>   </span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>  </span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">// \--- Código do Processo Pai \---  </span></span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Processo pai criou o filho com PID: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="op">**</span>PID<span class="op">**</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Processo pai esperando o filho terminar..."</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> status<span class="op">;</span>  </span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// waitpid espera por uma mudança de estado no filho especificado.  </span></span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">// \-1 significa esperar por qualquer filho.  </span></span>
<span id="cb49-53"><a href="#cb49-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">// O ponteiro para 'status' receberá informações sobre a terminação.  </span></span>
<span id="cb49-54"><a href="#cb49-54" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 0 como último argumento significa esperar indefinidamente.  </span></span>
<span id="cb49-55"><a href="#cb49-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>waitpid<span class="op">(</span>pid<span class="op">,</span> \<span class="op">&amp;</span>status<span class="op">,</span> <span class="dv">0</span><span class="op">)</span> \<span class="op">==</span> \<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span>  </span>
<span id="cb49-56"><a href="#cb49-56" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cerr \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Falha no waitpid: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>strerror<span class="op">(</span>errno<span class="op">)</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb49-57"><a href="#cb49-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span>  </span>
<span id="cb49-58"><a href="#cb49-58" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-59"><a href="#cb49-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-60"><a href="#cb49-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Analisa o status de saída do filho.  </span></span>
<span id="cb49-61"><a href="#cb49-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>WIFEXITED<span class="op">(</span>status<span class="op">))</span> <span class="op">{</span>  </span>
<span id="cb49-62"><a href="#cb49-62" aria-hidden="true" tabindex="-1"></a>            <span class="co">// O filho terminou normalmente via exit() ou \_exit().  </span></span>
<span id="cb49-63"><a href="#cb49-63" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> exit\_code \<span class="op">=</span> WEXITSTATUS<span class="op">(</span>status<span class="op">);</span>  </span>
<span id="cb49-64"><a href="#cb49-64" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Processo filho terminou com o código de saída: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> exit\_code \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb49-65"><a href="#cb49-65" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>WIFSIGNALED<span class="op">(</span>status<span class="op">))</span> <span class="op">{</span>  </span>
<span id="cb49-66"><a href="#cb49-66" aria-hidden="true" tabindex="-1"></a>            <span class="co">// O filho foi terminado por um sinal.  </span></span>
<span id="cb49-67"><a href="#cb49-67" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> term\_signal \<span class="op">=</span> WTERMSIG<span class="op">(</span>status<span class="op">);</span>  </span>
<span id="cb49-68"><a href="#cb49-68" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Processo filho foi terminado pelo sinal: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> term\_signal \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb49-69"><a href="#cb49-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>  </span>
<span id="cb49-70"><a href="#cb49-70" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">"Processo filho terminou de forma anormal."</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb49-71"><a href="#cb49-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>  </span>
<span id="cb49-72"><a href="#cb49-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-73"><a href="#cb49-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-74"><a href="#cb49-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>  </span>
<span id="cb49-75"><a href="#cb49-75" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="parte-iii-o-modelo-windows-um-estudo-em-configuração" class="level2" data-number="10.11">
<h2 data-number="10.11" class="anchored" data-anchor-id="parte-iii-o-modelo-windows-um-estudo-em-configuração"><span class="header-section-number">10.11</span> <strong>Parte III: O Modelo Windows: Um Estudo em Configuração</strong></h2>
<section id="o-layout-de-memória-virtual-do-windows" class="level3" data-number="10.11.1">
<h3 data-number="10.11.1" class="anchored" data-anchor-id="o-layout-de-memória-virtual-do-windows"><span class="header-section-number">10.11.1</span> <strong>3. O Layout de Memória Virtual do Windows</strong></h3>
<p>O layout do espaço de endereço virtual no <strong>Windows</strong> difere significativamente entre as arquiteturas de 32 e 64 bits, refletindo as restrições e capacidades de cada uma.</p>
<ul>
<li><strong>Windows de 32 bits</strong>: Por padrão, o <strong>VAS</strong> de <span class="math inline">\(4 GB\)</span> é dividido em duas partições de <span class="math inline">\(2 GB\)</span>. A partição inferior, de<br>
<code>0x00000000</code> a <code>0x7FFFFFFF</code>, é o espaço de endereço privado do processo, acessível em modo de usuário. A partição superior, de <code>0x80000000</code> a <code>0xFFFFFFFF</code>, é reservada para o <strong>Sistema Operacional</strong> e só é acessível em modo <code>Kernel</code>. Para aplicativos com uso intensivo de memória, como bancos de dados ou servidores, essa divisão de <span class="math inline">\(2 GB\)</span> pode ser restritiva. Para mitigar isso, o <strong>Windows</strong> introduziu o <strong>4-Gigabyte Tuning (4GT)</strong>. Ao habilitar uma opção de inicialização (historicamente o switch /3GB no boot.ini, agora BCDEdit /set increaseuserva), a divisão pode ser ajustada para alocar até <span class="math inline">\(3 GB\)</span> para o espaço do usuário, deixando <span class="math inline">\(1 GB\)</span> para o sistema. Essa funcionalidade só beneficia aplicativos que são compilados com o flag <code>IMAGE\_FILE\_LARGE\_ADDRESS\_AWARE</code> em seu cabeçalho de imagem, sinalizando que estão cientes e podem manipular um espaço de endereço maior.<br>
</li>
<li><strong>Windows de 64 bits</strong>: Com a mudança para <span class="math inline">\(64 bits\)</span>, as limitações de endereço foram efetivamente eliminadas. O espaço de endereço virtual teórico é de <span class="math inline">\(264 bytes\)</span>, equivamete a <span class="math inline">\(16 exabytes\)</span>. As implementações atuais do <strong>Windows</strong> de <span class="math inline">\(64 bits\)</span> fornecem a cada processo em modo de usuário um <strong>VAS</strong> privado de <span class="math inline">\(128 TB\)</span>, variando de <code>0x000'00000000</code> a <code>0x7FFF'FFFFFFFF</code>. Esse espaço vasto torna obsoletas as complexidades como o <span class="math inline">\(4GT\)</span>, fornecendo um espaço de endereço mais do que suficiente para praticamente qualquer aplicativo.</li>
</ul>
</section>
<section id="de-arquivo-para-memória-o-formato-portable-executable-pe" class="level3" data-number="10.11.2">
<h3 data-number="10.11.2" class="anchored" data-anchor-id="de-arquivo-para-memória-o-formato-portable-executable-pe"><span class="header-section-number">10.11.2</span> <strong>3. De Arquivo para Memória: O Formato Portable Executable (PE)</strong></h3>
<p>O formato Portable Executable (PE) é o padrão para todos os arquivos executáveis, bibliotecas de vínculo dinâmico (DLLs) e drivers de dispositivo em todas as versões modernas do Windows. Ele é uma evolução do formato Common Object File Format (COFF) e foi projetado com a portabilidade entre arquiteturas de <code>CPU</code> e a compatibilidade com versões anteriores em mente.</p>
<p>A estrutura de um arquivo PE é organizada de forma linear e hierárquica 35:</p>
<ul>
<li><strong>Stub MS-DOS</strong>: Todo arquivo PE começa com um programa MS-DOS totalmente funcional. Sua principal função é a compatibilidade com versões anteriores. Se o executável for executado em um ambiente MS-DOS, este stub é executado e normalmente exibe uma mensagem como “Este programa não pode ser executado no modo DOS”. Um campo fundamental neste <code>stub</code>, no deslocamento <code>0x3c</code>, contém um ponteiro para o início do cabeçalho PE principal, permitindo que o carregador do <strong>Windows</strong> pule o stub.<br>
</li>
<li><strong>Assinatura PE</strong>: No deslocamento especificado pelo stub, encontra-se uma assinatura de 4 bytes: PE\0\0 (os caracteres ASCII ‘P’ e ‘E’, seguidos por dois bytes nulos). Isso identifica inequivocamente o arquivo como um executável no formato PE.<br>
</li>
<li><strong>Cabeçalho de Arquivo COFF</strong>: Imediatamente após a assinatura, este cabeçalho contém informações básicas sobre o arquivo, como a arquitetura da máquina de destino, o número de seções no arquivo, um carimbo de data/hora de compilação e o tamanho do cabeçalho opcional que se segue.<br>
</li>
<li><strong>Cabeçalho Opcional</strong>: Este cabeçalho é “opcional” apenas para arquivos de objeto; ele é <strong>obrigatório</strong> para imagens executáveis. Ele contém as informações mais críticas para o carregador do Windows:
<ul>
<li>ImageBase: O endereço de memória virtual preferencial em que o executável deve ser carregado. O padrão para executáveis é frequentemente <code>0x00400000</code>.<br>
</li>
<li>SizeOfImage: O tamanho total que a imagem ocupará na memória virtual quando carregada.<br>
</li>
<li>SectionAlignment e FileAlignment: Ditames de alinhamento para as seções na memória e no arquivo, respectivamente.<br>
</li>
<li><strong>Diretórios de Dados</strong>: Uma matriz de estruturas que apontam para tabelas de dados importantes dentro da imagem, como a Tabela de Exportação (para DLLs), a Tabela de Recursos (para ícones, diálogos, etc.) e, mais importante, a <strong>Tabela de Importação</strong>.</li>
</ul></li>
</ul>
<p>A ligação dinâmica no <strong>Windows</strong> depende fundamentalmente da <strong>Tabela de Endereços de Importação (IAT)</strong>. Quando um programa chama uma função de uma DLL, o compilador não pode saber o endereço absoluto da função em tempo de compilação. Em vez disso, a chamada é compilada como uma chamada indireta por meio de uma entrada na IAT. A IAT atua como uma tabela de ponteiros de função. Quando o carregador do <strong>Windows</strong> carrega o aplicativo, ele lê a Tabela de Importação para determinar quais DLLs são necessárias. Ele carrega essas DLLs na memória e, em seguida, percorre a IAT do aplicativo, preenchendo cada entrada com o endereço virtual real da função importada correspondente. Se o carregador não puder carregar o executável em seu</p>
<p>ImageBase preferido (por exemplo, porque o espaço já está ocupado), ele deve realizar a “realocação de base” (<em>rebasing</em>), usando informações da seção .reloc para corrigir todas as referências de endereço absoluto dentro do código.</p>
</section>
<section id="criação-de-processos-a-api-createprocess" class="level3" data-number="10.11.3">
<h3 data-number="10.11.3" class="anchored" data-anchor-id="criação-de-processos-a-api-createprocess"><span class="header-section-number">10.11.3</span> <strong>3. Criação de Processos: A API CreateProcess</strong></h3>
<p>Em contraste com o modelo de duas etapas do <strong>Linux</strong>, o <strong>Windows</strong> emprega uma única função monolítica e altamente configurável, CreateProcess, para criar um novo processo. Esta função é responsável por criar o objeto de processo do <code>Kernel</code> e carregar a imagem do programa inicial nele, tudo em uma única operação atômica.</p>
<p>O comportamento da função é governado por seus dez parâmetros, que oferecem um controle abrangente e antecipado sobre o novo processo 38:</p>
<ul>
<li>lpApplicationName e/ou lpCommandLine: Especifica o programa a ser executado e seus argumentos de linha de comando.<br>
</li>
<li>lpProcessAttributes e lpThreadAttributes: Ponteiros para estruturas de segurança que definem as permissões para o novo objeto de processo e seu thread principal.<br>
</li>
<li>bInheritHandles: Um booleano que controla se o processo filho herda os identificadores abertos (para arquivos, pipes, etc.) do processo pai.<br>
</li>
<li>dwCreationFlags: Um conjunto de flags que controla a prioridade do processo, a visibilidade da janela (por exemplo, CREATE_NEW_CONSOLE para forçar uma nova janela de console) e o estado inicial (por exemplo, CREATE_SUSPENDED para criar o processo em um estado suspenso).<br>
</li>
<li>lpEnvironment: Um ponteiro para um bloco de ambiente personalizado para o novo processo.<br>
</li>
<li>lpCurrentDirectory: Define o diretório de trabalho inicial do processo filho.</li>
</ul>
<p>Dois parâmetros de estrutura são particularmente importantes:</p>
<ul>
<li><strong>STARTUPINFO (entrada)</strong>: Uma estrutura que o chamador preenche para especificar propriedades da interface do usuário, como a estação de janela, o desktop e os identificadores para os fluxos de <code>E/S</code> padrão (stdin, stdout, stderr) do novo processo.<br>
</li>
<li><strong>PROCESS_INFORMATION (saída)</strong>: Uma estrutura que a função CreateProcess preenche com informações sobre o novo processo, mais importante, os identificadores (handles) para o novo processo (hProcess) e seu thread primário (hThread), bem como seus IDs numéricos.</li>
</ul>
<p>Após uma chamada bem-sucedida a CreateProcess, o processo pai geralmente usa WaitForSingleObject(pi.hProcess, INFINITE) para pausar sua execução até que o processo filho termine. É de importância crítica que o pai chame CloseHandle() em pi.hProcess e pi.hThread quando eles não forem mais necessários. Falhar em fechar esses identificadores resulta em um vazamento de recursos, pois o <strong>Sistema Operacional</strong> não liberará completamente as estruturas de dados do processo até que todos os identificadores abertos para ele sejam fechados.</p>
<p>O modelo de criação de processos do Windows, centrado na API CreateProcess e no formato PE, é um reflexo direto de sua história e prioridades de design como um <strong>Sistema Operacional</strong> comercial de longa data. A filosofia subjacente pode ser entendida por meio de várias de suas características técnicas. Primeiramente, a ênfase na compatibilidade com versões anteriores é evidente na estrutura do formato PE, que inclui um stub MS-DOS obrigatório. Este componente não tem função prática em sistemas modernos, mas garante uma falha graciosa em <strong>Sistemas Operacionais</strong> legados, demonstrando um compromisso em não quebrar o vasto ecossistema de software existente, uma consideração decisiva para um <strong>Sistema Operacional</strong> comercial. Em segundo lugar, a API</p>
<p>CreateProcess exemplifica uma abordagem de controle abrangente e por configuração. Seus dez parâmetros e duas estruturas de dados complexas 36 fornecem ao processo pai um controle granular e explícito sobre o contexto de segurança, ambiente, estado inicial e interface do usuário do novo processo, tudo</p>
<p><em>antes</em> que qualquer código do filho seja executado. Este modelo de cima para baixo e “configuracional” contrasta fortemente com o modelo “composicional” do <strong>Linux</strong> e é altamente desejável em ambientes corporativos nos quais políticas de segurança e estado inicial devem ser rigorosamente aplicadas. Finalmente, o modelo do <strong>Windows</strong> estabelece um limite transacional claro entre o <strong>Sistema Operacional</strong> e o aplicativo. O processo pai atua como um “configurador”, emitindo uma única solicitação atômica: “Crie um processo com estas especificações exatas”. Não há um estado intermediário de “clone” como no Linux. Embora essa abordagem seja potencialmente menos flexível, ela é mais explícita e menos suscetível a erros durante a fase de configuração intermediária. Juntas, essas características de design não são escolhas arbitrárias, mas sim o resultado da evolução do <strong>Windows</strong> como um produto da Microsoft, moldado pela necessidade de suportar uma base de software legada maciça, fornecer <code>APIs</code>poderosas para desenvolvedores e manter uma plataforma estável e segura para clientes corporativos.</p>
</section>
<section id="implementação-prática-em-c23-windows" class="level3" data-number="10.11.4">
<h3 data-number="10.11.4" class="anchored" data-anchor-id="implementação-prática-em-c23-windows"><span class="header-section-number">10.11.4</span> <strong>3. Implementação Prática em C++23 (Windows)</strong></h3>
<p>O exemplo a seguir demonstra o uso da API CreateProcessW no <strong>Windows</strong> usando C++23. O programa inicia uma nova instância do Bloco de Notas (notepad.exe), aguarda sua conclusão e, em seguida, limpa adequadamente os identificadores do processo e do thread.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">// process\_windows.cpp  </span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Compilar com o compilador do Visual Studio (cl.exe) ou MinGW-w64.  </span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Linkar com a biblioteca user32.lib se usar MessageBox.</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;iostream\&gt;  </span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;string\&gt;  </span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>\<span class="er">#**include** \&lt;windows.h\&gt; // Cabeçalho principal da API do Windows</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> PrintError<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>wstring<span class="op">&amp;</span> functionName<span class="op">)</span> <span class="op">{</span>  </span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    DWORD errorCode \<span class="op">=</span> GetLastError<span class="op">();</span>  </span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    LPWSTR messageBuffer \<span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span>  </span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    size\_t size \<span class="op">=</span> FormatMessageW<span class="op">(</span>  </span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>        FORMAT\_MESSAGE\_ALLOCATE\_BUFFER <span class="op">|</span> FORMAT\_MESSAGE\_FROM\_SYSTEM <span class="op">|</span> FORMAT\_MESSAGE\_IGNORE\_INSERTS<span class="op">,</span>  </span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>        NULL<span class="op">,</span>  </span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>        errorCode<span class="op">,</span>  </span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>        MAKELANGID<span class="op">(</span>LANG\_NEUTRAL<span class="op">,</span> SUBLANG\_DEFAULT<span class="op">),</span>  </span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>LPWSTR<span class="op">)</span>\<span class="op">&amp;</span>messageBuffer<span class="op">,</span>  </span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span><span class="op">,</span>  </span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        NULL<span class="op">);</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcerr \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L"Falha em "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> functionName \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L" com o erro "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> errorCode \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L": "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> messageBuffer \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>    LocalFree<span class="op">(</span>messageBuffer<span class="op">);</span>  </span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span>  </span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L"Processo pai (PID: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> GetCurrentProcessId<span class="op">()</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L") iniciando..."</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Estruturas para CreateProcess. É necessário inicializá-las com zeros.  </span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>    STARTUPINFOW si<span class="op">;</span>  </span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>    PROCESS\_INFORMATION pi<span class="op">;</span></span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>    ZeroMemory<span class="op">(</span>\<span class="op">&amp;</span>si<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>si<span class="op">));</span>  </span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>    si<span class="op">.</span>cb \<span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>si<span class="op">);</span> <span class="co">// O tamanho da estrutura deve ser definido.  </span></span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>    ZeroMemory<span class="op">(</span>\<span class="op">&amp;</span>pi<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>pi<span class="op">));</span></span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Linha de comando para o novo processo.  </span></span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// O caminho para o executável deve ser fornecido.  </span></span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Para CreateProcessW, a string deve ser mutável.  </span></span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wstring commandLine \<span class="op">=</span> <span class="st">L"notepad.exe"</span><span class="op">;</span></span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cria o processo filho.  </span></span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CreateProcessW é a versão Unicode, preferida para aplicativos modernos.  </span></span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>\<span class="op">!</span>CreateProcessW<span class="op">(</span>  </span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true" tabindex="-1"></a>            NULL<span class="op">,</span>                   <span class="co">// lpApplicationName \- Usa a linha de comando.  </span></span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true" tabindex="-1"></a>            \<span class="op">&amp;</span>commandLine<span class="op">,</span>        <span class="co">// lpCommandLine \- Deve ser um ponteiro para um buffer de escrita.  </span></span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true" tabindex="-1"></a>            NULL<span class="op">,</span>                   <span class="co">// lpProcessAttributes \- Segurança padrão para o processo.  </span></span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true" tabindex="-1"></a>            NULL<span class="op">,</span>                   <span class="co">// lpThreadAttributes \- Segurança padrão para o thread.  </span></span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true" tabindex="-1"></a>            FALSE<span class="op">,</span>                  <span class="co">// bInheritHandles \- Não herda identificadores.  </span></span>
<span id="cb50-50"><a href="#cb50-50" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span><span class="op">,</span>                      <span class="co">// dwCreationFlags \- Sem flags especiais.  </span></span>
<span id="cb50-51"><a href="#cb50-51" aria-hidden="true" tabindex="-1"></a>            NULL<span class="op">,</span>                   <span class="co">// lpEnvironment \- Usa o ambiente do pai.  </span></span>
<span id="cb50-52"><a href="#cb50-52" aria-hidden="true" tabindex="-1"></a>            NULL<span class="op">,</span>                   <span class="co">// lpCurrentDirectory \- Usa o diretório do pai.  </span></span>
<span id="cb50-53"><a href="#cb50-53" aria-hidden="true" tabindex="-1"></a>            \<span class="op">&amp;</span>si<span class="op">,</span>                    <span class="co">// lpStartupInfo \- Ponteiro para a estrutura STARTUPINFO.  </span></span>
<span id="cb50-54"><a href="#cb50-54" aria-hidden="true" tabindex="-1"></a>            \<span class="op">&amp;</span>pi                     <span class="co">// lpProcessInformation \- Ponteiro para a estrutura PROCESS\_INFORMATION.  </span></span>
<span id="cb50-55"><a href="#cb50-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">))</span> <span class="op">{</span>  </span>
<span id="cb50-56"><a href="#cb50-56" aria-hidden="true" tabindex="-1"></a>        PrintError<span class="op">(</span><span class="st">L"CreateProcessW"</span><span class="op">);</span>  </span>
<span id="cb50-57"><a href="#cb50-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span>  </span>
<span id="cb50-58"><a href="#cb50-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-59"><a href="#cb50-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-60"><a href="#cb50-60" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L"Processo pai criou o filho com PID: "</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> pi<span class="op">.</span>dwProcessId \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb50-61"><a href="#cb50-61" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L"Processo pai esperando o filho terminar..."</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb50-62"><a href="#cb50-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-63"><a href="#cb50-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Espera indefinidamente até que o objeto do processo filho seja sinalizado (ou seja, termine).  </span></span>
<span id="cb50-64"><a href="#cb50-64" aria-hidden="true" tabindex="-1"></a>    WaitForSingleObject<span class="op">(</span>pi<span class="op">.</span>hProcess<span class="op">,</span> INFINITE<span class="op">);</span></span>
<span id="cb50-65"><a href="#cb50-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-66"><a href="#cb50-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>wcout \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="st">L"Processo filho terminou."</span> \<span class="op">&lt;</span>\<span class="op">&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb50-67"><a href="#cb50-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-68"><a href="#cb50-68" aria-hidden="true" tabindex="-1"></a>    <span class="co">// É essencial fechar os identificadores do processo e do thread para evitar vazamentos de recursos.  </span></span>
<span id="cb50-69"><a href="#cb50-69" aria-hidden="true" tabindex="-1"></a>    CloseHandle<span class="op">(</span>pi<span class="op">.</span>hProcess<span class="op">);</span>  </span>
<span id="cb50-70"><a href="#cb50-70" aria-hidden="true" tabindex="-1"></a>    CloseHandle<span class="op">(</span>pi<span class="op">.</span>hThread<span class="op">);</span></span>
<span id="cb50-71"><a href="#cb50-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-72"><a href="#cb50-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>  </span>
<span id="cb50-73"><a href="#cb50-73" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="parte-iv-análise-comparativa-e-síntese" class="level2" data-number="10.12">
<h2 data-number="10.12" class="anchored" data-anchor-id="parte-iv-análise-comparativa-e-síntese"><span class="header-section-number">10.12</span> <strong>Parte IV: Análise Comparativa e Síntese</strong></h2>
<section id="filosofias-de-design-forkexec-vs.-createprocess" class="level3" data-number="10.12.1">
<h3 data-number="10.12.1" class="anchored" data-anchor-id="filosofias-de-design-forkexec-vs.-createprocess"><span class="header-section-number">10.12.1</span> <strong>4. Filosofias de Design: fork/exec vs.&nbsp;CreateProcess</strong></h3>
<p>As abordagens do <strong>Linux</strong> e do <strong>Windows</strong> para a criação de processos revelam filosofias de design fundamentalmente diferentes, que podem ser caracterizadas como composição versus configuração.</p>
<ul>
<li><strong>Linux/UNIX: Composição e Flexibilidade</strong>: O modelo fork()/exec() é <strong>composicional</strong>. Ele fornece dois primitivos simples e ortogonais: fork(), que clona o estado de um processo, e exec(), que substitui a imagem do programa. O poder deste modelo reside na capacidade de compor essas duas operações. O período entre a chamada<br>
fork() e a chamada exec() permite que o processo filho, agora em execução, modifique programaticamente seu próprio ambiente antes de se transformar no novo programa. Durante esta fase, o filho pode realizar tarefas complexas como redirecionar descritores de arquivo para implementar <code>E/S</code> (&gt;), configurar pipes (|), alterar seu ID de usuário ou grupo, modificar variáveis de ambiente. Este design é um exemplo clássico da filosofia UNIX de criar ferramentas pequenas e simples que podem ser combinadas de maneiras poderosas.<br>
</li>
<li><strong>Windows: Configuração e Atomicidade</strong>: O modelo CreateProcess() é <strong>configuracional</strong> e <strong>atômico</strong>. Em vez de compor primitivos, o processo pai especifica o estado inicial completo do processo filho por meio de um conjunto abrangente de parâmetros em uma única chamada de API. Não há um estado intermediário em que o processo filho executa o código do pai. A criação e a carga do novo programa são uma operação única e indivisível. Esta abordagem é menos flexível do que o modelo<br>
fork()/exec(), mas é mais explícita e pode ser considerada menos propensa a erros, pois a configuração é centralizada no chamador e não distribuída para o novo processo.</li>
</ul>
<p>Historicamente, fork() foi considerado uma operação cara devido à necessidade de copiar todo o espaço de endereço. No entanto, com a otimização moderna de <strong>Copy-on-Write (COW)</strong>, o fork() tornou-se extremamente eficiente, pois a cópia física das páginas de memória é adiada até que uma escrita ocorra. Mesmo assim, o modelo ainda pode ser visto como realizando “operações duplicadas”, pois um espaço de endereço é meticulosamente criado apenas para ser descartado imediatamente pela chamada</p>
<p>exec(). Para contornar isso, o padrão POSIX oferece</p>
<p>posix_spawn(), uma alternativa que se assemelha mais ao CreateProcess(), embora seja menos utilizada na prática do que o idiomático fork()/exec().</p>
</section>
<section id="formatos-executáveis-uma-comparação-direta-entre-elf-e-pe" class="level3" data-number="10.12.2">
<h3 data-number="10.12.2" class="anchored" data-anchor-id="formatos-executáveis-uma-comparação-direta-entre-elf-e-pe"><span class="header-section-number">10.12.2</span> <strong>4. Formatos Executáveis: Uma Comparação Direta entre ELF e PE</strong></h3>
<p>Os formatos de arquivo executável dominantes em cada ecossistema, ELF e PE, também refletem suas respectivas filosofias de design.</p>
<ul>
<li><strong>Diferenças Estruturais</strong>:
<ul>
<li><strong>ELF</strong>: Apresenta uma estrutura de visão dupla com “seções” para o ligador e “segmentos” para o carregador. Esta separação clara de interesses entre a ligação estática e a carga para execução é um dos pontos fortes do design do ELF.<br>
</li>
<li><strong>PE</strong>: Possui uma estrutura mais linear com um único conjunto de “seções” que são mapeadas na memória. Embora a tabela de seções sirva a um propósito semelhante ao da tabela de cabeçalhos de programa do ELF para o carregador, ela não possui a mesma distinção explícita entre as visões de ligação e execução.<br>
</li>
</ul></li>
<li><strong>Ligação Dinâmica</strong>:
<ul>
<li><strong>ELF</strong>: Utiliza a <strong>Tabela de Deslocamento Global (GOT)</strong> e a <strong>Tabela de Ligação de Procedimento (PLT)</strong>. Este mecanismo é fundamental para a geração de <strong>Código de Posição Independente (PIC)</strong>, que permite que o código de uma biblioteca compartilhada seja carregado em qualquer endereço virtual sem necessidade de modificação. A desvantagem é um pequeno custo de desempenho devido a um nível extra de indireção nas chamadas de função e ao uso de um registrador dedicado para o GOT.<br>
</li>
<li><strong>PE</strong>: Baseia-se na <strong>Tabela de Endereços de Importação (IAT)</strong>. O carregador do <strong>Windows</strong> modifica diretamente a IAT em tempo de carga, inserindo os endereços virtuais absolutos das funções importadas. Se a imagem não puder ser carregada em seu<br>
ImageBase preferido, o carregador deve realizar a “realocação de base”, um processo potencialmente lento que usa a seção .reloc para corrigir todas as referências de endereço absoluto no código.<br>
</li>
</ul></li>
<li><strong>Origens e Governança</strong>:
<ul>
<li><strong>ELF</strong>: É um padrão aberto, impulsionado pela comunidade, historicamente gerenciado pelo Comitê de Padrões de Interface de Ferramentas (TIS). Seu design é amplamente considerado limpo, bem documentado e extensível, tornando-o a escolha padrão para <strong>Sistemas Operacionais</strong> novos e de código aberto.<br>
</li>
<li><strong>PE</strong>: É um formato específico de fornecedor, projetado pela Microsoft. Ele contém recursos específicos do <strong>Windows</strong> e uma forte ênfase na compatibilidade com versões anteriores, como evidenciado pelo onipresente stub MS-DOS.</li>
</ul></li>
</ul>
</section>
<section id="resumo-das-distinções" class="level3" data-number="10.12.3">
<h3 data-number="10.12.3" class="anchored" data-anchor-id="resumo-das-distinções"><span class="header-section-number">10.12.3</span> <strong>4. Resumo das Distinções</strong></h3>
<p>A tabela a seguir resume as principais diferenças arquitetônicas e filosóficas discutidas neste relatório, fornecendo uma visão geral concisa para comparação direta.</p>
<p>Tabela 1: Comparação de Recursos do Gerenciamento de Processos no <strong>Linux</strong> e no <strong>Windows</strong><br>
| Recurso | <strong>Linux</strong> | <strong>Windows</strong> |<br>
| :— | :— | :— |<br>
| API de Criação Primária | fork() seguido por exec() (duas etapas, composicional) | CreateProcess() (etapa única, atômica, configuracional) |<br>
| Estado Inicial da Memória | O filho é um clone Copy-on-Write (COW) do pai. | Um novo espaço de endereço separado é criado e configurado. |<br>
| Formato Executável | ELF (Executable and Linkable Format) | PE (Portable Executable) |<br>
| Ligação Dinâmica | GOT/PLT para Código de Posição Independente (PIC). | Tabela de Endereços de Importação (IAT) corrigida pelo carregador; realocação de base se necessário. |<br>
| Configuração do Ambiente | Realizada pelo próprio processo filho após o fork() e antes do exec(). | Especificada por meio de parâmetros para CreateProcess() pelo pai. |<br>
| Filosofia de Design | Ferramentas pequenas e componíveis; separação de interesses. | Controle abrangente, explícito e orientado por API; compatibilidade com versões anteriores. |</p>
</section>
</section>
<section id="conclusão-e-perspectivas-futuras" class="level2" data-number="10.13">
<h2 data-number="10.13" class="anchored" data-anchor-id="conclusão-e-perspectivas-futuras"><span class="header-section-number">10.13</span> <strong>Conclusão e Perspectivas Futuras</strong></h2>
<p>A análise detalhada do gerenciamento de processos e memória no <strong>Linux</strong> e no <strong>Windows</strong> revela que as diferenças entre os dois <strong>Sistemas Operacionais</strong> n são meramente superficiais, mas estão profundamente enraizadas em suas distintas filosofias de design e trajetórias históricas.</p>
<p>O modelo do <strong>Linux</strong>, com seu paradigma fork()/exec() e o formato ELF, personifica a filosofia UNIX de simplicidade e composição. A separação da criação de processos da execução de programas oferece uma flexibilidade extraordinária, que se tornou a base para ferramentas de linha de comando poderosas e, mais recentemente, provou ser bem adequada para tecnologias de contêineres como o Docker, que dependem do isolamento eficiente de grupos de processos dentro de um <code>Kernel</code> compartilhado.</p>
<p>Em contraste, o modelo do Windows, com sua API CreateProcess() monolítica e o formato PE, reflete uma filosofia de controle explícito, configuração atômica e um compromisso inabalável com a compatibilidade com versões anteriores. Este design, embora menos flexível, fornece aos desenvolvedores um controle granular sobre o ambiente do processo filho desde o início e está intrinsecamente ligado ao robusto modelo de segurança que é uma pedra angular das ofertas corporativas do Windows.</p>
<p>Para desenvolvedores, arquitetos de sistemas e pesquisadores, a compreensão dessas diferenças fundamentais é essencial. Elas influenciam não apenas como o software é escrito e executado, mas também como os sistemas são protegidos, gerenciados e escalados. À medida que a computação continua a evoluir, com o aumento da computação em nuvem, microsserviços e sistemas de segurança cada vez mais complexos, os legados arquitetônicos desses dois <strong>Sistemas Operacionais</strong> dominantes continuarão a moldar o futuro da tecnologia de software.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./gerproc2.html" class="pagination-link" aria-label="Processos de Sistema: Linux vs. Windows">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Processos de Sistema: Linux vs.&nbsp;Windows</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./gerproc4.html" class="pagination-link" aria-label="Agendamento de Tarefas e Escalonamento">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Agendamento de Tarefas e Escalonamento</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/edit/main/gerproc3.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>