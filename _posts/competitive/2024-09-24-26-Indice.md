---
author: Frank
beforetoc: ""
categories:
  - Matemática
  - Linguagens Formais
  - Programação
description: Dynamic Programming in C++ with practical examples, performance analysis, and detailed explanations to optimize your coding skills and algorithm efficiency.
draft: null
featured: false
image: assets/images/prog_dynamic.jpeg
keywords:
  - Dynamic Programming
lastmod: 2024-09-25T23:34:56.849Z
layout: post
preview: In this comprehensive guide, we delve into the world of Dynamic Programming with C++. Learn the core principles of Competitive Programming, explore various algorithmic examples, and understand performance differences through detailed code comparisons. Perfect for developers looking to optimize their coding skills and boost algorithm efficiency.
published: false
rating: 5
slug: competitive-programming-techniques-insights
tags:
  - Practical Programming Guide
title: Competitive Programming Summary
toc: true
---

- [1. Introduction](2024-09-24-2-1.-Introduction.md)
- [2. C++ Competitive Programming Hacks](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md)
  - [2.1 Typing Tips](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%2321-typing-tips)
  - [2.2 Why Typing Speed Matters](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%2322-why-typing-speed-matters)
  - [2.3 Advanced Typing Techniques for Programmers](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%2323-advanced-typing-techniques-for-programmers)
  - [2.4 Typing Less in Competitive Programming](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%2324-typing-less-in-competitive-programming)
    - [2.4.1. Using `#define` for `std::vector` Abbreviations](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%23241-using-define-for-stdvector-abbreviations)
    - [2.4.2. Predefined Utility Functions](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%23242-predefined-utility-functions)
    - [2.4.3. Predefining Common Operations](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%23243-predefining-common-operations)
    - [2.4.4. Using Lambda Functions](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%23244-using-lambda-functions)
    - [2.4.5 Prefer Not to Use `#define`](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%23245-prefer-not-to-use-define)
  - [3. Optimizing File I/O in C++ for competitive programmings](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%233-optimizing-file-io-in-c-for-competitive-programmings)
    - [3.1 Disabling I/O Synchronization](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%2331-disabling-io-synchronization)
    - [3.2 Command Line Argument Checking](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%2332-command-line-argument-checking)
    - [3.3 Opening and Verifying the File](2024-09-24-3-2.-C%2B%2B-Competitive-Programming-Hacks.md%2333-opening-and-verifying-the-file)
- [4. Introduction to File I/O in C++](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md)
  - [4.1 `std::ifstream`: File Reading](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%2341-stdifstream-file-reading)
    - [4.1.1 Opening Files for Reading](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23411-opening-files-for-reading)
    - [4.1.2 Verifying File Opening](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23412-verifying-file-opening)
    - [4.1.3 File Reading](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23413-file-reading)
    - [4.1.4 File Closing](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23414-file-closing)
    - [4.1.5 File Writing - `std::ofstream`](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23415-file-writing---stdofstream)
    - [4.1.6 File Reading and Writing - `std::fstream`](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23416-file-reading-and-writing---stdfstream)
    - [4.1.7 File Opening Modes](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23417-file-opening-modes)
  - [4.2 Advanced File I/O Techniques in C++](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%2342-advanced-file-io-techniques-in-c)
    - [4.2.1 Using `mmap` for Faster File I/O in Unix-Based Systems](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23421-using-mmap-for-faster-file-io-in-unix-based-systems)
      - [4.2.1.1 How to Use `mmap`](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%234211-how-to-use-mmap)
    - [4.2.2 Parallel Input/Output with Threads (C++20)](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%23422-parallel-inputoutput-with-threads-c20)
  - [4.3 Efficient Techniques for File I/O and Array Handling in Competitive Programming](2024-09-24-4-4.-Introduction-to-File-IO-in-C%2B%2B.md%2343-efficient-techniques-for-file-io-and-array-handling-in-competitive-programming)
- [5. Maximizing Input/Output Efficiency in Competitive Programming (Windows and Linux)](2024-09-24-5-5.-Maximizing-InputOutput-Efficiency-in-Competitive-Programming-%28Windows-and-Linux%29.md)
  - [5.1 Optimized Input and Output](2024-09-24-5-5.-Maximizing-InputOutput-Efficiency-in-Competitive-Programming-%28Windows-and-Linux%29.md%2351-optimized-input-and-output)
  - [5.2 Key Techniques for Faster I/O](2024-09-24-5-5.-Maximizing-InputOutput-Efficiency-in-Competitive-Programming-%28Windows-and-Linux%29.md%2352-key-techniques-for-faster-io)
  - [5.3 Differences Between Windows and Linux](2024-09-24-5-5.-Maximizing-InputOutput-Efficiency-in-Competitive-Programming-%28Windows-and-Linux%29.md%2353-differences-between-windows-and-linux)
  - [5.4 Using Manual Buffers with `fread` and `fwrite`](2024-09-24-5-5.-Maximizing-InputOutput-Efficiency-in-Competitive-Programming-%28Windows-and-Linux%29.md%2354-using-manual-buffers-with-fread-and-fwrite)
- [6. Introduction to Namespaces](2024-09-24-6-6.-Introduction-to-Namespaces.md)
  - [6.1 Basic Syntax of a Namespace](2024-09-24-6-6.-Introduction-to-Namespaces.md%2361-basic-syntax-of-a-namespace)
  - [6.2 Using Namespaces](2024-09-24-6-6.-Introduction-to-Namespaces.md%2362-using-namespaces)
    - [6.2.1 Accessing Elements of a Namespace](2024-09-24-6-6.-Introduction-to-Namespaces.md%23621-accessing-elements-of-a-namespace)
    - [6.2.2 `using namespace std;`](2024-09-24-6-6.-Introduction-to-Namespaces.md%23622-using-namespace-std)
  - [6.3 Disadvantages of Using `using namespace std;`](2024-09-24-6-6.-Introduction-to-Namespaces.md%2363-disadvantages-of-using-using-namespace-std)
  - [6.4 Alternatives to `using namespace std;`](2024-09-24-6-6.-Introduction-to-Namespaces.md%2364-alternatives-to-using-namespace-std)
    - [6.4.1 Advanced Example: Nested Namespace](2024-09-24-6-6.-Introduction-to-Namespaces.md%23641-advanced-example-nested-namespace)
- [7. Working with Vector and Matrix](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md)
  - [7.1 Vectors](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%2371-vectors)
    - [7.1.1 Inserting Elements at a Specific Position](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23711-inserting-elements-at-a-specific-position)
    - [7.1.2 Removing the Last Element and a Specific Element](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23712-removing-the-last-element-and-a-specific-element)
    - [7.1.3 Creating a New Vector with a Default Value](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23713-creating-a-new-vector-with-a-default-value)
    - [7.1.4 Resizing and Filling with Random Values](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23714-resizing-and-filling-with-random-values)
    - [7.1.5 Sorting the Vector](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23715-sorting-the-vector)
    - [7.1.6 Vectors as Inputs and Outputs](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23716-vectors-as-inputs-and-outputs)
      - [7.1.6.1 Optimized Version Using `fread` and `putchar` with Command-Line File Input](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%237161-optimized-version-using-fread-and-putchar-with-command-line-file-input)
  - [7.2 Matrices](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%2372-matrices)
    - [7.2.1 Creating and Filling a Matrix](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23721-creating-and-filling-a-matrix)
    - [7.2.2 Displaying the Matrix](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23722-displaying-the-matrix)
    - [7.2.3 Inserting Elements at a Specific Position](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23723-inserting-elements-at-a-specific-position)
    - [7.2.4 Removing the Last Element and a Specific Element](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23724-removing-the-last-element-and-a-specific-element)
    - [7.2.5 Creating a New Vector with a Default Value](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23725-creating-a-new-vector-with-a-default-value)
    - [7.2.6 Resizing and Filling with Random Values](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23726-resizing-and-filling-with-random-values)
    - [7.2.7 Sorting Matrices by Rows and Columns](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23727-sorting-matrices-by-rows-and-columns)
      - [7.2.7.1 Sorting by Rows](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%237271-sorting-by-rows)
      - [7.2.7.2 Sorting by Columns](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%237272-sorting-by-columns)
  - [7.2.8 Optimizing Matrix Input and Output in Competitive Programming](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%23728-optimizing-matrix-input-and-output-in-competitive-programming)
    - [7.2.8.1 Optimized Reading with `fread`](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%237281-optimized-reading-with-fread)
    - [7.2.8.2 Optimized Output with `putchar_unlocked`](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%237282-optimized-output-with-putchar_unlocked)
    - [7.2.8.3 Complexity Analysis](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%237283-complexity-analysis)
    - [7.2.8.4 Using `mmap` on Unix Systems](2024-09-24-7-7.-Working-with-Vector-and-Matrix.md%237284-using-mmap-on-unix-systems)
- [8. Efficient Data Manipulation in C++ using Span and Ranges](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md)
  - [8.1 Using `std::span`](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%2381-using-stdspan)
    - [8.1.1 Efficient Use Cases for `std::span`](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%23811-efficient-use-cases-for-stdspan)
    - [8.1.2 Comparing `std::span` to Traditional Methods](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%23812-comparing-stdspan-to-traditional-methods)
    - [8.1.3 Practical Application: Using `std::span` in Competitive Programming](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%23813-practical-application-using-stdspan-in-competitive-programming)
  - [8.2 Efficient Data Manipulation with `std::ranges` in C++20](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%2382-efficient-data-manipulation-with-stdranges-in-c20)
    - [8.2.1 How `std::ranges` Works](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%23821-how-stdranges-works)
    - [8.2.2 Composition of Operations](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%23822-composition-of-operations)
    - [8.2.3 Memory and Performance Considerations](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%23823-memory-and-performance-considerations)
    - [8.2.3 Practical Use Cases in Competitive Programming](2024-09-24-8-8.-Efficient-Data-Manipulation-in-C%2B%2B-using-Span-and-Ranges.md%23823-practical-use-cases-in-competitive-programming)
- [9. Time and Space Complexity in Competitive Programming](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md)
  - [9.1 Loops, Time and Space Complexity](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md%2391-loops-time-and-space-complexity)
  - [9.2 Order of Growth](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md%2392-order-of-growth)
  - [9.3 Algorithm Phases and Time Complexity](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md%2393-algorithm-phases-and-time-complexity)
  - [9.4 Recursive Algorithms](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md%2394-recursive-algorithms)
    - [9.4.1 Exponential Recursion](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md%23941-exponential-recursion)
    - [9.4.2 Common Complexity Classes](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md%23942-common-complexity-classes)
    - [9.4.3 Estimating Efficiency](2024-09-24-9-9.-Time-and-Space-Complexity-in-Competitive-Programming.md%23943-estimating-efficiency)
- [10. Loops the Heart of All Competitive Programming](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md)
  - [10.1 Deep Dive into `for` Loops in Competitive Programming](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23101-deep-dive-into-for-loops-in-competitive-programming)
    - [10.1.1 `for` Loop with Iterator](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231011-for-loop-with-iterator)
    - [10.1.2. Classic `for` Loop with Index](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231012-classic-for-loop-with-index)
    - [10.1.3. Range-Based `for-each` with Constant Reference](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231013-range-based-for-each-with-constant-reference)
    - [10.1.4. Range-Based `for-each` by Value](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231014-range-based-for-each-by-value)
    - [10.1.5. `for` Loop with Range Views (C++20)](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231015-for-loop-with-range-views-c20)
    - [10.1.6. Parallel `for` Loop (C++17/C++20)](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231016-parallel-for-loop-c17c20)
    - [10.1.7. Optimal `for` Loops for Competitive Programming](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231017-optimal-for-loops-for-competitive-programming)
  - [10.2 Now the `while` Loop which we all love](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23102-now-the-while-loop-which-we-all-love)
    - [10.2.1. Basic `while` Loop](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231021-basic-while-loop)
    - [10.2.2. `while` Loop with Complex Conditions](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231022-while-loop-with-complex-conditions)
    - [10.2.3. Infinite `while` Loops](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231023-infinite-while-loops)
    - [10.2.4. `do-while` Loop](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231024-do-while-loop)
    - [10.2.5. `while` Loop with Early Exit](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231025-while-loop-with-early-exit)
    - [10.2.6. Combining `while` with Multiple Conditions](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231026-combining-while-with-multiple-conditions)
    - [10.2.7. Optimal `while` Loops for Competitive Programming](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231027-optimal-while-loops-for-competitive-programming)
  - [10.3 Special Loops in C++20 for Competitive Programming](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23103-special-loops-in-c20-for-competitive-programming)
    - [10.3.1. Range-Based Loops with `std::ranges::views`](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231031-range-based-loops-with-stdrangesviews)
    - [10.3.2. Parallel Loops with `std::for_each` and `std::execution::par`](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231032-parallel-loops-with-stdfor_each-and-stdexecutionpar)
  - [10.4. `constexpr` Loops](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23104-constexpr-loops)
    - [10.4.1 Considerations for competitive programmings](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%231041-considerations-for-competitive-programmings)
  - [10.5. Early Exit Loops](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23105-early-exit-loops)
  - [10.6. Indexed Loops with Range-Based `for`](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23106-indexed-loops-with-range-based-for)
  - [10.7. Standard Library Algorithms (`std::for_each`, `std::transform`)](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23107-standard-library-algorithms-stdfor_each-stdtransform)
  - [10.8 Summary Table of Useful Loop Techniques for competitive programmings](2024-09-24-10-10.-Loops-the-Heart-of-All-Competitive-Programming.md%23108-summary-table-of-useful-loop-techniques-for-competitive-programmings)
- [11. Problems in One-Dimensional Arrays](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md)
  - [11.1. Preprocessing and Efficient Query Techniques - Arrays](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23111-preprocessing-and-efficient-query-techniques---arrays)
    - [11.1.1 Algorithm: Prefix Sum Array](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231111-algorithm-prefix-sum-array)
      - [11.1.1.1. Algorithm Prefix Sum in Plain English](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311111-algorithm-prefix-sum-in-plain-english)
    - [11.1.1.2. Complexity Analysis](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311112-complexity-analysis)
    - [11.1.1.3. Typical Problem: The Plate Balancer (Problem 2)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311113-typical-problem-the-plate-balancer-problem-2)
      - [11.1.1.3.A Naïve Solution](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311113a-nave-solution)
      - [11.1.1.3.B Prefix Sum Array Solution](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311113b-prefix-sum-array-solution)
      - [11.1.1.3.C Competitive Solution](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311113c-competitive-solution)
    - [11.1.2. Algorithm: Difference Array - Efficient Range Updates](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231112-algorithm-difference-array---efficient-range-updates)
      - [11.1.2.1 Difference Array Algorithm Explained in Plain English](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311121-difference-array-algorithm-explained-in-plain-english)
      - [11.1.2.2 Complexity Analysis](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311122-complexity-analysis)
      - [11.1.2.3. Typical Problem: Humidity Levels in a Greenhouse (Problem 1)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311123-typical-problem-humidity-levels-in-a-greenhouse-problem-1)
    - [11.1.3. Algorithm: Incremental Sum](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231113-algorithm-incremental-sum)
      - [11.1.3.1. Incremental Sum Algorithm Explained in Plain English](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311131-incremental-sum-algorithm-explained-in-plain-english)
      - [11.1.3.2 Complexity Analysis](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311132-complexity-analysis)
    - [11.1.4. Typical Problem: "Humidity Levels in a Greenhouse" (Problem 1)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231114-typical-problem-humidity-levels-in-a-greenhouse-problem-1)
    - [11.1.5. Static Array Queries](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231115-static-array-queries)
    - [11.1.6. Range Minimum Queries (RMQ)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231116-range-minimum-queries-rmq)
    - [11.1.7. Fenwick Tree](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231117-fenwick-tree)
  - [11.2. Sliding Window Algorithms](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23112-sliding-window-algorithms)
    - [11.2.1. Sliding Window Minimum](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231121-sliding-window-minimum)
    - [11.2.2. Sliding Window Maximum](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231122-sliding-window-maximum)
  - [11.3. Multiple Query Processing](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23113-multiple-query-processing)
    - [11.3.1 Mo's Algorithm](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231131-mos-algorithm)
      - [11.3.1.1 Why Choose $\sqrt{n}$ as the Block Size?](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311311-why-choose-sqrtn-as-the-block-size)
      - [11.3.1.2. Complexity Analysis](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311312-complexity-analysis)
      - [11.3.1.3 Implementation](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311313-implementation)
      - [11.3.1.4. Typical Problem: Humidity Levels in a Greenhouse (Problem 1)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2311314-typical-problem-humidity-levels-in-a-greenhouse-problem-1)
  - [11.4. Auxiliary Data Structures](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23114-auxiliary-data-structures)
    - [11.4.1 Deque (for Sliding Window Minimum/Maximum)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231141-deque-for-sliding-window-minimummaximum)
    - [11.4.2 Sparse Table (for RMQ)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231142-sparse-table-for-rmq)
    - [11.4.3 Segment Tree](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231143-segment-tree)
  - [11.5. Complexity Optimization Techniques](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23115-complexity-optimization-techniques)
    - [11.5.1. Reduction from $O(n^2)$ to $O(n)$](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231151-reduction-from-on2-to-on)
    - [11.5.2. Update in $O(1)$](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231152-update-in-o1)
    - [11.5.3. Query in $O(1)$ after preprocessing](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231153-query-in-o1-after-preprocessing)
    - [11.5.4. Processing in $O((n + q) \sqrt{n})$](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231154-processing-in-on--q-sqrtn)
  - [11.6. Subarray Algorithms](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23116-subarray-algorithms)
    - [11.6.1 Kadane's Algorithm](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231161-kadanes-algorithm)
    - [11.6.2 Two Pointers](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231162-two-pointers)
  - [11.7. Hashing Techniques](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23117-hashing-techniques)
    - [11.6.1. Prefix Hash](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231161-prefix-hash)
    - [11.6.2. Rolling Hash](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231162-rolling-hash)
  - [11.8. Partitioning Algorithms](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23118-partitioning-algorithms)
    - [11.6.1. Partition Algorithm (QuickSelect)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231161-partition-algorithm-quickselect)
    - [11.6.2. Dutch National Flag](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231162-dutch-national-flag)
  - [11.7. The Fenwick Tree](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23117-the-fenwick-tree)
    - [11.7.1 Fundamental Concept](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231171-fundamental-concept)
    - [11.7.2. Querying the Fenwick tree](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231172-querying-the-fenwick-tree)
    - [11.7.3. Updating the Fenwick tree](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231173-updating-the-fenwick-tree)
    - [11.7.4. Basic Operations](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%231174-basic-operations)
      - [Update](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23update)
      - [4.2 Prefix Sum Query](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2342-prefix-sum-query)
      - [4.3 Range Query](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%2343-range-query)
    - [5. Fenwick tree Construction](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%235-fenwick-tree-construction)
    - [Complexity Analysis](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23complexity-analysis)
    - [Variations and Extensions](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23variations-and-extensions)
      - [Range Update and Point Query](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23range-update-and-point-query)
      - [Range Update and Range Query](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23range-update-and-range-query)
      - [2D Fenwick tree](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%232d-fenwick-tree)
    - [Applications](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23applications)
    - [Comparison with Other Structures](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23comparison-with-other-structures)
    - [Problem Example: "Humidity Levels in a Greenhouse" (Problem 1)](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23problem-example-humidity-levels-in-a-greenhouse-problem-1)
    - [Inventory Restocking](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23inventory-restocking)
      - [Naïve Solution](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23nave-solution)
    - [4 - Sales Target Analysis](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%234---sales-target-analysis)
      - [Naïve Code](2024-09-24-11-11.-Problems-in-One-Dimensional-Arrays.md%23nave-code)
- [Search and Sorting Algorithms](2024-09-24-12-Search-and-Sorting-Algorithms.md)
  - [Binary Search](2024-09-24-12-Search-and-Sorting-Algorithms.md%23binary-search)
  - [Sorting](2024-09-24-12-Search-and-Sorting-Algorithms.md%23sorting)
- [Data Structures](2024-09-24-13-Data-Structures.md)
  - [Stacks and Queues](2024-09-24-13-Data-Structures.md%23stacks-and-queues)
  - [Trees](2024-09-24-13-Data-Structures.md%23trees)
  - [Priority Queues (Heaps)](2024-09-24-13-Data-Structures.md%23priority-queues-heaps)
  - [Hashing](2024-09-24-13-Data-Structures.md%23hashing)
- [Dynamic Programming (DP)](2024-09-24-14-Dynamic-Programming-%28DP%29.md)
  - [Knapsack Problem](2024-09-24-14-Dynamic-Programming-%28DP%29.md%23knapsack-problem)
  - [Longest Increasing Subsequence](2024-09-24-14-Dynamic-Programming-%28DP%29.md%23longest-increasing-subsequence)
  - [Grid Pathfinding](2024-09-24-14-Dynamic-Programming-%28DP%29.md%23grid-pathfinding)
- [Dynamic Programming](2024-09-24-15-Dynamic-Programming.md)
  - [The Recursive Function](2024-09-24-15-Dynamic-Programming.md%23the-recursive-function)
    - [The Dynamic Programming Function Using Memoization](2024-09-24-15-Dynamic-Programming.md%23the-dynamic-programming-function-using-memoization)
    - [The Dynamic Programming Function Using Tabulation](2024-09-24-15-Dynamic-Programming.md%23the-dynamic-programming-function-using-tabulation)
    - [Performance Evaluation and Support Functions](2024-09-24-15-Dynamic-Programming.md%23performance-evaluation-and-support-functions)
      - [Code 3: C-style Array](2024-09-24-15-Dynamic-Programming.md%23code-3-c-style-array)
      - [Running Code 3: using C-Style Array](2024-09-24-15-Dynamic-Programming.md%23running-code-3-using-c-style-array)
  - [Execution Time Comparison Table](2024-09-24-15-Dynamic-Programming.md%23execution-time-comparison-table)
  - [Your First Dynamic Programming Problem](2024-09-24-15-Dynamic-Programming.md%23your-first-dynamic-programming-problem)
    - [The "Two-Sum" problem](2024-09-24-15-Dynamic-Programming.md%23the-two-sum-problem)
    - [Brute-Force for Two-Sum's problem](2024-09-24-15-Dynamic-Programming.md%23brute-force-for-two-sums-problem)
      - [Recursive Approach: Divide and Conquer](2024-09-24-15-Dynamic-Programming.md%23recursive-approach-divide-and-conquer)
      - [Base Cases](2024-09-24-15-Dynamic-Programming.md%23base-cases)
      - [Recursive Step](2024-09-24-15-Dynamic-Programming.md%23recursive-step)
      - [Solution Analysis](2024-09-24-15-Dynamic-Programming.md%23solution-analysis)
      - [Dynamic Programming: memoization](2024-09-24-15-Dynamic-Programming.md%23dynamic-programming-memoization)
      - [Memoized Recursive Solution in C++20](2024-09-24-15-Dynamic-Programming.md%23memoized-recursive-solution-in-c20)
      - [Complexity Analysis of the Memoized Solution](2024-09-24-15-Dynamic-Programming.md%23complexity-analysis-of-the-memoized-solution)
      - [Dynamic Programming: tabulation](2024-09-24-15-Dynamic-Programming.md%23dynamic-programming-tabulation)
      - [C++ code for Two-Sum problem using tabulation](2024-09-24-15-Dynamic-Programming.md%23c-code-for-two-sum-problem-using-tabulation)
      - [Complexity Analysis of the Tabulation Function](2024-09-24-15-Dynamic-Programming.md%23complexity-analysis-of-the-tabulation-function)
      - [Execution Time Analysis](2024-09-24-15-Dynamic-Programming.md%23execution-time-analysis)
      - [The Dynamic Memory Bottleneck](2024-09-24-15-Dynamic-Programming.md%23the-dynamic-memory-bottleneck)
    - [We will always have C](2024-09-24-15-Dynamic-Programming.md%23we-will-always-have-c)
      - [Two-Sum C-Style Tabulation Function Complexity](2024-09-24-15-Dynamic-Programming.md%23two-sum-c-style-tabulation-function-complexity)
    - [High Performance C++](2024-09-24-15-Dynamic-Programming.md%23high-performance-c)
    - [Exercises: Variations of the Two Sum](2024-09-24-15-Dynamic-Programming.md%23exercises-variations-of-the-two-sum)
- [The Dynamic Programming Classic Problems](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md)
  - [Problem 1 Statement: Counting All Possible Paths in a Matrix](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23problem-1-statement-counting-all-possible-paths-in-a-matrix)
    - [Using Brute-Force](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23using-brute-force)
    - [Using Memoization](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23using-memoization)
    - [Using Tabulation](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23using-tabulation)
  - [Problem 2 Statement: Subset Sum](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23problem-2-statement-subset-sum)
  - [Problem 3 Statement: Longest Increasing Subsequence](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23problem-3-statement-longest-increasing-subsequence)
    - [Brute-Force](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23brute-force)
    - [Memoization](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23memoization)
    - [Tabulation](2024-09-24-16-The-Dynamic-Programming-Classic-Problems.md%23tabulation)
- [5. Graphs and Graph Theory](2024-09-24-17-5.-Graphs-and-Graph-Theory.md)
- [6. Computational Geometry](2024-09-24-18-6.-Computational-Geometry.md)
- [7. Number Theory and Modular Arithmetic](2024-09-24-19-7.-Number-Theory-and-Modular-Arithmetic.md)
- [8. Combinatorics and Counting](2024-09-24-20-8.-Combinatorics-and-Counting.md)
- [9. String Processing](2024-09-24-21-9.-String-Processing.md)
- [10. Simulation and Backtracking](2024-09-24-22-10.-Simulation-and-Backtracking.md)
- [11. NP-Complete Problems](2024-09-24-23-11.-NP-Complete-Problems.md)
- [12. Ad-hoc Problems](2024-09-24-24-12.-Ad-hoc-Problems.md)
- [Notes and References](2024-09-24-25-Notes-and-References.md)
