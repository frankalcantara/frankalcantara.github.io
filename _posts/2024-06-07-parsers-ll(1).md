---
layout: post
title: Parsers LL(1) o mundo obscuro da análise sintática
author: Frank
categories:
    - Matemática
    - Linguagens Formais
tags:
    - Matemática
    - Linguagens Formais
    - Compiladores
image: assets/images/deriva.webp
description: Tudo que você sempre quis saber sobre parsers LL(1) e nunca teve coragem de perguntar.
slug: parsers-ll(1)
keywords:
    - parsers
    - first
    - follow
    - derivation
    - derivação
rating: 5
published: 2024-06-08T21:17:00.799Z
draft: 2024-06-08T21:15:23.198Z
preview: Definição, processo de funcionamento e outras informações necessárias ao entendimento do funcionamento de parsers LL(1)
lastmod: 2025-08-25T00:19:16.809Z
---

**ESTE ARQUIVO FOI CORRIGIDO, E SUBSTITUÍDO PELO LIVRO [LINGUAGENS FORMAIS](https://frankalcantara.com/lf/index.html)**.

Elementar meu caro Watson! Mesmo que Sherlock nunca tenha dito esta frase nos livros de [Sir Arthur Conan Doyle](https://www.ebiografia.com/arthur_conan_doyle/), a lembrança do grande detetive ocupa meu imaginário sempre que falo de *parsers*. Assim como o grande detetive, o trabalho do *parser* será  verificar todos os detalhes de uma cena e validar cada um dos seus itens em relação a um contexto. No nosso caso, a cena será formada por um *string* e  o contexto do crime, será determinado por uma Tabela de Derivação. Infelizmente nosso detetive, o *parser* $LL(1)$, nem de perto terá a mesma capacidade de Sherlock Holmes. Ainda que seja eficiente, um *parser* $LL(1)$ é linear e determinístico e, pensando bem, esta foi uma metáfora ruim. Mas, eu sempre quis começar um texto falado: elementar meu caro Watson!.

Em geral, ainda que muitos lenços de papel tenham sido gastos durantes as avaliações de final de período, *parsers* $LL(1)$ são algoritmos simples.

Um *parser* $LL(1)$ é um tipo de analisador sintático descendente que utiliza a análise preditiva, e uma tabela que chamarei de Tabela de Derivação, para determinar qual será a regra de produção que deverá ser aplicada em cada etapa da análise a regra de produção que será utilizada para substituir um símbolo não-terminal por um terminal, criando uma árvore sintática e permitindo a identificação de um *string* como parte de uma determinada linguagem. Esta ideia começou com o trabalho [*On the Translation of Languages from Left to Right*](https://www.sciencedirect.com/science/article/pii/S0019995865904262) de [Donald Knuth](https://pt.wikipedia.org/wiki/Donald_Knuth) mas foi sendo aprimorada ao longo do tempo por pesquisadores como [Alfred Aho](https://en.wikipedia.org/wiki/Alfred_Aho) e [Jeffrey Ullman](https://en.wikipedia.org/wiki/Jeffrey_Ullman), nos anos 1970 1980.

A análise preditiva é um tipo de análise descendente que usa uma pilha para armazenar os símbolos esperados e os conjuntos $FIRST$ e $FOLLOW$ para prever qual regra de produção aplicar em cada etapa do processo de análise. Essa previsão permite que o analisador tome decisões sem precisar retroceder, tornando a análise mais eficiente computacionalmente. Esta análise preditiva será a ação que um parser $LL(1)$ irá utilizar para validar os *strings* de uma determinada linguagem, símbolo por símbolo.

Para atingir meu objetivo, com este texto, as linguagens que usaremos como exemplo serão representadas apenas pelo conjunto de regras de produção da sua gramática. Vou manter a álgebra o mais longe possível e se o conjunto de regras de produção estiver perfeitamente construído todos os elementos da gramática poderão ser identificados. isso permitirá que aqueles com arrepios algébricos possam se dedicar a uma análise formal da linguagem.

Outro ponto importante, neste texto, símbolos não-terminais serão representados em caracteres latinos maiúsculos e símbolos terminais em caracteres latinos minúsculos. A única exceção será $\varepsilon$  para representar uma produção vazia.

Os *parsers* preditivos são analisadores sintáticos descendentes (*top-down*) que utilizam um único símbolo de *lookahead* (antecipação) para determinar a regra de produção correta a ser aplicada em cada etapa da análise. Eles *predizem* qual regra usar com base no próximo símbolo da entrada e no não-terminal atualmente sendo analisado. O termo $LL(1)$ significa:

* **L:** Left-to-right scan (varredura da esquerda para a direita) da entrada.
* **L:** Leftmost derivation (derivação mais à esquerda) da gramática.
* **1:** Um símbolo de *lookahead* (antecipação) para tomada de decisão.

Um *parser* $LL(1)$, requer uma gramática $LL(1)$. Nesta gramática não pode existir qualquer ambiguidade na escolha da regra de produção que será aplicada a cada símbolo de *lookahead*. Além disso, a gramática não pode ter recursão à esquerda, seja esta recursão direta ou indireta. A recursão à esquerda é um desafio considerável. Existem duas formas de recursão à esquerda:

* **Recursão à Esquerda Direta**: ocorre quando um símbolo não-terminal pode ser derivado em uma sequência que começa com ele mesmo. Por exemplo, na regra $A → Aa \mid b$, o símbolo $A$ pode ser substituído no processo de derivação em $Aa$, onde $A$ aparece novamente no início da regra. E aqui está o laço infinito.

* **Recursão à Esquerda Indireta**: acontece quando um símbolo não-terminal pode ser derivado em uma sequência que começa com outro símbolo não-terminal, que por sua vez pode ser derivado de volta ao símbolo original. Ilustrando, nas regras $A → Ba$ e $B → Ab$, $A$ deriva para $Ba$, $B$ deriva para $Ab$ e $Ab$ pode derivar novamente para $A$, criando outro laço infinito.

Além do perigo do laço de repetição infinito que faz o pobre Turing se revolver no túmulo, a recursão à esquerda impede o desenvolvimento de uma Tabela de Derivação. Graças a criação de regras em conflito. Duas ou mais regras, para a mesma combinação de símbolo terminal e símbolo não-terminal em um determinado momento do processo de *parser*.

