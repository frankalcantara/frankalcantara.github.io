---
layout: post
title: "First & Follow"
author: Frank
categories:
  - Math
  - Computing Theory
tags:
  - Math
  - Grammar
  - First
  - Follow
  - Parser
image: assets/images/eletromag1.jpg
featured: 2024-03-18T18:35:18.910Z
rating: 0
description: ""
date: 2024-03-18T18:35:18.911Z
preview: ""
keywords: ""
published: 2024-03-18T18:35:18.911Z
slug: 2024-03-18T18:35:18.911Z
type: default
description: Understand how mathematics underpins electromagnetism and its practical applications in an academic article aimed at science and engineering students.
slug: formula-of-attraction-mathematics-supporting-electromagnetism
keywords:
  - Vectorial Calculus
  - Eletromagnetism
  - Math
  - Poetry
  - Vectorial Algebra
rating: 5
published: false
---

# Frist & Follow

Na an√°lise sint√°tica, no contexto de compila√ß√£o de linguagens de programa√ß√£o, os algoritmos $FRIST$ e $FOLLOW$ s√£o utilizados na constru√ß√£o de tabelas de an√°lise sint√°tica para gram√°ticas livres de contexto. Esses algoritmos s√£o importantes no processo de an√°lise preditiva, um m√©todo de an√°lise sint√°tica *top-down*.

- O algoritmo $FRIST$ √© utilizado para determinar o conjunto de terminais que podem aparecer no in√≠cio de alguma forma derivada de um s√≠mbolo n√£o-terminal. Em outras palavras, para um dado n√£o-terminal, o conjunto $FRIST$ cont√©m todos os s√≠mbolos terminais que podem come√ßar as cadeias derivadas desse n√£o-terminal.

- O algoritmo $FOLLOW$ √© usado para encontrar o conjunto de terminais que podem seguir imediatamente um n√£o-terminal em alguma forma derivada a partir do s√≠mbolo inicial da gram√°tica. O conjunto $FOLLOW$ de um n√£o-terminal comt√©m todos os terminais que podem aparecer logo ap√≥s o n√£o-terminal em quest√£o, nas deriva√ß√µes da gram√°tica.

Ambos s√£o essenciais na an√°lise sint√°tica LL, uma vez que permitem prever qual regra de produ√ß√£o deve ser aplicada com base no s√≠mbolo de entrada atual e no conte√∫do da pilha de an√°lise.

## Regras de cria√ß√£o dos conjuntos $FIRST \& FOLLOW$

###Conjunto First

o conjunto $FIRST$ de um s√≠mbolo n√£o-terminal √© o conjunto de terminais que podem aparecer no in√≠cio de alguma string derivada desse s√≠mbolo.

Para definir o conjunto $FIRST(X)$ para todos os s√≠mbolos n√£o-terminais
$X$ de uma gram√°tica que esteja definida por um conjunto de regras de produ√ß√£o, podemos seguir os seguintes passos:

1. **Para s√≠mbolos terminais**: o conjunto $FIRST$ √© o pr√≥prio s√≠mbolo terminal. Ou seja, se $a$ √© um terminal, ent√£o $FIRST(a) = {a}$.

2. **Para um s√≠mbolo n√£o-terminal $X$**: olhe para cada regra de produ√ß√£o $X \rightarrow \alpha$ e siga as seguintes regras:

    - Se $\alpha$ √© um terminal, adicione $\alpha$ ao conjunto $FIRST(X)$.
    - Se $\alpha$ come√ßa com um s√≠mbolo n√£o-terminal $Y$, adicione $FIRST(Y)$ ao $FIRST(X)$, exceto pelo s√≠mbolo de vazio $(\varepsilon$) se ele estiver presente.
    - Se $\alpha$ pode derivar em vazio (diretamente ou indiretamente atrav√©s de outros n√£o-terminais), adicione $\varepsilon$ ao conjunto $FIRST(X)$.

**O s√≠mbolo vazio $\varepsilon$ n√£o √© sempre um elemento de um conjunto $FIRST$. Ele pode ser um elemento de $FIRST$ se a regra de produ√ß√£o permitir deriva√ß√£o para o vazio, desde que n√£o seja o √∫nico elemento do conjunto $FIRST$.**

Repita esses passos at√© que os conjuntos $FIRST$ de todos os s√≠mbolos n√£o-terminais n√£o possam ser alterado.

**Exemplo**: Considere a gram√°tica definida por:

$$
\begin{array}{|c|c|}
\hline
\textbf{S√≠mbolo n√£o-terminal} & \textbf{Regras de produ√ß√£o} \\ \hline
S & aB | bA \\ \hline
A & c | d \\ \hline
B & e | f \\ \hline
\end{array}
$$

Este conjunto de regras de produ√ß√£o permite criar:

$$
\begin{array}{|c|c|c|}
\hline
\textbf{S√≠mbolo} & \textbf{FIRST} & \textbf{Explica√ß√£o}\\ \hline
S & \{a, b\} & \textbf{S pode ser derivado em "aB" ou "bA"}\\ \hline
A & \{c, d\} & \textbf{A pode ser derivado em "c" ou "d"}\\ \hline
B & \{e, f\} & \textbf{B pode ser derivado em "e" ou "f"}\\ \hline
\end{array}
$$

Logo: $FIRST =\{(S,\{a, b\}),(A,\{c, d\}),(B,\{e, f\})\}$, um conjunto de tuplas.

###Conjunto FOLLOW

O conjunto $FOLLOW$ de um s√≠mbolo n√£o-terminal √© o conjunto de terminais que podem aparecer imediatamente √† direita desse n√£o-terminal em alguma forma sentencial derivada. Para calcular o conjunto $FOLLOW(A)$ para cada n√£o-terminal $A$, siga estes passos:

1. Coloque o s√≠mbolo de fim de entrada $(\$)$ no $FOLLOW$ do s√≠mbolo inicial da gram√°tica.

  Ao colocar o s√≠mbolo de fim de entrada (\$) no $FOLLOW$ do s√≠mbolo inicial da gram√°tica, garantimos que o analisador sint√°tico reconhe√ßa a √∫ltima deriva√ß√£o da gram√°tica como v√°lida. Isso significa que o analisador estar√° preparado para encontrar o s√≠mbolo (\$) ao final da string de entrada, indicando que a an√°lise foi conclu√≠da com sucesso.

  Em outras palavras, o s√≠mbolo (\$) no $FOLLOW$ do s√≠mbolo inicial representa a expectativa de que a string de entrada seja completamente processada e que n√£o existam s√≠mbolos "soltos" ap√≥s a √∫ltima derivada.

2. Para cada produ√ß√£o $X \rightarrow \alpha B \beta$, onde $B$ seja um n√£o-terminal e $\beta$ √© uma sequ√™ncia de s√≠mbolos que pode ser vazia:

    - Se $\beta$ n√£o √© vazio, adicione todos os s√≠mbolos de $FIRST(\beta)$, (exceto por $\varepsilon$, ao $FOLLOW(B)$.
    - Se $\beta$ √© vazio ou $FIRST(\beta)$ cont√©m $\varepsilon$, adicione todos os s√≠mbolos de $FOLLOW(X)$ ao $FOLLOW(B)$..

Repita esses passos at√© que os conjuntos $FOLLOW$ de todos os s√≠mbolos n√£o-terminais n√£o mudem mais.

**Exemplo**: Considere a gram√°tica definida por:

$$
\begin{array}{|c|c|}
\hline
\textbf{S√≠mbolo n√£o-terminal} & \textbf{Regras de produ√ß√£o} \\ \hline
S & aB | bA \\ \hline
A & c | d \\ \hline
B & e | f \\ \hline
\end{array}
$$

Este conjunto de regras de produ√ß√£o permite criar:

| S√≠mbolo | FOLLOW          | Explica√ß√£o                                                                                                          |
|---------|-----------------|---------------------------------------------------------------------------------------------------------------------|
| S       | { \$ }          | S √© o s√≠mbolo inicial, ent√£o \$ √© o √∫nico terminal que pode aparecer √† direita de S em uma forma sentencial derivada. |
| A       | { c, d, \$ }    | A pode ser seguido por "c" na regra A -> c, "d" na regra A -> d, ou pelo s√≠mbolo de fim de entrada \$ em regras que cont√™m A. |
| B       | { a, c, d, \$ } | B pode ser seguido por "a" na regra S -> aB, "c" na regra A -> cB, "d" na regra A -> d B, ou pelo s√≠mbolo de fim de entrada \$ em regras que cont√™m B. |


###Construindo a tabela de an√°lise LL(1)

A tabela de an√°lise LL(1) √© usada para determinar qual regra de produ√ß√£o aplicar, dada a entrada corrente e o n√£o-terminal no topo da pilha de an√°lise. Para constru√≠-la:

Para cada produ√ß√£o $A\rightarrow \alpha$ fa√ßa:

   - Para cada terminal $a$ em $FIRST(\alpha)$, adicione a regra $A\rightarrow \alpha$ √† tabela para a combina√ß√£o $[A,a]$.
   - Se $\varepsilon$ est√° em $FIRST(\alpha)$, ent√£o para cada s√≠mbolo $b$ em $FOLLOW(A)$, adicione a regra $A\rightarrow \alpha$ √† tabela para a combina√ß√£o $[A,b]$.
   - Se $\\$$ est√° em $FOLLOW(A)$, adicione tamb√©m para $[A, \$]$.

Se h√° conflitos na tabela (mais de uma regra para a mesma combina√ß√£o de n√£o-terminal e terminal de entrada), a gram√°tica n√£o √© LL(1).

## Exemplo de cria√ß√£o de conjuntos $FIRST \& FOLLOW$
Considerando o seguinte conjunto de regras de produ√ß√£o

$$
\begin{array}{|lc|}
\hline
\textbf{Regras de Produ√ß√£o } \\ \hline
\space \space ùëÖ\rightarrow \varepsilon \\ \hline
\space \space ùëÖ\rightarrow +ùëÜ \\ \hline
\space \space ùëá\rightarrow ùêπùê∫ \\ \hline
\space \space ùê∫\rightarrow \varepsilon \\ \hline
\space \space ùê∫\rightarrow ‚àóùëá \\ \hline
\space \space ùêπ\rightarrow ùëõ \\ \hline
\space \space ùêπ\rightarrow (ùëÜ) \\ \hline
\end{array}
$$

Crie uma tabela de deriva√ß√£o para um parser LL(1).

### Conjunto FIRST

**Para $F$:**

- $F \rightarrow n$: Adiciona $n$ ao FIRST($F$).
- $F \rightarrow (S)$: Adiciona $($ ao FIRST($F$).

Portanto, FIRST($F$) = \{n, (\}.

**Para $G$:**

- $G \rightarrow \epsilon$: Adiciona $\epsilon$ ao FIRST($G$).
- $G \rightarrow *T$: Adiciona $*$ ao FIRST($G$).

Portanto, FIRST($G$) = \{*, \epsilon\}.

**Para $T$:**

- $T \rightarrow FG$: Como FIRST($F$) inclui $n$ e $($ e $G$ pode ser vazio ($\epsilon$), FIRST($T$) tamb√©m incluir√° $n$ e $($.

Portanto, FIRST($T$) = \{n, (\}.

**Para $R$:**

- $R \rightarrow \epsilon$: Adiciona $\epsilon$ ao FIRST($R$).
- $R \rightarrow +S$: Adiciona $+$ ao FIRST($R$).

Portanto, FIRST($R$) = \{+, \epsilon\}.

**Para $S$:**

- $S \rightarrow TR$: J√° que FIRST($T$) inclui $n$ e $($, FIRST($S$) tamb√©m incluir√° $n$ e $($.

Portanto, FIRST($S$) = \{n, (\}.

### Conjunto FOLLOW

Para calcular FOLLOW, consideramos onde cada n√£o-terminal aparece na gram√°tica:

**FOLLOW($S$):**

- $S$ √© o s√≠mbolo inicial, ent√£o inclui \$ no FOLLOW($S$).
- $S$ aparece ap√≥s $+$ em $R \rightarrow +S$: Adiciona FOLLOW($R$) (que ser√° calculado) a FOLLOW($S$).

FOLLOW($S$) = \{\$\} (e possivelmente mais, dependendo de FOLLOW($R$)).

**FOLLOW($R$):**

- $R$ segue $T$ em $S \rightarrow TR$, ent√£o tudo em FOLLOW($S$) (que inclui \$ e mais tarde, outros s√≠mbolos) √© adicionado a FOLLOW($R$).

FOLLOW($R$) = \{\$\} (e possivelmente mais, dependendo de FOLLOW($S$)).

**FOLLOW($T$):**

- $T$ √© seguido por $R$ em $S \rightarrow TR$: Adiciona FIRST($R$) excluindo $\epsilon$ (que √© $+$) a FOLLOW($T$). Se $\epsilon$ est√° em FIRST($R$), tamb√©m adiciona FOLLOW($S$) (que √© \$ e possivelmente mais).

FOLLOW($T$) = \{+, \$\}.

**FOLLOW($G$):**

- $G$ segue $F$ em $T \rightarrow FG$: Adiciona FOLLOW($T$) (que inclui $+$ e \$) a FOLLOW($G$).
- $G$ aparece ap√≥s $*$ em si mesmo ($G \rightarrow *T$), significando que tudo em FOLLOW($T$) tamb√©m est√° em FOLLOW($G$).

FOLLOW($G$) = \{+, \$\}.

**FOLLOW($F$):**

- $F$ √© seguido por $G$ em $T \rightarrow FG$: Adiciona FIRST($G$) excluindo $\epsilon$ (que √© $*$) a FOLLOW($F$). Se $\epsilon$ est√° em FIRST($G$), tamb√©m adiciona FOLLOW($T$) (que √© $+$, \$).

- $F$ aparece dentro de $F \rightarrow (S)$ em si mesmo: Isso significa que FOLLOW($F$) tamb√©m deve incluir $)$ quando $F$ √© derivado por $S$.

FOLLOW($F$) = \{*, +, \$, )\}.
### M√©todo para Criar a Tabela LL(1)

1. **Para cada produ√ß√£o da forma $A \rightarrow \alpha$:**
   - Para cada terminal $a$ em $FIRST(\alpha)$, adicione $A \rightarrow \alpha$ √† tabela em $[A, a]$.
   - Se $\epsilon$ est√° em $FIRST(\alpha)$, ent√£o para cada s√≠mbolo $b$ em $FOLLOW(A)$, adicione $A \rightarrow \alpha$ √† tabela em $[A, b]$.
   - Se $\epsilon$ est√° em $FIRST(\alpha)$ e $FOLLOW(A)$ cont√©m o s√≠mbolo de final de arquivo (EOF, representado como $), adicione $A \rightarrow \alpha$ √† tabela em $[A, $]$.

### Aplica√ß√£o ao Exemplo

Vamos aplicar o m√©todo para criar a tabela LL(1) para as produ√ß√µes da gram√°tica dada. Aqui est√£o as produ√ß√µes e os conjuntos $FIRST$ e $FOLLOW$ calculados:

- **Produ√ß√µes:**
  - $S \rightarrow TR$
  - $R \rightarrow \epsilon | +S$
  - $T \rightarrow FG$
  - $G \rightarrow \epsilon | *T$
  - $F \rightarrow n | (S)$

- **Conjuntos FIRST e FOLLOW:**
  - $FIRST(S) = \{n, (\}$
  - $FIRST(R) = \{+, \epsilon\}$
  - $FIRST(T) = \{n, (\}$
  - $FIRST(G) = \{*, \epsilon\}$
  - $FIRST(F) = \{n, (\}$

  - $FOLLOW(S) = \{\$\}$
  - $FOLLOW(R) = \{\$\}$
  - $FOLLOW(T) = \{+, \$\}$
  - $FOLLOW(G) = \{+, \$\}$
  - $FOLLOW(F) = \{*, +, \$, )\}$

### Tabela LL(1)

A tabela tem n√£o-terminais como linhas ($S, R, T, G, F$) e terminais como colunas ($n, (, ), +, *, \$)$. Vamos preencher cada c√©lula conforme as regras.

$$\begin{array}{|c|c|c|c|c|c|c|}
\hline
    & n        & (        & ) & +         & *         & \$ \\
\hline
S   & S \to TR & S \to TR &   &           &           &    \\
\hline
R   &          &          &   & R \to +S  &           & R \to \epsilon \\
\hline
T   & T \to FG & T \to FG &   &           &           &    \\
\hline
G   &          &          &   & G \to \epsilon & G \to *T & G \to \epsilon \\
\hline
F   & F \to n  & F \to (S)&   &           &           &    \\
\hline
\end{array}$$

### Explica√ß√£o da Tabela

- $S \rightarrow TR$: Como $FIRST(S) = \{n, (\}$, colocamos "S ‚Üí TR" sob 'n' e '('.
- $R \rightarrow +S | \epsilon$: Com $FIRST(R) = \{+, \epsilon\}$ e $FOLLOW(R) = \{\$\}$, colocamos "R ‚Üí +S" sob '+' e "R ‚Üí \epsilon" sob '$', indicando redu√ß√£o a $\epsilon$ se o pr√≥ximo s√≠mbolo for '$'.
- $T \rightarrow FG$: Como $FIRST(T) = \{n, (\}$, colocamos "T ‚Üí FG" sob 'n' e '('.
- $G \rightarrow *T | \epsilon$: Com $FIRST(G) = \{*, \epsilon\}$ e $FOLLOW(G) = \{+, \$\}$, colocamos "G ‚Üí *T" sob '*' e "G ‚Üí \epsilon" sob '+' e '$', j√° que G pode levar a $\epsilon$.
- $F \rightarrow n | (S)$: Colocamos "F ‚Üí n" sob 'n' e "F ‚Üí (S)" sob '('.

As c√©lulas vazias indicam combina√ß√µes de entrada para as quais o parser LL(1) n√£o tem regra de produ√ß√£o aplic√°vel, o que pode levar a erros de sintaxe durante a an√°lise. Esta tabela √© fundamental para entender como o

## Testando com $n*n$

Para verificar se a string "n*n" faz parte da linguagem gerada pela gram√°tica e se pode ser analisada pelo parser LL(1) usando a tabela de an√°lise que constru√≠mos, seguiremos o processo de an√°lise descendente, come√ßando pelo s√≠mbolo inicial e utilizando a tabela de an√°lise para guiar a deriva√ß√£o.

Come√ßamos com a pilha contendo o s√≠mbolo inicial da gram√°tica, $ S $, e a string de entrada "n*n\$", onde o "$" indica o final da entrada.

1. Olhamos para o topo da pilha $ S $ e o pr√≥ximo s√≠mbolo de entrada ('n').
2. Usamos a tabela de an√°lise para encontrar a produ√ß√£o apropriada, que seria $ S \rightarrow TR $.
3. Substitu√≠mos $ S $ pela produ√ß√£o $ TR $ na pilha.
4. O pr√≥ximo passo √© olhar para o topo da pilha $ T $ e o pr√≥ximo s√≠mbolo de entrada ('n').
5. A tabela indica $ T \rightarrow FG $. Substitu√≠mos $ T $ por $ FG $.
6. O pr√≥ximo passo √© olhar para o topo da pilha $ F $ e o pr√≥ximo s√≠mbolo de entrada ('n').
7. A tabela indica $ F \rightarrow n $. Substitu√≠mos $ F $ por 'n'.
8. Agora a pilha tem 'nG' e a entrada √© "n*n". O pr√≥ximo passo √© consumir 'n' da entrada e da pilha, pois eles coincidem.
9. O topo da pilha agora √© $ G $ e o pr√≥ximo s√≠mbolo de entrada √© '*'.
10. A tabela indica $ G \rightarrow *T $. Substitu√≠mos $ G $ por '*T'.
11. Consumimos '*' da entrada e da pilha, pois eles coincidem.
12. O topo da pilha agora √© $ T $ novamente e o pr√≥ximo s√≠mbolo de entrada √© 'n'.
13. A tabela indica $ T \rightarrow FG $. Substitu√≠mos $ T $ por $ FG $.
14. O pr√≥ximo passo √© olhar para o topo da pilha $ F $ e o pr√≥ximo s√≠mbolo de entrada ('n').
15. A tabela indica $ F \rightarrow n $. Substitu√≠mos $ F $ por 'n'.
16. Consumimos 'n' da entrada e da pilha, pois eles coincidem.
17. O topo da pilha agora √© $ G $ e o pr√≥ximo s√≠mbolo de entrada √© '\$'.
18. A tabela indica $ G \rightarrow \epsilon $. Substitu√≠mos $ G $ por $ \epsilon $ e removemos $ G $ da pilha.
19. Finalmente, a pilha est√° vazia e a entrada foi completamente consumida.

Como conseguimos consumir toda a entrada "n\*n$" e esvaziar a pilha sem encontrar nenhum erro, a string "n\*n" √© de fato parte da linguagem identificada por este parser LL(1).



## Testando com "n*n+n"

Para analisar a string "n*n+n" usando o parser LL(1) e a tabela de an√°lise constru√≠da, seguir√≠amos o mesmo processo que usamos para a string anterior "n*n". No entanto, desta vez, adicionaremos o terminal '+' na entrada. Vamos ver o passo a passo:

Inicializamos a pilha com o s√≠mbolo inicial da gram√°tica, que √© $S$, e preparamos a string de entrada como "n*n+n\$", incluindo o sinal de fim de entrada "\$".

1. Olhamos para o topo da pilha $S$ e o primeiro s√≠mbolo de entrada ('n'). A tabela de an√°lise nos diz para usar a produ√ß√£o $S \rightarrow TR$.
2. Substitu√≠mos $S$ por $TR$ na pilha.
3. Agora o topo da pilha √© $T$, e o pr√≥ximo s√≠mbolo de entrada √© 'n'. A tabela de an√°lise nos indica que devemos usar $T \rightarrow FG$.
4. Substitu√≠mos $T$ por $FG$ na pilha.
5. O topo da pilha agora √© $F$, e o pr√≥ximo s√≠mbolo de entrada ainda √© 'n'. A tabela de an√°lise indica $F \rightarrow n$, ent√£o substitu√≠mos $F$ por 'n' e consumimos o 'n' da entrada.
6. Agora o topo da pilha √© $G$, e o pr√≥ximo s√≠mbolo de entrada √© '*'. A tabela nos diz que devemos usar $G \rightarrow *T$.
7. Substitu√≠mos $G$ por '*T' na pilha.
8. Consumimos '*' da entrada.
9. O topo da pilha agora √© $T$ novamente, e o pr√≥ximo s√≠mbolo de entrada √© 'n'. Novamente, a tabela de an√°lise nos indica que devemos usar $T \rightarrow FG$.
10. Substitu√≠mos $T$ por $FG$ na pilha.
11. O topo da pilha agora √© $F$, e o pr√≥ximo s√≠mbolo de entrada √© 'n'. Usamos a produ√ß√£o $F \rightarrow n$, substitu√≠mos $F$ por 'n' e consumimos 'n' da entrada.
12. O topo da pilha agora √© $G$, e o pr√≥ximo s√≠mbolo de entrada √© '+'. A tabela de an√°lise nos indica que devemos usar $G \rightarrow \epsilon$, ent√£o retiramos $G$ da pilha.
13. O topo da pilha agora √© $R$, e o pr√≥ximo s√≠mbolo de entrada √© '+'. A tabela nos diz que devemos usar $R \rightarrow +S$.
14. Substitu√≠mos $R$ por '+S' na pilha.
15. Consumimos '+' da entrada.
16. O topo da pilha agora √© $S$, e o pr√≥ximo s√≠mbolo de entrada √© 'n'. A tabela de an√°lise nos indica que devemos usar $S \rightarrow TR$.
17. Repetimos o processo para a nova ocorr√™ncia de $TR$ na pilha, com a entrada restante sendo 'n$'.

Finalmente, se todos os s√≠mbolos da entrada forem consumidos adequadamente e a pilha for esvaziada, ent√£o a string "n*n+n" √© aceita pela gram√°tica e o parser LL(1).

## Testando com "n-n*n"

Vamos analisar a string "n-n*n" utilizando a tabela de an√°lise LL(1) que foi estabelecida anteriormente, seguindo os passos do parser LL(1):

Come√ßamos com a pilha inicial contendo o s√≠mbolo inicial $S$ e a entrada "n-n*n\$".

1. A entrada come√ßa com 'n', ent√£o olhamos para $S$ na tabela de an√°lise e aplicamos a produ√ß√£o $S \rightarrow TR$.
2. Substitu√≠mos $S$ por $TR$ na pilha.
3. Com 'n' ainda como entrada e $T$ no topo da pilha, aplicamos $T \rightarrow FG$.
4. Substitu√≠mos $T$ por $FG$ na pilha.
5. O topo da pilha √© $F$ e a entrada √© 'n'. Aplicamos $F \rightarrow n$.
6. Consumimos 'n' da entrada, igualando a entrada e a pilha.
7. Agora $G$ est√° no topo da pilha e o pr√≥ximo s√≠mbolo de entrada √© '-', mas na nossa tabela de an√°lise LL(1), n√£o temos uma produ√ß√£o para $G$ quando o pr√≥ximo s√≠mbolo de entrada √© '-', o que implica que o parser n√£o pode prosseguir. A gram√°tica parece n√£o incluir produ√ß√µes para lidar com o terminal '-', o que √© necess√°rio para analisar express√µes com subtra√ß√£o.

Portanto, a string "n-n\*n" **n√£o faz parte da linguagem definida pela gram√°tica fornecida**, porque a gram√°tica n√£o tem regras para lidar com o s√≠mbolo '-'. Isso significa que a gram√°tica dada n√£o pode gerar a string fornecida, e o parser LL(1) falhar√° ao tentar analis√°-la. Para que a gram√°tica suporte opera√ß√µes como a subtra√ß√£o, regras adicionais precisariam ser inclu√≠das, o que exigiria uma revis√£o da defini√ß√£o de $G$ e $R$ para incluir e tratar corretamente o operador '-'.

## Uma Gram√°tica para Aritm√©tica

Considere o seguinte conjunto de regras de produ√ß√£o:

$$
\begin{array}{|lc|}
\hline
\textbf{Regras de Produ√ß√£o } \\ \hline
\space \space S \rightarrow E \\ \hline
\space \space E \rightarrow E + T \,|\, E - T \,|\, T \\ \hline
\space \space T \rightarrow T * F \,|\, T / F \,|\, F \\ \hline
\space \space F \rightarrow n \,|\, (E) \\ \hline
\end{array}
$$

Cuja cria√ß√£o foi baseada nos seguintes conceitos:

- $S$: S√≠mbolo de in√≠cio da gram√°tica.
- $E$: Representa uma express√£o, que pode ser uma soma ou subtra√ß√£o de termos ($T$), ou simplesmente um termo.
- $T$: Representa um termo, que pode ser um produto ou divis√£o de fatores ($F$), ou simplesmente um fator.
- $F$: Representa um fator, que pode ser um n√∫mero inteiro ($n$) ou uma express√£o entre par√™nteses.

Esse conjunto de regras de produ√ß√£o define uma gram√°tica que reflete a preced√™ncia dos operadores aritm√©ticos, de tal forma que: $*$ e $/$ t√™m maior preced√™ncia que $+$ e $-$, e os par√™nteses podem ser usados para alterar a ordem de avalia√ß√£o das express√µes.

A recurs√£o √† esquerda nas regras para $E$ e $T$ permite a continua√ß√£o das express√µes e termos, respectivamente. A op√ß√£o de $F\rightarrow (E)$ permite o uso de par√™nteses para agrupar express√µes e alterar a preced√™ncia padr√£o dos operadores.

Note que a representa√ß√£o de $n$ como um n√∫mero inteiro √© abstrata; em uma implementa√ß√£o real, voc√™ poderia criar regras adicionais para definir a estrutura de um n√∫mero inteiro, como uma sequ√™ncia de d√≠gitos. Ou, se for o caso, criar regras que incluam os n√∫meros reais e os n√∫meros inteiros.

### $FIRST \& FOLLOW$

#### C√°lculo dos Conjuntos FIRST

##### FIRST(S)

Como $S$ produz $E$ e s√≥ $E$, FIRST(S) = FIRST(E).

##### FIRST(E)

- $E$ pode produzir $T$ diretamente, ent√£o FIRST(E) inclui FIRST(T).
- Tamb√©m pode iniciar com $E + T$ ou $E - T$, mas isso eventualmente reduz a $T$, ent√£o n√£o adicionamos novos s√≠mbolos a FIRST(E) baseado nisso.
- Portanto, FIRST(E) √© baseado em FIRST(T).

##### FIRST(T)

- $T$ pode produzir $F$ diretamente, ent√£o FIRST(T) inclui FIRST(F).
- Tamb√©m pode iniciar com $T * F$ ou $T / F$, mas isso eventualmente reduz a $F$, ent√£o n√£o adicionamos novos s√≠mbolos a FIRST(T) baseado nisso.
- Assim, FIRST(T) = FIRST(F).

##### FIRST(F)

- $F$ pode produzir 'n' diretamente, ent√£o 'n' est√° em FIRST(F).
- $F$ tamb√©m pode produzir $(E)$, ent√£o '(' est√° em FIRST(F).
- Portanto, FIRST(F) = {'n', '('}.

Com base nas defini√ß√µes acima e entendendo que as produ√ß√µes para $E$ e $T$ s√£o recursivas √† esquerda e apenas rearranjam os mesmos conjuntos de s√≠mbolos iniciais (ou seja, eles sempre come√ßam com $T$ ou $F$, que levam a 'n' ou '('), podemos concluir:

$$FIRST(S) = FIRST(E) = FIRST(T) = FIRST(F) = {'n', '('}$$

Esses conjuntos FIRST indicam que as strings derivadas de $S$, $E$, $T$, e $F$ podem come√ßar com um n√∫mero inteiro ou um par√™ntese aberto, refletindo as op√ß√µes de iniciar uma express√£o aritm√©tica com um n√∫mero ou uma express√£o aninhada entre par√™nteses.

#### C√°lculo dos Conjuntos FOLLOW

##### FOLLOW(S)

- $S$ √© o s√≠mbolo inicial, ent√£o inclu√≠mos o s√≠mbolo de fim de entrada \$ em FOLLOW(S). N√£o h√° produ√ß√µes que levem a $S$ diretamente, ent√£o n√£o adicionamos mais nada.
- FOLLOW(S) = {\$}

##### FOLLOW(E)

- $E$ aparece dentro dos par√™nteses em $F \rightarrow (E)$, ent√£o $)$ est√° em FOLLOW(E).
- Todas as inst√¢ncias de $E$ est√£o seguidas por $+$ ou $-$ quando n√£o s√£o a √∫ltima coisa numa produ√ß√£o, ent√£o $+$ e $-$ est√£o em FOLLOW(E).
- Como $E$ √© o in√≠cio da gram√°tica (atrav√©s de $S$), tudo em FOLLOW(S) tamb√©m est√° em FOLLOW(E).
- FOLLOW(E) = {+, -, ), \$}

##### FOLLOW(T)

- $T$ √© seguido por $+$ e $-$ nas produ√ß√µes de $E$, ent√£o $+$ e $-$ est√£o em FOLLOW(T).
- $T$ tamb√©m aparece √† esquerda de $*$ e $/$ em suas pr√≥prias produ√ß√µes, ent√£o $*$ e $/$ est√£o em FOLLOW(T).
- Al√©m disso, qualquer coisa em FOLLOW(E) deve estar em FOLLOW(T), pois $E$ pode terminar com $T$.
- FOLLOW(T) = {+, -, *, /, ), \$}

##### FOLLOW(F)

- $F$ √© seguido por $*$ e $/$ em produ√ß√µes de $T$, ent√£o $*$ e $/$ est√£o em FOLLOW(F).
- $F$ tamb√©m √© o √∫ltimo n√£o-terminal nas produ√ß√µes de $T$ e $E$, assim tudo que est√° em FOLLOW(T) e FOLLOW(E) tamb√©m deve estar em FOLLOW(F).
- FOLLOW(F) = {+, -, *, /, ), \$}

### Conclus√£o

Os conjuntos FOLLOW para cada n√£o-terminal s√£o:

- FOLLOW(S) = {\$}
- FOLLOW(E) = {+, -, ), \$}
- FOLLOW(T) = {+, -, *, /, ), \$}
- FOLLOW(F) = {+, -, *, /, ), \$}

Esses conjuntos FOLLOW ajudam a definir os s√≠mbolos que podem seguir cada n√£o-terminal na deriva√ß√£o de strings da gram√°tica, orientando a constru√ß√£o de um parser preditivo para express√µes aritm√©ticas.
A tabela √© organizada com n√£o-terminais nas linhas e terminais (incluindo o final de entrada \$) nas colunas. Vamos preencher as entradas da tabela de acordo com as produ√ß√µes de nossa gram√°tica.

$$
\begin{array}{|l|c|c|c|c|c|c|c|c|}
\hline
 & \textbf{n} & \textbf{(} & \textbf{)} & \textbf{+} & \textbf{-} & \textbf{*} & \textbf{/} & \textbf{\$} \\ \hline
\textbf{S} & S \to E & S \to E & & & & & & \\ \hline
\textbf{E} & E \to TE' & E \to TE' & & E' \to \epsilon & E' \to \epsilon & & & E' \to \epsilon \\ \hline
\textbf{E'} & & & E' \to \epsilon & E' \to +TE' & E' \to -TE' & & & E' \to \epsilon \\ \hline
\textbf{T} & T \to FT' & T \to FT' & & T' \to \epsilon & T' \to \epsilon & & & T' \to \epsilon \\ \hline
\textbf{T'} & & & T' \to \epsilon & T' \to \epsilon & T' \to \epsilon & T' \to *FT' & T' \to /FT' & T' \to \epsilon \\ \hline
\textbf{F} & F \to n & F \to (E) & & & & & & \\ \hline
\end{array}
$$

### Preenchimento da Tabela

- Para $S \rightarrow E$, usamos diretamente na entrada 'n' e '(', que s√£o os √∫nicos s√≠mbolos em FIRST(S).
- Para $E \rightarrow T E'$, aplicamos quando o pr√≥ximo s√≠mbolo √© 'n' ou '(', que est√£o em FIRST(T). Para as produ√ß√µes $E \rightarrow E + T$ e $E \rightarrow E - T$, olhamos para FOLLOW(E), colocando essas produ√ß√µes nas colunas '+' e '-', respectivamente, porque esses s√£o os s√≠mbolos que podem seguir um $E$ na entrada.
- Para $T$, o racioc√≠nio √© similar: $T \rightarrow F T'$ se aplica para 'n' e '(', enquanto $T \rightarrow T * F$ e $T \rightarrow T / F$ s√£o usadas quando os pr√≥ximos s√≠mbolos s√£o '*' e '/', respectivamente, refletindo a preced√™ncia dos operadores.
- $F \rightarrow n$ √© usado quando o pr√≥ximo s√≠mbolo de entrada √© 'n', e $F \rightarrow (E)$ quando o pr√≥ximo s√≠mbolo √© '('.

Note que a tabela deixa v√°rias c√©lulas vazias, indicando erros de parsing para combina√ß√µes de entrada n√£o-terminais/terminais n√£o cobertas pelas regras da gram√°tica. Al√©m disso, n√£o h√° entradas para o s√≠mbolo de fechamento de par√™nteses ')' e o final de entrada '$' na maior parte das linhas, pois esses s√≠mbolos s√£o tratados via mecanismos de pilha e lookahead no processo de parsing, dependendo do contexto fornecido pelos conjuntos FOLLOW.

### Observa√ß√µes Importantes

1. **Tratamento de Erros:** A tabela de deriva√ß√£o apresentada √© did√°tica e oferece um caminho para analisar strings v√°lidas de acordo com uma gram√°tica explicitada por suas **Regras de Produ√ß√£o**. Por√©m, em um cen√°rio real, entradas inv√°lidas s√£o comuns, e um _parser_ precisa de mecanismos para identificar, reportar e possivelmente corrigir erros sint√°ticos. Isso ir√° envolver estrat√©gias diversas como pular _tokens_ at√© encontrar um que fa√ßa sentido no contexto atual ou fornecer mensagens de erro detalhadas que ajudem o usu√°rio a corrigir a entrada.

2. **Manipula√ß√£o de S√≠mbolos de Fechamento de Escopo:** A gram√°tica envolve o uso de par√™nteses para delinear o escopo de express√µes. A tabela assume que os par√™nteses ser√£o tratados corretamente como parte das regras de produ√ß√£o. No entanto, a implementa√ß√£o do parser precisa gerenciar explicitamente o escopo aberto e fechado pelos par√™nteses, garantindo que cada par√™ntese aberto seja correspondido por um fechamento apropriado e que os escopos sejam aninhados corretamente. Uma t√©cnica para a solu√ß√£o deste problema envolve contagem positiva e negativa.

3. **Preced√™ncia e Associatividade de Operadores:** Enquanto a gram√°tica e a tabela LL(1) refletem a preced√™ncia dos operadores (por exemplo, `*` e `/` t√™m maior preced√™ncia que `+` e `-`), a implementa√ß√£o precisa garantir que essas regras sejam aplicadas consistentemente para avaliar express√µes corretamente. Al√©m disso, a associatividade dos operadores (por exemplo, da esquerda para a direita) tamb√©m precisa ser considerada ao analisar express√µes com m√∫ltiplos operadores do mesmo n√≠vel de preced√™ncia.

4. **Otimiza√ß√µes:** Implementa√ß√µes reais de parsers frequentemente incorporam otimiza√ß√µes para melhorar a efici√™ncia, tanto em termos de velocidade quanto de uso de mem√≥ria. Isso pode incluir t√©cnicas para reduzir a quantidade de backtracking (se houver) ou para reutilizar resultados de an√°lises de subexpress√µes comuns.

