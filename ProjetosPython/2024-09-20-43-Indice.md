---
author: Frank
beforetoc: ''
categories:
- Matemática
- Linguagens Formais
- Programação
description: Dynamic Programming in C++ with practical examples, performance analysis,
  and detailed explanations to optimize your coding skills and algorithm efficiency.
draft: null
featured: true
image: assets/images/prog_dynamic.jpeg
keywords:
- Dynamic Programming
- C++ Algorithms
- Coding Examples
- Performance Optimization
- Algorithm Efficiency
- Programming Guide
- Code Comparison
- Developer Tips
lastmod: 2024-09-20 22:35:36.353000+00:00
layout: post
preview: In this comprehensive guide, we delve into the world of Dynamic Programming
  with C++. Learn the core principles of Dynamic Programming, explore various algorithmic
  examples, and understand performance differences through detailed code comparisons.
  Perfect for developers looking to optimize their coding skills and enhance algorithm
  efficiency.
published: 2024-06-27 19:43:15.124000+00:00
rating: 5
slug: competitive-programming-techniques-insights
tags:
- Matemática
- Linguagens Formais
- Programação Dinâmica
- Dynamic Programming
- C++ Algorithms
- Performance Analysis
- Coding Examples
- Algorithm Optimization
- Practical Programming Guide
title: Índice
toc: true
---
- [1. Introduction](%231-introduction)
- [2. C++ Competitive Programming Hacks](%232-c-competitive-programming-hacks)
  - [2.1 Typing Tips]()
  - [2.2 Why Typing Speed Matters]()
  - [2.3 Advanced Typing Techniques for Programmers]()
  - [2.4 Typing Less in Competitive Programming]()
    - [2.4.1. Using `#define` for `std::vector` Abbreviations](%23241-using-define-for-stdvector-abbreviations)
    - [2.4.2. Predefined Utility Functions](%23242-predefined-utility-functions)
    - [2.4.3. Predefining Common Operations](%23243-predefining-common-operations)
    - [2.4.4. Using Lambda Functions](%23244-using-lambda-functions)
    - [2.4.5 Prefer Not to Use `#define`](%23245-prefer-not-to-use-define)
  - [3. Optimizing File I/O in C++ for competitive programmings]()
    - [3.1 Disabling I/O Synchronization](%2331-disabling-io-synchronization)
    - [3.2 Command Line Argument Checking](%2332-command-line-argument-checking)
    - [3.3 Opening and Verifying the File](%2333-opening-and-verifying-the-file)
- [4. Introduction to File I/O in C++](%234-introduction-to-file-io-in-c)
  - [4.1 `std::ifstream`: File Reading]()
    - [4.1.1 Opening Files for Reading](%23411-opening-files-for-reading)
    - [4.1.2 Verifying File Opening](%23412-verifying-file-opening)
    - [4.1.3 File Reading](%23413-file-reading)
    - [4.1.4 File Closing](%23414-file-closing)
    - [4.1.5 File Writing - `std::ofstream`](%23415-file-writing---stdofstream)
    - [4.1.6 File Reading and Writing - `std::fstream`](%23416-file-reading-and-writing---stdfstream)
    - [4.1.7 File Opening Modes](%23417-file-opening-modes)
  - [4.2 Advanced File I/O Techniques in C++]()
    - [4.2.1 Using `mmap` for Faster File I/O in Unix-Based Systems](%23421-using-mmap-for-faster-file-io-in-unix-based-systems)
      - [4.2.1.1 How to Use `mmap`](%234211-how-to-use-mmap)
    - [4.2.2 Parallel Input/Output with Threads (C++20)](%23422-parallel-inputoutput-with-threads-c20)
  - [4.3 Efficient Techniques for File I/O and Array Handling in Competitive Programming]()
- [Maximizing Input/Output Efficiency in Competitive Programming (Windows and Linux)](%23maximizing-inputoutput-efficiency-in-competitive-programming-windows-and-linux)
  - [Optimized Input and Output]()
  - [Key Techniques for Faster I/O]()
  - [Differences Between Windows and Linux]()
  - [Using Manual Buffers with `fread` and `fwrite`]()
- [Introduction to Namespaces](%23introduction-to-namespaces)
  - [Basic Syntax of a Namespace]()
  - [Using Namespaces]()
    - [Accessing Elements of a Namespace](%23accessing-elements-of-a-namespace)
    - [`using namespace std;`](%23using-namespace-std)
  - [Disadvantages of Using `using namespace std;`]()
  - [Alternatives to `using namespace std;`]()
    - [Advanced Example: Nested Namespace](%23advanced-example-nested-namespace)
- [Working with Vector and Matrix](%23working-with-vector-and-matrix)
  - [Vectors]()
    - [Inserting Elements at a Specific Position](%23inserting-elements-at-a-specific-position)
    - [Removing the Last Element and a Specific Element](%23removing-the-last-element-and-a-specific-element)
    - [Creating a New Vector with a Default Value](%23creating-a-new-vector-with-a-default-value)
    - [Resizing and Filling with Random Values](%23resizing-and-filling-with-random-values)
    - [Sorting the Vector](%23sorting-the-vector)
  - [Matrices]()
    - [Creating and Filling a Matrix](%23creating-and-filling-a-matrix)
    - [Displaying the Matrix](%23displaying-the-matrix)
    - [Inserting Elements at a Specific Position](%23inserting-elements-at-a-specific-position)
    - [Removing the Last Element and a Specific Element](%23removing-the-last-element-and-a-specific-element)
    - [Creating a New Vector with a Default Value](%23creating-a-new-vector-with-a-default-value)
    - [Resizing and Filling with Random Values](%23resizing-and-filling-with-random-values)
    - [Sorting Matrices by Rows and Columns](%23sorting-matrices-by-rows-and-columns)
      - [Sorting by Rows](%23sorting-by-rows)
    - [Sorting by Columns](%23sorting-by-columns)
    - [Vectors as Inputs and Outputs](%23vectors-as-inputs-and-outputs)
      - [Optimized Version Using `fread` and `putchar` with Command-Line File Input](%23optimized-version-using-fread-and-putchar-with-command-line-file-input)
- [Efficient Data Manipulation in C++ using Span and Ranges](%23efficient-data-manipulation-in-c-using-span-and-ranges)
  - [Using `std::span`]()
    - [Efficient Use Cases for `std::span`](%23efficient-use-cases-for-stdspan)
    - [Comparing `std::span` to Traditional Methods](%23comparing-stdspan-to-traditional-methods)
    - [Practical Application: Using `std::span` in Competitive Programming](%23practical-application-using-stdspan-in-competitive-programming)
  - [Efficient Data Manipulation with `std::ranges` in C++20]()
    - [How `std::ranges` Works](%23how-stdranges-works)
    - [Composition of Operations](%23composition-of-operations)
    - [Memory and Performance Considerations](%23memory-and-performance-considerations)
    - [Practical Use Cases in Competitive Programming](%23practical-use-cases-in-competitive-programming)
- [Time and Space Complexity in Competitive Programming](%23time-and-space-complexity-in-competitive-programming)
  - [Loops, Time and Space Complexity]()
    - [Order of Growth](%23order-of-growth)
    - [Algorithm Phases and Time Complexity](%23algorithm-phases-and-time-complexity)
      - [Space and Time Complexity of Multiple Phases](%23space-and-time-complexity-of-multiple-phases)
  - [Recursive Algorithms]()
    - [Exponential Recursion](%23exponential-recursion)
    - [Common Complexity Classes](%23common-complexity-classes)
    - [Estimating Efficiency](%23estimating-efficiency)
- [Loops the heart of all competitive programming](%23loops-the-heart-of-all-competitive-programming)
  - [Deep Dive into `for` Loops in Competitive Programming]()
    - [1. `for` Loop with Iterator](%231-for-loop-with-iterator)
    - [2. Classic `for` Loop with Index](%232-classic-for-loop-with-index)
    - [3. Range-Based `for-each` with Constant Reference](%233-range-based-for-each-with-constant-reference)
    - [4. Range-Based `for-each` by Value](%234-range-based-for-each-by-value)
    - [5. `for` Loop with Range Views (C++20)](%235-for-loop-with-range-views-c20)
    - [6. Parallel `for` Loop (C++17/C++20)](%236-parallel-for-loop-c17c20)
    - [Optimal `for` Loops for Competitive Programming](%23optimal-for-loops-for-competitive-programming)
  - [Now the `while` Loop which we all love]()
    - [1. Basic `while` Loop](%231-basic-while-loop)
    - [2. `while` Loop with Complex Conditions](%232-while-loop-with-complex-conditions)
    - [3. Infinite `while` Loops](%233-infinite-while-loops)
    - [4. `do-while` Loop](%234-do-while-loop)
    - [5. `while` Loop with Early Exit](%235-while-loop-with-early-exit)
    - [6. Combining `while` with Multiple Conditions](%236-combining-while-with-multiple-conditions)
    - [Optimal `while` Loops for Competitive Programming](%23optimal-while-loops-for-competitive-programming)
  - [Special Loops in C++20 for Competitive Programming]()
    - [1. Range-Based Loops with `std::ranges::views`](%231-range-based-loops-with-stdrangesviews)
    - [2. Parallel Loops with `std::for_each` and `std::execution::par`](%232-parallel-loops-with-stdfor_each-and-stdexecutionpar)
  - [3. `constexpr` Loops]()
    - [Considerations for competitive programmings](%23considerations-for-competitive-programmings)
  - [4. Early Exit Loops]()
    - [Considerations for competitive programmings](%23considerations-for-competitive-programmings)
  - [5. Indexed Loops with Range-Based `for`]()
  - [6. Standard Library Algorithms (`std::for_each`, `std::transform`)]()
    - [Considerations for competitive programmings](%23considerations-for-competitive-programmings)
  - [Summary Table of Useful Loop Techniques for competitive programmings]()
- [Problems in One-Dimensional Arrays](%23problems-in-one-dimensional-arrays)
  - [Preprocessing and Efficient Query Techniques]()
    - [Algorithm: Sums and Prefixes](%23algorithm-sums-and-prefixes)
      - [Algorithm: Prefix Sum Array](%23algorithm-prefix-sum-array)
      - [Algorithm Prefix Sum in Plain English](%23algorithm-prefix-sum-in-plain-english)
    - [Understanding](%23understanding)
      - [Example](%23example)
      - [Complexity Analysis](%23complexity-analysis)
- [Example usage](%23example-usage)
- [Example usage](%23example-usage)
    - [Algorithm: Difference Array - Efficient Range Updates](%23algorithm-difference-array---efficient-range-updates)
      - [Mathematical Proof](%23mathematical-proof)
      - [Difference Array Algorithm Explained in Plain English](%23difference-array-algorithm-explained-in-plain-english)
      - [Complexity Analysis](%23complexity-analysis)
      - [Usage](%23usage)
- [Hardcoded inputs](%23hardcoded-inputs)
- [Initialize difference array](%23initialize-difference-array)
- [Apply all instructions](%23apply-all-instructions)
- [Reconstruct final heights](%23reconstruct-final-heights)
- [Print final heights for verification](%23print-final-heights-for-verification)
- [Calculate the median](%23calculate-the-median)
      - [Problem Example: "Humidity Levels in a Greenhouse" (Problem 1)](%23problem-example-humidity-levels-in-a-greenhouse-problem-1)
- [Exemplo de uso:](%23exemplo-de-uso)
    - [Algorithm: Incremental Sum](%23algorithm-incremental-sum)
- [Adjustment 1: Change arr[0] from 1 to 6](%23adjustment-1-change-arr0-from-1-to-6)
- [Adjustment 2: Change arr[1] from 2 to 3](%23adjustment-2-change-arr1-from-2-to-3)
      - [Complexity Analysis](%23complexity-analysis)
      - [Incremental Sum Mathematical Definitions](%23incremental-sum-mathematical-definitions)
    - [Incremental Sum Algorithm Explained in Plain English](%23incremental-sum-algorithm-explained-in-plain-english)
    - [Problem Example: "Humidity Levels in a Greenhouse" (Problem 1)](%23problem-example-humidity-levels-in-a-greenhouse-problem-1)
    - [Static Array Queries](%23static-array-queries)
    - [Range Minimum Queries (RMQ)](%23range-minimum-queries-rmq)
    - [Fenwick Tree](%23fenwick-tree)
  - [Sliding Window Algorithms]()
    - [Sliding Window Minimum](%23sliding-window-minimum)
    - [Sliding Window Maximum](%23sliding-window-maximum)
  - [Multiple Query Processing]()
    - [Mo's Algorithm](%23mos-algorithm)
      - [Why Choose $\sqrt{n}$ as the Block Size?](%23why-choose-sqrtn-as-the-block-size)
      - [Complexity Analysis](%23complexity-analysis)
      - [Implementation](%23implementation)
      - [Python Pseudocode](%23python-pseudocode)
- [Function to process the queries using Mo's Algorithm](%23function-to-process-the-queries-using-mos-algorithm)
- [Example usage](%23example-usage)
      - [C++20 Code Example](%23c20-code-example)
      - [Problem: "Humidity Levels in a Greenhouse" (Problem 1)](%23problem-humidity-levels-in-a-greenhouse-problem-1)
  - [Auxiliary Data Structures]()
    - [Deque (for Sliding Window Minimum/Maximum)](%23deque-for-sliding-window-minimummaximum)
    - [Sparse Table (for RMQ)](%23sparse-table-for-rmq)
    - [Segment Tree](%23segment-tree)
  - [Complexity Optimization Techniques]()
    - [Reduction from $O(n^2)$ to $O(n)$](%23reduction-from-on2-to-on)
    - [Update in $O(1)$](%23update-in-o1)
    - [Query in $O(1)$ after preprocessing](%23query-in-o1-after-preprocessing)
    - [Processing in $O((n + q) \sqrt{n})$](%23processing-in-on--q-sqrtn)
  - [Subarray Algorithms]()
    - [Kadane's Algorithm](%23kadanes-algorithm)
    - [Two Pointers](%23two-pointers)
  - [Hashing Techniques]()
    - [Prefix Hash](%23prefix-hash)
    - [Rolling Hash](%23rolling-hash)
  - [Partitioning Algorithms]()
    - [Partition Algorithm (QuickSelect)](%23partition-algorithm-quickselect)
    - [Dutch National Flag](%23dutch-national-flag)
  - [The Fenwick Tree]()
    - [Fundamental Concept](%23fundamental-concept)
      - [Querying the Fenwick tree](%23querying-the-fenwick-tree)
      - [Updating the Fenwick tree](%23updating-the-fenwick-tree)
    - [Basic Operations](%23basic-operations)
      - [Update](%23update)
      - [4.2 Prefix Sum Query](%2342-prefix-sum-query)
      - [4.3 Range Query](%2343-range-query)
    - [5. Fenwick tree Construction](%235-fenwick-tree-construction)
    - [Complexity Analysis](%23complexity-analysis)
    - [Variations and Extensions](%23variations-and-extensions)
      - [Range Update and Point Query](%23range-update-and-point-query)
      - [Range Update and Range Query](%23range-update-and-range-query)
      - [2D Fenwick tree](%232d-fenwick-tree)
    - [Applications](%23applications)
    - [Comparison with Other Structures](%23comparison-with-other-structures)
    - [Problem Example: "Humidity Levels in a Greenhouse" (Problem 1)](%23problem-example-humidity-levels-in-a-greenhouse-problem-1)
    - [Inventory Restocking](%23inventory-restocking)
      - [Naïve Solution](%23nave-solution)
- [Read the size of the inventory array](%23read-the-size-of-the-inventory-array)
- [Read the inventory array](%23read-the-inventory-array)
- [Read the number of adjustments](%23read-the-number-of-adjustments)
- [Initialize the sum of even numbers](%23initialize-the-sum-of-even-numbers)
- [Process the adjustments](%23process-the-adjustments)
    - [4 - Sales Target Analysis](%234---sales-target-analysis)
      - [Naïve Code](%23nave-code)
- [Search and Sorting Algorithms](%23search-and-sorting-algorithms)
  - [Binary Search]()
  - [Sorting]()
- [Data Structures](%23data-structures)
  - [Stacks and Queues]()
  - [Trees]()
  - [Priority Queues (Heaps)]()
  - [Hashing]()
- [Dynamic Programming (DP)](%23dynamic-programming-dp)
  - [Knapsack Problem]()
  - [Longest Increasing Subsequence]()
  - [Grid Pathfinding]()
- [Dynamic Programming](%23dynamic-programming)
  - [The Recursive Function]()
    - [The Dynamic Programming Function Using Memoization](%23the-dynamic-programming-function-using-memoization)
    - [The Dynamic Programming Function Using Tabulation](%23the-dynamic-programming-function-using-tabulation)
    - [Performance Evaluation and Support Functions](%23performance-evaluation-and-support-functions)
      - [Code 3: C-style Array](%23code-3-c-style-array)
      - [Running Code 3: using C-Style Array](%23running-code-3-using-c-style-array)
  - [Execution Time Comparison Table]()
  - [Your First Dynamic Programming Problem]()
    - [The "Two-Sum" problem](%23the-two-sum-problem)
    - [Brute-Force for Two-Sum's problem](%23brute-force-for-two-sums-problem)
      - [Recursive Approach: Divide and Conquer](%23recursive-approach-divide-and-conquer)
      - [Base Cases](%23base-cases)
      - [Recursive Step](%23recursive-step)
      - [Solution Analysis](%23solution-analysis)
      - [Dynamic Programming: memoization](%23dynamic-programming-memoization)
      - [Memoized Recursive Solution in C++20](%23memoized-recursive-solution-in-c20)
      - [Complexity Analysis of the Memoized Solution](%23complexity-analysis-of-the-memoized-solution)
      - [Dynamic Programming: tabulation](%23dynamic-programming-tabulation)
      - [C++ code for Two-Sum problem using tabulation](%23c-code-for-two-sum-problem-using-tabulation)
      - [Complexity Analysis of the Tabulation Function](%23complexity-analysis-of-the-tabulation-function)
      - [Execution Time Analysis](%23execution-time-analysis)
      - [The Dynamic Memory Bottleneck](%23the-dynamic-memory-bottleneck)
    - [We will always have C](%23we-will-always-have-c)
      - [Two-Sum C-Style Tabulation Function Complexity](%23two-sum-c-style-tabulation-function-complexity)
    - [High Performance C++](%23high-performance-c)
    - [Exercises: Variations of the Two Sum](%23exercises-variations-of-the-two-sum)
- [The Dynamic Programming Classic Problems](%23the-dynamic-programming-classic-problems)
  - [Problem 1 Statement: Counting All Possible Paths in a Matrix]()
    - [Using Brute-Force](%23using-brute-force)
    - [Using Memoization](%23using-memoization)
    - [Using Tabulation](%23using-tabulation)
  - [Problem 2 Statement: Subset Sum]()
  - [Problem 3 Statement: Longest Increasing Subsequence]()
    - [Brute-Force](%23brute-force)
    - [Memoization](%23memoization)
    - [Tabulation](%23tabulation)
- [5. Graphs and Graph Theory](%235-graphs-and-graph-theory)
- [6. Computational Geometry](%236-computational-geometry)
- [7. Number Theory and Modular Arithmetic](%237-number-theory-and-modular-arithmetic)
- [8. Combinatorics and Counting](%238-combinatorics-and-counting)
- [9. String Processing](%239-string-processing)
- [10. Simulation and Backtracking](%2310-simulation-and-backtracking)
- [11. NP-Complete Problems](%2311-np-complete-problems)
- [12. Ad-hoc Problems](%2312-ad-hoc-problems)
- [Notes and References](%23notes-and-references)