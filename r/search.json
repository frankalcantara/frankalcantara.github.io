[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Virando a Mesa no Jogo da Imitação",
    "section": "",
    "text": "1 Introdução\nNo coração da educação de disciplinas relacionadas à computação, especialmente nas disciplinas introdutórias, reside um desafio pedagógico fundamental percebido nos problemas encontrados para ensinar iniciantes a pensar como um programador. Essa habilidade, formalmente denominada Raciocínio Algorítmico, é a capacidade de decompor um problema complexo em uma sequência finita, não ambígua e executável de passos lógicos (1). O Institute of Electrical and Electronics Engineers, IEEE, define o Raciocínio Algorítmico como a habilidade de chegar a uma solução através da definição clara dos passos necessários (2). Não se trata de encontrar uma única resposta, mas de desenvolver um conjunto de regras ou instruções (um algoritmo) que, se seguido precisamente, resolve não apenas o problema original, mas também problemas similares (1). Como tal habilidade é essencial para a formação de profissionais competentes em Ciência da Computação e Engenharia, o ensino do Raciocínio Algorítmico deve ser uma prioridade curricular.\nO Jogo da imitação é o título no Brasil de uma adaptação cinematográfica da vida de Alan Turing (3). O jogo da imitação também seria um bom nome para os problemas pedagógicos que encontrados no ensino de Ciência e Engenharia da Computação. O termo imitação é usado aqui para descrever a tendência de muitos alunos de tentarem replicar soluções sem compreender os princípios subjacentes, resultando em uma superficialidade no aprendizado(4).\nMesmo que o aprendizado por imitação seja eficaz para transmitir rapidamente técnicas e algoritmos já estabelecidos, especialmente em ambientes complexos nos quais a programação manual é inviável (5), essa abordagem não apenas limita a capacidade dos alunos de resolver problemas complexos, mas também impede o desenvolvimento do Pensamento Computacional, uma habilidade essencial no século XXI (8).\nA deficiência pedagógica provocada pela pedagogia da imitação é frequentemente exacerbada pela falta de uma metodologia estruturada que guie os alunos na construção de um entendimento profundo e duradouro dos conceitos fundamentais (4). Acrescente-se a este cenário em que o problema da imitação em detrimento da compreensão profunda está sendo substancialmente agravado com a crescente integração da Inteligência Artificial no processo de ensino-aprendizagem (9).\nAo adotar sistemas de IA que priorizam a reprodução de padrões e soluções já existentes, corre-se o risco de perpetuar uma pedagogia da imitação, dificultando ainda mais a construção do raciocínio algorítmico autêntico entre estudantes e profissionais (11). Isso pode resultar em uma geração menos preparada para criar, adaptar ou inovar algoritmos diante de novos desafios.\nObserva-se que a ubiquidade das ferramentas de Inteligência Artificial Generativa, em particular dos Large Language Models1, LLMs, instaura um novo conjunto de desafios cognitivos e pedagógicos que exacerbam essa dinâmica (15).\nEste estudo propõe a implementação de uma disciplina introdutória de Raciocínio Algorítmico para cursos de Ciência e Engenharia da Computação, fundamentada em uma Metodologia DAAD (Decomposição, Abstração, Algoritmização e Depuração). Suportada pelos conceitos que levam ao desenvolvimento do Pensamento Computacional. Para tanto, além das definições e conceitos fundamentais, o trabalho explora a integração crescente do Pensamento Computacional e Raciocínio Algorítmico em currículos de universidades nos EUA, Reino Unido, Europa, destacando uma mudança do foco exclusivo na programação para uma compreensão mais ampla dos princípios computacionais.\nPara a prova de conceito, foi criada uma estrutura curricular detalhada para uma disciplina chamada de Raciocínio Algorítmico com 80 horas. Este projeto foi criado com a Metodologia DAAD, a experiência de 20 anos de aulas do autor em Universidades da Cidade de Curitiba e uma pesquisa bibliográfica realizada nas universidades dos EUA, UK e Europa. A disciplina está dividida em 4 módulos de ensino com conteúdos e exercícios que progridem do conceitual ao prático, enfatizando a aplicação de cada componente DAAD em todos os módulos da disciplina na forma de um framework composto de exercícios, estratégias pedagógicas, sugestões de avaliações, rubricas e objetivos. Além disso, o estudo sugere que essa metodologia pode ser generalizada para outras disciplinas de graduação em ciências, matemática e engenharia. Neste framework as estratégias pedagógicas incluem aprendizagem ativa, atividades unplugged e plugged, e oportunidades para o fomento da colaboração.\nAlém do framework pedagógico, inédito, este estudo também propõe uma técnica de aplicação de exercícios, também inédito, que usa a aplicação e repetição de conceitos para reforçar o aprendizado e a compreensão dos alunos. Esta técnica, baseado na Sequência de Fibonacci, projetado para ser flexível e adaptável, permitindo que os alunos pratiquem e apliquem os conceitos de Raciocínio Algorítmico em diferentes contextos e níveis de complexidade. O formato da Técnica da Sequência de Fibonacci, TSF se baseia nos estudos de (19).\nFinalmente, complementando o framework e a técnica de aplicação de exercícios, TSF, aqui propostos, este estudo também apresenta uma estrutura de Decomposição para a divisão de tarefas complexas entre alunos de um grupo de trabalho, visando o ensino de técnicas de divisão de projetos e tarefas complexas em partes menores e mais gerenciáveis, para fomentar as competências necessárias ao gerenciamento de projetos, trabalho em grupo e colaboração.\nEste documento começa com esta singela introdução, seguida por uma seção que apresenta os conceitos fundamentais do Raciocínio Algorítmico e do Pensamento Computacional. Em seguida, uma análise sobre a aplicação do ensino de Raciocínio Algorítmico em universidades dos EUA, Reino Unido e Europa que precede uma seção sobre a fundamentação teórica da Metodologia DAAD, específica para este estudo. A seguir, é apresentada a estrutura curricular da disciplina de Raciocínio Algorítmico, incluindo os módulos de ensino, objetivos, conteúdos e exercícios. O documento conclui com uma discussão sobre as implicações pedagógicas e sugestões para futuras pesquisas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Virando a Mesa no Jogo da Imitação",
    "section": "",
    "text": "em tradução livre, Modelos de Linguagem de Grande Escala. Esses modelos são capazes de gerar texto coerente e relevante com base em prompts fornecidos pelos usuários, o que pode levar a uma dependência excessiva dessas ferramentas para resolver problemas algorítmicos sem o devido entendimento dos princípios subjacentes.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD",
    "section": "",
    "text": "2.1 A Jornada Inacabada: O Problema do Ensino do Raciocínio Algorítmico\nAs críticas ao ensino de Raciocínio Algorítmico aparecem de forma relevante na academia a partir das últimas décadas do século XX. Os estudos de Lithner (2008)(13) destacaram que o ensino tradicional prioriza Raciocínio Algorítmico Imitativo, no qual alunos reproduzem procedimentos memorizados, em inglês Familiar Algorithmic Reasoning2, em detrimento do Raciocínio Matemático Criativo. Neste último, o aluno resolve o problema criando novas soluções a partir da combinação de conhecimentos díspares. Essa abordagem suprime a capacidade de decompor problemas e construir soluções originais, perpetuando uma cultura de superficialidade cognitiva (14). Os trabalhos de Lithner (2008)(13) e Harisman (2023) indicam que o ensino por imitação é parte significativa do problema. Mas, não é a única.\nPesquisas em educação matemática indicam que o ensino baseado em Raciocínio Algorítmico Imitativo pode comprometer a originalidade dos estudantes na solução de problemas novos. Isso ocorre porque a dependência de algoritmos predefinidos limita a capacidade de adaptação e inovação dos alunos diante de situações inéditas. Conforme Hurrell (2021)(15), o conhecimento procedimental, como fazer, caracterizado por sequências fixas de ações repetidas, não garante a compreensão necessária para gerar novas estratégias ou adaptar as conhecidas a novos problemas, o que reduz a originalidade na resolução.\nAlém disso, o National Council of Teachers of Mathematics, em seus Princípios e Padrões para a Matemática Escolar enfatiza que a aprendizagem matemática deve ir além do domínio de procedimentos algorítmicos e procedurais, promovendo a compreensão conceitual e a flexibilidade cognitiva(16). O documento alerta que a dependência excessiva de algoritmos e regras fixas pode inibir a transferência de conhecimentos para contextos inéditos e a capacidade de resolver problemas de forma criativa e inovadora (16).\nEstudos empíricos, ainda mais antigos, indicam que estudantes treinados predominantemente com técnicas algorítmicas apresentam até 32% menos originalidade na solução de problemas novos, em comparação com aqueles que desenvolvem compreensão conceitual e estratégias flexíveis (10).\nFinalmente, existem avaliações sobre a capacidade e eficiência da compreensão. O livro Programming: The Derivation of Algorithms (17) expôs como o ensino imperativo tradicional foca na sintaxe de laços de repetição e invariantes, usando a lógica de Hoare, negligenciando a construção de entendimento conceituais fundamentais. Essa metodologia foi criticada por substituir o “porquê” pelo “como”, limitando o Pensamento Computacional profundo (18). A Table 2.1 resume as principais críticas ao ensino tradicional de Raciocínio Algorítmico.\nUm problema mais recente para a criação das competências que levem ao Raciocínio Algorítmico e ao Pensamento Computacional parece estar relacionado com a Inteligência Artificial(4).\nO interesse na pesquisa de soluções de Inteligência Artificial, que segundo a Figure 2.1 se acentuou a partir de 2010.\nEste crescimento teve impacto na disponibilidade destas tecnologias, o que pode ser corroborado se considerarmos o aumento do uso de dispositivos contendo soluções embarcadas de Inteligência Artificial como pode ser visto na Figure 2.2.\nEsta velocidade de adaptação parece ter impactos negativos no binômio ensino-aprendizagem de forma geral em todos os cursos e formações.\nUm estudo recente conduzido pelo MIT Media Lab, intitulado Your Brain on ChatGPT: Accumulation of Cognitive Debt when Using an AI Assistant for Essay Writing Task3, publicado em junho de 2025, investigou os impactos do uso de modelos de linguagem grandes (LLMs), como o ChatGPT, na cognição humana, especificamente no contexto da escrita de ensaios(21). O estudo, ainda em forma de preprint e não revisado por pares, envolveu 54 participantes divididos em três grupos: um que utilizou o ChatGPT, outro que usou ferramentas de busca tradicionais e um terceiro que escreveu sem qualquer auxílio. Os resultados indicaram que os participantes que utilizaram o ChatGPT apresentaram menor atividade cerebral, menor retenção de memória e menor originalidade em seus escritos em comparação com os outros grupos(21). Além disso, o estudo sugeriu que o uso prolongado de LLMs pode levar a uma “dívida cognitiva”, com possíveis implicações a longo prazo para o aprendizado e o desenvolvimento cognitivo. No entanto, devido às limitações do estudo, como o tamanho da amostra e o foco específico no ChatGPT, os achados devem ser interpretados com cautela, e mais pesquisas são necessárias para generalizar os resultados (21).\nO estudo de SILVA QUINTO, W. A. et al. (22) investiga o impacto da Inteligência Artificial no desenvolvimento do pensamento crítico entre estudantes de Tecnologia da Informação na Região Norte do Brasil. Utilizando uma abordagem de métodos mistos, a pesquisa coletou e analisou respostas de 101 estudantes para entender suas percepções sobre o papel da Inteligência Artificial na sua formação acadêmica. Os resultados revelam que uma grande maioria (88,1%) reconhece a influência da Inteligência Artificial em seus estudos, com quase metade (47,3%) acreditando que as ferramentas de Inteligência Artificial facilitam a aprendizagem. No entanto, uma menor porção (13,2%) expressa preocupações de que a Inteligência Artificial pode impedir o desenvolvimento do pensamento crítico(22).\nO artigo Teaching AI with games: the impact of generative AI drawing on computational thinking skills4, publicado em 2025, investiga o impacto do uso de ferramentas generativas de Inteligência Artificial, como ferramentas generativas para desenho, no desenvolvimento de habilidades de Pensamento Computacional em 56 alunos do sexto ano de escolas no norte de Taiwan(23). Divididos em dois grupos: o experimental usando estas ferramentas com Inteligência Artificial embarcada e programação baseada em blocos para criar jogos; e o grupo de controle, usando ferramentas de busca disponíveis na internet. Os resultados indicaram que o grupo que usou Inteligência Artificial apresentou 23% menos domínio em abstração e uso de padrões lógicos, embora tenha completado tarefas mais rapidamente. A pesquisa sugere que a Inteligência Artificial (IA) acelera a execução, mas reduz a cognição lógica(4). Ainda que os autores tenham usado o termo Pensamento Algorítmico como sinônimo do conceito que neste estudo será representado, muitas vezes, por uma de suas partes o Raciocínio Algorítmico. É preciso ressaltar que o artigo destaca a necessidade de integrar essas ferramentas de forma equilibrada para promover habilidades que estão intimamente relacionadas com o Pensamento Computacional.\nNem tudo são avaliações negativas; ao longo do tempo foram realizadas tentativas de resolver os problemas do ensino de Raciocínio Algorítmico. Duas abordagens que se destacam: a Constructive Algorithmics, que em português poderia ser traduzida como algorítmica construtiva, e a Computação unplugged.\nA abordagem Constructive Algorithmics, desenvolvida por Richard Bird e Oege de Moor em 1997@BirdDeMoor1997, fundamenta-se no uso de raciocínio equacional e princípios da álgebra de programas por meio de uma abordagem matemática para a construção de programas de computador, tratando a programação como uma disciplina de engenharia e não como uma arte baseada em tentativa e erro(19). Esta metodologia prioriza a correção formal e a elegância matemática, permitindo a construção de algoritmos por meio de transformações verificáveis passo a passo. Um exemplo emblemático é a derivação de algoritmos de ordenação, como insertion sort, via composição funcional, no qual propriedades matemáticas garantem robustez lógica. Jeremy Gibbons 2020@GibbonsHaskell2020 aplicou esses mesmos princípios em Algorithm Design with Haskell5.\nA computação unplugged emerge como contraponto pedagógico, utilizando atividades manuais, como jogos de tabuleiro para decomposição de problemas e atividades com lápis e papel, para desenvolver bases conceituais do pensamento computacional. Estudos empíricos comprovam ganhos de até 37% no pensamento sistêmico e computacional. Os alunos internalizam conceitos abstratos, recursão, paralelismo, por meio de manipulação física e erro reflexivo (24). Porém sua eficácia decai em problemas de alta complexidade, como problemas de programação dinâmica ou otimização combinatorial, nos quais a abstração simbólica é indispensável. Por outro lado, estudos comparativos, como Unplugged versus plugged-in: examining basic programming achievement and computational thinking of 6th-grade students6 (25), demonstram que a falta de transição para ferramentas digitais limita a aplicação prática: alunos dominam puzzles com blocos, mas falham em traduzir lógica para código em problemas do mundo real, expondo uma fratura escalar no modelo (26).\nA Table 2.2 resume as principais diferenças entre as abordagens Constructive Algorithmics e Computação unplugged.\nDa ambiguidade, surge a integração híbrida como caminho promissor: iniciam-se com atividades não digitais, ou eletrônicas, para fundamentos e migra-se para Constructive Algorithmics com extensões que incluem análise como análise de vieses em algoritmos reais. Bird e de Moor em 1997@BirdDeMoor1997 já forneceram base para isso: seu método equacional pode ser estendido enquanto Gibbons (2020)(27) oferece ferramentas para essa transição ao usar Haskell em exemplos aplicados.\nDas pesquisas citadas é possível inferir que o ensino de Raciocínio Algorítmico e Pensamento Computacional permanece irresoluto porque supervaloriza eficiência em detrimento da análise: nas décadas de 1980 a 2000, pedagogias formaram gerações capazes de implementar BubbleSort, mas não de questionar por que usá-lo (27). Hoje, sistemas baseados em Inteligência Artificial agravam a superficialidade cognitiva (4).\nHoje, em julho de 2025, o cenário educacional ainda carece de uma abordagem unificada e estruturada para o ensino do Pensamento Computacional e do Raciocínio Algorítmico. A falta de uma metodologia clara, eficaz e prática para o ensino desses conceitos fundamentais limita o desenvolvimento das habilidades necessárias para a resolução de problemas computacionais. Dessa forma, este estudo propõe a criação de uma disciplina introdutória que utiliza a Metodologia DAAD como base para o desenvolvimento dessas competências, visando preencher essa lacuna no ensino superior. Uma disciplina que poderá ser chamada de Raciocínio Algorítmico.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span>"
    ]
  },
  {
    "objectID": "intro.html#sec-problema",
    "href": "intro.html#sec-problema",
    "title": "2  Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD",
    "section": "",
    "text": "Table 2.1: Estudos e possíveis razões por trás dos problemas persistentes no ensino de Raciocínio Algorítmico.\n\n\n\n\n\n\n\n\n\n\nFator\nImpacto Histórico\nEvidência Atual\n\n\n\n\nCurrículos Baseados em Eficiência\nPriorização de otimização (ex: complexidade O(n)) sobre metacognição.\nAlgoritmos como QuickSort são ensinados como fórmulas pré-definidas, sem discussão ou cognição (18).\n\n\nFalta de Formação Docente\nProfessores reproduzem métodos tradicionais por falta de treino em pedagogia criativa.\nEstudos mostram que educadores não dominam técnicas para mitigar dependência de Inteligência Artificial (19)\n\n\nInfraestrutura Cognitiva\nModelos mentais baseados em Raciocínio Algorítmico Imitativo dificultam a transição para Raciocínio Matemático Criativo.\nMeta-análises confirmam baixa transferência de conceitos algorítmicos entre domínios (20)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.1: Gráfico mostrando a evolução de publicações sobre Inteligência Artificial por tipo de publicação (2).\n\n\n\n\n\n\n\n\n\n\nFigure 2.2: Gráfico mostrando a evolução do número de dispositivos médicos contendo Inteligência Artificial embarcada segundo os dados da (2).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 2.2: Comparação entre as abordagens Constructive Algorithmics e Computação unplugged.\n\n\n\n\n\n\n\n\n\n\n\nAbordagem\nDescrição\nPontos Fortes\nLimitações\n\n\n\n\nAlgorítmica Construtiva\nUsa raciocínio equacional e álgebra de programas para derivar algoritmos em linguagens funcionais como Haskell (27).\nRigor matemático, correção formal, elegância na derivação de algoritmos (ex.: quicksort).\nDescontextualização ética, negligencia impactos sociais.\n\n\nComputação Unplugged\nUtiliza atividades manuais (ex.: jogos de tabuleiro) para ensinar Pensamento Computacional(25).\nGanhos de até 37% no pensamento sistêmico, internalização intuitiva de conceitos (recursão, paralelismo).\nIneficaz em problemas complexos (ex.: programação dinâmica), limitada transição para ferramentas digitais.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span>"
    ]
  },
  {
    "objectID": "intro.html#definições-fundamentais",
    "href": "intro.html#definições-fundamentais",
    "title": "2  Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD",
    "section": "2.2 Definições Fundamentais",
    "text": "2.2 Definições Fundamentais\nO Pensamento Computacional é uma estrutura que descreve um conjunto de habilidades de pensamento crítico e resolução de problemas, que tem ganhado significativa relevância como uma forma eficaz de ensinar essas habilidades em ambientes educacionais formais (29). Embora não seja a única abordagem para desenvolver essas competências, o Pensamento Computacional oferece uma maneira de analisar problemas para gerar soluções automatizadas ou semi-automatizadas que utilizam as capacidades únicas das tecnologias computacionais (30).\nÉ necessário considerar que o termo Pensamento Computacional parece ter sido criado por Papert (1985)(31), mas foi popularizado por Jeannette Wing, em 2006@Wing2006, argumentando que o Pensamento Computacional deveria ser considerado uma habilidade indispensável para todos, comparável à leitura, escrita e aritmética. Conceito no qual ela é apoiada por Saidin (2021)(32) e pela Computer Science Teachers Association@CSTA2011a. O Pensamento Computacional é reconhecido globalmente como uma das habilidades vitais para o século XXI, essencial para a resolução de problemas complexos em diversas áreas (33). O que pode ser corroborado com a pesquisa bibliográfica, realizada via internet, em sites de universidades nos EUA, Reino Unido, Europa e China. Esta pesquisa demonstrou uma tendência crescente na integração do Pensamento Computacional nos currículos de graduação, com ênfase em abordagens práticas e baseadas em projetos cujas características veremos na Chapter 3.\nJeannette Wing define o Pensamento Computacional como “os processos de pensamento envolvidos na formulação de problemas e suas soluções de forma que as soluções possam ser efetivamente executadas por um agente de processamento de informações” (11). Ela também o descreve como a resolução de problemas, o design de sistemas e a compreensão do comportamento humano, baseando-se em conceitos estruturantes da ciência da computação (34). O Pensamento Computacional é uma combinação de hábitos mentais disciplinados, atitudes de perseverança e habilidades interpessoais essenciais (12). Ele se distingue de outras abordagens de resolução de problemas, como o Pensamento Científico ou o design thinking, principalmente por seu foco em soluções algorítmicas e no desenvolvimento de sistemas que envolvem processamento de informações (35).\nDe acordo com Wing (2006) (11), o Pensamento Computacional estrutura-se em componentes fundamentais que transcendem a mera programação: a decomposição, fragmentação de problemas complexos em partes gerenciáveis, o reconhecimento de padrões, identificação de similaridades e tendências em diferentes contextos, a abstração, seleção de elementos essenciais e eliminação de detalhes irrelevantes, e o design algorítmico, criação de instruções passo a passo para solução automatizada, complementados por processos de generalização, aplicação de soluções a problemas análogos e modelagem, representação de sistemas do mundo real através de estruturas computacionais, formando uma abordagem holística para a resolução eficiente de problemas (11).\nAs características e a definição de Pensamento Computacional criam o cenário necessário ao entendimento do problema do ensino de Raciocínio Algorítmico.\nEm essência, o raciocínio algorítmico pode ser definido como uma forma de pensamento lógico e organizado utilizada para desmembrar um objetivo complexo em uma série de etapas ordenadas, empregando as ferramentas disponíveis (12). Um método de pensamento que guia processos de raciocínio por meio de procedimentos passo a passo, que exigem entradas e produzem saídas, demandando decisões sobre a qualidade e adequação das informações, e monitorando os próprios processos de pensamento para controlá-los e dirigi-los (12). É, portanto, simultaneamente um método de pensar e um meio para pensar sobre o próprio pensamento (12).\nEste constructo envolve um conjunto de habilidades cognitivas cruciais para a construção, compreensão e avaliação de algoritmos muito similares às habilidades necessárias para o Pensamento Computacional. As principais habilidades cognitivas que compõem o Raciocínio Algorítmico incluem (12):\n\nDecomposição: a capacidade de fragmentar um problema ou sistema complexo em partes menores ou sub-objetivos mais gerenciáveis (12).\nAbstração: habilidade de identificar os componentes essenciais de um problema ou sistema, o que implica coletar informações relevantes e descartar as irrelevantes, construindo representações que demonstrem como o problema ou sistema funciona (12).\nAlgoritmização (ou Design Algorítmico): o desenvolvimento de uma sequência de passos lógicos e ordenados para resolver um problema ou alcançar um objetivo (12). As regras que especificam o algoritmo devem ser precisas e determinadas (12).\nCompreensão, Análise e Especificação Precisa de Problemas: inclui a formulação de problemas e o desenvolvimento de uma sequência de passos composta por ações básicas que os resolverão, considerando casos simples e complexos, normais e especiais (36).\nAvaliação e Otimização: a capacidade de avaliar, aprimorar ou otimizar a eficiência de um algoritmo, considerando abordagens alternativas (36).\n\nHistoricamente, o termo Raciocínio Algorítmico antecedeu e se fundiu com o Pensamento Computacional (37). Alan Perlis, na década de 1960, cunhou o termo algoritmizar para descrever uma prática e um pensamento que levariam à automação de procedimentos em todas as indústrias (37). Edsger Dijkstra, um dos pilares da Ciência da Computação, delineou características do raciocínio algorítmico, como a capacidade de transitar entre níveis semânticos e de utilizar a língua materna como ponte entre problemas informais e soluções formais (37).\nNo contexto do Pensamento Computacional, a automação é um elemento indispensável para caracterizar a essência do raciocínio algorítmico, distinguindo-o de outras formas de pensamento, como o matemático, ao focar na implementação de instruções em dispositivos digitais por meio de programação (28). Este é, portanto, um pilar que permite a concepção de soluções que exploram as capacidades únicas das tecnologias computacionais.\nEm sua pesquisa, Ribeiro, L. et al (2017)(38) diferenciam raciocínio lógico, fundamentado em premissas e inferências, do raciocínio computacional, focado em abstração, automação e análise, enquanto fazem avaliações sobre a redução do Pensamento Computacional à criação de algoritmos, ressaltando que o Raciocínio Algorítmico é apenas um dos pilares do Pensamento Computacional, não sua totalidade. KONG, S. et al.@Kong2019 destacam que o Raciocínio Algorítmico é frequentemente confundido com o Pensamento Computacional por ser seu elemento mais tangível, especialmente em contextos de programação. Mais tarde, estes mesmos autores alertam que essa visão reduz o Pensamento Computacional a habilidades técnicas, negligenciando pilares como a decomposição de problemas e o pensamento analítico(39). O estudo de MEDEIROS (2024)(40) analisou 38 trabalhos brasileiros sobre Pensamento Computacional (2018–2024) e identificou que 76% deles equiparavam Pensamento Computacional ao ensino de algoritmos, via Scratch ((41)) ou aplicações de robótica. Concluindo que a ênfase excessiva no Raciocínio Algorítmico subestima outros pilares do Pensamento Computacional, tais como pensamento algébrico e resolução criativa de problemas (42).\nUma questão interessante surge do trabalho de Hora (2022)(43) que destaca que no Brasil o Pensamento Computacional é frequentemente restrito a disciplinas de exatas, Matemática e Computação, nas quais o Raciocínio Algorítmico domina as práticas pedagógicas, fazendo análises sobre o viés tecnicista que ignora dimensões como abstração contextualizada e análise sociotécnica. Destacando a abrangência do Pensamento Computacional. Dessa forma Hora (2022)(43) sustenta os trabalhos de Wing (2006) (11) e (12). Além disso, Felipussi e Padua (2023)(44) perceberam que os professores tendem a associar Pensamento Computacional diretamente à programação de robôs, tratando algoritmo como sinônimo de Pensamento Computacional.\nA própria Sociedade Brasileira de Computação (2017)(42) adverte que a BNCC (Base Nacional Comum Curricular) não distingue claramente Raciocínio Algorítmico e Pensamento Computacional, gerando ambiguidade em propostas pedagógicas e recomenda equilibrar o ensino de algoritmos com atividades de decomposição de problemas não lineares.\nFinalmente, existem trabalhos que indicam que a ambiguidade entre Pensamento Computacional e Raciocínio Algorítmico pode ter consequências negativas na formação do indivíduo.\nDo trabalho de Medeiros (2024)(40) podemos inferir que os estudantes desenvolvem habilidades técnicas (ex.: codificar em blocos) mas falham em aplicar Pensamento Computacional em contextos interdisciplinares. As humanidades e artes raramente integram Pensamento Computacional em seus currículos, pois o Raciocínio Algorítmico é visto como não aplicável (45). Por fim, as avaliações de Pensamento Computacional focam em correção algorítmica e eficiência do código, não em processos mentais como abstração (46).",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span>"
    ]
  },
  {
    "objectID": "intro.html#primeiro-contato-com-a-metodologia-daad",
    "href": "intro.html#primeiro-contato-com-a-metodologia-daad",
    "title": "2  Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD",
    "section": "2.3 Primeiro Contato com a Metodologia DAAD",
    "text": "2.3 Primeiro Contato com a Metodologia DAAD\nA Metodologia DAAD (Decomposição, Abstração, Algoritmização e Depuração), aqui proposta, estende uma discussão da Cambridge Mathmatics (1) e a análise feita por LEHMANN (2024)(36), sob os efeitos da algoritmização. O que este estudo propõe difere dos estudos anteriores por apresentar um framework prático iterativo de ações, exercícios e temas de estudo com o intuito de permitir a criação de Pensamento Computacional e Raciocínio Algorítmico em alunos de graduação, baseado nos estudos teóricos e empíricos de Wing (2006)(11), Lehmann (2023, 2024)(12),(36), Kirwan (2022)(47), KONG, Siu-Cheung et al. (2019)(46) e muitos outros que estão citados ao longo deste documento, sobre temas que abordam o Raciocínio Algorítmico e o Pensamento Computacional. Para tanto, este framework está estruturado em quatro estágios iterativos:\n\nDecomposição (D): processo de fragmentação de problemas complexos em subproblemas gerenciáveis, seguindo princípios de divisão funcional ou estrutural. Exemplo: Quebrar um sistema de recomendação em: coleta de dados, filtragem, ranking e interface. Wing (2006)(11), SBC (2017)(42) e Lehmann (2024)(36) estabelecem decomposição como pilar cognitivo essencial.\nAbstração (A): identificação seletiva de padrões e invariantes essenciais, com descarte consciente de detalhes irrelevantes ao núcleo do problema. Exemplo: Modelar tráfego urbano considerando apenas fluxo veicular médio, ignorando marcas e combustível. Baseia-se no conceito de “abstração progressiva” perceptível na Linguagem LOGO de Papert (1985)(31).\nAlgoritmização (A): formulação de soluções por meio de sequências lógico-operacionais, garantindo completude e implementabilidade. Exemplo: Projetar heurística para otimização de rotas usando grafos valorados e seleção gulosa. Alinha-se ao paradigma de descrição de estados finais. A essência do projeto algorítmico reside na descrição formal de estados finais, nos quais a corretude é verificada pelo atendimento inequívoco de pós-condições (19). Incluímos aqui, os conceitos:\n\nAlgoritmização (ou Design Algorítmico): o desenvolvimento de uma sequência de passos lógicos e ordenados para resolver um problema ou alcançar um objetivo (12). As regras que especificam o algoritmo devem ser precisas e determinadas (12).\nCompreensão, Análise e Especificação Precisa de Problemas: inclui a formulação de problemas e o desenvolvimento de uma sequência de passos composta por ações básicas que os resolverão, considerando casos simples e complexos, normais e especiais (36).\n\n\nNotadamente porque o segundo é parte integrante do primeiro, e ambos são fundamentais para a construção de soluções computacionais eficazes. A Algoritmização é o processo de criação de algoritmos, enquanto a Compreensão, Análise e Especificação Precisa de Problemas envolve a formulação e decomposição de problemas em etapas lógicas que podem ser resolvidas por meio de algoritmos.\n\nDepuração (D): refinamento iterativo mediante validação empírica, incluindo testes de robustez, análise de falhas e otimização pós-implementação. Exemplo: Injeção de dados corrompidos em pipelines de processamento para validar resiliência. Incorpora princípios de “engenharia resiliente” de Leveson (2012) (49). Ou seja, a Depuração abrange os conceitos relativos a Avaliação e Otimização: a capacidade de avaliar, aprimorar ou otimizar a eficiência de um algoritmo, considerando abordagens alternativas (36).\n\nEm um ambiente no qual existem ambiguidades e avaliações sobre a formação fundamental dos alunos de graduação, a Metodologia DAAD foca prioritariamente nos processos matemáticos e lógicos envolvidos na criação e depuração de soluções computacionais como ferramentas indispensáveis para a solução de problemas.\nA busca bibliográfica realizada para este estudo indicou que a Metodologia DAAD como está proposta parece ser a única ferramenta disponível que oferece uma estrutura prática iterativa para o ensino do Raciocínio Algorítmico, abordando tanto a decomposição de problemas quanto a abstração necessária para a criação de algoritmos eficazes e, principalmente, depuração. A relação e integração conceitual entre os componentes da Metodologia DAAD (Decomposição, Abstração, Algoritmização e Depuração) está ilustrada na Figure 2.3\n\n\n\n\n\n\nFigure 2.3: Ilustração da inter-relação entre Decomposição, Abstração, Algoritmização e Depuração. Fonte: o autor.\n\n\n\nA Metodologia DAAD modifica os tradicionais “Quatro Pilares do Pensamento Computacional” de Wing@Wing2006 ao substituir “Reconhecimento de Padrões” por “Depuração”, concordando com Lehmann@Lehmann2024 e com a Cambridge Mathematics@CambridgeMaths. Essa mudança adequa o Pensamento Computacional ao Raciocínio Algorítmico, enfatizando o processo ativo de criação de algoritmos e a habilidade essencial de detecção e correção de erros, a depuração. Criando uma metodologia iterativa adequada à solução de problemas em um ciclo de entendimento, abstração, construção da solução e depuração.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span>"
    ]
  },
  {
    "objectID": "intro.html#sec-estrat",
    "href": "intro.html#sec-estrat",
    "title": "2  Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD",
    "section": "2.4 Estratégias Pedagógicas e Materiais Didáticos para o Ensino de DAAD",
    "text": "2.4 Estratégias Pedagógicas e Materiais Didáticos para o Ensino de DAAD\nO ensino eficaz dos componentes do Raciocínio Algorítmico usando a Metodologia DAAD, Decomposição, Abstração, Algoritmização, Debugging, exige estratégias pedagógicas que transcendem as aulas expositivas tradicionais, promovendo o engajamento ativo e a aplicação prática. E deve superar o Jogo da Imitação 1 como metodologia de ensino. O que está proposto neste estudo é uma abordagem progressiva e integrada entre atividades unplugged ou desconectadas, plugged ou conectadas e o estudo independente para desenvolver o Pensamento Computacional.\nIniciar cada tema possível com atividades unplugged permite que os alunos construam uma compreensão conceitual sólida sem a barreira da sintaxe de programação (51). Posteriormente, essas compreensões conceituais são reforçadas e aplicadas por meio de desafios de programação plugged (51). Essa progressão didática pretende que os alunos compreendam os porquês antes de se aprofundarem nos comos, otimizando o processo e os resultados do aprendizado(15).\nA Metodologia Flipped Classroom (52), aplicada pela ETH Zurich (53), é uma estratégia pedagógica que inverte a dinâmica tradicional de ensino. A metodologia Flipped Classroom utiliza a expressão em inglês para sala de aula invertida para representar uma abordagem pedagógica que reverte a sequência do processo de ensino-aprendizagem. Nas últimas décadas, a introdução de novos conceitos passou a ocorrer em sala de aula majoritariamente, seguida por atividades de reforço em casa o que Bergmann (2012)(52) considera ineficiente. Segundo a metodologia Flipped Classroom, o estudo inicial do conteúdo deve ser realizado pelos alunos fora do ambiente de aula, por meio de materiais previamente fornecidos, de forma independente. Esse preparo prévio permite que o tempo em sala de aula seja otimizado para a prática, discussão e resolução de problemas, com o professor atuando como um orientador(52).\nA Aprendizagem Baseada em Projetos (PBL) (54) é uma estratégia amplamente utilizada e eficaz para o ensino de Pensamento Computacional (55). A metodologia PBL envolve os alunos na resolução de problemas complexos e autênticos do mundo real, permitindo-lhes construir conhecimento significativo por meio da investigação, cooperação e prática (46). Essa abordagem fomenta a autonomia do aluno, a criatividade e a capacidade de resolver problemas (55). Exemplos incluem a criação de modelos computacionais sobre furacões usando Scratch (41) ou o design de aplicativos para necessidades sociais (55).\nAs atividades unplugged ensinam o Pensamento Computacional sem o uso de dispositivos digitais, utilizando materiais como papel, cartas ou atividades físicas (50). Estas atividades permitem que os alunos se concentrem nos conceitos subjacentes do Pensamento Computacional sem se prenderem à sintaxe de uma linguagem de programação (50). Exemplos incluem programar um colega para realizar uma tarefa simples, usar mapas para ilustrar a abstração e a criação de fluxogramas da resolução do problema(28). O uso de atividades unplugged antes da programação baseada em computador pode levar a melhores resultados de aprendizagem (28).\nA Aprendizagem Ativa e Colaborativa é altamente incentivada (22). Discussões em equipe, resolução de problemas em grupo e a comunicação de soluções alternativas são práticas que fomentam o Pensamento Computacional. A aprendizagem colaborativa, facilitada por tecnologias simples, pode melhorar as habilidades de resolução de problemas e o engajamento dos alunos(22).\nA Abordagem Heurística e Baseada em Problemas envolve apresentar problemas desafiadores e guiar os alunos a explorar e inovar, escalando gradualmente a complexidade, o que é indispensável para aprofundar a compreensão do Pensamento Computacional (55). A abordagem socrática, na qual os conceitos são desenvolvidos por meio de questionamento dos alunos, também se mostra eficaz (57). Ao serem desafiados com perguntas como “Como você pode quebrar esse problema em etapas menores?” ou “Que padrões você nota que podem ser úteis para resolver este problema?”, os estudantes desenvolvem habilidades de pensamento analítico (57).\nNo contexto dessas abordagens, o papel do professor se transforma de um mero transmissor de conhecimento para um facilitador, diagnosticador e curador do conhecimento (39). O educador deve atuar como gerador de questionamento, não fornecendo todas as soluções, mas guiando os alunos para que resolvam os problemas por si mesmos (55). A capacidade do professor de diagnosticar dificuldades e oferecer orientação direcionada é determinante para o sucesso do processo de aprendizagem (55). Estas características parecem indicar a necessidade de formação e desenvolvimento profissional para os educadores, capacitando-os não apenas no conhecimento do Pensamento Computacional, mas também nas estratégias pedagógicas para a sua implementação eficaz, incluindo a criação de ambientes de aprendizagem ativos e a oferta de retorno avaliativo construtivo.\n\n2.4.1 Materiais Didáticos e Ferramentas\nA literatura e as práticas educacionais atuais oferecem uma variedade de recursos didáticos e ferramentas para o ensino do Pensamento Computacional e do Raciocínio Algorítmico. Estes recursos são fundamentais para a implementação eficaz da Metodologia DAAD e incluem:\n\nLinguagens de Programação: Python(59) é frequentemente citada como uma linguagem de programação ideal para o ensino de Pensamento Computacional, especialmente em disciplinas introdutórias, devido à sua estrutura direta e facilidade de uso (60). Outras linguagens como OCaml(61), Java(62), C(63), C++(64) e Prolog (65) também são utilizadas em currículos mais avançados (66) (60).\n\nAmbientes de Desenvolvimento e Ferramentas Visuais: Ambientes como Scratch(41) (para crianças e iniciantes), XLogo4Schools(67) para Logo(31) e Python, são empregados para reduzir a carga cognitiva e permitir que o foco recaia nos conceitos, notadamente para crianças e adolescentes (68). Além disso, ferramentas de depuração são essenciais para o aprendizado (55).",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span>"
    ]
  },
  {
    "objectID": "intro.html#melhores-práticas-e-desafios-na-implementação-de-metodologias-de-resolução-de-problemas",
    "href": "intro.html#melhores-práticas-e-desafios-na-implementação-de-metodologias-de-resolução-de-problemas",
    "title": "2  Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD",
    "section": "2.5 Melhores Práticas e Desafios na Implementação de Metodologias de Resolução de Problemas",
    "text": "2.5 Melhores Práticas e Desafios na Implementação de Metodologias de Resolução de Problemas\nA implementação de metodologias de resolução de problemas, como o Raciocínio Algorítmico, como parte integrante do Pensamento Computacional, no ensino superior no Brasil apresenta complexidades significativas. Um mapeamento sistemático da literatura nacional revelou um crescente interesse em iniciativas que estimulam o Pensamento Computacional(29). No entanto, a tradução da relevância teórica em práticas educacionais eficazes e amplamente disseminadas enfrenta desafios. A pesquisa aponta para uma grande diversidade nos instrumentos e artefatos utilizados para a avaliação (29). A discussão sobre a granularidade das avaliações, seja em alto nível desempenho final, ou granularidade fina, habilidades específicas, e a complexidade de sua mensuração eficiente, somada à questão da replicabilidade dos estudos empíricos devido à frequente ausência de detalhes metodológicos, indicam lacunas na padronização e na generalização das práticas avaliativas e de implementação (36). Desse modo, embora o reconhecimento da importância do Raciocínio Algorítmico no cenário educacional brasileiro seja evidente, sua plena e homogênea integração ainda é permeada por desafios de ordem prática e metodológica.\n\n2.5.1 Melhores Práticas Identificadas na Literatura\nO Pensamento Computacional é mais eficaz quando integrado em diversas disciplinas, não apenas nas disciplinas relacionadas a Ciência da Computação (39). Para tanto é necessário a contextualização dos problemas em cenários do mundo real ou em suas próprias pesquisas aumenta o engajamento dos alunos (55). Essa abordagem permite que os alunos apliquem as estruturas cognitivas desenvolvidas à solução de problemas relevantes para suas áreas de estudo, desde a análise de dados históricos até a otimização de processos logísticos(39).\nO ensino integral, voltado para a formação do indivíduo presupõe que. além das habilidades técnicas, o ensino de Pensamento Computacional deve cultivar atitudes como confiança na resolução de problemas, persistência diante de desafios, tolerância a diferenças e capacidade de colaborar [Huang2020ComputationalThinking.]. A aprendizagem baseada em projetos e atividades unplugged são eficazes para fomentar essa mentalidade (50). Além disso, as práticas de Raciocínio Algorítmico, especialmente a depuração, a detecção sistemática de erros, exigem tentativas múltiplas e processos iterativos de revisão e refinamento, visto que programas raramente funcionam corretamente na primeira execução (46). Isso fomenta a resiliência frente a obstáculos. O Raciocínio Algorítmico exige a avaliação e otimização contínua de soluções (36,12).\nDo ponto de vista da formação profissional, será indispensável garantir que os professores tenham um alto nível de conhecimento e prontidão em Pensamento Computacional e Raciocínio Algorítmico (55). Programas de desenvolvimento profissional que ofereçam ferramentas e ideias aprofundadas para a integração são essenciais. Isso inclui o apoio aos professores para criar novos materiais instrucionais e adaptar suas estratégias pedagógicas (55).\nFinalmente, introduzir conceitos de Pensamento Computacional de forma gradual, revisitando e expandindo a compreensão ao longo do currículo, parece ser uma prática eficaz (35). Começar com atividades unplugged e progredir para desafios de programação plugged pode otimizar o aprendizado (50).\n\n\n2.5.2 Desafios Comuns\nO primeiro desafio surge da falta de consenso na definição e na operacionalização do ensino de Pensamento Computacional. Neste cenário, uma das maiores dificuldades é a ausência de uma definição única e universalmente aceita (50). Essa ambiguidade afeta o design do currículo, a seleção de tópicos e, principalmente, a avaliação das habilidades dos alunos (46). Além disso, muitos educadores carecem de compreensão, confiança e habilidades necessárias para implementar o Pensamento Computacional de forma eficaz (32), ainda que suas disciplinas sejam diretamente ligadas a computação (28). Por fim, a expectativa de que as habilidades de Pensamento Computacional se desenvolvam naturalmente em alunos de ciência da computação é muitas vezes inadequada e irreal (35).\nA integração do Pensamento Computacional em currículos já estabelecidos, especialmente em disciplinas não diretamente relacionadas com ciência, matemática e as engenharias, pode ser um desafio devido à falta de uma abordagem padronizada (46). Alguns conceitos e práticas de Raciocínio Algorítmico, como condicionais, dados, operadores, testes e depuração, e abstração/modularização, são identificados como difíceis de aprender para alunos iniciantes (45). O que diminui a autoestima e estudantes com baixa autoeficácia ou menor confiança em suas habilidades, como as de escrita, tendem a depender mais de ferramentas de IA, priorizando soluções imediatas em vez de desenvolver habilidades cognitivas e criativas (21). Por outro lado, a percepção de que o processo de aprendizado é sem esforço devido à disponibilidade instantânea de soluções pode desencorajar tentativas de resolução independente de problemas e reduzir a motivação dos estudantes para realizar pesquisas ou gerar suas próprias soluções (21). Além disso, a falta de estímulo mental decorrente do uso excessivo de ferramentas que simplificam o processo pode, consequentemente, diminuir o desenvolvimento cognitivo e afetar negativamente a memória (21).\n\n\n2.5.3 Avaliação e Mensuração de Habilidades de Pensamento Computacional\nA avaliação das capacidades de realização do Pensamento Computacional é complexa e as ferramentas existentes são limitadas, muitas vezes focando em percepção-atitude ou testes de múltipla escolha simples. Alguns autores destacam que testes de múltipla escolha e questões de resposta curta são utilizados para medir o conhecimento e a compreensão de conceitos de Pensamento Computacional (50). Alguns testes, como o Computational Thinking Performance Test7, focam em pensamento lógico, generalização e abstração (50). A Figure 2.4 exemplifica o tipo de testes de avaliação de Pensamento Computacional que podem ser aplicados, com questões que avaliam a capacidade de decomposição, abstração e algoritmização.\n\n\n\n\n\n\n\n\n\n(a) Exemplo de Testes de Avaliação de Pensamento Computacional\n\n\n\n\n\nFigure 2.4: Exemplo de Testes de Avaliação de Pensamento Computacional [Smith2021].\n\n\n\nEm sala de aula, a avaliação de projetos e portfólios se destaca como ferramenta para discernir como os alunos aplicam seus conhecimentos para pensar computacionalmente e projetar artefatos computacionais criativos (46). Ao contrário dos testes e exames, que podem ser facilmente automatizados, a avaliação de projetos e portfólios requer avaliação manual ou o suporte de ferramentas de Inteligência Artificial.\nAs Rubricas de avaliação são ferramentas valiosas para guiar os professores na avaliação de atividades e objetivos de Pensamento Computacional, articulando critérios com descritores de desempenho que demonstram níveis progressivamente mais sofisticados de domínio (39). A Universidade de Delaware (69), por exemplo, desenvolveu uma rubrica para Pensamento Computacional com quatro dimensões: decomposição, algoritmos, dados e abstração que pode servir de exemplo e inspiração. A Table 2.3 apresenta um exemplo de rubrica para avaliação de habilidades de Pensamento Computacional.\n\n\n\nTable 2.3: Exemplo de Rubrica para Avaliação de Habilidades de Pensamento Computacional. Adaptado de (69).\n\n\n\n\n\n\n\n\n\n\n\n\nDimensão\nExcelente  4\nProficiente  3\nEm Desenvolvimento  2\nIniciante  1\n\n\n\n\nDecomposição  Divide um problema em seus subproblemas constituintes\nDivide um problema complexo em subproblemas claramente descritos, bem definidos e distintos, mas relacionados, que são mais fáceis de resolver do que o problema original, mas quando combinados resolvem eficientemente o problema original.\nDivide um problema complexo em subproblemas claramente descritos que são distintos, mas relacionados, porém carecem de eficiência, embora resolvam o problema original.\nDivide um problema complexo em subproblemas que carecem de eficiência, falham em ter descrições suficientes e se sobrepõem, embora resolvam o problema original.\nDivide um problema complexo em subproblemas que são ineficientes, descritos de forma inadequada, se sobrepõem ou são intimamente relacionados, e falham em resolver completamente o problema original.\n\n\nAlgoritmos  Cria uma série de passos ordenados para resolver um problema ou alcançar um objetivo\nCria uma sequência lógica, eficiente e bem descrita de passos ou instruções para resolver um problema ou alcançar um objetivo.\nCria uma sequência lógica de passos que são bem descritos (por exemplo, não ambíguos, precisos) e resolvem um problema ou alcançam um objetivo, mas os passos são ineficientes, por exemplo, não em uma sequência ótima, sobrepostos, duplicados ou desnecessários.\nCria uma sequência lógica de passos que resolvem um problema ou alcançam um objetivo, mas os passos são mal descritos (por exemplo, ambíguos, vagos).\nCria uma sequência de passos que não resolvem um problema ou alcançam um objetivo. Os passos carecem de eficiência, descrições suficientes e não são descritos ou documentados.\n\n\nDados  Avalia um conjunto de dados para garantir que facilite a descoberta de padrões e relações\nAvalia um conjunto de dados para garantir que seja suficientemente abrangente, eficientemente organizado, significativamente rotulado e completamente descrito para que possa ser analisado para descobrir padrões e relações significativos.\nAvalia um conjunto de dados para garantir que seja suficientemente abrangente, significativamente rotulado e completamente descrito, mas falha em garantir que seja eficientemente organizado.\nAvalia um conjunto de dados para garantir que seja suficientemente abrangente e significativamente rotulado, mas falha em garantir que seja completamente descrito e eficientemente organizado.\nAvalia um conjunto de dados, mas falha em garantir que seja suficientemente abrangente, eficientemente organizado, significativamente rotulado e completamente descrito, de modo que padrões e relações não sejam obscurecidos.\n\n\nAbstração  Reduz a complexidade para criar uma representação geral de um processo ou grupo de objetos, de modo que seja não apenas apropriada para o propósito ou objetivo imediato, mas também possa ser usada em diferentes contextos\nCria uma representação precisa, mas simplificada, de um processo ou grupo de objetos para resolver o problema ou atingir o objetivo. Seleciona características essenciais filtrando informações desnecessárias. Pode ser usada para resolver outros problemas ou objetivos.\nCria uma representação precisa, mas simplificada, de um processo ou grupo de objetos para resolver o problema ou atingir o objetivo. Seleciona características essenciais filtrando informações desnecessárias. Não pode ser usada para resolver outros problemas ou objetivos.\nCria uma representação precisa, mas simplificada, de um processo ou grupo de objetos para resolver o problema ou atingir o objetivo. Falha em selecionar todas as características essenciais filtrando informações desnecessárias. Não pode ser usada para resolver outros problemas ou objetivos.\nCria uma representação de um processo ou grupo de objetos que não é precisa, não é suficientemente simplificada, ou falha em resolver o problema ou atingir o objetivo.\n\n\n\n\n\n\nA rubrica proposta pela Universidade do Dellaware (69) demonstra clareza e foco. As quatro dimensões avaliadas, Decomposição, Algoritmos, Dados e Abstraçã, são os pilares essenciais e bem definidos do Pensamento Computacional. Dentro de cada dimensão, os critérios para cada nível são descritos com especificidade, utilizando exemplos concretos como “subproblemas claramente descritos” ou “sequência lógica”, o que os torna observáveis. Além disso, a linguagem é consistente em toda a tabela; termos-chave como “eficiente”, “claramente descrito”, “suficientemente abrangente”, “preciso” e “simplificado” são aplicados de maneira uniforme, facilitando a comparação entre os níveis e dimensões.\nOutra força significativa é a progressão lógica e hierárquica entre os níveis, de “Excelente” (4) a “Iniciante” (1). Cada degrau representa uma diferença clara na qualidade ou domínio da habilidade avaliada. Os níveis superiores não apenas cumprem os requisitos básicos, mas adicionam critérios mais sofisticados ou exigentes. Por exemplo, na Decomposição, o nível Excelente acrescenta eficiência e distinção clara aos subproblemas em relação ao Proficiente. Nos Algoritmos, a eficiência é o diferencial do Excelente. Na dimensão de Dados, os níveis inferiores perdem progressivamente critérios como organização e descrição completa. Já na Abstração, a capacidade de reutilização da representação em outros contextos é exclusiva do nível Excelente, marcando um salto qualitativo.\nFinalmente, a rubrica se destaca pela ênfase em critérios mensuráveis e observáveis, focando nos resultados tangíveis do trabalho do aluno – como os subproblemas foram divididos, como os passos do algoritmo foram descritos, como os dados foram organizados ou como a representação abstrata foi construída –, evitando termos excessivamente subjetivos. Essa objetividade, aliada à sua abordagem multidimensional, que avalia habilidades distintas porém inter-relacionadas, fornece um retrato mais completo do aluno do que uma nota única. Isso se traduz em uma utilidade pedagógica prática: ela serve como um guia claro de ensino, estabelecendo metas de aprendizagem; permite ao professor dar feedback específico e direcionado por dimensão; e promove maior consistência e equidade na avaliação, reduzindo a subjetividade.\nA aplicação eficaz da rúbrica da Universidade Delaware (69) exige atenção a certas considerações para garantir uma avaliação precisa. Primeiramente, a subjetividade residual em termos como “eficiente” ou “suficientemente abrangente” requer que o avaliador mantenha consistência, sendo o uso de “trabalhos âncora” uma prática recomendada para calibrar a avaliação. Essa necessidade de julgamento é particularmente notável ao diferenciar os níveis “Proficiente” (3) e “Excelente” (4), que dependem de conceitos avançados como eficiência e reusabilidade, exigindo que a tarefa proposta seja complexa o suficiente para permitir que o aluno demonstre tais habilidades. O avaliador deve estar ciente da forte interdependência prática entre as dimensões, por exemplo, uma decomposição fraca quase sempre levará a um algoritmo ineficiente, compreendendo que uma falha em uma área impacta diretamente o desempenho em outra, mesmo que sejam avaliadas separadamente. Esta rúbrica (69) serve apenas como referência. Ela requer adaptações para o uso com o Raciocínio Algorítmico.\nEm um contexto de domínio do Pensamento Computacional e do Raciocínio Algorítmico, a autoavaliação surge como uma estratégia interessante. Existem escalas psicométricas e questionários de autoavaliação são empregados para medir a percepção dos alunos sobre suas próprias habilidades de Pensamento Computacional e sua autoeficácia. Algumas estão academicamente validadas, como o Computational Thinking Self-Efficacy Survey8 (71)), que medem a percepção do estudante sobre sua capacidade de pensar computacionalmente. Essas ferramentas são úteis para entender como os alunos se veem em relação ao Pensamento Computacional e podem ajudar a identificar áreas de melhoria que poderão ser usadas no ensino de Raciocínio Algorítmico.\nAlgumas destas estratégias de avaliação podem ser realizadas por meio de ferramentas online como:\n\nUniCTCheck (Ainda em Desenvolvimento): um método inovador para avaliar habilidades de Pensamento Computacional em alunos universitários de Ciência da Computação. O CTScore é um aplicativo web interativo que mede sete componentes de Pensamento Computacional, reconhecimento de padrões, pensamento criativo, pensamento algorítmico, resolução de problemas, pensamento crítico, decomposição e abstração, por meio de 12 questões. O CTProg é uma escala psicométrica que mede a compreensão conceitual de cinco fundamentos de programação, direções básicas e sequências, condicionais, laços de repetição, funções, estruturas de dados (37).\nBebras Questions: utilizadas como ferramenta de teste para analisar melhorias nas capacidades de Pensamento Computacional para crianças e adolescentes (72).\nDr. Scratch, LOGO, C, C++, AgentCubes: linguagens, ferramentas de depuração, e teste mencionadas como ferramentas de avaliação que podem ser utilizadas para aprimorar o Pensamento Computacional, com foco principal no treinamento de habilidades de programação (55).\n\nApesar do crescimento na pesquisa sobre avaliação de Pensamento Computacional, como ainda existe uma falta de consenso na descrição ou nas partes constituintes do Pensamento Computacional, que dificulta a padronização e validação de instrumentos de avaliação (37), muitos estudos apontam para a necessidade de mais pesquisas para desenvolver e validar uma conceituação teórica robusta do Pensamento Computacional e, consequentemente, ferramentas de avaliação mais eficazes (71).\nPara o avanço da educação, parece ser importante que a comunidade acadêmica continue a colaborar na definição e operacionalização do Pensamento Computacional, o que, por sua vez, permitirá o desenvolvimento de instrumentos de avaliação mais rigorosos e comparáveis. Isso parece ser indispensável para medir o impacto das intervenções pedagógicas e garantir a qualidade da educação em Pensamento Computacional. Além disso, para a definição de uma disciplina de Raciocínio Algorítmico torna-se pertinente a análise deste tema em disciplinas de graduação ao redor do planeta.\n\n\n\n\n[1] CAMBRIDGE UNIVERSITY. Cambridge mathematics., 2025. \n\n\n[2] AI INDEX STEERING COMMITTEE. 2025 AI index report. Stanford, CA: Stanford Institute for Human-Centered Artificial Intelligence, 2025. Disponível em: &lt;https://hai.stanford.edu/ai-index/2025-ai-index-report&gt;. Acesso em: 10 jul. 2025.\n\n\n[3] CHUI, M. et al. The state of AI in 2022—and a half decade in review. [s.l.] McKinsey & Company, 2022. Disponível em: &lt;https://www.mckinsey.com/~/media/mckinsey/business%20functions/quantumblack/our%20insights/the%20state%20of%20ai%20in%202022%20and%20a%20half%20decade%20in%20review/the-state-of-ai-in-2022-and-a-half-decade-in-review.pdf&gt;. Acesso em: 10 jul. 2025.\n\n\n[4] LEINONEN, J.; HELLAS, A.; IHANTOLA, P. How can “vibe-coding” transform programming education? Communications of the ACM, May 2024. Disponível em: &lt;https://cacm.acm.org/blogcacm/how-can-vibe-coding-transform-programming-education/&gt;\n\n\n[5] BRASIL. Síntese de área: Ciência da computação (bacharelado/licenciatura). Brasília, DF: Ministério da Educação, Instituto Nacional de Estudos e Pesquisas Educacionais Anísio Teixeira (Inep), Diretoria de Avaliação da Educação Superior (Daes), 2021. Disponível em: &lt;https://download.inep.gov.br/educacao_superior/enade/relatorio_sintese/2021/Enade_2021_Relatorios_Sintese_Area_Ciencia_Computacao.pdf&gt;. Acesso em: 10 jul. 2025.\n\n\n[6] BRASIL. Relatório síntese de área: Engenharia de computação. Brasília, DF: Ministério da Educação, Instituto Nacional de Estudos e Pesquisas Educacionais Anísio Teixeira (Inep), Diretoria de Avaliação da Educação Superior (Daes), 2023. Disponível em: &lt;https://download.inep.gov.br/educacao_superior/enade/relatorio_sintese/2023/engenharia_de_computacao.pdf&gt;. Acesso em: 10 jul. 2025.\n\n\n[7] KRAMER, J. Is abstraction the key to computing? Communications of the ACM, v. 50, n. 4, p. 36–42, 2007. \n\n\n[8] WINSLOW, L. E. Programming pedagogy – a psychological overview. ACM SIGCSE Bulletin, v. 28, n. 3, p. 17–22, 1996. \n\n\n[9] MIROLO, C. et al. Abstraction in computer science education: An overview. Informatics in Education, v. 20, n. 4, p. 615–639, 2021. \n\n\n[10] HIEBERT, J.; LEFEVRE, P. Conceptual and procedural knowledge in mathematics: An introductory analysis. In: HIEBERT, J. (Ed.). Conceptual and procedural knowledge: The case of mathematics. Hillsdale, NJ: Lawrence Erlbaum Associates, 1986. p. 1–27. \n\n\n[11] WING, J. M. Computational thinking. Communications of the ACM, v. 49, n. 3, p. 33–35, Mar. 2006. \n\n\n[12] LEHMANN, T. H. Using algorithmic thinking to design algorithms: The case of critical path analysis. The Journal of Mathematical Behavior, v. 71, p. 101079, 2023. \n\n\n[13] LITHNER, J. A research framework for algorithmic and creative reasoning. Educational Studies in Mathematics, v. 67, n. 3, p. 255–276, 2008. \n\n\n[14] HARISMAN, Y. et al. Exploring students’ mathematical reasoning behavior. Education Sciences, v. 13, 2023. \n\n\n[15] HURRELL, D. P. Conceptual knowledge OR procedural knowledge OR conceptual knowledge AND procedural knowledge: Why the conjunction is important for teachers. Australian Journal of Teacher Education, v. 46, n. 2, p. art. 4, 2021. \n\n\n[16] NATIONAL COUNCIL OF TEACHERS OF MATHEMATICS – NCTM. Principles and standards for school mathematics. Reston, VA: NCTM, 2000. \n\n\n[17] KALDEWAIJ, A. Programming: The derivation of algorithms. [s.l.] Prentice Hall, 1990. \n\n\n[18] GIBBONS, J. Algorithm design with haskell. University of Oxford, 2020. Acesso em: 10 jul. 2025\n\n\n[19] BIRD, R.; DE MOOR, O. Algebra of programming. [s.l.] Prentice Hall, 1997. \n\n\n[20] GÜNDOĞDU, F. et al. Exploring mathematical reasoning skills. ScienceDirect, 2023. \n\n\n[21] KOSMYNA, N. et al. Your brain on ChatGPT: Accumulation of cognitive debt when using an AI assistant for essay writing task., 2025. Disponível em: &lt;https://arxiv.org/abs/2506.08872&gt;\n\n\n[22] SILVA QUINTO, W. A. et al. Explorando o impacto da inteligência artificial na formação do pensamento crítico entre acadêmicos de t.i. Na região norte do brasil. Caderno Pedagógico, v. 22, n. 7, 2025. \n\n\n[23] HSU, T.-C.; CHANG, Y.-S.; CHEN, S.-Y. Teaching AI with games: The impact of generative AI drawing on computational thinking skills. Education and Information Technologies, 2025. \n\n\n[24] TSAI, C.-Y.; YANG, Y.-F. The impact of unplugged activities on developing computational thinking skills in elementary school students. Journal of Educational Technology & Society, v. 22, n. 3, p. 77–89, 2019. \n\n\n[25] POLAT, E.; YILMAZ, R. M. Unplugged versus plugged-in: Examining basic programming achievement and computational thinking of 6th-grade students. Education and Information Technologies, v. 27, p. 9145–9179, 2022. \n\n\n[26] BRACKMANN, C. P. et al. Unplugged versus plugged-in: Examining basic programming achievement and computational thinking of 6th-grade students. Journal of Computer Science Education, 2022. \n\n\n[27] GIBBONS, J. Functional algorithm design, part 0. SIGPLAN Blog, 2020. \n\n\n[28] HUANG, R. et al. Computational thinking and the new curriculum standards of information technology for senior high schools in china. In: ABELSON, H.; KONG, S.-C. (Eds.). Computational thinking curricula in k–12: International implementations. Cambridge, Massachusetts; London, England: The MIT Press, 2020. \n\n\n[29] ARA’UJO, A. L. S. DE O.; ANDRADE, W. L. DE; GUERRERO, D. D. S. Um mapeamento sistem’atico sobre a avaliaç ao do pensamento computacional no Brasil. Anais do v congresso brasileiro de inform’atica na educaç ao (CBIE). Anais...2016. \n\n\n[30] LI, Y. et al. Computational thinking is more about thinking than computing. Journal for STEM Education Research, v. 3, n. 1, p. 1–18, 2020. \n\n\n[31] PAPERT, S. Logo: Computadores e educação. São Paulo: Brasiliense, 1985. \n\n\n[32] SAIDIN, N. D. et al. Benefits and challenges of applying computational thinking in education. International Journal of Information and Education Technology, v. 11, n. 5, p. 248–254, 2021. \n\n\n[33] COMPUTER SCIENCE TEACHERS ASSOCIATION. Computational thinking: A definition for k-12., 2011. Disponível em: &lt;https://csteachers.org/teaching-computational-thinking-in-early-elementary/&gt;. Acesso em: 7 jul. 2025\n\n\n[34] TEDRE, M.; DENNING, P. J. The long quest for computational thinking. Proceedings of the 16th koli calling conference on computing education research. Anais...Koli, Finland: Nov. 2016. \n\n\n[35] CURZON, P. et al. Computational thinking. In: FINCHER, S. A.; ROBINS, A. V. (Eds.). The cambridge handbook of computing education research. Cambridge: Cambridge University Press, 2019. p. 513–546. \n\n\n[36] LEHMANN, T. H. How current perspectives on algorithmic thinking can be applied to students’ engagement in algorithmatizing tasks. Mathematics Education Research Journal, v. 36, n. 3, p. 609–643, 2024. \n\n\n[37] HIJÓN-NEIRA, R. et al. Computational thinking measurement of CS university students in the AI era. Preprints.org, May 2024. \n\n\n[38] RIBEIRO, L. et al. Entendendo o pensamento computacional: Além da programação. Revista Brasileira de Informática na Educação, v. 25, n. 3, p. 45–62, 2017. \n\n\n[39] KONG, S. et al. Pensamento computacional na educação: Perspectivas internacionais. São Paulo: Penso, 2020. \n\n\n[40] MEDEIROS, W. M. Pensamento computacional ou programação? Uma análise de práticas pedagógicas com scratch. Dissertação (Mestrado em Educação)—Uberlândia: UFU, 2024.\n\n\n[41] SCRATCH FOUNDATION. Scratch., [s.d.][s.d.]. Disponível em: &lt;https://scratch.mit.edu/&gt;. Acesso em: 7 jul. 2025\n\n\n[42] SBC (SOCIEDADE BRASILEIRA DE COMPUTAÇÃO). Referenciais de formação em computação: Educação básica. Porto AlegreSBC, 2017. \n\n\n[43] HORA, N. DA. O ensino do pensamento computacional no brasil na era digital. Futura, 9 Feb. 2022. Disponível em: &lt;https://futura.frm.org.br/conteudo/professores/artigo/o-ensino-do-pensamento-computacional-no-brasil-na-era-digital&gt;. Acesso em: 9 jul. 2025\n\n\n[44] FELIPUSSI, A. L.; PADUA, C. C. S. Relato de aulas com robô programável e pensamento computacional. Anais do 12º congresso brasileiro de informática na educação. Anais...Recife: SBC, 2023. \n\n\n[45] FUTURA, C. P. O ensino do pensamento computacional no brasil na era digital. São Paulo: Fundação Roberto Marinho, 2023. \n\n\n[46] KONG, S.-C. Learning composite and prime numbers through developing an app: An example of computational thinking development through primary mathematics learning. In: KONG, S.-C.; ABELSON, H. (Eds.). Computational thinking education. Singapore: Springer, 2019. p. 155–177. \n\n\n[47] KIRWAN, C.; COSTELLO, E.; DONLON, E. ADAPTTER: Developing a framework for teaching computational thinking in second-level schools by design research. TechTrends, v. 66, n. 4, p. 495–509, 2022. \n\n\n[48] HOARE, C. A. R. An axiomatic basis for computer programming. Communications of the ACM, v. 12, n. 10, p. 576–580, 1969. \n\n\n[49] LEVESON, N. G. Engineering a safer world: Systems thinking applied to safety. Cambridge, MA: MIT Press, 2012. \n\n\n[50] CURZON, P.; MCOWAN, P.; BLACKWELL, A. Unplugged approaches to the teaching of computing to adults. Journal of Computing Sciences in Colleges, v. 29, n. 4, p. 90–97, 2014. \n\n\n[51] WEINTROP, D.; WILENSKY, U. Using unplugged activities in adult programming education. Proceedings of the 46th ACM technical symposium on computer science education (SIGCSE ’15). Anais...New York, NY, USA: ACM, 2015. \n\n\n[52] BERGMANN, J.; SAMS, A. Flip your classroom: Reach every student in every class every day. Eugene: ISTE, 2012. \n\n\n[53] ETH ZURICH. Flipped Classroom. https://ethz.ch/en/the-eth-zurich/education/educational-development/planning-teaching/flipped-classroom.html, 2025. Acesso em: 15 jul. 2025\n\n\n[54] LEIFER, L. A. Project based learning in design education. Proceedings of the 1970 conference on design methods. Anais...1970. \n\n\n[55] KIM, Y. Computational thinking. In: Educational technology: An online handbook for pre-k-12. [s.l.] EdTech Books, 2021. \n\n\n[56] BELL, T. et al. Computer science unplugged: School students doing real computing without computers. Article, 2009. \n\n\n[57] NEW YORK HALL OF SCIENCE. Computational thinking school strategy guide., [s.d.][s.d.]. Disponível em: &lt;https://nysci.org/pdf/NYSCI-Computational-Thinking-School-Strategy-Guide-04-09-2024.pdf&gt;. Acesso em: 6 jul. 2025\n\n\n[58] WONG, M. M. Y. et al. Self-development through service-oriented stress-adaption-growth (SOSAG) process in the engagement of computational thinking co-teaching education. In: KONG, S.-C.; ABELSON, H. (Eds.). Computational thinking education. Singapore: Springer Nature Singapore Pte Ltd., 2019. \n\n\n[59] PYTHON SOFTWARE FOUNDATION. The Python Language Reference. Disponível em: &lt;https://docs.python.org/3/reference/index.html&gt;. Acesso em: 13 jul. 2025. \n\n\n[60] PENN STATE UNIVERSITY. Computer science (CMPSC) - university bulletin - penn state., [s.d.]a[s.d.]a. Disponível em: &lt;https://bulletins.psu.edu/university-course-descriptions/undergraduate/cmpsc/&gt;. Acesso em: 6 jul. 2025\n\n\n[61] LEROY, X. et al. The OCaml system: Documentation and user’s manual. [s.l.] INRIA (Institut National de Recherche en Informatique et en Automatique), 2025. \n\n\n[62] GOSLING, J. et al. The java® language specification, java SE 22 edition. Redwood City, California: Oracle America, Inc., 2024. \n\n\n[63] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information technology – Programming languages – C. Geneva, Switzerland: International Organization for Standardization (ISO), 2018. Disponível em: &lt;https://www.iso.org/standard/74528.html&gt;.\n\n\n[64] 21, I. J. 1/SC 22/WG. ISO/IEC 14882:2024 - programming languages — c++. [s.l.] International Organization for Standardization, 2024. Disponível em: &lt;https://www.iso.org/standard/82312.html&gt;.\n\n\n[65] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. ISO/IEC 13211-1:1995 - information technology – programming languages – prolog – part 1: General core. [s.l.] ISO/IEC, 1995. \n\n\n[66] STANFORD UNIVERSITY. CS106A syllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1258/syllabus&gt;\n\n\n[67] ŽIVKOVIĆ, M. XLogo4Schools. SourceForge, 2014. Disponível em: &lt;http://sourceforge.net/projects/xlogo4schools&gt;\n\n\n[68] WATTENHOFER, R. Computational thinking. [s.l.] ETH Zürich, 2020. \n\n\n[69] AMENDUM, M. L. B. et al. Computational thinking rubric for problem solving. Newark, DE: The College School, University of Delaware, 2018. Disponível em: &lt;https://cpb-us-w2.wpmucdn.com/sites.udel.edu/dist/4/8672/files/2018/12/Computational-Thinking-Rubric-2ktkkgv.pdf&gt;.\n\n\n[70] ROMÁN-GONZÁLEZ, M.; MORENO-LEÓN, J.; ROBLES, G. Combining assessment tools for a comprehensive evaluation of computational thinking interventions. In: KONG, S.-C.; ABELSON, H. (Eds.). Computational thinking education. [s.l.] Springer, 2019. p. 85–100. \n\n\n[71] SMITH, J. A. C. B.; GROVER, S.; SMITH, A. L. Measuring computational thinking and computer science outcomes: A resource for CS for all researchers. [s.l.] U.S. Department of Education, Mar. 2021. Disponível em: &lt;https://www.ed.gov/sites/ed/files/2021/03/CSCTOutcomes_508.pdf&gt;.\n\n\n[72] RASPBERRY PI FOUNDATION. The UK bebras challenge. https://www.bebras.uk/, 2025.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "2  Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD",
    "section": "",
    "text": "Algoritmização é um neologismo para traduzir o termo “Algorithmization” do inglês. A ideia é que seja um termo que remete à criação de algoritmos, ou seja, a construção de soluções sistemáticas e eficientes para problemas computacionais. É horrível, eu sei.↩︎\nem tradução livre Raciocínio Algorítmico Familiar, ou Raciocínio Algorítmico Conhecido.↩︎\nem tradução livre “Seu Cérebro no ChatGPT: Acúmulo de Dívida Cognitiva ao Usar um Assistente de Inteligência Artificial para Tarefa de Escrita de Ensaio”.↩︎\nem tradução livre “Ensinando Inteligência Artificial com jogos: o impacto da Inteligência Artificial generativa no desenvolvimento de habilidades de pensamento computacional”.↩︎\nem tradução livre “Projeto de Algoritmos com Haskell”.↩︎\nem tradução livre Desplugado versus Plugado: examinando o desempenho em programação básica e oPensamento Computacionalde alunos do 6º ano↩︎\nem tradução livre: Teste de Desempenho de Pensamento Computacional.↩︎\nem tradução livre: Questionário de Autoeficácia de Pensamento Computacional.↩︎",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span>"
    ]
  },
  {
    "objectID": "inte.html",
    "href": "inte.html",
    "title": "3  Analisando Currículos Internacionais",
    "section": "",
    "text": "3.1 Detalhamento das Universidades nos Estados Unidos\nA Carnegie Mellon University (CMU) é uma instituição pioneira na promoção do Pensamento Computacional, com Jeannette Wing como figura central nesta iniciativa. A universidade possui um centro específico para Pensamento Computacional dedicado (14). A abordagem da CMU envolve o Project Olympus de inovação, no centro do qual estão os desafios PRoblem-Oriented Business Explorations, PROBES, uma sigla em inglês para exploração de problemas orientados a negócio. Alunos que resolvem estes problemas aplicam conceitos computacionais inovadores a problemas práticos para aprenderem na prática o valor do Pensamento Computacional (15). A disciplina Princípios da Computação (10 Créditos), introduzida em 2005, foca no estudo do processo de computação, não necessariamente na operação de um computador (16). A disciplina Estrutura de Dados e Algoritmos (12 Créditos) espera que os alunos aprendam a decompor problemas. Além disso, busca desenvolver habilidades para acompanhar o progresso da solução, avaliar a correção do código e corrigir falhas por meio de depuração automatizada (17).\nEm disciplinas diretamente relacionadas com Ciência e Engenharia da Computação, a disciplina Codificação e Pensamento Computacional com VEX V5 (18), na forma de um curso de extensão, utiliza atividades de programação estruturadas em contextos de projetos do mundo real, ensinando explicitamente a decomposição para simplificar a codificação complexa (19). A ênfase da CMU na aplicação do Pensamento Computacional para resolver problemas do mundo real transcende a mera compreensão. Pensamento Computacional significa pensar algoritmicamente e com a habilidade de aplicar conceitos matemáticos, tais como indução, para desenvolver soluções mais eficientes, justas e seguras (14). Essa abordagem cria uma relação causal: problemas autênticos fornecem a motivação e o contexto para que os alunos se engajem profundamente, desenvolvam e apliquem as habilidades DAAD.\nO MIT, Massachusetts Institute of Technology, reconhece o Pensamento Computacional como um tipo distinto de raciocínio rigoroso de importante valor intelectual. Este raciocínio requer e desenvolve modos importantes de comunicação e a necessidade de compreender o impacto transformador da computação em outras disciplinas (20). O MIT recomenda um requisito mínimo de computação para todos os estudantes de graduação, enfatizando que o Pensamento Computacional é mais amplo do que a proficiência em programação (22). As disciplinas Introdução ao Pensamento Computacional em Python (6.100A, 12 Créditos) e Introdução ao Pensamento Computacional e Ciência de Dados (6.100B, 12 Créditos) utilizam Python como linguagem de programação e visam dar aos alunos a confiança para escrever pequenos programas úteis, independentemente de sua área principal de estudos (22).\nA Penn State integra o Pensamento Computacional em seu currículo do curso de Ciência da Computação (23). As disciplinas enfatizam a conceituação e implementação de soluções computacionais, o raciocínio sobre problemas em múltiplos níveis de abstração e a análise de código quanto ao comportamento, eficiência e correção (23). Também abordam habilidades de desenvolvimento e manutenção de programas, como depuração e teste. Já na University of Wisconsin-Madison, a disciplina Introdução à Programação para Ciências Computacionais (CMPSC 204, 3 créditos) introduz a abstração e decomposição de problemas, discute métodos de uso de computadores para resolver problemas, incluindo técnicas elementares de programação, linguagens de manipulação simbólica e pacotes de software (23).\nA Harvard University adota uma estratégia pedagógica distintiva na sua disciplina Introdução à Ciência da Computação, CS50, caracterizada pela progressão no ensino do Pensamento Computacional. O curso, com duração de 11 semanas e exigindo dedicação semanal de 10 a 20 horas, tem aproximadamente 4 créditos. A disciplina inicia com a linguagem C (24) antes de avançar para Python, demonstrando uma filosofia que prioriza a compreensão fundamental dos mecanismos computacionais (25,26). Esta abordagem se alinha com os princípios estabelecidos por Jeannette Wing sobre Pensamento Computacional(1), enfatizando que Pensamento Computacional significa pensar algoritmicamente e com a habilidade de aplicar conceitos matemáticos, tais como indução, para desenvolver soluções mais eficientes, justas e seguras (26).\nA estrutura curricular do CS50 revela uma progressão cuidadosamente planejada: início com Scratch(27) para conceitos fundamentais, transição para Linguagem C(24) para compreensão de baixo nível, seguida por Python(28) para aplicações de alto nível (26). A introdução explícita de algoritmos na Semana 3, incluindo Notação Assintótica, estabelece uma base sólida para análise de eficiência que complementa o aprendizado prático da programação imperativa (26). Esta metodologia reflete uma compreensão de que o raciocínio algorítmico deve ser construído sobre fundamentos sólidos de como os computadores operam, incluindo gerenciamento de memória e ponteiros, conceitos essenciais para otimização e depuração avançadas (26).\nA Stanford University implementa uma filosofia de aprendizagem por maestria em suas disciplinas CS106A (5 créditos) e CS106B (5 créditos), caracterizada por um sistema extensivo de suporte pedagógico e progressão conceitual estruturada (29,30). O CS106A utiliza Karel the Robot (31) como ferramenta introdutória, permitindo que os alunos desenvolvam intuição sobre decomposição de problemas e controle de fluxo antes de enfrentar a complexidade sintática de linguagens de propósito geral (29,32). Esta abordagem reconhece que a abstração computacional pode ser ensinada de forma mais eficaz quando separada das complexidades de implementação.\nO sistema de suporte de Stanford, incluindo LaIR Hours, horas de ajuda presencial noturna, seções semanais obrigatórias e políticas flexíveis de avaliação, reflete uma compreensão profunda de que o desenvolvimento do Pensamento Computacional requer prática intensiva com retorno contínuo (29,30). A transição do CS106A (Python) para o CS106B, Linguagem C++ (33), demonstra uma progressão estratégica: estabelecimento inicial de confiança em resolução de problemas por meio de Python, seguido pelo aprofundamento em conceitos de baixo nível por meio de C++ (30). A introdução da Notação Big O no CS106B integra-se naturalmente com o aprendizado de estruturas de dados e algoritmos avançados, demonstrando como a análise de complexidade se conecta diretamente com decisões de implementação (30). A Figure 3.1 resume a estrutura do curso CS106A e CS106B.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Analisando Currículos Internacionais</span>"
    ]
  },
  {
    "objectID": "inte.html#detalhamento-das-universidades-nos-estados-unidos",
    "href": "inte.html#detalhamento-das-universidades-nos-estados-unidos",
    "title": "3  Analisando Currículos Internacionais",
    "section": "",
    "text": "Figure 3.1: Estrutura do curso CS106A e CS106B da Stanford University.\n\n\n\nSíntese da estrutura do curso CS106A e CS106B da Stanford University. A figura ilustra a progressão do ensino de Pensamento Computacional desde conceitos básicos até estruturas de dados avançadas, destacando a transição de C para Python e deste para C++ e a introdução da Notação Big O.\n\n\n3.1.1 Síntese das Abordagens Pedagógicas Americanas\nA análise das metodologias adotadas pelas principais universidades americanas revela um espectro diversificado de estratégias para o desenvolvimento do Pensamento Computacional, cada uma refletindo filosofias educacionais distintas mas complementares. Harvard prioriza a exposição inicial aos fundamentos computacionais por meio da progressão “do baixo para o alto”, argumentando que a compreensão profunda dos mecanismos de baixo nível facilita a maestria posterior de abstrações de alto nível (26). Stanford implementa uma abordagem de “aprendizagem por maestria”, enfatizando a construção gradual de confiança por meio de ferramentas acessíveis como Karel the Robot antes de introduzir complexidades técnicas (29).\nA Carnegie Mellon University distingue-se pela integração de problemas autênticos do mundo real por meio do Project Olympus e dos desafios PROBES, demonstrando como o Pensamento Computacional pode ser aplicado em contextos práticos de negócio (14). O MIT enfatiza uma abordagem estruturada que reconhece o Pensamento Computacional como um tipo distinto de raciocínio rigoroso, implementando disciplinas específicas como Introdução ao Pensamento Computacional em Python (6.100A, 12 Créditos) que visam desenvolver confiança na programação independentemente da área de estudos principal. As demais instituições, incluindo Penn State, University of Wisconsin-Madison e University of Texas at Austin, convergem na ênfase da decomposição de problemas, análise de eficiência e desenvolvimento de habilidades de depuração como componentes fundamentais do currículo introdutório.\nEsta diversidade metodológica demonstra que o Pensamento Computacional transcende a mera proficiência em programação, exigindo desenvolvimento de habilidades de decomposição, abstração e reconhecimento de padrões que são fundamentais para a resolução eficaz de problemas computacionais complexos. As variações nas estratégias pedagógicas refletem diferentes caminhos para alcançar o mesmo objetivo: capacitar os alunos a pensar algoritmicamente e aplicar conceitos matemáticos para desenvolver soluções eficientes, justas e seguras, conforme preconizado por Jeannette Wing e implementado de forma pioneira na Carnegie Mellon University (14).",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Analisando Currículos Internacionais</span>"
    ]
  },
  {
    "objectID": "inte.html#detalhamento-das-universidades-no-reino-unido",
    "href": "inte.html#detalhamento-das-universidades-no-reino-unido",
    "title": "3  Analisando Currículos Internacionais",
    "section": "3.2 Detalhamento das Universidades no Reino Unido",
    "text": "3.2 Detalhamento das Universidades no Reino Unido\nA Cambridge University estabelece uma abordagem distintiva para o desenvolvimento do Raciocínio Algorítmico por meio do instituto Cambridge Mathematics, uma iniciativa colaborativa criada pela união da editora universitária com as faculdades de educação e matemática (6). O instituto produz cursos, seminários e material didático especializado para a formação de competências computacionais em alunos de diferentes cursos de graduação, demonstrando uma visão integrada do Pensamento Computacional que transcende as fronteiras tradicionais da ciência da computação corroborando as ideias de Wing (2006) (1) e Lehmann (2033) (5). Nos documentos gerados pelo Cambridge Mathematics ((34) e (35)) é possível observar uma relação profunda e estruturada entre o Pensamento Computacional e o pensamento funcional matemático, estabelecendo uma base teórica sólida (6).\nO material desenvolvido pelo instituto, (34) e (35), é sistematicamente integrado no currículo universitário, com ênfase particular em abstração, lógica, algoritmos e representação de dados (6), estabelecendo a base para o desenvolvimento do raciocínio computacional em múltiplas disciplinas.\nO currículo de disciplinas introdutórias relacionadas ao desenvolvimento do Raciocínio Algorítimico em Cambridge revela uma progressão estruturada e rigorosa que combina fundamentos teóricos com aplicação prática. A disciplina Algoritmos 1 (14 créditos ECTS), parte do curso geral de Ciência da Computação (36), abrange tópicos fundamentais como ordenação, análise de complexidade, paradigmas de design incluindo divisão e conquista, programação dinâmica e algoritmos gulosos, estruturas de dados, e análise formal da eficiência dos algoritmos (37). Esta disciplina estabelece a base algorítmica essencial para o desenvolvimento do raciocínio computacional, enfatizando não apenas a implementação de algoritmos, mas também a compreensão profunda de sua eficiência e aplicabilidade.\nEsta base algorítmica é complementada pelo Computational Thinking Challenge, um projeto de pesquisa e avaliação digital desenvolvido pela faculdade de educação, especificamente focado na avaliação de competências de Pensamento Computacional voltado para estudantes e educadores (38). Esta iniciativa serve como evidência do compromisso de Cambridge não apenas com o ensino, mas também com a pesquisa e avaliação sistemática das metodologias de desenvolvimento do Pensamento Computacional.\nFinalmente, em Cambridge, a disciplina Algoritmos 2 (14 créditos ECTS)complementa a formação em Raciocínio Algorítmico, abordando conteúdos avançados. Esta disciplina inclui grafos e algoritmos de busca de caminho, grafos e subgrafos, com foco em fluxo máximo, emparelhamentos bipartidos, árvores geradoras mínimas de Kruskal e Prim, e ordenação topológica, e estruturas de dados avançadas (como heap binomial, análise amortizada, heaps de Fibonacci e conjuntos disjuntos)(39).\nAnalisando apenas as duas dicisplinas diretamente relacionadas com Ciência da Computação a uma das iniciativas de fomento ao desenvolvimento de Pensamento Computacional, é possível observar que a Cambridge University adota uma abordagem estruturada e progressiva, enfatizando a importância de fundamentos teóricos sólidos combinados com aplicação prática. A Figure 3.2 apresenta a evolução e relação entre os tópicos de Algoritmos 1 e 2, destacando a progressão do ensino de Pensamento Computacional desde conceitos básicos até estruturas de dados avançada\n\n\n\n\n\n\n\nFigure 3.2: Relação entre as disciplinas relacionadas a Raciocínio Algorítmico na Universidade de Cambridge\n\n\n\nComparação das estruturas curriculares das disciplinas de Algoritmos 1 e 2 da Cambridge University. A figura ilustra a progressão do ensino de Raciocínio Algorítmico desde conceitos básicos até estruturas de dados avançadas, destacando a relação entre os tópicos abordados nas duas disciplinas.\n\nA Oxford University implementa uma filosofia pedagógica que estimula o Pensamento Computacional desde os estágios iniciais por meio do design de programas de computador, oferecendo cursos integrados de Ciência da Computação(40), Matemática e Ciência da Computação(41), e Ciência da Computação e Filosofia(40). Esta diversidade de programas interdisciplinares parece refletir uma compreensão de que o Pensamento Computacional e o Raciocínio Algorítmico podem ser aplicados e desenvolvidos em múltiplos contextos acadêmicos, oferecendo perspectivas únicas e complementares.\nOxford parece estender seu compromisso com o Pensamento Computacional por meio de iniciativas específicas de divulgação e engajamento que demonstram uma visão ampla da responsabilidade educacional da universidade. A universidade participa ativamente do UK Bebras Challenge, um desafio nacional de Pensamento Computacional que visa introduzir esses conceitos aos alunos nos níveis de ensino anterior à graduação (42). A competição, que envolve mais de 100.000 crianças e adolescentes anualmente, promove o desenvolvimento de habilidades de Pensamento Computacional por meio de problemas desafiadores e interativos, refletindo uma abordagem prática e aplicada ao ensino desses conceitos fundamentais. Além disso, a universidade também participa do “Oxford University Computing Challenge”, um evento de participação por convite que encoraja o desenvolvimento de habilidades de Pensamento Computacional por meio da aplicação de algoritmos e programas para resolver problemas complexos (43).\nComplementarmente, o Oxford University Computing Challenge (OUCC), uma competição por convite que encoraja o desenvolvimento de habilidades de Pensamento Computacional por meio da aplicação de algoritmos e programas para resolver problemas complexos (44). Em 2023, mais de 20.000 participantes do UK Bebras foram convidados a participar do OUCC(45). Estas iniciativas demonstram o reconhecimento de que o Pensamento Computacional deve ser cultivado de forma ampla e sistemática, estendendo-se além dos limites tradicionais do ensino superior para impactar toda a sociedade.\nDiferenciando-se da Universidade de Cambridge e das universidades dos EUA, a Oxford University não permite acesso prático às ementas dos seus cursos, impedindo uma análise de conteúdo e duração para aqueles que não estão, de alguma forma, associados à instituição.\nO Imperial College London adota uma abordagem fundamentada em princípios de engenharia para o desenvolvimento do Pensamento Computacional, enfatizando princípios fundamentais, pensamento lógico e considerações de engenharia no design de sistemas (46). Esta perspectiva de engenharia distingue a abordagem do Imperial College, focando na aplicação prática do Pensamento Computacional em contextos de design e implementação de sistemas reais, preparando os alunos para os desafios práticos que enfrentarão em suas carreiras profissionais. Para corroborar esta integração entre teoria e prática, o Imperial College London promove a iniciativa I-X (47) para fomentar aprendizado e aplicação de tecnologia computacional em contextos práticos e reais.\nO programa de graduação em computação integra teoria e prática por meio de uma combinação estruturada de aulas de laboratório, resolução de problemas e trabalhos de projeto e design, criando um ambiente de aprendizagem que espelha as demandas profissionais reais (46). O objetivo desta estrutura parece ser a formação progressiva dos conceitos de Raciocínio Algorítmico e Pensamento Computacional por meio da aplicação prática em problemas autênticos de engenharia, nos quais os conceitos emergem naturalmente das necessidades práticas, ao invés de serem ensinados como abstrações isoladas.\nOs módulos centrais revelam uma progressão cuidadosamente estruturada que constrói sistematicamente as competências fundamentais: no primeiro ano Matemática Discreta, Lógica e Raciocínio (7,5 ECTS) e Grafos e Algoritmos (7,5 ECTS); no segundo ano Projeto e Análise de Algoritmos (7,5 ECTS), além de disciplinas opcionais como Raciocínio Simbólico (6 ECTS) e Técnicas Computacionais (6 ECTS) (46). Esta estrutura curricular parece induzir a criação do Raciocínio Algorítmico. E isso é tudo que se pode afirmar sobre o Imperial College London sobre Pensamento Computacional e Raciocínio Algorítmico já que não foi possível encontrar estes termos em nenhuma ementa de disciplina online.\nA Cardiff University distingue-se por sua abordagem explícita e dedicada ao Pensamento Computacional, oferecendo uma disciplina específica Pensamento Computacional (10 ECTS) no primeiro ano de seu curso de Ciência da Computação (48). Esta disciplina dedicada representa uma abordagem direta e sem ambiguidades para o desenvolvimento dessas competências fundamentais, garantindo que todos os alunos recebam uma base sólida e explícita em Pensamento Computacional desde o início de seus estudos. O ensino de Raciocínio Algorítmico é complementado por Resolução de Problemas com Python (5 ECTS) (49). A estrutura curricular de Cardiff indica um foco precoce e dedicado ao Pensamento Computacional, distribuído estrategicamente por meio de múltiplas disciplinas para garantir reforço e aplicação consistente dos conceitos fundamentais.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Analisando Currículos Internacionais</span>"
    ]
  },
  {
    "objectID": "inte.html#detalhamento-das-universidades-na-europa-continental",
    "href": "inte.html#detalhamento-das-universidades-na-europa-continental",
    "title": "3  Analisando Currículos Internacionais",
    "section": "3.3 Detalhamento das Universidades na Europa Continental",
    "text": "3.3 Detalhamento das Universidades na Europa Continental\nA Comissão Europeia, por meio do seu Plano de Ação para a Educação Digital 2021-2027, reforça a importância da educação em computação como uma prioridade para aprimorar as habilidades e competências digitais (50). Desde 2014, muitos países europeus têm revisado seus currículos de educação obrigatória para introduzir conceitos básicos de Ciência da Computação, preparando o terreno para o desenvolvimento de habilidades de Pensamento Computacional (50).\nA ETH Zurich (Suíça) enfatiza que o Pensamento Computacional vai além da programação e envolve as capacidades de abstração (51). Para o ensino exclusivo de Pensamento Computacional, a universidade adota um paradigma de sala de aula invertida, flipped classroom (52), com vídeos e leituras para autoestudo, disponíveis online para seus alunos. O modelo de sala de aula invertida da ETH Zurich (53) indica que a instituição tem consciência de que as disciplinas convencionais não são capazes de dividir o tempo, de forma justa, entre a aquisição do conhecimento, a consolidação supervisionada e a aplicação concreta deste conhecimento (53). Além disso, existem declarações indicando que o Pensamento Computacional é mais do que programar um computador, significa pensar em abstrações (51).\nTalvez o comprometimento mais evidente da ETH Zurich com o Pensamento Computacional seja a inclusão de um conjunto de tutoriais de programação para iniciantes com a indicação de qual linguagem de programação será mais relevante por curso, incluindo, Python, C++ e Java para cursos que vão da ciência da computação até ciências farmacêuticas, de biologia até ciência de alimentos (54).\nA École hôtelière de Lausanne (EHL), renomada instituição suíça de ensino superior, integra um módulo específico de “Pensamento Computacional” em seu programa de Bacharelado em Administração Hoteleira (EHL HOSPITALITY BUSINESS SCHOOL, 2024). Esta disciplina, oferecida no segundo semestre, representa 3,5 ECTS e uma carga horária total de 88 horas, sendo 30 horas de contato direto com o professor e 58 horas destinadas ao estudo independente (55). A inclusão de Pensamento Computacional em um programa de administração hoteleira demonstra o reconhecimento crescente de que essas competências transcendem as áreas tradicionais de ciência da computação. A oferta no segundo semestre indica seu papel como disciplina estruturante para o desenvolvimento de habilidades de resolução de problemas. Esta abordagem da EHL alinha-se com as tendências globais de integração explícita do Pensamento Computacional nos currículos de graduação, independentemente da área de formação principal (1).\n\n\n\n\n[1] WING, J. M. Computational thinking. Communications of the ACM, v. 49, n. 3, p. 33–35, Mar. 2006. \n\n\n[2] LI, Y. et al. Computational thinking is more about thinking than computing. Journal for STEM Education Research, v. 3, n. 1, p. 1–18, 2020. \n\n\n[3] CURZON, P. et al. Computational thinking. In: FINCHER, S. A.; ROBINS, A. V. (Eds.). The cambridge handbook of computing education research. Cambridge: Cambridge University Press, 2019. p. 513–546. \n\n\n[4] HURRELL, D. P. Conceptual knowledge OR procedural knowledge OR conceptual knowledge AND procedural knowledge: Why the conjunction is important for teachers. Australian Journal of Teacher Education, v. 46, n. 2, p. art. 4, 2021. \n\n\n[5] LEHMANN, T. H. Using algorithmic thinking to design algorithms: The case of critical path analysis. The Journal of Mathematical Behavior, v. 71, p. 101079, 2023. \n\n\n[6] CAMBRIDGE UNIVERSITY. Cambridge mathematics., 2025. \n\n\n[7] NATIONAL CENTER FOR EDUCATION STATISTICS (NCES). Glossary: Credit hour. Washington, D.C.U.S. Department of Education, 2010. Disponível em: &lt;https://www.naicu.edu/media/l3ckll0r/20101214_credithourbkgrnd12-13-10.pdf&gt;. Acesso em: 7 jul. 2025\n\n\n[8] EUROPEAN COMMISSION. ECTS users’ guide. LuxembourgPublications Office of the European Union, 2015. Disponível em: &lt;https://education.ec.europa.eu/sites/default/files/document-library-docs/ects-users-guide_en.pdf&gt;. Acesso em: 7 jul. 2025\n\n\n[9] XIAMEN UNIVERSITY. Overseas education college. credits. XiamenOEC, [s.d.][s.d.]. Disponível em: &lt;https://oec.xmu.edu.cn/en/Study/Credits.htm&gt;. Acesso em: 8 jul. 2025\n\n\n[10] BRASIL. Lei nº 9.394, de 20 de dezembro de 1996. Estabelece as diretrizes e bases da educação nacional., 1996. Disponível em: &lt;https://www.planalto.gov.br/ccivil_03/leis/l9394.htm&gt;. Acesso em: 11 jul. 2025\n\n\n[11] BRASIL. Resolução nº 2, de 18 de junho de 2007. Dispõe sobre carga horária mínima e procedimentos relativos à integralização e duração dos cursos de graduação, bacharelados, na modalidade presencial. Diário Oficial da UniãoBrasília, DF, 19 Jun. 2007. Disponível em: &lt;http://portal.mec.gov.br/cne/arquivos/pdf/2007/rces002_07.pdf&gt;. Acesso em: 11 jul. 2025\n\n\n[12] BRASIL. Parecer CNE/CES nº 261, de 9 de novembro de 2006. Solicita pronunciamento desta câmara sobre a duração do curso de bacharelado em educação física e sua carga horária. Diário Oficial da UniãoBrasília, DF, 18 Jan. 2007. Disponível em: &lt;http://portal.mec.gov.br/cne/arquivos/pdf/2006/pces261_06.pdf&gt;. Acesso em: 11 jul. 2025\n\n\n[13] FRAUCHES, C. Educação superior comentada: Políticas, diretrizes, legislação e normas do ensino superior. ABMES, Colunas, 4 Jul. 2011. Disponível em: &lt;https://www.abmes.org.br/colunas/detalhe/255/educacao-superior-comentada-politicas-diretrizes-legislacao-e-normas-do-ensino-superior&gt;. Acesso em: 11 jul. 2025\n\n\n[14] CARNEGIE MELLON CENTER OF COMPUTATIONAL THINKING. What is computational thinking., [s.d.][s.d.]. Disponível em: &lt;https://www.cs.cmu.edu/~CompThink/&gt;. Acesso em: 6 jul. 2025\n\n\n[15] PROJECT OLYMPUS, CARNEGIE MELLON UNIVERSITY. PROBE Projects. https://www.cmu.edu/project-olympus/probe-projects/index.html, [s.d.]. \n\n\n[16] OPEN LEARNING INITIATIVE, CARNEGIE MELLON UNIVERSITY. Principles of Computation with Python — Open & Free. https://oli.cmu.edu/courses/principles-of-computation-with-python-open-free/, [s.d.]. \n\n\n[17] UNIVERSITY OF CAMBRIDGE. Department of computer science and technology. Algorithms 1., [s.d.]a[s.d.]a. Disponível em: &lt;https://www.cl.cam.ac.uk/teaching/2324/Algorithm1/&gt;. Acesso em: 12 jul. 2025\n\n\n[18] VEX ROBOTICS. VEX Robotics Official Website. https://www.vexrobotics.com/, 2025. \n\n\n[19] CARNEGIE MELLON ROBOTICS ACADEMY. Coding and computational thinking with VEX V5., [s.d.][s.d.]. Disponível em: &lt;https://www.cmu.edu/roboticsacademy/roboticscurriculum/VEX%20Curriculum/coding_v5.html&gt;. Acesso em: 6 jul. 2025\n\n\n[20] DENNING, P. J.; TEDRE, M. Computational thinking. Cambridge, MA: The MIT Press, 2019. \n\n\n[21] MASSACHUSETTS INSTITUTE OF TECHNOLOGY. A computational thinking requirement for MIT undergraduates: Report of the working group on computational thinking., 2017. Disponível em: &lt;https://facultygovernance.mit.edu/sites/default/files/reports/2017-01_computational_thinking_requirement_FINAL_CLEAN.pdf&gt;. Acesso em: 11 jul. 2025\n\n\n[22] MASSACHUSETTS INSTITUTE OF TECHNOLOGY. General institute requirements. MIT Course Catalog, [s.d.]. Disponível em: &lt;https://catalog.mit.edu/mit/undergraduate-education/general-institute-requirements/&gt;. Acesso em: 11 jul. 2025\n\n\n[23] PENN STATE UNIVERSITY. Computer science (CMPSC) - university bulletin - penn state., [s.d.]a[s.d.]a. Disponível em: &lt;https://bulletins.psu.edu/university-course-descriptions/undergraduate/cmpsc/&gt;. Acesso em: 6 jul. 2025\n\n\n[24] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information technology – Programming languages – C. Geneva, Switzerland: International Organization for Standardization (ISO), 2018. Disponível em: &lt;https://www.iso.org/standard/74528.html&gt;.\n\n\n[25] HARVARD UNIVERSITY. CS50: Introduction to computer science., 2025. Disponível em: &lt;https://pll.harvard.edu/course/cs50-introduction-computer-science&gt;\n\n\n[26] HARVARD UNIVERSITY. Syllabus - CS50: Computer science courses and programs from harvard., 2025. Disponível em: &lt;https://cs50.harvard.edu/syllabus&gt;\n\n\n[27] SCRATCH FOUNDATION. Scratch., [s.d.][s.d.]. Disponível em: &lt;https://scratch.mit.edu/&gt;. Acesso em: 7 jul. 2025\n\n\n[28] PYTHON SOFTWARE FOUNDATION. The Python Language Reference. Disponível em: &lt;https://docs.python.org/3/reference/index.html&gt;. Acesso em: 13 jul. 2025. \n\n\n[29] STANFORD UNIVERSITY. CS106A syllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1258/syllabus&gt;\n\n\n[30] STANFORD UNIVERSITY. CS106B syllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/cs106b/syllabus&gt;\n\n\n[31] FREDOVERFLOW. Karel The Robot. Disponível em: &lt;https://github.com/fredoverflow/karel&gt;. Acesso em: 13 jul. 2025. \n\n\n[32] STANFORD UNIVERSITY. Programming methodology - stanford engineering everywhere | CS106A., 2025. Disponível em: &lt;https://see.stanford.edu/course/cs106a&gt;\n\n\n[33] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information technology – Programming languages – C++. Geneva, Switzerland: International Organization for Standardization (ISO), 2020. Disponível em: &lt;https://isocpp.org/std/the-standard&gt;.\n\n\n[34] RYCROFT-SMITH, L.; CONNOLLY, C. Comparing conceptions of mathematical and computational thinking cycles. Cambridge Espresso, 2019. \n\n\n[35] GOULD, T.; RYCROFT-SMITH, L. Establishing concepts of ratio. Instant, Cambridge Mathematics, 2022. \n\n\n[36] DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLOGY. Course pages 2023-24. University of Cambridge; https://www.cl.cam.ac.uk/teaching/2324/, 2024. \n\n\n[37] DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLOGY. Algorithms 1. University of Cambridge; https://www.cl.cam.ac.uk/teaching/2324/Algorithm1/, 2024. \n\n\n[38] UNIVERSITY OF CAMBRIDGE. Faculty of education. Computational thinking challenge., [s.d.]b[s.d.]b. Disponível em: &lt;https://www.educ.cam.ac.uk/research/programmes/computationalthinking/&gt;. Acesso em: 12 jul. 2025\n\n\n[39] DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLOGY. Algorithms 2. University of Cambridge; https://www.cl.cam.ac.uk/teaching/2324/Algorithm2/, 2024. \n\n\n[40] DEPARTMENT OF COMPUTER SCIENCE, UNIVERSITY OF OXFORD. Computer science. University of Oxford; https://www.cs.ox.ac.uk/teaching/bacompsci/, 2024. \n\n\n[41] DEPARTMENT OF COMPUTER SCIENCE, UNIVERSITY OF OXFORD. Mathematics and computer science. University of Oxford; https://www.cs.ox.ac.uk/teaching/mcs/, 2024. \n\n\n[42] UNIVERSITY OF OXFORD. UK bebras participants in the oxford university computing challenge., [s.d.]d[s.d.]d. Disponível em: &lt;https://www.raspberrypi.org/blog/uk-bebras-oxford-university-computing-challenge-2022/&gt;. Acesso em: 12 jul. 2025\n\n\n[43] UNIVERSITY OF OXFORD. Oxford university computing challenge and related programs., [s.d.]b[s.d.]b. Disponível em: &lt;https://www.raspberrypi.org/blog/uk-bebras-oxford-university-computing-challenge-2022/&gt;. Acesso em: 12 jul. 2025\n\n\n[44] UKCT CHALLENGES. About us. UKCT Challenges; https://ukctchallenges.org/about/, 2024. \n\n\n[45] RASPBERRY PI FOUNDATION. The UK bebras challenge. https://www.bebras.uk/, 2025. \n\n\n[46] IMPERIAL COLLEGE LONDON. Programme specification 2024-25: MEng computing. https://www.imperial.ac.uk/media/imperial-college/study/programme-specifications/computing/24x2f25/G401-MEng-Computing-2024-25.pdf, 2024. \n\n\n[47] IMPERIAL COLLEGE LONDON. I-x – reimagining the university in an age of rapid innovation. https://www.imperial.ac.uk/stories/ix-rapid-innovation/, 2020. \n\n\n[48] CARDIFF SCHOOL OF COMPUTER SCIENCE AND INFORMATICS. CM1101: Computational Thinking. https://data.cardiff.ac.uk/legacy/grails/module/CM1101.html, 2025. \n\n\n[49] CARDIFF SCHOOL OF COMPUTER SCIENCE AND INFORMATICS. CM1103: Problem Solving with Python. https://data.cardiff.ac.uk/legacy/grails/module/CM1103/24A.html, 2025. \n\n\n[50] EUROPEAN COMMISSION. Digital education action plan 2021-2027., 2021. Disponível em: &lt;https://education.ec.europa.eu/focus-topics/digital-education/action-plan&gt;. Acesso em: 6 jul. 2025\n\n\n[51] ETH ZÜRICH. Computational thinking., 2020. Disponível em: &lt;https://disco.ethz.ch/courses/hs20/coti/lecturenotes/script.pdf&gt;. Acesso em: 6 jul. 2025\n\n\n[52] BERGMANN, J.; SAMS, A. Flip your classroom: Reach every student in every class every day. Eugene: ISTE, 2012. \n\n\n[53] ETH ZURICH. Flipped Classroom. https://ethz.ch/en/the-eth-zurich/education/educational-development/planning-teaching/flipped-classroom.html, 2025. Acesso em: 15 jul. 2025\n\n\n[54] ETH ZURICH. Programming for beginners. https://ethz.ch/en/studies/bachelor/beginning-your-studies/subject-related-preparation/programming-beginners.html, 2025. Acesso em: 15 jul. 2025\n\n\n[55] EHL HOSPITALITY BUSINESS SCHOOL. Course Catalogue: Undergraduate Programs. Lausanne, Chur-Passugg, Singapore: EHL Hospitality Business School, 2023-2024.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Analisando Currículos Internacionais</span>"
    ]
  },
  {
    "objectID": "def.html",
    "href": "def.html",
    "title": "4  Definição e Princípios da Metodologia DAAD",
    "section": "",
    "text": "4.1 Metodologias Semelhantes ao DAAD\nA Metodologia DAAD se distingue de outras abordagens pedagógicas de Pensamento Computacional por sua ênfase na Depuração como etapa essencial do processo de aprendizado. A seguir, são apresentadas algumas metodologias concorrentes e suas diferenças em relação ao DAAD.\nA abordagem dos Quatro Pilares do Pensamento Computacional, desenvolvida pela Universidade de York, estrutura-se em decomposição, reconhecimento de padrões, abstração e pensamento algorítmico. Essa metodologia enfatiza a fragmentação de problemas complexos e a identificação de regularidades, mas não formaliza etapas de validação, limitando-se à concepção teórica de soluções (10).\nA Abordagem por Atividades Desplugadas, proposta por (11), prioriza intervenções pedagógicas sem uso de tecnologia, utilizando recursos físicos, como quebra-cabeças, para desenvolver abstração e decomposição. Embora eficaz em contextos com infraestrutura limitada, sua aplicação tende a focar em modelagem de hardware em detrimento do design sistemático de algoritmos, além de carecer de sequencialidade didática clara (10).\nA metodologia de Wing (2006) (2), base teórica seminal, define pilares como decomposição, abstração, design algorítmico e generalização. Wing enfatiza que a generalização de soluções permite aplicação em múltiplos contextos, porém não integra explicitamente mecanismos de depuração ou validação, sejam eles iterativos ou não, concentrando-se na fase de concepção em vez do refinamento prático (12). Essas lacunas são supridas pela Metodologia DAAD, que incorpora a Depuração como etapa fundamental para testar robustez, eficiência e escalabilidade de algoritmos em cenários reais, como em sistemas embarcados ou otimização NP-Difícil1, consolidando um ciclo completo de desenvolvimento (12). A Table 4.1 resume estas metodologias.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Definição e Princípios da Metodologia DAAD</span>"
    ]
  },
  {
    "objectID": "def.html#metodologias-semelhantes-ao-daad",
    "href": "def.html#metodologias-semelhantes-ao-daad",
    "title": "4  Definição e Princípios da Metodologia DAAD",
    "section": "",
    "text": "Table 4.1: Propostas metodológicas de aplicação pedagógica dos conceitos de Pensamento Computacional\n\n\n\n\n\n\n\n\n\n\n\nMetodologia\nInstituição/Referência\nComponentes-Chave\nDiferenças para o DAAD\n\n\n\n\nQuatro Pilares do PC\nUniversity of York\n1. Decomposição2. Reconhecimento de padrões3. Abstração4. Pensamento algorítmico\n• Substitui Decomposição por Reconhecimento de padrões• Não inclui refinamento iterativo após implementação\n\n\nAbordagem por Atividades Desplugadas\nBrackmann (2022)\n• Problemas físicos (ex.: quebra-cabeças)• Modelagem conceitual sem código• Ênfase em abstração\n• Foco em hardware vs. solução algorítmica• Menos estruturada em etapas sequenciais\n\n\nMetodologia de Wing (2006)\nWing (2006)\n• Decomposição• Abstração• Design algorítmico• Generalização\n• Não formaliza Decomposição como pilar independente• Generalização ≠ Validação prática iterativa",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Definição e Princípios da Metodologia DAAD</span>"
    ]
  },
  {
    "objectID": "def.html#inovações-do-daad",
    "href": "def.html#inovações-do-daad",
    "title": "4  Definição e Princípios da Metodologia DAAD",
    "section": "4.2 Inovações do DAAD",
    "text": "4.2 Inovações do DAAD\nA diferença sine qua non do DAAD em relação aos outros modelos é a integração explícita de Depuração (4). Uma fase do processo de aprendizado dedicada à eliminação e correção de problemas, mas também valida soluções. Essa abordagem de Lehmann (2023) (4) corrige a lacuna de modelos que ignoram o refinamento pós-implementação, promovendo uma compreensão mais profunda e prática do desenvolvimento de algoritmos.\nNa Abordagem de York (2020) (9), o reconhecimento de padrões é estático, enquanto no DAAD a abstração é dinâmica, preparação para depuração. O modelo original de Wing (2006) (2) trata generalização como resultado, enquanto no DAAD a Depuração torna-a processual através de iteração. Finalmente, a Abordagem Desplugada de Brackmann (2022) (11) enfatiza modelagem física, mantém abstração como conceito teórico, já na Metodologia DAAD vincula-se à rastreabilidade durante validação, enquanto a Metodologia DAAD prioriza soluções algorítmicas e validação prática.\nA estrutura do DAAD também inclui uma sequência pedagógica otimizada em ordenação lógica: Problema → Abstração → Algoritmo → Validação. O que contrasta com os modelos fragmentados, como as metodologias de York (9) e Wing (2) que não articulam nenhuma ordem de transição entre etapas. Além disso, como o objetivo é criar um framework pedagógico para a disciplina de Raciocínio Algorítmico, inicialmente, e depois progredir para todas as disciplinas dos cursos de Ciência e Engenharia da Computação, a Metodologia DAAD enfatiza a criação de algoritmos robustos e eficientes, alinhando-se às demandas do mercado de trabalho. Portanto, a Metodologia DAAD inclui a aplicação de técnicas avançadas de depuração, como testes de estresse e análise de casos limites, que vão além da simples correção de erros sintáticos. Suportando processos de depuração sistemática alinhados às demandas industriais à medida que a complexidade das disciplinas aumenta ao longo do curso.\nA relação entre as fases do DAAD e a solução de problemas pode ser validada por meio da análise de problemas simples típicos das disciplinas introdutórias dos cursos de Ciência e Engenharia da Computação. A Figure 4.1 apresenta exemplos de problemas simples que podem ser resolvidos usando a Metodologia DAAD. Esses problemas são comuns em disciplinas introdutórias e ilustram como cada fase do DAAD pode ser aplicada para chegar a uma solução eficaz.\n\n\n\n\n\n\n\nFigure 4.1: Exemplos de problemas simples que podem ser resolvidos usando a metodologia DAAD.\n\n\n\n\nA Metodologia DAAD foi concebida para ir além das disciplinas introdutórias e além dos cursos de Ciência e Engenharia da Computação. O objetivo é que a Metodologia DAAD ajude a criar a capacidade de resolver problemas complexos de forma sistemática, promovendo uma compreensão profunda dos processos envolvidos na criação de soluções em qualquer área do conhecimento. Entretanto, como a prova de conceito aqui proposta diz respeito aos cursos de Ciência e Engenharia da Computação, a seguir são apresentados exemplos de aplicação do DAAD em contextos mais avançados, que demonstram sua versatilidade e aplicabilidade em problemas complexos e multidisciplinares.\n\nOtimização Algorítmica para Problemas NP-Difíceis: usando um modelo de decomposição baseado usando o Teorema Cook-Levin para problemas NP-completos, com métricas de validação de Dolan-Moré (13).\n\n\nDecomposição: fragmentação de problemas de otimização combinatorial (ex.: problema do caixeiro viajante) em subproblemas de roteamento local e conexões inter-regionais, permitindo abordagens divide-et-conquer, dividir e conquistar.\n\nAlgoritmização: implementação de meta-heurísticas para busca de soluções ótimas em espaços de estado complexos.\n\nDepuração: validação via análise de falhas entre soluções heurísticas e limites teóricos, utilizando perfis de desempenho para avaliação estatística .\n\n\nEngenharia de Sistemas Embarcados: usando framework de abstração conforme definido por Wilhelm (2008) para sistemas tempo-real, com validação por Henzinger (2007), teremos:\n\n\nAbstração: modelagem de invariantes temporais e de consumo energético através de Worst-Case Execution Time, WCET, e máquinas de estado de consumo, filtrando variáveis não essenciais ao cumprimento de restrições rígidas de tempo real.\n\nAlgoritmização: síntese de algoritmos com garantias formais (ex.: controle PID com provas de estabilidade usando a Função de Lyapunov (14)) atendendo a requisitos de segurança.\n\nDepuração: verificação Hardware-In-the-Loop, HIL, com injeção de falhas sistêmicas e análise de violações de datas limites via acompanhamento e registro, em tempo real.\n\n\nDesenvolvimento de Pipeline de Aprendizado de Máquina: usando com referência o trabalho de Geron (2019) (15), que descreve a construção de sistemas de aprendizado de máquina como um processo iterativo e sistemático, teremos:\n\n\nDecomposição: fragmentação do fluxo de trabalho em coleta de dados, pré-processamento, seleção de modelo, treinamento e avaliação.\n\nAbstração: identificação de características essenciais nos dados (ex.: seleção de funcionalidades via análise de componente principal, PCA, ou análise de importância) .\n\nAlgoritmização: projeto de arquitetura de redes neurais ou ajuste de hiperparâmetros de algoritmos de classificação.\n\nDepuração: validação cruzada, análise de superajuste, overfitting e ajuste de modelos com base em métricas de precisão.\n\n\nDesenvolvimento de Sistemas Concorrentes: usando como referência o trabalho de Herlihy (2015)(16), que aborda a construção de sistemas concorrentes e distribuídos, teremos:\n\n\nDecomposição: divisão do sistema em tarefas concorrentes (ex.: threads para E/S, processamento e comunicação).\n\nAbstração: isolamento de seções críticas e recursos compartilhados (ex.: buffer de mensagens).\n\nAlgoritmização: criação de protocolos de sincronização (ex.: semáforos, mutexes) e algoritmos de exclusão mútua.\n\nDepuração: teste de estresse para detecção de deadlocks e condições de corrida com ferramentas como Valgrind ou TSan .\n\n\nDesenvolvimento de Sistemas Distribuídos: este caso requer a aplicação dos princípios de decomposição hierárquica e depuração em falhas não determinísticas, seguindo o modelo de Tanenbaum (2015) (17) para sistemas distribuídos.\n\n\nDecomposição: divisão de sistemas complexos em microsserviços independentes (ex.: separação de módulos de autenticação, processamento de pagamentos e gerenciamento de dados) para tratamento paralelo.\nAlgoritmização: implementação de protocolos de consenso como Raft ou Paxos para garantir consistência entre nós distribuídos.\nDepuração: simulação de falhas em cascata e testes de partição de rede com ferramentas como Chaos Monkey para validar resiliência(18).",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Definição e Princípios da Metodologia DAAD</span>"
    ]
  },
  {
    "objectID": "def.html#metodologia-daad-estrutura-e-fases",
    "href": "def.html#metodologia-daad-estrutura-e-fases",
    "title": "4  Definição e Princípios da Metodologia DAAD",
    "section": "4.3 Metodologia DAAD: Estrutura e Fases",
    "text": "4.3 Metodologia DAAD: Estrutura e Fases\nA Metodologia DAAD é composta por quatro fases principais: Decomposição, Abstração, Algoritmização e Depuração. Cada fase desempenha um papel importante na resolução de problemas complexos, permitindo que os alunos desenvolvam habilidades de raciocínio e análise. A seguir, são apresentadas as fases da Metodologia DAAD e suas respectivas definições.\nA Metodologia DAAD pode ser representada visualmente como um ciclo contínuo, no qual cada fase se conecta à próxima, formando um processo iterativo de resolução de problemas. A Figure 4.2 ilustra essa representação, destacando as fases de Decomposição, Abstração, Algoritmização e Depuração.\n\n\n\n\n\n\n\nFigure 4.2: Representação visual da metodologia DAAD.\n\n\n\n\nA representação visual da Metodologia DAAD enfatiza a natureza cíclica e interconectada do processo de resolução de problemas. Porém, contém uma deficiência, pois não representa a natureza iterativa da metodologia; talvez uma espiral fosse mais adequada. Contudo, como a espiral é, em si própria, uma representação complexa, a representação em ciclo parece mais adequada para o ensino inicial da Metodologia DAAD. A característica iterativa e cíclica da Metodologia DAAD pode ser percebida por meio do detalhamento das fases da Metodologia DAAD.\n\n4.3.1 Decomposição: Quebrando a Complexidade\nA Decomposição é o processo analítico pelo qual problemas ou conceitos complexos são divididos em partes menores e mais gerenciáveis (4). Esse passo é necessário para a construção de uma resolução eficaz de problemas, transformando situações que inicialmente parecem complexas e limitantes em elementos mais simples e acessíveis (23). Miller (1956) descobriu que a memória humana está limitada a 7 ± 2 elementos, o que implica que a decomposição de informações complexas em partes menores pode facilitar a compreensão e a retenção (24). Ao dividir um problema grande em subproblemas, torna-se mais fácil analisar cada componente isoladamente e, posteriormente, integrar as soluções para resolver o problema original (4).\nDividir o problema em partes menores, fragmentos, é o primeiro problema que o aluno precisa resolver usando a própria Metodologia DAAD.\nUma das formas de transformar os fragmentos resultantes do processo de decomposição é a modelagem e análise. Um modelo funciona como uma representação abstrata de situações do mundo real (25) e é útil em soluções de engenharia e computação. O processo de modelagem começa com o reconhecimento de padrões e a correspondência de padrões.\nEstes processos envolvem a identificação de similaridades e diferenças entre as partes menores do problema. Esta identificação de similaridades e diferenças ajuda a categorizar os fragmentos do problema em uma sequência específica (1). No contexto da Decomposição, a correspondência de padrões oferece oportunidades interessantes. Os padrões descobertos podem ser transferidos para problemas similares, evitando reiniciar processos do zero.\nO próximo passo é a generalização dos fragmentos, mediante a eliminação de detalhes irrelevantes (26). Aqui, dentro da Decomposição surge um processo de Abstração baseado na lógica indutiva. A lógica indutiva baseia-se no princípio de que conclusões gerais podem ser derivadas de observações e experiências empíricas. Como essas conclusões indutivas contêm incerteza inerente, seu grau de confiabilidade depende do número de observações realizadas (27). Contudo, o uso da indução permite a formulação de regras gerais a partir de casos individuais e permite a definição apurada dos fragmentos em que o problema deve ser resolvido. Neste ponto, a Decomposição exige a dedução. A dedução requer conhecimento das regras e limites do problema que está sendo resolvido. A essência do uso da Abstração na decomposição reside na eliminação de detalhes irrelevantes e no foco em elementos essenciais, simplificando estruturas complexas e permitindo ênfases específicas (3).\nA definição das partes resultantes da Decomposição requer que os fragmentos encontrados sejam validados. A validação é o processo de garantir que as partes do problema sejam adequadas para a solução do problema original e que funcionem em conjunto. Para isso, é importante organizar as partes em uma forma que permita a avaliação. Esta organização é chamada de Algoritmização. A validação pode ser feita por meio de testes, simulações ou outras técnicas que garantam que as partes sejam adequadas para a solução do problema original (4). Este processo de validação é, na verdade, a aplicação dos conceitos de Depuração.\nNo contexto da engenharia, a decomposição é empregada para desmembrar tarefas complexas, como a simulação de construção, em segmentos menores e mais fáceis de gerenciar (5). Na ciência da computação, a Decomposição visa quebrar um problema ou sistema complexo em partes que são mais fáceis de conceber, entender, programar e manter (19).\nExemplos clássicos unplugged incluem a divisão da tarefa de fazer um bolo em etapas menores, como preparar a massa, assar o bolo, fazer a cobertura e aplicá-la. Todos os exemplos de tarefas diárias, como fazer um sanduíche, montar um quebra-cabeça ou organizar uma festa, podem ser vistos como exemplos de Decomposição. Desmembrar uma tarefa como fazer um bolo, ou outras tarefas diárias, em etapas menores e mais gerenciáveis busca facilitar a execução e o entendimento do processo como um todo, o que reflete diretamente o propósito da Decomposição: quebrar um problema ou sistema complexo em partes que são mais fáceis de conceber, entender, programar ou manter (2).\n\n\n4.3.2 Abstração: Focando no Essencial\nA Abstração é uma técnica central do Pensamento Computacional que se concentra em identificar informações importantes e relevantes, enquanto ignora detalhes desnecessários ou irrelevantes, facilitando uma compreensão mais clara das questões essenciais (1) referentes ao problema que precisa ser resolvido. A abstração é o processo de generalizar detalhes concretos para direcionar a atenção para aspectos de maior importância (26).\nA abstração é considerada o processo de pensamento de mais alto nível no Pensamento Computacional, conferindo a capacidade de escalar e gerenciar a complexidade (26). A sua presença é tão difundida na ciência da computação que a sua descrição concisa é um desafio, e embora haja um consenso sobre a sua centralidade (1), as definições exatas podem variar entre os investigadores. Porém, unindo as definições, podemos afirmar que:\nA Abstração é o processo cognitivo de redução da complexidade que envolve a criação de representações gerais de processos ou grupos de objetos mediante a remoção sistemática de informações desnecessárias e o foco seletivo nos elementos essenciais de uma situação específica (21). Este processo permite a formulação de afirmações gerais que resumem exemplos particulares sobre conceitos, procedimentos, relações e modelos subjacentes (4), constituindo uma estratégia fundamental para lidar com a complexidade (29).\nA Abstração caracteriza-se pela capacidade de identificar padrões e realizar generalizações a partir de instâncias específicas, criando representações que sejam não apenas apropriadas para o propósito imediato, mas também reutilizáveis em contextos diferentes (23). Esta habilidade cognitiva permite que soluções desenvolvidas para problemas específicos possam ser adaptadas e aplicadas a situações análogas, otimizando o processo de resolução de problemas e promovendo a transferência de conhecimento entre domínios distintos.\nNo contexto do Raciocínio Algorítmico e do Pensamento Computacional, a Abstração funciona como uma ferramenta indispensável para a simplificação de estruturas complexas e terá impacto na Decomposição e Algoritmização. A Abstração permite que os solucionadores de problemas concentrem seus recursos cognitivos nos aspectos mais relevantes e significativos de uma situação, descartando detalhes que não contribuem para a compreensão ou resolução do problema em questão (3).\nComo a abstração também é caracterizada como a habilidade de construir representações utilizando os componentes essenciais que demonstram o funcionamento do problema ou sistema (4). Exemplos ilustrativos, unplugged, de Abstração incluem o uso de mapas, que simplificam o mundo real ao omitir detalhes desnecessários e, principalmente fluxogramas.\nOs fluxogramas funcionam como ferramentas de abstração porque simplificam processos complexos em representações visuais que eliminam detalhes de implementação específicos. Além disso, os fluxogramas identificam padrões estruturais (sequências, decisões, repetições) e removem informações desnecessárias como sintaxe específica, permitindo que programadores se concentrem no essencial do problema. Finalmente, fluxogramas podem ser realizados completamente unplugged, sem o uso de computadores, o que os torna uma ferramenta acessível para ensinar abstração e raciocínio algorítmico utilizando as vantagens cognitivas do ensino unplugged(30). O uso de fluxogramas induz a Algoritmização.\n\n\n4.3.3 Algoritmização: Desenvolvendo Soluções Sistemáticas\nA Algoritmização, ou Design de Algoritmos para Wing (2006) (2), envolve a criação de instruções passo a passo ou procedimentos para resolver um problema. Um algoritmo é definido como uma sequência finita de instruções matematicamente rigorosas, tipicamente utilizadas para resolver uma classe específica de problemas ou para realizar uma computação (31). Para fazer um algoritmo, é necessário decompor o problema em partes menores, identificar padrões e abstrair os detalhes irrelevantes, seguindo as etapas da Metodologia DAAD. A Algoritmização é a fase em que as soluções são formalizadas e estruturadas, permitindo que sejam implementadas de forma sistemática e eficiente (4).\nA Algoritmização baseia-se na premissa de que as soluções para os problemas não se limitam a respostas pontuais, mas sim a algoritmos que podem fornecer respostas sempre que necessário para casos gerais (22). É o processo de construir um esquema de passos ordenados que podem ser seguidos para fornecer soluções para todos os problemas constituintes necessários para resolver o problema original. A capacidade de expressar uma solução na forma de um algoritmo demonstra uma compreensão mais profunda do problema (33). A eficiência, em termos de velocidade ou uso de memória, é uma consideração importante na criação de algoritmos (33) sempre que o objetivo final for transformar o algoritmo em uma solução computacional.\nAs abstrações necessárias ao entendimento de algoritmos podem ser expressas de várias formas, incluindo linguagem natural, pseudocódigo, fluxogramas e diagramas (31). Neste contexto, destacam-se os fluxogramas e o pseudocódigo como ferramentas de apoio.\nO pseudocódigo atua como uma ponte entre a abstração visual e a escrita de código real, descrevendo algoritmos em linguagem natural estruturada. O pseudocódigo facilita a compreensão de estruturas condicionais (8). Expressar um processo como um algoritmo, o que o pseudocódigo permite, força a precisão na formulação e leva a uma compreensão mais profunda do problema do que outros meios de pensamento tradicionais (8).\nO fluxograma permite que os alunos visualizem estruturas de controle como condicionais e laços, além do fluxo de dados e pontos de parada. Um exemplo prático envolve representar a tomada de decisão para identificar se um número é positivo ou negativo, conectando etapas como leitura do valor, verificação da condição e saída do resultado em uma sequência gráfica. A Figure 6.1 ilustra um exemplo de fluxograma que pode ser usado para ensinar a Algoritmização em uma ferramenta que remove o fator unplugged porém permite a Depuração independente (34).\n\n\n\n\n\n\n\nFigure 4.3: Exemplo de fluxograma que pode ser usado para ensinar a Algoritmização.\n\n\n\n\n\n\n4.3.4 Depuração: Identificando e Corrigindo Erros\nA Depuração é a fase responsável por encontrar e remover erros, imperfeições ou elementos indesejáveis durante todas as fases da Metodologia DAAD. Na computação, a depuração, debugging, é o processo de identificar, isolar e corrigir erros em programas de computador, garantindo que eles funcionem conforme o esperado (31).\nO processo de depuração envolve a identificação do erro, a análise de sua causa, registrando as mudanças de estado do programa e os valores dos dados, a correção do problema e a validação da correção por meio de testes (29). É uma atividade iterativa que contribui para a construção do conhecimento e o aprendizado de estratégias de resolução de problemas (35).\nO trabalho de Brennan e Resnick (2012) (35) estabelece a Depuração como uma das práticas computacionais fundamentais. Esta abordagem reconhece debugging não como habilidade isolada, mas como componente integrado do processo de resolução de problemas. A Depuração pode ser sintetizada em cinco etapas: validar; identificar; representar; localizar e corrigir. Esta sistematização oferece framework pedagógico aplicável a diferentes faixas etárias, desde educação infantil até ensino superior, com adaptações apropriadas para cada nível de desenvolvimento cognitivo (35).\nNas fases de Decomposição e Abstração, a Depuração atua como um processo de refinamento contínuo. Cada fase requer uma técnica específica para identificar e corrigir problemas, garantindo que o processo de resolução de problemas seja robusto e eficiente. Por exemplo, na Decomposição, a depuração pode envolver a verificação da clareza e viabilidade dos subproblemas identificados. Na Abstração, a depuração pode se concentrar na eliminação de detalhes irrelevantes que possam obscurecer a compreensão do problema. Nestes dois casos, a representação de conceitos em palavras simples pode ser a forma mais eficiente.\nNeste cenário, fluxogramas oferecem representação visual clara da lógica algorítmica, facilitando identificação de caminhos de execução problemáticos. Estratégias eficazes incluem a análise visual através do rastreamento do fluxo do algoritmo identificando pontos de falha. Tanto o fluxograma quanto o pseudocódigo são ferramentas valiosas para a Depuração, pois permitem que os alunos visualizem a lógica do algoritmo e identifiquem possíveis erros de forma mais intuitiva. Tabelas de rastreamento, nas quais os alunos registram valores de variáveis e estados do programa durante a execução, são úteis para identificar erros lógicos e comportamentais.",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Definição e Princípios da Metodologia DAAD</span>"
    ]
  },
  {
    "objectID": "def.html#ferramentas-de-abstração-na-metodologia-daad",
    "href": "def.html#ferramentas-de-abstração-na-metodologia-daad",
    "title": "4  Definição e Princípios da Metodologia DAAD",
    "section": "4.4 Ferramentas de Abstração na Metodologia DAAD",
    "text": "4.4 Ferramentas de Abstração na Metodologia DAAD\nAs ferramentas de abstração e apoio à Metodologia DAAD incluem uma variedade de recursos visuais e interativos que facilitam a compreensão e aplicação das fases do processo. Algumas dessas ferramentas são:\n\n4.4.1 Fluxogramas\nRepresentações visuais que ilustram a lógica do algoritmo, permitindo identificar facilmente os passos e decisões envolvidas. Historicamente, o fluxograma — uma representação visual padronizada de processos — emergiu como uma das principais ferramentas para construir essa ponte entre o pensamento humano e a lógica computacional na década de 1960. No entanto, sua prevalência e utilidade são temas de um debate contínuo e vigoroso na academia, refletindo uma tensão mais ampla entre a teoria da carga cognitiva, a necessidade de aprendizado e a rápida evolução dos paradigmas de programação. A persistência dos fluxogramas em contextos educacionais é sustentada por vantagens pedagógicas claras, validadas por estudos empíricos.\n\nRedução da Carga Cognitiva: A principal vantagem é a separação da lógica da sintaxe. Ferramentas visuais como os fluxogramas reduzem a carga extrínseca, permitindo que os alunos dediquem seus recursos cognitivos à tarefa mais fundamental de estruturar uma solução (36).\nClareza Visual e Desempenho Superior em Compreensão: Um estudo empírico de 2022, que utilizou rastreamento ocular, descobriu que, ao analisar algoritmos, os participantes foram significativamente mais rápidos, cometeram menos erros e tiveram maior confiança em suas soluções ao usar fluxogramas estruturados em comparação com o pseudocódigo (37).\nAlavanca para a Programação Textual (Scaffolding): Pesquisas recentes demonstram que a habilidade de resolver problemas usando fluxogramas é um forte preditor da habilidade de resolver os mesmos problemas em uma linguagem textual como o Python (36).\nAplicações Modernas e Inovadoras: A defesa moderna dos fluxogramas não se concentra no desenho manual, mas em sua integração em ambientes de software interativos. Ferramentas como o Progranimate permitem que os alunos construam fluxogramas dinâmicos que são sincronizados visualmente com o código gerado e uma animação da execução do programa (36).\n\nA crítica mais contundente ao uso de fluxogramas surge da sua inadequação aos paradigmas modernos. Os fluxogramas são inerentemente procedurais e sequenciais. Eles são inadequados para representar paradigmas como Programação Orientada a Objetos (POO), recursividade e concorrência (38). Para modelar sistemas complexos e orientados a objetos, a indústria e a academia utilizam a Linguagem de Modelagem Unificada (UML). Apesar disso, a evolução histórica das ferramentas de ensino de programação, desde os fluxogramas e pseudocódigo, passando pelas linguagens baseadas em blocos como o Scratch, até aos modernos assistentes de IA, pode ser vista como uma busca contínua por um ponto ótimo de abstração. Cada geração de ferramentas tenta minimizar a carga cognitiva extrínseca (relacionada com a sintaxe e o ambiente de desenvolvimento) sem sacrificar a carga cognitiva essencial, o próprio Raciocínio Algorítmico (39). Esta trajetória não é aleatória; é uma otimização pedagógica impulsionada pela teoria da carga cognitiva, que procura libertar os recursos mentais do aluno para que se possam concentrar no que é verdadeiramente fundamental: a arte de resolver problemas.\nA principal vantagem pedagógica do fluxograma reside na sua clareza visual. Ao representar um algoritmo como um diagrama, ele transforma um processo temporal e abstrato num artefacto espacial e concreto, permitindo que os alunos visualizem um constructo físico que representa o fluxo de controle, os pontos de decisão e a sequência de operações. Para isso, na Metodologia DAAD, como proposta neste documento, os alunos poderão utilizar apenas 4 dos símbolos usados para fluxogramas (40), como pode ser visto na Figure 4.4.\n\n\n\n\n\n\n\nFigure 4.4: Símbolos usados para fluxogramas na metodologia DAAD.\n\n\n\n\nA simplicidade dos símbolos utilizados na Metodologia DAAD, em relação aos símbolos tradicionais de fluxogramas(41), permite que os alunos se concentrem na lógica do algoritmo, e internalizem as abstrações básicas para a solução de problemas usando o Raciocínio Algorítmico. Algumas pesquisas corroboram a eficácia dos fluxogramas na educação de programação:\n\nEficiência na Compreensão: uma quantidade significativa de evidências empíricas sugere que os fluxogramas são superiores ao pseudocódigo em tarefas de compreensão de algoritmos. Estudos controlados, alguns utilizando tecnologia de eye-tracking para medir objetivamente a atenção, descobriram que os participantes analisavam algoritmos representados por fluxogramas de forma significativamente mais rápida e com menos erros do que quando representados por pseudocódigo (42).\nImpacto da Complexidade: a vantagem dos fluxogramas parece aumentar com a complexidade do algoritmo. Para problemas mais complexos, a diferença no tempo de análise e na taxa de erro a favor dos fluxogramas torna-se ainda mais pronunciada (42).\nConfiança e Preferência do Aluno: os alunos não só têm um desempenho melhor com fluxogramas, como também relatam sentir-se mais confiantes nas suas soluções e expressam uma clara preferência pela representação visual. Num estudo seminal de Scanlan (1989) (43), os alunos que usaram fluxogramas demonstraram uma melhor compreensão, maior confiança, cometeram menos erros e necessitaram de menos tempo de aprendizagem em comparação com os que usaram pseudocódigo (44).\nBase Cognitiva: acredita-se que a representação visual e espacial dos fluxogramas estimula ambos os hemisférios cerebrais, enquanto o pseudocódigo, sendo textual, estimula predominantemente o hemisfério esquerdo, associado ao processamento lógico e linguístico. Esta estimulação mais holística pode tornar os fluxogramas mais acessíveis a uma gama mais vasta de estilos de aprendizagem (45).\n\nA Figure 4.5 ilustra um exemplo de fluxograma que pode ser usado para ensinar a Abstração e a Algoritmização em uma ferramenta que remove o fator unplugged porém permite a Depuração independente.\n\n\n\n\n\n\n\nFigure 4.5: Exemplo de fluxograma que pode ser usado para ensinar a Abstração e a Algoritmização.\n\n\n\n\nA análise da literatura e da prática curricular revela um paradoxo notável. Por um lado, a investigação empírica, particularmente estudos controlados recentes, demonstra que os fluxogramas podem ser uma ferramenta de abstração eficaz para programadores iniciantes. Eles superam consistentemente o pseudocódigo em tarefas de compreensão visual, reduzem o tempo de aprendizagem e a taxa de erros, e aumentam a confiança dos alunos (42). Por outro lado, esta eficácia teórica contrasta fortemente com sua ausência quase total na prática pedagógica das principais universidades pesquisadas neste estudo (48). Estas instituições, que definem as tendências na educação em ciência da computação, relegaram os fluxogramas a um papel secundário em favor da codificação direta em linguagens de alto nível como Python (49), ou do uso de linguagens baseadas em blocos como o Scratch (50) como um passo introdutório. E aqui reside o dilema que o framework proposto por este estudo para a Metodologia DAAD pretende resolver usando as vantagens cognitivas dos fluxogramas sem sacrificar a carga cognitiva necessária aos paradigmas modernos.\nA solução está no equilíbrio. A pedagogia de Raciocínio Algorítmico não deve adotar uma rejeição total dos fluxogramas, mas sim um reposicionamento estratégico do seu papel no currículo. Em vez de serem vistos como uma ferramenta universal para o design de algoritmos, devem ser empregados como uma ferramenta de nicho, com um propósito pedagógico específico e limitado. O seu uso ideal é como uma ferramenta introdutória e transitória para alunos iniciantes. O objetivo deve ser o de visualizar explicitamente as três estruturas de controlo fundamentais da programação estruturada: atribuição, decisão e iteração (laços).\n\n\n4.4.2 Pseudocódigo\nO pseudocódigo é uma forma de descrever algoritmos em linguagem natural, que ajuda os alunos a entender a lógica sem se preocupar com a sintaxe de uma linguagem de programação específica. A sua estrutura textual do pseudocódigo assemelha-se à estrutura de uma linguagem de programação real, o que pode, teoricamente, facilitar a transição final para a codificação. Além disso, o pseudocódigo parece ser mais adequado para descrever algoritmos complexos em detalhe, nos quais um fluxograma se tornaria visualmente poluído e ilegível (51).\nTipicamente, o pseudocódigo utiliza uma linguagem simples e direta, evitando jargões técnicos. Muitas vezes, é escrito em uma mistura de inglês simples, ou português, com uma estrutura semelhante à de programação, o que o torna acessível tanto para programadores quanto para não programadores. Como o exemplo podemos criar um pseudocódigo baseado no fluxograma da Figure 4.5:\n\n\n\nListing 4.1\n\n\nALGORITMO EncontrarMaximo\nINÍCIO\n    // Entrada dos dados\n    LEIA a\n    LEIA b\n    \n    // Processo de decisão\n    SE a &gt; b ENTÃO\n        max ← a\n    SENÃO\n        max ← b\n    FIM SE\n    \n    // Saída do resultado\n    ESCREVA max\nFIM\n\n\n\nO pseudocódigo, como o apresentado na Listing 4.1, deve ser independente de linguagem, o que significa que pode ser convertido para qualquer linguagem de programação. Foca na lógica do algoritmo, não na sintaxe de uma linguagem de programação específica, mas permite a inclusão de estruturas de controle como loops, condicionais e variáveis, facilitando a compreensão dos conceitos fundamentais de programação. Necessariamente precisa ser fácil de ler e entender.\nAlém da vantagem clara de interpretação, sendo baseado em texto, o pseudocódigo é inerentemente mais fácil e rápido de escrever e modificar (51). Apesar da forte evidência a favor dos fluxogramas em tarefas de compreensão, alguns estudos não encontraram diferenças estatisticamente significativas no desempenho dos alunos, sugerindo que a eficácia de cada ferramenta pode ser dependente da tarefa específica (42).\nO framework proposto por este estudo para a Metodologia DAAD propõe o uso do pseudocódigo como uma ferramenta de abstração complementar aos fluxogramas. O pseudocódigo pode ser usado para descrever algoritmos mais complexos, nos quais a clareza visual dos fluxogramas pode não ser suficiente. A combinação de fluxogramas e pseudocódigo permite que os alunos desenvolvam uma compreensão mais profunda dos conceitos de programação, aproveitando as vantagens de ambas as ferramentas. O objetivo é usar o pseudocódigo para fazer a ponte para o pensamento textual; e, finalmente, introduzir uma linguagem de programação completa.\n\n\n4.4.3 Tabelas de Rastreio\nAs Tabelas de Rastreio são estruturas que permitem aos alunos registrar e acompanhar os valores das variáveis e os estados do programa durante a execução, facilitando a identificação de erros. Também são conhecidas como tabelas de rastreio, tabelas de execução, tabelas de acompanhamento ou teste de bancada. Elas são uma ferramenta valiosa para o ensino do Raciocínio Algorítmico e da Depuração, pois permitem que os alunos visualizem o fluxo de controle e as mudanças de estado do programa de forma sistemática. Estas tabelas funcionam como uma simulação manual da execução de um programa, permitindo acompanhar o estado das variáveis e o fluxo de controle passo a passo.\nBasicamente, uma tabela de rastreio é composta por:\n\nColunas para variáveis: cada variável do programa tem sua própria coluna;\nColuna de linha/instrução: indica qual linha do código está sendo executada;\nColunas de saída: registram valores impressos ou exibidos;\nLinhas: cada linha representa um momento na execução.\n\nO processo de construção de uma tabela de rastreio envolve a execução do código linha por linha, registrando as mudanças nas variáveis e quaisquer saídas produzidas. Isso permite que os alunos vejam como o estado do programa evolui ao longo do tempo e identifiquem em que pontos ocorrem erros ou comportamentos inesperados. Para entender tabelas de rastreio, considere que o fluxograma da Figure 4.5 representado pelo pseudocódigo da Listing 4.1 pode ser executado por um programa com os dados de entrada a = 15, b = 8. Neste caso, a tabela de rastreio seria:\n\n\n\nTable 4.2: Tabela de rastreio de exemplo para o pseudocódigo da Listing 4.1.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\na\nb\na &gt; b\nmax\nSaída\nObservações\n\n\n\n\n1\n-\n-\n-\n-\n-\nInício do algoritmo\n\n\n2\n15\n-\n-\n-\n-\nLeitura do primeiro valor\n\n\n3\n15\n8\n-\n-\n-\nLeitura do segundo valor\n\n\n4\n15\n8\nTrue\n-\n-\nAvaliação da condição: 15 &gt; 8\n\n\n5\n15\n8\nTrue\n15\n-\nExecuta ramo verdadeiro\n\n\n9\n15\n8\nTrue\n15\n15\nExibe o resultado\n\n\n10\n15\n8\nTrue\n15\n15\nFim do algoritmo\n\n\n\n\n\n\nA pesquisa do grupo de trabalho Innovation and Technology in Computer Science Education, ITiCSE2, forneceu evidências interessantes sobre visualização e engajamento. O estudo marco Exploring the Role of Visualization and Engagement in Computer Science Education3 estabeleceu que tabelas de rastreio requerem engajamento ativo do aluno para serem educacionalmente valiosas, com resultados de aprendizado correlacionados diretamente aos níveis de engajamento (52). Além disso, O artigo IEEE de 2023 Generating Trace Table for Java Programs4 estendeu conceitos de tabela de rastreio usando implementações baseadas em Excel projetadas em torno de diagramas de sequência UML, facilitando a compreensão de comportamento dinâmico incluindo polimorfismo e ligação dinâmica (53). As duas pesquisas parecem destacar a eficiência de tabelas de rastreio como ferramenta de ensino, notadamente para Depuração e Abstração. Finalmente os cursos de introdução de Stanford combinam tabelas de rastreio com abordagens sistemáticas de depuração(54). A metodologia de Stanford advoga por rastreamento estratégico em vez de exaustivo, reconhecendo que rastreamentos completos de programa são frequentemente impraticáveis para sistemas complexos.\nEssas ferramentas são essenciais para apoiar a Metodologia DAAD, pois proporcionam representações claras e acessíveis dos conceitos envolvidos, facilitando a compreensão e a aplicação das fases do processo de resolução de problemas e permitem a interação unplugged com os conceitos de Raciocínio Algorítmico. A combinação de fluxogramas, pseudocódigo e tabelas de rastreio oferece uma abordagem abrangente para o ensino do Pensamento Computacional, permitindo que os alunos desenvolvam habilidades essenciais de resolução de problemas e programação adequadas às suas capacidades individuais.\n\n\n\n\n[1] CURZON, P. et al. Computational thinking. In: FINCHER, S. A.; ROBINS, A. V. (Eds.). The cambridge handbook of computing education research. Cambridge: Cambridge University Press, 2019. p. 513–546. \n\n\n[2] WING, J. M. Computational thinking. Communications of the ACM, v. 49, n. 3, p. 33–35, Mar. 2006. \n\n\n[3] KONG, S. et al. Pensamento computacional na educação: Perspectivas internacionais. São Paulo: Penso, 2020. \n\n\n[4] LEHMANN, T. H. Using algorithmic thinking to design algorithms: The case of critical path analysis. The Journal of Mathematical Behavior, v. 71, p. 101079, 2023. \n\n\n[5] HIJÓN-NEIRA, R. et al. Computational thinking measurement of CS university students in the AI era. Preprints.org, May 2024. \n\n\n[6] HUANG, R. et al. Computational thinking and the new curriculum standards of information technology for senior high schools in china. In: ABELSON, H.; KONG, S.-C. (Eds.). Computational thinking curricula in k–12: International implementations. Cambridge, Massachusetts; London, England: The MIT Press, 2020. \n\n\n[7] LI, Y. et al. Computational thinking is more about thinking than computing. Journal for STEM Education Research, v. 3, n. 1, p. 1–18, 2020. \n\n\n[8] TEDRE, M.; DENNING, P. J. The long quest for computational thinking. Proceedings of the 16th koli calling conference on computing education research. Anais...Koli, Finland: Nov. 2016. \n\n\n[9] UNIVERSITY OF YORK. Computational thinking: Foundations and fundamentals. YorkDepartment of Computer Science, 2020. \n\n\n[10] SENTANCE, S. et al. Creating cool stuff: Pupils’ experience of the BBC micro:bit. Proceedings of the ACM SIGCSE technical symposium. Anais...Seattle: ACM, 2017. \n\n\n[11] BRACKMANN, C. P. et al. Unplugged versus plugged-in: Examining basic programming achievement and computational thinking of 6th-grade students. Journal of Computer Science Education, 2022. \n\n\n[12] KURKOVSKY, S. Mobile computing and robotics in one course: Teaching design patterns. Journal of Computing Sciences in Colleges, v. 28, n. 6, p. 67–73, 2013. \n\n\n[13] BARAK, B. Chapter 15: NP, NP completeness, and the cook-levin theorem. https://introtcs.org/public/ch15_nptime.html, 2023. \n\n\n[14] MURRAY, R. M.; LI, Z.; SASTRY, S. S. A mathematical introduction to robotic manipulation. [s.l.] CRC Press, 1994. \n\n\n[15] GÉRON, A. Hands-on machine learning with scikit-learn, keras & TensorFlow: Concepts, tools, and techniques to build intelligent systems. 2nd. ed. [s.l.] O’Reilly Media, Inc., 2019. \n\n\n[16] HERLIHY, M.; SHAVIT, N. The art of multiprocessor programming. Revised Reprint ed. Waltham, MA, USA: Morgan Kaufmann Publishers Inc., 2012. \n\n\n[17] TANENBAUM, A. S.; BOS, H. Modern operating systems. 4th. ed. USA: Prentice Hall Press, 2015. \n\n\n[18] NETFLIX, INC. Chaos engineering., 2021. Disponível em: &lt;https://netflix.github.io/chaosmonkey/&gt;. Acesso em: 10 jul. 2025\n\n\n[19] SMITH, J. A. C. B.; GROVER, S.; SMITH, A. L. Measuring computational thinking and computer science outcomes: A resource for CS for all researchers. [s.l.] U.S. Department of Education, Mar. 2021. Disponível em: &lt;https://www.ed.gov/sites/ed/files/2021/03/CSCTOutcomes_508.pdf&gt;.\n\n\n[20] MASSACHUSETTS INSTITUTE OF TECHNOLOGY. A computational thinking requirement for MIT undergraduates: Report of the working group on computational thinking., 2017. Disponível em: &lt;https://facultygovernance.mit.edu/sites/default/files/reports/2017-01_computational_thinking_requirement_FINAL_CLEAN.pdf&gt;. Acesso em: 11 jul. 2025\n\n\n[21] NEW YORK HALL OF SCIENCE. Computational thinking school strategy guide., [s.d.][s.d.]. Disponível em: &lt;https://nysci.org/pdf/NYSCI-Computational-Thinking-School-Strategy-Guide-04-09-2024.pdf&gt;. Acesso em: 6 jul. 2025\n\n\n[22] SAIDIN, N. D. et al. Benefits and challenges of applying computational thinking in education. International Journal of Information and Education Technology, v. 11, n. 5, p. 248–254, 2021. \n\n\n[23] KONG, S.-C. Learning composite and prime numbers through developing an app: An example of computational thinking development through primary mathematics learning. In: KONG, S.-C.; ABELSON, H. (Eds.). Computational thinking education. Singapore: Springer, 2019. p. 155–177. \n\n\n[24] MILLER, G. A. The magical number seven, plus or minus two: Some limits on our capacity for processing information. Psychological Review, v. 63, n. 2, p. 81–97, 1956. \n\n\n[25] FRIGG, R. Models and representation: Why structures are not enough. London: London School of Economics, 2002. Disponível em: &lt;https://romanfrigg.org/wp-content/uploads/writings/Models_and_Representation.pdf&gt;.\n\n\n[26] DENNING, P. J.; TEDRE, M. Computational thinking. Cambridge, MA: The MIT Press, 2019. \n\n\n[27] MUGGLETON, S. Inductive logic programming: Theory and methods. Journal of Logic Programming, v. 19, n. 20, p. 629–679, 1991. \n\n\n[28] ARA’UJO, A. L. S. DE O.; ANDRADE, W. L. DE; GUERRERO, D. D. S. Um mapeamento sistem’atico sobre a avaliaç ao do pensamento computacional no Brasil. Anais do v congresso brasileiro de inform’atica na educaç ao (CBIE). Anais...2016. \n\n\n[29] GROVER, S.; PEA, R. Computational thinking in k–12: A review of the state of the field. Educational Researcher, v. 42, n. 1, p. 38–43, 2013. \n\n\n[30] WEINTROP, D.; WILENSKY, U. Using unplugged activities in adult programming education. Proceedings of the 46th ACM technical symposium on computer science education (SIGCSE ’15). Anais...New York, NY, USA: ACM, 2015. \n\n\n[31] KIM, Y. Computational thinking. In: Educational technology: An online handbook for pre-k-12. [s.l.] EdTech Books, 2021. \n\n\n[32] GÜNDOĞDU, F. et al. Exploring mathematical reasoning skills. ScienceDirect, 2023. \n\n\n[33] LEHMANN, T. H. How current perspectives on algorithmic thinking can be applied to students’ engagement in algorithmatizing tasks. Mathematics Education Research Journal, v. 36, n. 3, p. 609–643, 2024. \n\n\n[34] ALCANTARA, F. C. DE. Fluxograma interativo. https://frankalcantara.com/fluxograma/index.html, [s.d.]. \n\n\n[35] BRENNAN, K.; RESNICK, M. New frameworks for studying and assessing the development of computational thinking. Proceedings of the 2012 annual meeting of the american educational research association. Anais...Vancouver, Canada: 2012. \n\n\n[36] PRITCHARD, T. A. Using flowcharts, code and animation for improved comprehension and ability in novice programming. PhD thesis—[s.l.] University of South Wales, 2018.\n\n\n[37] ALI, F. Effect of flowcharts on code comprehension of novice programmers. Master’s thesis—[s.l.] Chemnitz University of Technology, 2022.\n\n\n[38] SOCIEDADE BRASILEIRA DE COMPUTAÇÃO. Nota Técnica da Sociedade Brasileira de Computação sobre a BNCC-EF e a BNCC-EM. Porto Alegre, RS, Brasil: Sociedade Brasileira de Computação (SBC); https://www.sbc.org.br/wp-content/uploads/2024/07/Nota-t-cnica-sobre-a-BNCC-Ensino-m-dio-e-fundamental-2018.pdf, 2018. \n\n\n[39] LEINONEN, J.; HELLAS, A.; IHANTOLA, P. How can “vibe-coding” transform programming education? Communications of the ACM, May 2024. Disponível em: &lt;https://cacm.acm.org/blogcacm/how-can-vibe-coding-transform-programming-education/&gt;\n\n\n[40] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information processing – documentation symbols and conventions for data, program and system flowcharts, program network charts and system resources charts. [s.l.] International Organization for Standardization, 1985. Disponível em: &lt;https://cdn.standards.iteh.ai/samples/11955/1b7dd254a2a54fd7a89d616dc0570e18/ISO-5807-1985.pdf&gt;.\n\n\n[41] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information processing – documentation symbols and conventions for data, program and system flowcharts, program network charts and system resources charts. Geneva, CHInternational Organization for Standardization, 1985. \n\n\n[42] ANDRZEJEWSKA, M.; STOLIŃSKA, A. Do structured flowcharts outperform pseudocode? Evidence from eye movements. IEEE Access, v. 10, p. 132965–132975, 2022. \n\n\n[43] SCANLAN, D. A. Structured flowcharts outperform pseudocode: An experimental comparison. IEEE Software, v. 6, n. 5, p. 28–36, 1989. \n\n\n[44] THREEKUNPRAPA, A.; YASRI, P. Patterns of computational thinking development while solving unplugged coding activities coupled with the 3S approach for self-directed learning. European Journal of Educational Research, v. 9, n. 3, p. 1025–1045, 2020. \n\n\n[45] SIOZOU, S.; TSELIOS, N.; KOMIS, V. Effect of algorithms’ multiple representations in the context of programming education. Proceedings of the 4th pan-hellenic conference “informatics and education.” Anais...Patras, Greece: 2008. Disponível em: &lt;https://www.researchgate.net/publication/220373268_Effect_of_algorithms'_multiple_representations_in_the_context_of_programming_education&gt;\n\n\n[46] HARVARD UNIVERSITY. CS50: Introduction to computer science., 2025. Disponível em: &lt;https://pll.harvard.edu/course/cs50-introduction-computer-science&gt;\n\n\n[47] STANFORD UNIVERSITY. CS106A syllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1258/syllabus&gt;\n\n\n[48] UNIVERSITY OF CAMBRIDGE. Department of computer science and technology. Algorithms 1., [s.d.]a[s.d.]a. Disponível em: &lt;https://www.cl.cam.ac.uk/teaching/2324/Algorithm1/&gt;. Acesso em: 12 jul. 2025\n\n\n[49] PYTHON SOFTWARE FOUNDATION. The Python Language Reference. Disponível em: &lt;https://docs.python.org/3/reference/index.html&gt;. Acesso em: 13 jul. 2025. \n\n\n[50] SCRATCH FOUNDATION. Scratch., [s.d.][s.d.]. Disponível em: &lt;https://scratch.mit.edu/&gt;. Acesso em: 7 jul. 2025\n\n\n[51] THE KNOWLEDGE ACADEMY. Differences between flowchart and pseudocode: A detailed comparison., 2025. Disponível em: &lt;https://www.theknowledgeacademy.com/blog/flowchart-vs-pseudocode/&gt;\n\n\n[52] KELLEHER, C. D.; PAUSCH, R. Exploring the role of visualization and engagement in computer science education. ACM SIGCSE Bulletin, v. 39, n. 3, p. 213–217, 2007. \n\n\n[53] MEN, N. et al. Hybrid beamforming for RIS-aided multiuser millimeter wave systems. 2022 IEEE 95th vehicular technology conference: (VTC2022-spring). Anais...2022. \n\n\n[54] STANFORD UNIVERSITY. CS106B syllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/cs106b/syllabus&gt;",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Definição e Princípios da Metodologia DAAD</span>"
    ]
  },
  {
    "objectID": "def.html#footnotes",
    "href": "def.html#footnotes",
    "title": "4  Definição e Princípios da Metodologia DAAD",
    "section": "",
    "text": "Problema NP-Difícil: Classe de problemas computacionais considerados altamente complexos, cuja solução exata em tempo razoável é improvável. Resolver tais problemas frequentemente requer algoritmos heurísticos ou aproximados.↩︎\nem tradução livre, Inovação e Tecnologia na Educação em Ciência da Computação, ITiCSE é um grupo de trabalho da ACM SIGCSE, que visa melhorar a educação em ciência da computação por meio de visualização e engajamento.↩︎\nem tradução livre, Explorando o Papel da Visualização e do Engajamento na Educação em Ciência da Computação.↩︎\nem tradução livre, Gerando Tabela de Rastreio para Programas Java.↩︎",
    "crumbs": [
      "Contextualização e Pesquisa",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Definição e Princípios da Metodologia DAAD</span>"
    ]
  },
  {
    "objectID": "desen.html",
    "href": "desen.html",
    "title": "5  Projeto de Disciplina de Raciocínio Algorítmico",
    "section": "",
    "text": "5.1 EMENTA DE DISCIPLINA: RACIOCÍNIO ALGORÍTMICO\nCarga Horária: 68 horas-aula presenciais + 12 horas de trabalho independente\nCréditos: 4,53 (sistema brasileiro)\nPré-requisitos: Nenhum\nModalidade: Presencial\nDesenvolvimento do Raciocínio Algorítmico por meio da Metodologia DAAD (Decomposição, Abstração, Algoritmização e Depuração). A disciplina é estruturada em quatro módulos principais interativos com atividades práticas e projetos que reforçam os conceitos de Introdução ao Raciocínio Algorítmico e técnicas de decomposição de problemas, desenvolvimento de habilidades de abstração e reconhecimento de padrões, design de algoritmos e implementação de estruturas de dados, técnicas de depuração sistemática e desenvolvimento de projetos integrados. Usando os conceitos fundamentais de resolução de problemas computacionais, desde atividades unplugged até implementação de algoritmos e estruturas de dados. Desenvolvimento de habilidades de análise, design e implementação de soluções computacionais utilizando fluxogramas, pseudocódigo e programação em C++ e Python. Aplicação de técnicas de depuração, controle de versão e desenvolvimento de projetos práticos. Complementa as atividades presenciais com três atividades de pesquisa e solução de problemas realizadas fora de sala.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Projeto de Disciplina de Raciocínio Algorítmico</span>"
    ]
  },
  {
    "objectID": "desen.html#ementa-de-disciplina-raciocínio-algorítmico",
    "href": "desen.html#ementa-de-disciplina-raciocínio-algorítmico",
    "title": "5  Projeto de Disciplina de Raciocínio Algorítmico",
    "section": "",
    "text": "5.1.1 OBJETIVOS\nObjetivo Geral: capacitar o estudante a aplicar o Raciocínio Algorítmico para resolver problemas complexos por meio da decomposição, abstração, algoritmização e depuração sistemática, desenvolvendo competências práticas através de módulos interativos e projetos aplicados.\nObjetivos Específicos:\n\ncompreender e aplicar os princípios fundamentais do Raciocínio Algorítmico através da Metodologia DAAD;\ndesenvolver habilidades de decomposição de problemas complexos em subproblemas gerenciáveis;\ncriar e interpretar fluxogramas seguindo uma versão simplificada para representação algorítmica;\nrepresentar algoritmos usando pseudocódigo;\nimplementar soluções computacionais utilizando linguagem C++ e Python;\naplicar técnicas de abstração na criação de componentes reutilizáveis e estruturas de dados;\nanalisar eficiência e complexidade de algoritmos fundamentais;\nutilizar técnicas sistemáticas de depuração e teste de software;\ndesenvolver projetos práticos aplicando metodologias de controle de versão;\n\nAo final da disciplina, os alunos deverão ser capazes de: decompor problemas computacionais complexos em subproblemas menores e gerenciáveis, identificando interfaces claras entre eles; identificar características essenciais e informações relevantes de um problema, criando modelos ou representações generalizadas, e aplicar múltiplos níveis de abstração para gerenciar a complexidade; projetar procedimentos passo a passo eficientes e corretos, algoritmos, para resolver problemas decompostos, e expressá-los usando pseudocódigo e uma linguagem de programação escolhida; identificar, localizar e corrigir sistematicamente erros em seus próprios códigos e nos de outros, empregando diversas estratégias de depuração e teste; aplicar a Metodologia DAAD de forma iterativa para resolver desafios computacionais e de engenharia novos, demonstrando pensamento analítico; trabalhar eficazmente em equipes em projetos de programação, utilizando ferramentas e práticas colaborativas; articular claramente definições de problemas, soluções algorítmicas e processos de depuração para públicos técnicos e não técnicos.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Projeto de Disciplina de Raciocínio Algorítmico</span>"
    ]
  },
  {
    "objectID": "desen.html#conteúdo-programático",
    "href": "desen.html#conteúdo-programático",
    "title": "5  Projeto de Disciplina de Raciocínio Algorítmico",
    "section": "5.2 CONTEÚDO PROGRAMÁTICO",
    "text": "5.2 CONTEÚDO PROGRAMÁTICO\nA organização modular da disciplina combina teoria e prática através de atividades presenciais dinâmicas e projetos aplicados. Cada módulo é projetado para reforçar os conceitos aprendidos por meio de: atividades unplugged na forma de exercícios e atividades realizadas sem uso de máquinas de processamento; laboratórios Práticos permitindo a implementação progressiva de fluxogramas para código C++; projetos aplicados incluindo o desenvolvimento de sistemas especialistas e soluções do mundo real. Usando uma metodologia progressiva na evolução gradual de atividades simples para complexas; e incentivando a prática da aprendizagem Colaborativa nas atividades em sala e no uso de repositórios públicos e controle de versão.\n\n\n\n\n[1] ETH ZÜRICH. Computational thinking., 2020. Disponível em: &lt;https://disco.ethz.ch/courses/hs20/coti/lecturenotes/script.pdf&gt;. Acesso em: 6 jul. 2025\n\n\n[2] IMPERIAL COLLEGE LONDON. Programme specification 2024-25: MEng computing. https://www.imperial.ac.uk/media/imperial-college/study/programme-specifications/computing/24x2f25/G401-MEng-Computing-2024-25.pdf, 2024. \n\n\n[3] STANFORD UNIVERSITY. CS106A syllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1258/syllabus&gt;\n\n\n[4] STANFORD UNIVERSITY. CS106B syllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/cs106b/syllabus&gt;\n\n\n[5] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information technology – Programming languages – C++. Geneva, Switzerland: International Organization for Standardization (ISO), 2020. Disponível em: &lt;https://isocpp.org/std/the-standard&gt;.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Projeto de Disciplina de Raciocínio Algorítmico</span>"
    ]
  },
  {
    "objectID": "desenv1.html",
    "href": "desenv1.html",
    "title": "6  Módulo 1: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição",
    "section": "",
    "text": "6.1 Atribuição, Condicional, Repetição\nEstas são as sugestões para atividades a serem realizadas no primeiro dia de aula, logo após a apresentação da disciplina. O professor deve escolher entre as atividades sugeridas aquelas que são adequadas ao seu perfil e as características da turma. Alternativamente, o professor pode usar suas próprias atividades, desde que elas possuam o mesmo grau de aderência às práticas da Metodologia DAAD.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>**Módulo 1**: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span>"
    ]
  },
  {
    "objectID": "desenv1.html#atribuição-condicional-repetição",
    "href": "desenv1.html#atribuição-condicional-repetição",
    "title": "6  Módulo 1: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição",
    "section": "",
    "text": "6.1.1 Atividades Unplugged: Decomposição e Abstração\nO importante é que o professor seja capaz de fazer atividades lúdicas que envolvam toda a turma na criação de listas de instruções para resolver tarefas simples, relacionadas com atividades cotidianas para criar os constructos cognitivos necessários ao entendimento da divisão de problemas grandes em problemas menores. Cada lista completa é, na verdade, um algoritmo. Ao final das tarefas, o professor deve enfatizar que a lista de tarefas é um algoritmo, e que cada tarefa é uma etapa do algoritmo.\nPara as duas tarefas sugeridas a seguir, o professor deve enfatizar que o objetivo é criar uma lista de tarefas que permita a qualquer pessoa, mesmo aquelas que nunca fizeram a tarefa, completá-la com sucesso.\n\nFazer um bolo / Fazer um sanduíche de presunto e queijo:\n\nNos dois casos, antes de começar a tarefa, o professor deve distribuir uma página com pautas contendo a receita do bolo ou do sanduíche. Divida a sala em grupos e forneça uma receita para cada aluno do grupo. A tarefa consiste em escrever, o mais detalhadamente possível, todas as instruções necessárias para que alguém que nunca fez um sanduíche ou um bolo possa fazê-lo. O professor deve enfatizar a importância de incluir todas as tarefas possíveis. Cada grupo deve entregar apenas uma lista de tarefas, contendo uma versão das listas criadas pelos integrantes do grupo.\nMaterial necessário: lápis e papel.\nEntrega: a entrega será a lista de tarefas, escritas à mão.\nAvaliação por Pares: o professor deve criar uma tabela com 10 notas no quadro em ordem descendente, embaralhar as listas, remover a relação grupo-lista, para que a avaliação seja anônima. Ler cada lista de tarefas destacando os pontos que não foram indicados. Por exemplo: é impossível colocar o queijo no pão sem pegar a fatia de queijo antes. Caberá ao professor destacar as instruções faltantes. Uma vez que a lista tenha sido lida, o professor irá pedir que os alunos levantem a mão para a nota que eles acham que o grupo merece, começando em 10, e marcar a nota que for mais votada. Finalmente, o professor deve separar a lista que tiver a maior nota. Esta lista será útil para explicar fluxogramas.\nObjetivo: entender o que é dividir um problema em problemas menores e enfatizar a necessidade de detalhamento. Trabalhar em grupo. Avaliação por pares.\n\nProgramar o Professor:\n\nNesta atividade, o professor é um autômato que só sabe ler e identificar símbolos gráficos e usar o teclado. Além disso, o professor tem acesso exclusivo aos seus segredos, como se fosse uma memória interna. Esta tarefa deve ser realizada com a participação de todos os alunos da sala de forma voluntária. A tarefa que será realizada deve ser uma tarefa simples, como enviar um e-mail para si mesmo.\nAntes de começar, o professor deve certificar-se de que seja possível operar o seu sistema operacional apenas com as teclas tab e enter para conseguir realizar a tarefa que será proposta. É importante que o professor não possa usar o mouse ou qualquer outro dispositivo de entrada para realizar a tarefa.\nEm sala, divida a turma em grupos e sugira que dois ou mais alunos de cada grupo anotem todas as instruções que foram realizadas com sucesso. Sucesso significa que a instrução foi bem construída, segue a sequência correta e foi executada sem erros.\nPara começar a atividade, explique os limites da capacidade do professor, compartilhe o desktop do seu computador sem nenhum aplicativo aberto. Informe qual aplicativo ou site será necessário para completar a tarefa e pare com as mãos no teclado. Neste ponto, a tarefa começou.\nO professor deve ter apenas duas reações: ou faz o que os alunos pediram ou fica parado e imóvel. Esta é uma tarefa lúdica que tem o potencial de provocar interesse e engajamento.\nAssim que a tarefa for concluída, o professor deve pedir que os alunos analisem as instruções escritas no seu grupo e verifiquem se elas estão corretas. Neste momento, o professor pode interagir com os grupos e fazer perguntas para guiá-los na análise. Guarde uma das listas de instruções para a definição de fluxogramas.\nMaterial necessário: lápis e papel.\nEntrega: lista de tarefas executadas criada pelos alunos.\nAvaliação: a avaliação das listas será feita apenas pelos grupos.\nObjetivo: mostrar os limites de entrada e saída de dados, os limites dos sistemas computacionais, a divisão de problemas em problemas menores.\n\n\n6.1.2 Atividades Unplugged Fluxogramas: Decomposição, Abstração, Algoritmização e Depuração\nApós as atividades lúdicas, o professor deve introduzir os conceitos de fluxogramas e estruturas de decisão e repetição. A ideia é que os alunos comecem criando fluxogramas para representar as tarefas realizadas nas atividades lúdicas.\n\nCriar fluxogramas para as instruções escritas pelos grupos:\n\nEsta é uma tarefa para a prática de criação de fluxogramas. Estas tarefas focam em Decomposição e Abstração. O professor deve propor problemas simples que podem ser resolvidos com fluxogramas, como calcular a média de três números, verificar se um número é par ou ímpar, ou encontrar o maior de três números. Os alunos devem criar fluxogramas para resolver esses problemas, praticando a decomposição e abstração.\nO professor irá apresentar o conceito de fluxogramas, utilizando uma adaptação dos módulos da ISO 5807:1985 (1), mostrando apenas os quatro módulos destacados na Figure 6.2. Cabe ao professor escolher se deve apresentar a ISO 5807:1985 (1) em mais detalhes, evidenciando a diferença entre o padrão completo e a versão reduzida a ser utilizada.\n\n\n\n\n\n\nFigure 6.2: Módulos de Fluxogramas que serão usados para resolver os problemas básicos de algoritmização. Adaptados do padrão ISO 5807:1985.\n\n\n\nO professor pode começar apresentando a ideia de fluxograma e os módulos que poderão ser utilizados para resolver as tarefas que ele irá apresentar. Para explicar os módulos, o professor pode usar uma das listas de atividades que resultaram das atividades da Section 6.1.1. Este é um bom momento para explicar que a lista de tarefas é um algoritmo, que cada tarefa corresponde a uma etapa do algoritmo, e aproveitar essa lista para criar o primeiro fluxograma.\nAs listas de instruções criadas pelos alunos para a solução das atividades geralmente não contêm módulos de decisão. Neste ponto, o professor pode escolher um problema diferente que inclua um módulo de decisão para explicar este processo. A explicação do módulo de decisão deve necessariamente incluir a ideia de que ele representa uma bifurcação do algoritmo, permitindo que o fluxo siga dois caminhos distintos, conforme a condição avaliada. Assim, há dois fluxos possíveis para a solução e para a execução. A tomada de decisão implica controle de fluxo, e o professor deve enfatizar que esse controle é parte essencial do Raciocínio Algorítmico e da construção de programas.\nDivida a turma em grupos e entregue uma página impressa com as tarefas para cada grupo. Ao contrário da primeira atividade, quando entregamos uma página em branco para cada aluno, nesta atividade certifique-se de entregar apenas uma lista de tarefas por grupo. Isso induz o convívio e o compartilhamento.\nFinalmente, o professor deve indicar que o sistema só consegue resolver problemas usando as regras da aritmética aplicando apenas operações binárias e unárias. Ou seja, para fazer a divisão do resultado de um produto, precisamos primeiro fazer o produto e depois dividir o resultado. O professor deve enfatizar que o sistema não consegue fazer operações de ordem superior, como calcular a média de três números, sem decompor o problema em subproblemas menores. O objetivo desta restrição é criar os constructos cognitivos necessários para que os alunos entendam a importância da decomposição de problemas, variáveis temporárias e controle de fluxo para a resolução de problemas.\nMaterial necessário: lápis, papel.\nEntrega: fluxogramas criados pelos alunos.\nApresentação e Avaliação: nesta tarefa, a avaliação consiste apenas na devolutiva da tarefa de forma coletiva e interativa no quadro. O professor pode escolher entre resolver apenas alguns problemas ou resolver todos os problemas no quadro. Além disso, o ritmo é importante. Avalie o resultado de acordo com o progresso da turma. Uma prática interessante é usar a Técnica da Sequência de Fibonacci para a apresentação da tarefa e devolutiva.\nPara usar a Técnica da Sequência de Fibonacci na aplicação de tarefa siga os seguintes passos:\n\natribua tempo para a solução de 1 problema, ao final deste tempo faça a devolutiva deste problema;\natribua tempo para a solução de 1 problema, ao final deste tempo faça a devolutiva deste problema;\natribua tempo para a solução de 2 problemas, ao final deste tempo faça a devolutiva destes 2 problemas;\natribua tempo para a solução de 3 problemas, ao final deste tempo faça a devolutiva destes 3 problemas;\natribua tempo para a solução de 5 problemas, ao final deste tempo faça a devolutiva destes 5 problemas;\n\nO tempo disponível para cada problema individual deve diminuir progressivamente. Assim, no último estágio, o tempo total para a solução dos 5 problemas propostos será igual ao tempo disponível para a solução do primeiro problema. A Figure 6.3 resume a Técnica da Sequência de Fibonacci.\n\n\n\n\n\n\nFigure 6.3\n\n\n\nSe escolher a Técnica da Sequência de Fibonacci para apresentação e devolutiva de atividades, o professor deverá escolher o número de problemas que serão resolvidos em cada etapa de acordo com o tamanho e o resultado da turma, mas deve se manter na Técnica da Sequência de Fibonacci. A devolutiva deve ser feita no quadro, e o professor deve explicar cada passo do algoritmo, enfatizando a importância da decomposição e controle de fluxo. A seguir está uma lista de problemas que podem ser usados para esta atividade:\nA. Elegibilidade para Eventos Cívicos: a Câmara Municipal de “Vila Nova” está organizando um evento cívico importante e precisa determinar rapidamente quais cidadãos são elegíveis para participar em atividades que exigem uma idade mínima de 16 anos. O Sr. João, responsável pelo registro, precisa de um sistema que, ao receber a idade de um cidadão, indique se este pode ou não participar nas atividades restritas. Crie o fluxograma de um sistema capaz de automatizar esta tarefa.\nAnálise:\n\n\n\n\n\n\nFigure 6.4: Resultado do Fluxograma de Elegibilidade para Eventos Cívicos.\n\n\n\nB. Controle de Sistema de Descontos: a empresa “Varejo Inteligente” está implementando um novo sistema de descontos automáticos para os seus clientes mais fiéis. Se o valor total da compra de um cliente for de pelo menos 100 Reais, ele recebe um desconto de 10% sobre o valor total. Caso contrário, não há desconto. A Dona Alice, gerente da loja, precisa de uma forma rápida de calcular o valor final a ser pago por um cliente, dado o valor inicial da sua compra. Crie o fluxograma do algoritmo de um sistema que, ao receber o valor_compra, determine o valor_final com base nesta política de descontos.\nAnálise: ::: {#fig-fluxEX2} \nResultado do Fluxograma de Controle de Sistema de Descontos. :::\nC. Análise de Dados Meteorológicos: no centro de meteorologia da cidade “Longe a Beça”, o Dr. Silva está analisando dados de temperatura. Ele precisa classificar as leituras de temperatura para identificar padrões climáticos. Dado um valor de temperatura (em graus Celsius), o Dr. Silva precisa saber se este valor representa uma temperatura positiva (acima de zero), negativa (abaixo de zero) ou se é exatamente zero graus. Crie um fluxograma para um sistema capaz de classificar estas temperaturas.\nAnálise: ::: {#fig-fluxEX3} \nResultado do Fluxograma de Análise de Dados Meteorológicos. :::\nD. Avaliação de Desempenho Acadêmico: a Professora Sofia precisa avaliar o desempenho dos seus alunos na disciplina de “Raciocínio Algorítmico”. Cada aluno realizará três avaliações, e a média aritmética desses testes determinará a sua aprovação. Para ser aprovado, a media_final deve ser igual ou superior a 7.0. Ajude a Professora Sofia a criar um algoritmo que, recebendo as três notas de um aluno, calcule a média e determine se o aluno foi “Aprovado” ou “Reprovado”.\nAnálise: ::: {#fig-fluxEX4} \nResultado do Fluxograma de Avaliação de Desempenho Acadêmico. :::\nE. Monitoramento de Condições Climáticas: a equipe de investigação do Ártico, liderada pela Dra. Anastácia, recolhe dados de temperatura em Celsius, mas precisa convertê-los para Fahrenheit a fim de comparar com dados históricos de outras estações. Além disso, para fins de segurança, é importante que seja emitido um alerta especial se a temperatura em Celsius for inferior a 0 graus. A fórmula de conversão é F = (C × 1,8) + 32. Crie um algoritmo, na forma de fluxograma, que realize esta conversão e emita o alerta quando necessário.\nAnálise: ::: {#fig-fluxEX5} \nResultado do Fluxograma de Monitoramento de Condições Climáticas. :::\nF. Calendário Empresarial: a empresa “Eventos Globais” planeja os seus eventos com base em um calendário anual decidido com 10 anos de antecedência. Para certos cálculos de prazos, é útil saber se um determinado ano é bissexto. Sabendo que um ano é bissexto se satisfizer as seguintes condições:\n\nO ano é divisível por 4: exemplo: 2024 é divisível por 4 (2024 / 4 = 506), então ele poderia ser bissexto.\nEXCETO se o ano for divisível por 100: exemplo: 1900 é divisível por 100 (1900 / 100 = 19), então ele não seria bissexto, apesar de ser divisível por 4.\nMAS, se o ano for divisível por 400, então ele é bissexto, mesmo que seja divisível por 100: exemplo: 2000 é divisível por 400 (2000 / 400 = 5), então ele é bissexto, mesmo sendo divisível por 100.\n\nAnálise:\n\n\n\n\n\n\nFigure 6.5: Resultado do Fluxograma de Calendário Empresarial.\n\n\n\nG. Sistema de Acesso a Recursos: a biblioteca universitária “Conhecimento Aberto” está testando um novo sistema de acesso online aos seus tomos. Para a fase de testes, existem um nome_usuário (“admin”) e uma senha (“123”) pré-definidos. O objetivo é que os usuários insiram suas credenciais e o sistema verifique se o login foi bem-sucedido ou falhou. Usando apenas o nome_usuário (“admin”) e a senha (“123”), desenvolva um algoritmo, na forma de fluxograma, que simule este processo de login.\nAnálise:\n\n\n\n\n\n\nFigure 6.6: Resultado do Fluxograma de Sistema de Acesso a Recursos.\n\n\n\nNo exercício G, termina a Sequência de Fibonacci de aplicação (1, 1, 2, 3). Neste ponto, o professor pode escolher entre continuar a Sequência de Fibonacci, oferecendo 5 exercícios, sem alteração de conteúdo ou introduzir os conceitos de pseudocódigo e tabelas de rastreio. Se optar por esta abordagem, explique os conceitos de depuração e o uso das tabelas de rastreio usando o ao exercício F e solicite que os alunos apliquem estas mesmas técnicas ao exercício G.\nPara o exercício F, Análise: o pseudocódigo poderia ser:\nALGORITMO VerificarAnoBissexto\n\nENTRADA:\n    ano: inteiro\n\nSAÍDA:\n    ehBissexto: booleano\n\nINÍCIO\n    SE (ano % 400 == 0) ENTÃO\n        ehBissexto ← VERDADEIRO\n    SENÃO SE (ano % 100 == 0) ENTÃO\n        ehBissexto ← FALSO\n    SENÃO SE (ano % 4 == 0) ENTÃO\n        ehBissexto ← VERDADEIRO\n    SENÃO\n        ehBissexto ← FALSO\n    FIM SE\n    \n    RETORNAR ehBissexto\nFIM\nFinalmente, esta é uma oportunidade de discutir tanto a legibilidade do pseudocódigo quanto seu uso para testes e depuração. Neste caso, o professor pode sugerir os seguintes anos para validação do algoritmo: 2024, 1900, 2000, 2023. O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses anos usando as Tabelas de Rastreio.\n\n\n\nTable 6.1: Teste 1: Ano 2024: resultado: 2024 é bissexto\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nehBissexto\nPróximo Passo\n\n\n\n\nENTRADA\nano ← 2024\n-\nindefinido\nLinha SE\n\n\nSE\nano % 400 == 0\n2024 % 400 = 24 ≠ 0 → FALSO\nindefinido\nSENÃO SE (linha 2)\n\n\nSENÃO SE\nano % 100 == 0\n2024 % 100 = 24 ≠ 0 → FALSO\nindefinido\nSENÃO SE (linha 3)\n\n\nSENÃO SE\nano % 4 == 0\n2024 % 4 = 0 → VERDADEIRO\nVERDADEIRO\nFIM SE\n\n\nRETORNAR\nehBissexto\n-\nVERDADEIRO\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.2: Teste 2: Ano 1900: resultado: 1900 não é bissexto\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nehBissexto\nPróximo Passo\n\n\n\n\nENTRADA\nano ← 1900\n-\nindefinido\nLinha SE\n\n\nSE\nano % 400 == 0\n1900 % 400 = 300 ≠ 0 → FALSO\nindefinido\nSENÃO SE (linha 2)\n\n\nSENÃO SE\nano % 100 == 0\n1900 % 100 = 0 → VERDADEIRO\nFALSO\nFIM SE\n\n\nRETORNAR\nehBissexto\n-\nFALSO\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.3: Teste 3: Ano 2000: resultado: 2000 é bissexto\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nehBissexto\nPróximo Passo\n\n\n\n\nENTRADA\nano ← 2000\n-\nindefinido\nLinha SE\n\n\nSE\nano % 400 == 0\n2000 % 400 = 0 → VERDADEIRO\nVERDADEIRO\nFIM SE\n\n\nRETORNAR\nehBissexto\n-\nVERDADEIRO\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.4: Teste 4: Ano 2023: resultado: 2023 não é bissexto\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nehBissexto\nPróximo Passo\n\n\n\n\nENTRADA\nano ← 2023\n-\nindefinido\nLinha SE\n\n\nSE\nano % 400 == 0\n2023 % 400 = 23 ≠ 0 → FALSO\nindefinido\nSENÃO SE (linha 2)\n\n\nSENÃO SE\nano % 100 == 0\n2023 % 100 = 23 ≠ 0 → FALSO\nindefinido\nSENÃO SE (linha 3)\n\n\nSENÃO SE\nano % 4 == 0\n2023 % 4 = 3 ≠ 0 → FALSO\nindefinido\nSENÃO\n\n\nSENÃO\nehBissexto ← FALSO\n-\nFALSO\nFIM SE\n\n\nRETORNAR\nehBissexto\n-\nFALSO\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.5: Resumo: 2024 e 2000 são bissextos, enquanto 1900 e 2023 não são bissextos\n\n\n\n\n\n\n\n\n\n\n\n\nAno\nDivisível por 4\nDivisível por 100\nDivisível por 400\nÉ Bissexto\n\n\n\n\n2024\nSim\nNão\nNão\nSim\n\n\n1900\nSim\nSim\nNão\nNão\n\n\n2000\nSim\nSim\nSim\nSim\n\n\n2023\nNão\nNão\nNão\nNão\n\n\n\n\n\n\nEm seguida, o professor pode apresentar uma versão mais próxima das linguagens de programação, como C++ ou Python, para que os alunos vejam a transição do pseudocódigo para o código real.\nALGORITMO VerificarAnoBissexto\n\nENTRADA:\n    ano: inteiro\n\nSAÍDA:\n    ehBissexto: booleano\n\nINÍCIO\n    ehBissexto ← ((ano % 4 == 0) E (ano % 100 != 0)) OU (ano % 400 == 0)\n    RETORNAR ehBissexto\nFIM\nPara o exercício G, Análise: o pseudocódigo poderia ser:\nALGORITMO SistemaLogin\n\nCONSTANTES:\n    USUARIO_VALIDO ← \"admin\"\n    SENHA_VALIDA ← \"123\"\n\nENTRADA:\n    nomeUsuário: texto\n    senha: texto\n\nSAÍDA:\n    loginSucesso: booleano\n\nINÍCIO\n    ESCREVER \"Digite o nome de Usuário:\"\n    LER nomeUsuário\n    ESCREVER \"Digite a senha:\"\n    LER senha\n    \n    SE (nomeUsuário == USUARIO_VALIDO) E (senha == SENHA_VALIDA) ENTÃO\n        loginSucesso ← VERDADEIRO\n        ESCREVER \"Login bem-sucedido! Acesso autorizado.\"\n    SENÃO\n        loginSucesso ← FALSO\n        ESCREVER \"Login falhado! Credenciais inválidas.\"\n    FIM SE\n    \n    RETORNAR loginSucesso\nFIM\nNeste caso, o professor pode sugerir os seguintes casos para validação do algoritmo: credenciais corretas (admin/123), nome correto com senha errada (admin/456), nome errado com senha correta (user/123), e ambas credenciais erradas (user/456). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\n\n\n\nTable 6.6: Teste 1: Credenciais corretas (admin/123): resultado: login bem-sucedido\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nloginSucesso\nPróximo Passo\n\n\n\n\nENTRADA\nnomeUsuário ← “admin”, senha ← “123”\n-\nindefinido\nLinha SE\n\n\nSE\n(nomeUsuário == “admin”) E (senha == “123”)\n(“admin” == “admin”) E (“123” == “123”) → VERDADEIRO E VERDADEIRO → VERDADEIRO\nVERDADEIRO\nLinha loginSucesso\n\n\nloginSucesso\nloginSucesso ← VERDADEIRO\n-\nVERDADEIRO\nESCREVER\n\n\nESCREVER\n“Login bem-sucedido! Acesso autorizado.”\n-\nVERDADEIRO\nFIM SE\n\n\nRETORNAR\nloginSucesso\n-\nVERDADEIRO\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.7: Teste 2: Nome correto, senha errada (admin/456): resultado: login falhado\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nloginSucesso\nPróximo Passo\n\n\n\n\nENTRADA\nnomeUsuário ← “admin”, senha ← “456”\n-\nindefinido\nLinha SE\n\n\nSE\n(nomeUsuário == “admin”) E (senha == “123”)\n(“admin” == “admin”) E (“456” == “123”) → VERDADEIRO E FALSO → FALSO\nindefinido\nSENÃO\n\n\nSENÃO\nloginSucesso ← FALSO\n-\nFALSO\nESCREVER\n\n\nESCREVER\n“Login falhado! Credenciais inválidas.”\n-\nFALSO\nFIM SE\n\n\nRETORNAR\nloginSucesso\n-\nFALSO\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.8: Teste 3: Nome errado, senha correta (user/123): resultado: login falhado\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nloginSucesso\nPróximo Passo\n\n\n\n\nENTRADA\nnomeUsuário ← “user”, senha ← “123”\n-\nindefinido\nLinha SE\n\n\nSE\n(nomeUsuário == “admin”) E (senha == “123”)\n(“user” == “admin”) E (“123” == “123”) → FALSO E VERDADEIRO → FALSO\nindefinido\nSENÃO\n\n\nSENÃO\nloginSucesso ← FALSO\n-\nFALSO\nESCREVER\n\n\nESCREVER\n“Login falhado! Credenciais inválidas.”\n-\nFALSO\nFIM SE\n\n\nRETORNAR\nloginSucesso\n-\nFALSO\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.9: Teste 4: Ambas credenciais erradas (user/456): resultado: login falhado\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nloginSucesso\nPróximo Passo\n\n\n\n\nENTRADA\nnomeUsuário ← “user”, senha ← “456”\n-\nindefinido\nLinha SE\n\n\nSE\n(nomeUsuário == “admin”) E (senha == “123”)\n(“user” == “admin”) E (“456” == “123”) → FALSO E FALSO → FALSO\nindefinido\nSENÃO\n\n\nSENÃO\nloginSucesso ← FALSO\n-\nFALSO\nESCREVER\n\n\nESCREVER\n“Login falhado! Credenciais inválidas.”\n-\nFALSO\nFIM SE\n\n\nRETORNAR\nloginSucesso\n-\nFALSO\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.10: Resumo: apenas o caso com credenciais corretas (admin/123) resulta em login bem-sucedido\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nNome Usuário\nSenha\nNome Válido\nSenha Válida\nLogin Sucesso\n\n\n\n\nCredenciais corretas\nadmin\n123\nSim\nSim\nSim\n\n\nNome correto, senha errada\nadmin\n456\nSim\nNão\nNão\n\n\nNome errado, senha correta\nuser\n123\nNão\nSim\nNão\n\n\nAmbas credenciais erradas\nuser\n456\nNão\nNão\nNão\n\n\n\n\n\n\nEm seguida, o professor pode apresentar uma versão mais próxima das linguagens de programação, como C++ ou Python, para que os alunos vejam a transição do pseudocódigo para o código real.\nALGORITMO SistemaLoginConciso\n\nCONSTANTES:\n    USUARIO_VALIDO ← \"admin\"\n    SENHA_VALIDA ← \"123\"\n\nENTRADA:\n    nomeUsuário: texto\n    senha: texto\n\nSAÍDA:\n    loginSucesso: booleano\n\nINÍCIO\n    LER nomeUsuário, senha\n    loginSucesso ← (nomeUsuário == USUARIO_VALIDO) E (senha == SENHA_VALIDA)\n    RETORNAR loginSucesso\nFIM\nDeste ponto em diante, o professor pode começar uma nova Sequência de Fibonacci, introduzindo exercícios mais complexos que envolvam estruturas de repetição e funções. A seguir estão alguns exemplos de exercícios que podem ser usados para continuar a prática de fluxogramas, pseudocódigo e tabelas de rastreio. Para estes exercícios caberá aos alunos escolher se usarão fluxogramas, pseudocódigo, mas devem usar as tabelas de rastreio:\nH. Avaliação de Saúde Ocupacional: em uma clínica de saúde ocupacional, a enfermeira Joana Mãoleve realiza avaliações de rotina, incluindo o cálculo do Índice de Massa Corporal (IMC) dos funcionários. O IMC é calculado pela fórmula \\(IMC = \\frac{peso}{altura \\times altura}\\), na qual o peso é em quilogramas e a altura em metros. Após o cálculo, o IMC é classificado para indicar o estado nutricional. Ajude a enfermeira Joana Mãoleve a criar um algoritmo, na forma de fluxograma, que, dados o peso e a altura de um funcionário, calcule o IMC e o classifique como:\n\nMenor que 18.5: “Abaixo do peso”\nEntre 18.5 e 24.9: “Peso normal”\nEntre 25 e 29.9: “Sobrepeso”\n30 ou mais: “Obesidade”\n\n\n\n\n\n\n\nFigure 6.7: Resultado do Fluxograma de Avaliação de Saúde Ocupacional.\n\n\n\nO pseudocódigo poderia ser:\nALGORITMO AvaliacaoIMC\n\nENTRADA:\n    peso: real\n    altura: real\n\nSAÍDA:\n    imc: real\n    classificacao: texto\n\nINÍCIO\n    ESCREVER \"Digite o peso (kg):\"\n    LER peso\n    ESCREVER \"Digite a altura (m):\"\n    LER altura\n    \n    imc ← peso / (altura * altura)\n    \n    SE (imc &lt; 18.5) ENTÃO\n        classificacao ← \"Abaixo do peso\"\n    SENÃO SE (imc &gt;= 18.5) E (imc &lt;= 24.9) ENTÃO\n        classificacao ← \"Peso normal\"\n    SENÃO SE (imc &gt;= 25.0) E (imc &lt;= 29.9) ENTÃO\n        classificacao ← \"Sobrepeso\"\n    SENÃO\n        classificacao ← \"Obesidade\"\n    FIM SE\n    \n    ESCREVER \"IMC: \", imc\n    ESCREVER \"Classificação: \", classificacao\n    \n    RETORNAR imc, classificacao\nFIM\nNeste caso, o professor pode sugerir os seguintes casos para validação do algoritmo: pessoa com baixo peso (45kg, 1.70m), peso normal (70kg, 1.75m), sobrepeso (80kg, 1.70m), e obesidade (100kg, 1.70m). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\n\n\n\nTable 6.11: Teste 1: Baixo peso (45kg, 1.70m): resultado: IMC 15.57 - Abaixo do peso\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nimc\nclassificacao\nPróximo Passo\n\n\n\n\nENTRADA\npeso ← 45, altura ← 1.70\n-\nindefinido\nindefinido\nCálculo IMC\n\n\nimc\nimc ← 45 / (1.70 * 1.70)\n45 / 2.89 = 15.57\n15.57\nindefinido\nLinha SE\n\n\nSE\nimc &lt; 18.5\n15.57 &lt; 18.5 → VERDADEIRO\n15.57\n“Abaixo do peso”\nFIM SE\n\n\nESCREVER\n“IMC: 15.57”\n-\n15.57\n“Abaixo do peso”\nESCREVER\n\n\nESCREVER\n“Classificação: Abaixo do peso”\n-\n15.57\n“Abaixo do peso”\nRETORNAR\n\n\nRETORNAR\nimc, classificacao\n-\n15.57\n“Abaixo do peso”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.12: Teste 2: Peso normal (70kg, 1.75m): resultado: IMC 22.86 - Peso normal\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nimc\nclassificacao\nPróximo Passo\n\n\n\n\nENTRADA\npeso ← 70, altura ← 1.75\n-\nindefinido\nindefinido\nCálculo IMC\n\n\nimc\nimc ← 70 / (1.75 * 1.75)\n70 / 3.0625 = 22.86\n22.86\nindefinido\nLinha SE\n\n\nSE\nimc &lt; 18.5\n22.86 &lt; 18.5 → FALSO\n22.86\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(imc &gt;= 18.5) E (imc &lt;= 24.9)\n(22.86 &gt;= 18.5) E (22.86 &lt;= 24.9) → VERDADEIRO E VERDADEIRO → VERDADEIRO\n22.86\n“Peso normal”\nFIM SE\n\n\nESCREVER\n“IMC: 22.86”\n-\n22.86\n“Peso normal”\nESCREVER\n\n\nESCREVER\n“Classificação: Peso normal”\n-\n22.86\n“Peso normal”\nRETORNAR\n\n\nRETORNAR\nimc, classificacao\n-\n22.86\n“Peso normal”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.13: Teste 3: Sobrepeso (80kg, 1.70m): resultado: IMC 27.68 - Sobrepeso\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nimc\nclassificacao\nPróximo Passo\n\n\n\n\nENTRADA\npeso ← 80, altura ← 1.70\n-\nindefinido\nindefinido\nCálculo IMC\n\n\nimc\nimc ← 80 / (1.70 * 1.70)\n80 / 2.89 = 27.68\n27.68\nindefinido\nLinha SE\n\n\nSE\nimc &lt; 18.5\n27.68 &lt; 18.5 → FALSO\n27.68\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(imc &gt;= 18.5) E (imc &lt;= 24.9)\n(27.68 &gt;= 18.5) E (27.68 &lt;= 24.9) → VERDADEIRO E FALSO → FALSO\n27.68\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(imc &gt;= 25.0) E (imc &lt;= 29.9)\n(27.68 &gt;= 25.0) E (27.68 &lt;= 29.9) → VERDADEIRO E VERDADEIRO → VERDADEIRO\n27.68\n“Sobrepeso”\nFIM SE\n\n\nESCREVER\n“IMC: 27.68”\n-\n27.68\n“Sobrepeso”\nESCREVER\n\n\nESCREVER\n“Classificação: Sobrepeso”\n-\n27.68\n“Sobrepeso”\nRETORNAR\n\n\nRETORNAR\nimc, classificacao\n-\n27.68\n“Sobrepeso”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.14: Teste 4: Obesidade (100kg, 1.70m): resultado: IMC 34.60 - Obesidade\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nimc\nclassificacao\nPróximo Passo\n\n\n\n\nENTRADA\npeso ← 100, altura ← 1.70\n-\nindefinido\nindefinido\nCálculo IMC\n\n\nimc\nimc ← 100 / (1.70 * 1.70)\n100 / 2.89 = 34.60\n34.60\nindefinido\nLinha SE\n\n\nSE\nimc &lt; 18.5\n34.60 &lt; 18.5 → FALSO\n34.60\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(imc &gt;= 18.5) E (imc &lt;= 24.9)\n(34.60 &gt;= 18.5) E (34.60 &lt;= 24.9) → VERDADEIRO E FALSO → FALSO\n34.60\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(imc &gt;= 25.0) E (imc &lt;= 29.9)\n(34.60 &gt;= 25.0) E (34.60 &lt;= 29.9) → VERDADEIRO E FALSO → FALSO\n34.60\nindefinido\nSENÃO\n\n\nSENÃO\nclassificacao ← “Obesidade”\n-\n34.60\n“Obesidade”\nFIM SE\n\n\nESCREVER\n“IMC: 34.60”\n-\n34.60\n“Obesidade”\nESCREVER\n\n\nESCREVER\n“Classificação: Obesidade”\n-\n34.60\n“Obesidade”\nRETORNAR\n\n\nRETORNAR\nimc, classificacao\n-\n34.60\n“Obesidade”\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.15: Resumo: algoritmo classifica corretamente todas as faixas de IMC conforme especificação médica\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nPeso (kg)\nAltura (m)\nIMC Calculado\nFaixa IMC\nClassificação\n\n\n\n\nBaixo peso\n45\n1.70\n15.57\n&lt; 18.5\nAbaixo do peso\n\n\nPeso normal\n70\n1.75\n22.86\n18.5-24.9\nPeso normal\n\n\nSobrepeso\n80\n1.70\n27.68\n25.0-29.9\nSobrepeso\n\n\nObesidade\n100\n1.70\n34.60\n≥ 30.0\nObesidade\n\n\n\n\n\n\nEm seguida, o professor pode apresentar uma versão mais próxima das linguagens de programação, como C++ ou Python, para que os alunos vejam a transição do pseudocódigo para o código real.\nALGORITMO AvaliacaoIMCConciso\n\nENTRADA:\n    peso: real\n    altura: real\n\nSAÍDA:\n    imc: real\n    classificacao: texto\n\nINÍCIO\n    LER peso, altura\n    imc ← peso / (altura * altura)\n    \n    SE (imc &lt; 18.5) ENTÃO classificacao ← \"Abaixo do peso\"\n    SENÃO SE (imc &lt;= 24.9) ENTÃO classificacao ← \"Peso normal\"  \n    SENÃO SE (imc &lt;= 29.9) ENTÃO classificacao ← \"Sobrepeso\"\n    SENÃO classificacao ← \"Obesidade\"\n    \n    RETORNAR imc, classificacao\nFIM\nI. Sistema de Avaliação de Crédito Bancário: no banco “Futuro Seguro”, o analista Roberto precisa automatizar a aprovação de empréstimos pessoais. O sistema deve considerar múltiplos critérios: renda_mensal, idade, score_credito e tempo_emprego (em anos). As regras são: (1) Renda mínima de 2000 reais; (2) Idade entre 21 e 65 anos; (3) Score de crédito de pelo menos 600; (4) Tempo de emprego de pelo menos 2 anos. Se todos os critérios forem atendidos, calcular o valor_maximo_emprestimo como renda_mensal × 10. Se o score for maior que 750, aplicar bônus de 20% no valor máximo. Se algum critério não for atendido, negar o empréstimo. Crie um fluxograma que implemente este sistema de avaliação.\nAnálise: o pseudocódigo poderia ser:\nALGORITMO AvaliacaoCreditoBancario\n\nENTRADA:\n    rendaMensal: real\n    idade: inteiro\n    scoreCredito: inteiro\n    tempoEmprego: real\n\nSAÍDA:\n    aprovado: booleano\n    valorMaximoEmprestimo: real\n    motivoRejeicao: texto\n\nINÍCIO\n    ESCREVER \"Digite a renda mensal:\"\n    LER rendaMensal\n    ESCREVER \"Digite a idade:\"\n    LER idade\n    ESCREVER \"Digite o score de crédito:\"\n    LER scoreCredito\n    ESCREVER \"Digite o tempo de emprego (anos):\"\n    LER tempoEmprego\n    \n    aprovado ← VERDADEIRO\n    motivoRejeicao ← \"\"\n    valorMaximoEmprestimo ← 0\n    \n    // Verificar critério 1: Renda mínima de 2000 reais\n    SE (rendaMensal &lt; 2000) ENTÃO\n        aprovado ← FALSO\n        motivoRejeicao ← motivoRejeicao + \"Renda insuficiente (mín. R$ 2000); \"\n    FIM SE\n    \n    // Verificar critério 2: Idade entre 21 e 65 anos\n    SE (idade &lt; 21) OU (idade &gt; 65) ENTÃO\n        aprovado ← FALSO\n        motivoRejeicao ← motivoRejeicao + \"Idade fora da faixa permitida (21-65 anos); \"\n    FIM SE\n    \n    // Verificar critério 3: Score de crédito de pelo menos 600\n    SE (scoreCredito &lt; 600) ENTÃO\n        aprovado ← FALSO\n        motivoRejeicao ← motivoRejeicao + \"Score de crédito insuficiente (mín. 600); \"\n    FIM SE\n    \n    // Verificar critério 4: Tempo de emprego de pelo menos 2 anos\n    SE (tempoEmprego &lt; 2) ENTÃO\n        aprovado ← FALSO\n        motivoRejeicao ← motivoRejeicao + \"Tempo de emprego insuficiente (mín. 2 anos); \"\n    FIM SE\n    \n    // Se todos os critérios forem atendidos, calcular valor máximo\n    SE (aprovado == VERDADEIRO) ENTÃO\n        valorMaximoEmprestimo ← rendaMensal * 10\n        \n        // Verificar bônus para score &gt; 750\n        SE (scoreCredito &gt; 750) ENTÃO\n            valorMaximoEmprestimo ← valorMaximoEmprestimo * 1.2\n            ESCREVER \"Bônus de 20% aplicado devido ao excelente score de crédito!\"\n        FIM SE\n        \n        ESCREVER \"Empréstimo APROVADO!\"\n        ESCREVER \"Valor máximo disponível: R$ \", valorMaximoEmprestimo\n    SENÃO\n        ESCREVER \"Empréstimo NEGADO!\"\n        ESCREVER \"Motivos: \", motivoRejeicao\n    FIM SE\n    \n    RETORNAR aprovado, valorMaximoEmprestimo, motivoRejeicao\nFIM\nNeste caso, o professor pode sugerir os seguintes casos para validação do algoritmo: cliente aprovado sem bônus (R$ 5000 renda, 35 anos, score 700, 5 anos emprego), cliente aprovado com bônus (R$ 8000 renda, 28 anos, score 800, 3 anos emprego), negação por renda baixa (R$ 1500 renda, 30 anos, score 650, 3 anos emprego), e negação por múltiplos critérios (R$ 1800 renda, 19 anos, score 550, 1 ano emprego). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\n\n\n\nTable 6.16: Teste 1: Aprovação sem bônus (5000 renda, 35 anos, score 700): resultado: Aprovado - R$ 50.000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\naprovado\nvalorMaximoEmprestimo\nmotivoRejeicao\nPróximo Passo\n\n\n\n\nENTRADA\nrenda ← 5000, idade ← 35, score ← 700, tempo ← 5\n-\nVERDADEIRO\n0\n“”\nVerificar renda\n\n\nSE renda\nrendaMensal &lt; 2000 → 5000 &lt; 2000 → FALSO\n-\nVERDADEIRO\n0\n“”\nVerificar idade\n\n\nSE idade\n(idade &lt; 21) OU (idade &gt; 65) → (35 &lt; 21) OU (35 &gt; 65) → FALSO OU FALSO → FALSO\n-\nVERDADEIRO\n0\n“”\nVerificar score\n\n\nSE score\nscoreCredito &lt; 600 → 700 &lt; 600 → FALSO\n-\nVERDADEIRO\n0\n“”\nVerificar tempo\n\n\nSE tempo\ntempoEmprego &lt; 2 → 5 &lt; 2 → FALSO\n-\nVERDADEIRO\n0\n“”\nCalcular valor\n\n\nSE aprovado\naprovado == VERDADEIRO → VERDADEIRO\nvalorMaximoEmprestimo = 5000 * 10 = 50000\nVERDADEIRO\n50000\n“”\nVerificar bônus\n\n\nSE bônus\nscoreCredito &gt; 750 → 700 &gt; 750 → FALSO\n-\nVERDADEIRO\n50000\n“”\nESCREVER\n\n\nRETORNAR\naprovado, valorMaximoEmprestimo, motivoRejeicao\n-\nVERDADEIRO\n50000\n“”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.17: Teste 2: Aprovação com bônus (8000 renda, 28 anos, score 800): resultado: Aprovado - R$ 96.000 com bônus\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\naprovado\nvalorMaximoEmprestimo\nmotivoRejeicao\nPróximo Passo\n\n\n\n\nENTRADA\nrenda ← 8000, idade ← 28, score ← 800, tempo ← 3\n-\nVERDADEIRO\n0\n“”\nVerificar critérios\n\n\nVerificações\nTodas as condições (renda ≥ 2000, idade 21-65, score ≥ 600, tempo ≥ 2) são atendidas\n-\nVERDADEIRO\n0\n“”\nCalcular valor\n\n\nSE aprovado\naprovado == VERDADEIRO → VERDADEIRO\nvalorMaximoEmprestimo = 8000 * 10 = 80000\nVERDADEIRO\n80000\n“”\nVerificar bônus\n\n\nSE bônus\nscoreCredito &gt; 750 → 800 &gt; 750 → VERDADEIRO\nvalorMaximoEmprestimo = 80000 * 1.2 = 96000\nVERDADEIRO\n96000\n“”\nESCREVER\n\n\nESCREVER\n“Bônus de 20% aplicado…”\n-\nVERDADEIRO\n96000\n“”\nESCREVER\n\n\nRETORNAR\naprovado, valorMaximoEmprestimo, motivoRejeicao\n-\nVERDADEIRO\n96000\n“”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.18: Teste 3: Negação por renda baixa (1500 renda): resultado: Negado - Renda insuficiente\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\naprovado\nvalorMaximoEmprestimo\nmotivoRejeicao\nPróximo Passo\n\n\n\n\nENTRADA\nrenda ← 1500, idade ← 30, score ← 650, tempo ← 3\n-\nVERDADEIRO\n0\n“”\nVerificar renda\n\n\nSE renda\nrendaMensal &lt; 2000 → 1500 &lt; 2000 → VERDADEIRO\naprovado ← FALSO, motivoRejeicao ← “Renda insuficiente (mín. R$ 2000);”\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nVerificar idade\n\n\nSE idade\n(30 &lt; 21) OU (30 &gt; 65) → FALSO OU FALSO → FALSO\n-\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nVerificar score\n\n\nSE score\n650 &lt; 600 → FALSO\n-\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nVerificar tempo\n\n\nSE tempo\n3 &lt; 2 → FALSO\n-\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nVerificar aprovação\n\n\nSE aprovado\naprovado == VERDADEIRO → FALSO == VERDADEIRO → FALSO\n-\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nSENÃO\n\n\nSENÃO\nESCREVER “Empréstimo NEGADO!”\n-\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nRETORNAR\n\n\nRETORNAR\naprovado, valorMaximoEmprestimo, motivoRejeicao\n-\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.19: Teste 4: Negação por múltiplos critérios (todos critérios falham): resultado: Negado - Múltiplos motivos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\naprovado\nvalorMaximoEmprestimo\nmotivoRejeicao\nPróximo Passo\n\n\n\n\nENTRADA\nrenda ← 1800, idade ← 19, score ← 550, tempo ← 1\n-\nVERDADEIRO\n0\n“”\nVerificar critérios\n\n\nSE renda\n1800 &lt; 2000 → VERDADEIRO\naprovado ← FALSO, motivoRejeicao ← “Renda insuficiente (mín. R$ 2000);”\nFALSO\n0\n“Renda insuficiente (mín. R$ 2000);”\nVerificar idade\n\n\nSE idade\n(19 &lt; 21) OU (19 &gt; 65) → VERDADEIRO OU FALSO → VERDADEIRO\nmotivoRejeicao ← “…Idade fora da faixa permitida (21-65 anos);”\nFALSO\n0\n“Renda insuficiente…; Idade fora da faixa…;”\nVerificar score\n\n\nSE score\n550 &lt; 600 → VERDADEIRO\nmotivoRejeicao ← “…Score de crédito insuficiente (mín. 600);”\nFALSO\n0\n“…Score insuficiente…;”\nVerificar tempo\n\n\nSE tempo\n1 &lt; 2 → VERDADEIRO\nmotivoRejeicao ← “…Tempo de emprego insuficiente (mín. 2 anos);”\nFALSO\n0\n“…Tempo insuficiente…;”\nVerificar aprovação\n\n\nSE aprovado\nFALSO == VERDADEIRO → FALSO\n-\nFALSO\n0\n“Múltiplos motivos de rejeição”\nSENÃO\n\n\nRETORNAR\naprovado, valorMaximoEmprestimo, motivoRejeicao\n-\nFALSO\n0\n“Múltiplos motivos”\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.20: Resumo: algoritmo avalia corretamente todos os critérios bancários e aplica bônus para clientes premium\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nRenda\nIdade\nScore\nTempo Emp.\nCritérios Atendidos\nValor Base\nBônus\nValor Final\nStatus\n\n\n\n\nAprovação básica\n5000\n35\n700\n5\nTodos (4/4)\nR$ 50.000\nNão\nR$ 50.000\nAprovado\n\n\nAprovação c/ bônus\n8000\n28\n800\n3\nTodos (4/4)\nR$ 80.000\nSim (+20%)\nR$ 96.000\nAprovado\n\n\nRenda baixa\n1500\n30\n650\n3\n3/4 (renda falha)\n-\n-\nR$ 0\nNegado\n\n\nMúltiplos problemas\n1800\n19\n550\n1\n0/4 (todos falham)\n-\n-\nR$ 0\nNegado\n\n\n\n\n\n\nA versão mais próxima:\nALGORITMO AvaliacaoCreditoBancarioConciso\n\nENTRADA:\n    rendaMensal, idade, scoreCredito, tempoEmprego: numerico\n\nSAÍDA:\n    aprovado: booleano\n    valorMaximoEmprestimo: real\n\nINÍCIO\n    LER rendaMensal, idade, scoreCredito, tempoEmprego\n    \n    aprovado ← (rendaMensal &gt;= 2000) E (idade &gt;= 21 E idade &lt;= 65) E \n               (scoreCredito &gt;= 600) E (tempoEmprego &gt;= 2)\n    \n    SE aprovado ENTÃO\n        valorMaximoEmprestimo ← rendaMensal * 10\n        SE (scoreCredito &gt; 750) ENTÃO\n            valorMaximoEmprestimo ← valorMaximoEmprestimo * 1.2\n        valorMaximoEmprestimo ← valorMaximoEmprestimo\n    SENÃO\n        valorMaximoEmprestimo ← 0\n    \n    RETORNAR aprovado, valorMaximoEmprestimo\nFIM\nJ. Classificação de Emergências Hospitalares: no Hospital “Santa Esperança”, a enfermeira Carla utiliza o protocolo de Manchester para classificar a urgência dos pacientes. O sistema recebe temperatura, pressao_sistolica, frequencia_cardiaca, nivel_dor (escala 0-10) e idade. As classificações são: Emergência (vermelho): temperatura &gt; 39°C OU pressão &lt; 90 OU &gt; 180 OU frequência &lt; 50 OU &gt; 120; Muito Urgente (laranja): temperatura entre 38-39°C OU pressão entre 90-100 OU 160-180 OU dor &gt; 7; Urgente (amarelo): temperatura entre 37.5-38°C OU dor entre 4-7 OU idade &gt; 65 anos; Pouco Urgente (verde): demais casos. Se múltiplas condições se aplicarem, usar a classificação mais alta. Desenvolva o algoritmo para esta triagem.\nAnálise: o pseudocódigo poderia ser:\nALGORITMO ClassificacaoEmergencia\n\nENTRADA:\n    temperatura: real\n    pressaoSistolica: inteiro\n    frequenciaCardiaca: inteiro\n    nivelDor: inteiro\n    idade: inteiro\n\nSAÍDA:\n    classificacao: texto\n    cor: texto\n\nINÍCIO\n    ESCREVER \"Digite a temperatura (°C):\"\n    LER temperatura\n    ESCREVER \"Digite a pressão sistólica:\"\n    LER pressaoSistolica\n    ESCREVER \"Digite a frequência cardíaca:\"\n    LER frequenciaCardiaca\n    ESCREVER \"Digite o nível de dor (0-10):\"\n    LER nivelDor\n    ESCREVER \"Digite a idade:\"\n    LER idade\n    \n    // Verificar Emergência (vermelho) - prioridade máxima\n    SE (temperatura &gt; 39) OU (pressaoSistolica &lt; 90) OU (pressaoSistolica &gt; 180) OU \n       (frequenciaCardiaca &lt; 50) OU (frequenciaCardiaca &gt; 120) ENTÃO\n        classificacao ← \"Emergência\"\n        cor ← \"vermelho\"\n    // Verificar Muito Urgente (laranja)\n    SENÃO SE (temperatura &gt;= 38 E temperatura &lt;= 39) OU \n             (pressaoSistolica &gt;= 90 E pressaoSistolica &lt;= 100) OU\n             (pressaoSistolica &gt;= 160 E pressaoSistolica &lt;= 180) OU\n             (nivelDor &gt; 7) ENTÃO\n        classificacao ← \"Muito Urgente\"\n        cor ← \"laranja\"\n    // Verificar Urgente (amarelo)\n    SENÃO SE (temperatura &gt;= 37.5 E temperatura &lt; 38) OU\n             (nivelDor &gt;= 4 E nivelDor &lt;= 7) OU\n             (idade &gt; 65) ENTÃO\n        classificacao ← \"Urgente\"\n        cor ← \"amarelo\"\n    // Pouco Urgente (verde) - demais casos\n    SENÃO\n        classificacao ← \"Pouco Urgente\"\n        cor ← \"verde\"\n    FIM SE\n    \n    ESCREVER \"Classificação: \", classificacao, \" (\", cor, \")\"\n    \n    RETORNAR classificacao, cor\nFIM\nO professor pode sugerir os seguintes casos para validação do algoritmo: emergência por temperatura alta (40°C temperatura, 120 pressão, 80 frequência cardíaca, dor 3, 45 anos), muito urgente por dor severa (37°C temperatura, 130 pressão, 70 frequência cardíaca, dor 8, 30 anos), urgente por idade avançada (36.5°C temperatura, 130 pressão, 70 frequência cardíaca, dor 2, 70 anos), e pouco urgente para caso normal (36.5°C temperatura, 120 pressão, 70 frequência cardíaca, dor 2, 30 anos).\n\n\n\nTable 6.21: Teste 1: Emergência por temperatura alta (40°C): resultado: Emergência (vermelho)\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\ncor\nPróximo Passo\n\n\n\n\nENTRADA\ntemp ← 40, pressao ← 120, freq ← 80, dor ← 3, idade ← 45\n-\nindefinido\nindefinido\nLinha SE\n\n\nSE\n(temp &gt; 39) OU …\n(40 &gt; 39) OU (120 &lt; 90) OU (120 &gt; 180) OU (80 &lt; 50) OU (80 &gt; 120) → VERDADEIRO OU FALSO OU FALSO OU FALSO OU FALSO → VERDADEIRO\n“Emergência”\n“vermelho”\nFIM SE\n\n\nESCREVER\n“Classificação: Emergência (vermelho)”\n-\n“Emergência”\n“vermelho”\nRETORNAR\n\n\nRETORNAR\nclassificacao, cor\n-\n“Emergência”\n“vermelho”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.22: Teste 2: Muito urgente por dor severa (dor 8): resultado: Muito Urgente (laranja)\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\ncor\nPróximo Passo\n\n\n\n\nENTRADA\ntemp ← 37, pressao ← 130, freq ← 70, dor ← 8, idade ← 30\n-\nindefinido\nindefinido\nLinha SE\n\n\nSE\n(temp &gt; 39) OU …\n(37 &gt; 39) OU (130 &lt; 90) OU (130 &gt; 180) OU (70 &lt; 50) OU (70 &gt; 120) → FALSO OU FALSO OU FALSO OU FALSO OU FALSO → FALSO\nindefinido\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(temp &gt;= 38 E temp &lt;= 39) OU … OU (dor &gt; 7)\n(37 &gt;= 38 E 37 &lt;= 39) OU … OU (8 &gt; 7) → FALSO OU … OU VERDADEIRO → VERDADEIRO\n“Muito Urgente”\n“laranja”\nFIM SE\n\n\nESCREVER\n“Classificação: Muito Urgente (laranja)”\n-\n“Muito Urgente”\n“laranja”\nRETORNAR\n\n\nRETORNAR\nclassificacao, cor\n-\n“Muito Urgente”\n“laranja”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.23: Teste 3: Urgente por idade avançada (70 anos): resultado: Urgente (amarelo)\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\ncor\nPróximo Passo\n\n\n\n\nENTRADA\ntemp ← 36.5, pressao ← 130, freq ← 70, dor ← 2, idade ← 70\n-\nindefinido\nindefinido\nLinha SE\n\n\nSE\n(temp &gt; 39) OU …\n(36.5 &gt; 39) OU … → FALSO\nindefinido\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(temp &gt;= 38 E temp &lt;= 39) OU …\n(36.5 &gt;= 38 E 36.5 &lt;= 39) OU … OU (2 &gt; 7) → FALSO OU … OU FALSO → FALSO\nindefinido\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(temp &gt;= 37.5 E temp &lt; 38) OU … OU (idade &gt; 65)\n(36.5 &gt;= 37.5 E 36.5 &lt; 38) OU (2 &gt;= 4 E 2 &lt;= 7) OU (70 &gt; 65) → FALSO OU FALSO OU VERDADEIRO → VERDADEIRO\n“Urgente”\n“amarelo”\nFIM SE\n\n\nESCREVER\n“Classificação: Urgente (amarelo)”\n-\n“Urgente”\n“amarelo”\nRETORNAR\n\n\nRETORNAR\nclassificacao, cor\n-\n“Urgente”\n“amarelo”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.24: Teste 4: Pouco urgente - caso normal: resultado: Pouco Urgente (verde)\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\ncor\nPróximo Passo\n\n\n\n\nENTRADA\ntemp ← 36.5, pressao ← 120, freq ← 70, dor ← 2, idade ← 30\n-\nindefinido\nindefinido\nLinha SE\n\n\nSE\n(temp &gt; 39) OU …\nFALSO\nindefinido\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(temp &gt;= 38 E temp &lt;= 39) OU …\nFALSO\nindefinido\nindefinido\nSENÃO SE\n\n\nSENÃO SE\n(temp &gt;= 37.5 E temp &lt; 38) OU …\n(36.5 &gt;= 37.5 E 36.5 &lt; 38) OU (2 &gt;= 4 E 2 &lt;= 7) OU (30 &gt; 65) → FALSO OU FALSO OU FALSO → FALSO\nindefinido\nindefinido\nSENÃO\n\n\nSENÃO\nclassificacao ← “Pouco Urgente”, cor ← “verde”\n-\n“Pouco Urgente”\n“verde”\nFIM SE\n\n\nESCREVER\n“Classificação: Pouco Urgente (verde)”\n-\n“Pouco Urgente”\n“verde”\nRETORNAR\n\n\nRETORNAR\nclassificacao, cor\n-\n“Pouco Urgente”\n“verde”\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.25: Resumo: algoritmo classifica corretamente conforme protocolo de Manchester, priorizando casos mais graves\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nTemp (°C)\nPressão\nFreq. Card.\nDor\nIdade\nCritério Ativado\nClassificação\n\n\n\n\nEmergência\n40\n120\n80\n3\n45\nTemperatura &gt; 39°C\nEmergência (vermelho)\n\n\nMuito Urgente\n37\n130\n70\n8\n30\nDor &gt; 7\nMuito Urgente (laranja)\n\n\nUrgente\n36.5\n130\n70\n2\n70\nIdade &gt; 65 anos\nUrgente (amarelo)\n\n\nPouco Urgente\n36.5\n120\n70\n2\n30\nNenhum critério\nPouco Urgente (verde)\n\n\n\n\n\n\nA versão mais próxima das linguagens de programação poderia ser:\nALGORITMO ClassificacaoEmergenciaConcisa\n\nENTRADA:\n    temperatura, pressaoSistolica, frequenciaCardiaca, nivelDor, idade: numerico\n\nSAÍDA:\n    classificacao: texto\n\nINÍCIO\n    LER temperatura, pressaoSistolica, frequenciaCardiaca, nivelDor, idade\n    \n    SE (temperatura &gt; 39) OU (pressaoSistolica &lt; 90 OU pressaoSistolica &gt; 180) OU \n       (frequenciaCardiaca &lt; 50 OU frequenciaCardiaca &gt; 120) ENTÃO\n        classificacao ← \"Emergência (vermelho)\"\n    SENÃO SE (temperatura &gt;= 38 E temperatura &lt;= 39) OU \n             (pressaoSistolica &gt;= 90 E pressaoSistolica &lt;= 100) OU\n             (pressaoSistolica &gt;= 160 E pressaoSistolica &lt;= 180) OU (nivelDor &gt; 7) ENTÃO\n        classificacao ← \"Muito Urgente (laranja)\"\n    SENÃO SE (temperatura &gt;= 37.5 E temperatura &lt; 38) OU (nivelDor &gt;= 4 E nivelDor &lt;= 7) OU \n             (idade &gt; 65) ENTÃO\n        classificacao ← \"Urgente (amarelo)\"\n    SENÃO\n        classificacao ← \"Pouco Urgente (verde)\"\n    \n    RETORNAR classificacao\nFIM\nK. Sistema de Precificação Dinâmica: a empresa de transporte “MoveFast” precisa calcular tarifas dinâmicas. O sistema recebe distancia_km, horario (0-23), dia_semana (1-7), condicoes_clima (“normal”, “chuva”, “tempestade”) e demanda_regiao (“baixa”, “media”, “alta”). A tarifa base é distancia_km × 2.50. Aplicar multiplicadores: horários de pico (7-9h, 17-19h): ×1.5; fins de semana (6-7): ×1.2; chuva: ×1.3; tempestade: ×1.8; demanda alta: ×1.4; demanda media: ×1.1. Se for horário de pico E fim de semana E tempestade E demanda alta, aplicar desconto de 10% no valor final (para evitar preços abusivos). Crie o fluxograma deste sistema de precificação.\nAnálise: o pseudocódigo:\nALGORITMO PrecificacaoDinamica\n\nENTRADA:\n    distanciaKm: real\n    horario: inteiro\n    diaSemana: inteiro\n    condicoesClima: texto\n    demandaRegiao: texto\n\nSAÍDA:\n    tarifaFinal: real\n\nINÍCIO\n    ESCREVER \"Digite a distância (km):\"\n    LER distanciaKm\n    ESCREVER \"Digite o horário (0-23):\"\n    LER horario\n    ESCREVER \"Digite o dia da semana (1-7):\"\n    LER diaSemana\n    ESCREVER \"Digite as condições do clima (normal/chuva/tempestade):\"\n    LER condicoesClima\n    ESCREVER \"Digite a demanda da região (baixa/media/alta):\"\n    LER demandaRegiao\n    \n    // Calcular tarifa base\n    tarifaBase ← distanciaKm * 2.50\n    tarifaFinal ← tarifaBase\n    \n    // Verificar horário de pico (7-9h ou 17-19h)\n    horarioPico ← FALSO\n    SE (horario &gt;= 7 E horario &lt;= 9) OU (horario &gt;= 17 E horario &lt;= 19) ENTÃO\n        tarifaFinal ← tarifaFinal * 1.5\n        horarioPico ← VERDADEIRO\n    FIM SE\n    \n    // Verificar fim de semana (6=sábado, 7=domingo)\n    fimSemana ← FALSO\n    SE (diaSemana == 6) OU (diaSemana == 7) ENTÃO\n        tarifaFinal ← tarifaFinal * 1.2\n        fimSemana ← VERDADEIRO\n    FIM SE\n    \n    // Verificar condições climáticas\n    tempestade ← FALSO\n    SE (condicoesClima == \"chuva\") ENTÃO\n        tarifaFinal ← tarifaFinal * 1.3\n    SENÃO SE (condicoesClima == \"tempestade\") ENTÃO\n        tarifaFinal ← tarifaFinal * 1.8\n        tempestade ← VERDADEIRO\n    FIM SE\n    \n    // Verificar demanda da região\n    demandaAlta ← FALSO\n    SE (demandaRegiao == \"media\") ENTÃO\n        tarifaFinal ← tarifaFinal * 1.1\n    SENÃO SE (demandaRegiao == \"alta\") ENTÃO\n        tarifaFinal ← tarifaFinal * 1.4\n        demandaAlta ← VERDADEIRO\n    FIM SE\n    \n    // Condição especial de desconto (10% off)\n    SE (horarioPico == VERDADEIRO) E (fimSemana == VERDADEIRO) E \n       (tempestade == VERDADEIRO) E (demandaAlta == VERDADEIRO) ENTÃO\n        tarifaFinal ← tarifaFinal * 0.9\n        ESCREVER \"Desconto de 10% aplicado para evitar preços abusivos!\"\n    FIM SE\n    \n    ESCREVER \"Tarifa base: R$ \", tarifaBase\n    ESCREVER \"Tarifa final: R$ \", tarifaFinal\n    \n    RETORNAR tarifaFinal\nFIM\nFinalmente, esta é uma oportunidade de discutir tanto a legibilidade do pseudocódigo quanto seu uso para testes e depuração. Neste caso, o professor pode sugerir os seguintes casos para validação do algoritmo: tarifa normal sem multiplicadores (10km, 14h quarta-feira, clima normal, demanda baixa), tarifa com múltiplos multiplicadores (5km, 8h sábado, chuva, demanda média), e o caso especial de desconto para evitar preços abusivos (8km, 18h domingo, tempestade, demanda alta).\n\n\n\nTable 6.26: Teste 1: Tarifa normal (10km, dia útil, clima normal, demanda baixa): resultado: R$ 25.00\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\ntarifaFinal\nVariáveis de Controle\nPróximo Passo\n\n\n\n\nENTRADA\ndist ← 10, hora ← 14, dia ← 3, clima ← “normal”, demanda ← “baixa”\n-\nindefinido\n-\nCálculo base\n\n\ntarifaBase\ntarifaBase ← 10 * 2.50 = 25.00\n25.00\n25.00\n-\nVerificar pico\n\n\nSE horário pico\n(14 &gt;= 7 E 14 &lt;= 9) OU (14 &gt;= 17 E 14 &lt;= 19) → FALSO OU FALSO → FALSO\n-\n25.00\nhorarioPico ← FALSO\nVerificar fim semana\n\n\nSE fim semana\n(3 == 6) OU (3 == 7) → FALSO OU FALSO → FALSO\n-\n25.00\nfimSemana ← FALSO\nVerificar clima\n\n\nSE clima\nclima == “chuva” → FALSO, clima == “tempestade” → FALSO\n-\n25.00\ntempestade ← FALSO\nVerificar demanda\n\n\nSE demanda\ndemanda == “media” → FALSO, demanda == “alta” → FALSO\n-\n25.00\ndemandaAlta ← FALSO\nVerificar desconto\n\n\nSE desconto\nFALSO E FALSO E FALSO E FALSO → FALSO\n-\n25.00\n-\nESCREVER\n\n\nRETORNAR\ntarifaFinal\n-\n25.00\n-\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.27: Teste 2: Múltiplos multiplicadores (5km, sábado pico, chuva, demanda média): resultado: R$ 32.18\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\ntarifaFinal\nVariáveis de Controle\nPróximo Passo\n\n\n\n\nENTRADA\ndist ← 5, hora ← 8, dia ← 6, clima ← “chuva”, demanda ← “media”\n-\nindefinido\n-\nCálculo base\n\n\ntarifaBase\ntarifaBase ← 5 * 2.50 = 12.50\n12.50\n12.50\n-\nVerificar pico\n\n\nSE horário pico\n(8 &gt;= 7 E 8 &lt;= 9) OU (8 &gt;= 17 E 8 &lt;= 19) → VERDADEIRO OU FALSO → VERDADEIRO\n12.50 * 1.5 = 18.75\n18.75\nhorarioPico ← VERDADEIRO\nVerificar fim semana\n\n\nSE fim semana\n(6 == 6) OU (6 == 7) → VERDADEIRO OU FALSO → VERDADEIRO\n18.75 * 1.2 = 22.50\n22.50\nfimSemana ← VERDADEIRO\nVerificar clima\n\n\nSE clima\nclima == “chuva” → VERDADEIRO\n22.50 * 1.3 = 29.25\n29.25\ntempestade ← FALSO\nVerificar demanda\n\n\nSE demanda\ndemanda == “media” → VERDADEIRO\n29.25 * 1.1 = 32.18\n32.18\ndemandaAlta ← FALSO\nVerificar desconto\n\n\nSE desconto\nVERDADEIRO E VERDADEIRO E FALSO E FALSO → FALSO\n-\n32.18\n-\nESCREVER\n\n\nRETORNAR\ntarifaFinal\n-\n32.18\n-\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.28: Teste 3: Caso especial com desconto (8km, domingo pico, tempestade, demanda alta): resultado: R$ 81.65 com desconto\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\ntarifaFinal\nVariáveis de Controle\nPróximo Passo\n\n\n\n\nENTRADA\ndist ← 8, hora ← 18, dia ← 7, clima ← “tempestade”, demanda ← “alta”\n-\nindefinido\n-\nCálculo base\n\n\ntarifaBase\ntarifaBase ← 8 * 2.50 = 20.00\n20.00\n20.00\n-\nVerificar pico\n\n\nSE horário pico\n(18 &gt;= 7 E 18 &lt;= 9) OU (18 &gt;= 17 E 18 &lt;= 19) → FALSO OU VERDADEIRO → VERDADEIRO\n20.00 * 1.5 = 30.00\n30.00\nhorarioPico ← VERDADEIRO\nVerificar fim semana\n\n\nSE fim semana\n(7 == 6) OU (7 == 7) → FALSO OU VERDADEIRO → VERDADEIRO\n30.00 * 1.2 = 36.00\n36.00\nfimSemana ← VERDADEIRO\nVerificar clima\n\n\nSE clima\nclima == “tempestade” → VERDADEIRO\n36.00 * 1.8 = 64.80\n64.80\ntempestade ← VERDADEIRO\nVerificar demanda\n\n\nSE demanda\ndemanda == “alta” → VERDADEIRO\n64.80 * 1.4 = 90.72\n90.72\ndemandaAlta ← VERDADEIRO\nVerificar desconto\n\n\nSE desconto\nVERDADEIRO E VERDADEIRO E VERDADEIRO E VERDADEIRO → VERDADEIRO\n90.72 * 0.9 = 81.65\n81.65\n-\nESCREVER\n\n\nRETORNAR\ntarifaFinal\n-\n81.65\n-\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.29: Resumo: algoritmo aplica corretamente todos os multiplicadores e o desconto especial para evitar preços abusivos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nDist (km)\nHorário\nDia\nClima\nDemanda\nMultiplicadores Aplicados\nTarifa Final\nDesconto\n\n\n\n\nNormal\n10\n14\n3 (qua)\nnormal\nbaixa\nNenhum\nR$ 25.00\nNão\n\n\nMúltiplos\n5\n8\n6 (sáb)\nchuva\nmedia\nPico (1.5) + Fim semana (1.2) + Chuva (1.3) + Média (1.1)\nR$ 32.18\nNão\n\n\nEspecial\n8\n18\n7 (dom)\ntempestade\nalta\nPico (1.5) + Fim semana (1.2) + Tempestade (1.8) + Alta (1.4) - Desconto (0.9)\nR$ 81.65\nSim (10%)\n\n\n\n\n\n\nPara ver a transição o professor poderia usar:\nALGORITMO PrecificacaoDinamicaConcisa\n\nENTRADA:\n    distanciaKm, horario, diaSemana: numerico\n    condicoesClima, demandaRegiao: texto\n\nSAÍDA:\n    tarifaFinal: real\n\nINÍCIO\n    LER distanciaKm, horario, diaSemana, condicoesClima, demandaRegiao\n    \n    tarifaFinal ← distanciaKm * 2.50\n    horarioPico ← ((horario &gt;= 7 E horario &lt;= 9) OU (horario &gt;= 17 E horario &lt;= 19))\n    fimSemana ← (diaSemana == 6 OU diaSemana == 7)\n    tempestade ← (condicoesClima == \"tempestade\")\n    demandaAlta ← (demandaRegiao == \"alta\")\n    \n    SE horarioPico ENTÃO tarifaFinal ← tarifaFinal * 1.5\n    SE fimSemana ENTÃO tarifaFinal ← tarifaFinal * 1.2\n    SE (condicoesClima == \"chuva\") ENTÃO tarifaFinal ← tarifaFinal * 1.3\n    SE tempestade ENTÃO tarifaFinal ← tarifaFinal * 1.8\n    SE (demandaRegiao == \"media\") ENTÃO tarifaFinal ← tarifaFinal * 1.1\n    SE demandaAlta ENTÃO tarifaFinal ← tarifaFinal * 1.4\n    SE (horarioPico E fimSemana E tempestade E demandaAlta) ENTÃO tarifaFinal ← tarifaFinal * 0.9\n    \n    RETORNAR tarifaFinal\nFIM\nL. Avaliação de Risco de Investimento: a corretora “InvestSmart”, gerenciada pela analista Dra. Patricia, desenvolveu um sistema para classificar perfis de investidor. O sistema recebe idade, renda_mensal, patrimonio_liquido, experiencia_investimentos (anos), tolerancia_perda (percentual) e objetivo_prazo (“curto”, “medio”, “longo”). O perfil é determinado por pontuação: idade &lt; 30 (+2 pontos), 30-50 (+1 ponto), &gt;50 (0 pontos); renda &gt; 10000 (+2), 5000-10000 (+1), &lt;5000 (0); patrimônio &gt; 100000 (+2), 50000-100000 (+1), &lt;50000 (0); experiência &gt; 5 anos (+2), 2-5 anos (+1), &lt;2 anos (0); tolerância &gt; 20% (+2), 10-20% (+1), &lt;10% (0); prazo longo (+2), médio (+1), curto (0). Classificação: 0-4 pontos: “Conservador”; 5-8: “Moderado”; 9-12: “Arrojado”. Adicionalmente, se idade &gt; 60 E tolerância &lt; 15%, forçar “Conservador” independente da pontuação. Desenvolva este algoritmo de classificação.\nAnálise: o pseudocódigo poderia ser:\nALGORITMO AvaliacaoPerfilInvestidor\n\nENTRADA:\n    idade: inteiro\n    rendaMensal: real\n    patrimonioLiquido: real\n    experienciaInvestimentos: inteiro\n    toleranciaPerda: real\n    objetivoPrazo: texto\n\nSAÍDA:\n    pontuacaoTotal: inteiro\n    perfilInvestidor: texto\n\nINÍCIO\n    ESCREVER \"Digite a idade:\"\n    LER idade\n    ESCREVER \"Digite a renda mensal:\"\n    LER rendaMensal\n    ESCREVER \"Digite o patrimônio líquido:\"\n    LER patrimonioLiquido\n    ESCREVER \"Digite a experiência em investimentos (anos):\"\n    LER experienciaInvestimentos\n    ESCREVER \"Digite a tolerância à perda (%):\"\n    LER toleranciaPerda\n    ESCREVER \"Digite o objetivo de prazo (curto/medio/longo):\"\n    LER objetivoPrazo\n    \n    pontuacaoTotal ← 0\n    \n    // Pontuação por idade\n    SE (idade &lt; 30) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (idade &gt;= 30 E idade &lt;= 50) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 1\n    // idade &gt; 50: +0 pontos\n    FIM SE\n    \n    // Pontuação por renda\n    SE (rendaMensal &gt; 10000) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (rendaMensal &gt;= 5000 E rendaMensal &lt;= 10000) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 1\n    // renda &lt; 5000: +0 pontos\n    FIM SE\n    \n    // Pontuação por patrimônio\n    SE (patrimonioLiquido &gt; 100000) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (patrimonioLiquido &gt;= 50000 E patrimonioLiquido &lt;= 100000) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 1\n    // patrimônio &lt; 50000: +0 pontos\n    FIM SE\n    \n    // Pontuação por experiência\n    SE (experienciaInvestimentos &gt; 5) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (experienciaInvestimentos &gt;= 2 E experienciaInvestimentos &lt;= 5) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 1\n    // experiência &lt; 2: +0 pontos\n    FIM SE\n    \n    // Pontuação por tolerância\n    SE (toleranciaPerda &gt; 20) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (toleranciaPerda &gt;= 10 E toleranciaPerda &lt;= 20) ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 1\n    // tolerância &lt; 10: +0 pontos\n    FIM SE\n    \n    // Pontuação por prazo\n    SE (objetivoPrazo == \"longo\") ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (objetivoPrazo == \"medio\") ENTÃO\n        pontuacaoTotal ← pontuacaoTotal + 1\n    // prazo \"curto\": +0 pontos\n    FIM SE\n    \n    // Classificação baseada na pontuação\n    SE (pontuacaoTotal &gt;= 0 E pontuacaoTotal &lt;= 4) ENTÃO\n        perfilInvestidor ← \"Conservador\"\n    SENÃO SE (pontuacaoTotal &gt;= 5 E pontuacaoTotal &lt;= 8) ENTÃO\n        perfilInvestidor ← \"Moderado\"\n    SENÃO SE (pontuacaoTotal &gt;= 9 E pontuacaoTotal &lt;= 12) ENTÃO\n        perfilInvestidor ← \"Arrojado\"\n    FIM SE\n    \n    // Condição especial: forçar conservador para idosos com baixa tolerância\n    SE (idade &gt; 60) E (toleranciaPerda &lt; 15) ENTÃO\n        perfilInvestidor ← \"Conservador\"\n        ESCREVER \"Perfil ajustado para Conservador devido à idade e baixa tolerância ao risco.\"\n    FIM SE\n    \n    ESCREVER \"Pontuação total: \", pontuacaoTotal\n    ESCREVER \"Perfil do investidor: \", perfilInvestidor\n    \n    RETORNAR pontuacaoTotal, perfilInvestidor\nFIM\nO professor pode sugerir os seguintes casos para validação do algoritmo: jovem investidor arrojado (25 anos, R$ 12000 renda, R$ 150000 patrimônio, 3 anos experiência, 25% tolerância, prazo longo), investidor de perfil moderado (40 anos, R$ 7000 renda, R$ 70000 patrimônio, 4 anos experiência, 15% tolerância, prazo médio), e o caso especial de idoso forçado a conservador (65 anos, R$ 15000 renda, R$ 200000 patrimônio, 8 anos experiência, 12% tolerância, prazo longo).\n\n\n\nTable 6.30: Teste 1: Jovem arrojado (25 anos, alta renda e patrimônio): resultado: 11 pontos - Arrojado\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\npontuacaoTotal\nperfilInvestidor\nPróximo Passo\n\n\n\n\nENTRADA\nidade ← 25, renda ← 12000, patrimonio ← 150000, exp ← 3, tolerancia ← 25, prazo ← “longo”\n-\n0\nindefinido\nPontuação idade\n\n\nSE idade\nidade &lt; 30 → 25 &lt; 30 → VERDADEIRO\npontuacaoTotal + 2 = 2\n2\nindefinido\nPontuação renda\n\n\nSE renda\nrenda &gt; 10000 → 12000 &gt; 10000 → VERDADEIRO\npontuacaoTotal + 2 = 4\n4\nindefinido\nPontuação patrimônio\n\n\nSE patrimônio\npatrimonio &gt; 100000 → 150000 &gt; 100000 → VERDADEIRO\npontuacaoTotal + 2 = 6\n6\nindefinido\nPontuação experiência\n\n\nSE experiência\nexp &gt;= 2 E exp &lt;= 5 → 3 &gt;= 2 E 3 &lt;= 5 → VERDADEIRO\npontuacaoTotal + 1 = 7\n7\nindefinido\nPontuação tolerância\n\n\nSE tolerância\ntolerancia &gt; 20 → 25 &gt; 20 → VERDADEIRO\npontuacaoTotal + 2 = 9\n9\nindefinido\nPontuação prazo\n\n\nSE prazo\nprazo == “longo” → VERDADEIRO\npontuacaoTotal + 2 = 11\n11\nindefinido\nClassificação\n\n\nSE classificação\npontuacao &gt;= 9 E pontuacao &lt;= 12 → 11 &gt;= 9 E 11 &lt;= 12 → VERDADEIRO\n-\n11\n“Arrojado”\nCondição especial\n\n\nSE especial\n(idade &gt; 60) E (tolerancia &lt; 15) → (25 &gt; 60) E (25 &lt; 15) → FALSO E FALSO → FALSO\n-\n11\n“Arrojado”\nESCREVER\n\n\nRETORNAR\npontuacaoTotal, perfilInvestidor\n-\n11\n“Arrojado”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.31: Teste 2: Investidor moderado (40 anos, renda e patrimônio médios): resultado: 6 pontos - Moderado\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\npontuacaoTotal\nperfilInvestidor\nPróximo Passo\n\n\n\n\nENTRADA\nidade ← 40, renda ← 7000, patrimonio ← 70000, exp ← 4, tolerancia ← 15, prazo ← “medio”\n-\n0\nindefinido\nPontuação idade\n\n\nSE idade\nidade &gt;= 30 E idade &lt;= 50 → 40 &gt;= 30 E 40 &lt;= 50 → VERDADEIRO\npontuacaoTotal + 1 = 1\n1\nindefinido\nPontuação renda\n\n\nSE renda\nrenda &gt;= 5000 E renda &lt;= 10000 → 7000 &gt;= 5000 E 7000 &lt;= 10000 → VERDADEIRO\npontuacaoTotal + 1 = 2\n2\nindefinido\nPontuação patrimônio\n\n\nSE patrimônio\npatrimonio &gt;= 50000 E patrimonio &lt;= 100000 → 70000 &gt;= 50000 E 70000 &lt;= 100000 → VERDADEIRO\npontuacaoTotal + 1 = 3\n3\nindefinido\nPontuação experiência\n\n\nSE experiência\nexp &gt;= 2 E exp &lt;= 5 → 4 &gt;= 2 E 4 &lt;= 5 → VERDADEIRO\npontuacaoTotal + 1 = 4\n4\nindefinido\nPontuação tolerância\n\n\nSE tolerância\ntolerancia &gt;= 10 E tolerancia &lt;= 20 → 15 &gt;= 10 E 15 &lt;= 20 → VERDADEIRO\npontuacaoTotal + 1 = 5\n5\nindefinido\nPontuação prazo\n\n\nSE prazo\nprazo == “medio” → VERDADEIRO\npontuacaoTotal + 1 = 6\n6\nindefinido\nClassificação\n\n\nSE classificação\npontuacao &gt;= 5 E pontuacao &lt;= 8 → 6 &gt;= 5 E 6 &lt;= 8 → VERDADEIRO\n-\n6\n“Moderado”\nCondição especial\n\n\nSE especial\n(idade &gt; 60) E (tolerancia &lt; 15) → (40 &gt; 60) E (15 &lt; 15) → FALSO E FALSO → FALSO\n-\n6\n“Moderado”\nESCREVER\n\n\nRETORNAR\npontuacaoTotal, perfilInvestidor\n-\n6\n“Moderado”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.32: Teste 3: Caso especial - idoso conservador (65 anos, boa situação mas baixa tolerância): resultado: 9 pontos mas forçado para Conservador\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\npontuacaoTotal\nperfilInvestidor\nPróximo Passo\n\n\n\n\nENTRADA\nidade ← 65, renda ← 15000, patrimonio ← 200000, exp ← 8, tolerancia ← 12, prazo ← “longo”\n-\n0\nindefinido\nPontuação idade\n\n\nSE idade\nidade &gt; 50 → 65 &gt; 50 → VERDADEIRO (mas sem pontos)\n-\n0\nindefinido\nPontuação renda\n\n\nSE renda\nrenda &gt; 10000 → 15000 &gt; 10000 → VERDADEIRO\npontuacaoTotal + 2 = 2\n2\nindefinido\nPontuação patrimônio\n\n\nSE patrimônio\npatrimonio &gt; 100000 → 200000 &gt; 100000 → VERDADEIRO\npontuacaoTotal + 2 = 4\n4\nindefinido\nPontuação experiência\n\n\nSE experiência\nexp &gt; 5 → 8 &gt; 5 → VERDADEIRO\npontuacaoTotal + 2 = 6\n6\nindefinido\nPontuação tolerância\n\n\nSE tolerância\ntolerancia &gt;= 10 E tolerancia &lt;= 20 → 12 &gt;= 10 E 12 &lt;= 20 → VERDADEIRO\npontuacaoTotal + 1 = 7\n7\nindefinido\nPontuação prazo\n\n\nSE prazo\nprazo == “longo” → VERDADEIRO\npontuacaoTotal + 2 = 9\n9\nindefinido\nClassificação\n\n\nSE classificação\npontuacao &gt;= 9 E pontuacao &lt;= 12 → 9 &gt;= 9 E 9 &lt;= 12 → VERDADEIRO\n-\n9\n“Arrojado”\nCondição especial\n\n\nSE especial\n(idade &gt; 60) E (tolerancia &lt; 15) → (65 &gt; 60) E (12 &lt; 15) → VERDADEIRO E VERDADEIRO → VERDADEIRO\n-\n9\n“Conservador”\nESCREVER\n\n\nRETORNAR\npontuacaoTotal, perfilInvestidor\n-\n9\n“Conservador”\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.33: Resumo: algoritmo classifica corretamente perfis de investidor e aplica proteção especial para idosos com baixa tolerância ao risco\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nIdade\nRenda\nPatrimônio\nExp.\nTolerância\nPrazo\nPontos\nPerfil Original\nPerfil Final\nRegra Especial\n\n\n\n\nJovem arrojado\n25\n12000\n150000\n3\n25%\nlongo\n11\nArrojado\nArrojado\nNão\n\n\nModerado\n40\n7000\n70000\n4\n15%\nmedio\n6\nModerado\nModerado\nNão\n\n\nIdoso especial\n65\n15000\n200000\n8\n12%\nlongo\n9\nArrojado\nConservador\nSim (idade&gt;60 E tolerância&lt;15%)\n\n\n\n\n\n\nA versão mais próxima seria:\nALGORITMO AvaliacaoPerfilInvestidorConciso\n\nENTRADA:\n    idade, rendaMensal, patrimonioLiquido, experienciaInvestimentos, toleranciaPerda: numerico\n    objetivoPrazo: texto\n\nSAÍDA:\n    pontuacaoTotal: inteiro\n    perfilInvestidor: texto\n\nINÍCIO\n    LER idade, rendaMensal, patrimonioLiquido, experienciaInvestimentos, toleranciaPerda, objetivoPrazo\n    \n    pontuacaoTotal ← 0\n    SE (idade &lt; 30) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (idade &lt;= 50) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (rendaMensal &gt; 10000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (rendaMensal &gt;= 5000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (patrimonioLiquido &gt; 100000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (patrimonioLiquido &gt;= 50000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (experienciaInvestimentos &gt; 5) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (experienciaInvestimentos &gt;= 2) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (toleranciaPerda &gt; 20) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (toleranciaPerda &gt;= 10) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (objetivoPrazo == \"longo\") ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (objetivoPrazo == \"medio\") ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (pontuacaoTotal &lt;= 4) ENTÃO perfilInvestidor ← \"Conservador\"\n    SENÃO SE (pontuacaoTotal &lt;= 8) ENTÃO perfilInvestidor ← \"Moderado\"\n    SENÃO perfilInvestidor ← \"Arrojado\"\n    \n    SE (idade &gt; 60) E (toleranciaPerda &lt; 15) ENTÃO perfilInvestidor ← \"Conservador\"\n    \n    RETORNAR pontuacaoTotal, perfilInvestidor\nFIM\nM. Sistema de Controle de Qualidade Industrial: na fábrica “Precisão Total”, o engenheiro Carlos implementa controle de qualidade para peças metálicas. O sistema mede diametro_mm, peso_gramas, dureza_hrc, temperatura_teste e lote_producao. Especificações: diâmetro 50mm ±0.5mm; peso 200g ±10g; dureza 45-55 HRC; temperatura teste entre 20-25°C. Classificação de defeitos: Classe A (aprovado): todas especificações atendidas; Classe B (aprovado com ressalvas): máximo 1 parâmetro fora da especificação E desvio não superior a 10% do limite; Classe C (retrabalho): 2 parâmetros fora OU 1 parâmetro com desvio &gt; 10% mas ≤ 20%; Classe D (refugo): 3+ parâmetros fora OU qualquer desvio &gt; 20%. Adicionalmente, lotes de produção pares têm tolerância aumentada em 5% para todos os parâmetros. Crie o fluxograma para este sistema de controle de qualidade.\nAnálise: o pseudocódigo:\nALGORITMO ControleQualidadeIndustrial\n\nENTRADA:\n    diametroMm: real\n    pesoGramas: real\n    durezaHrc: real\n    temperaturaTeste: real\n    loteProducao: inteiro\n\nSAÍDA:\n    classeQualidade: texto\n    statusAprovacao: texto\n\nINÍCIO\n    ESCREVER \"Digite o diâmetro (mm):\"\n    LER diametroMm\n    ESCREVER \"Digite o peso (gramas):\"\n    LER pesoGramas\n    ESCREVER \"Digite a dureza (HRC):\"\n    LER durezaHrc\n    ESCREVER \"Digite a temperatura de teste (°C):\"\n    LER temperaturaTeste\n    ESCREVER \"Digite o lote de produção:\"\n    LER loteProducao\n    \n    // Especificações base\n    diametroMin ← 49.5\n    diametroMax ← 50.5\n    pesoMin ← 190\n    pesoMax ← 210\n    durezaMin ← 45\n    durezaMax ← 55\n    tempMin ← 20\n    tempMax ← 25\n    \n    // Verificar se lote é par (tolerância aumentada em 5%)\n    SE (loteProducao % 2 == 0) ENTÃO\n        diametroMin ← diametroMin - (0.5 * 0.05)\n        diametroMax ← diametroMax + (0.5 * 0.05)\n        pesoMin ← pesoMin - (10 * 0.05)\n        pesoMax ← pesoMax + (10 * 0.05)\n        durezaMin ← durezaMin - (5 * 0.05)\n        durezaMax ← durezaMax + (5 * 0.05)\n        tempMin ← tempMin - (2.5 * 0.05)\n        tempMax ← tempMax + (2.5 * 0.05)\n        ESCREVER \"Lote par: tolerâncias aumentadas em 5%\"\n    FIM SE\n    \n    parametrosForaEspec ← 0\n    maxDesvioPercentual ← 0\n    \n    // Verificar diâmetro\n    SE (diametroMm &lt; diametroMin) OU (diametroMm &gt; diametroMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvioMin ← ABS((diametroMm - diametroMin) / 50) * 100\n        desvioMax ← ABS((diametroMm - diametroMax) / 50) * 100\n        desvio ← MAIOR(desvioMin, desvioMax)\n        SE (desvio &gt; maxDesvioPercentual) ENTÃO maxDesvioPercentual ← desvio\n    FIM SE\n    \n    // Verificar peso\n    SE (pesoGramas &lt; pesoMin) OU (pesoGramas &gt; pesoMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvioMin ← ABS((pesoGramas - pesoMin) / 200) * 100\n        desvioMax ← ABS((pesoGramas - pesoMax) / 200) * 100\n        desvio ← MAIOR(desvioMin, desvioMax)\n        SE (desvio &gt; maxDesvioPercentual) ENTÃO maxDesvioPercentual ← desvio\n    FIM SE\n    \n    // Verificar dureza\n    SE (durezaHrc &lt; durezaMin) OU (durezaHrc &gt; durezaMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvioMin ← ABS((durezaHrc - durezaMin) / 50) * 100\n        desvioMax ← ABS((durezaHrc - durezaMax) / 50) * 100\n        desvio ← MAIOR(desvioMin, desvioMax)\n        SE (desvio &gt; maxDesvioPercentual) ENTÃO maxDesvioPercentual ← desvio\n    FIM SE\n    \n    // Verificar temperatura\n    SE (temperaturaTeste &lt; tempMin) OU (temperaturaTeste &gt; tempMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvioMin ← ABS((temperaturaTeste - tempMin) / 22.5) * 100\n        desvioMax ← ABS((temperaturaTeste - tempMax) / 22.5) * 100\n        desvio ← MAIOR(desvioMin, desvioMax)\n        SE (desvio &gt; maxDesvioPercentual) ENTÃO maxDesvioPercentual ← desvio\n    FIM SE\n    \n    // Classificação baseada nos critérios\n    SE (parametrosForaEspec == 0) ENTÃO\n        classeQualidade ← \"Classe A\"\n        statusAprovacao ← \"Aprovado\"\n    SENÃO SE (parametrosForaEspec == 1) E (maxDesvioPercentual &lt;= 10) ENTÃO\n        classeQualidade ← \"Classe B\"\n        statusAprovacao ← \"Aprovado com ressalvas\"\n    SENÃO SE (parametrosForaEspec == 2) OU \n             ((parametrosForaEspec == 1) E (maxDesvioPercentual &gt; 10 E maxDesvioPercentual &lt;= 20)) ENTÃO\n        classeQualidade ← \"Classe C\"\n        statusAprovacao ← \"Retrabalho\"\n    SENÃO SE (parametrosForaEspec &gt;= 3) OU (maxDesvioPercentual &gt; 20) ENTÃO\n        classeQualidade ← \"Classe D\"\n        statusAprovacao ← \"Refugo\"\n    FIM SE\n    \n    ESCREVER \"Parâmetros fora de especificação: \", parametrosForaEspec\n    ESCREVER \"Maior desvio percentual: \", maxDesvioPercentual, \"%\"\n    ESCREVER \"Classificação: \", classeQualidade\n    ESCREVER \"Status: \", statusAprovacao\n    \n    RETORNAR classeQualidade, statusAprovacao\nFIM\nO professor pode sugerir os seguintes casos para validação do algoritmo: peça perfeita dentro de todas as especificações (50.0mm diâmetro, 200g peso, 50 HRC dureza, 22°C temperatura, lote 101 ímpar), lote par com pequeno desvio no diâmetro (51.0mm diâmetro, 200g peso, 50 HRC dureza, 22°C temperatura, lote 102 par), e peça defeituosa com múltiplos parâmetros fora de especificação (48.0mm diâmetro, 170g peso, 40 HRC dureza, 30°C temperatura, lote 103 ímpar). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\n\n\n\nTable 6.34: Teste 1: Peça perfeita (todas especificações atendidas): resultado: Classe A - Aprovado\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nparametrosForaEspec\nmaxDesvioPercentual\nclasseQualidade\nPróximo Passo\n\n\n\n\nENTRADA\ndiam ← 50.0, peso ← 200, dureza ← 50, temp ← 22, lote ← 101\n-\n0\n0\nindefinido\nVerificar lote\n\n\nSE lote par\n101 % 2 == 0 → FALSO\nTolerâncias base mantidas\n0\n0\nindefinido\nVerificar diâmetro\n\n\nSE diâmetro\n(50.0 &lt; 49.5) OU (50.0 &gt; 50.5) → FALSO OU FALSO → FALSO\nDiâmetro OK\n0\n0\nindefinido\nVerificar peso\n\n\nSE peso\n(200 &lt; 190) OU (200 &gt; 210) → FALSO OU FALSO → FALSO\nPeso OK\n0\n0\nindefinido\nVerificar dureza\n\n\nSE dureza\n(50 &lt; 45) OU (50 &gt; 55) → FALSO OU FALSO → FALSO\nDureza OK\n0\n0\nindefinido\nVerificar temperatura\n\n\nSE temperatura\n(22 &lt; 20) OU (22 &gt; 25) → FALSO OU FALSO → FALSO\nTemperatura OK\n0\n0\nindefinido\nClassificação\n\n\nSE classificação\nparametrosForaEspec == 0 → 0 == 0 → VERDADEIRO\n-\n0\n0\n“Classe A”\nESCREVER\n\n\nRETORNAR\nclasseQualidade, statusAprovacao\n-\n0\n0\n“Classe A”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.35: Teste 2: Lote par com pequeno desvio no diâmetro: resultado: Classe B - Aprovado com ressalvas\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nparametrosForaEspec\nmaxDesvioPercentual\nclasseQualidade\nPróximo Passo\n\n\n\n\nENTRADA\ndiam ← 51.0, peso ← 200, dureza ← 50, temp ← 22, lote ← 102\n-\n0\n0\nindefinido\nVerificar lote\n\n\nSE lote par\n102 % 2 == 0 → VERDADEIRO\nTolerâncias aumentadas: diam 49.475-50.525, etc.\n0\n0\nindefinido\nVerificar diâmetro\n\n\nSE diâmetro\n(51.0 &lt; 49.475) OU (51.0 &gt; 50.525) → FALSO OU VERDADEIRO → VERDADEIRO\nparametrosForaEspec = 1, desvio =\n(51.0-50.525)/50\n*100 = 0.95%\n1\n0.95\n\n\nSE outros\nPeso, dureza, temp OK\n-\n1\n0.95\nindefinido\nClassificação\n\n\nSE classificação\n(parametrosForaEspec == 1) E (maxDesvioPercentual &lt;= 10) → (1 == 1) E (0.95 &lt;= 10) → VERDADEIRO\n-\n1\n0.95\n“Classe B”\nESCREVER\n\n\nRETORNAR\nclasseQualidade, statusAprovacao\n-\n1\n0.95\n“Classe B”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.36: Teste 3: Múltiplos parâmetros fora de especificação: resultado: Classe D - Refugo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nparametrosForaEspec\nmaxDesvioPercentual\nclasseQualidade\nPróximo Passo\n\n\n\n\nENTRADA\ndiam ← 48.0, peso ← 170, dureza ← 40, temp ← 30, lote ← 103\n-\n0\n0\nindefinido\nVerificar lote\n\n\nSE lote par\n103 % 2 == 0 → FALSO\nTolerâncias base\n0\n0\nindefinido\nVerificar parâmetros\n\n\nVerificações\nDiâmetro fora (48.0 &lt; 49.5), Peso fora (170 &lt; 190), Dureza fora (40 &lt; 45), Temp fora (30 &gt; 25)\nparametrosForaEspec = 4, maxDesvioPercentual &gt; 20%\n4\n&gt;20\nindefinido\nClassificação\n\n\nSE classificação\nparametrosForaEspec &gt;= 3 → 4 &gt;= 3 → VERDADEIRO\n-\n4\n&gt;20\n“Classe D”\nESCREVER\n\n\nRETORNAR\nclasseQualidade, statusAprovacao\n-\n4\n&gt;20\n“Classe D”\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.37: Resumo: algoritmo classifica corretamente peças conforme especificações industriais e aplica tolerâncias especiais para lotes pares\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nDiâmetro\nPeso\nDureza\nTemp\nLote\nParâm. Fora\nMaior Desvio\nClasse\nStatus\n\n\n\n\nPerfeita\n50.0\n200\n50\n22\n101 (ímpar)\n0\n0%\nA\nAprovado\n\n\nLote par\n51.0\n200\n50\n22\n102 (par)\n1\n0.95%\nB\nAprovado c/ ressalvas\n\n\nDefeituosa\n48.0\n170\n40\n30\n103 (ímpar)\n4\n&gt;20%\nD\nRefugo\n\n\n\n\n\n\nO pseudocódigo mais próximo:\nALGORITMO ControleQualidadeIndustrialConciso\n\nENTRADA:\n    diametroMm, pesoGramas, durezaHrc, temperaturaTeste: real\n    loteProducao: inteiro\n\nSAÍDA:\n    classeQualidade: texto\n\nINÍCIO\n    LER diametroMm, pesoGramas, durezaHrc, temperaturaTeste, loteProducao\n    \n    toleranciaExtra ← SE (loteProducao % 2 == 0) ENTÃO 1.05 SENÃO 1.0\n    \n    diamMin ← 49.5 * toleranciaExtra\n    diamMax ← 50.5 * toleranciaExtra\n    pesoMin ← 190 * toleranciaExtra\n    pesoMax ← 210 * toleranciaExtra\n    durezaMin ← 45 * toleranciaExtra\n    durezaMax ← 55 * toleranciaExtra\n    tempMin ← 20 * toleranciaExtra\n    tempMax ← 25 * toleranciaExtra\n    \n    parametrosForaEspec ← 0\n    maxDesvio ← 0\n    \n    SE (diametroMm &lt; diamMin) OU (diametroMm &gt; diamMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (diametroMm &lt; diamMin) ENTÃO (diamMin - diametroMm) / 50 * 100 SENÃO (diametroMm - diamMax) / 50 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (pesoGramas &lt; pesoMin) OU (pesoGramas &gt; pesoMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (pesoGramas &lt; pesoMin) ENTÃO (pesoMin - pesoGramas) / 200 * 100 SENÃO (pesoGramas - pesoMax) / 200 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (durezaHrc &lt; durezaMin) OU (durezaHrc &gt; durezaMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (durezaHrc &lt; durezaMin) ENTÃO (durezaMin - durezaHrc) / 50 * 100 SENÃO (durezaHrc - durezaMax) / 50 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (temperaturaTeste &lt; tempMin) OU (temperaturaTeste &gt; tempMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (temperaturaTeste &lt; tempMin) ENTÃO (tempMin - temperaturaTeste) / 22.5 * 100 SENÃO (temperaturaTeste - tempMax) / 22.5 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (parametrosForaEspec == 0) ENTÃO classeQualidade ← \"Classe A\"\n    SENÃO SE (parametrosForaEspec == 1) E (maxDesvio &lt;= 10) ENTÃO classeQualidade ← \"Classe B\"\n    SENÃO SE (parametrosForaEspec == 2) OU (parametrosForaEspec == 1 E maxDesvio &lt;= 20) ENTÃO classeQualidade ← \"Classe C\"\n    SENÃO classeQualidade ← \"Classe D\"\n    \n    RETORNAR classeQualidade\nFIM\nN. Sistema de Avaliação para Promoção Corporativa: na empresa “Crescer Juntos”, a gestora de RH Dra. Ana Carolina precisa automatizar o processo de avaliação para promoções. O sistema deve analisar múltiplos critérios dos funcionários: tempo_empresa (anos), avaliacao_desempenho (1-10), nivel_formacao (“medio”, “superior”, “pos”), certificacoes_profissionais (quantidade), idade e salario_atual. As regras de classificação são: Promoção Imediata: tempo ≥ 3 anos E avaliação ≥ 8 E (formação superior OU pós) E certificações ≥ 2; Promoção Condicional: tempo ≥ 2 anos E avaliação ≥ 7 E pelo menos um dos critérios extras (formação superior/pós OU certificações ≥ 1); Desenvolvimento Necessário: tempo ≥ 1 ano E avaliação ≥ 6; Não Elegível: demais casos. Adicionalmente, se idade &gt; 55 anos E salário &gt; R$ 15000, aplicar regra especial “Plano Sucessão” independente dos outros critérios. Desenvolva este algoritmo de classificação.\nAnálise: o pseudocódigo poderia ser:\nALGORITMO AvaliacaoPromocao\n\nENTRADA:\n    tempoEmpresa: real\n    avaliacaoDesempenho: real\n    nivelFormacao: texto\n    certificacoesProfissionais: inteiro\n    idade: inteiro\n    salarioAtual: real\n\nSAÍDA:\n    classificacao: texto\n    statusPromocao: texto\n\nINÍCIO\n    ESCREVER \"Digite o tempo na empresa (anos):\"\n    LER tempoEmpresa\n    ESCREVER \"Digite a avaliação de desempenho (1-10):\"\n    LER avaliacaoDesempenho\n    ESCREVER \"Digite o nível de formação (medio/superior/pos):\"\n    LER nivelFormacao\n    ESCREVER \"Digite o número de certificações profissionais:\"\n    LER certificacoesProfissionais\n    ESCREVER \"Digite a idade:\"\n    LER idade\n    ESCREVER \"Digite o salário atual:\"\n    LER salarioAtual\n    \n    // Verificar regra especial primeiro\n    SE (idade &gt; 55) E (salarioAtual &gt; 15000) ENTÃO\n        classificacao ← \"Plano Sucessão\"\n        statusPromocao ← \"Preparação para transição de conhecimento\"\n        ESCREVER \"Regra especial aplicada: Plano Sucessão ativado.\"\n    SENÃO\n        // Verificar formação superior ou pós\n        formacaoAvancada ← FALSO\n        SE (nivelFormacao == \"superior\") OU (nivelFormacao == \"pos\") ENTÃO\n            formacaoAvancada ← VERDADEIRO\n        FIM SE\n        \n        // Verificar Promoção Imediata\n        SE (tempoEmpresa &gt;= 3) E (avaliacaoDesempenho &gt;= 8) E \n           (formacaoAvancada == VERDADEIRO) E (certificacoesProfissionais &gt;= 2) ENTÃO\n            classificacao ← \"Promoção Imediata\"\n            statusPromocao ← \"Aprovado para promoção no próximo ciclo\"\n        \n        // Verificar Promoção Condicional\n        SENÃO SE (tempoEmpresa &gt;= 2) E (avaliacaoDesempenho &gt;= 7) E \n                 ((formacaoAvancada == VERDADEIRO) OU (certificacoesProfissionais &gt;= 1)) ENTÃO\n            classificacao ← \"Promoção Condicional\"\n            statusPromocao ← \"Aprovado mediante cumprimento de requisitos adicionais\"\n        \n        // Verificar Desenvolvimento Necessário\n        SENÃO SE (tempoEmpresa &gt;= 1) E (avaliacaoDesempenho &gt;= 6) ENTÃO\n            classificacao ← \"Desenvolvimento Necessário\"\n            statusPromocao ← \"Participar de programa de desenvolvimento antes da promoção\"\n        \n        // Não Elegível\n        SENÃO\n            classificacao ← \"Não Elegível\"\n            statusPromocao ← \"Não atende aos critérios mínimos para promoção\"\n        FIM SE\n    FIM SE\n    \n    ESCREVER \"Classificação: \", classificacao\n    ESCREVER \"Status: \", statusPromocao\n    \n    RETORNAR classificacao, statusPromocao\nFIM\nCasos de teste: funcionário para promoção imediata (4 anos empresa, avaliação 9, formação superior, 3 certificações, 30 anos, R$ 8000), promoção condicional (2.5 anos empresa, avaliação 7.5, formação média, 1 certificação, 28 anos, R$ 5000), e caso especial do plano sucessão (10 anos empresa, avaliação 8, formação pós, 5 certificações, 58 anos, R$ 18000). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\n\n\n\nTable 6.38: Teste 1: Promoção imediata (4 anos, avaliação 9, superior, 3 certificações): resultado: Promoção Imediata\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\nformacaoAvancada\nstatusPromocao\nPróximo Passo\n\n\n\n\nENTRADA\ntempo ← 4, aval ← 9, form ← “superior”, cert ← 3, idade ← 30, sal ← 8000\n-\nindefinido\nindefinido\nindefinido\nRegra especial\n\n\nSE especial\n(idade &gt; 55) E (salario &gt; 15000) → (30 &gt; 55) E (8000 &gt; 15000) → FALSO E FALSO → FALSO\n-\nindefinido\nindefinido\nindefinido\nSENÃO\n\n\nformacaoAvancada\n(form == “superior”) OU (form == “pos”) → (“superior” == “superior”) OU (“superior” == “pos”) → VERDADEIRO OU FALSO → VERDADEIRO\n-\nindefinido\nVERDADEIRO\nindefinido\nPromoção Imediata\n\n\nSE Imediata\n(tempo &gt;= 3) E (aval &gt;= 8) E (formAvancada == VERDADEIRO) E (cert &gt;= 2) → (4 &gt;= 3) E (9 &gt;= 8) E (VERDADEIRO) E (3 &gt;= 2) → VERDADEIRO\n-\n“Promoção Imediata”\nVERDADEIRO\n“Aprovado para promoção no próximo ciclo”\nFIM SE\n\n\nESCREVER\n“Classificação: Promoção Imediata”\n-\n“Promoção Imediata”\nVERDADEIRO\n“Aprovado para promoção no próximo ciclo”\nESCREVER\n\n\nRETORNAR\nclassificacao, statusPromocao\n-\n“Promoção Imediata”\nVERDADEIRO\n“Aprovado para promoção no próximo ciclo”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.39: Teste 2: Promoção condicional (2.5 anos, avaliação 7.5, ensino médio, 1 certificação): resultado: Promoção Condicional\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\nformacaoAvancada\nstatusPromocao\nPróximo Passo\n\n\n\n\nENTRADA\ntempo ← 2.5, aval ← 7.5, form ← “medio”, cert ← 1, idade ← 28, sal ← 5000\n-\nindefinido\nindefinido\nindefinido\nRegra especial\n\n\nSE especial\n(28 &gt; 55) E (5000 &gt; 15000) → FALSO E FALSO → FALSO\n-\nindefinido\nindefinido\nindefinido\nSENÃO\n\n\nformacaoAvancada\n(form == “superior”) OU (form == “pos”) → (“medio” == “superior”) OU (“medio” == “pos”) → FALSO OU FALSO → FALSO\n-\nindefinido\nFALSO\nindefinido\nPromoção Imediata\n\n\nSE Imediata\n(2.5 &gt;= 3) E (7.5 &gt;= 8) E (FALSO) E (1 &gt;= 2) → FALSO E FALSO E FALSO E FALSO → FALSO\n-\nindefinido\nFALSO\nindefinido\nSENÃO SE Condicional\n\n\nSE Condicional\n(tempo &gt;= 2) E (aval &gt;= 7) E ((formAvancada == VERDADEIRO) OU (cert &gt;= 1)) → (2.5 &gt;= 2) E (7.5 &gt;= 7) E ((FALSO) OU (1 &gt;= 1)) → VERDADEIRO E VERDADEIRO E (FALSO OU VERDADEIRO) → VERDADEIRO\n-\n“Promoção Condicional”\nFALSO\n“Aprovado mediante cumprimento de requisitos adicionais”\nFIM SE\n\n\nRETORNAR\nclassificacao, statusPromocao\n-\n“Promoção Condicional”\nFALSO\n“Aprovado mediante cumprimento de requisitos adicionais”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.40: Teste 3: Caso especial - plano sucessão (58 anos, R$ 18000): resultado: Plano Sucessão\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\nformacaoAvancada\nstatusPromocao\nPróximo Passo\n\n\n\n\nENTRADA\ntempo ← 10, aval ← 8, form ← “pos”, cert ← 5, idade ← 58, sal ← 18000\n-\nindefinido\nindefinido\nindefinido\nRegra especial\n\n\nSE especial\n(idade &gt; 55) E (salario &gt; 15000) → (58 &gt; 55) E (18000 &gt; 15000) → VERDADEIRO E VERDADEIRO → VERDADEIRO\n-\n“Plano Sucessão”\nindefinido\n“Preparação para transição de conhecimento”\nESCREVER\n\n\nESCREVER\n“Regra especial aplicada: Plano Sucessão ativado.”\n-\n“Plano Sucessão”\nindefinido\n“Preparação para transição de conhecimento”\nESCREVER\n\n\nESCREVER\n“Classificação: Plano Sucessão”\n-\n“Plano Sucessão”\nindefinido\n“Preparação para transição de conhecimento”\nESCREVER\n\n\nRETORNAR\nclassificacao, statusPromocao\n-\n“Plano Sucessão”\nindefinido\n“Preparação para transição de conhecimento”\nFIM\n\n\n\n\n\n\n\n\n\nTable 6.41: Teste 4: Desenvolvimento necessário (1.5 anos, avaliação 6.5): resultado: Desenvolvimento Necessário\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinha\nCondição/Ação\nResultado\nclassificacao\nformacaoAvancada\nstatusPromocao\nPróximo Passo\n\n\n\n\nENTRADA\ntempo ← 1.5, aval ← 6.5, form ← “superior”, cert ← 0, idade ← 25, sal ← 4000\n-\nindefinido\nindefinido\nindefinido\nRegra especial\n\n\nSE especial\n(25 &gt; 55) E (4000 &gt; 15000) → FALSO E FALSO → FALSO\n-\nindefinido\nindefinido\nindefinido\nSENÃO\n\n\nformacaoAvancada\n(“superior” == “superior”) OU (“superior” == “pos”) → VERDADEIRO OU FALSO → VERDADEIRO\n-\nindefinido\nVERDADEIRO\nindefinido\nVerificações\n\n\nSE Imediata\n(1.5 &gt;= 3) E (6.5 &gt;= 8) E (VERDADEIRO) E (0 &gt;= 2) → FALSO E FALSO E VERDADEIRO E FALSO → FALSO\n-\nindefinido\nVERDADEIRO\nindefinido\nSENÃO SE Condicional\n\n\nSE Condicional\n(1.5 &gt;= 2) E (6.5 &gt;= 7) E ((VERDADEIRO) OU (0 &gt;= 1)) → FALSO E FALSO E (VERDADEIRO OU FALSO) → FALSO\n-\nindefinido\nVERDADEIRO\nindefinido\nSENÃO SE Desenvolvimento\n\n\nSE Desenvolvimento\n(tempo &gt;= 1) E (aval &gt;= 6) → (1.5 &gt;= 1) E (6.5 &gt;= 6) → VERDADEIRO E VERDADEIRO → VERDADEIRO\n-\n“Desenvolvimento Necessário”\nVERDADEIRO\n“Participar de programa de desenvolvimento antes da promoção”\nFIM SE\n\n\nRETORNAR\nclassificacao, statusPromocao\n-\n“Desenvolvimento Necessário”\nVERDADEIRO\n“Participar de programa de desenvolvimento antes da promoção”\nFIM\n\n\n\n\n\n\nEm resumo:\n\n\n\nTable 6.42: Resumo: algoritmo classifica corretamente funcionários para promoção e aplica regra especial do plano sucessão\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaso de Teste\nTempo\nAvaliação\nFormação\nCertificações\nIdade\nSalário\nCritérios Atendidos\nClassificação\n\n\n\n\nPromoção imediata\n4 anos\n9.0\nSuperior\n3\n30\nR$ 8000\nTodos para imediata\nPromoção Imediata\n\n\nPromoção condicional\n2.5 anos\n7.5\nMédio\n1\n28\nR$ 5000\nTempo + avaliação + certificação\nPromoção Condicional\n\n\nPlano sucessão\n10 anos\n8.0\nPós\n5\n58\nR$ 18000\nRegra especial (idade&gt;55 + salário&gt;15k)\nPlano Sucessão\n\n\nDesenvolvimento\n1.5 anos\n6.5\nSuperior\n0\n25\nR$ 4000\nApenas tempo mínimo + avaliação básica\nDesenvolvimento Necessário\n\n\n\n\n\n\nEm seguida, o professor pode apresentar uma versão mais próxima das linguagens de programação, como C++ ou Python, para que os alunos vejam a transição do pseudocódigo para o código real.\nALGORITMO AvaliacaoPromocaoConciso\n\nENTRADA:\n    tempoEmpresa, avaliacaoDesempenho, certificacoesProfissionais, idade, salarioAtual: numerico\n    nivelFormacao: texto\n\nSAÍDA:\n    classificacao: texto\n\nINÍCIO\n    LER tempoEmpresa, avaliacaoDesempenho, nivelFormacao, certificacoesProfissionais, idade, salarioAtual\n    \n    SE (idade &gt; 55) E (salarioAtual &gt; 15000) ENTÃO\n        classificacao ← \"Plano Sucessão\"\n    SENÃO\n        formacaoAvancada ← (nivelFormacao == \"superior\") OU (nivelFormacao == \"pos\")\n        \n        SE (tempoEmpresa &gt;= 3) E (avaliacaoDesempenho &gt;= 8) E formacaoAvancada E (certificacoesProfissionais &gt;= 2) ENTÃO\n            classificacao ← \"Promoção Imediata\"\n        SENÃO SE (tempoEmpresa &gt;= 2) E (avaliacaoDesempenho &gt;= 7) E (formacaoAvancada OU certificacoesProfissionais &gt;= 1) ENTÃO\n            classificacao ← \"Promoção Condicional\"\n        SENÃO SE (tempoEmpresa &gt;= 1) E (avaliacaoDesempenho &gt;= 6) ENTÃO\n            classificacao ← \"Desenvolvimento Necessário\"\n        SENÃO\n            classificacao ← \"Não Elegível\"\n    \n    RETORNAR classificacao\nFIM\n\n\n6.1.3 Atividades Plugged: Programação C++23\nA linguagem C++23 (2) é uma linguagem de programação de propósito geral, que suporta programação procedural, orientada a objetos e genérica. Esta linguagem é adequada à metodologia DAA graças ao artefato sintático goto, que permitirá que o aluno construa a cognição necessária ao entendimento dos laços de repetição antes de utilizar artefatos complexos como for e while.\nAinda estamos no primeiro módulo e o professor precisa ter cuidado com o nível de stress cognitivo ao qual sujeita os alunos. Dessa forma, o uso de ambientes de desenvolvimento online parece ser mais adequado já que remove a necessidade de instalação de aplicativos específicos. Neste caso, estão disponíveis online:\n\nReplit\nOnlineGDB\nC++ OnLine Compiler)\nOnLine CPP\n\nCabe ao professor, testar e escolher entre estas opções, ou qualquer outra disponível online o ambiente mais adequado às suas características e necessidades. Uma vez definido o ambiente, as atividades devem ser baseadas nas atividades anteriores.\nObjetivo: transformar em programas os algoritmos desenvolvidos nas tarefas anteriores.\nMaterial: ambiente de desenvolvimento online, enunciados e pseudocódigo dos exercícios A até N.\nO professor deve começar com um exercício simples para explicar o contexto do ambiente de desenvolvimento online e o básico da linguagem C++. Escolha entre os exercícios da Section 6.1.2 e repetir o ciclo de exercícios baseado na Técnica da Sequência de Fibonacci. A seguir estão os exemplos de uma sequência possível.\nAtenção: os códigos a seguir utiliza o C++23 com a liberdade permitida pelos compiladores modernos. Assim, foi possível fazer todos os exemplos iniciais sem usar as bibliotecas de manipulação de strings além disso, o código irá parecer excessivamente complexo para que já conhece as abstrações de alto nível, mas é necessário para que os alunos possam criar as estruturas cognitivas necessárias ao Raciocínio Algorítmico. Por isso, não usamos as funções para cálculo de seno, cosseno, raiz quadrada, etc..\nG. Sistema de Acesso a Recursos: a biblioteca universitária “Conhecimento Aberto” está testando um novo sistema de acesso online aos seus tomos. Para a fase de testes, existem um nome_Usuário (“admin”) e uma senha (“123”) pré-definidos. O objetivo é que os usuários insiram suas credenciais e o sistema verifique se o login foi bem-sucedido ou falhou. Usando apenas o nome_Usuário (“admin”) e a senha (“123”), desenvolva um algoritmo, na forma de fluxograma, que simule este processo de login.\nO pseudocódigo poderia ser:\nALGORITMO SistemaLoginConciso\n\nCONSTANTES:\n    USUARIO_VALIDO ← \"admin\"\n    SENHA_VALIDA ← \"123\"\n\nENTRADA:\n    nomeUsuário: texto\n    senha: texto\n\nSAÍDA:\n    loginSucesso: booleano\n\nINÍCIO\n    LER nomeUsuário, senha\n    loginSucesso ← (nomeUsuário == USUARIO_VALIDO) E (senha == SENHA_VALIDA)\n    RETORNAR loginSucesso\nFIM\nEste algoritmo pode ser representado com o Listing 6.1.\n\n\n\nListing 6.1\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // CONSTANTES\n    const std::string USUARIO_VALIDO = \"admin\";\n    const std::string SENHA_VALIDA = \"123\";\n    \n    // ENTRADA\n    std::string nomeUsuário, senha;\n    \n    std::cout &lt;&lt; \"Nome de Usuário: \";\n    std::cin &gt;&gt; nomeUsuário;\n    \n    std::cout &lt;&lt; \"Senha: \";\n    std::cin &gt;&gt; senha;\n    \n    // PROCESSAMENTO\n    bool loginSucesso = (nomeUsuário == USUARIO_VALIDO) && (senha == SENHA_VALIDA);\n    \n    // SAÍDA\n    if (loginSucesso) {\n        std::cout &lt;&lt; \"Login bem-sucedido!\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Login falhou.\" &lt;&lt; std::endl;\n    }\n    \n    return 0;\n}\n\n\n\nO Listing 6.1 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB. O professor deve refazer as tabelas de rastreio para este algoritmo, e sugerir casos de teste como: credenciais corretas (admin/123), nome correto com senha errada (admin/456), nome errado com senha correta (user/123), e ambas credenciais erradas (user/456). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\nH. Avaliação de Saúde Ocupacional: em uma clínica de saúde ocupacional, a enfermeira Joana Mãoleve realiza avaliações de rotina, incluindo o cálculo do Índice de Massa Corporal (IMC) dos funcionários. O IMC é calculado pela fórmula IMC = frac{peso}{altura * altura}, na qual o peso é em quilogramas e a altura em metros. Após o cálculo, o IMC é classificado para indicar o estado nutricional. Ajude a enfermeira Joana Mãoleve a criar um algoritmo, na forma de fluxograma, que, dados o peso e a altura de um funcionário, calcule o IMC e o classifique como:\n\nMenor que 18.5: “Abaixo do peso”\nEntre 18.5 e 24.9: “Peso normal”\nEntre 25 e 29.9: “Sobrepeso”\n30 ou mais: “Obesidade”\n\nAnálise: o pseudocódigo poderia ser:\nALGORITMO AvaliacaoIMCConciso\n\nENTRADA:\n    peso: real\n    altura: real\n\nSAÍDA:\n    imc: real\n    classificacao: texto\n\nINÍCIO\n    LER peso, altura\n    imc ← peso / (altura * altura)\n    \n    SE (imc &lt; 18.5) ENTÃO classificacao ← \"Abaixo do peso\"\n    SENÃO SE (imc &lt;= 24.9) ENTÃO classificacao ← \"Peso normal\"  \n    SENÃO SE (imc &lt;= 29.9) ENTÃO classificacao ← \"Sobrepeso\"\n    SENÃO classificacao ← \"Obesidade\"\n    \n    RETORNAR imc, classificacao\nFIM\nEste pseudocódigo pode ser representado com o Listing 6.2.\n\n\n\nListing 6.2\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double peso, altura;\n    \n    std::cout &lt;&lt; \"Peso (kg): \";\n    std::cin &gt;&gt; peso;\n    \n    std::cout &lt;&lt; \"Altura (m): \";\n    std::cin &gt;&gt; altura;\n    \n    // PROCESSAMENTO\n    double imc = peso / (altura * altura);\n    std::string classificacao;\n    \n    if (imc &lt; 18.5) {\n        classificacao = \"Abaixo do peso\";\n    } else if (imc &lt;= 24.9) {\n        classificacao = \"Peso normal\";\n    } else if (imc &lt;= 29.9) {\n        classificacao = \"Sobrepeso\";\n    } else {\n        classificacao = \"Obesidade\";\n    }\n    \n    // SAÍDA\n    std::cout &lt;&lt; \"IMC: \" &lt;&lt; imc &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Classificação: \" &lt;&lt; classificacao &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\nO código Listing 6.1 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nO professor deve refazer as tabelas de rastreio para este algoritmo, e sugerir casos de teste como: IMC abaixo do peso (45kg, 1.70m), IMC normal (70kg, 1.75m), IMC sobrepeso (80kg, 1.70m), e IMC obesidade (100kg, 1.70m). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\nI. Sistema de Avaliação de Crédito Bancário: no banco “Futuro Seguro”, o analista Roberto precisa automatizar a aprovação de empréstimos pessoais. O sistema deve considerar múltiplos critérios: renda_mensal, idade, score_credito e tempo_emprego (em anos). As regras são: (1) Renda mínima de 2000 reais; (2) Idade entre 21 e 65 anos; (3) Score de crédito de pelo menos 600; (4) Tempo de emprego de pelo menos 2 anos. Se todos os critérios forem atendidos, calcular o valor_maximo_emprestimo como renda_mensal × 10. Se o score for maior que 750, aplicar bônus de 20% no valor máximo. Se algum critério não for atendido, negar o empréstimo. Crie um fluxograma que implemente este sistema de avaliação.\nAnálise: o pseudocódigo poderia ser:\nALGORITMO AvaliacaoCreditoBancarioConciso\n\nENTRADA:\n    rendaMensal, idade, scoreCredito, tempoEmprego: numerico\n\nSAÍDA:\n    aprovado: booleano\n    valorMaximoEmprestimo: real\n\nINÍCIO\n    LER rendaMensal, idade, scoreCredito, tempoEmprego\n    \n    aprovado ← (rendaMensal &gt;= 2000) E (idade &gt;= 21 E idade &lt;= 65) E \n               (scoreCredito &gt;= 600) E (tempoEmprego &gt;= 2)\n    \n    SE aprovado ENTÃO\n        valorMaximoEmprestimo ← rendaMensal * 10\n        SE (scoreCredito &gt; 750) ENTÃO\n            valorMaximoEmprestimo ← valorMaximoEmprestimo * 1.2\n        valorMaximoEmprestimo ← valorMaximoEmprestimo\n    SENÃO\n        valorMaximoEmprestimo ← 0\n    \n    RETORNAR aprovado, valorMaximoEmprestimo\nFIM\nEste pseudocódigo pode ser representado com o Listing 6.3.\n\n\n\nListing 6.3\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double rendaMensal, idade, scoreCredito, tempoEmprego;\n    \n    std::cout &lt;&lt; \"Renda mensal (R$): \";\n    std::cin &gt;&gt; rendaMensal;\n    \n    std::cout &lt;&lt; \"Idade: \";\n    std::cin &gt;&gt; idade;\n    \n    std::cout &lt;&lt; \"Score de crédito: \";\n    std::cin &gt;&gt; scoreCredito;\n    \n    std::cout &lt;&lt; \"Tempo de emprego (anos): \";\n    std::cin &gt;&gt; tempoEmprego;\n    \n    // PROCESSAMENTO\n    bool aprovado = (rendaMensal &gt;= 2000) && (idade &gt;= 21 && idade &lt;= 65) && \n                    (scoreCredito &gt;= 600) && (tempoEmprego &gt;= 2);\n    \n    double valorMaximoEmprestimo;\n    \n    if (aprovado) {\n        valorMaximoEmprestimo = rendaMensal * 10;\n        if (scoreCredito &gt; 750) {\n            valorMaximoEmprestimo = valorMaximoEmprestimo * 1.2;\n        }\n        valorMaximoEmprestimo = valorMaximoEmprestimo;\n    } else {\n        valorMaximoEmprestimo = 0;\n    }\n    \n    // SAÍDA\n    if (aprovado) {\n        std::cout &lt;&lt; \"Empréstimo APROVADO\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Valor máximo: R$ \" &lt;&lt; valorMaximoEmprestimo &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Empréstimo NEGADO\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Critérios não atendidos\" &lt;&lt; std::endl;\n    }\n    \n    return 0;\n}\n\n\n\nO código Listing 6.3 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nO professor deve validar o código usando: cliente aprovado sem bônus (R$ 5000 renda, 35 anos, score 700, 5 anos emprego), cliente aprovado com bônus (R$ 8000 renda, 28 anos, score 800, 3 anos emprego), negação por renda baixa (R$ 1500 renda, 30 anos, score 650, 3 anos emprego), e negação por múltiplos critérios (R$ 1800 renda, 19 anos, score 550, 1 ano emprego). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\nJ. Classificação de Emergências Hospitalares: no Hospital “Santa Esperança”, a enfermeira Carla utiliza o protocolo de Manchester para classificar a urgência dos pacientes. O sistema recebe temperatura, pressao_sistolica, frequencia_cardiaca, nivel_dor (escala 0-10) e idade. As classificações são: Emergência (vermelho): temperatura &gt; 39°C OU pressão &lt; 90 OU &gt; 180 OU frequência &lt; 50 OU &gt; 120; Muito Urgente (laranja): temperatura entre 38-39°C OU pressão entre 90-100 OU 160-180 OU dor &gt; 7; Urgente (amarelo): temperatura entre 37.5-38°C OU dor entre 4-7 OU idade &gt; 65 anos; Pouco Urgente (verde): demais casos. Se múltiplas condições se aplicarem, usar a classificação mais alta. Desenvolva o algoritmo para esta triagem.\nAnálise: o pseudocódigo poderia ser:\nALGORITMO ClassificacaoEmergenciaConcisa\n\nENTRADA:\n    temperatura, pressaoSistolica, frequenciaCardiaca, nivelDor, idade: numerico\n\nSAÍDA:\n    classificacao: texto\n\nINÍCIO\n    LER temperatura, pressaoSistolica, frequenciaCardiaca, nivelDor, idade\n    \n    SE (temperatura &gt; 39) OU (pressaoSistolica &lt; 90 OU pressaoSistolica &gt; 180) OU \n       (frequenciaCardiaca &lt; 50 OU frequenciaCardiaca &gt; 120) ENTÃO\n        classificacao ← \"Emergência (vermelho)\"\n    SENÃO SE (temperatura &gt;= 38 E temperatura &lt;= 39) OU \n             (pressaoSistolica &gt;= 90 E pressaoSistolica &lt;= 100) OU\n             (pressaoSistolica &gt;= 160 E pressaoSistolica &lt;= 180) OU (nivelDor &gt; 7) ENTÃO\n        classificacao ← \"Muito Urgente (laranja)\"\n    SENÃO SE (temperatura &gt;= 37.5 E temperatura &lt; 38) OU (nivelDor &gt;= 4 E nivelDor &lt;= 7) OU \n             (idade &gt; 65) ENTÃO\n        classificacao ← \"Urgente (amarelo)\"\n    SENÃO\n        classificacao ← \"Pouco Urgente (verde)\"\n    \n    RETORNAR classificacao\nFIM\nO algoritmo pode ser representado com o Listing 6.4.\n\n\n\nListing 6.4\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double temperatura, pressaoSistolica, frequenciaCardiaca, nivelDor, idade;\n    \n    std::cout &lt;&lt; \"Temperatura (°C): \";\n    std::cin &gt;&gt; temperatura;\n    \n    std::cout &lt;&lt; \"Pressão sistólica (mmHg): \";\n    std::cin &gt;&gt; pressaoSistolica;\n    \n    std::cout &lt;&lt; \"Frequência cardíaca (bpm): \";\n    std::cin &gt;&gt; frequenciaCardiaca;\n    \n    std::cout &lt;&lt; \"Nível de dor (0-10): \";\n    std::cin &gt;&gt; nivelDor;\n    \n    std::cout &lt;&lt; \"Idade (anos): \";\n    std::cin &gt;&gt; idade;\n    \n    // PROCESSAMENTO\n    std::string classificacao;\n    \n    if ((temperatura &gt; 39) || (pressaoSistolica &lt; 90 || pressaoSistolica &gt; 180) || \n        (frequenciaCardiaca &lt; 50 || frequenciaCardiaca &gt; 120)) {\n        classificacao = \"Emergência (vermelho)\";\n    } else if ((temperatura &gt;= 38 && temperatura &lt;= 39) || \n               (pressaoSistolica &gt;= 90 && pressaoSistolica &lt;= 100) ||\n               (pressaoSistolica &gt;= 160 && pressaoSistolica &lt;= 180) || (nivelDor &gt; 7)) {\n        classificacao = \"Muito Urgente (laranja)\";\n    } else if ((temperatura &gt;= 37.5 && temperatura &lt; 38) || (nivelDor &gt;= 4 && nivelDor &lt;= 7) || \n               (idade &gt; 65)) {\n        classificacao = \"Urgente (amarelo)\";\n    } else {\n        classificacao = \"Pouco Urgente (verde)\";\n    }\n    \n    // SAÍDA\n    std::cout &lt;&lt; \"Classificação: \" &lt;&lt; classificacao &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\nO código Listing 6.4 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nO professor pode verificar os seguintes casos para validação do algoritmo: emergência por temperatura alta (40°C temperatura, 120 pressão, 80 frequência cardíaca, dor 3, 45 anos), muito urgente por dor severa (37°C temperatura, 130 pressão, 70 frequência cardíaca, dor 8, 30 anos), urgente por idade avançada (36.5°C temperatura, 130 pressão, 70 frequência cardíaca, dor 2, 70 anos), e pouco urgente para caso normal (36.5°C temperatura, 120 pressão, 70 frequência cardíaca, dor 2, 30 anos).\nK. Sistema de Precificação Dinâmica: a empresa de transporte “MoveFast” precisa calcular tarifas dinâmicas. O sistema recebe distancia_km, horario (0-23), dia_semana (1-7), condicoes_clima (“normal”, “chuva”, “tempestade”) e demanda_regiao (“baixa”, “media”, “alta”). A tarifa base é distancia_km × 2.50. Aplicar multiplicadores: horários de pico (7-9h, 17-19h): ×1.5; fins de semana (6-7): ×1.2; chuva: ×1.3; tempestade: ×1.8; demanda alta: ×1.4; demanda media: ×1.1. Se for horário de pico E fim de semana E tempestade E demanda alta, aplicar desconto de 10% no valor final (para evitar preços abusivos). Crie o fluxograma deste sistema de precificação.\nAnálise: o pseudocódigo:\nALGORITMO PrecificacaoDinamicaConcisa\n\nENTRADA:\n    distanciaKm, horario, diaSemana: numerico\n    condicoesClima, demandaRegiao: texto\n\nSAÍDA:\n    tarifaFinal: real\n\nINÍCIO\n    LER distanciaKm, horario, diaSemana, condicoesClima, demandaRegiao\n    \n    tarifaFinal ← distanciaKm * 2.50\n    horarioPico ← ((horario &gt;= 7 E horario &lt;= 9) OU (horario &gt;= 17 E horario &lt;= 19))\n    fimSemana ← (diaSemana == 6 OU diaSemana == 7)\n    tempestade ← (condicoesClima == \"tempestade\")\n    demandaAlta ← (demandaRegiao == \"alta\")\n    \n    SE horarioPico ENTÃO tarifaFinal ← tarifaFinal * 1.5\n    SE fimSemana ENTÃO tarifaFinal ← tarifaFinal * 1.2\n    SE (condicoesClima == \"chuva\") ENTÃO tarifaFinal ← tarifaFinal * 1.3\n    SE tempestade ENTÃO tarifaFinal ← tarifaFinal * 1.8\n    SE (demandaRegiao == \"media\") ENTÃO tarifaFinal ← tarifaFinal * 1.1\n    SE demandaAlta ENTÃO tarifaFinal ← tarifaFinal * 1.4\n    SE (horarioPico E fimSemana E tempestade E demandaAlta) ENTÃO tarifaFinal ← tarifaFinal * 0.9\n    \n    RETORNAR tarifaFinal\nFIM\nO pseucódigo pode ser representado com o Listing 6.5.\n\n\n\nListing 6.5\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double distanciaKm, horario, diaSemana;\n    std::string condicoesClima, demandaRegiao;\n    \n    std::cout &lt;&lt; \"Distância (km): \";\n    std::cin &gt;&gt; distanciaKm;\n    \n    std::cout &lt;&lt; \"Horário (0-23): \";\n    std::cin &gt;&gt; horario;\n    \n    std::cout &lt;&lt; \"Dia da semana (1-7): \";\n    std::cin &gt;&gt; diaSemana;\n    \n    std::cout &lt;&lt; \"Condições do clima (normal/chuva/tempestade): \";\n    std::cin &gt;&gt; condicoesClima;\n    \n    std::cout &lt;&lt; \"Demanda da região (baixa/media/alta): \";\n    std::cin &gt;&gt; demandaRegiao;\n    \n    // PROCESSAMENTO\n    double tarifaFinal = distanciaKm * 2.50;\n    \n    bool horarioPico = ((horario &gt;= 7 && horario &lt;= 9) || (horario &gt;= 17 && horario &lt;= 19));\n    bool fimSemana = (diaSemana == 6 || diaSemana == 7);\n    bool tempestade = (condicoesClima == \"tempestade\");\n    bool demandaAlta = (demandaRegiao == \"alta\");\n    \n    if (horarioPico) {\n        tarifaFinal = tarifaFinal * 1.5;\n    }\n    \n    if (fimSemana) {\n        tarifaFinal = tarifaFinal * 1.2;\n    }\n    \n    if (condicoesClima == \"chuva\") {\n        tarifaFinal = tarifaFinal * 1.3;\n    }\n    \n    if (tempestade) {\n        tarifaFinal = tarifaFinal * 1.8;\n    }\n    \n    if (demandaRegiao == \"media\") {\n        tarifaFinal = tarifaFinal * 1.1;\n    }\n    \n    if (demandaAlta) {\n        tarifaFinal = tarifaFinal * 1.4;\n    }\n    \n    if (horarioPico && fimSemana && tempestade && demandaAlta) {\n        tarifaFinal = tarifaFinal * 0.9;\n    }\n    \n    // SAÍDA\n    std::cout &lt;&lt; \"Tarifa final: R$ \" &lt;&lt; tarifaFinal &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\nO código Listing 6.5 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nNeste caso, o professor pode sugerir os seguintes casos para validação do algoritmo: tarifa normal sem multiplicadores (10km, 14h quarta-feira, clima normal, demanda baixa), tarifa com múltiplos multiplicadores (5km, 8h sábado, chuva, demanda média), e o caso especial de desconto para evitar preços abusivos (8km, 18h domingo, tempestade, demanda alta).\nL. Avaliação de Risco de Investimento: a corretora “InvestSmart”, gerenciada pela analista Dra. Patricia, desenvolveu um sistema para classificar perfis de investidor. O sistema recebe idade, renda_mensal, patrimonio_liquido, experiencia_investimentos (anos), tolerancia_perda (percentual) e objetivo_prazo (“curto”, “medio”, “longo”). O perfil é determinado por pontuação: idade &lt; 30 (+2 pontos), 30-50 (+1 ponto), &gt;50 (0 pontos); renda &gt; 10000 (+2), 5000-10000 (+1), &lt;5000 (0); patrimônio &gt; 100000 (+2), 50000-100000 (+1), &lt;50000 (0); experiência &gt; 5 anos (+2), 2-5 anos (+1), &lt;2 anos (0); tolerância &gt; 20% (+2), 10-20% (+1), &lt;10% (0); prazo longo (+2), médio (+1), curto (0). Classificação: 0-4 pontos: “Conservador”; 5-8: “Moderado”; 9-12: “Arrojado”. Adicionalmente, se idade &gt; 60 E tolerância &lt; 15%, forçar “Conservador” independente da pontuação. Desenvolva este algoritmo de classificação.\nAnálise: o pseudocódigo poderia ser:\nALGORITMO AvaliacaoPerfilInvestidorConciso\n\nENTRADA:\n    idade, rendaMensal, patrimonioLiquido, experienciaInvestimentos, toleranciaPerda: numerico\n    objetivoPrazo: texto\n\nSAÍDA:\n    pontuacaoTotal: inteiro\n    perfilInvestidor: texto\n\nINÍCIO\n    LER idade, rendaMensal, patrimonioLiquido, experienciaInvestimentos, toleranciaPerda, objetivoPrazo\n    \n    pontuacaoTotal ← 0\n    SE (idade &lt; 30) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (idade &lt;= 50) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (rendaMensal &gt; 10000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (rendaMensal &gt;= 5000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (patrimonioLiquido &gt; 100000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (patrimonioLiquido &gt;= 50000) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (experienciaInvestimentos &gt; 5) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (experienciaInvestimentos &gt;= 2) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (toleranciaPerda &gt; 20) ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (toleranciaPerda &gt;= 10) ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (objetivoPrazo == \"longo\") ENTÃO pontuacaoTotal ← pontuacaoTotal + 2\n    SENÃO SE (objetivoPrazo == \"medio\") ENTÃO pontuacaoTotal ← pontuacaoTotal + 1\n    \n    SE (pontuacaoTotal &lt;= 4) ENTÃO perfilInvestidor ← \"Conservador\"\n    SENÃO SE (pontuacaoTotal &lt;= 8) ENTÃO perfilInvestidor ← \"Moderado\"\n    SENÃO perfilInvestidor ← \"Arrojado\"\n    \n    SE (idade &gt; 60) E (toleranciaPerda &lt; 15) ENTÃO perfilInvestidor ← \"Conservador\"\n    \n    RETORNAR pontuacaoTotal, perfilInvestidor\nFIM\nO pseudocódigo pode ser representado com o Listing 6.6.\n\n\n\nListing 6.6\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double idade, rendaMensal, patrimonioLiquido, experienciaInvestimentos, toleranciaPerda;\n    std::string objetivoPrazo;\n    \n    std::cout &lt;&lt; \"Idade: \";\n    std::cin &gt;&gt; idade;\n    \n    std::cout &lt;&lt; \"Renda mensal (R$): \";\n    std::cin &gt;&gt; rendaMensal;\n    \n    std::cout &lt;&lt; \"Patrimônio líquido (R$): \";\n    std::cin &gt;&gt; patrimonioLiquido;\n    \n    std::cout &lt;&lt; \"Experiência em investimentos (anos): \";\n    std::cin &gt;&gt; experienciaInvestimentos;\n    \n    std::cout &lt;&lt; \"Tolerância à perda (%): \";\n    std::cin &gt;&gt; toleranciaPerda;\n    \n    std::cout &lt;&lt; \"Objetivo de prazo (curto/medio/longo): \";\n    std::cin &gt;&gt; objetivoPrazo;\n    \n    // PROCESSAMENTO\n    int pontuacaoTotal = 0;\n    \n    if (idade &lt; 30) {\n        pontuacaoTotal = pontuacaoTotal + 2;\n    } else if (idade &lt;= 50) {\n        pontuacaoTotal = pontuacaoTotal + 1;\n    }\n    \n    if (rendaMensal &gt; 10000) {\n        pontuacaoTotal = pontuacaoTotal + 2;\n    } else if (rendaMensal &gt;= 5000) {\n        pontuacaoTotal = pontuacaoTotal + 1;\n    }\n    \n    if (patrimonioLiquido &gt; 100000) {\n        pontuacaoTotal = pontuacaoTotal + 2;\n    } else if (patrimonioLiquido &gt;= 50000) {\n        pontuacaoTotal = pontuacaoTotal + 1;\n    }\n    \n    if (experienciaInvestimentos &gt; 5) {\n        pontuacaoTotal = pontuacaoTotal + 2;\n    } else if (experienciaInvestimentos &gt;= 2) {\n        pontuacaoTotal = pontuacaoTotal + 1;\n    }\n    \n    if (toleranciaPerda &gt; 20) {\n        pontuacaoTotal = pontuacaoTotal + 2;\n    } else if (toleranciaPerda &gt;= 10) {\n        pontuacaoTotal = pontuacaoTotal + 1;\n    }\n    \n    if (objetivoPrazo == \"longo\") {\n        pontuacaoTotal = pontuacaoTotal + 2;\n    } else if (objetivoPrazo == \"medio\") {\n        pontuacaoTotal = pontuacaoTotal + 1;\n    }\n    \n    std::string perfilInvestidor;\n    \n    if (pontuacaoTotal &lt;= 4) {\n        perfilInvestidor = \"Conservador\";\n    } else if (pontuacaoTotal &lt;= 8) {\n        perfilInvestidor = \"Moderado\";\n    } else {\n        perfilInvestidor = \"Arrojado\";\n    }\n    \n    if ((idade &gt; 60) && (toleranciaPerda &lt; 15)) {\n        perfilInvestidor = \"Conservador\";\n    }\n    \n    // SAÍDA\n    std::cout &lt;&lt; \"Pontuação total: \" &lt;&lt; pontuacaoTotal &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Perfil do investidor: \" &lt;&lt; perfilInvestidor &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\nO código Listing 6.6 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nO professor pode sugerir os seguintes casos para validação do algoritmo: jovem investidor arrojado (25 anos, R$ 12000 renda, R$ 150000 patrimônio, 3 anos experiência, 25% tolerância, prazo longo), investidor de perfil moderado (40 anos, R$ 7000 renda, R$ 70000 patrimônio, 4 anos experiência, 15% tolerância, prazo médio), e o caso especial de idoso forçado a conservador (65 anos, R$ 15000 renda, R$ 200000 patrimônio, 8 anos experiência, 12% tolerância, prazo longo).\nM. Sistema de Controle de Qualidade Industrial: na fábrica “Precisão Total”, o engenheiro Carlos implementa controle de qualidade para peças metálicas. O sistema mede diametro_mm, peso_gramas, dureza_hrc, temperatura_teste e lote_producao. Especificações: diâmetro 50mm ±0.5mm; peso 200g ±10g; dureza 45-55 HRC; temperatura teste entre 20-25°C. Classificação de defeitos: Classe A (aprovado): todas especificações atendidas; Classe B (aprovado com ressalvas): máximo 1 parâmetro fora da especificação E desvio não superior a 10% do limite; Classe C (retrabalho): 2 parâmetros fora OU 1 parâmetro com desvio &gt; 10% mas ≤ 20%; Classe D (refugo): 3+ parâmetros fora OU qualquer desvio &gt; 20%. Adicionalmente, lotes de produção pares têm tolerância aumentada em 5% para todos os parâmetros. Crie o fluxograma para este sistema de controle de qualidade.\nAnálise: o pseudocódigo:\nALGORITMO ControleQualidadeIndustrialConciso\n\nENTRADA:\n    diametroMm, pesoGramas, durezaHrc, temperaturaTeste: real\n    loteProducao: inteiro\n\nSAÍDA:\n    classeQualidade: texto\n\nINÍCIO\n    LER diametroMm, pesoGramas, durezaHrc, temperaturaTeste, loteProducao\n    \n    toleranciaExtra ← SE (loteProducao % 2 == 0) ENTÃO 1.05 SENÃO 1.0\n    \n    diamMin ← 49.5 * toleranciaExtra\n    diamMax ← 50.5 * toleranciaExtra\n    pesoMin ← 190 * toleranciaExtra\n    pesoMax ← 210 * toleranciaExtra\n    durezaMin ← 45 * toleranciaExtra\n    durezaMax ← 55 * toleranciaExtra\n    tempMin ← 20 * toleranciaExtra\n    tempMax ← 25 * toleranciaExtra\n    \n    parametrosForaEspec ← 0\n    maxDesvio ← 0\n    \n    SE (diametroMm &lt; diamMin) OU (diametroMm &gt; diamMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (diametroMm &lt; diamMin) ENTÃO (diamMin - diametroMm) / 50 * 100 SENÃO (diametroMm - diamMax) / 50 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (pesoGramas &lt; pesoMin) OU (pesoGramas &gt; pesoMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (pesoGramas &lt; pesoMin) ENTÃO (pesoMin - pesoGramas) / 200 * 100 SENÃO (pesoGramas - pesoMax) / 200 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (durezaHrc &lt; durezaMin) OU (durezaHrc &gt; durezaMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (durezaHrc &lt; durezaMin) ENTÃO (durezaMin - durezaHrc) / 50 * 100 SENÃO (durezaHrc - durezaMax) / 50 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (temperaturaTeste &lt; tempMin) OU (temperaturaTeste &gt; tempMax) ENTÃO\n        parametrosForaEspec ← parametrosForaEspec + 1\n        desvio ← SE (temperaturaTeste &lt; tempMin) ENTÃO (tempMin - temperaturaTeste) / 22.5 * 100 SENÃO (temperaturaTeste - tempMax) / 22.5 * 100\n        SE (desvio &gt; maxDesvio) ENTÃO maxDesvio ← desvio\n    \n    SE (parametrosForaEspec == 0) ENTÃO classeQualidade ← \"Classe A\"\n    SENÃO SE (parametrosForaEspec == 1) E (maxDesvio &lt;= 10) ENTÃO classeQualidade ← \"Classe B\"\n    SENÃO SE (parametrosForaEspec == 2) OU (parametrosForaEspec == 1 E maxDesvio &lt;= 20) ENTÃO classeQualidade ← \"Classe C\"\n    SENÃO classeQualidade ← \"Classe D\"\n    \n    RETORNAR classeQualidade\nFIM\nO pseudocódigo pode ser representado com o Listing 6.7.\n\n\n\nListing 6.7\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double diametroMm, pesoGramas, durezaHrc, temperaturaTeste;\n    int loteProducao;\n    \n    std::cout &lt;&lt; \"Diâmetro (mm): \";\n    std::cin &gt;&gt; diametroMm;\n    \n    std::cout &lt;&lt; \"Peso (gramas): \";\n    std::cin &gt;&gt; pesoGramas;\n    \n    std::cout &lt;&lt; \"Dureza (HRC): \";\n    std::cin &gt;&gt; durezaHrc;\n    \n    std::cout &lt;&lt; \"Temperatura de teste (°C): \";\n    std::cin &gt;&gt; temperaturaTeste;\n    \n    std::cout &lt;&lt; \"Lote de produção: \";\n    std::cin &gt;&gt; loteProducao;\n    \n    // PROCESSAMENTO\n    double toleranciaExtra;\n    if (loteProducao % 2 == 0) {\n        toleranciaExtra = 1.05;\n    } else {\n        toleranciaExtra = 1.0;\n    }\n    \n    double diamMin = 49.5 * toleranciaExtra;\n    double diamMax = 50.5 * toleranciaExtra;\n    double pesoMin = 190 * toleranciaExtra;\n    double pesoMax = 210 * toleranciaExtra;\n    double durezaMin = 45 * toleranciaExtra;\n    double durezaMax = 55 * toleranciaExtra;\n    double tempMin = 20 * toleranciaExtra;\n    double tempMax = 25 * toleranciaExtra;\n    \n    int parametrosForaEspec = 0;\n    double maxDesvio = 0;\n    \n    if ((diametroMm &lt; diamMin) || (diametroMm &gt; diamMax)) {\n        parametrosForaEspec = parametrosForaEspec + 1;\n        double desvio;\n        if (diametroMm &lt; diamMin) {\n            desvio = (diamMin - diametroMm) / 50 * 100;\n        } else {\n            desvio = (diametroMm - diamMax) / 50 * 100;\n        }\n        if (desvio &gt; maxDesvio) {\n            maxDesvio = desvio;\n        }\n    }\n    \n    if ((pesoGramas &lt; pesoMin) || (pesoGramas &gt; pesoMax)) {\n        parametrosForaEspec = parametrosForaEspec + 1;\n        double desvio;\n        if (pesoGramas &lt; pesoMin) {\n            desvio = (pesoMin - pesoGramas) / 200 * 100;\n        } else {\n            desvio = (pesoGramas - pesoMax) / 200 * 100;\n        }\n        if (desvio &gt; maxDesvio) {\n            maxDesvio = desvio;\n        }\n    }\n    \n    if ((durezaHrc &lt; durezaMin) || (durezaHrc &gt; durezaMax)) {\n        parametrosForaEspec = parametrosForaEspec + 1;\n        double desvio;\n        if (durezaHrc &lt; durezaMin) {\n            desvio = (durezaMin - durezaHrc) / 50 * 100;\n        } else {\n            desvio = (durezaHrc - durezaMax) / 50 * 100;\n        }\n        if (desvio &gt; maxDesvio) {\n            maxDesvio = desvio;\n        }\n    }\n    \n    if ((temperaturaTeste &lt; tempMin) || (temperaturaTeste &gt; tempMax)) {\n        parametrosForaEspec = parametrosForaEspec + 1;\n        double desvio;\n        if (temperaturaTeste &lt; tempMin) {\n            desvio = (tempMin - temperaturaTeste) / 22.5 * 100;\n        } else {\n            desvio = (temperaturaTeste - tempMax) / 22.5 * 100;\n        }\n        if (desvio &gt; maxDesvio) {\n            maxDesvio = desvio;\n        }\n    }\n    \n    std::string classeQualidade;\n    \n    if (parametrosForaEspec == 0) {\n        classeQualidade = \"Classe A\";\n    } else if ((parametrosForaEspec == 1) && (maxDesvio &lt;= 10)) {\n        classeQualidade = \"Classe B\";\n    } else if ((parametrosForaEspec == 2) || (parametrosForaEspec == 1 && maxDesvio &lt;= 20)) {\n        classeQualidade = \"Classe C\";\n    } else {\n        classeQualidade = \"Classe D\";\n    }\n    \n    // SAÍDA\n    std::cout &lt;&lt; \"Parâmetros fora de especificação: \" &lt;&lt; parametrosForaEspec &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Desvio máximo: \" &lt;&lt; maxDesvio &lt;&lt; \"%\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Classificação: \" &lt;&lt; classeQualidade &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\nO código Listing 6.7 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nO professor pode sugerir os seguintes casos para validação do algoritmo: peça perfeita dentro de todas as especificações (50.0mm diâmetro, 200g peso, 50 HRC dureza, 22°C temperatura, lote 101 ímpar), lote par com pequeno desvio no diâmetro (51.0mm diâmetro, 200g peso, 50 HRC dureza, 22°C temperatura, lote 102 par), e peça defeituosa com múltiplos parâmetros fora de especificação (48.0mm diâmetro, 170g peso, 40 HRC dureza, 30°C temperatura, lote 103 ímpar). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\nN. Sistema de Avaliação para Promoção Corporativa: na empresa “Crescer Juntos”, a gestora de RH Dra. Ana Carolina precisa automatizar o processo de avaliação para promoções. O sistema deve analisar múltiplos critérios dos funcionários: tempo_empresa (anos), avaliacao_desempenho (1-10), nivel_formacao (“medio”, “superior”, “pos”), certificacoes_profissionais (quantidade), idade e salario_atual. As regras de classificação são: Promoção Imediata: tempo ≥ 3 anos E avaliação ≥ 8 E (formação superior OU pós) E certificações ≥ 2; Promoção Condicional: tempo ≥ 2 anos E avaliação ≥ 7 E pelo menos um dos critérios extras (formação superior/pós OU certificações ≥ 1); Desenvolvimento Necessário: tempo ≥ 1 ano E avaliação ≥ 6; Não Elegível: demais casos. Adicionalmente, se idade &gt; 55 anos E salário &gt; R$ 15000, aplicar regra especial “Plano Sucessão” independente dos outros critérios. Desenvolva este algoritmo de classificação.\nAnálise: o pseudocódigo:\nALGORITMO AvaliacaoPromocaoConciso\n\nENTRADA:\n    tempoEmpresa, avaliacaoDesempenho, certificacoesProfissionais, idade, salarioAtual: numerico\n    nivelFormacao: texto\n\nSAÍDA:\n    classificacao: texto\n\nINÍCIO\n    LER tempoEmpresa, avaliacaoDesempenho, nivelFormacao, certificacoesProfissionais, idade, salarioAtual\n    \n    SE (idade &gt; 55) E (salarioAtual &gt; 15000) ENTÃO\n        classificacao ← \"Plano Sucessão\"\n    SENÃO\n        formacaoAvancada ← (nivelFormacao == \"superior\") OU (nivelFormacao == \"pos\")\n        \n        SE (tempoEmpresa &gt;= 3) E (avaliacaoDesempenho &gt;= 8) E formacaoAvancada E (certificacoesProfissionais &gt;= 2) ENTÃO\n            classificacao ← \"Promoção Imediata\"\n        SENÃO SE (tempoEmpresa &gt;= 2) E (avaliacaoDesempenho &gt;= 7) E (formacaoAvancada OU certificacoesProfissionais &gt;= 1) ENTÃO\n            classificacao ← \"Promoção Condicional\"\n        SENÃO SE (tempoEmpresa &gt;= 1) E (avaliacaoDesempenho &gt;= 6) ENTÃO\n            classificacao ← \"Desenvolvimento Necessário\"\n        SENÃO\n            classificacao ← \"Não Elegível\"\n    \n    RETORNAR classificacao\nFIM\nO pseudocódigo pode ser representado com o Listing 6.8.\n\n\n\nListing 6.8\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double tempoEmpresa, avaliacaoDesempenho, certificacoesProfissionais, idade, salarioAtual;\n    std::string nivelFormacao;\n    \n    std::cout &lt;&lt; \"Tempo na empresa (anos): \";\n    std::cin &gt;&gt; tempoEmpresa;\n    \n    std::cout &lt;&lt; \"Avaliação de desempenho (1-10): \";\n    std::cin &gt;&gt; avaliacaoDesempenho;\n    \n    std::cout &lt;&lt; \"Nível de formação (medio/superior/pos): \";\n    std::cin &gt;&gt; nivelFormacao;\n    \n    std::cout &lt;&lt; \"Certificações profissionais (quantidade): \";\n    std::cin &gt;&gt; certificacoesProfissionais;\n    \n    std::cout &lt;&lt; \"Idade: \";\n    std::cin &gt;&gt; idade;\n    \n    std::cout &lt;&lt; \"Salário atual (R$): \";\n    std::cin &gt;&gt; salarioAtual;\n    \n    // PROCESSAMENTO\n    std::string classificacao;\n    \n    if ((idade &gt; 55) && (salarioAtual &gt; 15000)) {\n        classificacao = \"Plano Sucessão\";\n    } else {\n        bool formacaoAvancada = (nivelFormacao == \"superior\") || (nivelFormacao == \"pos\");\n        \n        if ((tempoEmpresa &gt;= 3) && (avaliacaoDesempenho &gt;= 8) && formacaoAvancada && (certificacoesProfissionais &gt;= 2)) {\n            classificacao = \"Promoção Imediata\";\n        } else if ((tempoEmpresa &gt;= 2) && (avaliacaoDesempenho &gt;= 7) && (formacaoAvancada || certificacoesProfissionais &gt;= 1)) {\n            classificacao = \"Promoção Condicional\";\n        } else if ((tempoEmpresa &gt;= 1) && (avaliacaoDesempenho &gt;= 6)) {\n            classificacao = \"Desenvolvimento Necessário\";\n        } else {\n            classificacao = \"Não Elegível\";\n        }\n    }\n    \n    // SAÍDA\n    std::cout &lt;&lt; \"Classificação: \" &lt;&lt; classificacao &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\nO código Listing 6.8 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nCasos de teste: funcionário para promoção imediata (4 anos empresa, avaliação 9, formação superior, 3 certificações, 30 anos, R$ 8000), promoção condicional (2.5 anos empresa, avaliação 7.5, formação média, 1 certificação, 28 anos, R$ 5000), e caso especial do plano sucessão (10 anos empresa, avaliação 8, formação pós, 5 certificações, 58 anos, R$ 18000). O professor pode pedir que os alunos verifiquem se o pseudocódigo funciona corretamente para esses casos usando as Tabelas de Rastreio.\n\n\n6.1.4 Atividade Unplugged: Estruturas de Repetição\nNas primeiras três seções exploramos à Metodologia DAAD e a construção de algoritmos com estruturas condicionais. Nesta seção vamos introduzir os conceitos relacionados a laços de repetição completando as três estruturas básicas da programação imperativa: atribuição, decisão e repetição. Abaixo estão sete problemas que envolvem laços de repetição e que podem ser resolvidos com fluxogramas e pseudocódigo.\nO primeiro exercício deve ser completamente resolvido pelo professor, no quadro.\nA1. Geração de Relatórios Financeiros: a contabilidade da empresa “Números Certos” precisa de um sistema que gere rapidamente relatórios de multiplicação para auditorias internas. O Sr. Costa, o contador, frequentemente precisa visualizar a “tabuada” de um determinado número (multiplicado de 1 a 10). Projete um algoritmo que, dado um número inteiro, imprima sua tabuada completa.\nAnálise: o fluxograma pode ser representado pelo fluxo da Figure 6.8.\n\n\n\n\n\n\nFigure 6.8: Fluxograma para representar o problema Geração de Relatórios Financeiros.\n\n\n\nO pseudocódigo pode ser representado como:\nALGORITMO GeracaoTabuadaConciso\n\nENTRADA:\n    numero: inteiro\n\nSAÍDA:\n    resultado: inteiro\n\nINÍCIO\n    LER numero\n    contador ← 1\n    \nETIQUETA LOOP:\n    resultado ← numero * contador\n    ESCREVER numero, \" x \", contador, \" = \", resultado\n    contador ← contador + 1\n    SE contador &lt;= 10 ENTÃO IR PARA LOOP\n    \nFIM\nO pseudocódigo pode ser representado com o Listing 6.9.\n\n\n\nListing 6.9\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    int numero, contador;\n    \n    std::cout &lt;&lt; \"Digite um número para a tabuada: \";\n    std::cin &gt;&gt; numero;\n    \n    // PROCESSAMENTO\n    contador = 1;\n    \nLOOP:\n    int resultado = numero * contador;\n    std::cout &lt;&lt; numero &lt;&lt; \" x \" &lt;&lt; contador &lt;&lt; \" = \" &lt;&lt; resultado &lt;&lt; std::endl;\n    contador = contador + 1;\n    if (contador &lt;= 10) goto LOOP;\n    \n    return 0;\n}\n\n\n\nO código Listing 6.9 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nPara testar adequadamente o algoritmo de geração de tabuada, o professor deverá executar pelo menos três casos de teste distintos com suas respectivas tabelas de rastreio.\n\nCaso 1 (Normal): numero = 5, este caso deve produzir a tabuada completa do 5 (\\(5 \\times 1 = 5, 5 \\times 2 = 10, ..., 5 \\times 10 = 50\\)) e verificar se o laço de repetição executa exatamente 10 iterações.\n\n\nTabela de rastreio para o Caso 1 demonstra que o algoritmo lida corretamente com números inteiros, produzindo uma tabuada de 5.{#tbl-rastreio-exa11}\n\n\n\n\n\n\n\n\n\n\nPasso\nnumero\ncontador\nresultado\ncondição (contador≤10)\nação executada\n\n\n\n\n1\n5\n1\n5\nverdadeiro\nimprimir “5 x 1 = 5”, incrementar contador\n\n\n2\n5\n2\n10\nverdadeiro\nimprimir “5 x 2 = 10”, incrementar contador\n\n\n3\n5\n3\n15\nverdadeiro\nimprimir “5 x 3 = 15”, incrementar contador\n\n\n4\n5\n4\n20\nverdadeiro\nimprimir “5 x 4 = 20”, incrementar contador\n\n\n5\n5\n5\n25\nverdadeiro\nimprimir “5 x 5 = 25”, incrementar contador\n\n\n6\n5\n6\n30\nverdadeiro\nimprimir “5 x 6 = 30”, incrementar contador\n\n\n7\n5\n7\n35\nverdadeiro\nimprimir “5 x 7 = 35”, incrementar contador\n\n\n8\n5\n8\n40\nverdadeiro\nimprimir “5 x 8 = 40”, incrementar contador\n\n\n9\n5\n9\n45\nverdadeiro\nimprimir “5 x 9 = 45”, incrementar contador\n\n\n10\n5\n10\n50\nverdadeiro\nimprimir “5 x 10 = 50”, incrementar contador\n\n\n11\n5\n11\n-\nfalso\nencerrar algoritmo\n\n\n\n\nCaso 2 (Limite): numero = 0, embora tecnicamente válido, produzirá uma tabuada de zeros, útil para verificar se o algoritmo funciona com valores extremos.\n\n\nTabela de rastreio para o Caso 2 demonstra que o algoritmo lida corretamente com o zero, produzindo uma tabuada de zeros.{#tbl-rastreio-exa12}\n\n\n\n\n\n\n\n\n\n\nPasso\nnumero\ncontador\nresultado\ncondição (contador≤10)\nação executada\n\n\n\n\n1\n0\n1\n0\nverdadeiro\nimprimir “0 x 1 = 0”, incrementar contador\n\n\n2\n0\n2\n0\nverdadeiro\nimprimir “0 x 2 = 0”, incrementar contador\n\n\n3\n0\n3\n0\nverdadeiro\nimprimir “0 x 3 = 0”, incrementar contador\n\n\n4\n0\n4\n0\nverdadeiro\nimprimir “0 x 4 = 0”, incrementar contador\n\n\n5\n0\n5\n0\nverdadeiro\nimprimir “0 x 5 = 0”, incrementar contador\n\n\n6\n0\n6\n0\nverdadeiro\nimprimir “0 x 6 = 0”, incrementar contador\n\n\n7\n0\n7\n0\nverdadeiro\nimprimir “0 x 7 = 0”, incrementar contador\n\n\n8\n0\n8\n0\nverdadeiro\nimprimir “0 x 8 = 0”, incrementar contador\n\n\n9\n0\n9\n0\nverdadeiro\nimprimir “0 x 9 = 0”, incrementar contador\n\n\n10\n0\n10\n0\nverdadeiro\nimprimir “0 x 10 = 0”, incrementar contador\n\n\n11\n0\n11\n-\nfalso\nencerrar algoritmo\n\n\n\nCaso 3 (Problemático): numero = -3, este caso revela uma limitação do algoritmo, pois embora execute corretamente do ponto de vista técnico (-3x1=-3, -3x2=-6, etc.), gera resultados negativos que podem não ser apropriados para “relatórios financeiros” em um contexto empresarial real.\n\nTabela de rastreio para o Caso 3 demonstra que o algoritmo funciona matematicamente, mas gera valores negativos inadequados para um contexto de relatórios financeiros empresariais.{#tbl-rastreio-exa13}\n\n\n\n\n\n\n\n\n\n\nPasso\nnumero\ncontador\nresultado\ncondição (contador≤10)\nação executada\n\n\n\n\n1\n-3\n1\n-3\nverdadeiro\nimprimir “-3 x 1 = -3”, incrementar contador\n\n\n2\n-3\n2\n-6\nverdadeiro\nimprimir “-3 x 2 = -6”, incrementar contador\n\n\n3\n-3\n3\n-9\nverdadeiro\nimprimir “-3 x 3 = -9”, incrementar contador\n\n\n4\n-3\n4\n-12\nverdadeiro\nimprimir “-3 x 4 = -12”, incrementar contador\n\n\n5\n-3\n5\n-15\nverdadeiro\nimprimir “-3 x 5 = -15”, incrementar contador\n\n\n6\n-3\n6\n-18\nverdadeiro\nimprimir “-3 x 6 = -18”, incrementar contador\n\n\n7\n-3\n7\n-21\nverdadeiro\nimprimir “-3 x 7 = -21”, incrementar contador\n\n\n8\n-3\n8\n-24\nverdadeiro\nimprimir “-3 x 8 = -24”, incrementar contador\n\n\n9\n-3\n9\n-27\nverdadeiro\nimprimir “-3 x 9 = -27”, incrementar contador\n\n\n10\n-3\n10\n-30\nverdadeiro\nimprimir “-3 x 10 = -30”, incrementar contador\n\n\n11\n-3\n11\n-\nfalso\nencerrar algoritmo\n\n\n\nSeguindo a técnica da Sequência de Fibonacci (1, 1, 2), o professor deve solicitar que os quatro próximos exercícios sejam resolvidos com fluxogramas, os fluxogramas sejam transformados em pseudocódigo, os pseudocódigos sejam transformados em código C++ e, finalmente, os códigos C++ sejam validados com tabelas de rastreio. Além disso, o professor deve dimensionar o tempo de cada exercício lembrando que o tempo para execução dos dois últimos deve ser aproximadamente igual ao tempo disponibilizado para o primeiro exercício.\nB1. Sequência de Lançamento de Foguetes: na agência espacial “Horizonte Infinito”, o protocolo de lançamento de foguetes exige uma contagem regressiva precisa. O sistema deve exibir os números de 10 até 0, e no momento zero, a mensagem “Lançar!” deve ser exibida. O engenheiro Rui Gambia precisa de um algoritmo que automatize esta sequência de contagem regressiva para os lançamentos. Crie um fluxograma para este algoritmo.\nAnálise: neste caso, o fluxograma pode ser representado pelo fluxo da Figure 6.9.\n\n\n\n Fluxograma para representar o problema Sequência de Lançamento de Foguetes.\n\n\nFigure 6.9\n\n\n\nO pseudocódigo pode ser representado como:\nALGORITMO SequenciaLancamentoFoguetesConciso\n\nSAÍDA:\n    contador: inteiro\n\nINÍCIO\n    contador ← 10\n    \nETIQUETA LOOP:\n    ESCREVER contador\n    SE contador = 0 ENTÃO \n        ESCREVER \"Lançar!\"\n        IR PARA FIM\n    SENÃO\n        contador ← contador - 1\n        IR PARA LOOP\n        \nETIQUETA FIM:\nFIM\nO pseudocódigo pode ser representado com o Listing 6.10.\n\n\n\nListing 6.10\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // PROCESSAMENTO\n    int contador = 10;\n    \nLOOP:\n    std::cout &lt;&lt; contador &lt;&lt; std::endl;\n    if (contador == 0) {\n        std::cout &lt;&lt; \"Lançar!\" &lt;&lt; std::endl;\n        goto FIM;\n    } else {\n        contador = contador - 1;\n        goto LOOP;\n    }\n    \nFIM:\n    return 0;\n}\n\n\n\nO código Listing 6.10 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nC1. Análise de Desempenho de Vendas: o gerente de vendas da “Vendas Top” precisa calcular a media_de_vendas por vendedor. Ele insere os valores de venda um por um. No entanto, apenas vendas entre 0 e 1000 Reais são consideradas válidas. O processo de inserção de vendas termina quando um valor negativo é digitado (este valor negativo não deve ser incluído na média). Ajude o gerente criando um algoritmo que calcule a média das vendas válidas.\nAnálise: o fluxograma pode ser representado por:\n\n\n\n Fluxograma para representar o problema Análise de Desempenho de Vendas.\n\n\nFigure 6.10\n\n\n\nO pseudocódigo pode ser representado como:\nALGORITMO AnaliseDesempenhoVendasConciso\n\nENTRADA:\n    venda: real\n\nSAÍDA:\n    media: real\n\nINÍCIO\n    soma ← 0\n    contador ← 0\n    \nETIQUETA LOOP:\n    LER venda\n    SE venda &lt; 0 ENTÃO IR PARA CALCULAR_MEDIA\n    SE (venda &gt;= 0) E (venda &lt;= 1000) ENTÃO\n        soma ← soma + venda\n        contador ← contador + 1\n    IR PARA LOOP\n\nETIQUETA CALCULAR_MEDIA:\n    SE contador &gt; 0 ENTÃO\n        media ← soma / contador\n        ESCREVER \"Média:\", media\n    SENÃO\n        ESCREVER \"Nenhuma venda válida\"\nFIM\nO pseudocódigo pode ser representado com o Listing 6.11.\n\n\n\nListing 6.11\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double venda;\n    \n    // PROCESSAMENTO\n    double soma = 0;\n    int contador = 0;\n    \nLOOP:\n    std::cout &lt;&lt; \"Digite o valor da venda (negativo para encerrar): \";\n    std::cin &gt;&gt; venda;\n    if (venda &lt; 0) goto CALCULAR_MEDIA;\n    if ((venda &gt;= 0) && (venda &lt;= 1000)) {\n        soma = soma + venda;\n        contador = contador + 1;\n    }\n    goto LOOP;\n\nCALCULAR_MEDIA:\n    if (contador &gt; 0) {\n        double media = soma / contador;\n        std::cout &lt;&lt; \"Média de vendas: \" &lt;&lt; media &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Nenhuma venda válida foi inserida.\" &lt;&lt; std::endl;\n    }\n    \n    return 0;\n}\n\n\n\nO código Listing 6.11 pode ser executado em qualquer ambiente de desenvolvimento C++ online, e está disponível no OnlineGDB.\nD1. Jogo Interativo de Lógica: a empresa de jogos “Mente Brilhante” está desenvolvendo um jogo de adivinhação. O computador “escolhe” um numero_secreto (por exemplo, 42) entre 1 e 100. O jogador tem 5 tentativas para adivinhar. A cada tentativa, o jogo deve informar se o palpite do jogador foi “Muito alto!”, “Muito baixo!” ou “Correto! Você adivinhou o número!”. Se o jogador acertar, o jogo termina com uma mensagem de vitória. Se as tentativas acabarem, o jogo termina com uma mensagem de derrota, revelando o numero_secreto. Considerando que o número secreto é fixo e você não vai mudá-lo nesta tarefa, crie um fluxograma para um algoritmo que represente o processo de adivinhação.\nAnálise: o pseudocódigo para este exercício pode ser representado como:\nALGORITMO JogoAdivinhacao\n\nCONSTANTES:\n    numero_secreto ← 42\n    max_tentativas ← 5\n\nENTRADA:\n    palpite: inteiro\n\nSAÍDA:\n    mensagem: texto\n\nINÍCIO\n    tentativas_feitas ← 0\n\nETIQUETA LOOP_TENTATIVAS:\n    SE tentativas_feitas &gt;= max_tentativas ENTÃO\n        ESCREVER \"Você perdeu! O número secreto era \", numero_secreto\n        IR PARA FIM_JOGO\n    FIM SE\n\n    ESCREVER \"Tentativa \", tentativas_feitas + 1, \". Digite seu palpite (1-100):\"\n    LER palpite\n    tentativas_feitas ← tentativas_feitas + 1\n\n    SE palpite = numero_secreto ENTÃO\n        ESCREVER \"Correto! Você adivinhou o número!\"\n        IR PARA FIM_JOGO\n    SENÃO SE palpite &gt; numero_secreto ENTÃO\n        ESCREVER \"Muito alto!\"\n    SENÃO\n        ESCREVER \"Muito baixo!\"\n    FIM SE\n\n    IR PARA LOOP_TENTATIVAS\n\nETIQUETA FIM_JOGO:\nFIM\nE1. Cálculo de Probabilidades: no departamento de estatística da Universidade, a aluna Clara está estudando probabilidades e frequentemente precisa calcular o fatorial de números inteiros não negativos. O fatorial de um número n (representado por n!) é o produto de todos os inteiros positivos menores ou iguais a n. Por definição, 0! = 1. Ajude a Clara a desenvolver um algoritmo que, dado um numero, calcule e exiba o seu fatorial. (Ex: 5! = 5 × 4 × 3 × 2 × 1 = 120).\nAnálise: o pseudocódigo para este exercício pode ser representado como:\nALGORITMO CalculoFatorialConciso\n\nENTRADA:\n    numero: inteiro\n\nSAÍDA:\n    fatorial: inteiro\n\nINÍCIO\n    LER numero\n    fatorial ← 1\n    contador ← numero\n    \n    SE numero = 0 ENTÃO IR PARA RESULTADO\n    \nETIQUETA LOOP:\n    fatorial ← fatorial * contador\n    contador ← contador - 1\n    SE contador &gt; 0 ENTÃO IR PARA LOOP\n    \nETIQUETA RESULTADO:\n    ESCREVER numero, \"! = \", fatorial\nFIM\nQue pode ser implementado em C++ 23 por:\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    int numero;\n    \n    std::cout &lt;&lt; \"Digite um número para calcular o fatorial: \";\n    std::cin &gt;&gt; numero;\n    \n    // PROCESSAMENTO\n    long long fatorial = 1;\n    int contador = numero;\n    \n    if (numero == 0) goto RESULTADO;\n    \nLOOP:\n    fatorial = fatorial * contador;\n    contador = contador - 1;\n    if (contador &gt; 0) goto LOOP;\n    \nRESULTADO:\n    std::cout &lt;&lt; numero &lt;&lt; \"! = \" &lt;&lt; fatorial &lt;&lt; std::endl;\n    \n    return 0;\n}\nF1. Sistema de Análise de Desempenho Acadêmico por Turmas: na escola “Excelência Educacional”, a coordenadora pedagógica Profa. Marina precisa analisar o desempenho de múltiplas turmas simultaneamente. O sistema deve processar numero_turmas turmas, e para cada turma, deve ler numero_alunos da turma e as notas de cada aluno (0-100). Para cada turma, calcular e exibir: média da turma, quantidade de alunos aprovados (nota ≥ 60), maior nota e menor nota. Adicionalmente, o sistema deve identificar qual turma teve a maior média geral e quantos alunos no total ficaram abaixo da média de sua respectiva turma. Notas inválidas (fora do range 0-100) devem ser rejeitadas e solicitadas novamente. Se uma turma tiver menos de 3 alunos válidos, ela deve ser marcada como “Turma Inválida” e não incluída nas estatísticas gerais. No final, exibir um relatório consolidado com: média geral de todas as turmas válidas, total de alunos aprovados em toda a escola, e o número da turma com melhor desempenho.\nAnálise: o pseudocódigo para este exercício pode ser representado como:\nALGORITMO AnaliseDesempenhoAcademicoConciso\n\nENTRADA:\n    numeroTurmas, numeroAlunos, nota: inteiro\n\nSAÍDA:\n    mediaTurma, alunosAprovados, maiorNota, menorNota: real\n    melhorTurma, totalAbaixoMedia: inteiro\n\nINÍCIO\n    LER numeroTurmas\n    turmaAtual ← 1\n    melhorMedia ← 0\n    melhorTurma ← 0\n    totalTurmasValidas ← 0\n    somaMediasGeral ← 0\n    totalAlunosAprovadosGeral ← 0\n    totalAbaixoMedia ← 0\n    \nETIQUETA LOOP_TURMAS:\n    ESCREVER \"=== TURMA \", turmaAtual, \" ===\"\n    LER numeroAlunos\n    alunoAtual ← 1\n    somaTurma ← 0\n    alunosValidos ← 0\n    alunosAprovados ← 0\n    maiorNota ← 0\n    menorNota ← 100\n    \nETIQUETA LOOP_ALUNOS:\n    ESCREVER \"Nota do aluno \", alunoAtual, \": \"\n    \nETIQUETA LER_NOTA:\n    LER nota\n    SE (nota &lt; 0) OU (nota &gt; 100) ENTÃO\n        ESCREVER \"Nota inválida! Digite novamente: \"\n        IR PARA LER_NOTA\n    \n    somaTurma ← somaTurma + nota\n    alunosValidos ← alunosValidos + 1\n    SE nota &gt;= 60 ENTÃO alunosAprovados ← alunosAprovados + 1\n    SE nota &gt; maiorNota ENTÃO maiorNota ← nota\n    SE nota &lt; menorNota ENTÃO menorNota ← nota\n    \n    alunoAtual ← alunoAtual + 1\n    SE alunoAtual &lt;= numeroAlunos ENTÃO IR PARA LOOP_ALUNOS\n    \n    SE alunosValidos &lt; 3 ENTÃO\n        ESCREVER \"Turma Inválida (menos de 3 alunos válidos)\"\n        IR PARA PROXIMA_TURMA\n    \n    mediaTurma ← somaTurma / alunosValidos\n    ESCREVER \"Média da turma: \", mediaTurma\n    ESCREVER \"Alunos aprovados: \", alunosAprovados\n    ESCREVER \"Maior nota: \", maiorNota\n    ESCREVER \"Menor nota: \", menorNota\n    \n    totalTurmasValidas ← totalTurmasValidas + 1\n    somaMediasGeral ← somaMediasGeral + mediaTurma\n    totalAlunosAprovadosGeral ← totalAlunosAprovadosGeral + alunosAprovados\n    \n    SE mediaTurma &gt; melhorMedia ENTÃO\n        melhorMedia ← mediaTurma\n        melhorTurma ← turmaAtual\n    \n    alunoContador ← 1\nETIQUETA CONTAR_ABAIXO_MEDIA:\n    SE alunoContador &lt;= alunosValidos ENTÃO\n        SE notaAluno[alunoContador] &lt; mediaTurma ENTÃO\n            totalAbaixoMedia ← totalAbaixoMedia + 1\n        alunoContador ← alunoContador + 1\n        IR PARA CONTAR_ABAIXO_MEDIA\n    \nETIQUETA PROXIMA_TURMA:\n    turmaAtual ← turmaAtual + 1\n    SE turmaAtual &lt;= numeroTurmas ENTÃO IR PARA LOOP_TURMAS\n    \n    ESCREVER \"=== RELATÓRIO CONSOLIDADO ===\"\n    SE totalTurmasValidas &gt; 0 ENTÃO\n        mediaGeral ← somaMediasGeral / totalTurmasValidas\n        ESCREVER \"Média geral: \", mediaGeral\n        ESCREVER \"Total de alunos aprovados: \", totalAlunosAprovadosGeral\n        ESCREVER \"Melhor turma: \", melhorTurma\n        ESCREVER \"Alunos abaixo da média: \", totalAbaixoMedia\n    SENÃO\n        ESCREVER \"Nenhuma turma válida encontrada\"\n        \nFIM\nQue pode ser representado em C++23 por:\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    int numeroTurmas, numeroAlunos, nota;\n    \n    std::cout &lt;&lt; \"Número de turmas: \";\n    std::cin &gt;&gt; numeroTurmas;\n    \n    // PROCESSAMENTO\n    int turmaAtual = 1;\n    double melhorMedia = 0;\n    int melhorTurma = 0;\n    int totalTurmasValidas = 0;\n    double somaMediasGeral = 0;\n    int totalAlunosAprovadosGeral = 0;\n    int totalAbaixoMedia = 0;\n    \n    int notasTurma[1000]; // Array para armazenar notas da turma atual\n    \nLOOP_TURMAS:\n    std::cout &lt;&lt; \"n=== TURMA \" &lt;&lt; turmaAtual &lt;&lt; \" ===\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Número de alunos: \";\n    std::cin &gt;&gt; numeroAlunos;\n    \n    int alunoAtual = 1;\n    double somaTurma = 0;\n    int alunosValidos = 0;\n    int alunosAprovados = 0;\n    double maiorNota = 0;\n    double menorNota = 100;\n    \nLOOP_ALUNOS:\n    std::cout &lt;&lt; \"Nota do aluno \" &lt;&lt; alunoAtual &lt;&lt; \": \";\n    \nLER_NOTA:\n    std::cin &gt;&gt; nota;\n    if ((nota &lt; 0) || (nota &gt; 100)) {\n        std::cout &lt;&lt; \"Nota inválida! Digite novamente: \";\n        goto LER_NOTA;\n    }\n    \n    notasTurma[alunosValidos] = nota;\n    somaTurma = somaTurma + nota;\n    alunosValidos = alunosValidos + 1;\n    if (nota &gt;= 60) alunosAprovados = alunosAprovados + 1;\n    if (nota &gt; maiorNota) maiorNota = nota;\n    if (nota &lt; menorNota) menorNota = nota;\n    \n    alunoAtual = alunoAtual + 1;\n    if (alunoAtual &lt;= numeroAlunos) goto LOOP_ALUNOS;\n    \n    if (alunosValidos &lt; 3) {\n        std::cout &lt;&lt; \"Turma Inválida (menos de 3 alunos válidos)\" &lt;&lt; std::endl;\n        goto PROXIMA_TURMA;\n    }\n    \n    double mediaTurma = somaTurma / alunosValidos;\n    std::cout &lt;&lt; \"Média da turma: \" &lt;&lt; mediaTurma &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Alunos aprovados: \" &lt;&lt; alunosAprovados &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Maior nota: \" &lt;&lt; maiorNota &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Menor nota: \" &lt;&lt; menorNota &lt;&lt; std::endl;\n    \n    totalTurmasValidas = totalTurmasValidas + 1;\n    somaMediasGeral = somaMediasGeral + mediaTurma;\n    totalAlunosAprovadosGeral = totalAlunosAprovadosGeral + alunosAprovados;\n    \n    if (mediaTurma &gt; melhorMedia) {\n        melhorMedia = mediaTurma;\n        melhorTurma = turmaAtual;\n    }\n    \n    int alunoContador = 0;\nCONTAR_ABAIXO_MEDIA:\n    if (alunoContador &lt; alunosValidos) {\n        if (notasTurma[alunoContador] &lt; mediaTurma) {\n            totalAbaixoMedia = totalAbaixoMedia + 1;\n        }\n        alunoContador = alunoContador + 1;\n        goto CONTAR_ABAIXO_MEDIA;\n    }\n    \nPROXIMA_TURMA:\n    turmaAtual = turmaAtual + 1;\n    if (turmaAtual &lt;= numeroTurmas) goto LOOP_TURMAS;\n    \n    std::cout &lt;&lt; \"n=== RELATÓRIO CONSOLIDADO ===\" &lt;&lt; std::endl;\n    if (totalTurmasValidas &gt; 0) {\n        double mediaGeral = somaMediasGeral / totalTurmasValidas;\n        std::cout &lt;&lt; \"Média geral: \" &lt;&lt; mediaGeral &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Total de alunos aprovados: \" &lt;&lt; totalAlunosAprovadosGeral &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Melhor turma: \" &lt;&lt; melhorTurma &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Alunos abaixo da média: \" &lt;&lt; totalAbaixoMedia &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Nenhuma turma válida encontrada\" &lt;&lt; std::endl;\n    }\n    \n    return 0;\n}\nG1. Simulação de Sistema de Caixa Eletrônico Bancário: no banco “Futuro Digital”, o analista Pedro precisa simular operações de caixa eletrônico para teste de capacidade. O sistema deve processar uma sequência de operacoes até que seja digitado 0 (encerrar). Os tipos de operação são: 1-Saque, 2-Depósito, 3-Consulta. Para cada operação, ler o valor correspondente. O sistema inicia com saldo R$ 1000,00. Regras: saques só são permitidos se houver saldo suficiente e se o valor for múltiplo de R$ 10,00 (limitação física das cédulas); depósitos devem ser valores positivos; a cada 5 operações bem-sucedidas consecutivas, aplicar uma taxa de manutenção de R$ 2,00; se o saldo ficar negativo ou se houver 3 operações inválidas consecutivas, bloquear o cartão e encerrar. Durante a simulação, manter contadores de: total de saques realizados, valor total depositado, número de consultas, operações inválidas consecutivas e operações válidas consecutivas. No encerramento, exibir relatório completo: saldo final, estatísticas de operações, total de taxas cobradas, e motivo do encerramento (usuário, bloqueio por saldo, ou bloqueio por operações inválidas).\nAnálise: o pseudocódigo para este exercício pode ser representado como:\nALGORITMO SimulacaoCaixaEletronicoConciso\n\nENTRADA:\n    operacao, valor: real\n\nSAÍDA:\n    saldo, totalSaques, valorTotalDepositado, numeroConsultas: real\n    operacoesInvalidasConsecutivas, operacoesValidasConsecutivas: inteiro\n\nINÍCIO\n    saldo ← 1000.00\n    totalSaques ← 0\n    valorTotalDepositado ← 0\n    numeroConsultas ← 0\n    operacoesInvalidasConsecutivas ← 0\n    operacoesValidasConsecutivas ← 0\n    totalTaxas ← 0\n    motivoEncerramento ← \"usuário\"\n    \nETIQUETA LOOP_OPERACOES:\n    ESCREVER \"Operação (1-Saque, 2-Depósito, 3-Consulta, 0-Encerrar): \"\n    LER operacao\n    \n    SE operacao = 0 ENTÃO IR PARA RELATORIO_FINAL\n    \n    SE operacao = 3 ENTÃO\n        ESCREVER \"Saldo atual: R$ \", saldo\n        numeroConsultas ← numeroConsultas + 1\n        operacoesValidasConsecutivas ← operacoesValidasConsecutivas + 1\n        operacoesInvalidasConsecutivas ← 0\n        IR PARA VERIFICAR_TAXA\n    \n    ESCREVER \"Valor: R$ \"\n    LER valor\n    \n    SE operacao = 1 ENTÃO\n        SE (valor % 10 ≠ 0) OU (valor &gt; saldo) OU (valor &lt;= 0) ENTÃO\n            ESCREVER \"Operação inválida!\"\n            operacoesInvalidasConsecutivas ← operacoesInvalidasConsecutivas + 1\n            operacoesValidasConsecutivas ← 0\n        SENÃO\n            saldo ← saldo - valor\n            totalSaques ← totalSaques + 1\n            ESCREVER \"Saque realizado. Saldo: R$ \", saldo\n            operacoesValidasConsecutivas ← operacoesValidasConsecutivas + 1\n            operacoesInvalidasConsecutivas ← 0\n    SENÃO SE operacao = 2 ENTÃO\n        SE valor &lt;= 0 ENTÃO\n            ESCREVER \"Operação inválida!\"\n            operacoesInvalidasConsecutivas ← operacoesInvalidasConsecutivas + 1\n            operacoesValidasConsecutivas ← 0\n        SENÃO\n            saldo ← saldo + valor\n            valorTotalDepositado ← valorTotalDepositado + valor\n            ESCREVER \"Depósito realizado. Saldo: R$ \", saldo\n            operacoesValidasConsecutivas ← operacoesValidasConsecutivas + 1\n            operacoesInvalidasConsecutivas ← 0\n    SENÃO\n        ESCREVER \"Operação inválida!\"\n        operacoesInvalidasConsecutivas ← operacoesInvalidasConsecutivas + 1\n        operacoesValidasConsecutivas ← 0\n    \nETIQUETA VERIFICAR_TAXA:\n    SE operacoesValidasConsecutivas = 5 ENTÃO\n        saldo ← saldo - 2.00\n        totalTaxas ← totalTaxas + 2.00\n        operacoesValidasConsecutivas ← 0\n        ESCREVER \"Taxa de manutenção aplicada: R$ 2,00\"\n    \nETIQUETA VERIFICAR_BLOQUEIOS:\n    SE saldo &lt; 0 ENTÃO\n        motivoEncerramento ← \"bloqueio por saldo negativo\"\n        IR PARA RELATORIO_FINAL\n    \n    SE operacoesInvalidasConsecutivas &gt;= 3 ENTÃO\n        motivoEncerramento ← \"bloqueio por operações inválidas\"\n        IR PARA RELATORIO_FINAL\n    \n    IR PARA LOOP_OPERACOES\n\nETIQUETA RELATORIO_FINAL:\n    ESCREVER \"=== RELATÓRIO FINAL ===\"\n    ESCREVER \"Saldo final: R$ \", saldo\n    ESCREVER \"Total de saques: \", totalSaques\n    ESCREVER \"Valor total depositado: R$ \", valorTotalDepositado\n    ESCREVER \"Número de consultas: \", numeroConsultas\n    ESCREVER \"Total de taxas: R$ \", totalTaxas\n    ESCREVER \"Motivo do encerramento: \", motivoEncerramento\n    \nFIM\nQue pode ser representado em C++23 por:\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    int operacao;\n    double valor;\n    \n    // PROCESSAMENTO\n    double saldo = 1000.00;\n    int totalSaques = 0;\n    double valorTotalDepositado = 0;\n    int numeroConsultas = 0;\n    int operacoesInvalidasConsecutivas = 0;\n    int operacoesValidasConsecutivas = 0;\n    double totalTaxas = 0;\n    std::string motivoEncerramento = \"usuário\";\n    \nLOOP_OPERACOES:\n    std::cout &lt;&lt; \"nOperação (1-Saque, 2-Depósito, 3-Consulta, 0-Encerrar): \";\n    std::cin &gt;&gt; operacao;\n    \n    if (operacao == 0) goto RELATORIO_FINAL;\n    \n    if (operacao == 3) {\n        std::cout &lt;&lt; \"Saldo atual: R$ \" &lt;&lt; saldo &lt;&lt; std::endl;\n        numeroConsultas = numeroConsultas + 1;\n        operacoesValidasConsecutivas = operacoesValidasConsecutivas + 1;\n        operacoesInvalidasConsecutivas = 0;\n        goto VERIFICAR_TAXA;\n    }\n    \n    std::cout &lt;&lt; \"Valor: R$ \";\n    std::cin &gt;&gt; valor;\n    \n    if (operacao == 1) {\n        if ((static_cast&lt;int&gt;(valor) % 10 != 0) || (valor &gt; saldo) || (valor &lt;= 0)) {\n            std::cout &lt;&lt; \"Operação inválida!\" &lt;&lt; std::endl;\n            operacoesInvalidasConsecutivas = operacoesInvalidasConsecutivas + 1;\n            operacoesValidasConsecutivas = 0;\n        } else {\n            saldo = saldo - valor;\n            totalSaques = totalSaques + 1;\n            std::cout &lt;&lt; \"Saque realizado. Saldo: R$ \" &lt;&lt; saldo &lt;&lt; std::endl;\n            operacoesValidasConsecutivas = operacoesValidasConsecutivas + 1;\n            operacoesInvalidasConsecutivas = 0;\n        }\n    } else if (operacao == 2) {\n        if (valor &lt;= 0) {\n            std::cout &lt;&lt; \"Operação inválida!\" &lt;&lt; std::endl;\n            operacoesInvalidasConsecutivas = operacoesInvalidasConsecutivas + 1;\n            operacoesValidasConsecutivas = 0;\n        } else {\n            saldo = saldo + valor;\n            valorTotalDepositado = valorTotalDepositado + valor;\n            std::cout &lt;&lt; \"Depósito realizado. Saldo: R$ \" &lt;&lt; saldo &lt;&lt; std::endl;\n            operacoesValidasConsecutivas = operacoesValidasConsecutivas + 1;\n            operacoesInvalidasConsecutivas = 0;\n        }\n    } else {\n        std::cout &lt;&lt; \"Operação inválida!\" &lt;&lt; std::endl;\n        operacoesInvalidasConsecutivas = operacoesInvalidasConsecutivas + 1;\n        operacoesValidasConsecutivas = 0;\n    }\n    \nVERIFICAR_TAXA:\n    if (operacoesValidasConsecutivas == 5) {\n        saldo = saldo - 2.00;\n        totalTaxas = totalTaxas + 2.00;\n        operacoesValidasConsecutivas = 0;\n        std::cout &lt;&lt; \"Taxa de manutenção aplicada: R$ 2,00\" &lt;&lt; std::endl;\n    }\n    \nVERIFICAR_BLOQUEIOS:\n    if (saldo &lt; 0) {\n        motivoEncerramento = \"bloqueio por saldo negativo\";\n        goto RELATORIO_FINAL;\n    }\n    \n    if (operacoesInvalidasConsecutivas &gt;= 3) {\n        motivoEncerramento = \"bloqueio por operações inválidas\";\n        goto RELATORIO_FINAL;\n    }\n    \n    goto LOOP_OPERACOES;\n\nRELATORIO_FINAL:\n    std::cout &lt;&lt; \"n=== RELATÓRIO FINAL ===\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Saldo final: R$ \" &lt;&lt; saldo &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Total de saques: \" &lt;&lt; totalSaques &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Valor total depositado: R$ \" &lt;&lt; valorTotalDepositado &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Número de consultas: \" &lt;&lt; numeroConsultas &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Total de taxas: R$ \" &lt;&lt; totalTaxas &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Motivo do encerramento: \" &lt;&lt; motivoEncerramento &lt;&lt; std::endl;\n    \n    return 0;\n}\nI1. O biólogo Dr. Miguel está modelando o crescimento de uma população de bactérias que segue uma progressão aritmética. Ele precisa de um algoritmo que, dado o primeiro_termo da população inicial e a razao de crescimento diário, consiga exibir os N primeiros dias de crescimento dessa população.\nJ1. Para aumentar a segurança dos dados dos usuários, a empresa “CiberSeguro” exige que, ao criar uma nova conta, o usuário digite a sua nova_senha e, em seguida, a confirme digitando-a novamente. O sistema só deve aceitar o registro quando a confirmação_senha for exatamente igual à nova_senha. Desenvolva um algoritmo que implemente esta validação, continuando a pedir a confirmação até que as senhas coincidam.\nK1. A Professora Lúcia, da disciplina de “Matemática Discreta”, está ensinando a sequência de Fibonacci, que aparece em diversos fenômenos naturais (espirais de conchas, arranjo de folhas). A sequência começa com 0 e 1, e cada termo subsequente é a soma dos dois anteriores (0, 1, 1, 2, 3, 5, 8…). Ela precisa de um algoritmo que, dado um número inteiro N, gere e exiba os N primeiros termos desta sequência.\nL1. No departamento de análise de dados, a estatística Marta está processando grandes conjuntos de números. Para uma análise específica, ela precisa de um algoritmo que, dado um numero_inteiro_positivo, determine quantos dos seus dígitos são pares e quantos são ímpares. (Ex: o número 12345 tem 2 dígitos pares (2, 4) e 3 dígitos ímpares (1, 3, 5)).\nM1. O Banco “Futuro Digital” está desenvolvendo um protótipo de caixa eletrônico. O sistema inicia com um saldo_inicial de 1000 euros. O usuário pode escolher entre “Depositar”, “Sacar” ou “Sair” do sistema.\n\nDepositar: O usuário informa o valor_deposito, que é adicionado ao saldo.\nSacar: O usuário informa o valor_saque. Se o saldo for suficiente, o valor é debitado. Caso contrário, uma mensagem de “Saldo insuficiente” é exibida.\n\nO sistema deve continuar a apresentar o menu e a executar as operações até que o usuário escolha a opção “Sair”.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>**Módulo 1**: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span>"
    ]
  },
  {
    "objectID": "desenv1.html#for-while-do-while",
    "href": "desenv1.html#for-while-do-while",
    "title": "6  Módulo 1: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição",
    "section": "6.2 For, While, Do While",
    "text": "6.2 For, While, Do While\nNesta seção, o professor deve escolher se irá continuar com C++23, ou já fará a transição para o Python. O Objetivo é criar o entendimento dos artefatos sintáticos que foram criados para representar laços de repetição: for, while e do while.\nO professor deverá escolher três problemas, entre aqueles que foram anteriormente resolvidos, e reescrevê-los utilizando os laços de repetição for, while e do while. A seguir, são apresentados exemplos de como cada laço pode ser utilizado.\n\n6.2.1 Laço for\nO laço for deve ser utilizado quando se sabe o número exato de iterações que serão realizadas. Por exemplo, para imprimir os números de 1 a 10:\nfor (int i = 1; i &lt;= 10; i++) {\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n}\nO problema a seguir pode ser resolvido utilizando o laço for:\nA1. Geração de Relatórios Financeiros: a contabilidade da empresa “Números Certos” precisa de um sistema que gere rapidamente relatórios de multiplicação para auditorias internas. O Sr. Costa, o contador, frequentemente precisa visualizar a “tabuada” de um determinado número (multiplicado de 1 a 10). Projete um algoritmo que, dado um número inteiro, imprima sua tabuada completa.\nAnálise: Este problema foi resolvido com o fluxograma apresentado na Figure 6.11.\n\n\n\n\n\n\nFigure 6.11: Fluxograma para representar o problema Geração de Relatórios Financeiros, sem e com o laço for.\n\n\n\nExiste um módulo no padrão ISO, (2), que pode ser utilizado para representar o laço for, um hexágono. Contudo, este diagrama não contém uma simbologia clara agregando um nível extra de abstração. Na Figure 6.11, o laço for é representado por um bloco de processamento, com a definição do laço, indicando o que deve ser contado, até que valor, e, dentro deste bloco, os comandos que devem ser executados dentro do laço estão representados com fundo branco. Esta representação é exclusiva deste trabalho em uma tentativa de facilitar a abstração e o entendimento.\nA tabela Table 6.43 apresenta o pseudocódigo para o algorítmo que resolve o problema A1 usando goto para desvio de fluxo e usando o laço for.\n\n\n\nTable 6.43: Comparação entre o pseudocódigo sem e com o laço for.\n\n\n\n\n\n\n\n\n\nPseudocódigo (sem laço for)\nPseudocódigo (com laço for)\n\n\n\n\nshell &lt;br&gt;ALGORITMO GeracaoTabuadaConciso&lt;br&gt;&lt;br&gt;ENTRADA:&lt;br&gt;    numero: inteiro&lt;br&gt;&lt;br&gt;SAÍDA:&lt;br&gt;    resultado: inteiro&lt;br&gt;&lt;br&gt;INÍCIO&lt;br&gt;    LER numero&lt;br&gt;    contador ← 1&lt;br&gt;    &lt;br&gt;ETIQUETA LOOP:&lt;br&gt;    resultado ← numero * contador&lt;br&gt;    ESCREVER numero, \" x \", contador, \" = \", resultado&lt;br&gt;    contador ← contador + 1&lt;br&gt;    SE contador &lt;= 10 ENTÃO IR PARA LOOP&lt;br&gt;    &lt;br&gt;FIM&lt;br&gt;\nshell &lt;br&gt;ALGORITMO GeracaoTabuadaComFor&lt;br&gt;&lt;br&gt;ENTRADA:&lt;br&gt;    numero: inteiro&lt;br&gt;&lt;br&gt;SAÍDA:&lt;br&gt;    resultado: inteiro&lt;br&gt;&lt;br&gt;INÍCIO&lt;br&gt;    LER numero&lt;br&gt;    &lt;br&gt;    PARA contador DE 1 ATÉ 10 PASSO 1 FAÇA&lt;br&gt;        resultado ← numero * contador&lt;br&gt;        ESCREVER numero, \" x \", contador, \" = \", resultado&lt;br&gt;    FIM PARA&lt;br&gt;    &lt;br&gt;FIM&lt;br&gt;\n\n\n\n\n\n\nO código Listing 6.12 exemplifica o uso do laço for em C++23.\n\n\n\nListing 6.12\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    int numero;\n    std::cout &lt;&lt; \"Digite um número: \";\n    std::cin &gt;&gt; numero;\n\n    for (int contador = 1; contador &lt;= 10; contador++) {\n        int resultado = numero * contador;\n        std::cout &lt;&lt; numero &lt;&lt; \" x \" &lt;&lt; contador &lt;&lt; \" = \" &lt;&lt; resultado &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n\n\n\nEm Python, este algorítmo seria representado por:\nnumero = int(input(\"Digite um número: \"))\nfor contador in range(1, 11):\n    resultado = numero * contador\n    print(f\"{numero} x {contador} = {resultado}\")\n\n\n6.2.2 Laço while\nO problema a seguir, que o aluno deve ter resolvido anteriormente, pode ser resolvido utilizando o laço while.\nC1. Análise de Desempenho de Vendas: o gerente de vendas da “Vendas Top” precisa calcular a media_de_vendas por vendedor. Ele insere os valores de venda um por um. No entanto, apenas vendas entre 0 e 1000 Reais são consideradas válidas. O processo de inserção de vendas termina quando um valor negativo é digitado (este valor negativo não deve ser incluído na média). Ajude o gerente criando um algoritmo que calcule a média das vendas válidas.\nAnálise: os pseudocódigos do algorítmo para resolver o problema C1 são apresentados na Table 6.44.\n\n\n\nTable 6.44: Comparação entre o pseudocódigo com goto e com while.\n\n\n\n\n\n\n\n\n\nPseudocódigo (com goto)\nPseudocódigo (com while)\n\n\n\n\n&lt;br&gt;ALGORITMO AnaliseDesempenhoVendasConciso&lt;br&gt;&lt;br&gt;ENTRADA:&lt;br&gt;    venda: real&lt;br&gt;&lt;br&gt;SAÍDA:&lt;br&gt;    media: real&lt;br&gt;&lt;br&gt;INÍCIO&lt;br&gt;    soma ← 0&lt;br&gt;    contador ← 0&lt;br&gt;    &lt;br&gt;ETIQUETA LOOP:&lt;br&gt;    LER venda&lt;br&gt;    SE venda &lt; 0 ENTÃO IR PARA CALCULAR_MEDIA&lt;br&gt;    SE (venda &gt;= 0) E (venda &lt;= 1000) ENTÃO&lt;br&gt;        soma ← soma + venda&lt;br&gt;        contador ← contador + 1&lt;br&gt;    IR PARA LOOP&lt;br&gt;&lt;br&gt;ETIQUETA CALCULAR_MEDIA:&lt;br&gt;    SE contador &gt; 0 ENTÃO&lt;br&gt;        media ← soma / contador&lt;br&gt;        ESCREVER \"Média:\", media&lt;br&gt;    SENÃO&lt;br&gt;        ESCREVER \"Nenhuma venda válida\"&lt;br&gt;FIM&lt;br&gt;\n&lt;br&gt;ALGORITMO AnaliseDesempenhoVendasComWhile&lt;br&gt;&lt;br&gt;ENTRADA:&lt;br&gt;    venda: real&lt;br&gt;&lt;br&gt;SAÍDA:&lt;br&gt;    media: real&lt;br&gt;&lt;br&gt;INÍCIO&lt;br&gt;    soma ← 0&lt;br&gt;    contador ← 0&lt;br&gt;    &lt;br&gt;    ENQUANTO VERDADEIRO FAÇA&lt;br&gt;        LER venda&lt;br&gt;        SE venda &lt; 0 ENTÃO SAIR DO LOOP&lt;br&gt;        SE (venda &gt;= 0) E (venda &lt;= 1000) ENTÃO&lt;br&gt;            soma ← soma + venda&lt;br&gt;            contador ← contador + 1&lt;br&gt;    FIM ENQUANTO&lt;br&gt;    &lt;br&gt;    SE contador &gt; 0 ENTÃO&lt;br&gt;        media ← soma / contador&lt;br&gt;        ESCREVER \"Média:\", media&lt;br&gt;    SENÃO&lt;br&gt;        ESCREVER \"Nenhuma venda válida\"&lt;br&gt;FIM&lt;br&gt;\n\n\n\n\n\n\nO exercício C1 pode ser resolvido em C++23 usando o código Listing 6.13.\n\n\n\nListing 6.13\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    double venda;\n    \n    // PROCESSAMENTO\n    double soma = 0;\n    int contador = 0;\n    \n    while (true) {\n        std::cout &lt;&lt; \"Digite o valor da venda (negativo para encerrar): \";\n        std::cin &gt;&gt; venda;\n        \n        if (venda &lt; 0) break;\n        \n        if ((venda &gt;= 0) && (venda &lt;= 1000)) {\n            soma = soma + venda;\n            contador = contador + 1;\n        }\n    }\n    \n    // SAÍDA\n    if (contador &gt; 0) {\n        double media = soma / contador;\n        std::cout &lt;&lt; \"Média de vendas: \" &lt;&lt; media &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Nenhuma venda válida foi inserida.\" &lt;&lt; std::endl;\n    }\n    \n    return 0;\n}\n\n\n\nEm Python, o mesmo algorítmo seria representado por:\nsoma = 0\ncontador = 0\nwhile True:\n    venda = float(input(\"Digite o valor da venda (negativo para encerrar): \"))\n    if venda &lt; 0:\n        break\n    if 0 &lt;= venda &lt;= 1000:\n        soma += venda\n        contador += 1\nif contador &gt; 0:\n    media = soma / contador\n    print(f\"Média de vendas: {media}\")\nelse:\n    print(\"Nenhuma venda válida foi inserida.\")\n\n\n6.2.3 Laço do while\nO problema a seguir, que o aluno deve ter resolvido anteriormente, pode ser resolvido utilizando o laço do while.\nF1. Sistema de Análise de Desempenho Acadêmico por Turmas: na escola “Excelência Educacional”, a coordenadora pedagógica Profa. Marina precisa analisar o desempenho de múltiplas turmas simultaneamente. O sistema deve processar numero_turmas turmas, e para cada turma, deve ler numero_alunos da turma e as notas de cada aluno (0-100). Para cada turma, calcular e exibir: média da turma, quantidade de alunos aprovados (nota ≥ 60), maior nota e menor nota. Adicionalmente, o sistema deve identificar qual turma teve a maior média geral e quantos alunos no total ficaram abaixo da média de sua respectiva turma. Notas inválidas (fora do range 0-100) devem ser rejeitadas e solicitadas novamente. Se uma turma tiver menos de 3 alunos válidos, ela deve ser marcada como “Turma Inválida” e não incluída nas estatísticas gerais. No final, exibir um relatório consolidado com: média geral de todas as turmas válidas, total de alunos aprovados em toda a escola, e o número da turma com melhor desempenho.\nAnálise: o pseudocódigo para este exercício, usando goto pode ser representado como:\nALGORITMO AnaliseDesempenhoAcademicoConciso\n\nENTRADA:\n    numeroTurmas, numeroAlunos, nota: inteiro\n\nSAÍDA:\n    mediaTurma, alunosAprovados, maiorNota, menorNota: real\n    melhorTurma, totalAbaixoMedia: inteiro\n\nINÍCIO\n    LER numeroTurmas\n    turmaAtual ← 1\n    melhorMedia ← 0\n    melhorTurma ← 0\n    totalTurmasValidas ← 0\n    somaMediasGeral ← 0\n    totalAlunosAprovadosGeral ← 0\n    totalAbaixoMedia ← 0\n    \nETIQUETA LOOP_TURMAS:\n    ESCREVER \"=== TURMA \", turmaAtual, \" ===\"\n    LER numeroAlunos\n    alunoAtual ← 1\n    somaTurma ← 0\n    alunosValidos ← 0\n    alunosAprovados ← 0\n    maiorNota ← 0\n    menorNota ← 100\n    \nETIQUETA LOOP_ALUNOS:\n    ESCREVER \"Nota do aluno \", alunoAtual, \": \"\n    \nETIQUETA LER_NOTA:\n    LER nota\n    SE (nota &lt; 0) OU (nota &gt; 100) ENTÃO\n        ESCREVER \"Nota inválida! Digite novamente: \"\n        IR PARA LER_NOTA\n    \n    somaTurma ← somaTurma + nota\n    alunosValidos ← alunosValidos + 1\n    SE nota &gt;= 60 ENTÃO alunosAprovados ← alunosAprovados + 1\n    SE nota &gt; maiorNota ENTÃO maiorNota ← nota\n    SE nota &lt; menorNota ENTÃO menorNota ← nota\n    \n    alunoAtual ← alunoAtual + 1\n    SE alunoAtual &lt;= numeroAlunos ENTÃO IR PARA LOOP_ALUNOS\n    \n    SE alunosValidos &lt; 3 ENTÃO\n        ESCREVER \"Turma Inválida (menos de 3 alunos válidos)\"\n        IR PARA PROXIMA_TURMA\n    \n    mediaTurma ← somaTurma / alunosValidos\n    ESCREVER \"Média da turma: \", mediaTurma\n    ESCREVER \"Alunos aprovados: \", alunosAprovados\n    ESCREVER \"Maior nota: \", maiorNota\n    ESCREVER \"Menor nota: \", menorNota\n    \n    totalTurmasValidas ← totalTurmasValidas + 1\n    somaMediasGeral ← somaMediasGeral + mediaTurma\n    totalAlunosAprovadosGeral ← totalAlunosAprovadosGeral + alunosAprovados\n    \n    SE mediaTurma &gt; melhorMedia ENTÃO\n        melhorMedia ← mediaTurma\n        melhorTurma ← turmaAtual\n    \n    alunoContador ← 1\nETIQUETA CONTAR_ABAIXO_MEDIA:\n    SE alunoContador &lt;= alunosValidos ENTÃO\n        SE notaAluno[alunoContador] &lt; mediaTurma ENTÃO\n            totalAbaixoMedia ← totalAbaixoMedia + 1\n        alunoContador ← alunoContador + 1\n        IR PARA CONTAR_ABAIXO_MEDIA\n    \nETIQUETA PROXIMA_TURMA:\n    turmaAtual ← turmaAtual + 1\n    SE turmaAtual &lt;= numeroTurmas ENTÃO IR PARA LOOP_TURMAS\n    \n    ESCREVER \"=== RELATÓRIO CONSOLIDADO ===\"\n    SE totalTurmasValidas &gt; 0 ENTÃO\n        mediaGeral ← somaMediasGeral / totalTurmasValidas\n        ESCREVER \"Média geral: \", mediaGeral\n        ESCREVER \"Total de alunos aprovados: \", totalAlunosAprovadosGeral\n        ESCREVER \"Melhor turma: \", melhorTurma\n        ESCREVER \"Alunos abaixo da média: \", totalAbaixoMedia\n    SENÃO\n        ESCREVER \"Nenhuma turma válida encontrada\"\n        \nFIM\nPor outro lado, usando o laço do while, o pseudocódigo para este exercício pode ser representado por:\n// Versão com goto (atual)\nLER_NOTA:\n    std::cin &gt;&gt; nota;\n    if ((nota &lt; 0) || (nota &gt; 100)) {\n        std::cout &lt;&lt; \"Nota inválida! Digite novamente: \";\n        goto LER_NOTA;\n    }\n\n// Equivalente com DO-WHILE\ndo {\n    std::cin &gt;&gt; nota;\n    if ((nota &lt; 0) || (nota &gt; 100)) {\n        std::cout &lt;&lt; \"Nota inválida! Digite novamente: \";\n    }\n} while ((nota &lt; 0) || (nota &gt; 100));\nO exercício F1 pode ser resolvido em C++23 usando o código Listing 6.14.\n\n\n\nListing 6.14\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    // ENTRADA\n    int numeroAlunos;\n    int nota;\n    \n    std::cout &lt;&lt; \"Número de alunos: \";\n    std::cin &gt;&gt; numeroAlunos;\n    \n    // PROCESSAMENTO\n    double soma = 0;\n    int alunosValidos = 0;\n    int alunosAprovados = 0;\n    int maiorNota = 0;\n    int menorNota = 100;\n    \n    for (int i = 1; i &lt;= numeroAlunos; i++) {\n        std::cout &lt;&lt; \"Aluno \" &lt;&lt; i &lt;&lt; std::endl;\n        \n        // VALIDAÇÃO COM DO-WHILE\n        do {\n            std::cout &lt;&lt; \"Digite a nota (0-100): \";\n            std::cin &gt;&gt; nota;\n            \n            if ((nota &lt; 0) || (nota &gt; 100)) {\n                std::cout &lt;&lt; \"Nota inválida! Deve estar entre 0 e 100.\" &lt;&lt; std::endl;\n            }\n        } while ((nota &lt; 0) || (nota &gt; 100));\n        \n        // PROCESSAMENTO DA NOTA VÁLIDA\n        soma = soma + nota;\n        alunosValidos = alunosValidos + 1;\n        \n        if (nota &gt;= 60) {\n            alunosAprovados = alunosAprovados + 1;\n        }\n        \n        if (nota &gt; maiorNota) {\n            maiorNota = nota;\n        }\n        \n        if (nota &lt; menorNota) {\n            menorNota = nota;\n        }\n    }\n    \n    // SAÍDA\n    if (alunosValidos &gt; 0) {\n        double media = soma / alunosValidos;\n        std::cout &lt;&lt; \"n=== RELATÓRIO DA TURMA ===\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Média da turma: \" &lt;&lt; media &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Alunos aprovados: \" &lt;&lt; alunosAprovados &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Maior nota: \" &lt;&lt; maiorNota &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Menor nota: \" &lt;&lt; menorNota &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Nenhum aluno válido.\" &lt;&lt; std::endl;\n    }\n    \n    return 0;\n}\n\n\n\nEm Python, o mesmo algorítmo seria representado por:\nnumero_alunos = int(input(\"Número de alunos: \"))\n\nsoma = 0\nalunos_validos = 0\nalunos_aprovados = 0\nmaior_nota = 0\nmenor_nota = 100\n\nfor i in range(1, numero_alunos + 1):\n    print(f\"Aluno {i}\")\n    \n    # SIMULAÇÃO DO DO-WHILE\n    while True:\n        nota = int(input(\"Digite a nota (0-100): \"))\n        \n        if 0 &lt;= nota &lt;= 100:\n            break  # Sai do loop se válida\n        else:\n            print(\"Nota inválida! Deve estar entre 0 e 100.\")\n    \n    # PROCESSAMENTO DA NOTA VÁLIDA\n    soma += nota\n    alunos_validos += 1\n    \n    if nota &gt;= 60:\n        alunos_aprovados += 1\n    \n    if nota &gt; maior_nota:\n        maior_nota = nota\n    \n    if nota &lt; menor_nota:\n        menor_nota = nota\n\n# SAÍDA\nif alunos_validos &gt; 0:\n    media = soma / alunos_validos\n    print(\"n=== RELATÓRIO DA TURMA ===\")\n    print(f\"Média da turma: {media}\")\n    print(f\"Alunos aprovados: {alunos_aprovados}\")\n    print(f\"Maior nota: {maior_nota}\")\n    print(f\"Menor nota: {menor_nota}\")\nelse:\n    print(\"Nenhum aluno válido.\")",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>**Módulo 1**: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span>"
    ]
  },
  {
    "objectID": "desenv1.html#problemas-para-prática",
    "href": "desenv1.html#problemas-para-prática",
    "title": "6  Módulo 1: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição",
    "section": "6.3 Problemas para Prática",
    "text": "6.3 Problemas para Prática\nUma vez que o aluno tenha compreendido os laços de repetição, o professor pode optar por solicitar que os alunos refaçam os exercícios que fizeram, em um esforço de abstração e compreensão dos laços de repetição, seja por repetição ou pela apresentação de um conjunto novo de problemas. A seguir está uma lista com 12 problemas para aplicação usando a Técnica da Sequência de Fibonacci (1, 1, 2, 3, 5).\n1f. Na empresa de consultoria matemática “Números Dourados”, o analista precisa gerar os primeiros N termos da sequência de Fibonacci para análise de padrões. A sequência começa com 0 e 1, e cada termo seguinte é a soma dos dois anteriores (0, 1, 1, 2, 3, 5, 8, 13…). Crie um algoritmo que receba N e exiba os primeiros N termos da sequência.\n2w. No supermercado “Compra Certa”, o gerente precisa registrar vendas de produtos até que o estoque se esgote. O sistema inicia com estoque_inicial unidades de um produto. A cada venda, deve ler a quantidade_vendida e subtrair do estoque. O processo continua enquanto houver estoque disponível e a quantidade vendida for válida (positiva e não maior que o estoque atual). Ao final, exibir o total de vendas realizadas e a quantidade total vendida.\n3d. Na calculadora científica “MathPro”, o usuário deve escolher operações matemáticas através de um menu: 1-Adição, 2-Subtração, 3-Multiplicação, 4-Divisão, 5-Sair. Após escolher uma operação válida (1-4), ler dois números e exibir o resultado. Se escolher 5, encerrar o programa. Para qualquer opção inválida, exibir mensagem de erro e mostrar o menu novamente. O menu deve aparecer pelo menos uma vez.\n4f. No laboratório meteorológico “Clima Exato”, a pesquisadora precisa gerar uma tabela de conversão de Celsius para Fahrenheit e Kelvin. O algoritmo deve receber temperatura_inicial, temperatura_final e incremento, e exibir uma tabela com todas as temperaturas no intervalo especificado. Fórmulas: F = C × 9/5 + 32 e K = C + 273.15.\n5w. Na empresa de jogos “Mente Ágil”, o desenvolvedor criou um jogo no qual o computador “pensa” em um número entre 1 e 50 (fixo: 27). O jogador faz tentativas até acertar. A cada tentativa errada, o jogo informa se o número é “maior” ou “menor” que o palpite. Contar quantas tentativas foram necessárias e exibir no final junto com uma mensagem de parabéns.\n6d. No sistema de cadastro da rede social “ConectaMais”, o usuário deve criar uma senha que atenda critérios específicos: ter pelo menos 8 caracteres, conter pelo menos um número e começar com letra maiúscula. O sistema deve solicitar a senha e validar todos os critérios. Se algum critério não for atendido, explicar qual falhou e solicitar nova senha. O processo continua até uma senha válida ser inserida.\n7f. No banco “Investimento Seguro”, o consultor financeiro precisa mostrar a evolução de um investimento ao longo dos anos. Dados o capital_inicial, taxa_juros anual e numero_anos, calcular e exibir o montante a cada ano usando a fórmula: Montante = Capital × (1 + taxa)^ano. Exibir uma tabela mostrando ano a ano a evolução do investimento.\n8w. Na escola “Futuro Brilhante”, o professor precisa calcular a média de uma turma. O sistema lê notas de alunos (valores entre 0 e 10) até que seja digitada uma nota inválida (negativa ou maior que 10), que indica o fim da entrada. Calcular e exibir: média da turma, maior nota, menor nota, quantidade de alunos aprovados (nota ≥ 7) e percentual de aprovação.\n9d. No banco digital “FinTech Nova”, antes de executar uma transferência, o sistema deve confirmar os dados com o usuário. Exibir: valor da transferência, conta de destino e taxa. Perguntar “Confirma a transação? (S/N)”. Se digitar ‘S’ ou ‘s’, executar a transferência. Se digitar ‘N’ ou ‘n’, cancelar. Para qualquer outra resposta, mostrar “Opção inválida” e perguntar novamente. O sistema deve fazer a pergunta pelo menos uma vez.\n10f. Na gráfica “Arte Digital”, o designer precisa gerar padrões visuais usando asteriscos. Dado um número N, criar um padrão triangular no qual a primeira linha tem 1 asterisco, a segunda tem 2, e assim por diante até N asteriscos na última linha. Exemplo para N=4:\n*\n**\n***\n****\n11w. No sistema de segurança “Proteção Total”, o usuário tem no máximo 3 tentativas para inserir a senha correta (fixo: “seguro123”). A cada tentativa errada, decrementar o contador e informar quantas tentativas restam. Se acertar, exibir “Acesso liberado”. Se esgotar as tentativas, exibir “Acesso bloqueado - sistema travado”. O processo para quando a senha for correta ou as tentativas acabarem.\n12d. No hospital “Cuidar Bem”, após cada atendimento, o paciente deve avaliar o serviço numa escala de 1 a 5 (1-Péssimo, 2-Ruim, 3-Regular, 4-Bom, 5-Excelente). O sistema deve solicitar a avaliação e só aceitar valores entre 1 e 5. Para valores inválidos, exibir “Avaliação inválida. Use valores de 1 a 5” e solicitar novamente. Após uma avaliação válida, exibir uma mensagem de agradecimento correspondente à nota dada.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>**Módulo 1**: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span>"
    ]
  },
  {
    "objectID": "desenv1.html#avaliação-problemas-ad-hoc",
    "href": "desenv1.html#avaliação-problemas-ad-hoc",
    "title": "6  Módulo 1: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição",
    "section": "6.4 Avaliação: Problemas Ad-hoc",
    "text": "6.4 Avaliação: Problemas Ad-hoc\nUm problema ad-hoc, no domínio da Metodologia DAAD, é um quebra-cabeça que depende de uma observação específica, de uma regra matemática ou de uma simulação cuidadosa, utilizando apenas as ferramentas mais fundamentais da programação.\nA dificuldade na solução destes problemas não será encontrada no processo de escrever o código, que muitas vezes é curto e direto. A dificuldade está em descobrir a chave que destrava a solução. Os problemas são resolvidos com lógica e com as técnicas de solução de problemas que estamos discutindo neste estudo. Contudo, como esta disciplina está proposta para os primeiros dois períodos dos cursos de Ciência e Engenharia da Computação, o enunciado dos problemas foi simplificado, transformando-os em problemas de Raciocínio Algorítmico simples. Ainda assim, eles exigem uma abordagem estruturada e lógica para serem resolvidos.\n\nDecomposição: compreender e Testar com Casos Pequenos. A primeira etapa é garantir um entendimento absoluto do problema. Isso envolve ler o enunciado múltiplas vezes e, principalmente, testar o processo manualmente com exemplos simples. Para o problema “Número Perfeito”, por exemplo, testar com N=6, N=12 e N=28 revelará o padrão de funcionamento. Identificar o Desafio Central: Qual é a restrição ou a dificuldade principal? No problema “Divisível por 11”, o desafio não é a divisibilidade em si, mas como verificá-la processando o número dígito a dígito, sem armazená-los.\nAbstração: quase todo problema ad-hoc tem um momento Eureka! Pode ser uma propriedade matemática, como a regra de divisibilidade por 11, uma otimização, como usar a raiz quadrada para encontrar divisores, ou a redução de um sistema complexo a uma regra simples. Aqui, existe a espiral da Depuração: testar a solução com números pequenos, como 1, 2, 3, 4, 5, até encontrar um padrão ou uma regra que funcione. A abstração é o processo de identificar essa regra geral que pode ser aplicada a todos os casos do problema. A depuração permite validar a regra.\nAlgoritmização: apenas com a lógica da solução bem definida, a implementação pode começar. O objetivo é traduzir a ideia em um algoritmo claro, passo a passo, antes de escrever qualquer código. Este processo transforma um raciocínio abstrato em um conjunto de instruções concretas. Um fluxograma, um pseudocódigo ou o próprio código são formas de representar essa lógica. A implementação deve ser feita com clareza, seguindo a lógica definida na etapa anterior.\nDepuração: testar a solução com casos de teste variados, incluindo os limites do problema. A depuração é essencial para garantir que a solução funcione corretamente em todos os cenários possíveis. Isso envolve verificar se a implementação atende às condições do problema e se produz os resultados esperados.\n\nA Table 6.45 apresenta um resumo dos problemas selecionados para avaliação deste módulo, apresentando uma visão geral dos cinco problemas analisados, destacando os conceitos fundamentais que cada um exercita.\n\n\n\nTable 6.45: Resumo dos problemas selecionados para avaliação deste módulo.\n\n\n\n\n\n\n\n\n\n\nNome do Problema\nConceito Chave\nEstruturas Fundamentais\n\n\n\n\nDivisibilidade por 11\nRegra de Divisibilidade Matemática (Posições Ímpares vs Pares)\nLaço de Repetição, Decisão, Manipulação de Dígitos\n\n\nVerificação de Número Palíndromo\nReversão e Comparação de Sequências Numéricas\nLaço de Repetição, Decisão, Construção de Número Invertido\n\n\nRaiz Digital de um Número\nIteração Convergente (Soma Repetida até Dígito Único)\nLaços Aninhados, Decisão, Soma Acumulativa\n\n\nNúmero Feliz\nDetecção de Ciclos com Limite Superior\nLaços Aninhados, Decisão, Aritmética de Quadrados\n\n\nMaior e Menor Dígito\nBusca de Extremos em Sequência Linear\nLaço de Repetição, Decisão, Comparação de Valores\n\n\n\n\n\n\nAs seções a seguir detalham cada um dos cinco problemas, com enunciado estendido, para diminuir a necessidade de pesquisa de matemática teórica, seguidos de uma análise detalhada do problema frente à Metodologia DAAD.\n\n6.4.1 Problema 1: Divisibilidade por 11\nDado um número inteiro positivo \\(N\\) (\\(1 \\leq N \\leq 10^9\\)), determine se \\(N\\) é divisível por \\(11\\). Você só pode usar operações aritméticas básicas e laços de repetição, e não pode armazenar os dígitos do número em estruturas de dados compostas como arrays ou estruturas similares.\nDivisibilidade: um número \\(a\\) é divisível por um número \\(b\\) se a divisão \\(a/b\\) resultar em um número inteiro, sem resto. A chave para resolver o problema é a conhecida regra de divisibilidade por \\(11\\): um número é divisível por \\(11\\) se a diferença absoluta entre a soma dos dígitos em posições ímpares e a soma dos dígitos em posições pares for um número divisível por \\(11\\). Por exemplo, para \\(N=132\\), os dígitos são \\(1\\), \\(3\\) e \\(2\\). Posições (da direita para a esquerda): \\(2\\) (pos \\(1\\), ímpar), \\(3\\) (pos \\(2\\), par), \\(1\\) (pos \\(3\\), ímpar).\n\nSoma ímpar: \\(2+1=3\\)\n\nSoma par: \\(3\\)\n\nDiferença: \\(\\lvert 3 − 3 \\rvert=0\\). Como \\(0\\) é divisível por \\(11\\), \\(132\\) também é.\n\n\n6.4.1.1 Decomposição e Abstração\nA primeira abordagem seria simplesmente calcular \\(N \\% 11\\). No entanto, o problema foi desenhado para treinar a manipulação de um número dígito a dígito. Esta restrição induz a necessidade de entender a divisibilidade em um nível mais fundamental. O aluno, ou grupo, terá que descobrir como processar o número sem armazenar seus dígitos, o que é um desafio interessante.\nO desafio é implementar esta regra sem usar arrays. Para isso, será necessário processar o número \\(N\\) da direita para a esquerda usando operações de módulo e divisão. O laço while (\\(N &gt; 0\\)) é a ferramenta perfeita para isso. Em cada iteração, \\(N \\% 10\\) nos dá o último dígito, e \\(N = N / 10\\) remove esse dígito. Para alternar entre as somas par e ímpar, é possível usar uma variável de controle (\\(posicao\\)) que alterna entre \\(0\\) e \\(1\\) a cada passo.\n\n\n6.4.1.2 Algoritmização\nALGORITMO VerificaDivisibilidadePor11Conciso\n\nENTRADA:\n    N: inteiro\n\nSAÍDA:\n    divisivel: booleano\n\nINÍCIO\n    LER N\n    numeroOriginal ← N\n    somaImpar ← 0\n    somaPar ← 0\n    posicao ← 1\n    \nETIQUETA EXTRAIR_DIGITOS:\n    SE N = 0 ENTÃO IR PARA CALCULAR_DIFERENCA\n    \n    digito ← N % 10\n    N ← N / 10\n    \n    SE (posicao % 2 = 1) ENTÃO\n        somaImpar ← somaImpar + digito\n    SENÃO\n        somaPar ← somaPar + digito\n    \n    posicao ← posicao + 1\n    IR PARA EXTRAIR_DIGITOS\n\nETIQUETA CALCULAR_DIFERENCA:\n    SE somaImpar &gt;= somaPar ENTÃO\n        diferenca ← somaImpar - somaPar\n    SENÃO\n        diferenca ← somaPar - somaImpar\n    \n    SE (diferenca % 11 = 0) ENTÃO\n        divisivel ← VERDADEIRO\n        ESCREVER numeroOriginal, \" é divisível por 11\"\n    SENÃO\n        divisivel ← FALSO\n        ESCREVER numeroOriginal, \" não é divisível por 11\"\n    \n    ESCREVER \"Soma posições ímpares:\", somaImpar\n    ESCREVER \"Soma posições pares:\", somaPar\n    ESCREVER \"Diferença absoluta:\", diferenca\n    \n    RETORNAR divisivel\nFIM\n\n\n6.4.1.3 Depuração\nO erro mais comum é confundir a ordem das posições ou não alternar a variável de controle corretamente. É útil testar com caneta e papel usando um número como \\(98765\\) para garantir que as somas estão sendo calculadas corretamente. A beleza desta solução está em como ela decompõe um número grande em uma série de operações simples, usando apenas algumas variáveis para manter o estado.\n\n\n\n6.4.2 Problema 2: Verificação de Número Palíndromo\nDado um número inteiro positivo \\(N\\) (\\(1 \\leq N \\leq 10^9\\)), determine se \\(N\\) é um palíndromo. Um número palíndromo é aquele que permanece o mesmo quando seus dígitos são invertidos. Você só pode usar operações aritméticas básicas e laços de repetição, e não pode armazenar os dígitos do número em estruturas de dados compostas como arrays ou strings.\nNúmero Palíndromo: um número que se lê da mesma forma da esquerda para a direita e da direita para a esquerda. Por exemplo, \\(12321\\) é palíndromo porque invertido continua sendo \\(12321\\). Já \\(12345\\) não é palíndromo porque invertido vira \\(54321\\). Para resolver este problema, precisamos construir o número invertido e comparar com o original.\n\n6.4.2.1 Decomposição e Abstração\nO desafio está em construir o número invertido sem usar arrays para armazenar os dígitos. A estratégia é processar o número original da direita para a esquerda, extraindo cada dígito com \\(N \\bmod 10\\) e construindo simultaneamente o número invertido. Para construir o invertido, multiplicamos o valor atual por \\(10\\) e somamos o novo dígito. O algoritmo termina quando o número original se torna \\(0\\), momento em que comparamos o número invertido com o valor original salvo.\n\n\n6.4.2.2 Algoritmização\nALGORITMO VerificaPalindromoConciso\n\nENTRADA:\n    N: inteiro\n\nSAÍDA:\n    palindromo: booleano\n\nINÍCIO\n    LER N\n    numeroOriginal ← N\n    numeroInvertido ← 0\n    \nETIQUETA INVERTER_NUMERO:\n    SE N = 0 ENTÃO IR PARA COMPARAR\n    \n    digito ← N % 10\n    numeroInvertido ← numeroInvertido * 10 + digito\n    N ← N / 10\n    IR PARA INVERTER_NUMERO\n\nETIQUETA COMPARAR:\n    SE numeroOriginal = numeroInvertido ENTÃO\n        palindromo ← VERDADEIRO\n        ESCREVER numeroOriginal, \" é palíndromo\"\n    SENÃO\n        palindromo ← FALSO\n        ESCREVER numeroOriginal, \" não é palíndromo\"\n    \n    ESCREVER \"Número original:\", numeroOriginal\n    ESCREVER \"Número invertido:\", numeroInvertido\n    \n    RETORNAR palindromo\nFIM\n\n\n6.4.2.3 Depuração\nO erro mais frequente é esquecer de salvar o número original antes de modificá-lo, resultando em comparação incorreta. Outro erro comum é a construção incorreta do número invertido. É importante ter em mente que para adicionar um dígito à direita, multiplicamos por \\(10\\) e somamos o dígito. Tabelas de Rastreio podem ser criadas com números simples como \\(121\\) e \\(12321\\) para verificar a lógica.\n\n\n\n6.4.3 Problema 3: Raiz Digital de um Número\nDado um número inteiro positivo \\(N\\) (\\(1 \\leq N \\leq 10^9\\)), calcule sua raiz digital. A raiz digital é obtida somando repetidamente os dígitos de um número até obter um único dígito. Você só pode usar operações aritméticas básicas e laços de repetição, e não pode armazenar os dígitos do número em estruturas de dados compostas.\nRaiz Digital (RD): resultado da soma iterativa dos dígitos até sobrar apenas um dígito. Por exemplo, para \\(N = 9875\\): soma dos dígitos \\(RD= 9 + 8 + 7 + 5 = 29\\). Como \\(29\\) tem dois dígitos, repetimos: \\(2 + 9 = 11\\). Como \\(11\\) tem dois dígitos: \\(1 + 1 = 2\\). A raiz digital de \\(9875\\) é \\(2\\). Existe uma fórmula matemática para isso que não pode ser usada para resolver este problema. O objetivo é implementar o processo iterativo para treinar manipulação de dígitos.\n\n6.4.3.1 Decomposição e Abstração\nO algoritmo precisa de dois laços de repetição aninhados: um externo que continua enquanto o número tiver mais de um dígito, e um interno que soma todos os dígitos do número atual. A cada iteração do loop externo, o número é substituído pela soma de seus dígitos. O processo para quando o número se torna menor que \\(10\\), um único dígito. Para verificar se um número tem mais de um dígito, basta testar se é maior ou igual a \\(10\\).\n\n\n6.4.3.2 Algoritmização\nALGORITMO CalculaRaizDigitalConciso\n\nENTRADA:\n    N: inteiro\n\nSAÍDA:\n    raizDigital: inteiro\n\nINÍCIO\n    LER N\n    numeroOriginal ← N\n    \nETIQUETA LOOP_PRINCIPAL:\n    SE N &lt; 10 ENTÃO IR PARA RESULTADO\n    \n    soma ← 0\n    numeroTemp ← N\n    \nETIQUETA SOMAR_DIGITOS:\n    SE numeroTemp = 0 ENTÃO\n        N ← soma\n        IR PARA LOOP_PRINCIPAL\n    \n    digito ← numeroTemp % 10\n    soma ← soma + digito\n    numeroTemp ← numeroTemp / 10\n    IR PARA SOMAR_DIGITOS\n\nETIQUETA RESULTADO:\n    raizDigital ← N\n    ESCREVER \"Número original:\", numeroOriginal\n    ESCREVER \"Raiz digital:\", raizDigital\n    \n    RETORNAR raizDigital\nFIM\n\n\n6.4.3.3 Depuração\nUm erro comum é não reinicializar corretamente as variáveis a cada iteração. Certifique-se de que soma é zerada antes de cada cálculo e que numeroTemp recebe o valor atual de \\(N\\). Outro erro é confundir as condições de parada dos laços de repetição. Uma forma interessante de depurar é a criação de tabela de rastreio com números como \\(38\\) (\\(3 + 8 = 11\\), \\(1 + 1 = 2\\)) para verificar múltiplas iterações.\n\n\n\n6.4.4 Problema 4: Número Feliz\nDado um número inteiro positivo \\(N\\) (\\(1 \\leq N \\leq 10^9\\)), determine se \\(N\\) é um “número feliz”. Um número é feliz se, ao repetir o processo de substituir o número pela soma dos quadrados de seus dígitos, eventualmente chegamos ao número \\(1\\). Se o processo entrar em um ciclo que não inclui \\(1\\), o número é “infeliz”. Você só pode usar operações aritméticas básicas e laços de repetição, limitando-se a \\(100\\) iterações para detectar ciclos.\nNúmero Feliz: conceito matemático no qual aplicamos repetidamente a operação “soma dos quadrados dos dígitos”. Por exemplo, \\(N = 23\\): \\(2^2 + 3^2 = 4 + 9 = 13\\). Depois \\(1^2 + 3^2 = 1 + 9 = 10\\). Depois \\(1^2 + 0^2 = 1 + 0 = 1\\). Como chegamos a \\(1\\), o número \\(23\\) é feliz. Alguns números entram em ciclos infinitos, como \\(4 \\rightarrow 16 \\rightarrow 37 \\rightarrow 58 \\rightarrow 89 \\rightarrow 145 \\rightarrow 42 \\rightarrow 20 \\rightarrow 4\\), sendo portanto infelizes.\n\n6.4.4.1 Decomposição e Abstração\nO algoritmo precisa repetir o processo de calcular a soma dos quadrados dos dígitos até chegar a \\(1\\) (feliz) ou detectar um possível ciclo. Como a identificação automática de ciclos requer estruturas de dados mais complexas, como arrays e conjunto, as iterações estão limitadas a \\(100\\). Se após \\(100\\) iterações o valor \\(1\\) não for alcançado, o algoritmo deve assumir que o número é infeliz. Para cada iteração, os dígitos são extraídos, seus quadrados são calculados e somados, substituindo o número original por esta soma.\n\n\n6.4.4.2 Algoritmização\nALGORITMO VerificaNumeroFelizConciso\n\nENTRADA:\n    N: inteiro\n\nSAÍDA:\n    feliz: booleano\n\nINÍCIO\n    LER N\n    numeroOriginal ← N\n    iteracoes ← 0\n    \nETIQUETA LOOP_PRINCIPAL:\n    SE N = 1 ENTÃO IR PARA NUMERO_FELIZ\n    SE iteracoes &gt;= 100 ENTÃO IR PARA NUMERO_INFELIZ\n    \n    soma ← 0\n    numeroTemp ← N\n    \nETIQUETA CALCULAR_SOMA_QUADRADOS:\n    SE numeroTemp = 0 ENTÃO\n        N ← soma\n        iteracoes ← iteracoes + 1\n        IR PARA LOOP_PRINCIPAL\n    \n    digito ← numeroTemp % 10\n    soma ← soma + (digito * digito)\n    numeroTemp ← numeroTemp / 10\n    IR PARA CALCULAR_SOMA_QUADRADOS\n\nETIQUETA NUMERO_FELIZ:\n    feliz ← VERDADEIRO\n    ESCREVER numeroOriginal, \" é um número feliz\"\n    ESCREVER \"Chegou a 1 em\", iteracoes, \"iterações\"\n    IR PARA FIM_ALGORITMO\n\nETIQUETA NUMERO_INFELIZ:\n    feliz ← FALSO\n    ESCREVER numeroOriginal, \" é um número infeliz\"\n    ESCREVER \"Não chegou a 1 em 100 iterações\"\n\nETIQUETA FIM_ALGORITMO:\n    RETORNAR feliz\nFIM\n\n\n6.4.4.3 Depuração\nO erro mais comum é calcular incorretamente o quadrado dos dígitos ou somar incorretamente. O aluno deve verificar se digito * digito está sendo calculado corretamente. Outro erro é não reinicializar soma a cada iteração. Números conhecidos: 1 (já é feliz), 7 (feliz), e 4 (infeliz) são interessantes para a criação de tabelas de rastreio.\n\n\n\n6.4.5 Problema 5: Maior e Menor Dígito\nDado um número inteiro positivo \\(N\\) (\\(1 \\leq N \\leq 10^9\\)), encontre o maior e o menor dígito que compõem este número. Você só pode usar operações aritméticas básicas e laços de repetição, e não pode armazenar os dígitos do número em estruturas de dados compostas como arrays.\nMaior e Menor Dígito: em qualquer número, cada dígito está entre 0 e 9. O objetivo é percorrer todos os dígitos do número e manter registro do maior e menor encontrados. Por exemplo, para \\(N=49327\\), os dígitos são 4, 9, 3, 2, 7. O maior dígito é 9 e o menor é 2. Este problema treina a capacidade de manter estado (maior e menor) durante a iteração pelos dígitos.\n\n6.4.5.1 Decomposição e Abstração\nA estratégia é inicializar o maior dígito com 0 (menor valor possível) e o menor dígito com \\(9\\), maior valor possível. Conforme extraímos cada dígito usando \\(N \\bmod 10\\), comparamos com os valores atuais de maior e menor, atualizando quando necessário. O processo continua até que todos os dígitos sejam processados (\\(N = 0\\)). A beleza desta solução está na simplicidade: apenas duas comparações por dígito são suficientes para manter o estado desejado.\n\n\n6.4.5.2 Algoritmização\nALGORITMO EncontraMaiorMenorDigitoConciso\n\nENTRADA:\n    N: inteiro\n\nSAÍDA:\n    maiorDigito, menorDigito: inteiro\n\nINÍCIO\n    LER N\n    numeroOriginal ← N\n    maiorDigito ← 0\n    menorDigito ← 9\n    \nETIQUETA PROCESSAR_DIGITOS:\n    SE N = 0 ENTÃO IR PARA RESULTADO\n    \n    digito ← N % 10\n    N ← N / 10\n    \n    SE digito &gt; maiorDigito ENTÃO\n        maiorDigito ← digito\n    \n    SE digito &lt; menorDigito ENTÃO\n        menorDigito ← digito\n    \n    IR PARA PROCESSAR_DIGITOS\n\nETIQUETA RESULTADO:\n    ESCREVER \"Número original:\", numeroOriginal\n    ESCREVER \"Maior dígito:\", maiorDigito\n    ESCREVER \"Menor dígito:\", menorDigito\n    ESCREVER \"Diferença:\", (maiorDigito - menorDigito)\n    \n    RETORNAR maiorDigito, menorDigito\nFIM\n\n\n6.4.5.3 Depuração\nUm erro inicial comum é não inicializar corretamente as variáveis: maior deve começar em 0 (menor valor possível para um dígito) e menor deve começar em \\(9\\). Outro erro é esquecer de processar números com dígitos \\(0\\), certifique-se de que o algoritmo funciona corretamente com números como 1029. Para a tabela de rastreio, considere casos extremos como \\(1111\\) e \\(9000\\).\n\n\n\n\n[1] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information processing – documentation symbols and conventions for data, program and system flowcharts, program network charts and system resources charts. [s.l.] International Organization for Standardization, 1985. Disponível em: &lt;https://cdn.standards.iteh.ai/samples/11955/1b7dd254a2a54fd7a89d616dc0570e18/ISO-5807-1985.pdf&gt;.\n\n\n[2] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information technology – Programming languages – C++. Geneva, Switzerland: International Organization for Standardization (ISO), 2020. Disponível em: &lt;https://isocpp.org/std/the-standard&gt;.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>**Módulo 1**: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span>"
    ]
  },
  {
    "objectID": "desenv2.html",
    "href": "desenv2.html",
    "title": "7  Módulo 2: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões",
    "section": "",
    "text": "7.1 Abstração: Reutilização\nAplicação da abstração na programação: criação de componentes reutilizáveis, funções, laços de repetição e estruturas de dados. Utilizando a Linguagem C++ com as abstrações de função, for, while, do while.\nAntes de ofertar os novos exercícios, o professor pode revisar os conceitos de abstração que foram introduzidos no Módulo 1. Como por exemplo, o professor pode considerar usar os exercícios \\(4\\) exercícios a seguir para revisar os conceitos de abstração e controle de fluxo. Observe que os exercícios são complexos e demandam tempo de implementação, por isso o professor deve escolher os exercícios de acordo com o tamanho e o resultado da turma, mas deve se manter na Técnica da Sequência de Fibonacci. Vimos a Técnica da Sequência de Fibonacci na Section 6.1.1 nesta técnica além de tempos e quantidades, o professor precisa se preocupar que a devolutiva deve ser feita no quadro, com o professor explicando cada passo do algoritmo, enfatizando a importância da decomposição e controle de fluxo. A seguir está uma lista de problemas que podem ser usados para esta atividade:\nRevisão 1: dado um número inteiro positivo \\(N\\) (\\(1 \\leq N \\leq 10^9\\)), encontre o maior e o menor dígito que compõem este número. Você só pode usar operações aritméticas básicas e laços de repetição, e não pode armazenar os dígitos do número em estruturas de dados compostas como arrays.\nEm qualquer número, cada dígito está entre \\(0\\) e \\(9\\). O objetivo é percorrer todos os dígitos do número e manter registro do maior e menor encontrados. Por exemplo, para \\(N = 49327\\), os dígitos são \\(4\\), \\(9\\), \\(3\\), \\(2\\), \\(7\\). O maior dígito é \\(9\\) e o menor é \\(2\\). Este problema treina a capacidade de manter estado (maior e menor) durante a iteração pelos dígitos.\nAlgoritmização:\nO código Listing 7.1 apresenta o código em C++23 que implementa o algoritmo acima.\nMas, como os alunos já devem estar familiarizados com as estruturas de repetição, o professor pode propor uma versão mais concisa do algoritmo, utilizando a abstração de função. O código Listing 7.2, apresenta o código em C++23 que implementa o algoritmo acima, mas com a abstração de função.\nRevisão 2: no Laboratório de Engenharia, o professor Carlos precisa implementar uma calculadora científica que calcule o seno de ângulos com alta precisão. Como as funções trigonométricas padrão podem ter limitações de precisão, ele decide usar a série de Taylor para sen(x). A série é definida como:\n\\[\\sin(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \\frac{x^9}{9!} - \\cdots = \\sum_{n=0}^{\\infty} \\frac{(-1)^n \\cdot x^{2n+1}}{(2n+1)!}\\]\nO sistema deve receber um angulo em radianos e a precisao desejada, número de termos da série, calcular o seno usando a série de Taylor e comparar com o resultado obtido na sua calculadora. Desenvolva um algoritmo que implemente este cálculo, mostrando cada termo da série e o erro absoluto em relação ao valor da biblioteca padrão.\nSolução:\nNeste caso, o pseudocódigo pode ser representado como:\nPseudocódigo:\nO código em C++23 que implementa o algoritmo acima, utilizando a biblioteca padrão C++ (STL) e ranges, pode ser representado visto na Listing 7.3:\nO código da Listing 7.3 implementa a série de Taylor para calcular o seno de um ângulo em radianos, mostrando cada termo da série e o erro absoluto em relação ao valor de referência. O professor pode propor diferentes valores de angulo e senoReferencia para testar a precisão do cálculo a Table 7.1 contém algumas sugestões.\nRevisão 3. na empresa de software “Algoritmos Precisos”, a matemática Dra. Marina está desenvolvendo um módulo para calcular o valor de pi com diferentes níveis de precisão. Ela escolheu usar a série de Leibniz, também conhecida como série de Gregory-Leibniz e dada por:\n\\[\\frac{\\pi}{4} = 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} - \\cdots = \\sum_{n=0}^{\\infty} \\frac{(-1)^n}{2n+1}\\]\nO sistema deve receber o numero_termos desejado, calcular pi usando a série, mostrar a convergência a cada 1000 iterações e comparar com o valor de pi digitado manualmente. Além disso, deve calcular quantos termos são necessários para atingir uma precisão de pelo menos 6 casas decimais. Crie um algoritmo que implemente este cálculo de pi.\nSolução:\nEste exercício envolve a aproximação do fatorial usando a fórmula de Stirling e uma série de correção. O pseudocódigo para este exercício pode ser representado como:\nNeste caso, o código Listing 7.4, em C++23 mostra como pseudocódigo pode ser representado com C++23, utilizando a biblioteca padrão C++ (STL) e ranges. O uso de std::views::iota permite iterar facilmente sobre uma sequência de números, e o uso de auto simplifica a dedução de tipos, fazendo com que o código da Listing 7.4 seja mais conciso e legível.\nRevisão 4: no Centro de Pesquisa em Matemática Computacional, o Dr. Roberto está estudando diferentes métodos para aproximar fatoriais de números grandes. Ele decidiu implementar uma versão simplificada da fórmula de Stirling combinada com uma série de correção. A fórmula de Stirling é uma aproximação do fatorial de um número grande \\(n\\) e é dada por:\n\\[n! \\approx \\sqrt{2\\pi n} \\left(\\frac{n}{e}\\right)^n \\cdot \\left(1 + \\frac{1}{12n} + \\frac{1}{288n^2}\\right)\\]\nQue pode ser expressa usando somatório e produtório como:\n\\[\\text{Aproximação} = \\sqrt{2\\pi n} \\cdot \\prod_{i=1}^{n} \\frac{i}{e} \\cdot \\sum_{k=0}^{2} \\frac{c_k}{n^k}\\]\nNa qual \\(c_0 = 1\\), \\(c_1 = \\frac{1}{12}\\), \\(c_2 = \\frac{1}{288}\\).\nO sistema deve receber um número n, calcular o fatorial exato (para \\(n \\leq 20\\)), calcular a aproximação usando a fórmula acima, mostrar os valores do produtório e somatório separadamente, e calcular o erro percentual entre o valor exato e a aproximação. Como a fórmula de Stirling requer o cálculo de \\(\\sqrt{2\\pi n}\\), o algoritmo deve implementar o método babilônico para calcular raiz quadrada sem depender de bibliotecas matemáticas externas. O método babilônico utiliza a fórmula iterativa \\(x_{novo} = \\frac{1}{2}(x + \\frac{numero}{x})\\), repetindo até atingir a precisão desejada. Desenvolva um algoritmo que implemente este sistema de aproximação fatorial, incluindo uma função para calcular a raiz quadrada usando o método babilônico, uma função para calcular o valor absoluto sem usar a biblioteca cmath, e utilizando os valores pré-definidos \\(\\pi = 3.141592653589793\\) e \\(e = 2.718281828459045\\).\nSolução:\nConsiderando o pseudo código acima, o código Listing 7.5 permite a implementação do algoritmo em C++23:\nPara testar o código Listing 7.5, o professor pode usar os seguintes valores de entrada para n = 5:",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>**Módulo 2**: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span>"
    ]
  },
  {
    "objectID": "desenv2.html#abstração-reutilização",
    "href": "desenv2.html#abstração-reutilização",
    "title": "7  Módulo 2: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões",
    "section": "",
    "text": "ALGORITMO EncontraMaiorMenorDigitoConciso\n\nENTRADA:\n    N: inteiro\n\nSAÍDA:\n    maiorDigito, menorDigito: inteiro\n\nINÍCIO\n    LER N\n    numeroOriginal ← N\n    maiorDigito ← 0\n    menorDigito ← 9\n    \nETIQUETA PROCESSAR_DIGITOS:\n    SE N = 0 ENTÃO IR PARA RESULTADO\n    \n    digito ← N % 10\n    N ← N / 10\n    \n    SE digito &gt; maiorDigito ENTÃO\n        maiorDigito ← digito\n    \n    SE digito &lt; menorDigito ENTÃO\n        menorDigito ← digito\n    \n    IR PARA PROCESSAR_DIGITOS\n\nETIQUETA RESULTADO:\n    ESCREVER \"Número original:\", numeroOriginal\n    ESCREVER \"Maior dígito:\", maiorDigito\n    ESCREVER \"Menor dígito:\", menorDigito\n    ESCREVER \"Diferença:\", (maiorDigito - menorDigito)\n    \n    RETORNAR maiorDigito, menorDigito\nFIM\n\n\n\n\nListing 7.1\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    int N;\n    std::cout &lt;&lt; \"Digite um número: \";\n    std::cin &gt;&gt; N;\n    \n    int numeroOriginal = N;\n    int maiorDigito = 0;\n    int menorDigito = 9;\n    \n    PROCESSAR_DIGITOS:\n    if (N == 0) goto RESULTADO;\n    \n    int digito = N % 10;\n    N = N / 10;\n    \n    if (digito &gt; maiorDigito) {\n        maiorDigito = digito;\n    }\n    \n    if (digito &lt; menorDigito) {\n        menorDigito = digito;\n    }\n    \n    goto PROCESSAR_DIGITOS;\n    \n    RESULTADO:\n    std::cout &lt;&lt; \"Número original: \" &lt;&lt; numeroOriginal &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Maior dígito: \" &lt;&lt; maiorDigito &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Menor dígito: \" &lt;&lt; menorDigito &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Diferença: \" &lt;&lt; (maiorDigito - menorDigito) &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\n\n\n\n\nListing 7.2\n\n\n#include &lt;iostream&gt;\n\nint main() {\n    auto N = 0;\n    std::cout &lt;&lt; \"Digite um número: \";\n    std::cin &gt;&gt; N;\n    \n    auto numeroOriginal = N;\n    auto maiorDigito = 0;\n    auto menorDigito = 9;\n    \n    while (N != 0) {\n        auto digito = N % 10;\n        N /= 10;\n        \n        if (digito &gt; maiorDigito) maiorDigito = digito;\n        if (digito &lt; menorDigito) menorDigito = digito;\n    }\n    \n    std::cout &lt;&lt; \"Número original: \" &lt;&lt; numeroOriginal &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Maior dígito: \" &lt;&lt; maiorDigito &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Menor dígito: \" &lt;&lt; menorDigito &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Diferença: \" &lt;&lt; (maiorDigito - menorDigito) &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n\nALGORITMO CalculadoraSeno\n\nENTRADA:\n    precisao: inteiro\n\nSAÍDA:\n    senoCalculado: real\n    senoReferencia: real\n    erroAbsoluto: real\n\nINÍCIO\n    // Valor de teste pré-definido: π/6 (30°)\n    angulo ← 0.523599\n    senoReferencia ← 0.5\n    \n    ESCREVER \"Calculando sen(π/6) = sen(30°) = sen(0.523599 rad)\"\n    ESCREVER \"Valor de referência: 0.5\"\n    ESCREVER \"Digite o número de termos da série:\"\n    LER precisao\n    \n    senoCalculado ← 0\n    termo ← angulo\n    \n    PARA i DE 0 ATÉ (precisao - 1) FAÇA\n        SE (i % 2 == 0) ENTÃO\n            senoCalculado ← senoCalculado + termo\n            ESCREVER \"Termo \", i+1, \": +\", termo, \" | Soma parcial: \", senoCalculado\n        SENÃO\n            senoCalculado ← senoCalculado - termo\n            ESCREVER \"Termo \", i+1, \": -\", termo, \" | Soma parcial: \", senoCalculado\n        FIM SE\n        \n        // Calcular próximo termo: x^(2n+3) / (2n+3)!\n        termo ← termo * angulo * angulo / ((2*i + 2) * (2*i + 3))\n    FIM PARA\n    \n    erroAbsoluto ← ABS(senoCalculado - senoReferencia)\n    \n    ESCREVER \"Ângulo: \", angulo, \" radianos (π/6 ou 30°)\"\n    ESCREVER \"Seno calculado: \", senoCalculado\n    ESCREVER \"Seno de referência: \", senoReferencia\n    ESCREVER \"Erro absoluto: \", erroAbsoluto\n    \n    RETORNAR senoCalculado, senoReferencia, erroAbsoluto\nFIM\n\n\n\n\nListing 7.3\n\n\n#include &lt;iostream&gt;\n#include &lt;ranges&gt;\n\n// Função para valor absoluto sem usar cmath\nauto abs_manual(auto valor) {\n    return (valor &lt; 0) ? -valor : valor;\n}\n\nint main() {\n    // Valor de teste pré-definido: π/6 (30°)\n    auto angulo = 0.523599;      // π/6 radianos\n    auto senoReferencia = 0.5;   // sen(π/6) = 0.5\n    \n    auto precisao = 0;\n    \n    std::cout &lt;&lt; \"Calculando sen(π/6) = sen(30°) = sen(0.523599 rad)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Valor de referência: 0.5\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Digite o número de termos da série: \";\n    std::cin &gt;&gt; precisao;\n    \n    auto senoCalculado = 0.0;\n    auto termo = angulo;\n    \n    for (auto i : std::views::iota(0, precisao)) {\n        if (i % 2 == 0) {\n            senoCalculado += termo;\n            std::cout &lt;&lt; \"Termo \" &lt;&lt; i+1 &lt;&lt; \": +\" &lt;&lt; termo \n                 &lt;&lt; \" | Soma parcial: \" &lt;&lt; senoCalculado &lt;&lt; std::endl;\n        } else {\n            senoCalculado -= termo;\n            std::cout &lt;&lt; \"Termo \" &lt;&lt; i+1 &lt;&lt; \": -\" &lt;&lt; termo \n                 &lt;&lt; \" | Soma parcial: \" &lt;&lt; senoCalculado &lt;&lt; std::endl;\n        }\n        \n        // Próximo termo: x^(2n+3) / (2n+3)!\n        termo = termo * angulo * angulo / ((2*i + 2) * (2*i + 3));\n    }\n    \n    auto erroAbsoluto = abs_manual(senoCalculado - senoReferencia);\n    \n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Ângulo: \" &lt;&lt; angulo &lt;&lt; \" radianos (π/6 ou 30°)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Seno calculado: \" &lt;&lt; senoCalculado &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Seno de referência: \" &lt;&lt; senoReferencia &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Erro absoluto: \" &lt;&lt; erroAbsoluto &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\n\n\n\n\nTable 7.1: Valores de teste para diferentes ângulos na série de Taylor do seno\n\n\n\n\n\n\n\n\n\n\n\n\n\nTeste\nÂngulo\nGraus\nRadianos\nSeno de Referência\nCódigo\n\n\n\n\n1\nπ/4\n45°\n0.785398\n0.707107\nauto angulo = 0.785398; auto senoReferencia = 0.707107;\n\n\n2\nπ/3\n60°\n1.047198\n0.866025\nauto angulo = 1.047198; auto senoReferencia = 0.866025;\n\n\n3\nπ/2\n90°\n1.570796\n1.0\nauto angulo = 1.570796; auto senoReferencia = 1.0;\n\n\n\n\n\n\n\n\n\n\n\nALGORITMO CalculadoraPi\n\nENTRADA:\n    numeroTermos: inteiro\n\nSAÍDA:\n    piCalculado: real\n    piReferencia: real\n    termosParaPrecisao: inteiro\n\nINÍCIO\n    ESCREVER \"Digite o número de termos:\"\n    LER numeroTermos\n    \n    somaLeibniz ← 0\n    precisaoAtingida ← FALSO\n    termosParaPrecisao ← 0\n    piReferencia ← 3.141592653589793\n    \n    PARA i DE 0 ATÉ (numeroTermos - 1) FAÇA\n        SE (i % 2 == 0) ENTÃO\n            somaLeibniz ← somaLeibniz + (1.0 / (2*i + 1))\n        SENÃO\n            somaLeibniz ← somaLeibniz - (1.0 / (2*i + 1))\n        FIM SE\n        \n        piCalculado ← 4 * somaLeibniz\n        \n        // Mostrar progresso a cada 1000 termos\n        SE ((i + 1) % 1000 == 0) ENTÃO\n            ESCREVER \"Termos: \", i+1, \" | Pi aproximado: \", piCalculado\n        FIM SE\n        \n        // Verificar precisão de 6 casas decimais\n        SE (ABS(piCalculado - piReferencia) &lt; 0.000001) E (precisaoAtingida == FALSO) ENTÃO\n            termosParaPrecisao ← i + 1\n            precisaoAtingida ← VERDADEIRO\n        FIM SE\n    FIM PARA\n    \n    ESCREVER \"Pi calculado: \", piCalculado\n    ESCREVER \"Pi de referência: \", piReferencia\n    ESCREVER \"Erro absoluto: \", ABS(piCalculado - piReferencia)\n    SE (precisaoAtingida) ENTÃO\n        ESCREVER \"Precisão de 6 casas atingida com \", termosParaPrecisao, \" termos\"\n    SENÃO\n        ESCREVER \"Precisão de 6 casas não atingida com \", numeroTermos, \" termos\"\n    FIM SE\n    \n    RETORNAR piCalculado, termosParaPrecisao\nFIM\n\n\n\n\nListing 7.4\n\n\n#include &lt;iostream&gt;\n#include &lt;ranges&gt;\n#include &lt;cmath&gt;\n\nint main() {\n    auto numeroTermos = 0;\n    auto somaLeibniz = 0.0;\n    auto piCalculado = 0.0;\n    auto precisaoAtingida = false;\n    auto termosParaPrecisao = 0;\n    \n    auto piReferencia = 3.1415926535897932;\n    \n    std::cout &lt;&lt; \"Digite o número de termos: \";\n    std::cin &gt;&gt; numeroTermos;\n    \n    for (auto i : std::views::iota(0, numeroTermos)) {\n        if (i % 2 == 0) {\n            somaLeibniz += 1.0 / (2*i + 1);\n        } else {\n            somaLeibniz -= 1.0 / (2*i + 1);\n        }\n        \n        piCalculado = 4 * somaLeibniz;\n        \n        // Mostrar progresso a cada 1000 termos\n        if ((i + 1) % 1000 == 0) {\n            std::cout &lt;&lt; \"Termos: \" &lt;&lt; i+1 &lt;&lt; \" | Pi aproximado: \" \n                 &lt;&lt; piCalculado &lt;&lt; std::endl;\n        }\n        \n        // Verificar precisão de 6 casas decimais\n        if (std::abs(piCalculado - piReferencia) &lt; 0.000001 and not precisaoAtingida) {\n            termosParaPrecisao = i + 1;\n            precisaoAtingida = true;\n        }\n    }\n    \n    std::cout &lt;&lt; \"Pi calculado: \" &lt;&lt; piCalculado &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pi de referência: \" &lt;&lt; piReferencia &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Erro absoluto: \" &lt;&lt; std::abs(piCalculado - piReferencia) &lt;&lt; std::endl;\n    \n    if (precisaoAtingida) {\n        std::cout &lt;&lt; \"Precisão de 6 casas atingida com \" &lt;&lt; termosParaPrecisao &lt;&lt; \" termos\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Precisão de 6 casas não atingida com \" &lt;&lt; numeroTermos &lt;&lt; \" termos\" &lt;&lt; std::endl;\n    }\n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\nALGORITMO AproximacaoFatorial\n\nENTRADA:\n    n: inteiro\n\nSAÍDA:\n    fatorialExato: inteiro\n    aproximacaoStirling: real\n    erroPercentual: real\n\nINÍCIO\n    ESCREVER \"Digite o valor de n (≤ 20):\"\n    LER n\n    \n    // Calcular fatorial exato\n    fatorialExato ← 1\n    PARA i DE 1 ATÉ n FAÇA\n        fatorialExato ← fatorialExato * i\n    FIM PARA\n    \n    // Calcular produtório: ∏(i/e) de i=1 até n\n    produtorio ← 1.0\n    e ← 2.718281828459045\n    PARA i DE 1 ATÉ n FAÇA\n        produtorio ← produtorio * (i / e)\n    FIM PARA\n    ESCREVER \"Produtório ∏(i/e): \", produtorio\n    \n    // Calcular somatório: Σ(ck/n^k) de k=0 até 2\n    c0 ← 1.0\n    c1 ← 1.0 / 12.0\n    c2 ← 1.0 / 288.0\n    \n    somatorio ← c0 + (c1 / n) + (c2 / (n * n))\n    ESCREVER \"Somatório (1 + 1/12n + 1/288n²): \", somatorio\n    \n    // Calcular raiz quadrada usando método babilônico\n    valor ← 2 * pi * n\n    raizParte ← RAIZ_BABILONICA(valor)\n    \n    // Calcular aproximação completa\n    pi ← 3.141592653589793\n    aproximacaoStirling ← raizParte * produtorio * somatorio\n    \n    // Calcular erro percentual\n    erroPercentual ← VALOR_ABSOLUTO(aproximacaoStirling - fatorialExato) / fatorialExato * 100\n    \n    ESCREVER \"Fatorial exato de \", n, \"!: \", fatorialExato\n    ESCREVER \"Aproximação de Stirling: \", aproximacaoStirling\n    ESCREVER \"√(2πn): \", raizParte\n    ESCREVER \"Erro percentual: \", erroPercentual, \"%\"\n    \n    RETORNAR fatorialExato, aproximacaoStirling, erroPercentual\nFIM\n\nFUNÇÃO RAIZ_BABILONICA(numero: real) → real\n    SE numero &lt;= 0 ENTÃO RETORNAR 0\n    x ← numero\n    REPETIR\n        raiz ← 0.5 * (x + numero / x)\n        SE VALOR_ABSOLUTO(raiz - x) &lt; 0.000001 ENTÃO\n            RETORNAR raiz\n        x ← raiz\n    ATÉ FALSO\nFIM FUNÇÃO\n\nFUNÇÃO VALOR_ABSOLUTO(valor: real) → real\n    SE valor &lt; 0 ENTÃO\n        RETORNAR -valor\n    SENÃO\n        RETORNAR valor\n    FIM SE\nFIM FUNÇÃO\n\n\n\n\nListing 7.5\n\n\n#include &lt;iostream&gt;\n#include &lt;ranges&gt;\n\n// Constantes matemáticas definidas manualmente\nauto PI = 3.141592653589793;\nauto E = 2.718281828459045;\n\n// Função para valor absoluto sem usar cmath\nauto abs_manual(auto valor) {\n    return (valor &lt; 0) ? -valor : valor;\n}\n\n// Função para raiz quadrada usando método babilônico\nauto sqrt_babilonico(auto numero) {\n    if (numero &lt;= 0) return 0.0;\n    \n    auto x = numero;\n    while (true) {\n        auto raiz = 0.5 * (x + numero / x);\n        if (abs_manual(raiz - x) &lt; 0.000001) {\n            return raiz;\n        }\n        x = raiz;\n    }\n}\n\nauto calcularFatorial(auto n) {\n    auto resultado = 1LL;\n    for (auto i : std::views::iota(1, n+1)) {\n        resultado *= i;\n    }\n    return resultado;\n}\n\nint main() {\n    auto n = 0;\n    std::cout &lt;&lt; \"Digite o valor de n (≤ 20): \";\n    std::cin &gt;&gt; n;\n    \n    if (n &gt; 20) {\n        std::cout &lt;&lt; \"Valor muito grande. Use n ≤ 20.\" &lt;&lt; std::endl;\n        return 1;\n    }\n    \n    // Calcular fatorial exato\n    auto fatorialExato = calcularFatorial(n);\n    \n    // Calcular produtório: ∏(i/e) de i=1 até n\n    auto produtorio = 1.0;\n    for (auto i : std::views::iota(1, n+1)) {\n        produtorio *= (static_cast&lt;double&gt;(i) / E);\n    }\n    std::cout &lt;&lt; \"Produtório ∏(i/e): \" &lt;&lt; produtorio &lt;&lt; std::endl;\n    \n    // Calcular somatório: Σ(ck/n^k) de k=0 até 2\n    auto c0 = 1.0;\n    auto c1 = 1.0 / 12.0;\n    auto c2 = 1.0 / 288.0;\n    \n    auto somatorio = c0 + (c1 / n) + (c2 / (n * n));\n    std::cout &lt;&lt; \"Somatório (1 + 1/12n + 1/288n²): \" &lt;&lt; somatorio &lt;&lt; std::endl;\n    \n    // Calcular aproximação completa\n    auto valorRaiz = 2 * PI * n;\n    auto raizParte = sqrt_babilonico(valorRaiz);\n    auto aproximacaoStirling = raizParte * produtorio * somatorio;\n    \n    // Calcular erro percentual\n    auto erroPercentual = abs_manual(aproximacaoStirling - fatorialExato) / fatorialExato * 100;\n    \n    std::cout &lt;&lt; \"Fatorial exato de \" &lt;&lt; n &lt;&lt; \"!: \" &lt;&lt; fatorialExato &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Aproximação de Stirling: \" &lt;&lt; aproximacaoStirling &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"√(2πn): \" &lt;&lt; raizParte &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Erro percentual: \" &lt;&lt; erroPercentual &lt;&lt; \"%\" &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\n\n\nFatorial exato: 5! = 120\nAproximação de Stirling esperada: ≈ 118.02\nErro percentual esperado: ≈ 1.65%\n\n\n7.1.1 Reconhecimento de Padrões: Função\nO reconhecimento de padrões é uma habilidade essencial no raciocínio algorítmico, permitindo identificar soluções comuns para problemas recorrentes. Foi o reconhecimento de padrões que levou à criação de funções, que são blocos reutilizáveis de código que encapsulam uma lógica específica. Neste módulo, os alunos devem aprender a identificar padrões em problemas antes de criar funções para resolver esses problemas. O objetivo é que a metáfora de “função” seja vista como uma abstração que permite resolver problemas complexos de forma modular e reutilizável. Além disso, é importante que os alunos entendam que a função é um desvio de fluxo que permite encapsular uma lógica específica, tornando o código mais legível e organizado. Mas que implica em custo computacional extra.\nOs exercícios a seguir podem ser aplicados segundo a Técnica da Sequência de Fibonacci, na qual o professor deve escolher o número de problemas que serão resolvidos em cada etapa de acordo com o tamanho e o resultado da turma, mas deve se manter na Técnica da Sequência de Fibonacci. A Técnica da Sequência de Fibonacci foi abordada na Section 6.1.1 nesta técnica além de tempos e quantidades, o professor precisa se preocupar que a devolutiva deve ser feita no quadro, com o professor explicando cada passo do algoritmo, enfatizando a importância da decomposição e abstração. A seguir está uma lista de problemas que podem ser usados para esta atividade, começando com a repetição de um exercício anterior, apenas revisão:\nA. Um canhão dispara projéteis seguindo a equação de altura \\(h(t) = -4.9t^2 + v_0 \\sin(\\theta) \\cdot t + h_0\\), na qual \\(t\\) é o tempo em segundos, \\(v_0\\) é a velocidade inicial, \\(\\theta\\) é o ângulo de lançamento e \\(h_0\\) é a altura inicial. Você deverá determinar quando o projétil atinge o solo a Atendendo as seguintes especificações.\nEntrada: \\(v_0\\) (velocidade inicial em m/s), \\(\\theta\\) (ângulo em graus), \\(h_0\\) (altura inicial em metros)\nTarefa: Calcule quando o projétil atinge o solo (h = 0). Se existirem duas soluções positivas, mostre a menor (primeiro impacto). Se não houver soluções reais positivas, informe que o projétil não atinge o solo.\nSaída: Tempo de impacto ou mensagem de erro.\nAlém desta especificações, você deve considerar que o seno de um ângulo pode ser aproximado usando a série de Taylor.\nA série de Taylor para calcular \\(\\sin(x)\\) é dada por:\n\\[\\sin(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n \\cdot x^{2n+1}}{(2n+1)!}\\]\nExpandindo os primeiros termos:\n\\[\\sin(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \\frac{x^9}{9!} - \\frac{x^{11}}{11!} + \\ldots\\]\nNesta expressão:\n\n\\(x\\) deve estar em radianos;\n\\(n!\\) representa o fatorial de \\(n\\);\nA série alterna entre sinais positivos e negativos;\nPara precisão razoável, geralmente 7 termos são suficientes.\n\nAnálise: o pseudocódigo para este exercício pode ser representado como:\nALGORITMO TrajetoriaProjetil\n\nENTRADA:\n    v0, theta, h0: real\n\nSAÍDA:\n    tempo: real ou mensagem\n\nINÍCIO\n    LER v0, theta, h0\n    \n    // Converter ângulo para radianos\n    pi ← 3.14159265\n    radianos ← theta * pi\n    radianos ← radianos / 180\n    \n    // Calcular seno usando aproximação por série de Taylor (5 termos)\n    seno ← radianos\n    termo ← radianos\n    i ← 1\n    ENQUANTO i &lt;= 4 FAÇA\n        termo ← termo * radianos\n        termo ← termo * radianos\n        temp ← 2 * i\n        temp ← temp + 1\n        temp2 ← temp - 1\n        temp3 ← temp2 * temp\n        termo ← termo / temp3\n        SE i % 2 = 0 ENTÃO\n            seno ← seno + termo\n        SENÃO\n            seno ← seno - termo\n        FIM SE\n        i ← i + 1\n    FIM ENQUANTO\n    \n    // Coeficientes da equação quadrática: at² + bt + c = 0\n    a ← -4.9\n    b ← v0 * seno\n    c ← h0\n    \n    // Calcular discriminante\n    temp ← b * b\n    temp2 ← 4 * a\n    temp3 ← temp2 * c\n    discriminante ← temp - temp3\n    \n    SE discriminante &lt; 0 ENTÃO\n        ESCREVER \"O projétil não atinge o solo\"\n    SENÃO\n        // Calcular raiz quadrada do discriminante usando método de Newton\n        raizQuadrada ← discriminante / 2\n        ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA\n            temp ← raizQuadrada * raizQuadrada\n            temp ← temp + discriminante\n            raizQuadrada ← temp / (2 * raizQuadrada)\n        FIM ENQUANTO\n        \n        // Calcular as duas raízes\n        temp ← 0 - b\n        temp2 ← 2 * a\n        raiz1 ← temp + raizQuadrada\n        raiz1 ← raiz1 / temp2\n        raiz2 ← temp - raizQuadrada\n        raiz2 ← raiz2 / temp2\n        \n        // Verificar soluções positivas\n        SE raiz1 &gt; 0 E raiz2 &gt; 0 ENTÃO\n            SE raiz1 &lt; raiz2 ENTÃO\n                tempo ← raiz1\n            SENÃO\n                tempo ← raiz2\n            FIM SE\n            ESCREVER \"Tempo de impacto:\", tempo, \"segundos\"\n        SENÃO SE raiz1 &gt; 0 ENTÃO\n            ESCREVER \"Tempo de impacto:\", raiz1, \"segundos\"\n        SENÃO SE raiz2 &gt; 0 ENTÃO\n            ESCREVER \"Tempo de impacto:\", raiz2, \"segundos\"\n        SENÃO\n            ESCREVER \"O projétil não atinge o solo\"\n        FIM SE\n    FIM SE\nFIM\nNós estamos tentando criar a cognição necessária para entender o uso de funções. Assim, o professor pode propor o uso de um fluxograma para melhorar a visualização do algoritmo apresentado no pseudocódigo acima. Para tanto, o professor pode usar o fluxograma apresentado na Figure 7.1.\n\n\n\n\n\n\nFigure 7.1: Fluxograma do Algoritmo de Trajetória de Projétil usando apenas operações binárias e unárias.\n\n\n\nO fluxograma da Figure 7.1 mostra as operações binárias e unárias necessárias para resolver o problema da trajetória do projétil detalhando cada processo necessário. Esta estrutura pode criar dúvidas e confusão. Contudo, é preciso lembrar que neste momento, estamos trabalhando para criar a abstração necessária ao entendimento do conceito de função. E não usando funções.\nO professor pode usar este fluxograma para destacar a necessidade do uso de abstrações mais eficientes. Por exemplo, podemos criar um pseudocódigo, ou conjunto de módulos, só para calcular o quadrado de um valor e dividir este quadrado por outro valor, em vez de um bloco para multiplicar um valor por si mesmo e então dividir este valor por outro, como é feito na Figure 7.1.\nUsando a Figure 7.1, será importante destacar as áreas que podem ser transformadas em funções, como o cálculo do seno usando a série de Taylor, que pode ser encapsulado em uma função separada.\nFinalmente, neste ponto, fica claro que o fluxograma não atende todas as abstrações que precisamos construir para usar linguagens imperativas de forma estruturada. Deste ponto, em diante, vamos dar prioridade ao pseudocódigo.\nB. Um fazendeiro possui 120 metros de cerca para delimitar um terreno retangular. Uma das dimensões será \\(x\\) metros, resultando numa área \\(A = x(60-x)\\) metros quadrados. Determine as dimensões possíveis do terreno para atingir uma determinada área. Sabendo que a equação que representa este fenômeno é \\(x^2 - 60x + \\text{área} = 0\\). Considere as seguintes especificações:\nEntrada: Área desejada em metros quadrados\nSaída: As duas dimensões possíveis ou mensagem informando que a área é impossível de atingir.\nSolução:\nJá usando funções no pseudocódigo, podemos representar o problema da seguinte forma:\nALGORITMO DimensoesTerreno\n\nENTRADA:\n    area_desejada: real\n\nSAÍDA:\n    dimensoes: real, real ou mensagem\n\nINÍCIO\n    LER area_desejada\n    \n    // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA\n    // Equação: x² - 60x + area_desejada = 0\n    a ← 1\n    b ← -60\n    c ← area_desejada\n    \n    // CALCULAR DISCRIMINANTE\n    temp1 ← b * b\n    temp2 ← 4 * a\n    temp3 ← temp2 * c\n    discriminante ← temp1 - temp3\n    \n    // VERIFICAR VIABILIDADE DA SOLUÇÃO\n    SE discriminante &lt; 0 ENTÃO\n        ESCREVER \"Área impossível de atingir com 120 metros de cerca\"\n    SENÃO\n        // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\n        raizQuadrada ← calcularRaizQuadrada(discriminante)\n        \n        // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA\n        raiz1, raiz2 ← calcularRaizes(a, b, raizQuadrada)\n        \n        // CALCULAR AS DIMENSÕES DO TERRENO\n        // Primeira dimensão: x = raiz1\n        dimensao1_x ← raiz1\n        temp_sub1 ← 60 - raiz1\n        dimensao1_y ← temp_sub1\n        \n        // Segunda dimensão: x = raiz2\n        dimensao2_x ← raiz2\n        temp_sub2 ← 60 - raiz2\n        dimensao2_y ← temp_sub2\n        \n        // VALIDAR DIMENSÕES FÍSICAS\n        valida1 ← FALSO\n        valida2 ← FALSO\n        \n        // Verificar primeira solução\n        SE dimensao1_x &gt; 0 E dimensao1_x &lt; 60 ENTÃO\n            SE dimensao1_y &gt; 0 E dimensao1_y &lt; 60 ENTÃO\n                valida1 ← VERDADEIRO\n            FIM SE\n        FIM SE\n        \n        // Verificar segunda solução\n        SE dimensao2_x &gt; 0 E dimensao2_x &lt; 60 ENTÃO\n            SE dimensao2_y &gt; 0 E dimensao2_y &lt; 60 ENTÃO\n                valida2 ← VERDADEIRO\n            FIM SE\n        FIM SE\n        \n        // APRESENTAR RESULTADOS\n        SE valida1 = VERDADEIRO E valida2 = VERDADEIRO ENTÃO\n            ESCREVER \"Primeira solução:\"\n            ESCREVER \"Dimensões:\", dimensao1_x, \"metros x\", dimensao1_y, \"metros\"\n            ESCREVER \"Segunda solução:\"\n            ESCREVER \"Dimensões:\", dimensao2_x, \"metros x\", dimensao2_y, \"metros\"\n        SENÃO SE valida1 = VERDADEIRO ENTÃO\n            ESCREVER \"Dimensões possíveis:\"\n            ESCREVER dimensao1_x, \"metros x\", dimensao1_y, \"metros\"\n        SENÃO SE valida2 = VERDADEIRO ENTÃO\n            ESCREVER \"Dimensões possíveis:\"\n            ESCREVER dimensao2_x, \"metros x\", dimensao2_y, \"metros\"\n        SENÃO\n            ESCREVER \"Área impossível de atingir com as limitações físicas\"\n        FIM SE\n    FIM SE\nFIM\n\n// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\nFUNÇÃO calcularRaizQuadrada(discriminante: real): real\nINÍCIO\n    raizQuadrada ← discriminante / 2\n\n    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA\n        // Calcular raizQuadrada² \n        temp_quad ← raizQuadrada * raizQuadrada\n        \n        // Calcular numerador: raizQuadrada² + discriminante\n        numerador ← temp_quad + discriminante\n        \n        // Calcular denominador: 2 * raizQuadrada\n        denominador ← 2 * raizQuadrada\n        \n        // Nova aproximação\n        raizQuadrada ← numerador / denominador\n    FIM ENQUANTO\n    \n    RETORNAR raizQuadrada\nFIM\n\n// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA\nFUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real\nINÍCIO\n    // Calcular -b\n    menos_b ← 0 - b\n\n    // Calcular denominador comum: 2a\n    denominador_comum ← 2 * a\n    \n    // Calcular raiz1: (-b + √Δ) / 2a\n    numerador1 ← menos_b + raizQuadrada\n    raiz1 ← numerador1 / denominador_comum\n    \n    // Calcular raiz2: (-b - √Δ) / 2a  \n    numerador2 ← menos_b - raizQuadrada\n    raiz2 ← numerador2 / denominador_comum\n    \n    RETORNAR raiz1, raiz2\nFIM\n\n// FUNÇÃO AUXILIAR: VALOR ABSOLUTO\nFUNÇÃO abs(valor: real): real\nINÍCIO\n    SE valor &lt; 0 ENTÃO\n        resultado ← 0 - valor\n    SENÃO\n        resultado ← valor\n    FIM SE\n    RETORNAR resultado\nFIM\nEste pseudocódigo serve como ferramenta de abstração para o professor, que pode usar este algoritmo para explicar a decomposição do problema em funções menores. O professor pode destacar como cada função tem uma responsabilidade específica, como calcular a raiz quadrada, calcular as raízes da equação quadrática e validar as dimensões físicas. Além disso, o professor pode enfatizar a importância de validar as entradas e saídas de cada função, garantindo que o código seja robusto e fácil de entender. Por fim, as funções auxiliares foram colocadas no final do pseudocódigo para destacar que elas são abstrações que podem ser reutilizadas em outros contextos, reforçando a ideia de modularidade, reutilização de código e de controle de fluxo. Em C++23, o pseudocódigo está implementado no site GDB Online no link https://onlinegdb.com/Si-IeJICB.\nC. Um veículo em movimento tem sua posição descrita por \\(s(t) = s_0 + v_0t + \\frac{1}{2}at^2\\), na qual \\(s_0\\) é a posição inicial, \\(v_0\\) é a velocidade inicial e \\(a\\) é a aceleração. Sua tarefa é criar um algoritmo que calcule em que instante(s) o veículo passa por uma posição final \\(s_f\\). Para tanto, considere as seguintes especificações:\nEntrada: \\(s_0\\) (posição inicial em metros), \\(v_0\\) (velocidade inicial em m/s), \\(a\\) (aceleração em m/s²), \\(s_f\\) (posição final desejada em metros)\nTarefa: Calcule em que instante(s) o veículo passa pela posição \\(s_f\\). A equação é \\(\\frac{1}{2}at^2 + v_0t + (s_0 - s_f) = 0\\).\nSaída: Tempo(s) em que o veículo passa pela posição ou mensagem de que nunca passa.\nSolução:\nNeste caso, reusando as abstrações criadas para funções do exercício anterior, teremos:\nALGORITMO PosicaoVeiculo\n\nENTRADA:\n    s0, v0, a, sf: real\n\nSAÍDA:\n    tempo(s): real ou mensagem\n\nINÍCIO\n    LER s0, v0, a, sf\n    \n    // VERIFICAR TIPO DE MOVIMENTO\n    \n    SE a = 0 ENTÃO\n        // Movimento uniforme: s = s0 + v0*t\n        // sf = s0 + v0*t  =&gt;  t = (sf - s0)/v0\n        \n        SE v0 = 0 ENTÃO\n            SE s0 = sf ENTÃO\n                ESCREVER \"O veículo está sempre na posição desejada\"\n            SENÃO\n                ESCREVER \"O veículo nunca passa pela posição desejada\"\n            FIM SE\n        SENÃO\n            // Calcular t = (sf - s0) / v0\n            diferenca ← sf - s0\n            tempo ← diferenca / v0\n            ESCREVER \"O veículo passa pela posição no tempo:\", tempo, \"segundos\"\n        FIM SE\n    SENÃO\n        \n        // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA\n        // Equação: (1/2)at² + v0t + (s0 - sf) = 0\n        // Multiplicando por 2: at² + 2v0t + 2(s0 - sf) = 0\n        coef_a ← a\n        temp_2v0 ← 2 * v0\n        coef_b ← temp_2v0\n        temp_diff ← s0 - sf\n        temp_2diff ← 2 * temp_diff\n        coef_c ← temp_2diff\n        \n        \n        // CALCULAR DISCRIMINANTE\n        temp1 ← coef_b * coef_b\n        temp2 ← 4 * coef_a\n        temp3 ← temp2 * coef_c\n        discriminante ← temp1 - temp3\n        \n        \n        // VERIFICAR VIABILIDADE DA SOLUÇÃO\n        SE discriminante &lt; 0 ENTÃO\n            ESCREVER \"O veículo nunca passa pela posição desejada\"\n        SENÃO\n            \n            // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\n            raizQuadrada ← calcularRaizQuadrada(discriminante)\n            \n            // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA\n           tempo1, tempo2 ← calcularRaizes(coef_a, coef_b, raizQuadrada)\n            \n            // VALIDAR E APRESENTAR TEMPOS\n            tempos_validos ← 0\n            \n            // Verificar primeiro tempo\n            SE tempo1 &gt;= 0 ENTÃO\n                tempos_validos ← tempos_validos + 1\n                primeiro_tempo_valido ← tempo1\n            FIM SE\n            \n            // Verificar segundo tempo\n            SE tempo2 &gt;= 0 ENTÃO\n                tempos_validos ← tempos_validos + 1\n                SE tempos_validos = 1 ENTÃO\n                    primeiro_tempo_valido ← tempo2\n                SENÃO\n                    segundo_tempo_valido ← tempo2\n                FIM SE\n            FIM SE\n            \n            \n            // APRESENTAR RESULTADOS\n            SE tempos_validos = 0 ENTÃO\n                ESCREVER \"O veículo passou pela posição apenas no passado:\"\n                ESCREVER \"Tempo 1:\", tempo1, \"segundos\"\n                ESCREVER \"Tempo 2:\", tempo2, \"segundos\"\n            SENÃO SE tempos_validos = 1 ENTÃO\n                ESCREVER \"O veículo passa pela posição no tempo:\"\n                ESCREVER primeiro_tempo_valido, \"segundos\"\n                \n                // Mostrar também tempo negativo se existir\n                SE tempo1 &lt; 0 ENTÃO\n                    ESCREVER \"Também passou no passado em:\", tempo1, \"segundos\"\n                FIM SE\n                SE tempo2 &lt; 0 ENTÃO\n                    ESCREVER \"Também passou no passado em:\", tempo2, \"segundos\"\n                FIM SE\n            SENÃO\n                // Ordenar os tempos (menor primeiro)\n                SE primeiro_tempo_valido &gt; segundo_tempo_valido ENTÃO\n                    temp_swap ← primeiro_tempo_valido\n                    primeiro_tempo_valido ← segundo_tempo_valido\n                    segundo_tempo_valido ← temp_swap\n                FIM SE\n                \n                ESCREVER \"O veículo passa pela posição em dois momentos:\"\n                ESCREVER \"Primeiro tempo:\", primeiro_tempo_valido, \"segundos\"\n                ESCREVER \"Segundo tempo:\", segundo_tempo_valido, \"segundos\"\n            FIM SE\n        FIM SE\n    FIM SE\nFIM\n\n\n// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\nFUNÇÃO calcularRaizQuadrada(discriminante: real): real\nINÍCIO\n    raizQuadrada ← discriminante / 2\n    \n    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA\n        // Calcular raizQuadrada² \n        temp_quad ← raizQuadrada * raizQuadrada\n        \n        // Calcular numerador: raizQuadrada² + discriminante\n        numerador ← temp_quad + discriminante\n        \n        // Calcular denominador: 2 * raizQuadrada\n        denominador ← 2 * raizQuadrada\n        \n        // Nova aproximação\n        raizQuadrada ← numerador / denominador\n    FIM ENQUANTO\n    \n    RETORNAR raizQuadrada\nFIM\n\n\n// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA\nFUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real\nINÍCIO\n    // Calcular -b\n    menos_b ← 0 - b\n    \n    // Calcular denominador comum: 2a\n    denominador_comum ← 2 * a\n    \n    // Calcular raiz1: (-b + √Δ) / 2a\n    numerador1 ← menos_b + raizQuadrada\n    raiz1 ← numerador1 / denominador_comum\n    \n    // Calcular raiz2: (-b - √Δ) / 2a  \n    numerador2 ← menos_b - raizQuadrada\n    raiz2 ← numerador2 / denominador_comum\n    \n    RETORNAR raiz1, raiz2\nFIM\n\n// FUNÇÃO AUXILIAR: VALOR ABSOLUTO\nFUNÇÃO abs(valor: real): real\nINÍCIO\n    SE valor &lt; 0 ENTÃO\n        resultado ← 0 - valor\n    SENÃO\n        resultado ← valor\n    FIM SE\n    RETORNAR resultado\nFIM\nO código em C++23 para o pseudocódigo acima pode ser encontrado no site GDB Online no link https://onlinegdb.com/2ZaBx62x_.\nD. Uma empresa possui função de lucro \\(L(q) = -2q^2 + 80q - 300\\), na qual \\(q\\) é a quantidade produzida e \\(L\\) é o lucro em reais. Você deverá criar um programa que determine a quantidade de produção necessária para atingir o lucro desejado. A equação é \\(-2q^2 + 80q - (300 + \\text{lucro desejado}) = 0\\). Considerando as seguintes especificações:\nEntrada: Lucro desejado em reais\nSaída: Quantidade(s) de produção ou mensagem de que o lucro é inatingível.\nSolução:\nNeste caso, teremos:\nALGORITMO LucroEmpresa\n\nENTRADA:\n    lucro_desejado: real\n\nSAÍDA:\n    quantidade(s): real ou mensagem\n\nINÍCIO\n    LER lucro_desejado\n    \n    // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA\n    // Equação: -2q² + 80q - (300 + lucro_desejado) = 0\n    a ← -2\n    b ← 80\n    temp_soma ← 300 + lucro_desejado\n    temp_negativo ← 0 - temp_soma\n    c ← temp_negativo\n    \n    // CALCULAR DISCRIMINANTE\n    temp1 ← b * b\n    temp2 ← 4 * a\n    temp3 ← temp2 * c\n    discriminante ← temp1 - temp3\n    \n    // VERIFICAR VIABILIDADE DA SOLUÇÃO\n    SE discriminante &lt; 0 ENTÃO\n        ESCREVER \"Lucro inatingível com a função de produção atual\"\n    SENÃO\n        \n        // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\n        raizQuadrada ← calcularRaizQuadrada(discriminante)\n        \n        // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA\n        quantidade1, quantidade2 ← calcularRaizes(a, b, raizQuadrada)\n        \n        // VALIDAR QUANTIDADES FÍSICAS\n        valida1 ← FALSO\n        valida2 ← FALSO\n        \n        // Verificar primeira quantidade\n        SE quantidade1 &gt; 0 ENTÃO\n            valida1 ← VERDADEIRO\n        FIM SE\n        \n        // Verificar segunda quantidade\n        SE quantidade2 &gt; 0 ENTÃO\n            valida2 ← VERDADEIRO\n        FIM SE\n        \n        // CALCULAR LUCROS PARA VERIFICAÇÃO\n        SE valida1 = VERDADEIRO ENTÃO\n            // Calcular L(q1) = -2q1² + 80q1 - 300\n            temp_q1_quadrado ← quantidade1 * quantidade1\n            temp_menos2q1_quadrado ← -2 * temp_q1_quadrado\n            temp_80q1 ← 80 * quantidade1\n            temp_soma_termos ← temp_menos2q1_quadrado + temp_80q1\n            lucro_verificacao1 ← temp_soma_termos - 300\n        FIM SE\n        \n        SE valida2 = VERDADEIRO ENTÃO\n            // Calcular L(q2) = -2q2² + 80q2 - 300\n            temp_q2_quadrado ← quantidade2 * quantidade2\n            temp_menos2q2_quadrado ← -2 * temp_q2_quadrado\n            temp_80q2 ← 80 * quantidade2\n            temp_soma_termos2 ← temp_menos2q2_quadrado + temp_80q2\n            lucro_verificacao2 ← temp_soma_termos2 - 300\n        FIM SE\n        \n        // APRESENTAR RESULTADOS\n        SE valida1 = VERDADEIRO E valida2 = VERDADEIRO ENTÃO\n            // Ordenar quantidades (menor primeiro)\n            SE quantidade1 &gt; quantidade2 ENTÃO\n                temp_swap ← quantidade1\n                quantidade1 ← quantidade2\n                quantidade2 ← temp_swap\n            FIM SE\n            \n            ESCREVER \"Duas quantidades de produção possíveis:\"\n            ESCREVER \"Primeira quantidade:\", quantidade1, \"unidades\"\n            ESCREVER \"Segunda quantidade:\", quantidade2, \"unidades\"\n            ESCREVER \"Ambas geram o lucro de:\", lucro_desejado, \"reais\"\n            \n        SENÃO SE valida1 = VERDADEIRO ENTÃO\n            ESCREVER \"Quantidade de produção necessária:\"\n            ESCREVER quantidade1, \"unidades\"\n            ESCREVER \"Lucro gerado:\", lucro_verificacao1, \"reais\"\n            \n            // Mostrar também quantidade negativa se existir\n            SE quantidade2 &lt; 0 ENTÃO\n                ESCREVER \"Quantidade negativa descartada:\", quantidade2\n            FIM SE\n            \n        SENÃO SE valida2 = VERDADEIRO ENTÃO\n            ESCREVER \"Quantidade de produção necessária:\"\n            ESCREVER quantidade2, \"unidades\"\n            ESCREVER \"Lucro gerado:\", lucro_verificacao2, \"reais\"\n            \n            // Mostrar também quantidade negativa se existir\n            SE quantidade1 &lt; 0 ENTÃO\n                ESCREVER \"Quantidade negativa descartada:\", quantidade1\n            FIM SE\n            \n        SENÃO\n            ESCREVER \"Todas as soluções resultam em quantidades negativas:\"\n            ESCREVER \"Quantidade 1:\", quantidade1, \"unidades\"\n            ESCREVER \"Quantidade 2:\", quantidade2, \"unidades\"\n            ESCREVER \"Não é possível produzir quantidades negativas\"\n        FIM SE\n    FIM SE\n    \n    // INFORMAÇÕES ADICIONAIS SOBRE A EMPRESA\n    ESCREVER \"Informações da função de lucro L(q) = -2q² + 80q - 300:\"\n    \n    // Calcular lucro máximo (vértice da parábola)\n    // q_max = -b/(2a) = -80/(2*(-2)) = 80/4 = 20\n    temp_2a ← 2 * a\n    temp_menos_b ← 0 - b\n    q_maximo ← temp_menos_b / temp_2a\n    \n    // Calcular lucro máximo L(20)\n    temp_qmax_quadrado ← q_maximo * q_maximo\n    temp_menos2qmax_quadrado ← -2 * temp_qmax_quadrado\n    temp_80qmax ← 80 * q_maximo\n    temp_soma_max ← temp_menos2qmax_quadrado + temp_80qmax\n    lucro_maximo ← temp_soma_max - 300\n    \n    ESCREVER \"Quantidade para lucro máximo:\", q_maximo, \"unidades\"\n    ESCREVER \"Lucro máximo possível:\", lucro_maximo, \"reais\"\nFIM\n\n// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\nFUNÇÃO calcularRaizQuadrada(discriminante: real): real\nINÍCIO\n    raizQuadrada ← discriminante / 2\n    \n    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA\n        // Calcular raizQuadrada² \n        temp_quad ← raizQuadrada * raizQuadrada\n        \n        // Calcular numerador: raizQuadrada² + discriminante\n        numerador ← temp_quad + discriminante\n        \n        // Calcular denominador: 2 * raizQuadrada\n        denominador ← 2 * raizQuadrada\n        \n        // Nova aproximação\n        raizQuadrada ← numerador / denominador\n    FIM ENQUANTO\n    \n    RETORNAR raizQuadrada\nFIM\n\n// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA\nFUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real\nINÍCIO\n    // Calcular -b\n    menos_b ← 0 - b\n    \n    // Calcular denominador comum: 2a\n    denominador_comum ← 2 * a\n    \n    // Calcular raiz1: (-b + √Δ) / 2a\n    numerador1 ← menos_b + raizQuadrada\n    raiz1 ← numerador1 / denominador_comum\n    \n    // Calcular raiz2: (-b - √Δ) / 2a  \n    numerador2 ← menos_b - raizQuadrada\n    raiz2 ← numerador2 / denominador_comum\n    \n    RETORNAR raiz1, raiz2\nFIM\n\n// FUNÇÃO AUXILIAR: VALOR ABSOLUTO\nFUNÇÃO abs(valor: real): real\nINÍCIO\n    SE valor &lt; 0 ENTÃO\n        resultado ← 0 - valor\n    SENÃO\n        resultado ← valor\n    FIM SE\n    RETORNAR resultado\nFIM\nO código em C++23 para o pseudocódigo acima pode ser encontrado no site GDB Online no link https://onlinegdb.com/flCt2mss0.\nE. O ganho de uma antena parabólica em função do diâmetro segue a relação \\(G = -0.1d^2 + 3d + 5\\), na qual \\(d\\) é o diâmetro em metros e \\(G\\) é o ganho em dB. Você precisa criar um algoritmo que calcule o diâmetro de uma antena que forneça o ganho desejado. A equação é \\(-0.1d^2 + 3d + (5 - \\text{ganho desejado}) = 0\\). Considere as seguintes especificações:\nEntrada: Ganho mínimo desejado em dB\nSaída: Diâmetro(s) da antena ou mensagem de que o ganho é impossível.\nSolução:\nPara este exercício o pseudocódigo será semelhante ao anterior, mas com ajustes para a função de ganho da antena parabólica:\nALGORITMO GanhoAntenaParabolica\n\nENTRADA:\n    ganho_desejado: real\n\nSAÍDA:\n    diametro(s): real ou mensagem\n\nINÍCIO\n    LER ganho_desejado\n    \n    // CONFIGURAR COEFICIENTES DA EQUAÇÃO QUADRÁTICA\n    // Equação: -0.1d² + 3d + (5 - ganho_desejado) = 0\n    a ← -0.1\n    b ← 3\n    temp_subtracao ← 5 - ganho_desejado\n    c ← temp_subtracao\n    \n    // CALCULAR DISCRIMINANTE\n    temp1 ← b * b\n    temp2 ← 4 * a\n    temp3 ← temp2 * c\n    discriminante ← temp1 - temp3\n    \n    // VERIFICAR VIABILIDADE DA SOLUÇÃO\n    SE discriminante &lt; 0 ENTÃO\n        ESCREVER \"Ganho impossível de atingir com antena parabólica\"\n    SENÃO\n        \n        // CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\n        raizQuadrada ← calcularRaizQuadrada(discriminante)\n        \n        \n        // CALCULAR AS RAÍZES DA EQUAÇÃO QUADRÁTICA\n        diametro1, diametro2 ← calcularRaizes(a, b, raizQuadrada)\n        \n        // VALIDAR DIÂMETROS FÍSICOS\n        valida1 ← FALSO\n        valida2 ← FALSO\n        \n        // Verificar primeiro diâmetro\n        SE diametro1 &gt; 0 ENTÃO\n            valida1 ← VERDADEIRO\n        FIM SE\n        \n        // Verificar segundo diâmetro\n        SE diametro2 &gt; 0 ENTÃO\n            valida2 ← VERDADEIRO\n        FIM SE\n        \n        \n        // CALCULAR GANHOS PARA VERIFICAÇÃO\n        SE valida1 = VERDADEIRO ENTÃO\n            // Calcular G(d1) = -0.1d1² + 3d1 + 5\n            temp_d1_quadrado ← diametro1 * diametro1\n            temp_menos01d1_quadrado ← -0.1 * temp_d1_quadrado\n            temp_3d1 ← 3 * diametro1\n            temp_soma_termos ← temp_menos01d1_quadrado + temp_3d1\n            ganho_verificacao1 ← temp_soma_termos + 5\n        FIM SE\n        \n        SE valida2 = VERDADEIRO ENTÃO\n            // Calcular G(d2) = -0.1d2² + 3d2 + 5\n            temp_d2_quadrado ← diametro2 * diametro2\n            temp_menos01d2_quadrado ← -0.1 * temp_d2_quadrado\n            temp_3d2 ← 3 * diametro2\n            temp_soma_termos2 ← temp_menos01d2_quadrado + temp_3d2\n            ganho_verificacao2 ← temp_soma_termos2 + 5\n        FIM SE\n        \n        \n        // APRESENTAR RESULTADOS\n        SE valida1 = VERDADEIRO E valida2 = VERDADEIRO ENTÃO\n            // Ordenar diâmetros (menor primeiro)\n            SE diametro1 &gt; diametro2 ENTÃO\n                temp_swap ← diametro1\n                diametro1 ← diametro2\n                diametro2 ← temp_swap\n            FIM SE\n            \n            ESCREVER \"Dois diâmetros de antena possíveis:\"\n            ESCREVER \"Primeiro diâmetro:\", diametro1, \"metros\"\n            ESCREVER \"Segundo diâmetro:\", diametro2, \"metros\"\n            ESCREVER \"Ambos geram o ganho de:\", ganho_desejado, \"dB\"\n            ESCREVER \"Recomendação: usar o menor diâmetro por economia de material\"\n            \n        SENÃO SE valida1 = VERDADEIRO ENTÃO\n            ESCREVER \"Diâmetro da antena necessário:\"\n            ESCREVER diametro1, \"metros\"\n            ESCREVER \"Ganho gerado:\", ganho_verificacao1, \"dB\"\n            \n            // Mostrar também diâmetro negativo se existir\n            SE diametro2 &lt; 0 ENTÃO\n                ESCREVER \"Diâmetro negativo descartado:\", diametro2\n            FIM SE\n            \n        SENÃO SE valida2 = VERDADEIRO ENTÃO\n            ESCREVER \"Diâmetro da antena necessário:\"\n            ESCREVER diametro2, \"metros\"\n            ESCREVER \"Ganho gerado:\", ganho_verificacao2, \"dB\"\n            \n            // Mostrar também diâmetro negativo se existir\n            SE diametro1 &lt; 0 ENTÃO\n                ESCREVER \"Diâmetro negativo descartado:\", diametro1\n            FIM SE\n            \n        SENÃO\n            ESCREVER \"Todas as soluções resultam em diâmetros negativos:\"\n            ESCREVER \"Diâmetro 1:\", diametro1, \"metros\"\n            ESCREVER \"Diâmetro 2:\", diametro2, \"metros\"\n            ESCREVER \"Não é possível construir antenas com diâmetros negativos\"\n        FIM SE\n    FIM SE\n    \n    \n    // INFORMAÇÕES TÉCNICAS DA ANTENA\n    ESCREVER \"Informações da função de ganho G(d) = -0.1d² + 3d + 5:\"\n    \n    // Calcular diâmetro para ganho máximo (vértice da parábola)\n    // d_max = -b/(2a) = -3/(2*(-0.1)) = 3/0.2 = 15\n    temp_2a ← 2 * a\n    temp_menos_b ← 0 - b\n    d_maximo ← temp_menos_b / temp_2a\n    \n    // Calcular ganho máximo G(15)\n    temp_dmax_quadrado ← d_maximo * d_maximo\n    temp_menos01dmax_quadrado ← -0.1 * temp_dmax_quadrado\n    temp_3dmax ← 3 * d_maximo\n    temp_soma_max ← temp_menos01dmax_quadrado + temp_3dmax\n    ganho_maximo ← temp_soma_max + 5\n    \n    ESCREVER \"Diâmetro para ganho máximo:\", d_maximo, \"metros\"\n    ESCREVER \"Ganho máximo possível:\", ganho_maximo, \"dB\"\n    \n    // Calcular diâmetro mínimo para ganho positivo (G = 0)\n    // -0.1d² + 3d + 5 = 0\n    a_min ← -0.1\n    b_min ← 3\n    c_min ← 5\n    \n    temp1_min ← b_min * b_min\n    temp2_min ← 4 * a_min\n    temp3_min ← temp2_min * c_min\n    discriminante_min ← temp1_min - temp3_min\n    \n    SE discriminante_min &gt;= 0 ENTÃO\n        raizQuadrada_min ← calcularRaizQuadrada(discriminante_min)\n        diametro_min1, diametro_min2 ← calcularRaizes(a_min, b_min, raizQuadrada_min)\n        \n        // Escolher a maior raiz positiva (ponto no qual o ganho volta a zero)\n        SE diametro_min1 &gt; diametro_min2 ENTÃO\n            d_limite ← diametro_min1\n        SENÃO\n            d_limite ← diametro_min2\n        FIM SE\n        \n        ESCREVER \"Diâmetro limite (ganho = 0dB):\", d_limite, \"metros\"\n    FIM SE\nFIM\n\n// FUNÇÃO AUXILIAR: CALCULAR RAIZ QUADRADA (MÉTODO DE NEWTON)\nFUNÇÃO calcularRaizQuadrada(discriminante: real): real\nINÍCIO\n    raizQuadrada ← discriminante / 2\n    \n    ENQUANTO abs(raizQuadrada * raizQuadrada - discriminante) &gt; 0.0001 FAÇA\n        // Calcular raizQuadrada² \n        temp_quad ← raizQuadrada * raizQuadrada\n        \n        // Calcular numerador: raizQuadrada² + discriminante\n        numerador ← temp_quad + discriminante\n        \n        // Calcular denominador: 2 * raizQuadrada\n        denominador ← 2 * raizQuadrada\n        \n        // Nova aproximação\n        raizQuadrada ← numerador / denominador\n    FIM ENQUANTO\n    \n    RETORNAR raizQuadrada\nFIM\n\n// FUNÇÃO AUXILIAR: CALCULAR RAÍZES DA EQUAÇÃO QUADRÁTICA\nFUNÇÃO calcularRaizes(a: real, b: real, raizQuadrada: real): real, real\nINÍCIO\n    // Calcular -b\n    menos_b ← 0 - b\n    \n    // Calcular denominador comum: 2a\n    denominador_comum ← 2 * a\n    \n    // Calcular raiz1: (-b + √Δ) / 2a\n    numerador1 ← menos_b + raizQuadrada\n    raiz1 ← numerador1 / denominador_comum\n    \n    // Calcular raiz2: (-b - √Δ) / 2a  \n    numerador2 ← menos_b - raizQuadrada\n    raiz2 ← numerador2 / denominador_comum\n    \n    RETORNAR raiz1, raiz2\nFIM\n\n// FUNÇÃO AUXILIAR: VALOR ABSOLUTO\nFUNÇÃO abs(valor: real): real\nINÍCIO\n    SE valor &lt; 0 ENTÃO\n        resultado ← 0 - valor\n    SENÃO\n        resultado ← valor\n    FIM SE\n    RETORNAR resultado\nFIM\nO código em C++23 para o pseudocódigo acima pode ser encontrado no site GDB Online no link https://onlinegdb.com/ZGj9kp4Jp.\n\n\n7.1.2 Usando funções da biblioteca padrão\nA maioria das linguagens de programação modernas possui um conjunto de funções pré-definidas para as ações comuns em uma grande variedade de aplicações. Essas funções são otimizadas e testadas, oferecendo uma maneira eficiente de realizar tarefas comuns sem a necessidade de reescrever o código. Os exercícios a seguir exploram o uso destas funções. O professor, deve adequar estes exercícios de acordo com a linguagem de programação escolhida para a disciplina. Aqui, os exemplos serão realizados em C++23.\nPara o conjunto e exercícios a seguir, considere que o aluno já tenha sido apresentado às funções de manipulação de strings, manipulação de arquivos, e funções matemáticas básicas. Além das funções, métodos e classes da biblioteca padrão que estamos usando desde o primeiro código que fizemos, como std::cout, std::cin, std::string, etc.\nOs exercícios a seguir foram dimensionados para o uso da Técnica da Sequência de Fibonacci (1, 1, 2, 3,), como foi proposto para as seções anteriores.\nFinalmente, todos os exercícios são para a criação de sistemas especialistas. O professor pode aproveitar este conjunto de exercícios para discutir com os alunos a importância de se criar sistemas especialistas.\nA2: Uma casa lotérica precisa de um sistema para calcular probabilidades e combinações para seus jogos. O sistema deve calcular quantas combinações existem para a Mega-Sena (\\(6\\) números entre \\(1\\) e \\(60\\)), probabilidades de acertos parciais e outras operações matemáticas relacionadas. Desenvolva um programa que ofereça um menu com opções para calcular fatorial de um número, combinações \\(C(n,r)\\), permutações \\(P(n,r)\\), as probabilidades relacionadas com a Mega-Sena, e a chance de ganhar o prêmio principal de outras modalidades de loteria (Lotofácil, Quina, etc.). Conforme as especificações a seguir:\nFunções a implementar:\n\nFunções próprias: calcularFatorial(), calcularCombinacao(), calcularPermutacao()\nFunções da biblioteca padrão: As funções que sejam necessárias para resolver o problema\n\nMenu do sistema:\n\nCalcular fatorial de um número;\nCalcular combinação \\(C(n,r)\\);\nCalcular permutação \\(P(n,r)\\);\nMega-Sena: probabilidades de acertos (sena, quina, quadra);\nOutras loterias: Lotofácil (\\(15\\) de \\(25\\)), Quina (\\(5\\) de \\(80\\)), Dupla Sena (\\(6\\) de \\(50\\));\nSair.\n\nEntrada: Números para os cálculos conforme a opção escolhida\nSaída: Menu interativo com resultados dos cálculos matemáticos\nOperações específicas:\n\nMega-Sena: \\(C(60,6)\\) combinações totais, probabilidades de \\(4\\), \\(5\\) e \\(6\\) acertos;\nLotofácil: \\(C(25,15)\\) para \\(15\\) acertos;\nQuina: \\(C(80,5)\\) para \\(5\\) acertos;\nDupla Sena: \\(C(50,6)\\) para \\(6\\) acertos em cada sorteio.\n\nSolução:\nComeçamos com o pseudocódigo para o exercício:\nALGORITMO SistemaCasaLoterica\n\nENTRADA:\n    opcao_menu, numeros: inteiro\n\nSAÍDA:\n    resultados_calculos: real\n\nINÍCIO\n    opcao ← 0\n    \n    ENQUANTO opcao ≠ 7 FAÇA\n        \n        // APRESENTAR MENU PRINCIPAL\n        \n        ESCREVER \"=== SISTEMA CASA LOTÉRICA ===\"\n        ESCREVER \"1. Calcular Fatorial\"\n        ESCREVER \"2. Calcular Combinação C(n,r)\"\n        ESCREVER \"3. Calcular Permutação P(n,r)\"\n        ESCREVER \"4. Mega-Sena: Probabilidades Completas\"\n        ESCREVER \"5. Outros Jogos de Loteria\"\n        ESCREVER \"6. Simulação de Apostas\"\n        ESCREVER \"7. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        // PROCESSAR OPÇÃO ESCOLHIDA\n        SE opcao = 1 ENTÃO\n            ESCREVER \"Digite um número para calcular o fatorial:\"\n            LER n\n            SE n &gt;= 0 ENTÃO\n                resultado ← calcularFatorial(n)\n                ESCREVER \"Fatorial de\", n, \"=\", resultado\n            SENÃO\n                ESCREVER \"Erro: Número deve ser não-negativo\"\n            FIM SE\n            \n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite n (total de elementos):\"\n            LER n\n            ESCREVER \"Digite r (elementos escolhidos):\"\n            LER r\n            SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO\n                resultado ← calcularCombinacao(n, r)\n                ESCREVER \"C(\", n, \",\", r, \") =\", resultado\n            SENÃO\n                ESCREVER \"Erro: Parâmetros inválidos (n≥0, r≥0, r≤n)\"\n            FIM SE\n            \n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"Digite n (total de elementos):\"\n            LER n\n            ESCREVER \"Digite r (elementos escolhidos):\"\n            LER r\n            SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO\n                resultado ← calcularPermutacao(n, r)\n                ESCREVER \"P(\", n, \",\", r, \") =\", resultado\n            SENÃO\n                ESCREVER \"Erro: Parâmetros inválidos (n≥0, r≥0, r≤n)\"\n            FIM SE\n            \n        SENÃO SE opcao = 4 ENTÃO\n            ESCREVER \"=== MEGA-SENA: ANÁLISE COMPLETA ===\"\n            \n            // Combinações totais possíveis\n            total_combinacoes ← calcularCombinacao(60, 6)\n            ESCREVER \"Total de combinações possíveis:\", total_combinacoes\n            \n            // Probabilidade de acertar 6 números (sena)\n            prob_sena ← 1.0 / total_combinacoes\n            ESCREVER \"Sena (6 acertos):\"\n            ESCREVER \"  Probabilidade:\", prob_sena\n            ESCREVER \"  Chance: 1 em\", total_combinacoes\n            \n            // Probabilidade de acertar 5 números (quina)\n            comb_5_acertos ← calcularCombinacao(6, 5)\n            comb_1_erro ← calcularCombinacao(54, 1)\n            casos_quina ← comb_5_acertos * comb_1_erro\n            prob_quina ← casos_quina / total_combinacoes\n            chance_quina ← total_combinacoes / casos_quina\n            ESCREVER \"Quina (5 acertos):\"\n            ESCREVER \"  Probabilidade:\", prob_quina\n            ESCREVER \"  Chance: 1 em\", chance_quina\n            \n            // Probabilidade de acertar 4 números (quadra)\n            comb_4_acertos ← calcularCombinacao(6, 4)\n            comb_2_erros ← calcularCombinacao(54, 2)\n            casos_quadra ← comb_4_acertos * comb_2_erros\n            prob_quadra ← casos_quadra / total_combinacoes\n            chance_quadra ← total_combinacoes / casos_quadra\n            ESCREVER \"Quadra (4 acertos):\"\n            ESCREVER \"  Probabilidade:\", prob_quadra\n            ESCREVER \"  Chance: 1 em\", chance_quadra\n            \n        SENÃO SE opcao = 5 ENTÃO\n            ESCREVER \"=== OUTROS JOGOS DE LOTERIA ===\"\n            ESCREVER \"Escolha o jogo:\"\n            ESCREVER \"1. Lotofácil (15 de 25)\"\n            ESCREVER \"2. Quina (5 de 80)\"\n            ESCREVER \"3. Dupla Sena (6 de 50, dois sorteios)\"\n            ESCREVER \"4. Personalizado\"\n            LER jogo\n            \n            SE jogo = 1 ENTÃO\n                // Lotofácil: 15 números de 25\n                total_lotofacil ← calcularCombinacao(25, 15)\n                prob_lotofacil ← 1.0 / total_lotofacil\n                ESCREVER \"Lotofácil - Combinações possíveis:\", total_lotofacil\n                ESCREVER \"Probabilidade de 15 acertos:\", prob_lotofacil\n                \n            SENÃO SE jogo = 2 ENTÃO\n                // Quina: 5 números de 80\n                total_quina ← calcularCombinacao(80, 5)\n                prob_quina_jogo ← 1.0 / total_quina\n                ESCREVER \"Quina - Combinações possíveis:\", total_quina\n                ESCREVER \"Probabilidade de 5 acertos:\", prob_quina_jogo\n                \n            SENÃO SE jogo = 3 ENTÃO\n                // Dupla Sena: 6 números de 50, dois sorteios\n                total_dupla ← calcularCombinacao(50, 6)\n                prob_um_sorteio ← 1.0 / total_dupla\n                prob_qualquer_sorteio ← 2.0 * prob_um_sorteio\n                ESCREVER \"Dupla Sena - Combinações por sorteio:\", total_dupla\n                ESCREVER \"Probabilidade em um sorteio:\", prob_um_sorteio\n                ESCREVER \"Probabilidade em qualquer sorteio:\", prob_qualquer_sorteio\n                \n            SENÃO SE jogo = 4 ENTÃO\n                ESCREVER \"Digite o total de números disponíveis:\"\n                LER total_numeros\n                ESCREVER \"Digite quantos números são sorteados:\"\n                LER numeros_sorteados\n                SE total_numeros &gt;= numeros_sorteados E numeros_sorteados &gt; 0 ENTÃO\n                    total_personalizado ← calcularCombinacao(total_numeros, numeros_sorteados)\n                    prob_personalizado ← 1.0 / total_personalizado\n                    ESCREVER \"Combinações possíveis:\", total_personalizado\n                    ESCREVER \"Probabilidade de acerto:\", prob_personalizado\n                SENÃO\n                    ESCREVER \"Parâmetros inválidos\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 6 ENTÃO\n            ESCREVER \"=== SIMULAÇÃO DE APOSTAS ===\"\n            ESCREVER \"Digite o valor da aposta individual (R$):\"\n            LER valor_aposta\n            ESCREVER \"Digite o número de apostas:\"\n            LER num_apostas\n            \n            // Custo total\n            custo_total ← valor_aposta * num_apostas\n            ESCREVER \"Custo total: R$\", custo_total\n            \n            // Probabilidade de ganhar pelo menos uma vez usando pow()\n            total_comb_mega ← calcularCombinacao(60, 6)\n            prob_perder_uma ← (total_comb_mega - 1.0) / total_comb_mega\n            prob_perder_todas ← pow(prob_perder_uma, num_apostas)\n            prob_ganhar_pelo_menos_uma ← 1.0 - prob_perder_todas\n            \n            ESCREVER \"Probabilidade de não ganhar:\", prob_perder_todas\n            ESCREVER \"Probabilidade de ganhar pelo menos uma vez:\", prob_ganhar_pelo_menos_uma\n            \n            // Estatísticas\n            apostas_necessarias ← total_comb_mega\n            custo_garantia ← apostas_necessarias * valor_aposta\n            ESCREVER \"Apostas necessárias para garantir vitória:\", apostas_necessarias\n            ESCREVER \"Custo para garantir vitória: R$\", custo_garantia\n            \n        SENÃO SE opcao = 7 ENTÃO\n            ESCREVER \"Encerrando sistema da casa lotérica...\"\n            \n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n        \n        // Pausa para visualização\n        SE opcao ≠ 7 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n// FUNÇÃO: CALCULAR FATORIAL\nFUNÇÃO calcularFatorial(n: inteiro): real\nINÍCIO\n    SE n &lt; 0 ENTÃO\n        RETORNAR -1\n    FIM SE\n    \n    SE n = 0 OU n = 1 ENTÃO\n        RETORNAR 1\n    FIM SE\n    \n    resultado ← 1.0\n    PARA i DE 2 ATÉ n FAÇA\n        resultado ← resultado * i\n    FIM PARA\n    \n    RETORNAR resultado\nFIM\n\n// FUNÇÃO: CALCULAR COMBINAÇÃO C(n,r)\nFUNÇÃO calcularCombinacao(n: inteiro, r: inteiro): real\nINÍCIO\n    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO\n        RETORNAR -1\n    FIM SE\n    \n    SE r = 0 OU r = n ENTÃO\n        RETORNAR 1\n    FIM SE\n    \n    // Otimização: C(n,r) = C(n,n-r)\n    SE r &gt; n - r ENTÃO\n        r ← n - r\n    FIM SE\n    \n    // Cálculo iterativo para evitar overflow\n    resultado ← 1.0\n    PARA i DE 0 ATÉ r-1 FAÇA\n        resultado ← resultado * (n - i)\n        resultado ← resultado / (i + 1)\n    FIM PARA\n    \n    RETORNAR resultado\nFIM\n\n// FUNÇÃO: CALCULAR PERMUTAÇÃO P(n,r)\nFUNÇÃO calcularPermutacao(n: inteiro, r: inteiro): real\nINÍCIO\n    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO\n        RETORNAR -1\n    FIM SE\n    \n    SE r = 0 ENTÃO\n        RETORNAR 1\n    FIM SE\n    \n    // P(n,r) = n! / (n-r)! = n * (n-1) * ... * (n-r+1)\n    resultado ← 1.0\n    PARA i DE 0 ATÉ r-1 FAÇA\n        resultado ← resultado * (n - i)\n    FIM PARA\n    \n    RETORNAR resultado\nFIM\nO código em C++23 para implementar o pseudocódigo acima pode ser encontrado no site GDB Online no link https://onlinegdb.com/ugIolKSuu.\nFinalmente, este exercício A2 pode ser usado para introduzir outra abstração, switch-case. Sendo assim, o pseudocódigo será:\nALGORITMO SistemaCasaLoterica\n\nENTRADA:\n    opcao_menu, numeros: inteiro\n\nSAÍDA:\n    resultados_calculos: real\n\nINÍCIO\n    opcao ← 0\n    \n    ENQUANTO opcao ≠ 6 FAÇA\n        \n        // APRESENTAR MENU PRINCIPAL\n        ESCREVER \"=== SISTEMA CASA LOTÉRICA ===\"\n        ESCREVER \"1. Calcular fatorial de um número\"\n        ESCREVER \"2. Calcular combinação C(n,r)\"\n        ESCREVER \"3. Calcular permutação P(n,r)\"\n        ESCREVER \"4. Mega-Sena: probabilidades de acertos\"\n        ESCREVER \"5. Outras loterias\"\n        ESCREVER \"6. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        // PROCESSAR OPÇÃO COM SWITCH-CASE\n        ESCOLHA opcao FAÇA\n            CASO 1:\n                ESCREVER \"Digite um número para calcular o fatorial:\"\n                LER n\n                SE n &gt;= 0 ENTÃO\n                    resultado ← calcularFatorial(n)\n                    ESCREVER \"Fatorial de\", n, \"=\", resultado\n                SENÃO\n                    ESCREVER \"Erro: Número deve ser não-negativo\"\n                FIM SE\n                PARE\n                \n            CASO 2:\n                ESCREVER \"Digite n (total de elementos):\"\n                LER n\n                ESCREVER \"Digite r (elementos escolhidos):\"\n                LER r\n                SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO\n                    resultado ← calcularCombinacao(n, r)\n                    ESCREVER \"C(\", n, \",\", r, \") =\", resultado\n                SENÃO\n                    ESCREVER \"Erro: Parâmetros inválidos\"\n                FIM SE\n                PARE\n                \n            CASO 3:\n                ESCREVER \"Digite n (total de elementos):\"\n                LER n\n                ESCREVER \"Digite r (elementos escolhidos):\"\n                LER r\n                SE n &gt;= 0 E r &gt;= 0 E r &lt;= n ENTÃO\n                    resultado ← calcularPermutacao(n, r)\n                    ESCREVER \"P(\", n, \",\", r, \") =\", resultado\n                SENÃO\n                    ESCREVER \"Erro: Parâmetros inválidos\"\n                FIM SE\n                PARE\n                \n            CASO 4:\n                ESCREVER \"=== MEGA-SENA: PROBABILIDADES ===\"\n                \n                // Combinações totais C(60,6)\n                total_combinacoes ← calcularCombinacao(60, 6)\n                ESCREVER \"Total de combinações:\", total_combinacoes\n                \n                // Sena (6 acertos)\n                prob_sena ← 1.0 / total_combinacoes\n                ESCREVER \"Sena (6 acertos): 1 em\", total_combinacoes\n                \n                // Quina (5 acertos): C(6,5) * C(54,1) / C(60,6)\n                casos_quina ← calcularCombinacao(6, 5) * calcularCombinacao(54, 1)\n                prob_quina ← casos_quina / total_combinacoes\n                chance_quina ← total_combinacoes / casos_quina\n                ESCREVER \"Quina (5 acertos): 1 em\", chance_quina\n                \n                // Quadra (4 acertos): C(6,4) * C(54,2) / C(60,6)\n                casos_quadra ← calcularCombinacao(6, 4) * calcularCombinacao(54, 2)\n                prob_quadra ← casos_quadra / total_combinacoes\n                chance_quadra ← total_combinacoes / casos_quadra\n                ESCREVER \"Quadra (4 acertos): 1 em\", chance_quadra\n                PARE\n                \n            CASO 5:\n                ESCREVER \"=== OUTRAS LOTERIAS ===\"\n                ESCREVER \"1. Lotofácil (15 de 25)\"\n                ESCREVER \"2. Quina (5 de 80)\"\n                ESCREVER \"3. Dupla Sena (6 de 50)\"\n                ESCREVER \"Escolha:\"\n                LER subloteria\n                \n                ESCOLHA subloteria FAÇA\n                    CASO 1:\n                        total_lotofacil ← calcularCombinacao(25, 15)\n                        ESCREVER \"Lotofácil - Combinações:\", total_lotofacil\n                        ESCREVER \"Chance de ganhar: 1 em\", total_lotofacil\n                        PARE\n                        \n                    CASO 2:\n                        total_quina ← calcularCombinacao(80, 5)\n                        ESCREVER \"Quina - Combinações:\", total_quina\n                        ESCREVER \"Chance de ganhar: 1 em\", total_quina\n                        PARE\n                        \n                    CASO 3:\n                        total_dupla ← calcularCombinacao(50, 6)\n                        ESCREVER \"Dupla Sena - Combinações por sorteio:\", total_dupla\n                        ESCREVER \"Chance por sorteio: 1 em\", total_dupla\n                        PARE\n                        \n                    PADRÃO:\n                        ESCREVER \"Opção inválida\"\n                        PARE\n                FIM ESCOLHA\n                PARE\n                \n            CASO 6:\n                ESCREVER \"Encerrando sistema...\"\n                PARE\n                \n            PADRÃO:\n                ESCREVER \"Opção inválida! Tente novamente.\"\n                PARE\n        FIM ESCOLHA\n        \n        // Pausa para visualização\n        SE opcao ≠ 6 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n// FUNÇÃO: CALCULAR FATORIAL\nFUNÇÃO calcularFatorial(n: inteiro): real\nINÍCIO\n    SE n &lt; 0 ENTÃO\n        RETORNAR -1\n    FIM SE\n    \n    SE n = 0 OU n = 1 ENTÃO\n        RETORNAR 1\n    FIM SE\n    \n    resultado ← 1.0\n    PARA i DE 2 ATÉ n FAÇA\n        resultado ← resultado * i\n    FIM PARA\n    \n    RETORNAR resultado\nFIM\n\n// FUNÇÃO: CALCULAR COMBINAÇÃO C(n,r)\nFUNÇÃO calcularCombinacao(n: inteiro, r: inteiro): real\nINÍCIO\n    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO\n        RETORNAR -1\n    FIM SE\n    \n    SE r = 0 OU r = n ENTÃO\n        RETORNAR 1\n    FIM SE\n    \n    // Otimização: C(n,r) = C(n,n-r)\n    SE r &gt; n - r ENTÃO\n        r ← n - r\n    FIM SE\n    \n    // Cálculo iterativo para evitar overflow\n    resultado ← 1.0\n    PARA i DE 0 ATÉ r-1 FAÇA\n        resultado ← resultado * (n - i)\n        resultado ← resultado / (i + 1)\n    FIM PARA\n    \n    RETORNAR resultado\nFIM\n\n// FUNÇÃO: CALCULAR PERMUTAÇÃO P(n,r)\nFUNÇÃO calcularPermutacao(n: inteiro, r: inteiro): real\nINÍCIO\n    SE n &lt; 0 OU r &lt; 0 OU r &gt; n ENTÃO\n        RETORNAR -1\n    FIM SE\n    \n    SE r = 0 ENTÃO\n        RETORNAR 1\n    FIM SE\n    \n    // P(n,r) = n! / (n-r)!\n    resultado ← 1.0\n    PARA i DE 0 ATÉ r-1 FAÇA\n        resultado ← resultado * (n - i)\n    FIM PARA\n    \n    RETORNAR resultado\nFIM\nNeste caso, #### Código C++23 O código para implementar o pseudocódigo com switch-case está disponível no site GDB Online no link https://onlinegdb.com/WED1nNGeV.\nB2: um banco precisa de um sistema para orientar clientes sobre investimentos. O sistema deve calcular rendimentos de aplicações em renda fixa, determinar quanto tempo leva para duplicar um investimento e validar se os dados inseridos pelo cliente estão corretos. Crie um programa que calcule o montante final de um investimento com juros compostos, determine em quantos anos o capital dobra de valor e valide se as entradas do usuário são positivas e realistas.\nFunções a implementar:\n\nFunções próprias: calcularJuroComposto(), tempoParaDobrar(), validarEntrada()\nFunções padrão: pow(), log()\n\nEntrada: Capital inicial, taxa de juros anual, período de investimento Saída: Montante final, tempo para dobrar o capital, alertas de validação\nSolução:\nNeste caso, podemos representar o probleam como:\nALGORITMO SistemaBancarioInvestimentos\n\nENTRADA:\n    capital_inicial, taxa_juros, periodo: real\n\nSAÍDA:\n    montante_final, tempo_dobrar, alertas: real\n\nINÍCIO\n    opcao ← 0\n    \n    ENQUANTO opcao ≠ 5 FAÇA\n        \n        // APRESENTAR MENU PRINCIPAL\n        \n        ESCREVER \"=== SISTEMA BANCÁRIO DE INVESTIMENTOS ===\"\n        ESCREVER \"1. Calcular montante final (juros compostos)\"\n        ESCREVER \"2. Calcular tempo para dobrar o capital\"\n        ESCREVER \"3. Validar dados de entrada\"\n        ESCREVER \"4. Sistema completo de análise\"\n        ESCREVER \"5. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        \n        // PROCESSAR OPÇÃO ESCOLHIDA\n        \n        SE opcao = 1 ENTÃO\n            ESCREVER \"=== CÁLCULO DE MONTANTE FINAL ===\"\n            ESCREVER \"Digite o capital inicial (R$):\"\n            LER capital_inicial\n            ESCREVER \"Digite a taxa de juros anual (%):\"\n            LER taxa_juros\n            ESCREVER \"Digite o período em anos:\"\n            LER periodo\n            \n            // Validar entradas\n            validacao ← validarEntrada(capital_inicial, taxa_juros, periodo)\n            \n            SE validacao = VERDADEIRO ENTÃO\n                montante ← calcularJuroComposto(capital_inicial, taxa_juros, periodo)\n                rendimento ← montante - capital_inicial\n                ESCREVER \"Capital inicial: R$\", capital_inicial\n                ESCREVER \"Montante final: R$\", montante\n                ESCREVER \"Rendimento: R$\", rendimento\n                porcentagem_ganho ← (rendimento / capital_inicial) * 100\n                ESCREVER \"Ganho percentual:\", porcentagem_ganho, \"%\"\n            SENÃO\n                ESCREVER \"Dados inválidos! Verifique os valores inseridos.\"\n            FIM SE\n            \n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"=== TEMPO PARA DOBRAR O CAPITAL ===\"\n            ESCREVER \"Digite a taxa de juros anual (%):\"\n            LER taxa_juros\n            \n            SE taxa_juros &gt; 0 E taxa_juros &lt;= 50 ENTÃO\n                tempo ← tempoParaDobrar(taxa_juros)\n                ESCREVER \"Com taxa de\", taxa_juros, \"% ao ano:\"\n                ESCREVER \"Tempo para dobrar o capital:\", tempo, \"anos\"\n                \n                // Regra prática dos 72\n                regra_72 ← 72 / taxa_juros\n                ESCREVER \"Regra dos 72 (aproximação):\", regra_72, \"anos\"\n                diferenca ← abs(tempo - regra_72)\n                ESCREVER \"Diferença entre cálculo exato e regra dos 72:\", diferenca, \"anos\"\n            SENÃO\n                ESCREVER \"Taxa de juros inválida! Use valores entre 0.1% e 50%.\"\n            FIM SE\n            \n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"=== VALIDAÇÃO DE DADOS ===\"\n            ESCREVER \"Digite o capital inicial (R$):\"\n            LER capital_inicial\n            ESCREVER \"Digite a taxa de juros anual (%):\"\n            LER taxa_juros\n            ESCREVER \"Digite o período em anos:\"\n            LER periodo\n            \n            validacao ← validarEntrada(capital_inicial, taxa_juros, periodo)\n            \n            SE validacao = VERDADEIRO ENTÃO\n                ESCREVER \"✓ Todos os dados estão válidos!\"\n                ESCREVER \"✓ Capital inicial: R$\", capital_inicial, \"(válido)\"\n                ESCREVER \"✓ Taxa de juros:\", taxa_juros, \"% ao ano (válida)\"\n                ESCREVER \"✓ Período:\", periodo, \"anos (válido)\"\n            SENÃO\n                ESCREVER \"✗ Dados inválidos detectados!\"\n                \n                // Validações específicas\n                SE capital_inicial &lt;= 0 ENTÃO\n                    ESCREVER \"✗ Capital inicial deve ser positivo\"\n                FIM SE\n                \n                SE taxa_juros &lt;= 0 OU taxa_juros &gt; 50 ENTÃO\n                    ESCREVER \"✗ Taxa de juros deve estar entre 0.1% e 50%\"\n                FIM SE\n                \n                SE periodo &lt;= 0 OU periodo &gt; 100 ENTÃO\n                    ESCREVER \"✗ Período deve estar entre 1 e 100 anos\"\n                FIM SE\n            FIM SE\n            \n        SENÃO SE opcao = 4 ENTÃO\n            ESCREVER \"=== SISTEMA COMPLETO DE ANÁLISE ===\"\n            ESCREVER \"Digite o capital inicial (R$):\"\n            LER capital_inicial\n            ESCREVER \"Digite a taxa de juros anual (%):\"\n            LER taxa_juros\n            ESCREVER \"Digite o período em anos:\"\n            LER periodo\n            \n            // Validar todas as entradas\n            validacao ← validarEntrada(capital_inicial, taxa_juros, periodo)\n            \n            SE validacao = VERDADEIRO ENTÃO\n                ESCREVER \"\\n--- ANÁLISE COMPLETA DO INVESTIMENTO ---\"\n                \n                // Cálculo do montante final\n                montante ← calcularJuroComposto(capital_inicial, taxa_juros, periodo)\n                rendimento ← montante - capital_inicial\n                \n                ESCREVER \"💰 RESULTADOS FINANCEIROS:\"\n                ESCREVER \"Capital inicial: R$\", capital_inicial\n                ESCREVER \"Montante final: R$\", montante\n                ESCREVER \"Rendimento total: R$\", rendimento\n                porcentagem_ganho ← (rendimento / capital_inicial) * 100\n                ESCREVER \"Ganho percentual total:\", porcentagem_ganho, \"%\"\n                \n                // Tempo para dobrar\n                tempo_dobrar ← tempoParaDobrar(taxa_juros)\n                ESCREVER \"\\n⏰ TEMPO PARA DOBRAR:\"\n                ESCREVER \"Tempo para dobrar o capital:\", tempo_dobrar, \"anos\"\n                \n                // Análise comparativa\n                SE periodo &gt;= tempo_dobrar ENTÃO\n                    multiplicador ← periodo / tempo_dobrar\n                    ESCREVER \"Em\", periodo, \"anos, o capital dobrará\", multiplicador, \"vezes\"\n                SENÃO\n                    faltam_anos ← tempo_dobrar - periodo\n                    ESCREVER \"Faltam\", faltam_anos, \"anos para o capital dobrar\"\n                FIM SE\n                \n                // Recomendações\n                ESCREVER \"\\n📊 RECOMENDAÇÕES:\"\n                SE taxa_juros &lt; 5 ENTÃO\n                    ESCREVER \"⚠️  Taxa baixa - considere outras opções de investimento\"\n                SENÃO SE taxa_juros &gt; 20 ENTÃO\n                    ESCREVER \"⚠️  Taxa alta - verifique os riscos envolvidos\"\n                SENÃO\n                    ESCREVER \"✓ Taxa dentro de padrões normais do mercado\"\n                FIM SE\n                \n                SE periodo &lt; 2 ENTÃO\n                    ESCREVER \"💡 Investimento de curto prazo - juros compostos têm menor impacto\"\n                SENÃO SE periodo &gt; 10 ENTÃO\n                    ESCREVER \"💡 Investimento de longo prazo - excelente para juros compostos\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"❌ Não é possível realizar a análise com dados inválidos.\"\n                ESCREVER \"Por favor, corrija os valores e tente novamente.\"\n            FIM SE\n            \n        SENÃO SE opcao = 5 ENTÃO\n            ESCREVER \"Encerrando sistema bancário...\"\n            \n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n        \n        // Pausa para visualização\n        SE opcao ≠ 5 ENTÃO\n            ESCREVER \"\\nPressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n\n// FUNÇÃO: CALCULAR JUROS COMPOSTOS\n// M = C * (1 + i)^t\n\nFUNÇÃO calcularJuroComposto(capital: real, taxa: real, tempo: real): real\nINÍCIO\n    // Converter taxa percentual para decimal\n    taxa_decimal ← taxa / 100\n    \n    // Calcular (1 + taxa)\n    base ← 1 + taxa_decimal\n    \n    // Calcular (1 + taxa)^tempo usando pow()\n    fator_multiplicacao ← pow(base, tempo)\n    \n    // Calcular montante final\n    montante ← capital * fator_multiplicacao\n    \n    RETORNAR montante\nFIM\n\n\n// FUNÇÃO: TEMPO PARA DOBRAR O CAPITAL\n// 2 = (1 + i)^t  =&gt;  t = log(2) / log(1 + i)\n\nFUNÇÃO tempoParaDobrar(taxa: real): real\nINÍCIO\n    // Converter taxa percentual para decimal\n    taxa_decimal ← taxa / 100\n    \n    // Calcular (1 + taxa)\n    base ← 1 + taxa_decimal\n    \n    // Calcular log(2) / log(1 + taxa) usando log()\n    numerador ← log(2)\n    denominador ← log(base)\n    tempo ← numerador / denominador\n    \n    RETORNAR tempo\nFIM\n\n// FUNÇÃO: VALIDAR ENTRADA\nFUNÇÃO validarEntrada(capital: real, taxa: real, periodo: real): logico\nINÍCIO\n    // Validar capital inicial\n    SE capital &lt;= 0 ENTÃO\n        RETORNAR FALSO\n    FIM SE\n    \n    // Validar taxa de juros (entre 0.1% e 50%)\n    SE taxa &lt;= 0 OU taxa &gt; 50 ENTÃO\n        RETORNAR FALSO\n    FIM SE\n    \n    // Validar período (entre 1 e 100 anos)\n    SE periodo &lt;= 0 OU periodo &gt; 100 ENTÃO\n        RETORNAR FALSO\n    FIM SE\n    \n    // Se chegou até aqui, todos os dados são válidos\n    RETORNAR VERDADEIRO\nFIM\nResultando no código em C++23 que pode ser encontrado no GDB Online no link https://onlinegdb.com/Ha2Sfflfd.\nC2: Um escritório de engenharia civil precisa de um sistema para calcular parâmetros de rampas de acessibilidade e escadas. O sistema deve determinar ângulos de inclinação, comprimentos necessários e validar se os projetos atendem às normas de acessibilidade. Crie um programa que calcule ângulos de rampas, comprimentos de escadas e valide conformidade com normas brasileiras de acessibilidade.\nFunções a implementar: - Funções próprias: calcularAnguloRampa(), calcularComprimentoEscada(), validarAcessibilidade() - Funções padrão: sin(), cos(), tan(), atan(), asin()\nEntrada: Altura, comprimento, ângulo (conforme tipo de cálculo) Saída: Ângulos em graus, comprimentos em metros, status de conformidade com normas\nCálculos específicos: - Rampa de acessibilidade: máximo 8.33% de inclinação (NBR 9050) - Escadas: ângulo ideal entre 25° e 35° - Conversão radianos/graus automática\nSolução:\nComeçando pelo pseudocódigo, teremos:\nALGORITMO SistemaEngenhariaCivil\n\nENTRADA:\n    altura, comprimento, angulo: real\n\nSAÍDA:\n    angulos, comprimentos, status_conformidade: real\n\nINÍCIO\n    opcao ← 0\n    PI ← 3.14159265359\n    \n    ENQUANTO opcao ≠ 6 FAÇA\n        \n        // APRESENTAR MENU PRINCIPAL\n        ESCREVER \"=== SISTEMA DE ENGENHARIA CIVIL ===\"\n        ESCREVER \"1. Calcular ângulo de rampa de acessibilidade\"\n        ESCREVER \"2. Calcular comprimento de escada\"\n        ESCREVER \"3. Validar conformidade com normas\"\n        ESCREVER \"4. Análise completa de projeto\"\n        ESCREVER \"5. Conversões trigonométricas\"\n        ESCREVER \"6. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        \n        // PROCESSAR OPÇÃO ESCOLHIDA\n        SE opcao = 1 ENTÃO\n            ESCREVER \"=== CÁLCULO DE ÂNGULO DE RAMPA ===\"\n            ESCREVER \"Digite a altura da rampa (metros):\"\n            LER altura\n            ESCREVER \"Digite o comprimento da rampa (metros):\"\n            LER comprimento\n            \n            SE altura &gt; 0 E comprimento &gt; 0 ENTÃO\n                angulo ← calcularAnguloRampa(altura, comprimento)\n                inclinacao_percentual ← (altura / comprimento) * 100\n                \n                ESCREVER \"Altura:\", altura, \"m\"\n                ESCREVER \"Comprimento:\", comprimento, \"m\"\n                ESCREVER \"Ângulo de inclinação:\", angulo, \"graus\"\n                ESCREVER \"Inclinação percentual:\", inclinacao_percentual, \"%\"\n                \n                // Verificar conformidade NBR 9050\n                SE inclinacao_percentual &lt;= 8.33 ENTÃO\n                    ESCREVER \"✓ Rampa CONFORME com NBR 9050 (máx. 8.33%)\"\n                SENÃO\n                    ESCREVER \"✗ Rampa NÃO CONFORME com NBR 9050\"\n                    comprimento_minimo ← altura / 0.0833\n                    ESCREVER \"Comprimento mínimo necessário:\", comprimento_minimo, \"m\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Erro: Altura e comprimento devem ser positivos\"\n            FIM SE\n            \n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"=== CÁLCULO DE COMPRIMENTO DE ESCADA ===\"\n            ESCREVER \"Digite a altura total da escada (metros):\"\n            LER altura\n            ESCREVER \"Digite o ângulo desejado (graus):\"\n            LER angulo\n            \n            SE altura &gt; 0 E angulo &gt; 0 E angulo &lt; 90 ENTÃO\n                comprimento ← calcularComprimentoEscada(altura, angulo)\n                projecao_horizontal ← altura / tan(angulo * PI / 180)\n                \n                ESCREVER \"Altura total:\", altura, \"m\"\n                ESCREVER \"Ângulo:\", angulo, \"graus\"\n                ESCREVER \"Comprimento da escada:\", comprimento, \"m\"\n                ESCREVER \"Projeção horizontal:\", projecao_horizontal, \"m\"\n                \n                // Verificar ângulo ideal para escadas\n                SE angulo &gt;= 25 E angulo &lt;= 35 ENTÃO\n                    ESCREVER \"✓ Ângulo IDEAL para escadas (25° a 35°)\"\n                SENÃO SE angulo &lt; 25 ENTÃO\n                    ESCREVER \"⚠️ Ângulo muito baixo - escada pode ser desconfortável\"\n                SENÃO\n                    ESCREVER \"⚠️ Ângulo muito alto - escada pode ser perigosa\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Erro: Altura deve ser positiva e ângulo entre 0° e 90°\"\n            FIM SE\n            \n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"=== VALIDAÇÃO DE CONFORMIDADE ===\"\n            ESCREVER \"Escolha o tipo de estrutura:\"\n            ESCREVER \"1. Rampa de acessibilidade\"\n            ESCREVER \"2. Escada\"\n            LER tipo_estrutura\n            \n            SE tipo_estrutura = 1 ENTÃO\n                ESCREVER \"Digite a altura da rampa (metros):\"\n                LER altura\n                ESCREVER \"Digite o comprimento da rampa (metros):\"\n                LER comprimento\n                \n                SE altura &gt; 0 E comprimento &gt; 0 ENTÃO\n                    conformidade ← validarAcessibilidade(altura, comprimento, 1)\n                    \n                    SE conformidade = VERDADEIRO ENTÃO\n                        ESCREVER \"✓ Rampa APROVADA - Conforme NBR 9050\"\n                    SENÃO\n                        ESCREVER \"✗ Rampa REPROVADA - Não conforme NBR 9050\"\n                    FIM SE\n                SENÃO\n                    ESCREVER \"Dados inválidos\"\n                FIM SE\n                \n            SENÃO SE tipo_estrutura = 2 ENTÃO\n                ESCREVER \"Digite o ângulo da escada (graus):\"\n                LER angulo\n                \n                SE angulo &gt; 0 E angulo &lt; 90 ENTÃO\n                    conformidade ← validarAcessibilidade(0, 0, angulo)\n                    \n                    SE conformidade = VERDADEIRO ENTÃO\n                        ESCREVER \"✓ Escada APROVADA - Ângulo adequado\"\n                    SENÃO\n                        ESCREVER \"✗ Escada com ângulo inadequado\"\n                    FIM SE\n                SENÃO\n                    ESCREVER \"Ângulo inválido\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 4 ENTÃO\n            ESCREVER \"=== ANÁLISE COMPLETA DE PROJETO ===\"\n            ESCREVER \"Digite a altura (metros):\"\n            LER altura\n            ESCREVER \"Digite o comprimento disponível (metros):\"\n            LER comprimento_disponivel\n            \n            SE altura &gt; 0 E comprimento_disponivel &gt; 0 ENTÃO\n                ESCREVER \"\\n--- ANÁLISE PARA RAMPA ---\"\n                \n                // Análise de rampa\n                angulo_rampa ← calcularAnguloRampa(altura, comprimento_disponivel)\n                inclinacao ← (altura / comprimento_disponivel) * 100\n                \n                ESCREVER \"Ângulo atual:\", angulo_rampa, \"graus\"\n                ESCREVER \"Inclinação:\", inclinacao, \"%\"\n                \n                comprimento_ideal_rampa ← altura / 0.0833\n                ESCREVER \"Comprimento ideal para rampa:\", comprimento_ideal_rampa, \"m\"\n                \n                SE comprimento_disponivel &gt;= comprimento_ideal_rampa ENTÃO\n                    ESCREVER \"✓ Espaço SUFICIENTE para rampa conforme\"\n                SENÃO\n                    ESCREVER \"✗ Espaço INSUFICIENTE para rampa conforme\"\n                FIM SE\n                \n                ESCREVER \"\\n--- ANÁLISE PARA ESCADA ---\"\n                \n                // Análise de escada com ângulos ideais\n                angulo_30 ← 30.0\n                comprimento_escada_30 ← calcularComprimentoEscada(altura, angulo_30)\n                projecao_30 ← altura / tan(angulo_30 * PI / 180)\n                \n                ESCREVER \"Com ângulo de 30° (ideal):\"\n                ESCREVER \"Comprimento da escada:\", comprimento_escada_30, \"m\"\n                ESCREVER \"Projeção horizontal:\", projecao_30, \"m\"\n                \n                SE projecao_30 &lt;= comprimento_disponivel ENTÃO\n                    ESCREVER \"✓ Espaço SUFICIENTE para escada ideal\"\n                SENÃO\n                    ESCREVER \"✗ Espaço INSUFICIENTE para escada ideal\"\n                    \n                    // Calcular ângulo máximo possível\n                    angulo_maximo ← atan(altura / comprimento_disponivel) * 180 / PI\n                    ESCREVER \"Ângulo máximo possível:\", angulo_maximo, \"graus\"\n                FIM SE\n                \n                ESCREVER \"\\n--- RECOMENDAÇÃO FINAL ---\"\n                SE comprimento_disponivel &gt;= comprimento_ideal_rampa ENTÃO\n                    ESCREVER \"💡 RECOMENDAÇÃO: Construir rampa de acessibilidade\"\n                SENÃO SE projecao_30 &lt;= comprimento_disponivel ENTÃO\n                    ESCREVER \"💡 RECOMENDAÇÃO: Construir escada com ângulo ideal\"\n                SENÃO\n                    ESCREVER \"💡 RECOMENDAÇÃO: Reavaliar projeto - espaço limitado\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Dados inválidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 5 ENTÃO\n            ESCREVER \"=== CONVERSÕES TRIGONOMÉTRICAS ===\"\n            ESCREVER \"1. Graus para radianos\"\n            ESCREVER \"2. Radianos para graus\"\n            ESCREVER \"3. Calcular seno/cosseno/tangente\"\n            LER tipo_conversao\n            \n            SE tipo_conversao = 1 ENTÃO\n                ESCREVER \"Digite o ângulo em graus:\"\n                LER angulo_graus\n                radianos ← angulo_graus * PI / 180\n                ESCREVER angulo_graus, \"° =\", radianos, \"radianos\"\n                \n            SENÃO SE tipo_conversao = 2 ENTÃO\n                ESCREVER \"Digite o ângulo em radianos:\"\n                LER angulo_radianos\n                graus ← angulo_radianos * 180 / PI\n                ESCREVER angulo_radianos, \"rad =\", graus, \"°\"\n                \n            SENÃO SE tipo_conversao = 3 ENTÃO\n                ESCREVER \"Digite o ângulo em graus:\"\n                LER angulo_graus\n                radianos ← angulo_graus * PI / 180\n                \n                seno ← sin(radianos)\n                cosseno ← cos(radianos)\n                tangente ← tan(radianos)\n                \n                ESCREVER \"Para ângulo de\", angulo_graus, \"°:\"\n                ESCREVER \"Seno:\", seno\n                ESCREVER \"Cosseno:\", cosseno\n                ESCREVER \"Tangente:\", tangente\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 6 ENTÃO\n            ESCREVER \"Encerrando sistema de engenharia...\"\n            \n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n        \n        // Pausa para visualização\n        SE opcao ≠ 6 ENTÃO\n            ESCREVER \"\\nPressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n// FUNÇÃO: CALCULAR ÂNGULO DE RAMPA\nFUNÇÃO calcularAnguloRampa(altura: real, comprimento: real): real\nINÍCIO\n    PI ← 3.14159265359\n    \n    // Calcular ângulo usando arcotangente\n    angulo_radianos ← atan(altura / comprimento)\n    \n    // Converter para graus\n    angulo_graus ← angulo_radianos * 180 / PI\n    \n    RETORNAR angulo_graus\nFIM\n\n\n// FUNÇÃO: CALCULAR COMPRIMENTO DE ESCADA\nFUNÇÃO calcularComprimentoEscada(altura: real, angulo_graus: real): real\nINÍCIO\n    PI ← 3.14159265359\n    \n    // Converter ângulo para radianos\n    angulo_radianos ← angulo_graus * PI / 180\n    \n    // Calcular comprimento usando seno: altura = comprimento * sen(ângulo)\n    comprimento ← altura / sin(angulo_radianos)\n    \n    RETORNAR comprimento\nFIM\n\n\n// FUNÇÃO: VALIDAR ACESSIBILIDADE\nFUNÇÃO validarAcessibilidade(altura: real, comprimento: real, angulo: real): logico\nINÍCIO\n    // Se ângulo foi fornecido, é validação de escada\n    SE angulo &gt; 0 ENTÃO\n        // Validar escada: ângulo ideal entre 25° e 35°\n        SE angulo &gt;= 25 E angulo &lt;= 35 ENTÃO\n            RETORNAR VERDADEIRO\n        SENÃO\n            RETORNAR FALSO\n        FIM SE\n    SENÃO\n        // Validar rampa: inclinação máxima 8.33% (NBR 9050)\n        inclinacao_percentual ← (altura / comprimento) * 100\n        \n        SE inclinacao_percentual &lt;= 8.33 ENTÃO\n            RETORNAR VERDADEIRO\n        SENÃO\n            RETORNAR FALSO\n        FIM SE\n    FIM SE\nFIM\nO que código para implementação do pseudocódigo acima está disponível no GDB OnLine no endereço https://onlinegdb.com/_2rc38V9b.\nD2: Uma empresa de engenharia acústica precisa de um sistema para calcular níveis de ruído e intensidade sonora em projetos urbanos. O sistema deve converter intensidades para decibéis, calcular atenuação sonora com a distância e somar níveis de ruído de múltiplas fontes. Crie um programa que processe medições acústicas para controle de poluição sonora.\nFunções a implementar: - Funções próprias: calcularDecibeis(), calcularAtenuacao(), somarRuidos() - Funções padrão: log10(), exp(), pow(), log()\nEntrada: Intensidade sonora, distância, múltiplos níveis de ruído Saída: Níveis em dB, atenuação por distância, soma logarítmica de ruídos\nCálculos específicos: - Conversão I→dB: dB = 10×log₁₀(I/I₀) - Atenuação: dB_dist = dB_orig - 20×log₁₀(d₂/d₁) - Soma de ruídos: dB_total = 10×log₁₀(∑10^(dBᵢ/10))\nSolução:\nComeçando pelo pseudocódigo, teremos:\nALGORITMO SistemaEngenhariaAcustica\n\nENTRADA:\n    intensidade, distancia, niveis_db: real\n\nSAÍDA:\n    decibeis, atenuacao, soma_ruidos: real\n\nINÍCIO\n    opcao ← 0\n    I0 ← 1e-12  // Intensidade de referência: 10⁻¹² W/m²\n    \n    ENQUANTO opcao ≠ 6 FAÇA\n        \n        // APRESENTAR MENU PRINCIPAL\n        \n        ESCREVER \"=== SISTEMA DE ENGENHARIA ACÚSTICA ===\"\n        ESCREVER \"1. Converter intensidade para decibéis\"\n        ESCREVER \"2. Calcular atenuação sonora com distância\"\n        ESCREVER \"3. Somar níveis de ruído (múltiplas fontes)\"\n        ESCREVER \"4. Análise completa de projeto acústico\"\n        ESCREVER \"5. Conversões logarítmicas\"\n        ESCREVER \"6. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        \n        // PROCESSAR OPÇÃO ESCOLHIDA\n        \n        SE opcao = 1 ENTÃO\n            ESCREVER \"=== CONVERSÃO INTENSIDADE → DECIBÉIS ===\"\n            ESCREVER \"Digite a intensidade sonora (W/m²):\"\n            LER intensidade\n            \n            SE intensidade &gt; 0 ENTÃO\n                decibeis ← calcularDecibeis(intensidade)\n                \n                ESCREVER \"Intensidade:\", intensidade, \"W/m²\"\n                ESCREVER \"Nível sonoro:\", decibeis, \"dB\"\n                \n                // Classificação do ruído\n                SE decibeis &lt;= 30 ENTÃO\n                    ESCREVER \"Classificação: Muito silencioso\"\n                SENÃO SE decibeis &lt;= 50 ENTÃO\n                    ESCREVER \"Classificação: Silencioso\"\n                SENÃO SE decibeis &lt;= 70 ENTÃO\n                    ESCREVER \"Classificação: Moderado\"\n                SENÃO SE decibeis &lt;= 85 ENTÃO\n                    ESCREVER \"Classificação: Alto\"\n                SENÃO SE decibeis &lt;= 100 ENTÃO\n                    ESCREVER \"Classificação: Muito alto\"\n                SENÃO\n                    ESCREVER \"Classificação: Perigoso - usar proteção auditiva\"\n                FIM SE\n                \n                // Limites legais\n                SE decibeis &gt; 55 ENTÃO\n                    ESCREVER \"⚠️ Acima do limite diurno residencial (55 dB)\"\n                FIM SE\n                \n                SE decibeis &gt; 70 ENTÃO\n                    ESCREVER \"⚠️ Acima do limite comercial (70 dB)\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Erro: Intensidade deve ser positiva\"\n            FIM SE\n            \n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"=== CÁLCULO DE ATENUAÇÃO SONORA ===\"\n            ESCREVER \"Digite o nível inicial (dB):\"\n            LER nivel_inicial\n            ESCREVER \"Digite a distância inicial (metros):\"\n            LER distancia_inicial\n            ESCREVER \"Digite a nova distância (metros):\"\n            LER distancia_final\n            \n            SE nivel_inicial &gt;= 0 E distancia_inicial &gt; 0 E distancia_final &gt; 0 ENTÃO\n                nivel_final ← calcularAtenuacao(nivel_inicial, distancia_inicial, distancia_final)\n                perda_sonora ← nivel_inicial - nivel_final\n                \n                ESCREVER \"Nível inicial:\", nivel_inicial, \"dB a\", distancia_inicial, \"m\"\n                ESCREVER \"Nível final:\", nivel_final, \"dB a\", distancia_final, \"m\"\n                ESCREVER \"Perda sonora:\", perda_sonora, \"dB\"\n                \n                // Análise da atenuação\n                SE distancia_final &gt; distancia_inicial ENTÃO\n                    fator_distancia ← distancia_final / distancia_inicial\n                    ESCREVER \"Distância aumentou\", fator_distancia, \"vezes\"\n                    ESCREVER \"Redução esperada: ~\", 20 * log10(fator_distancia), \"dB\"\n                SENÃO\n                    ESCREVER \"⚠️ Som ficou mais alto - distância diminuiu\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Erro: Dados devem ser positivos e válidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"=== SOMA DE NÍVEIS DE RUÍDO ===\"\n            ESCREVER \"Quantas fontes de ruído você quer somar (2-5):\"\n            LER num_fontes\n            \n            SE num_fontes &gt;= 2 E num_fontes &lt;= 5 ENTÃO\n                nivel1 ← 0\n                nivel2 ← 0\n                nivel3 ← 0\n                nivel4 ← 0\n                nivel5 ← 0\n                \n                ESCREVER \"Digite o nível da fonte 1 (dB):\"\n                LER nivel1\n                ESCREVER \"Digite o nível da fonte 2 (dB):\"\n                LER nivel2\n                \n                SE num_fontes &gt;= 3 ENTÃO\n                    ESCREVER \"Digite o nível da fonte 3 (dB):\"\n                    LER nivel3\n                FIM SE\n                \n                SE num_fontes &gt;= 4 ENTÃO\n                    ESCREVER \"Digite o nível da fonte 4 (dB):\"\n                    LER nivel4\n                FIM SE\n                \n                SE num_fontes = 5 ENTÃO\n                    ESCREVER \"Digite o nível da fonte 5 (dB):\"\n                    LER nivel5\n                FIM SE\n                \n                // Calcular soma logarítmica\n                nivel_total ← somarRuidos(nivel1, nivel2, nivel3, nivel4, nivel5, num_fontes)\n                \n                ESCREVER \"Fontes individuais:\"\n                ESCREVER \"Fonte 1:\", nivel1, \"dB\"\n                ESCREVER \"Fonte 2:\", nivel2, \"dB\"\n                \n                SE num_fontes &gt;= 3 ENTÃO\n                    ESCREVER \"Fonte 3:\", nivel3, \"dB\"\n                FIM SE\n                SE num_fontes &gt;= 4 ENTÃO\n                    ESCREVER \"Fonte 4:\", nivel4, \"dB\"\n                FIM SE\n                SE num_fontes = 5 ENTÃO\n                    ESCREVER \"Fonte 5:\", nivel5, \"dB\"\n                FIM SE\n                \n                ESCREVER \"Nível total combinado:\", nivel_total, \"dB\"\n                \n                // Análise da soma\n                maior_individual ← nivel1\n                SE nivel2 &gt; maior_individual ENTÃO maior_individual ← nivel2 FIM SE\n                SE nivel3 &gt; maior_individual ENTÃO maior_individual ← nivel3 FIM SE\n                SE nivel4 &gt; maior_individual ENTÃO maior_individual ← nivel4 FIM SE\n                SE nivel5 &gt; maior_individual ENTÃO maior_individual ← nivel5 FIM SE\n                \n                incremento ← nivel_total - maior_individual\n                ESCREVER \"Incremento sobre a fonte mais alta:\", incremento, \"dB\"\n                \n            SENÃO\n                ESCREVER \"Número de fontes deve estar entre 2 e 5\"\n            FIM SE\n            \n        SENÃO SE opcao = 4 ENTÃO\n            ESCREVER \"=== ANÁLISE COMPLETA DE PROJETO ACÚSTICO ===\"\n            ESCREVER \"Digite a intensidade da fonte principal (W/m²):\"\n            LER intensidade_principal\n            ESCREVER \"Digite a distância da medição (metros):\"\n            LER distancia_medicao\n            ESCREVER \"Digite o nível de ruído de fundo (dB):\"\n            LER ruido_fundo\n            \n            SE intensidade_principal &gt; 0 E distancia_medicao &gt; 0 E ruido_fundo &gt;= 0 ENTÃO\n                ESCREVER \"\\n--- ANÁLISE DA FONTE PRINCIPAL ---\"\n                \n                // Converter intensidade para dB\n                nivel_fonte ← calcularDecibeis(intensidade_principal)\n                ESCREVER \"Nível da fonte:\", nivel_fonte, \"dB\"\n                \n                // Calcular níveis em diferentes distâncias\n                distancia_1m ← 1.0\n                nivel_1m ← calcularAtenuacao(nivel_fonte, distancia_medicao, distancia_1m)\n                \n                distancia_10m ← 10.0\n                nivel_10m ← calcularAtenuacao(nivel_fonte, distancia_medicao, distancia_10m)\n                \n                distancia_100m ← 100.0\n                nivel_100m ← calcularAtenuacao(nivel_fonte, distancia_medicao, distancia_100m)\n                \n                ESCREVER \"Nível a 1m:\", nivel_1m, \"dB\"\n                ESCREVER \"Nível a 10m:\", nivel_10m, \"dB\"\n                ESCREVER \"Nível a 100m:\", nivel_100m, \"dB\"\n                \n                ESCREVER \"\\n--- ANÁLISE COM RUÍDO DE FUNDO ---\"\n                \n                // Combinar fonte principal com ruído de fundo\n                nivel_combinado ← somarRuidos(nivel_fonte, ruido_fundo, 0, 0, 0, 2)\n                ESCREVER \"Nível combinado (fonte + fundo):\", nivel_combinado, \"dB\"\n                \n                mascaramento ← nivel_combinado - ruido_fundo\n                ESCREVER \"Efeito de mascaramento:\", mascaramento, \"dB\"\n                \n                ESCREVER \"\\n--- CONFORMIDADE LEGAL ---\"\n                \n                // Verificar limites legais (CONAMA 001/90)\n                SE nivel_combinado &lt;= 55 ENTÃO\n                    ESCREVER \"✓ Conforme para área residencial (≤55 dB diurno)\"\n                SENÃO\n                    ESCREVER \"✗ Não conforme para área residencial\"\n                    reducao_necessaria ← nivel_combinado - 55\n                    ESCREVER \"Redução necessária:\", reducao_necessaria, \"dB\"\n                FIM SE\n                \n                SE nivel_combinado &lt;= 70 ENTÃO\n                    ESCREVER \"✓ Conforme para área comercial (≤70 dB)\"\n                SENÃO\n                    ESCREVER \"✗ Não conforme para área comercial\"\n                FIM SE\n                \n                ESCREVER \"\\n--- RECOMENDAÇÕES ---\"\n                \n                SE nivel_combinado &gt; 85 ENTÃO\n                    ESCREVER \"🔊 Recomenda-se proteção auditiva\"\n                FIM SE\n                \n                SE nivel_combinado &gt; 55 ENTÃO\n                    distancia_segura ← distancia_medicao * pow(10, (nivel_combinado - 55) / 20)\n                    ESCREVER \"💡 Distância mínima para 55dB:\", distancia_segura, \"m\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Dados inválidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 5 ENTÃO\n            ESCREVER \"=== CONVERSÕES LOGARÍTMICAS ===\"\n            ESCREVER \"1. dB para intensidade (W/m²)\"\n            ESCREVER \"2. Intensidade para dB\"\n            ESCREVER \"3. Calcular log₁₀ e logaritmo natural\"\n            LER tipo_conversao\n            \n            SE tipo_conversao = 1 ENTÃO\n                ESCREVER \"Digite o nível em dB:\"\n                LER decibeis\n                \n                // Converter dB para intensidade: I = I₀ × 10^(dB/10)\n                intensidade ← I0 * pow(10, decibeis / 10)\n                ESCREVER decibeis, \"dB =\", intensidade, \"W/m²\"\n                \n            SENÃO SE tipo_conversao = 2 ENTÃO\n                ESCREVER \"Digite a intensidade (W/m²):\"\n                LER intensidade\n                \n                SE intensidade &gt; 0 ENTÃO\n                    decibeis ← calcularDecibeis(intensidade)\n                    ESCREVER intensidade, \"W/m² =\", decibeis, \"dB\"\n                SENÃO\n                    ESCREVER \"Intensidade deve ser positiva\"\n                FIM SE\n                \n            SENÃO SE tipo_conversao = 3 ENTÃO\n                ESCREVER \"Digite um número positivo:\"\n                LER numero\n                \n                SE numero &gt; 0 ENTÃO\n                    log_10 ← log10(numero)\n                    log_natural ← log(numero)\n                    \n                    ESCREVER \"Número:\", numero\n                    ESCREVER \"log₁₀(\", numero, \") =\", log_10\n                    ESCREVER \"ln(\", numero, \") =\", log_natural\n                SENÃO\n                    ESCREVER \"Número deve ser positivo\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 6 ENTÃO\n            ESCREVER \"Encerrando sistema de engenharia acústica...\"\n            \n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n        \n        // Pausa para visualização\n        SE opcao ≠ 6 ENTÃO\n            ESCREVER \"\\nPressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n// FUNÇÃO: CALCULAR DECIBÉIS\n// dB = 10 × log₁₀(I/I₀)\nFUNÇÃO calcularDecibeis(intensidade: real): real\nINÍCIO\n    I0 ← 1e-12  // Intensidade de referência: 10⁻¹² W/m²\n    \n    // Calcular razão I/I₀\n    razao ← intensidade / I0\n    \n    // Calcular dB = 10 × log₁₀(I/I₀)\n    decibeis ← 10 * log10(razao)\n    \n    RETORNAR decibeis\nFIM\n\n\n// FUNÇÃO: CALCULAR ATENUAÇÃO\n// dB_dist = dB_orig - 20 × log₁₀(d₂/d₁)\nFUNÇÃO calcularAtenuacao(nivel_inicial: real, dist_inicial: real, dist_final: real): real\nINÍCIO\n    // Calcular razão das distâncias\n    razao_distancias ← dist_final / dist_inicial\n    \n    // Calcular perda por distância: 20 × log₁₀(d₂/d₁)\n    perda ← 20 * log10(razao_distancias)\n    \n    // Nível final = nível inicial - perda\n    nivel_final ← nivel_inicial - perda\n    \n    RETORNAR nivel_final\nFIM\n\n// FUNÇÃO: SOMAR RUÍDOS\n// dB_total = 10 × log₁₀(∑10^(dBᵢ/10))\nFUNÇÃO somarRuidos(db1: real, db2: real, db3: real, db4: real, db5: real, num_fontes: inteiro): real\nINÍCIO\n    // Converter cada dB para intensidade relativa\n    intensidade1 ← pow(10, db1 / 10)\n    intensidade2 ← pow(10, db2 / 10)\n    \n    soma_intensidades ← intensidade1 + intensidade2\n    \n    SE num_fontes &gt;= 3 ENTÃO\n        intensidade3 ← pow(10, db3 / 10)\n        soma_intensidades ← soma_intensidades + intensidade3\n    FIM SE\n    \n    SE num_fontes &gt;= 4 ENTÃO\n        intensidade4 ← pow(10, db4 / 10)\n        soma_intensidades ← soma_intensidades + intensidade4\n    FIM SE\n    \n    SE num_fontes = 5 ENTÃO\n        intensidade5 ← pow(10, db5 / 10)\n        soma_intensidades ← soma_intensidades + intensidade5\n    FIM SE\n    \n    // Converter soma de volta para dB\n    db_total ← 10 * log10(soma_intensidades)\n    \n    RETORNAR db_total\nFIM\nCujo código C++ correspondente está disponivel no GDB OnLine no link https://onlinegdb.com/-ACks3zVu.\nE2: Uma empresa de engenharia elétrica precisa de um sistema para calcular parâmetros de circuitos trifásicos, eficiência energética e análise de harmônicos. O sistema deve determinar as potências ativa (\\(P\\)), reativa (\\(Q\\)) e aparente (\\(S\\)), calcular o fator de potência (\\(FP\\)) e analisar a distorção harmônica total (\\(THD\\)) em instalações industriais.\nFunções a implementar: - Funções próprias: calcularPotenciaTrifasica(), calcularFatorPotencia(), analisarHarmonicos() - Funções padrão: sqrt(), pow(), sin(), cos(), atan(), fabs()\nEntrada: Tensão (\\(V\\)), corrente (\\(I\\)), ângulo de fase (\\(\\phi\\)), e as amplitudes das frequências harmônicas (\\(H_h\\)). Saída: Potências (\\(P\\) em kW, \\(Q\\) em kVAr, \\(S\\) em kVA), fator de potência (\\(FP\\)), \\(THD\\%\\), e status de conformidade com normas.\nCálculos específicos: - Potência ativa (\\(P\\)): \\[P = \\sqrt{3} \\cdot V \\cdot I \\cdot \\cos(\\phi)\\]\n\nPotência reativa (\\(Q\\)): \\[Q = \\sqrt{3} \\cdot V \\cdot I \\cdot \\sin(\\phi)\\]\nFator de Potência (\\(FP\\)): \\[FP = \\cos(\\phi)\\]\nDistorção Harmônica Total (\\(THD\\)): \\[THD = \\frac{\\sqrt{\\sum_{h=2}^{n} H_h^2}}{H_1} \\times 100\\%\\]\n\nSolução:\nComeçando pelo pseudocódigo.\nALGORITMO SistemaEngenhariaEletrica\n\nENTRADA:\n    tensao, corrente, angulo_fase, harmonicos: real\n\nSAÍDA:\n    potencias, fator_potencia, thd, conformidade: real\n\nINÍCIO\n    opcao ← 0\n    PI ← 3.14159265359\n    \n    ENQUANTO opcao ≠ 6 FAÇA\n        \n        // BLOCO: APRESENTAR MENU PRINCIPAL\n        ESCREVER \"=== SISTEMA DE ENGENHARIA ELÉTRICA ===\"\n        ESCREVER \"1. Calcular potências trifásicas\"\n        ESCREVER \"2. Calcular fator de potência\"\n        ESCREVER \"3. Analisar distorção harmônica (THD)\"\n        ESCREVER \"4. Análise completa do sistema elétrico\"\n        ESCREVER \"5. Conversões e utilidades elétricas\"\n        ESCREVER \"6. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        \n        // BLOCO: PROCESSAR OPÇÃO ESCOLHIDA\n        SE opcao = 1 ENTÃO\n            ESCREVER \"=== CÁLCULO DE POTÊNCIAS TRIFÁSICAS ===\"\n            ESCREVER \"Digite a tensão de linha (V):\"\n            LER tensao\n            ESCREVER \"Digite a corrente de linha (A):\"\n            LER corrente\n            ESCREVER \"Digite o ângulo de fase (graus):\"\n            LER angulo_graus\n            \n            SE tensao &gt; 0 E corrente &gt; 0 ENTÃO\n                potencia_ativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 1)\n                potencia_reativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 2)\n                potencia_aparente ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 3)\n                \n                ESCREVER \"Tensão de linha:\", tensao, \"V\"\n                ESCREVER \"Corrente de linha:\", corrente, \"A\"\n                ESCREVER \"Ângulo de fase:\", angulo_graus, \"°\"\n                ESCREVER \"Potência ativa (P):\", potencia_ativa, \"kW\"\n                ESCREVER \"Potência reativa (Q):\", potencia_reativa, \"kVAr\"\n                ESCREVER \"Potência aparente (S):\", potencia_aparente, \"kVA\"\n                \n                // Classificação do sistema\n                SE potencia_ativa &lt; 100 ENTÃO\n                    ESCREVER \"Classificação: Sistema de baixa potência\"\n                SENÃO SE potencia_ativa &lt; 1000 ENTÃO\n                    ESCREVER \"Classificação: Sistema de média potência\"\n                SENÃO\n                    ESCREVER \"Classificação: Sistema de alta potência\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Erro: Tensão e corrente devem ser positivas\"\n            FIM SE\n            \n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"=== CÁLCULO DE FATOR DE POTÊNCIA ===\"\n            ESCREVER \"Digite a potência ativa (kW):\"\n            LER potencia_ativa\n            ESCREVER \"Digite a potência aparente (kVA):\"\n            LER potencia_aparente\n            \n            SE potencia_ativa &gt; 0 E potencia_aparente &gt; 0 E potencia_ativa &lt;= potencia_aparente ENTÃO\n                fator_potencia ← calcularFatorPotencia(potencia_ativa, potencia_aparente)\n                angulo_phi ← acos(fator_potencia) * 180 / PI\n                \n                ESCREVER \"Potência ativa:\", potencia_ativa, \"kW\"\n                ESCREVER \"Potência aparente:\", potencia_aparente, \"kVA\"\n                ESCREVER \"Fator de potência:\", fator_potencia\n                ESCREVER \"Ângulo φ:\", angulo_phi, \"°\"\n                \n                // Análise da qualidade\n                SE fator_potencia &gt;= 0.95 ENTÃO\n                    ESCREVER \"✓ Excelente - Sem necessidade de correção\"\n                SENÃO SE fator_potencia &gt;= 0.85 ENTÃO\n                    ESCREVER \"⚠️ Bom - Considerar correção para grandes cargas\"\n                SENÃO SE fator_potencia &gt;= 0.75 ENTÃO\n                    ESCREVER \"⚠️ Regular - Recomenda-se correção\"\n                SENÃO\n                    ESCREVER \"✗ Ruim - Correção urgente necessária\"\n                FIM SE\n                \n                // Cálculo de capacitores para correção\n                SE fator_potencia &lt; 0.95 ENTÃO\n                    potencia_reativa_atual ← potencia_ativa * tan(acos(fator_potencia))\n                    potencia_reativa_desejada ← potencia_ativa * tan(acos(0.95))\n                    capacitores_necessarios ← potencia_reativa_atual - potencia_reativa_desejada\n                    ESCREVER \"Capacitores necessários para FP=0.95:\", fabs(capacitores_necessarios), \"kVAr\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Erro: Dados inválidos (P deve ser ≤ S)\"\n            FIM SE\n            \n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"=== ANÁLISE DE DISTORÇÃO HARMÔNICA ===\"\n            ESCREVER \"Digite a amplitude da fundamental (A ou V):\"\n            LER fundamental\n            ESCREVER \"Quantos harmônicos analisar (2-10):\"\n            LER num_harmonicos\n            \n            SE fundamental &gt; 0 E num_harmonicos &gt;= 2 E num_harmonicos &lt;= 10 ENTÃO\n                thd ← analisarHarmonicos(fundamental, num_harmonicos)\n                \n                ESCREVER \"Fundamental (H1):\", fundamental\n                ESCREVER \"THD total:\", thd, \"%\"\n                \n                // Classificação da qualidade\n                SE thd &lt;= 5 ENTÃO\n                    ESCREVER \"✓ Excelente qualidade - THD ≤ 5%\"\n                SENÃO SE thd &lt;= 8 ENTÃO\n                    ESCREVER \"✓ Boa qualidade - THD ≤ 8%\"\n                SENÃO SE thd &lt;= 15 ENTÃO\n                    ESCREVER \"⚠️ Qualidade aceitável - THD ≤ 15%\"\n                SENÃO\n                    ESCREVER \"✗ Má qualidade - THD &gt; 15%\"\n                FIM SE\n                \n                // Normas brasileiras (PRODIST)\n                SE thd &lt;= 10 ENTÃO\n                    ESCREVER \"✓ Conforme PRODIST - Módulo 8\"\n                SENÃO\n                    ESCREVER \"✗ Não conforme PRODIST - Módulo 8\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Erro: Dados inválidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 4 ENTÃO\n            ESCREVER \"=== ANÁLISE COMPLETA DO SISTEMA ELÉTRICO ===\"\n            ESCREVER \"Digite a tensão de linha (V):\"\n            LER tensao\n            ESCREVER \"Digite a corrente de linha (A):\"\n            LER corrente\n            ESCREVER \"Digite o ângulo de fase (graus):\"\n            LER angulo_graus\n            ESCREVER \"Digite a amplitude da fundamental para THD:\"\n            LER fundamental\n            \n            SE tensao &gt; 0 E corrente &gt; 0 E fundamental &gt; 0 ENTÃO\n                ESCREVER \"\\n--- ANÁLISE DE POTÊNCIAS ---\"\n                \n                // Cálculos de potência\n                potencia_ativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 1)\n                potencia_reativa ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 2)\n                potencia_aparente ← calcularPotenciaTrifasica(tensao, corrente, angulo_graus, 3)\n                \n                ESCREVER \"Potência ativa:\", potencia_ativa, \"kW\"\n                ESCREVER \"Potência reativa:\", potencia_reativa, \"kVAr\"\n                ESCREVER \"Potência aparente:\", potencia_aparente, \"kVA\"\n                \n                // Fator de potência\n                fator_potencia ← calcularFatorPotencia(potencia_ativa, potencia_aparente)\n                ESCREVER \"Fator de potência:\", fator_potencia\n                \n                ESCREVER \"\\n--- ANÁLISE DE QUALIDADE ---\"\n                \n                // THD com 5 harmônicos por padrão\n                thd ← analisarHarmonicos(fundamental, 5)\n                ESCREVER \"THD (5 harmônicos):\", thd, \"%\"\n                \n                ESCREVER \"\\n--- ANÁLISE ECONÔMICA ---\"\n                \n                // Custo estimado por perdas\n                perda_percentual ← (1 - fator_potencia) * 100\n                ESCREVER \"Perdas por baixo FP:\", perda_percentual, \"%\"\n                \n                // Estimativa de custo mensal (R$ 0,50/kWh)\n                custo_kwh ← 0.50\n                horas_mes ← 720  // 30 dias × 24 horas\n                custo_mensal ← potencia_ativa * horas_mes * custo_kwh\n                ESCREVER \"Custo mensal estimado: R$\", custo_mensal\n                \n                ESCREVER \"\\n--- CONFORMIDADE GERAL ---\"\n                \n                problemas ← 0\n                \n                SE fator_potencia &lt; 0.85 ENTÃO\n                    problemas ← problemas + 1\n                    ESCREVER \"⚠️ Fator de potência baixo\"\n                FIM SE\n                \n                SE thd &gt; 10 ENTÃO\n                    problemas ← problemas + 1\n                    ESCREVER \"⚠️ THD acima do limite PRODIST\"\n                FIM SE\n                \n                SE problemas = 0 ENTÃO\n                    ESCREVER \"✓ Sistema em conformidade total\"\n                SENÃO\n                    ESCREVER \"✗ Sistema com\", problemas, \"não conformidade(s)\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Dados inválidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 5 ENTÃO\n            ESCREVER \"=== CONVERSÕES E UTILIDADES ELÉTRICAS ===\"\n            ESCREVER \"1. Converter potência (W ↔ HP ↔ CV)\"\n            ESCREVER \"2. Calcular resistência por temperatura\"\n            ESCREVER \"3. Converter ângulos (graus ↔ radianos)\"\n            LER tipo_conversao\n            \n            SE tipo_conversao = 1 ENTÃO\n                ESCREVER \"Digite a potência em Watts:\"\n                LER potencia_watts\n                \n                SE potencia_watts &gt; 0 ENTÃO\n                    hp ← potencia_watts / 745.7\n                    cv ← potencia_watts / 735.5\n                    \n                    ESCREVER potencia_watts, \"W =\"\n                    ESCREVER \"  \", hp, \"HP\"\n                    ESCREVER \"  \", cv, \"CV\"\n                SENÃO\n                    ESCREVER \"Potência deve ser positiva\"\n                FIM SE\n                \n            SENÃO SE tipo_conversao = 2 ENTÃO\n                ESCREVER \"Digite a resistência a 20°C (Ω):\"\n                LER r20\n                ESCREVER \"Digite a temperatura atual (°C):\"\n                LER temperatura\n                \n                // Coeficiente de temperatura do cobre\n                alfa ← 0.00393\n                r_temp ← r20 * (1 + alfa * (temperatura - 20))\n                \n                ESCREVER \"Resistência a\", temperatura, \"°C:\", r_temp, \"Ω\"\n                variacao ← ((r_temp - r20) / r20) * 100\n                ESCREVER \"Variação:\", variacao, \"%\"\n                \n            SENÃO SE tipo_conversao = 3 ENTÃO\n                ESCREVER \"1. Graus para radianos\"\n                ESCREVER \"2. Radianos para graus\"\n                LER direcao\n                \n                SE direcao = 1 ENTÃO\n                    ESCREVER \"Digite o ângulo em graus:\"\n                    LER graus\n                    radianos ← graus * PI / 180\n                    ESCREVER graus, \"° =\", radianos, \"rad\"\n                SENÃO SE direcao = 2 ENTÃO\n                    ESCREVER \"Digite o ângulo em radianos:\"\n                    LER radianos\n                    graus ← radianos * 180 / PI\n                    ESCREVER radianos, \"rad =\", graus, \"°\"\n                SENÃO\n                    ESCREVER \"Opção inválida\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 6 ENTÃO\n            ESCREVER \"Encerrando sistema de engenharia elétrica...\"\n            \n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n        \n        // Pausa para visualização\n        SE opcao ≠ 6 ENTÃO\n            ESCREVER \"\\nPressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n// FUNÇÃO: CALCULAR POTÊNCIA TRIFÁSICA\n// P = √3 × V × I × cos(φ)  [tipo 1]\n// Q = √3 × V × I × sin(φ)  [tipo 2]\n// S = √3 × V × I           [tipo 3]\n\nFUNÇÃO calcularPotenciaTrifasica(tensao: real, corrente: real, angulo_graus: real, tipo: inteiro): real\nINÍCIO\n    PI ← 3.14159265359\n    \n    // Converter ângulo para radianos\n    angulo_rad ← angulo_graus * PI / 180\n    \n    // Fator √3\n    raiz_tres ← sqrt(3)\n    \n    // Potência base em VA\n    potencia_base ← raiz_tres * tensao * corrente\n    \n    SE tipo = 1 ENTÃO\n        // Potência ativa (kW)\n        potencia_ativa ← potencia_base * cos(angulo_rad)\n        RETORNAR potencia_ativa / 1000\n    SENÃO SE tipo = 2 ENTÃO\n        // Potência reativa (kVAr)\n        potencia_reativa ← potencia_base * sin(angulo_rad)\n        RETORNAR potencia_reativa / 1000\n    SENÃO SE tipo = 3 ENTÃO\n        // Potência aparente (kVA)\n        RETORNAR potencia_base / 1000\n    SENÃO\n        RETORNAR 0\n    FIM SE\nFIM\n\n// FUNÇÃO: CALCULAR FATOR DE POTÊNCIA\n// FP = P / S = cos(φ)\nFUNÇÃO calcularFatorPotencia(potencia_ativa: real, potencia_aparente: real): real\nINÍCIO\n    SE potencia_aparente = 0 ENTÃO\n        RETORNAR 0\n    FIM SE\n    \n    fator_potencia ← potencia_ativa / potencia_aparente\n    \n    // Garantir que está entre 0 e 1\n    SE fator_potencia &gt; 1 ENTÃO\n        fator_potencia ← 1\n    FIM SE\n    \n    SE fator_potencia &lt; 0 ENTÃO\n        fator_potencia ← 0\n    FIM SE\n    \n    RETORNAR fator_potencia\nFIM\n\n// FUNÇÃO: ANALISAR HARMÔNICOS\n// THD = √(∑H²₂₋ₙ)/H₁ × 100%\nFUNÇÃO analisarHarmonicos(fundamental: real, num_harmonicos: inteiro): real\nINÍCIO\n    soma_quadrados ← 0\n    \n    // Processar cada harmônico sequencialmente\n    PARA i DE 2 ATÉ num_harmonicos FAÇA\n        ESCREVER \"Digite a amplitude do\", i, \"º harmônico:\"\n        LER harmonica\n        \n        SE harmonica &gt;= 0 ENTÃO\n            quadrado ← pow(harmonica, 2)\n            soma_quadrados ← soma_quadrados + quadrado\n            \n            // Mostrar porcentagem individual\n            percentual_individual ← (harmonica / fundamental) * 100\n            ESCREVER \"H\", i, \":\", percentual_individual, \"% da fundamental\"\n        FIM SE\n    FIM PARA\n    \n    // Calcular THD\n    SE fundamental &gt; 0 ENTÃO\n        raiz_soma ← sqrt(soma_quadrados)\n        thd ← (raiz_soma / fundamental) * 100\n        RETORNAR thd\n    SENÃO\n        RETORNAR 0\n    FIM SE\nFIM\nO código C++ correspondente está disponível no GDB OnLine no link https://onlinegdb.com/hWZ7dfvok.\nF2: Um observatório astronômico precisa de um sistema para calcular posições de corpos celestes, distâncias interplanetárias e janelas de lançamento de missões espaciais. O sistema deve converter coordenadas celestes (e.g., de \\((\\alpha, \\delta)\\) para \\((x,y,z)\\)), calcular órbitas elípticas e determinar tempos de trânsito (\\(t\\)) usando mecânica orbital.\nFunções a implementar: - Funções próprias: calcularPosicaoOrbital(), determinarJanelaLancamento(), converterCoordenadas() - Funções padrão: sin(), cos(), tan(), asin(), acos(), sqrt(), pow(), fmod()\nEntrada: Elementos orbitais (e.g., \\(a, e, i, \\Omega, \\omega, M\\)), coordenadas, tempo (\\(t\\)), velocidade inicial (\\(v_0\\)). Saída: Posições celestes, distâncias (\\(d\\)) em UA, velocidade de escape (\\(v_e\\)), delta-V (\\(\\Delta v\\)).\nCálculos específicos: - Equação de Kepler (relaciona anomalia média \\(M\\) com anomalia excêntrica \\(E\\) e excentricidade \\(e\\)): \\[M = E - e \\sin(E)\\]\n\nVelocidade orbital (Equação vis-viva), na qual de \\(v\\) é a velocidade, \\(\\mu\\) o parâmetro gravitacional, \\(r\\) a distância radial e \\(a\\) o semi-eixo maior: \\[v = \\sqrt{\\mu \\left( \\frac{2}{r} - \\frac{1}{a} \\right)}\\]\n\nSolução:\nComeçando com o pseudocódigo:\nALGORITMO SistemaObservatorioAstronomico\n\nENTRADA:\n    elementos_orbitais, coordenadas, tempo, velocidades: real\n\nSAÍDA:\n    posicoes_celestes, distancias_ua, velocidades_escape, delta_v: real\n\nINÍCIO\n    opcao ← 0\n    PI ← 3.14159265359\n    MU_SOL ← 1.32712440018e20  // μ solar em m³/s²\n    UA ← 149597870700.0        // Unidade Astronômica em metros\n    \n    ENQUANTO opcao ≠ 6 FAÇA\n        \n        // BLOCO: APRESENTAR MENU PRINCIPAL\n        ESCREVER \"=== SISTEMA DE OBSERVATÓRIO ASTRONÔMICO ===\"\n        ESCREVER \"1. Calcular posição orbital de corpo celeste\"\n        ESCREVER \"2. Determinar janela de lançamento\"\n        ESCREVER \"3. Converter coordenadas celestes\"\n        ESCREVER \"4. Análise completa de missão espacial\"\n        ESCREVER \"5. Conversões astronômicas\"\n        ESCREVER \"6. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        // BLOCO: PROCESSAR OPÇÃO ESCOLHIDA\n        SE opcao = 1 ENTÃO\n            ESCREVER \"=== CÁLCULO DE POSIÇÃO ORBITAL ===\"\n            ESCREVER \"Digite o semi-eixo maior (UA):\"\n            LER semi_eixo_maior\n            ESCREVER \"Digite a excentricidade (0-1):\"\n            LER excentricidade\n            ESCREVER \"Digite a anomalia média (graus):\"\n            LER anomalia_media_graus\n            ESCREVER \"Digite a inclinação (graus):\"\n            LER inclinacao_graus\n            \n            SE semi_eixo_maior &gt; 0 E excentricidade &gt;= 0 E excentricidade &lt; 1 ENTÃO\n                posicao_orbital ← calcularPosicaoOrbital(semi_eixo_maior, excentricidade, anomalia_media_graus, inclinacao_graus)\n                \n                ESCREVER \"Semi-eixo maior:\", semi_eixo_maior, \"UA\"\n                ESCREVER \"Excentricidade:\", excentricidade\n                ESCREVER \"Anomalia média:\", anomalia_media_graus, \"graus\"\n                ESCREVER \"Distância heliocêntrica:\", posicao_orbital, \"UA\"\n                \n                // Calcular período orbital (3ª Lei de Kepler)\n                periodo_anos ← sqrt(pow(semi_eixo_maior, 3))\n                ESCREVER \"Período orbital:\", periodo_anos, \"anos\"\n                \n                // Velocidade no periélio e afélio\n                r_perielio ← semi_eixo_maior * (1 - excentricidade)\n                r_afelio ← semi_eixo_maior * (1 + excentricidade)\n                \n                // Converter UA para metros para cálculos de velocidade\n                a_metros ← semi_eixo_maior * UA\n                r_per_metros ← r_perielio * UA\n                r_af_metros ← r_afelio * UA\n                \n                v_perielio ← sqrt(MU_SOL * (2 / r_per_metros - 1 / a_metros))\n                v_afelio ← sqrt(MU_SOL * (2 / r_af_metros - 1 / a_metros))\n                \n                ESCREVER \"Velocidade no periélio:\", v_perielio / 1000, \"km/s\"\n                ESCREVER \"Velocidade no afélio:\", v_afelio / 1000, \"km/s\"\n                \n            SENÃO\n                ESCREVER \"Erro: Parâmetros orbitais inválidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"=== DETERMINAÇÃO DE JANELA DE LANÇAMENTO ===\"\n            ESCREVER \"Digite a distância Terra-destino atual (UA):\"\n            LER distancia_atual\n            ESCREVER \"Digite a velocidade relativa (km/s):\"\n            LER velocidade_relativa\n            ESCREVER \"Digite o período sinódico do destino (dias):\"\n            LER periodo_sinodico\n            \n            SE distancia_atual &gt; 0 E velocidade_relativa &gt; 0 E periodo_sinodico &gt; 0 ENTÃO\n                janela_otima ← determinarJanelaLancamento(distancia_atual, velocidade_relativa, periodo_sinodico)\n                \n                ESCREVER \"Distância atual:\", distancia_atual, \"UA\"\n                ESCREVER \"Velocidade relativa:\", velocidade_relativa, \"km/s\"\n                ESCREVER \"Tempo de viagem ótimo:\", janela_otima, \"dias\"\n                \n                // Calcular delta-V necessário\n                distancia_metros ← distancia_atual * UA\n                delta_v_ms ← sqrt(2 * MU_SOL / distancia_metros)\n                delta_v_escape_terra ← 11200  // m/s\n                delta_v_total ← delta_v_ms + delta_v_escape_terra\n                \n                ESCREVER \"Delta-V de escape:\", delta_v_escape_terra / 1000, \"km/s\"\n                ESCREVER \"Delta-V interplanetário:\", delta_v_ms / 1000, \"km/s\"\n                ESCREVER \"Delta-V total:\", delta_v_total / 1000, \"km/s\"\n                \n                // Próxima janela\n                proxima_janela ← janela_otima + periodo_sinodico\n                ESCREVER \"Próxima janela em:\", proxima_janela, \"dias\"\n                \n            SENÃO\n                ESCREVER \"Erro: Parâmetros de missão inválidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"=== CONVERSÃO DE COORDENADAS CELESTES ===\"\n            ESCREVER \"1. Equatoriais (α,δ) para cartesianas (x,y,z)\"\n            ESCREVER \"2. Cartesianas (x,y,z) para equatoriais (α,δ)\"\n            ESCREVER \"3. Eclípticas para equatoriais\"\n            LER tipo_conversao\n            \n            SE tipo_conversao = 1 ENTÃO\n                ESCREVER \"Digite a ascensão reta α (horas):\"\n                LER ascensao_reta_horas\n                ESCREVER \"Digite a declinação δ (graus):\"\n                LER declinacao_graus\n                ESCREVER \"Digite a distância (UA):\"\n                LER distancia\n                \n                SE distancia &gt; 0 ENTÃO\n                    x_coord, y_coord, z_coord ← converterCoordenadas(ascensao_reta_horas, declinacao_graus, distancia, 1)\n                    \n                    ESCREVER \"Coordenadas equatoriais:\"\n                    ESCREVER \"α =\", ascensao_reta_horas, \"h\"\n                    ESCREVER \"δ =\", declinacao_graus, \"°\"\n                    ESCREVER \"Coordenadas cartesianas:\"\n                    ESCREVER \"x =\", x_coord, \"UA\"\n                    ESCREVER \"y =\", y_coord, \"UA\"\n                    ESCREVER \"z =\", z_coord, \"UA\"\n                SENÃO\n                    ESCREVER \"Distância deve ser positiva\"\n                FIM SE\n                \n            SENÃO SE tipo_conversao = 2 ENTÃO\n                ESCREVER \"Digite a coordenada x (UA):\"\n                LER x_coord\n                ESCREVER \"Digite a coordenada y (UA):\"\n                LER y_coord\n                ESCREVER \"Digite a coordenada z (UA):\"\n                LER z_coord\n                \n                ascensao_reta, declinacao, distancia ← converterCoordenadas(x_coord, y_coord, z_coord, 2)\n                \n                ESCREVER \"Coordenadas cartesianas:\"\n                ESCREVER \"x =\", x_coord, \"UA\"\n                ESCREVER \"y =\", y_coord, \"UA\"\n                ESCREVER \"z =\", z_coord, \"UA\"\n                ESCREVER \"Coordenadas equatoriais:\"\n                ESCREVER \"α =\", ascensao_reta, \"h\"\n                ESCREVER \"δ =\", declinacao, \"°\"\n                ESCREVER \"Distância =\", distancia, \"UA\"\n                \n            SENÃO SE tipo_conversao = 3 ENTÃO\n                ESCREVER \"Digite a longitude eclíptica (graus):\"\n                LER longitude_ecl\n                ESCREVER \"Digite a latitude eclíptica (graus):\"\n                LER latitude_ecl\n                \n                obliquidade ← 23.43929  // Obliquidade da eclíptica\n                \n                // Conversão eclíptica para equatorial\n                long_rad ← longitude_ecl * PI / 180\n                lat_rad ← latitude_ecl * PI / 180\n                obl_rad ← obliquidade * PI / 180\n                \n                ascensao_reta_rad ← atan2(sin(long_rad) * cos(obl_rad) - tan(lat_rad) * sin(obl_rad), cos(long_rad))\n                declinacao_rad ← asin(sin(lat_rad) * cos(obl_rad) + cos(lat_rad) * sin(obl_rad) * sin(long_rad))\n                \n                ascensao_reta_final ← ascensao_reta_rad * 180 / PI / 15  // Converter para horas\n                declinacao_final ← declinacao_rad * 180 / PI\n                \n                SE ascensao_reta_final &lt; 0 ENTÃO\n                    ascensao_reta_final ← ascensao_reta_final + 24\n                FIM SE\n                \n                ESCREVER \"Coordenadas eclípticas:\"\n                ESCREVER \"Longitude =\", longitude_ecl, \"°\"\n                ESCREVER \"Latitude =\", latitude_ecl, \"°\"\n                ESCREVER \"Coordenadas equatoriais:\"\n                ESCREVER \"α =\", ascensao_reta_final, \"h\"\n                ESCREVER \"δ =\", declinacao_final, \"°\"\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 4 ENTÃO\n            ESCREVER \"=== ANÁLISE COMPLETA DE MISSÃO ESPACIAL ===\"\n            ESCREVER \"Digite o planeta de destino (1=Marte, 2=Júpiter, 3=Saturno):\"\n            LER planeta_destino\n            ESCREVER \"Digite a massa da espaçonave (kg):\"\n            LER massa_nave\n            \n            SE planeta_destino &gt;= 1 E planeta_destino &lt;= 3 E massa_nave &gt; 0 ENTÃO\n                ESCREVER \"\\n--- PARÂMETROS DO DESTINO ---\"\n                \n                // Definir parâmetros planetários\n                SE planeta_destino = 1 ENTÃO\n                    // Marte\n                    nome_planeta ← \"Marte\"\n                    semi_eixo_planeta ← 1.52\n                    excentricidade_planeta ← 0.0934\n                    periodo_planeta ← 687\n                    massa_planeta ← 6.39e23\n                    raio_planeta ← 3389.5e3\n                    \n                SENÃO SE planeta_destino = 2 ENTÃO\n                    // Júpiter\n                    nome_planeta ← \"Júpiter\"\n                    semi_eixo_planeta ← 5.20\n                    excentricidade_planeta ← 0.0489\n                    periodo_planeta ← 4333\n                    massa_planeta ← 1.898e27\n                    raio_planeta ← 69911e3\n                    \n                SENÃO\n                    // Saturno\n                    nome_planeta ← \"Saturno\"\n                    semi_eixo_planeta ← 9.54\n                    excentricidade_planeta ← 0.0565\n                    periodo_planeta ← 10759\n                    massa_planeta ← 5.683e26\n                    raio_planeta ← 58232e3\n                FIM SE\n                \n                ESCREVER \"Destino:\", nome_planeta\n                ESCREVER \"Semi-eixo maior:\", semi_eixo_planeta, \"UA\"\n                ESCREVER \"Período orbital:\", periodo_planeta, \"dias\"\n                \n                ESCREVER \"\\n--- CÁLCULOS DE TRAJETÓRIA ---\"\n                \n                // Calcular transferência de Hohmann\n                semi_eixo_transferencia ← (1.0 + semi_eixo_planeta) / 2\n                periodo_transferencia ← sqrt(pow(semi_eixo_transferencia, 3)) * 365.25\n                tempo_viagem ← periodo_transferencia / 2\n                \n                ESCREVER \"Semi-eixo da órbita de transferência:\", semi_eixo_transferencia, \"UA\"\n                ESCREVER \"Tempo de viagem:\", tempo_viagem, \"dias\"\n                \n                // Velocidades características\n                v_terra_orbital ← 29.78  // km/s\n                v_escape_terra ← 11.2    // km/s\n                \n                // Velocidade no afélio da transferência\n                a_transf_metros ← semi_eixo_transferencia * UA\n                r_destino_metros ← semi_eixo_planeta * UA\n                v_chegada ← sqrt(MU_SOL * (2 / r_destino_metros - 1 / a_transf_metros))\n                v_chegada_kms ← v_chegada / 1000\n                \n                ESCREVER \"Velocidade de chegada:\", v_chegada_kms, \"km/s\"\n                \n                // Delta-V total\n                delta_v_partida ← v_escape_terra + 3.6  // 3.6 km/s para escape da órbita terrestre\n                delta_v_chegada ← fabs(v_chegada_kms - semi_eixo_planeta * 6.28)  // Aproximação\n                delta_v_missao ← delta_v_partida + delta_v_chegada\n                \n                ESCREVER \"Delta-V de partida:\", delta_v_partida, \"km/s\"\n                ESCREVER \"Delta-V de chegada:\", delta_v_chegada, \"km/s\"\n                ESCREVER \"Delta-V total da missão:\", delta_v_missao, \"km/s\"\n                \n                ESCREVER \"\\n--- ANÁLISE ENERGÉTICA ---\"\n                \n                // Energia específica\n                energia_especifica ← pow(delta_v_missao * 1000, 2) / 2  // J/kg\n                energia_total ← energia_especifica * massa_nave / 1e9   // GJ\n                \n                ESCREVER \"Energia específica:\", energia_especifica / 1e6, \"MJ/kg\"\n                ESCREVER \"Energia total necessária:\", energia_total, \"GJ\"\n                \n                // Período sinódico para próxima oportunidade\n                periodo_sinodico_calc ← fabs(365.25 * periodo_planeta / (periodo_planeta - 365.25))\n                ESCREVER \"Próxima janela em:\", periodo_sinodico_calc, \"dias\"\n                \n            SENÃO\n                ESCREVER \"Parâmetros inválidos\"\n            FIM SE\n            \n        SENÃO SE opcao = 5 ENTÃO\n            ESCREVER \"=== CONVERSÕES ASTRONÔMICAS ===\"\n            ESCREVER \"1. Anos-luz para UA e parsecs\"\n            ESCREVER \"2. Magnitudes estelares\"\n            ESCREVER \"3. Tempos astronômicos\"\n            LER tipo_conversao_astro\n            \n            SE tipo_conversao_astro = 1 ENTÃO\n                ESCREVER \"Digite a distância em anos-luz:\"\n                LER anos_luz\n                \n                SE anos_luz &gt; 0 ENTÃO\n                    ua_equiv ← anos_luz * 63241.1  // 1 ano-luz = 63241.1 UA\n                    parsecs ← anos_luz / 3.26156   // 1 parsec = 3.26156 anos-luz\n                    \n                    ESCREVER anos_luz, \"anos-luz =\"\n                    ESCREVER \"  \", ua_equiv, \"UA\"\n                    ESCREVER \"  \", parsecs, \"parsecs\"\n                SENÃO\n                    ESCREVER \"Distância deve ser positiva\"\n                FIM SE\n                \n            SENÃO SE tipo_conversao_astro = 2 ENTÃO\n                ESCREVER \"Digite a magnitude aparente:\"\n                LER mag_aparente\n                ESCREVER \"Digite a distância em parsecs:\"\n                LER distancia_pc\n                \n                SE distancia_pc &gt; 0 ENTÃO\n                    modulo_distancia ← 5 * log10(distancia_pc) - 5\n                    magnitude_absoluta ← mag_aparente - modulo_distancia\n                    \n                    ESCREVER \"Magnitude aparente:\", mag_aparente\n                    ESCREVER \"Módulo de distância:\", modulo_distancia\n                    ESCREVER \"Magnitude absoluta:\", magnitude_absoluta\n                SENÃO\n                    ESCREVER \"Distância deve ser positiva\"\n                FIM SE\n                \n            SENÃO SE tipo_conversao_astro = 3 ENTÃO\n                ESCREVER \"Digite o tempo em dias julianos:\"\n                LER dias_julianos\n                \n                // Converter para anos desde J2000\n                anos_j2000 ← (dias_julianos - 2451545.0) / 365.25\n                \n                ESCREVER \"Dias julianos:\", dias_julianos\n                ESCREVER \"Anos desde J2000.0:\", anos_j2000\n                \n                // Equinócio vernal aproximado\n                equinocio ← fmod(anos_j2000, 1.0) * 365.25\n                SE equinocio &lt; 0 ENTÃO equinocio ← equinocio + 365.25 FIM SE\n                \n                ESCREVER \"Dia do ano aproximado:\", equinocio\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 6 ENTÃO\n            ESCREVER \"Encerrando sistema de observatório astronômico...\"\n            \n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n        \n        // Pausa para visualização\n        SE opcao ≠ 6 ENTÃO\n            ESCREVER \"\\nPressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n// FUNÇÃO: CALCULAR POSIÇÃO ORBITAL\n// Resolve equação de Kepler: M = E - e*sin(E)\nFUNÇÃO calcularPosicaoOrbital(semi_eixo: real, excentricidade: real, anomalia_media_graus: real, inclinacao_graus: real): real\nINÍCIO\n    PI ← 3.14159265359\n    \n    // Converter anomalia média para radianos\n    anomalia_media_rad ← anomalia_media_graus * PI / 180\n    \n    // Resolver equação de Kepler iterativamente\n    anomalia_excentrica ← anomalia_media_rad  // Estimativa inicial\n    \n    PARA i DE 1 ATÉ 10 FAÇA\n        anomalia_excentrica_nova ← anomalia_media_rad + excentricidade * sin(anomalia_excentrica)\n        \n        // Verificar convergência\n        diferenca ← fabs(anomalia_excentrica_nova - anomalia_excentrica)\n        SE diferenca &lt; 1e-8 ENTÃO\n            PARE\n        FIM SE\n        \n        anomalia_excentrica ← anomalia_excentrica_nova\n    FIM PARA\n    \n    // Calcular distância heliocêntrica\n    distancia_heliocentrica ← semi_eixo * (1 - excentricidade * cos(anomalia_excentrica))\n    \n    RETORNAR distancia_heliocentrica\nFIM\n\n// FUNÇÃO: DETERMINAR JANELA DE LANÇAMENTO\n// Calcula tempo ótimo considerando mecânica orbital\nFUNÇÃO determinarJanelaLancamento(distancia_ua: real, velocidade_kms: real, periodo_sinodico: real): real\nINÍCIO\n    // Converter distância para metros e velocidade para m/s\n    UA ← 149597870700.0\n    distancia_metros ← distancia_ua * UA\n    velocidade_ms ← velocidade_kms * 1000\n    \n    // Tempo de viagem básico\n    tempo_viagem_segundos ← distancia_metros / velocidade_ms\n    tempo_viagem_dias ← tempo_viagem_segundos / 86400  // segundos por dia\n    \n    // Ajuste para órbita elíptica (transferência de Hohmann)\n    fator_correcao ← sqrt(2) * 0.5  // Aproximação para transferência elíptica\n    tempo_otimizado ← tempo_viagem_dias * fator_correcao\n    \n    // Considerar período sinódico para janela\n    SE tempo_otimizado &gt; periodo_sinodico / 2 ENTÃO\n        tempo_otimizado ← periodo_sinodico / 2\n    FIM SE\n    \n    RETORNAR tempo_otimizado\nFIM\n\n// FUNÇÃO: CONVERTER COORDENADAS\n// Tipo 1: (α,δ,r) -&gt; (x,y,z)\n// Tipo 2: (x,y,z) -&gt; (α,δ,r)\nFUNÇÃO converterCoordenadas(param1: real, param2: real, param3: real, tipo: inteiro): real, real, real\nINÍCIO\n    PI ← 3.14159265359\n    \n    SE tipo = 1 ENTÃO\n        // Equatoriais para cartesianas\n        ascensao_reta_horas ← param1\n        declinacao_graus ← param2\n        distancia ← param3\n        \n        // Converter para radianos\n        alpha_rad ← ascensao_reta_horas * 15 * PI / 180  // 15°/hora\n        delta_rad ← declinacao_graus * PI / 180\n        \n        // Coordenadas cartesianas\n        x ← distancia * cos(delta_rad) * cos(alpha_rad)\n        y ← distancia * cos(delta_rad) * sin(alpha_rad)\n        z ← distancia * sin(delta_rad)\n        \n        RETORNAR x, y, z\n        \n    SENÃO SE tipo = 2 ENTÃO\n        // Cartesianas para equatoriais\n        x ← param1\n        y ← param2\n        z ← param3\n        \n        // Distância\n        distancia ← sqrt(x * x + y * y + z * z)\n        \n        // Ascensão reta\n        alpha_rad ← atan2(y, x)\n        SE alpha_rad &lt; 0 ENTÃO\n            alpha_rad ← alpha_rad + 2 * PI\n        FIM SE\n        ascensao_reta_horas ← alpha_rad * 180 / PI / 15\n        \n        // Declinação\n        delta_rad ← asin(z / distancia)\n        declinacao_graus ← delta_rad * 180 / PI\n        \n        RETORNAR ascensao_reta_horas, declinacao_graus, distancia\n        \n    SENÃO\n        RETORNAR 0, 0, 0\n    FIM SE\nFIM\nA partir desse pseudocódigo, podemos implementar o código em C++ que está disponível em https://onlinegdb.com/acME7DYnz.\nG2: Um laboratório farmacêutico precisa de um sistema para análise estatística de dados experimentais, cálculo de concentrações moleculares e modelagem farmacocinética. O sistema deve processar dados sequencialmente, calcular estatísticas descritivas (como média, \\(\\mu\\), e desvio padrão, \\(\\sigma\\)) e determinar parâmetros de absorção/eliminação de medicamentos.\nFunções a implementar: - Funções próprias: calcularEstatisticas(), modelarFarmacocinetica(), determinarBioequivalencia() - Funções padrão: exp(), log(), pow(), sqrt(), fabs(), floor(), ceil()\nEntrada: Concentrações sanguíneas sequenciais (\\(C\\)), tempos de coleta (\\(t\\)), doses administradas (\\(Dose\\)). Saída: Média (\\(\\mu\\)), desvio padrão (\\(\\sigma\\)), meia-vida (\\(t_{1/2}\\)), clearance (\\(CL\\)), área sob a curva (\\(AUC\\)), resultado de bioequivalência.\nCálculos específicos:\n\nModelo monocompartimental, no qual \\(C(t)\\) é a concentração no tempo \\(t\\), \\(C_0\\) é a concentração inicial e \\(k\\) é a constante de eliminação: \\[C(t) = C_0 \\cdot e^{-k \\cdot t}\\]\nÁrea Sob a Curva (\\(AUC\\)), calculada numericamente (e.g., pela regra dos trapézios): \\[AUC = \\int_{0}^{\\infty} C(t) \\, dt\\]\nClearance (\\(CL\\)), ou depuração, que relaciona a dose com a área sob a curva: \\[CL = \\frac{Dose}{AUC}\\]\nEstatísticas calculadas sequencialmente (sem o uso de arrays para armazenamento completo dos dados).\n\nSolução:\nPrimeiro o pseudocódigo para a função de cálculo de estatísticas e farmacocinética:\nALGORITMO SistemaLaboratorioFarmaceutico\n\nENTRADA:\n    concentracoes, tempos, doses: real\n\nSAÍDA:\n    media, desvio_padrao, meia_vida, clearance, auc, bioequivalencia: real\n\nINÍCIO\n    opcao ← 0\n    \n    ENQUANTO opcao ≠ 6 FAÇA\n        \n        // BLOCO: APRESENTAR MENU PRINCIPAL\n        \n        ESCREVER \"=== SISTEMA DE LABORATÓRIO FARMACÊUTICO ===\"\n        ESCREVER \"1. Calcular estatísticas descritivas\"\n        ESCREVER \"2. Modelar farmacocinética\"\n        ESCREVER \"3. Determinar bioequivalência\"\n        ESCREVER \"4. Análise completa de medicamento\"\n        ESCREVER \"5. Cálculos auxiliares\"\n        ESCREVER \"6. Sair\"\n        ESCREVER \"Escolha uma opção:\"\n        LER opcao\n        \n        \n        // BLOCO: PROCESSAR OPÇÃO ESCOLHIDA\n        \n        SE opcao = 1 ENTÃO\n            ESCREVER \"=== CÁLCULO DE ESTATÍSTICAS DESCRITIVAS ===\"\n            ESCREVER \"Quantos dados você tem (2-20):\"\n            LER num_dados\n            \n            SE num_dados &gt;= 2 E num_dados &lt;= 20 ENTÃO\n                media, desvio_padrao ← calcularEstatisticas(num_dados)\n                \n                ESCREVER \"Número de amostras:\", num_dados\n                ESCREVER \"Média (μ):\", media\n                ESCREVER \"Desvio padrão (σ):\", desvio_padrao\n                ESCREVER \"Coeficiente de variação:\", (desvio_padrao / media) * 100, \"%\"\n                \n                // Classificação da variabilidade\n                cv ← (desvio_padrao / media) * 100\n                SE cv &lt;= 5 ENTÃO\n                    ESCREVER \"Variabilidade: Muito baixa (excelente)\"\n                SENÃO SE cv &lt;= 10 ENTÃO\n                    ESCREVER \"Variabilidade: Baixa (boa)\"\n                SENÃO SE cv &lt;= 20 ENTÃO\n                    ESCREVER \"Variabilidade: Moderada (aceitável)\"\n                SENÃO\n                    ESCREVER \"Variabilidade: Alta (revisar protocolo)\"\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Número de dados deve estar entre 2 e 20\"\n            FIM SE\n            \n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"=== MODELAGEM FARMACOCINÉTICA ===\"\n            ESCREVER \"Digite a concentração inicial C0 (mg/L):\"\n            LER c0\n            ESCREVER \"Digite a constante de eliminação k (/h):\"\n            LER k_eliminacao\n            ESCREVER \"Digite o tempo para análise (h):\"\n            LER tempo_analise\n            ESCREVER \"Digite a dose administrada (mg):\"\n            LER dose\n            \n            SE c0 &gt; 0 E k_eliminacao &gt; 0 E tempo_analise &gt; 0 E dose &gt; 0 ENTÃO\n                concentracao_tempo, meia_vida, auc, clearance ← modelarFarmacocinetica(c0, k_eliminacao, tempo_analise, dose)\n                \n                ESCREVER \"Concentração inicial C0:\", c0, \"mg/L\"\n                ESCREVER \"Constante de eliminação k:\", k_eliminacao, \"/h\"\n                ESCREVER \"Concentração em t =\", tempo_analise, \"h:\", concentracao_tempo, \"mg/L\"\n                ESCREVER \"Meia-vida (t½):\", meia_vida, \"h\"\n                ESCREVER \"AUC (0→∞):\", auc, \"mg⋅h/L\"\n                ESCREVER \"Clearance (CL):\", clearance, \"L/h\"\n                \n                // Análise da eliminação\n                percentual_eliminado ← (1 - concentracao_tempo / c0) * 100\n                ESCREVER \"Percentual eliminado em\", tempo_analise, \"h:\", percentual_eliminado, \"%\"\n                \n                // Tempo para concentração específica\n                ESCREVER \"Para atingir 10% da concentração inicial:\"\n                tempo_10_porcento ← -log(0.1) / k_eliminacao\n                ESCREVER \"Tempo necessário:\", tempo_10_porcento, \"h\"\n                \n            SENÃO\n                ESCREVER \"Todos os valores devem ser positivos\"\n            FIM SE\n            \n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"=== DETERMINAÇÃO DE BIOEQUIVALÊNCIA ===\"\n            ESCREVER \"Dados do medicamento de referência:\"\n            ESCREVER \"Digite a AUC de referência (mg⋅h/L):\"\n            LER auc_referencia\n            ESCREVER \"Digite a Cmax de referência (mg/L):\"\n            LER cmax_referencia\n            \n            ESCREVER \"Dados do medicamento teste:\"\n            ESCREVER \"Digite a AUC do teste (mg⋅h/L):\"\n            LER auc_teste\n            ESCREVER \"Digite a Cmax do teste (mg/L):\"\n            LER cmax_teste\n            \n            SE auc_referencia &gt; 0 E cmax_referencia &gt; 0 E auc_teste &gt; 0 E cmax_teste &gt; 0 ENTÃO\n                bioequivalencia ← determinarBioequivalencia(auc_referencia, cmax_referencia, auc_teste, cmax_teste)\n                \n                razao_auc ← auc_teste / auc_referencia\n                razao_cmax ← cmax_teste / cmax_referencia\n                \n                ESCREVER \"Medicamento de referência:\"\n                ESCREVER \"  AUC:\", auc_referencia, \"mg⋅h/L\"\n                ESCREVER \"  Cmax:\", cmax_referencia, \"mg/L\"\n                \n                ESCREVER \"Medicamento teste:\"\n                ESCREVER \"  AUC:\", auc_teste, \"mg⋅h/L\"\n                ESCREVER \"  Cmax:\", cmax_teste, \"mg/L\"\n                \n                ESCREVER \"Razão AUC (teste/referência):\", razao_auc\n                ESCREVER \"Razão Cmax (teste/referência):\", razao_cmax\n                \n                SE bioequivalencia = 1 ENTÃO\n                    ESCREVER \"Resultado: BIOEQUIVALENTES\"\n                    ESCREVER \"Ambas as razões estão entre 0.80 e 1.25\"\n                SENÃO\n                    ESCREVER \"Resultado: NÃO BIOEQUIVALENTES\"\n                    SE razao_auc &lt; 0.8 OU razao_auc &gt; 1.25 ENTÃO\n                        ESCREVER \"AUC fora do intervalo 0.80-1.25\"\n                    FIM SE\n                    SE razao_cmax &lt; 0.8 OU razao_cmax &gt; 1.25 ENTÃO\n                        ESCREVER \"Cmax fora do intervalo 0.80-1.25\"\n                    FIM SE\n                FIM SE\n                \n            SENÃO\n                ESCREVER \"Todos os valores devem ser positivos\"\n            FIM SE\n            \n        SENÃO SE opcao = 4 ENTÃO\n            ESCREVER \"=== ANÁLISE COMPLETA DE MEDICAMENTO ===\"\n            ESCREVER \"Quantas amostras de concentração foram coletadas (3-10):\"\n            LER num_amostras\n            \n            SE num_amostras &gt;= 3 E num_amostras &lt;= 10 ENTÃO\n                ESCREVER \"Digite a dose administrada (mg):\"\n                LER dose_total\n                \n                SE dose_total &gt; 0 ENTÃO\n                    // Calcular estatísticas das concentrações\n                    media_concentracao, dp_concentracao ← calcularEstatisticas(num_amostras)\n                    \n                    ESCREVER \"Estimativa dos parâmetros farmacocinéticos:\"\n                    ESCREVER \"Digite a concentração inicial estimada C0 (mg/L):\"\n                    LER c0_estimado\n                    ESCREVER \"Digite a constante de eliminação estimada k (/h):\"\n                    LER k_estimado\n                    \n                    SE c0_estimado &gt; 0 E k_estimado &gt; 0 ENTÃO\n                        // Modelagem completa\n                        concentracao_24h, meia_vida_calc, auc_calc, clearance_calc ← modelarFarmacocinetica(c0_estimado, k_estimado, 24, dose_total)\n                        \n                        ESCREVER \"\\n--- ESTATÍSTICAS DESCRITIVAS ---\"\n                        ESCREVER \"Média das concentrações:\", media_concentracao, \"mg/L\"\n                        ESCREVER \"Desvio padrão:\", dp_concentracao, \"mg/L\"\n                        cv_total ← (dp_concentracao / media_concentracao) * 100\n                        ESCREVER \"Coeficiente de variação:\", cv_total, \"%\"\n                        \n                        ESCREVER \"\\n--- PARÂMETROS FARMACOCINÉTICOS ---\"\n                        ESCREVER \"Concentração inicial (C0):\", c0_estimado, \"mg/L\"\n                        ESCREVER \"Meia-vida (t½):\", meia_vida_calc, \"h\"\n                        ESCREVER \"AUC (0→∞):\", auc_calc, \"mg⋅h/L\"\n                        ESCREVER \"Clearance total:\", clearance_calc, \"L/h\"\n                        ESCREVER \"Volume de distribuição:\", dose_total / c0_estimado, \"L\"\n                        \n                        ESCREVER \"\\n--- PREDIÇÕES ---\"\n                        ESCREVER \"Concentração em 24h:\", concentracao_24h, \"mg/L\"\n                        \n                        // Tempo para diferentes frações\n                        tempo_50_porcento ← meia_vida_calc\n                        tempo_25_porcento ← 2 * meia_vida_calc\n                        tempo_12_5_porcento ← 3 * meia_vida_calc\n                        \n                        ESCREVER \"Tempo para 50% eliminação:\", tempo_50_porcento, \"h\"\n                        ESCREVER \"Tempo para 75% eliminação:\", tempo_25_porcento, \"h\"\n                        ESCREVER \"Tempo para 87.5% eliminação:\", tempo_12_5_porcento, \"h\"\n                        \n                        ESCREVER \"\\n--- CLASSIFICAÇÃO FARMACOCINÉTICA ---\"\n                        \n                        SE meia_vida_calc &lt; 6 ENTÃO\n                            ESCREVER \"Eliminação: Rápida (t½ &lt; 6h)\"\n                        SENÃO SE meia_vida_calc &lt; 24 ENTÃO\n                            ESCREVER \"Eliminação: Moderada (6h ≤ t½ &lt; 24h)\"\n                        SENÃO\n                            ESCREVER \"Eliminação: Lenta (t½ ≥ 24h)\"\n                        FIM SE\n                        \n                        SE clearance_calc &lt; 1 ENTÃO\n                            ESCREVER \"Clearance: Baixo (&lt; 1 L/h)\"\n                        SENÃO SE clearance_calc &lt; 10 ENTÃO\n                            ESCREVER \"Clearance: Moderado (1-10 L/h)\"\n                        SENÃO\n                            ESCREVER \"Clearance: Alto (&gt; 10 L/h)\"\n                        FIM SE\n                        \n                    SENÃO\n                        ESCREVER \"Parâmetros estimados devem ser positivos\"\n                    FIM SE\n                SENÃO\n                    ESCREVER \"Dose deve ser positiva\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Número de amostras deve estar entre 3 e 10\"\n            FIM SE\n            \n        SENÃO SE opcao = 5 ENTÃO\n            ESCREVER \"=== CÁLCULOS AUXILIARES ===\"\n            ESCREVER \"1. Converter unidades de concentração\"\n            ESCREVER \"2. Calcular dose por peso corporal\"\n            ESCREVER \"3. Funções matemáticas (exp, log, etc.)\"\n            LER tipo_calculo\n            \n            SE tipo_calculo = 1 ENTÃO\n                ESCREVER \"Digite a concentração em mg/L:\"\n                LER conc_mg_l\n                ESCREVER \"Digite o peso molecular (g/mol):\"\n                LER peso_molecular\n                \n                SE conc_mg_l &gt;= 0 E peso_molecular &gt; 0 ENTÃO\n                    // Converter mg/L para μM\n                    conc_micromolar ← (conc_mg_l * 1000) / peso_molecular\n                    ESCREVER conc_mg_l, \"mg/L =\", conc_micromolar, \"μM\"\n                    \n                    // Converter para outras unidades\n                    conc_ng_ml ← conc_mg_l * 1000\n                    conc_g_dl ← conc_mg_l / 10\n                    \n                    ESCREVER \"Equivalências:\"\n                    ESCREVER \"  \", conc_ng_ml, \"ng/mL\"\n                    ESCREVER \"  \", conc_g_dl, \"μg/dL\"\n                SENÃO\n                    ESCREVER \"Valores devem ser não negativos\"\n                FIM SE\n                \n            SENÃO SE tipo_calculo = 2 ENTÃO\n                ESCREVER \"Digite a dose total (mg):\"\n                LER dose_mg\n                ESCREVER \"Digite o peso corporal (kg):\"\n                LER peso_kg\n                \n                SE dose_mg &gt; 0 E peso_kg &gt; 0 ENTÃO\n                    dose_por_kg ← dose_mg / peso_kg\n                    ESCREVER \"Dose por peso corporal:\", dose_por_kg, \"mg/kg\"\n                    \n                    // Classificação pediátrica vs adulto\n                    SE peso_kg &lt; 20 ENTÃO\n                        ESCREVER \"Classificação: Dose pediátrica\"\n                    SENÃO SE peso_kg &lt; 80 ENTÃO\n                        ESCREVER \"Classificação: Dose adulto padrão\"\n                    SENÃO\n                        ESCREVER \"Classificação: Dose para peso elevado\"\n                    FIM SE\n                SENÃO\n                    ESCREVER \"Valores devem ser positivos\"\n                FIM SE\n                \n            SENÃO SE tipo_calculo = 3 ENTÃO\n                ESCREVER \"Digite um valor para testar funções matemáticas:\"\n                LER valor\n                \n                SE valor &gt; 0 ENTÃO\n                    resultado_exp ← exp(valor)\n                    resultado_log ← log(valor)\n                    resultado_sqrt ← sqrt(valor)\n                    resultado_floor ← floor(valor)\n                    resultado_ceil ← ceil(valor)\n                    \n                    ESCREVER \"Para x =\", valor, \":\"\n                    ESCREVER \"exp(x) =\", resultado_exp\n                    ESCREVER \"ln(x) =\", resultado_log\n                    ESCREVER \"sqrt(x) =\", resultado_sqrt\n                    ESCREVER \"floor(x) =\", resultado_floor\n                    ESCREVER \"ceil(x) =\", resultado_ceil\n                    \n                    SE valor &lt;= 10 ENTÃO\n                        potencia_2 ← pow(valor, 2)\n                        potencia_3 ← pow(valor, 3)\n                        ESCREVER \"x² =\", potencia_2\n                        ESCREVER \"x³ =\", potencia_3\n                    FIM SE\n                SENÃO\n                    ESCREVER \"Valor deve ser positivo para logaritmo\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Opção inválida\"\n            FIM SE\n            \n        SENÃO SE opcao = 6 ENTÃO\n            ESCREVER \"Encerrando sistema de laboratório farmacêutico...\"\n            \n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n        \n        // Pausa para visualização\n        SE opcao ≠ 6 ENTÃO\n            ESCREVER \"\\nPressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    FIM ENQUANTO\nFIM\n\n// FUNÇÃO: CALCULAR ESTATÍSTICAS\n// Processamento sequencial sem arrays\nFUNÇÃO calcularEstatisticas(n: inteiro): real, real\nINÍCIO\n    soma ← 0\n    soma_quadrados ← 0\n    \n    // Primeira passagem: calcular média\n    PARA i DE 1 ATÉ n FAÇA\n        ESCREVER \"Digite o valor\", i, \":\"\n        LER valor\n        soma ← soma + valor\n    FIM PARA\n    \n    media ← soma / n\n    \n    // Segunda passagem: calcular desvio padrão\n    ESCREVER \"Agora digite os valores novamente para calcular o desvio padrão:\"\n    PARA i DE 1 ATÉ n FAÇA\n        ESCREVER \"Digite novamente o valor\", i, \":\"\n        LER valor\n        diferenca ← valor - media\n        quadrado_diferenca ← pow(diferenca, 2)\n        soma_quadrados ← soma_quadrados + quadrado_diferenca\n    FIM PARA\n    \n    variancia ← soma_quadrados / (n - 1)\n    desvio_padrao ← sqrt(variancia)\n    \n    RETORNAR media, desvio_padrao\nFIM\n\n// FUNÇÃO: MODELAR FARMACOCINÉTICA\n// C(t) = C0 × e^(-kt)\nFUNÇÃO modelarFarmacocinetica(c0: real, k: real, tempo: real, dose: real): real, real, real, real\nINÍCIO\n    // Concentração no tempo t: C(t) = C0 × e^(-kt)\n    concentracao_t ← c0 * exp(-k * tempo)\n    \n    // Meia-vida: t½ = ln(2) / k\n    meia_vida ← log(2) / k\n    \n    // AUC (0→∞): AUC = C0 / k\n    auc ← c0 / k\n    \n    // Clearance: CL = Dose / AUC\n    clearance ← dose / auc\n    \n    RETORNAR concentracao_t, meia_vida, auc, clearance\nFIM\n\n// FUNÇÃO: DETERMINAR BIOEQUIVALÊNCIA\n// Critérios: 0.80 ≤ razão ≤ 1.25 para AUC e Cmax\nFUNÇÃO determinarBioequivalencia(auc_ref: real, cmax_ref: real, auc_teste: real, cmax_teste: real): inteiro\nINÍCIO\n    // Calcular razões\n    razao_auc ← auc_teste / auc_ref\n    razao_cmax ← cmax_teste / cmax_ref\n    \n    // Verificar critérios de bioequivalência\n    auc_ok ← (razao_auc &gt;= 0.80) E (razao_auc &lt;= 1.25)\n    cmax_ok ← (razao_cmax &gt;= 0.80) E (razao_cmax &lt;= 1.25)\n    \n    // Retornar 1 se bioequivalente, 0 se não\n    SE auc_ok E cmax_ok ENTÃO\n        RETORNAR 1\n    SENÃO\n        RETORNAR 0\n    FIM SE\nFIM\nO pseudocódigo proposto pode ser representado pelo código disponível em https://onlinegdb.com/ayWgb_nfH.\nNota: O professor pode adaptar os exercícios para incluir mais funções ou módulos, dependendo do nível de conhecimento dos alunos e do tempo disponível. O Exercício G2 é uma boa oportunidade para o professor introduzir estruturas de dados complexas, pares e vetores por exemplo.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>**Módulo 2**: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span>"
    ]
  },
  {
    "objectID": "desenv2.html#decomposição-e-abstração-estruturas-de-dados-compostas",
    "href": "desenv2.html#decomposição-e-abstração-estruturas-de-dados-compostas",
    "title": "7  Módulo 2: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões",
    "section": "7.2 Decomposição e Abstração: Estruturas de Dados Compostas",
    "text": "7.2 Decomposição e Abstração: Estruturas de Dados Compostas\nAo completar o exercício G2, os alunos devem estar prontos para desafios mais complexos que envolvem estruturas de dados compostas, como arrays, vetores, strings, tuplas e registros. Que completam o conhecimento básico de manipulação de dados. As abstrações representadas por estas estruturas tem impacto além dos cursos de Ciência e Engenharia da Computação.\nNesta seção, serão usadas as funções, métodos e módulos que são relacinados a leitura e gravação de arquivos. Novamente, o professor deve escolhar ente usar a Técnica da Sequência de Fibonacci, ou a sua própria metodologia. Considerando que a Técnica da Sequência de Fibonacci é uma possibilidade, a seguir estão explicitados \\(7\\) exercícios (1, 1, 2, 3).\nFinalmente, neste ponto da disciplina, o aluno já será capaz de ler código e entender o algoritmo que ele representa. Deste ponto em diante, os exercícios serão mais desafiadores. Porém, os eventuas fluxograms, ou pseudocódigos, serão deixados para o professor e seus alunos, de acordo com a capacidade e evolução de cada turma.\nOs exercícios são mais desafiadores e, consequentemente mais demorados, o professor pode sugerir que eles sejam realizados em grupos e, neste caso, cabe ao professor dividir os exerícios em módulos que possam ser implementados separadamente. A divisão em módulos é uma boa prática de programação, que ajuda a organizar o código e facilita a manutenção. Além disso, serve como prática de Depuração e engenharia de software. Nos exercícios a seguir serão considerados grupos de 4 alunos.\nEstratégia de Apresentação: O professor pode dividir a turma em grupos de 4 alunos, apresentar o problema e solicitar que seja criado um fluxograma para a solução. O problema H2 deve ser usado para apresentar uma estratégia de Decomposição. Todos os outros problemas devem ser apresentados, sem incluir qualquer estratégia de decomposição. É importante que os alunos mudem de personagem a cada exercício, para que todos tenham a oportunidade de praticar a leitura e escrita de código. Ou seja, a pessoa que ocupa a posição Aluno 1 no exercício H2 deve ser a Aluno 2 no exercício I2, e assim por diante.\n\n7.2.1 H2\nUma pequena biblioteca precisa gerenciar os empréstimos de livros, registrando o nome do usuário e a quantidade de dias do empréstimo. O programa deve usar um array para armazenar até 10 empréstimos, salvar os dados em disco e permitir consultas. Desenvolva um sistema que registre empréstimos, mantenha um histórico em um array e permita consultar todos os empréstimos ou os de um usuário específico.\nFunções a implementar:\n\nEstruturas de dados: Array para armazenar nomes e dias de empréstimo;\nFunções próprias: registrarEmprestimo(), salvarEmprestimos(), lerEmprestimos(), buscarEmprestimo();\nFunções padrão: getline(), stoi(), to_string();\n\nEntrada: Nome do usuário (string) e dias de empréstimo (inteiro, \\(1\\) a \\(30\\)) Saída: Lista de todos os empréstimos ou empréstimos de um usuário específico, com média dos dias de empréstimo\n\n7.2.1.1 Algoritmização: Pseudocódigo e Código\nO pseudocódigo para esta tarefa pode ser:\nALGORITMO GerenciadorEmprestimos\n\n    // Constantes\n    MAX_EMPRESTIMOS ← 10\n    ARQUIVO ← \"empréstimos.csv\"\n\n    // Declaração de arrays\n    nomes[MAX_EMPRESTIMOS]: string\n    dias[MAX_EMPRESTIMOS]: inteiro\n    quantidade: inteiro\n\nINÍCIO\n    // Inicializar sistema\n    ESCREVER \"=== Sistema de Empréstimos de Livros ===\"\n    ESCREVER \"Inicializando sistema...\"\n    inicializarArquivo()\n\n    // Carregar dados existentes\n    lerEmprestimos(nomes, dias, quantidade)\n\n    FAÇA\n        exibirMenu()\n        ESCREVER \"Escolha uma opção: \"\n        LER opcao\n\n        SE opcao = 1 ENTÃO\n            registrarEmprestimo(nomes, dias, quantidade)\n            salvarEmprestimos(nomes, dias, quantidade)\n            ESCREVER quantidade, \" empréstimos registrados.\"\n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite o nome do usuário para busca: \"\n            LER nome\n            buscarEmprestimo(nome)\n        SENÃO SE opcao = 3 ENTÃO\n            nomesTemp[MAX_EMPRESTIMOS]: string\n            diasTemp[MAX_EMPRESTIMOS]: inteiro\n            totalRegistros: inteiro\n            SE lerEmprestimos(nomesTemp, diasTemp, totalRegistros) = FALSO ENTÃO\n                ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n            SENÃO\n                SE totalRegistros = 0 ENTÃO\n                    ESCREVER \"Nenhum registro encontrado!\"\n                SENÃO\n                    ESCREVER \"=== RELATÓRIO COMPLETO ===\"\n                    soma ← 0.0\n                    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n                        ESCREVER \"Usuário: \", nomesTemp[i], \", Dias: \", diasTemp[i]\n                        soma ← soma + diasTemp[i]\n                    FIM PARA\n                    ESCREVER \"Total de empréstimos: \", totalRegistros\n                    ESCREVER \"Média dos dias: \", soma / totalRegistros\n                FIM SE\n            FIM SE\n        SENÃO SE opcao = 0 ENTÃO\n            ESCREVER \"Encerrando sistema...\"\n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n\n        SE opcao ≠ 0 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    ENQUANTO opcao ≠ 0\n\nFIM\n\nFUNÇÃO registrarEmprestimo(nomes: string[], dias: inteiro[], quantidade: inteiro): void\nINÍCIO\n    SE quantidade ≥ MAX_EMPRESTIMOS ENTÃO\n        ESCREVER \"Limite de empréstimos atingido!\"\n        RETORNAR\n    FIM SE\n\n    FAÇA\n        ESCREVER \"Digite o nome do usuário (ou 'sair' para encerrar): \"\n        LER nome\n        SE nome = \"sair\" ENTÃO\n            RETORNAR\n        FIM SE\n\n        SE nome = \"\" OU nome CONTER \",\" ENTÃO\n            ESCREVER \"Nome inválido! Deve ser não vazio e sem vírgulas.\"\n            CONTINUAR\n        FIM SE\n\n        ESCREVER \"Digite a quantidade de dias (1-30): \"\n        LER entrada\n        TENTAR\n            dia ← CONVERTER_PARA_INTEIRO(entrada)\n            SE dia ≥ 1 E dia ≤ 30 ENTÃO\n                nomes[quantidade] ← nome\n                dias[quantidade] ← dia\n                quantidade ← quantidade + 1\n                SE quantidade = MAX_EMPRESTIMOS ENTÃO\n                    ESCREVER \"Limite de empréstimos atingido!\"\n                    RETORNAR\n                FIM SE\n            SENÃO\n                ESCREVER \"Dias fora do intervalo (1-30). Ignorado.\"\n            FIM SE\n        SENÃO\n            ESCREVER \"Valor inválido para dias. Ignorado.\"\n        FIM TENTAR\n    ENQUANTO VERDADEIRO\nFIM\n\nFUNÇÃO salvarEmprestimos(nomes: string[], dias: inteiro[], quantidade: inteiro): void\nINÍCIO\n    ABRIR arquivo(ARQUIVO, SOBRESCREVER)\n    SE arquivo NÃO ABERTO ENTÃO\n        ESCREVER \"Erro ao abrir arquivo para gravação!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER_ARQUIVO(arquivo, \"Nome,Dias\")\n    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n        ESCREVER_ARQUIVO(arquivo, nomes[i], \",\", dias[i])\n    FIM PARA\n    FECHAR arquivo\nFIM\n\nFUNÇÃO lerEmprestimos(nomes: string[], dias: inteiro[], quantidade: inteiro, nomeFiltro: string = \"\"): booleano\nINÍCIO\n    ABRIR arquivo(ARQUIVO, LEITURA)\n    SE arquivo NÃO ABERTO ENTÃO\n        RETORNAR FALSO\n    FIM SE\n\n    quantidade ← 0\n    LER_LINHA(arquivo, linha)\n    SE linha CONTER \"Nome\" ENTÃO\n        // Cabeçalho detectado\n    SENÃO\n        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)\n    FIM SE\n\n    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_EMPRESTIMOS FAÇA\n        SEPARAR(linha, \",\", nome, diasStr)\n        SE nomeFiltro = \"\" OU nome = nomeFiltro ENTÃO\n            TENTAR\n                dias[quantidade] ← CONVERTER_PARA_INTEIRO(diasStr)\n                nomes[quantidade] ← nome\n                quantidade ← quantidade + 1\n            SENÃO\n                // Ignorar linhas inválidas\n            FIM TENTAR\n        FIM SE\n    FIM ENQUANTO\n\n    SE quantidade = MAX_EMPRESTIMOS E MAIS_LINHAS(arquivo) ENTÃO\n        ESCREVER \"Aviso: Mais registros no arquivo do que o limite de \", MAX_EMPRESTIMOS\n    FIM SE\n\n    FECHAR arquivo\n    RETORNAR VERDADEIRO\nFIM\n\nFUNÇÃO buscarEmprestimo(nome: string): void\nINÍCIO\n    nomes[MAX_EMPRESTIMOS]: string\n    dias[MAX_EMPRESTIMOS]: inteiro\n    totalRegistros: inteiro\n\n    SE lerEmprestimos(nomes, dias, totalRegistros, nome) = FALSO ENTÃO\n        ESCREVER \"Erro ao ler dados!\"\n        RETORNAR\n    FIM SE\n\n    SE totalRegistros = 0 ENTÃO\n        ESCREVER \"Nenhum empréstimo encontrado para \", nome, \"!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER \"=== EMPRÉSTIMOS DE \", nome, \" ===\"\n    soma ← 0.0\n    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n        ESCREVER \"Usuário: \", nomes[i], \", Dias: \", dias[i]\n        soma ← soma + dias[i]\n    FIM PARA\n    ESCREVER \"Total de empréstimos: \", totalRegistros\n    ESCREVER \"Média dos dias: \", soma / totalRegistros\nFIM\n\nFUNÇÃO inicializarArquivo(): void\nINÍCIO\n    SE ARQUIVO NÃO EXISTIR ENTÃO\n        ABRIR arquivo(ARQUIVO, ESCRITA)\n        SE arquivo ABERTO ENTÃO\n            ESCREVER_ARQUIVO(arquivo, \"Nome,Dias\")\n            FECHAR arquivo\n            ESCREVER \"Arquivo de dados criado: \", ARQUIVO\n        SENÃO\n            ESCREVER \"Erro ao criar arquivo de dados!\"\n        FIM SE\n    SENÃO\n        ESCREVER \"Arquivo de dados encontrado: \", ARQUIVO\n    FIM SE\nFIM\n\nFUNÇÃO exibirMenu(): void\nINÍCIO\n    ESCREVER \"=== MENU PRINCIPAL ===\"\n    ESCREVER \"1. Registrar empréstimos\"\n    ESCREVER \"2. Buscar empréstimos por usuário\"\n    ESCREVER \"3. Relatório completo\"\n    ESCREVER \"0. Sair\"\nFIM\n\n\n7.2.1.2 Decomposição: Divisão de Tarefas para o Problema H2\nPara resolver o problema H2 de gerenciamento de empréstimos de livros, o trabalho pode ser dividido entre quatro alunos que trabalharão independentemente na mesma sala, sem sistema de controle de versão, durante o mesmo período de tempo. Cada aluno será responsável por uma parte específica do sistema, com interfaces claras para facilitar a integração final. Abaixo está a divisão das tarefas, considerando as funções solicitadas (registrarEmprestimo, salvarEmprestimos, lerEmprestimos, buscarEmprestimo).\nAluno 1: Função registrarEmprestimo e Validação de Entrada\nResponsabilidades: implementar registrarEmprestimo(std::string nomes[], int dias[], int& quantidade) para coletar nome do usuário e dias de empréstimo (\\(1\\) a \\(30\\)). Validar:\n\nNome não vazio e sem vírgulas (para evitar corromper o CSV);\nDias como inteiro entre \\(1\\) e \\(30\\), usando stoi com tratamento de exceções;\nNão zerar quantidade para preservar empréstimos anteriores no array.\n\nPermitir múltiplos empréstimos até MAX_EMPRESTIMOS (\\(10\\)) ou até o usuário digitar “sair”; Corrigir uso de std::cin.ignore para evitar problemas com o buffer. Ou o equivalente em Python.\nTarefas específicas:\n\nEscrever a função com entrada via getline para nome e dias;\nValidar nome (Ex.: if (nome.empty() || nome.find(',') != std::string::npos));\nAdicionar novos empréstimos a partir do índice quantidade, sem zerar o array;\nTestar isoladamente com entradas válidas e inválidas (Ex.: dias fora do intervalo, nomes com vírgulas).\n\nInterface:\nRecebe nomes[], dias[] e quantidade como parâmetros; Fornece dados válidos para salvarEmprestimos e consultas.\nAluno 2: Função salvarEmprestimos e Inicialização do Arquivo\nResponsabilidades:\n\nImplementar salvarEmprestimos(const std::string nomes[], const int dias[], int quantidade) para gravar empréstimos no arquivo emprestimos.csv;\nSobrescrever o arquivo (usando std::ios::trunc) para evitar duplicatas;\nImplementar inicializarArquivo() para criar o arquivo CSV com cabeçalho Nome,Dias se não existir;\nVerificar erros ao abrir/escrever no arquivo.\n\nTarefas específicas:\n\nGravar cada par nome,dias em uma linha do CSV, sobrescrevendo o arquivo;\nPreservar o cabeçalho ao sobrescrever;\nVerificar abertura do arquivo e exibir mensagens de erro;\nTestar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.\n\nInterface:\nRecebe nomes[], dias[] e quantidade de registrarEmprestimo; Produz um arquivo CSV lido por lerEmprestimos.\nAluno 3: Função lerEmprestimos e Carregamento Inicial\nResponsabilidades:\n\nImplementar lerEmprestimos(std::string nomes[], int dias[], int& quantidade, const std::string& nomeFiltro = \"\") para ler o arquivo CSV; Suportar leitura de todos os registros ou apenas os de um usuário (com nomeFiltro); Alertar se o arquivo tiver mais registros que MAX_EMPRESTIMOS; Carregar dados do arquivo no início do programa (no main) para sincronizar o array local.\n\nTarefas específicas:\n\nLer o CSV, ignorar o cabeçalho e preencher nomes e dias;\nImplementar filtragem por nomeFiltro quando não vazio;\nContar registros e alertar se exceder MAX_EMPRESTIMOS;\nModificar o main para chamar lerEmprestimos no início;\nTestar com arquivos CSV vazios, com menos de \\(10\\) registros e com mais de \\(10\\).\n\nInterface:\n\nLê o arquivo CSV de salvarEmprestimos;\nFornece dados para buscarEmprestimo e relatório completo.\n\nAluno 4: Função buscarEmprestimo, Relatório e Interface do Usuário\nResponsabilidades:\n\nImplementar buscarEmprestimo(const std::string& nome) para exibir empréstimos de um usuário e calcular a média dos dias;\nImplementar o relatório completo (opção \\(3\\) do menu) para listar todos os empréstimos e a média dos dias;\nEscrever exibirMenu() e gerenciar a interface no main, corrigindo std::cin.ignore;\nGarantir saídas formatadas (média com uma casa decimal, mensagens claras).\n\nTarefas específicas:\n\nChamar lerEmprestimos com filtro de nome e exibir resultados com total e média;\nImplementar relatório completo no main, usando lerEmprestimos sem filtro;\nCorrigir std::cin.ignore no main (e.g., usar std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') após std::cin &gt;&gt; opcao);\nTestar a interface com busca de usuário existente/inexistente e relatórios.\n\nInterface:\nUsa dados de lerEmprestimos para exibir resultados; Interage com o usuário, fornecendo nomes para registrarEmprestimo e buscarEmprestimo.\n\n\n7.2.1.3 Considerações para Integração do Problema H2\nInterfaces: os alunos devem concordar com assinaturas das funções e formato do CSV (nome,dias com cabeçalho); Depuração: os alunos devem fazer a Depuração de cada parte isoladamente, simulando entradas/saídas;\nPassos importantes da integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir inicializarArquivo e salvarEmprestimos do Aluno 2;\nAdicionar lerEmprestimos do Aluno 3, ajustando o main para carregar dados iniciais;\nIncluir registrarEmprestimo do Aluno 1 e buscarEmprestimo do Aluno 4.\n\nResolução de conflitos: discutir problemas imediatamente na sala. Depuração: testar o programa com cenários como registrar empréstimos, buscar por usuário e exibir relatórios.\n\n\n7.2.1.4 Código C++23\nUm dos códigos em C++23 que implementa o pseudocódigo acima pode ser encontrado em https://onlinegdb.com/KzjXw8xZm.\n\n\n\n7.2.2 I2\nUm estudante quer organizar suas tarefas diárias em uma lista dinâmica, com descrições curtas. O programa deve usar um vector para armazenar as tarefas, salvar em disco e permitir consultas. Desenvolva um sistema que gerencie tarefas, adicione ou remova tarefas de um vector e permita buscar tarefas por palavra-chave.\nFunções a implementar:\n\nFunções próprias: adicionarTarefa(), removerTarefa(), salvarTarefas(), lerTarefas(), buscarTarefa()\nFunções padrão: getline(), to_string()\n\nEntrada: Descrição da tarefa (string) ou palavra-chave para busca Saída: Lista completa de tarefas ou tarefas encontradas, com contagem total de tarefas\n\n7.2.2.1 Algoritmização: Pseudocódigo e Código\nALGORITMO GerenciadorTarefas\n\n    // Constantes\n    ARQUIVO ← \"tarefas.txt\"\n\n    // Declaração do vetor dinâmico\n    tarefas: vetor dinâmico de string\n\nINÍCIO\n    // Inicializar sistema\n    ESCREVER \"=== Sistema de Gerenciamento de Tarefas ===\"\n    ESCREVER \"Inicializando sistema...\"\n    inicializarArquivo()\n\n    // Carregar dados existentes\n    lerTarefas(tarefas)\n\n    FAÇA\n        exibirMenu()\n        ESCREVER \"Escolha uma opção: \"\n        LER opcao\n\n        SE opcao = 1 ENTÃO\n            adicionarTarefa(tarefas)\n            salvarTarefas(tarefas)\n            ESCREVER \"Tarefa(s) registrada(s).\"\n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite o índice da tarefa a remover (1-based): \"\n            LER indice\n            removerTarefa(tarefas, indice)\n            salvarTarefas(tarefas)\n            ESCREVER \"Tarefa removida.\"\n        SENÃO SE opcao = 3 ENTÃO\n            ESCREVER \"Digite a palavra-chave para busca (ou vazio para todas): \"\n            LER palavraChave\n            buscarTarefa(tarefas, palavraChave)\n        SENÃO SE opcao = 4 ENTÃO\n            tarefasTemp: vetor dinâmico de string\n            SE lerTarefas(tarefasTemp) = FALSO ENTÃO\n                ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n            SENÃO\n                SE tamanho(tarefasTemp) = 0 ENTÃO\n                    ESCREVER \"Nenhuma tarefa encontrada!\"\n                SENÃO\n                    ESCREVER \"=== RELATÓRIO COMPLETO ===\"\n                    PARA i DE 0 ATÉ tamanho(tarefasTemp) - 1 FAÇA\n                        ESCREVER \"Tarefa \", i + 1, \": \", tarefasTemp[i]\n                    FIM PARA\n                    ESCREVER \"Total de tarefas: \", tamanho(tarefasTemp)\n                FIM SE\n            FIM SE\n        SENÃO SE opcao = 0 ENTÃO\n            ESCREVER \"Encerrando sistema...\"\n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n\n        SE opcao ≠ 0 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    ENQUANTO opcao ≠ 0\n\nFIM\n\nFUNÇÃO adicionarTarefa(tarefas: vetor dinâmico de string): void\nINÍCIO\n    FAÇA\n        ESCREVER \"Digite a descrição da tarefa (ou 'sair' para encerrar): \"\n        LER descricao\n        SE descricao = \"sair\" ENTÃO\n            RETORNAR\n        FIM SE\n\n        SE descricao = \"\" OU descricao CONTER \",\" ENTÃO\n            ESCREVER \"Descrição inválida! Deve ser não vazia e sem vírgulas.\"\n            CONTINUAR\n        FIM SE\n\n        tarefas.ADICIONAR(descricao)\n    ENQUANTO VERDADEIRO\nFIM\n\nFUNÇÃO salvarTarefas(tarefas: vetor dinâmico de string): void\nINÍCIO\n    ABRIR arquivo(ARQUIVO, SOBRESCREVER)\n    SE arquivo NÃO ABERTO ENTÃO\n        ESCREVER \"Erro ao abrir arquivo para gravação!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER_ARQUIVO(arquivo, \"Tarefas\")\n    PARA i DE 0 ATÉ tamanho(tarefas) - 1 FAÇA\n        ESCREVER_ARQUIVO(arquivo, tarefas[i])\n    FIM PARA\n    FECHAR arquivo\nFIM\n\nFUNÇÃO lerTarefas(tarefas: vetor dinâmico de string): booleano\nINÍCIO\n    ABRIR arquivo(ARQUIVO, LEITURA)\n    SE arquivo NÃO ABERTO ENTÃO\n        RETORNAR FALSO\n    FIM SE\n\n    tarefas.LIMPAR()\n    LER_LINHA(arquivo, linha)\n    SE linha CONTER \"Tarefas\" ENTÃO\n        // Cabeçalho detectado\n    SENÃO\n        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)\n    FIM SE\n\n    ENQUANTO LER_LINHA(arquivo, linha) FAÇA\n        SE linha ≠ \"\" ENTÃO\n            tarefas.ADICIONAR(linha)\n        FIM SE\n    FIM ENQUANTO\n\n    FECHAR arquivo\n    RETORNAR VERDADEIRO\nFIM\n\nFUNÇÃO removerTarefa(tarefas: vetor dinâmico de string, indice: inteiro): void\nINÍCIO\n    SE indice &lt; 1 OU indice &gt; tamanho(tarefas) ENTÃO\n        ESCREVER \"Índice inválido!\"\n        RETORNAR\n    FIM SE\n\n    tarefas.REMOVER(indice - 1)\nFIM\n\nFUNÇÃO buscarTarefa(tarefas: vetor dinâmico de string, palavraChave: string): void\nINÍCIO\n    totalEncontradas ← 0\n    SE palavraChave = \"\" ENTÃO\n        ESCREVER \"=== TODAS AS TAREFAS ===\"\n        PARA i DE 0 ATÉ tamanho(tarefas) - 1 FAÇA\n            ESCREVER \"Tarefa \", i + 1, \": \", tarefas[i]\n            totalEncontradas ← totalEncontradas + 1\n        FIM PARA\n    SENÃO\n        ESCREVER \"=== TAREFAS COM PALAVRA-CHAVE '\", palavraChave, \"' ===\"\n        PARA i DE 0 ATÉ tamanho(tarefas) - 1 FAÇA\n            SE tarefas[i] CONTER palavraChave ENTÃO\n                ESCREVER \"Tarefa \", i + 1, \": \", tarefas[i]\n                totalEncontradas ← totalEncontradas + 1\n            FIM SE\n        FIM PARA\n    FIM SE\n\n    SE totalEncontradas = 0 ENTÃO\n        ESCREVER \"Nenhuma tarefa encontrada!\"\n    SENÃO\n        ESCREVER \"Total de tarefas encontradas: \", totalEncontradas\n    FIM SE\nFIM\n\nFUNÇÃO inicializarArquivo(): void\nINÍCIO\n    SE ARQUIVO NÃO EXISTIR ENTÃO\n        ABRIR arquivo(ARQUIVO, ESCRITA)\n        SE arquivo ABERTO ENTÃO\n            ESCREVER_ARQUIVO(arquivo, \"Tarefas\")\n            FECHAR arquivo\n            ESCREVER \"Arquivo de dados criado: \", ARQUIVO\n        SENÃO\n            ESCREVER \"Erro ao criar arquivo de dados!\"\n        FIM SE\n    SENÃO\n        ESCREVER \"Arquivo de dados encontrado: \", ARQUIVO\n    FIM SE\nFIM\n\nFUNÇÃO exibirMenu(): void\nINÍCIO\n    ESCREVER \"=== MENU PRINCIPAL ===\"\n    ESCREVER \"1. Adicionar tarefa\"\n    ESCREVER \"2. Remover tarefa\"\n    ESCREVER \"3. Buscar tarefas por palavra-chave\"\n    ESCREVER \"4. Relatório completo\"\n    ESCREVER \"0. Sair\"\nFIM\n\n\n7.2.2.2 Decomposição: Divisão de Tarefas para o Problema I2\nAluno 1: Função adicionarTarefa e Validação de Entrada\nResponsabilidades:\n\nImplementar adicionarTarefa(vector&lt;string&gt;& tarefas) para coletar descrições de tarefas (strings).\nValidar:\n\nDescrição não vazia e sem vírgulas (para evitar corromper o arquivo)]\nPermitir múltiplas adições até o usuário digitar “sair”;\n\nUsar getline para entrada da descrição;\nAdicionar tarefas ao vetor dinâmico sem limite fixo.\n\nTarefas específicas:\n\nEscrever a função para ler descrição via getline e adicionar ao vetor;\nValidar descrição (ex.: if (descricao.empty() || descricao.find(',') != string::npos) em C++);\nTestar isoladamente com entradas válidas (ex.: “Estudar C++”) e inválidas (ex.: ““,”Comprar leite, pão”);\nTratar buffer de entrada adequadamente (ex.: evitar problemas com std::cin).\n\nInterface:\n\nRecebe vector&lt;string&gt;& tarefas como parâmetro;\nModifica o vetor diretamente, fornecendo dados para salvarTarefas e consultas.\n\nAluno 2: Função salvarTarefas e Inicialização do Arquivo\nResponsabilidades:\n\nImplementar salvarTarefas(const vector&lt;string&gt;& tarefas) para gravar tarefas em tarefas.txt (uma tarefa por linha);\nSobrescrever o arquivo (ex.: std::ios::trunc em C++) para evitar duplicatas;\nImplementar inicializarArquivo() para criar o arquivo com cabeçalho “Tarefas” se não existir;\nVerificar erros ao abrir/escrever no arquivo.\n\nTarefas específicas:\n\nGravar cada tarefa em uma linha, sobrescrevendo o arquivo;\nPreservar o cabeçalho ao sobrescrever;\nVerificar abertura do arquivo e exibir mensagens de erro;\nTestar isoladamente com vetores de diferentes tamanhos e verificar o arquivo gerado.\n\nInterface:\n\nRecebe vector&lt;string&gt;& tarefas de adicionarTarefa ou removerTarefa.\nProduz um arquivo lido por lerTarefas.\n\nAluno 3: Função lerTarefas e Carregamento Inicial\nResponsabilidades:\n\nImplementar lerTarefas(vector&lt;string&gt;& tarefas) para ler o arquivo e preencher o vetor;\nIgnorar o cabeçalho do arquivo;\nCarregar dados do arquivo no início do programa (no main) para sincronizar o vetor local;\nTratar erros como arquivo inexistente ou vazio.\n\nTarefas específicas:\n\nLer o arquivo linha por linha, ignorar o cabeçalho e adicionar tarefas ao vetor;\nLimpar o vetor antes de carregar para evitar duplicatas;\nModificar o main para chamar lerTarefas no início;\nTestar com arquivos vazios, com uma tarefa e com múltiplas tarefas.\n\nInterface:\n\nLê o arquivo gerado por salvarTarefas;\nFornece dados para buscarTarefa e relatórios.\n\nAluno 4: Funções removerTarefa, buscarTarefa, Relatório e Interface do Usuário\nResponsabilidades:\n\nImplementar removerTarefa(vector&lt;string&gt;& tarefas, int indice) para remover uma tarefa pelo índice (1-based para o usuário);\nImplementar buscarTarefa(const vector&lt;string&gt;& tarefas, const string& palavraChave) para exibir tarefas que contenham a palavra-chave (case-insensitive, se possível);\nImplementar o relatório completo (opção 3 do menu) para listar todas as tarefas e contar o total;\nEscrever exibirMenu() e gerenciar a interface no main, corrigindo problemas de buffer (ex.: std::cin.ignore em C++);\nGarantir saídas formatadas (ex.: mensagens claras, contagem de tarefas).\n\nTarefas específicas:\n\nImplementar remoção por índice com validação (ex.: índice válido);\nImplementar busca por palavra-chave, verificando substrings na descrição;\nImplementar relatório completo no main, usando lerTarefas para listar todas as tarefas;\nCorrigir std::cin.ignore no main (ex.: std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') após leitura de opção);\nTestar a interface com busca de palavras existentes/inexistentes, remoção válida/inválida e relatórios.\n\nInterface:\n\nUsa dados de lerTarefas para exibir resultados;\nInterage com o usuário, fornecendo descrições para adicionarTarefa, índices para removerTarefa e palavras-chave para buscarTarefa.\n\n\n\n7.2.2.3 Considerações para Integração\nInterfaces:\n\nOs alunos devem concordar com a assinatura das funções e o formato do arquivo (tarefas.txt, uma tarefa por linha, com cabeçalho);\nO vetor dinâmico (vector&lt;string&gt;) é passado por referência para modificações e como const para consultas.\n\nDepuração:\n\nCada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, vetores pré-preenchidos).\n\nPassos importantes da integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir inicializarArquivo e salvarTarefas do Aluno 2;\nAdicionar lerTarefas do Aluno 3, ajustando o main para carregar dados iniciais;\nIncluir adicionarTarefa do Aluno 1, removerTarefa e buscarTarefa do Aluno 4.\n\nResolução de conflitos:\n\nDiscutir problemas imediatamente na sala (ex.: formato do arquivo, tratamento de buffer);\nTestar o programa completo com cenários como adicionar tarefas, remover, buscar por palavra-chave e exibir relatórios.\n\nDepuração:\n\nVerificar adição de múltiplas tarefas, remoção por índice, busca por palavra-chave e relatório completo;\nTestar casos extremos (arquivo vazio, palavra-chave não encontrada, índice inválido).\n\n\n\n7.2.2.4 Código C++23\nA solução em C++23 para o problema I2 pode ser encontrada em https://onlinegdb.com/SHylYeSy7.`\n\n\n\n7.2.3 J2\nUma loja de conveniência precisa registrar os produtos vendidos, armazenando nome e preço como uma string formatada. O programa deve usar um array de strings para até 15 produtos, salvar em disco e permitir consultas. Desenvolva um sistema que registre vendas, mantenha um array de strings com os produtos e permita buscar produtos por nome.\nFunções a implementar:\n\nFunções próprias: registrarProduto(), salvarProdutos(), lerProdutos(), buscarProduto()\nFunções padrão: getline(), stod(), to_string()\n\nEntrada: Nome do produto e preço (combinados em uma string no formato “nome,preco”) Saída: Lista de todos os produtos ou produtos encontrados por busca, com soma dos preços\n\n7.2.3.1 Algoritmização: Pseudocódigo\nALGORITMO GerenciadorProdutos\n\n    // Constantes\n    MAX_PRODUTOS ← 15\n    ARQUIVO ← \"produtos.csv\"\n\n    // Declaração de arrays\n    produtos[MAX_PRODUTOS]: string\n    quantidade: inteiro\n\nINÍCIO\n    // Inicializar sistema\n    ESCREVER \"=== Sistema de Gerenciamento de Produtos ===\"\n    ESCREVER \"Inicializando sistema...\"\n    inicializarArquivo()\n\n    // Carregar dados existentes\n    lerProdutos(produtos, quantidade)\n\n    FAÇA\n        exibirMenu()\n        ESCREVER \"Escolha uma opção: \"\n        LER opcao\n\n        SE opcao = 1 ENTÃO\n            registrarProduto(produtos, quantidade)\n            salvarProdutos(produtos, quantidade)\n            ESCREVER quantidade, \" produto(s) registrado(s).\"\n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite o nome do produto para busca: \"\n            LER nome\n            buscarProduto(nome)\n        SENÃO SE opcao = 3 ENTÃO\n            produtosTemp[MAX_PRODUTOS]: string\n            totalRegistros: inteiro\n            SE lerProdutos(produtosTemp, totalRegistros) = FALSO ENTÃO\n                ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n            SENÃO\n                SE totalRegistros = 0 ENTÃO\n                    ESCREVER \"Nenhum produto encontrado!\"\n                SENÃO\n                    ESCREVER \"=== RELATÓRIO COMPLETO ===\"\n                    soma ← 0.0\n                    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n                        SEPARAR(produtosTemp[i], \",\", nome, precoStr)\n                        TENTAR\n                            preco ← CONVERTER_PARA_DOUBLE(precoStr)\n                            ESCREVER \"Produto: \", nome, \", Preço: R$\", preco\n                            soma ← soma + preco\n                        SENÃO\n                            ESCREVER \"Erro ao processar preço em: \", produtosTemp[i]\n                        FIM TENTAR\n                    FIM PARA\n                    ESCREVER \"Total de produtos: \", totalRegistros\n                    ESCREVER \"Soma dos preços: R$\", soma\n                FIM SE\n            FIM SE\n        SENÃO SE opcao = 0 ENTÃO\n            ESCREVER \"Encerrando sistema...\"\n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n\n        SE opcao ≠ 0 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    ENQUANTO opcao ≠ 0\n\nFIM\n\nFUNÇÃO registrarProduto(produtos: string[], quantidade: inteiro): void\nINÍCIO\n    SE quantidade ≥ MAX_PRODUTOS ENTÃO\n        ESCREVER \"Limite de produtos atingido!\"\n        RETORNAR\n    FIM SE\n\n    FAÇA\n        ESCREVER \"Digite o nome do produto (ou 'sair' para encerrar): \"\n        LER nome\n        SE nome = \"sair\" ENTÃO\n            RETORNAR\n        FIM SE\n\n        SE nome = \"\" OU nome CONTER \",\" ENTÃO\n            ESCREVER \"Nome inválido! Deve ser não vazio e sem vírgulas.\"\n            CONTINUAR\n        FIM SE\n\n        ESCREVER \"Digite o preço do produto (positivo): \"\n        LER entrada\n        TENTAR\n            preco ← CONVERTER_PARA_DOUBLE(entrada)\n            SE preco &gt; 0 ENTÃO\n                produtos[quantidade] ← nome + \",\" + to_string(preco)\n                quantidade ← quantidade + 1\n                SE quantidade = MAX_PRODUTOS ENTÃO\n                    ESCREVER \"Limite de produtos atingido!\"\n                    RETORNAR\n                FIM SE\n            SENÃO\n                ESCREVER \"Preço inválido! Deve ser positivo.\"\n            FIM SE\n        SENÃO\n            ESCREVER \"Valor inválido para preço. Ignorado.\"\n        FIM TENTAR\n    ENQUANTO VERDADEIRO\nFIM\n\nFUNÇÃO salvarProdutos(produtos: string[], quantidade: inteiro): void\nINÍCIO\n    ABRIR arquivo(ARQUIVO, SOBRESCREVER)\n    SE arquivo NÃO ABERTO ENTÃO\n        ESCREVER \"Erro ao abrir arquivo para gravação!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER_ARQUIVO(arquivo, \"Nome,Preco\")\n    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n        ESCREVER_ARQUIVO(arquivo, produtos[i])\n    FIM PARA\n    FECHAR arquivo\nFIM\n\nFUNÇÃO lerProdutos(produtos: string[], quantidade: inteiro, nomeFiltro: string = \"\"): booleano\nINÍCIO\n    ABRIR arquivo(ARQUIVO, LEITURA)\n    SE arquivo NÃO ABERTO ENTÃO\n        RETORNAR FALSO\n    FIM SE\n\n    quantidade ← 0\n    LER_LINHA(arquivo, linha)\n    SE linha CONTER \"Nome\" ENTÃO\n        // Cabeçalho detectado\n    SENÃO\n        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)\n    FIM SE\n\n    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_PRODUTOS FAÇA\n        SEPARAR(linha, \",\", nome, precoStr)\n        SE nomeFiltro = \"\" OU nome CONTER nomeFiltro ENTÃO\n            TENTAR\n                preco ← CONVERTER_PARA_DOUBLE(precoStr)\n                produtos[quantidade] ← linha\n                quantidade ← quantidade + 1\n            SENÃO\n                // Ignorar linhas inválidas\n            FIM TENTAR\n        FIM SE\n    FIM ENQUANTO\n\n    SE quantidade = MAX_PRODUTOS E MAIS_LINHAS(arquivo) ENTÃO\n        ESCREVER \"Aviso: Mais registros no arquivo do que o limite de \", MAX_PRODUTOS\n    FIM SE\n\n    FECHAR arquivo\n    RETORNAR VERDADEIRO\nFIM\n\nFUNÇÃO buscarProduto(nome: string): void\nINÍCIO\n    produtosTemp[MAX_PRODUTOS]: string\n    totalRegistros: inteiro\n\n    SE lerProdutos(produtosTemp, totalRegistros, nome) = FALSO ENTÃO\n        ESCREVER \"Erro ao ler dados!\"\n        RETORNAR\n    FIM SE\n\n    SE totalRegistros = 0 ENTÃO\n        ESCREVER \"Nenhum produto encontrado para '\", nome, \"'!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER \"=== PRODUTOS COM NOME CONTENDO '\", nome, \"' ===\"\n    soma ← 0.0\n    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n        SEPARAR(produtosTemp[i], \",\", nomeProduto, precoStr)\n        TENTAR\n            preco ← CONVERTER_PARA_DOUBLE(precoStr)\n            ESCREVER \"Produto: \", nomeProduto, \", Preço: R$\", preco\n            soma ← soma + preco\n        SENÃO\n            ESCREVER \"Erro ao processar preço em: \", produtosTemp[i]\n        FIM TENTAR\n    FIM PARA\n    ESCREVER \"Total de produtos: \", totalRegistros\n    ESCREVER \"Soma dos preços: R$\", soma\nFIM\n\nFUNÇÃO inicializarArquivo(): void\nINÍCIO\n    SE ARQUIVO NÃO EXISTIR ENTÃO\n        ABRIR arquivo(ARQUIVO, ESCRITA)\n        SE arquivo ABERTO ENTÃO\n            ESCREVER_ARQUIVO(arquivo, \"Nome,Preco\")\n            FECHAR arquivo\n            ESCREVER \"Arquivo de dados criado: \", ARQUIVO\n        SENÃO\n            ESCREVER \"Erro ao criar arquivo de dados!\"\n        FIM SE\n    SENÃO\n        ESCREVER \"Arquivo de dados encontrado: \", ARQUIVO\n    FIM SE\nFIM\n\nFUNÇÃO exibirMenu(): void\nINÍCIO\n    ESCREVER \"=== MENU PRINCIPAL ===\"\n    ESCREVER \"1. Registrar produto\"\n    ESCREVER \"2. Buscar produtos por nome\"\n    ESCREVER \"3. Relatório completo\"\n    ESCREVER \"0. Sair\"\nFIM\n\n\n7.2.3.2 Decomposição: Divisão de Tarefas para o Problema J2\nO problema J2 propõe um sistema para gerenciar vendas de produtos em uma loja de conveniência, usando um array fixo de até 15 strings formatadas como “nome,preco”, com persistência em arquivo e funcionalidades de registro, salvamento, leitura e busca por nome. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.\nAluno 1: Função registrarProduto e Validação de Entrada\nResponsabilidades:\n\nImplementar registrarProduto(string produtos[], int& quantidade) para coletar nome do produto (string) e preço (double, positivo), formatando como “nome,preco”.\nValidar:\n\nNome não vazio e sem vírgulas (para evitar corromper o formato);\nPreço como double positivo, usando stod com tratamento de exceções;\nNão zerar quantidade para preservar produtos anteriores no array;\n\nPermitir múltiplos registros até MAX_PRODUTOS (15) ou até o usuário digitar “sair”;\nTratar buffer de entrada adequadamente (ex.: corrigir uso de std::cin.ignore em C++).\n\nTarefas específicas:\n\nEscrever a função com entrada via getline para nome e preço;\nValidar nome (ex.: if (nome.empty() || nome.find(',') != string::npos) em C++);\nValidar preço (ex.: converter com stod, verificar se positivo);\nAdicionar string formatada (“nome,preco”) ao array a partir do índice quantidade;\nTestar isoladamente com entradas válidas (ex.: “Leite,3.50”) e inválidas (ex.: ““,”Pão,leite”, “-5”).\n\nInterface:\n\nRecebe produtos[] e quantidade como parâmetros;\nFornece strings formatadas para salvarProdutos e consultas.\n\nAluno 2: Função salvarProdutos e Inicialização do Arquivo\nResponsabilidades:\n\nImplementar salvarProdutos(const string produtos[], int quantidade) para gravar produtos em produtos.csv (formato: “Nome,Preco” por linha);\nSobrescrever o arquivo (ex.: std::ios::trunc em C++) para evitar duplicatas;\nImplementar inicializarArquivo() para criar o arquivo CSV com cabeçalho “Nome,Preco” se não existir;\nVerificar erros ao abrir/escrever no arquivo.\n\nTarefas específicas:\n\nGravar cada string formatada (“nome,preco”) em uma linha, sobrescrevendo o arquivo;\nPreservar o cabeçalho ao sobrescrever;\nVerificar abertura do arquivo e exibir mensagens de erro;\nTestar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.\n\nInterface:\n\nRecebe produtos[] e quantidade de registrarProduto;\nProduz um arquivo CSV lido por lerProdutos.\n\nAluno 3: Função lerProdutos e Carregamento Inicial\nResponsabilidades:\n\nImplementar lerProdutos(string produtos[], int& quantidade, const string& nomeFiltro = \"\") para ler o arquivo CSV e preencher o array;\nSuportar leitura de todos os produtos ou filtragem por nome (substring no campo nome);\nAlertar se o arquivo tiver mais registros que MAX_PRODUTOS (15);\nCarregar dados do arquivo no início do programa (no main) para sincronizar o array local.\n\nTarefas específicas:\n\nLer o CSV, ignorar o cabeçalho e preencher o array com strings formatadas;\nImplementar filtragem por nomeFiltro quando não vazio (verificar substring no campo nome);\nContar registros e alertar se exceder MAX_PRODUTOS;\nModificar o main para chamar lerProdutos no início;\nTestar com arquivos CSV vazios, com menos de 15 registros e com mais de 15.\n\nInterface:\n\nLê o arquivo CSV de salvarProdutos;\nFornece dados para buscarProduto e relatório completo.\n\nAluno 4: Função buscarProduto, Relatório e Interface do Usuário\nResponsabilidades:\n\nImplementar buscarProduto(const string& nome) para exibir produtos cujo nome contenha a substring fornecida, com soma dos preços;\nImplementar o relatório completo (opção 3 do menu) para listar todos os produtos e a soma dos preços;\nEscrever exibirMenu() e gerenciar a interface no main, corrigindo problemas de buffer (ex.: std::cin.ignore em C++);\nGarantir saídas formatadas (ex.: preços com duas casas decimais, mensagens claras);\n\nTarefas específicas:\n\nChamar lerProdutos com filtro de nome e exibir resultados com total e soma dos preços;\nImplementar relatório completo no main, usando lerProdutos sem filtro;\nCorrigir std::cin.ignore no main (ex.: std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') após leitura de opção);\nTestar a interface com busca de nomes existentes/inexistentes e relatórios.\n\nInterface:\n\nUsa dados de lerProdutos para exibir resultados;\nInterage com o usuário, fornecendo nomes para registrarProduto e buscarProduto.\n\n\n\n7.2.3.3 Considerações para Integração\nInterfaces:\n\nOs alunos devem concordar com a assinatura das funções e o formato do CSV (uma linha por produto, “nome,preco” com cabeçalho);\nO array produtos[] armazena strings no formato “nome,preco”, e quantidade rastreia o número de registros.\n\nDepuração:\n\nCada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos).\n\nPassos importantes da integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir inicializarArquivo e salvarProdutos do Aluno 2;\nAdicionar lerProdutos do Aluno 3, ajustando o main para carregar dados iniciais;\nIncluir registrarProduto do Aluno 1 e buscarProduto do Aluno 4.\n\nResolução de conflitos:\n\nDiscutir problemas imediatamente na sala (ex.: formato do CSV, tratamento de buffer);\nTestar o programa completo com cenários como registrar produtos, buscar por nome e exibir relatórios.\n\nDepuração:\n\nVerificar registro de múltiplos produtos, busca por nome (substring), e relatório completo com soma de preços;\nTestar casos extremos (arquivo vazio, nome não encontrado, mais de 15 produtos).\n\n\n\n7.2.3.4 Código C++23\nO código correspondente ao problema J2 pode ser encontrado em https://onlinegdb.com/_Ng8nLlV1.\n\n\n\n7.2.4 K2\nUm clube de eventos precisa gerenciar registros de participantes em atividades culturais. Cada participante é registrado com nome, quantidade de eventos que participou e total pago pelas inscrições. O programa deve usar structs para armazenar os dados, salvar em disco e permitir consultas. Desenvolva um sistema que registre participantes, mantenha os dados em structs, salve em um arquivo CSV e permita consultar todos os registros ou os de um participante específico.\nFunções a implementar:\n\nFunções próprias: registrarParticipante(), salvarParticipantes(), lerParticipantes(), buscarParticipante();\nFunções padrão: getline(), stoi(), stod(), to_string().\nEntrada: nome do participante (string), quantidade de eventos (inteiro, 1 a 50), total pago (decimal).\nSaída: lista de todos os participantes ou registros de um participante específico, com média de eventos e soma dos valores pagos.\n\n\n7.2.4.1 Algoritmização: Pseudocódigo\nALGORITMO GerenciadorParticipantes\n\n    // Estrutura de dados\n    ESTRUTURA Participante\n        nome: string\n        eventos: inteiro\n        totalPago: decimal\n    FIM ESTRUTURA\n\n    // Constantes\n    MAX_PARTICIPANTES ← 20\n    ARQUIVO ← \"participantes.csv\"\n\n    // Declaração de arrays\n    participantes[MAX_PARTICIPANTES]: Participante\n    quantidade: inteiro\n\nINÍCIO\n    // Inicializar sistema\n    ESCREVER \"=== Sistema de Gerenciamento de Participantes ===\"\n    ESCREVER \"Inicializando sistema...\"\n    inicializarArquivo()\n\n    // Carregar dados existentes\n    lerParticipantes(participantes, quantidade)\n\n    FAÇA\n        exibirMenu()\n        ESCREVER \"Escolha uma opção: \"\n        LER opcao\n\n        SE opcao = 1 ENTÃO\n            registrarParticipante(participantes, quantidade)\n            salvarParticipantes(participantes, quantidade)\n            ESCREVER quantidade, \" participante(s) registrado(s).\"\n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite o nome do participante para busca: \"\n            LER nome\n            buscarParticipante(nome)\n        SENÃO SE opcao = 3 ENTÃO\n            participantesTemp[MAX_PARTICIPANTES]: Participante\n            totalRegistros: inteiro\n            SE lerParticipantes(participantesTemp, totalRegistros) = FALSO ENTÃO\n                ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n            SENÃO\n                SE totalRegistros = 0 ENTÃO\n                    ESCREVER \"Nenhum participante encontrado!\"\n                SENÃO\n                    ESCREVER \"=== RELATÓRIO COMPLETO ===\"\n                    somaEventos ← 0.0\n                    somaPagos ← 0.0\n                    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n                        ESCREVER \"Participante: \", participantesTemp[i].nome, \", Eventos: \", participantesTemp[i].eventos, \", Total Pago: R$\", participantesTemp[i].totalPago\n                        somaEventos ← somaEventos + participantesTemp[i].eventos\n                        somaPagos ← somaPagos + participantesTemp[i].totalPago\n                    FIM PARA\n                    ESCREVER \"Total de participantes: \", totalRegistros\n                    ESCREVER \"Média de eventos: \", somaEventos / totalRegistros\n                    ESCREVER \"Soma dos valores pagos: R$\", somaPagos\n                FIM SE\n            FIM SE\n        SENÃO SE opcao = 0 ENTÃO\n            ESCREVER \"Encerrando sistema...\"\n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n\n        SE opcao ≠ 0 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    ENQUANTO opcao ≠ 0\n\nFIM\n\nFUNÇÃO registrarParticipante(participantes: Participante[], quantidade: inteiro): void\nINÍCIO\n    SE quantidade ≥ MAX_PARTICIPANTES ENTÃO\n        ESCREVER \"Limite de participantes atingido!\"\n        RETORNAR\n    FIM SE\n\n    FAÇA\n        ESCREVER \"Digite o nome do participante (ou 'sair' para encerrar): \"\n        LER nome\n        SE nome = \"sair\" ENTÃO\n            RETORNAR\n        FIM SE\n\n        SE nome = \"\" OU nome CONTER \",\" ENTÃO\n            ESCREVER \"Nome inválido! Deve ser não vazio e sem vírgulas.\"\n            CONTINUAR\n        FIM SE\n\n        ESCREVER \"Digite a quantidade de eventos (1-50): \"\n        LER entradaEventos\n        TENTAR\n            eventos ← CONVERTER_PARA_INTEIRO(entradaEventos)\n            SE eventos ≥ 1 E eventos ≤ 50 ENTÃO\n                ESCREVER \"Digite o total pago (positivo): \"\n                LER entradaTotal\n                TENTAR\n                    total ← CONVERTER_PARA_DOUBLE(entradaTotal)\n                    SE total &gt; 0 ENTÃO\n                        participantes[quantidade].nome ← nome\n                        participantes[quantidade].eventos ← eventos\n                        participantes[quantidade].totalPago ← total\n                        quantidade ← quantidade + 1\n                        SE quantidade = MAX_PARTICIPANTES ENTÃO\n                            ESCREVER \"Limite de participantes atingido!\"\n                            RETORNAR\n                        FIM SE\n                    SENÃO\n                        ESCREVER \"Total pago inválido! Deve ser positivo.\"\n                    FIM SE\n                SENÃO\n                    ESCREVER \"Valor inválido para total pago. Ignorado.\"\n                FIM TENTAR\n            SENÃO\n                ESCREVER \"Quantidade de eventos fora do intervalo (1-50). Ignorado.\"\n            FIM SE\n        SENÃO\n            ESCREVER \"Valor inválido para eventos. Ignorado.\"\n        FIM TENTAR\n    ENQUANTO VERDADEIRO\nFIM\n\nFUNÇÃO salvarParticipantes(participantes: Participante[], quantidade: inteiro): void\nINÍCIO\n    ABRIR arquivo(ARQUIVO, SOBRESCREVER)\n    SE arquivo NÃO ABERTO ENTÃO\n        ESCREVER \"Erro ao abrir arquivo para gravação!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER_ARQUIVO(arquivo, \"Nome,Eventos,TotalPago\")\n    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n        ESCREVER_ARQUIVO(arquivo, participantes[i].nome, \",\", participantes[i].eventos, \",\", participantes[i].totalPago)\n    FIM PARA\n    FECHAR arquivo\nFIM\n\nFUNÇÃO lerParticipantes(participantes: Participante[], quantidade: inteiro, nomeFiltro: string = \"\"): booleano\nINÍCIO\n    ABRIR arquivo(ARQUIVO, LEITURA)\n    SE arquivo NÃO ABERTO ENTÃO\n        RETORNAR FALSO\n    FIM SE\n\n    quantidade ← 0\n    LER_LINHA(arquivo, linha)\n    SE linha CONTER \"Nome\" ENTÃO\n        // Cabeçalho detectado\n    SENÃO\n        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)\n    FIM SE\n\n    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_PARTICIPANTES FAÇA\n        SEPARAR(linha, \",\", nome, eventosStr, totalStr)\n        SE nomeFiltro = \"\" OU nome = nomeFiltro ENTÃO\n            TENTAR\n                eventos ← CONVERTER_PARA_INTEIRO(eventosStr)\n                total ← CONVERTER_PARA_DOUBLE(totalStr)\n                participantes[quantidade].nome ← nome\n                participantes[quantidade].eventos ← eventos\n                participantes[quantidade].totalPago ← total\n                quantidade ← quantidade + 1\n            SENÃO\n                // Ignorar linhas inválidas\n            FIM TENTAR\n        FIM SE\n    FIM ENQUANTO\n\n    SE quantidade = MAX_PARTICIPANTES E MAIS_LINHAS(arquivo) ENTÃO\n        ESCREVER \"Aviso: Mais registros no arquivo do que o limite de \", MAX_PARTICIPANTES\n    FIM SE\n\n    FECHAR arquivo\n    RETORNAR VERDADEIRO\nFIM\n\nFUNÇÃO buscarParticipante(nome: string): void\nINÍCIO\n    participantesTemp[MAX_PARTICIPANTES]: Participante\n    totalRegistros: inteiro\n\n    SE lerParticipantes(participantesTemp, totalRegistros, nome) = FALSO ENTÃO\n        ESCREVER \"Erro ao ler dados!\"\n        RETORNAR\n    FIM SE\n\n    SE totalRegistros = 0 ENTÃO\n        ESCREVER \"Nenhum participante encontrado para '\", nome, \"'!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER \"=== REGISTROS DE \", nome, \" ===\"\n    somaEventos ← 0.0\n    somaPagos ← 0.0\n    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n        ESCREVER \"Participante: \", participantesTemp[i].nome, \", Eventos: \", participantesTemp[i].eventos, \", Total Pago: R$\", participantesTemp[i].totalPago\n        somaEventos ← somaEventos + participantesTemp[i].eventos\n        somaPagos ← somaPagos + participantesTemp[i].totalPago\n    FIM PARA\n    ESCREVER \"Total de registros: \", totalRegistros\n    ESCREVER \"Média de eventos: \", somaEventos / totalRegistros\n    ESCREVER \"Soma dos valores pagos: R$\", somaPagos\nFIM\n\nFUNÇÃO inicializarArquivo(): void\nINÍCIO\n    SE ARQUIVO NÃO EXISTIR ENTÃO\n        ABRIR arquivo(ARQUIVO, ESCRITA)\n        SE arquivo ABERTO ENTÃO\n            ESCREVER_ARQUIVO(arquivo, \"Nome,Eventos,TotalPago\")\n            FECHAR arquivo\n            ESCREVER \"Arquivo de dados criado: \", ARQUIVO\n        SENÃO\n            ESCREVER \"Erro ao criar arquivo de dados!\"\n        FIM SE\n    SENÃO\n        ESCREVER \"Arquivo de dados encontrado: \", ARQUIVO\n    FIM SE\nFIM\n\nFUNÇÃO exibirMenu(): void\nINÍCIO\n    ESCREVER \"=== MENU PRINCIPAL ===\"\n    ESCREVER \"1. Registrar participante\"\n    ESCREVER \"2. Buscar participante por nome\"\n    ESCREVER \"3. Relatório completo\"\n    ESCREVER \"0. Sair\"\nFIM\n\n\n7.2.4.2 Decomposição: Divisão de Tarefas para o Problema K2\nO problema K2 propõe um sistema para gerenciar registros de participantes em atividades culturais, usando structs para armazenar nome, quantidade de eventos e total pago, com persistência em arquivo CSV e funcionalidades de registro, salvamento, leitura e busca por nome. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.\nAluno 1: Função registrarParticipante e Validação de Entrada\nResponsabilidades:\n\nImplementar registrarParticipante(Participante participantes[], int& quantidade) para coletar nome (string), quantidade de eventos (inteiro, 1 a 50) e total pago (double, positivo);\nValidar:\n\nNome não vazio e sem vírgulas (para evitar corromper o CSV);\nQuantidade de eventos entre 1 e 50, usando stoi com tratamento de exceções;\nTotal pago como double positivo, usando stod com tratamento de exceções;\nNão zerar quantidade para preservar registros anteriores;\n\nPermitir múltiplos registros até MAX_PARTICIPANTES (definido como 20, por exemplo) ou até o usuário digitar “sair”;\nTratar buffer de entrada adequadamente (ex.: corrigir uso de std::cin.ignore em C++).\n\nTarefas específicas:\n\nEscrever a função com entrada via getline para nome, eventos e total pago;\nValidar nome (ex.: if (nome.empty() || nome.find(',') != string::npos) em C++);\nValidar eventos (ex.: converter com stoi, verificar intervalo 1-50);\nValidar total pago (ex.: converter com stod, verificar se positivo);\nAdicionar dados à struct Participante no array a partir do índice quantidade;\nTestar isoladamente com entradas válidas (ex.: “Ana,5,100.50”) e inválidas (ex.: ““,”João,pão”, “0”, “-10”).\n\nInterface:\n\nRecebe participantes[] e quantidade como parâmetros;\nFornece dados válidos para salvarParticipantes e consultas.\n\nAluno 2: Função salvarParticipantes e Inicialização do Arquivo\nResponsabilidades:\n\nImplementar salvarParticipantes(const Participante participantes[], int quantidade) para gravar registros em participantes.csv (formato: “Nome,Eventos,TotalPago”);\nSobrescrever o arquivo (ex.: std::ios::trunc em C++) para evitar duplicatas;\nImplementar inicializarArquivo() para criar o arquivo CSV com cabeçalho “Nome,Eventos,TotalPago” se não existir;\nVerificar erros ao abrir/escrever no arquivo.\n\nTarefas específicas:\n\nGravar cada registro (nome, eventos, total pago) em uma linha do CSV, sobrescrevendo o arquivo;\nPreservar o cabeçalho ao sobrescrever;\nVerificar abertura do arquivo e exibir mensagens de erro;\nTestar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.\n\nInterface:\n\nRecebe participantes[] e quantidade de registrarParticipante;\nProduz um arquivo CSV lido por lerParticipantes.\n\nAluno 3: Função lerParticipantes e Carregamento Inicial\nResponsabilidades:\n\nImplementar lerParticipantes(Participante participantes[], int& quantidade, const string& nomeFiltro = \"\") para ler o arquivo CSV e preencher o array de structs;\nSuportar leitura de todos os registros ou filtragem por nome (exato ou substring);\nAlertar se o arquivo tiver mais registros que MAX_PARTICIPANTES;\nCarregar dados do arquivo no início do programa (no main) para sincronizar o array local.\n\nTarefas específicas:\n\nLer o CSV, ignorar o cabeçalho e preencher o array de structs;\nImplementar filtragem por nomeFiltro quando não vazio (ex.: verificar igualdade ou substring no campo nome);\nContar registros e alertar se exceder MAX_PARTICIPANTES;\nModificar o main para chamar lerParticipantes no início;\nTestar com arquivos CSV vazios, com menos de 20 registros e com mais de 20.\n\nInterface:\n\nLê o arquivo CSV de salvarParticipantes;\nFornece dados para buscarParticipante e relatório completo.\n\nAluno 4: Função buscarParticipante, Relatório e Interface do Usuário\nResponsabilidades:\n\nImplementar buscarParticipante(const string& nome) para exibir registros de um participante, com média de eventos e soma dos valores pagos;\nImplementar o relatório completo (opção 3 do menu) para listar todos os participantes, com média de eventos e soma total dos valores pagos;\nEscrever exibirMenu() e gerenciar a interface no main, corrigindo problemas de buffer (ex.: std::cin.ignore em C++);\nGarantir saídas formatadas (ex.: preços com duas casas decimais, média com uma casa decimal, mensagens claras).\n\nTarefas específicas:\n\nChamar lerParticipantes com filtro de nome e exibir resultados com total, média de eventos e soma dos valores pagos;\nImplementar relatório completo no main, usando lerParticipantes sem filtro;\nCorrigir std::cin.ignore no main (ex.: std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') após leitura de opção);\nTestar a interface com busca de nomes existentes/inexistentes e relatórios.\n\nInterface:\n\nUsa dados de lerParticipantes para exibir resultados;\nInterage com o usuário, fornecendo nomes para registrarParticipante e buscarParticipante.\n\n\n\n7.2.4.3 Considerações para Integração\nInterfaces:\n\nOs alunos devem concordar com a estrutura da struct Participante (campos: nome, eventos, totalPago) e o formato do CSV (“Nome,Eventos,TotalPago” com cabeçalho);\nO array participantes[] armazena structs, e quantidade rastreia o número de registros.\n\nDepuração:\n\nCada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos).\n\nPassos importantes da integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir inicializarArquivo e salvarParticipantes do Aluno 2;\nAdicionar lerParticipantes do Aluno 3, ajustando o main para carregar dados iniciais;\nIncluir registrarParticipante do Aluno 1 e buscarParticipante do Aluno 4.\n\nResolução de conflitos:\n\nDiscutir problemas imediatamente na sala (ex.: formato do CSV, tratamento de buffer);\nTestar o programa completo com cenários como registrar participantes, buscar por nome e exibir relatórios.\n\nDepuração:\n\nVerificar registro de múltiplos participantes, busca por nome, e relatório completo com média de eventos e soma de valores;\nTestar casos extremos (arquivo vazio, nome não encontrado, mais de 20 participantes).\n\n\n\n7.2.4.4 Código C++23\nO código correspondente ao problema K2 pode ser encontrado em https://onlinegdb.com/HPGcXEHrR.\n\n\n\n7.2.5 L2\nA prefeitura instalou sensores de temperatura pela cidade e precisa processar os dados coletados durante um mês. O sistema deve armazenar todas as temperaturas, identificar padrões climáticos, calcular estatísticas detalhadas e gerar relatórios para o departamento de meio ambiente. Desenvolva um programa que armazene até \\(30\\) temperaturas diárias em um array, calcule a temperatura média do dia e do mês, identifique as temperaturas máxima e mínima, no dia e no mês, calcule desvio padrão e identifique dias com temperaturas extremas. Para isso o programa deve manter em disco um arquivo, csv, com data, hora e valor de cada temperatura registrada.\nFunções a implementar:\n\nFunções próprias: lerTemperaturas(), gravarTemperaturas(), lerDadosTemperaturas(), calcularEstatisticas(), encontrarExtremos(), calcularDesvio()\nFunções padrão: abs(), round(), sqrt()\n\nEntrada: um valor de temperatura por hora, ou até 30 valores de uma vez na linha de comando, separados por vírgulas. Os valores de temperatura estão em graus Celsius, com uma casa decimal.\nSaída: Relatório completo com médias, extremos, desvio padrão e análise de tendências. O usuário pode escolher um dia específico para ver as temperaturas registradas, ou o relatório completo de um mês específico.\n\n7.2.5.1 Algoritmização: Pseudocódigo\nALGORITMO GerenciadorTemperaturas\n\n    // Constantes\n    MAX_TEMPERATURAS ← 30\n    ARQUIVO ← \"temperaturas.csv\"\n\n    // Declaração de arrays\n    temperaturas[MAX_TEMPERATURAS]: real\n\nINÍCIO\n    // Inicializar sistema\n    ESCREVER \"=== Sistema de Gerenciamento de Temperaturas ===\"\n    ESCREVER \"Inicializando sistema...\"\n    inicializarArquivo()\n\n    FAÇA\n        exibirMenu()\n        ESCREVER \"Escolha uma opção: \"\n        LER opcao\n\n        SE opcao = 1 ENTÃO\n            ESCREVER \"Digite a data (DD/MM/AAAA): \"\n            LER data\n            quantidade ← 0\n            SE VALIDAR_DATA(data) ENTÃO\n                lerTemperaturas(temperaturas, quantidade, data)\n                gravarTemperaturas(temperaturas, quantidade, data)\n                ESCREVER quantidade, \" temperatura(s) registrada(s).\"\n            SENÃO\n                ESCREVER \"Data inválida! Use o formato DD/MM/AAAA.\"\n            FIM SE\n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite a data para busca (DD/MM/AAAA, ou vazio para todas): \"\n            LER dataFiltro\n            SE dataFiltro = \"\" OU VALIDAR_DATA(dataFiltro) ENTÃO\n                quantidade ← 0\n                SE lerDadosTemperaturas(temperaturas, quantidade, dataFiltro) = FALSO ENTÃO\n                    ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n                SENÃO SE quantidade = 0 ENTÃO\n                    ESCREVER \"Nenhuma temperatura encontrada para a data!\"\n                SENÃO\n                    media ← 0.0\n                    minima ← 0.0\n                    maxima ← 0.0\n                    calcularEstatisticas(temperaturas, quantidade, media)\n                    encontrarExtremos(temperaturas, quantidade, minima, maxima)\n                    desvio ← calcularDesvio(temperaturas, quantidade, media)\n                    ESCREVER \"=== RELATÓRIO PARA \", dataFiltro, \" ===\"\n                    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n                        ESCREVER \"Hora: \", FORMATAR_HORA(i), \", Temperatura: \", temperaturas[i], \"°C\"\n                    FIM PARA\n                    ESCREVER \"Total de temperaturas: \", quantidade\n                    ESCREVER \"Média: \", ARREDONDAR(media, 1), \"°C\"\n                    ESCREVER \"Mínima: \", ARREDONDAR(minima, 1), \"°C\"\n                    ESCREVER \"Máxima: \", ARREDONDAR(maxima, 1), \"°C\"\n                    ESCREVER \"Desvio padrão: \", ARREDONDAR(desvio, 2), \"°C\"\n                FIM SE\n            SENÃO\n                ESCREVER \"Data inválida! Use o formato DD/MM/AAAA.\"\n            FIM SE\n        SENÃO SE opcao = 3 ENTÃO\n            // Relatório mensal (supõe que o usuário escolhe um mês/ano)\n            ESCREVER \"Digite o mês e ano (MM/AAAA): \"\n            LER mesAno\n            SE VALIDAR_MES_ANO(mesAno) ENTÃO\n                temperaturasTemp[MAX_TEMPERATURAS]: real\n                totalRegistros ← 0\n                diasExtremos: vetor dinâmico de string\n                mediaMensal ← 0.0\n                minimaMensal ← 0.0\n                maximaMensal ← 0.0\n                SE lerDadosTemperaturas(temperaturasTemp, totalRegistros, \"\") = FALSO ENTÃO\n                    ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n                SENÃO SE totalRegistros = 0 ENTÃO\n                    ESCREVER \"Nenhuma temperatura encontrada!\"\n                SENÃO\n                    ESCREVER \"=== RELATÓRIO MENSAL PARA \", mesAno, \" ===\"\n                    soma ← 0.0\n                    contagemTotal ← 0\n                    PARA CADA data NO ARQUIVO QUE CORRESPONDE A mesAno FAÇA\n                        quantidade ← 0\n                        lerDadosTemperaturas(temperaturasTemp, quantidade, data)\n                        SE quantidade &gt; 0 ENTÃO\n                            mediaDia ← 0.0\n                            minimaDia ← 0.0\n                            maximaDia ← 0.0\n                            calcularEstatisticas(temperaturasTemp, quantidade, mediaDia)\n                            encontrarExtremos(temperaturasTemp, quantidade, minimaDia, maximaDia)\n                            desvioDia ← calcularDesvio(temperaturasTemp, quantidade, mediaDia)\n                            soma ← soma + mediaDia * quantidade\n                            contagemTotal ← contagemTotal + quantidade\n                            SE minimaDia &lt; minimaMensal OU minimaMensal = 0 ENTÃO\n                                minimaMensal ← minimaDia\n                            FIM SE\n                            SE maximaDia &gt; maximaMensal ENTÃO\n                                maximaMensal ← maximaDia\n                            FIM SE\n                            SE ABS(mediaDia - mediaMensal) &gt; 2 * desvioDia ENTÃO\n                                diasExtremos.ADICIONAR(data)\n                            FIM SE\n                        FIM SE\n                    FIM PARA\n                    mediaMensal ← soma / contagemTotal\n                    desvioMensal ← calcularDesvio(temperaturasTemp, totalRegistros, mediaMensal)\n                    ESCREVER \"Média mensal: \", ARREDONDAR(mediaMensal, 1), \"°C\"\n                    ESCREVER \"Mínima mensal: \", ARREDONDAR(minimaMensal, 1), \"°C\"\n                    ESCREVER \"Máxima mensal: \", ARREDONDAR(maximaMensal, 1), \"°C\"\n                    ESCREVER \"Desvio padrão mensal: \", ARREDONDAR(desvioMensal, 2), \"°C\"\n                    ESCREVER \"Dias com temperaturas extremas: \"\n                    SE tamanho(diasExtremos) = 0 ENTÃO\n                        ESCREVER \"Nenhum dia extremo identificado.\"\n                    SENÃO\n                        PARA CADA dia EM diasExtremos FAÇA\n                            ESCREVER dia\n                        FIM PARA\n                    FIM SE\n                FIM SE\n            SENÃO\n                ESCREVER \"Mês/ano inválido! Use o formato MM/AAAA.\"\n            FIM SE\n        SENÃO SE opcao = 0 ENTÃO\n            ESCREVER \"Encerrando sistema...\"\n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n\n        SE opcao ≠ 0 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    ENQUANTO opcao ≠ 0\n\nFIM\n\nFUNÇÃO lerTemperaturas(temperaturas: real[], quantidade: inteiro, data: string): void\nINÍCIO\n    SE quantidade ≥ MAX_TEMPERATURAS ENTÃO\n        ESCREVER \"Limite de temperaturas atingido!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER \"Digite as temperaturas (separadas por vírgulas, ou 'sair'): \"\n    LER entrada\n    SE entrada = \"sair\" ENTÃO\n        RETORNAR\n    FIM SE\n\n    SEPARAR(entrada, \",\", valores)\n    PARA CADA valor EM valores FAÇA\n        SE quantidade ≥ MAX_TEMPERATURAS ENTÃO\n            ESCREVER \"Limite de temperaturas atingido!\"\n            RETORNAR\n        FIM SE\n        TENTAR\n            temp ← CONVERTER_PARA_REAL(valor)\n            temp ← ARREDONDAR(temp, 1)\n            temperaturas[quantidade] ← temp\n            quantidade ← quantidade + 1\n        SENÃO\n            ESCREVER \"Valor inválido: \", valor, \". Ignorado.\"\n        FIM TENTAR\n    FIM PARA\nFIM\n\nFUNÇÃO gravarTemperaturas(temperaturas: real[], quantidade: inteiro, data: string): void\nINÍCIO\n    ABRIR arquivo(ARQUIVO, APPEND)\n    SE arquivo NÃO ABERTO ENTÃO\n        ESCREVER \"Erro ao abrir arquivo para gravação!\"\n        RETORNAR\n    FIM SE\n\n    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n        ESCREVER_ARQUIVO(arquivo, data, \",\", FORMATAR_HORA(i), \",\", ARREDONDAR(temperaturas[i], 1))\n    FIM PARA\n    FECHAR arquivo\nFIM\n\nFUNÇÃO lerDadosTemperaturas(temperaturas: real[], quantidade: inteiro, dataFiltro: string = \"\"): booleano\nINÍCIO\n    ABRIR arquivo(ARQUIVO, LEITURA)\n    SE arquivo NÃO ABERTO ENTÃO\n        RETORNAR FALSO\n    FIM SE\n\n    quantidade ← 0\n    LER_LINHA(arquivo, linha)\n    SE linha CONTER \"Data\" ENTÃO\n        // Cabeçalho detectado\n    SENÃO\n        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)\n    FIM SE\n\n    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_TEMPERATURAS FAÇA\n        SEPARAR(linha, \",\", data, hora, tempStr)\n        SE dataFiltro = \"\" OU data = dataFiltro ENTÃO\n            TENTAR\n                temp ← CONVERTER_PARA_REAL(tempStr)\n                temperaturas[quantidade] ← ARREDONDAR(temp, 1)\n                quantidade ← quantidade + 1\n            SENÃO\n                // Ignorar linhas inválidas\n            FIM TENTAR\n        FIM SE\n    FIM ENQUANTO\n\n    SE quantidade = MAX_TEMPERATURAS E MAIS_LINHAS(arquivo) ENTÃO\n        ESCREVER \"Aviso: Mais registros para a data do que o limite de \", MAX_TEMPERATURAS\n    FIM SE\n\n    FECHAR arquivo\n    RETORNAR VERDADEIRO\nFIM\n\nFUNÇÃO calcularEstatisticas(temperaturas: real[], quantidade: inteiro, media: real): void\nINÍCIO\n    SE quantidade = 0 ENTÃO\n        media ← 0.0\n        RETORNAR\n    FIM SE\n    soma ← 0.0\n    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n        soma ← soma + temperaturas[i]\n    FIM PARA\n    media ← soma / quantidade\nFIM\n\nFUNÇÃO encontrarExtremos(temperaturas: real[], quantidade: inteiro, minima: real, maxima: real): void\nINÍCIO\n    SE quantidade = 0 ENTÃO\n        minima ← 0.0\n        maxima ← 0.0\n        RETORNAR\n    FIM SE\n    minima ← temperaturas[0]\n    maxima ← temperaturas[0]\n    PARA i DE 1 ATÉ quantidade - 1 FAÇA\n        SE temperaturas[i] &lt; minima ENTÃO\n            minima ← temperaturas[i]\n        FIM SE\n        SE temperaturas[i] &gt; maxima ENTÃO\n            maxima ← temperaturas[i]\n        FIM SE\n    FIM PARA\nFIM\n\nFUNÇÃO calcularDesvio(temperaturas: real[], quantidade: inteiro, media: real): real\nINÍCIO\n    SE quantidade = 0 ENTÃO\n        RETORNAR 0.0\n    FIM SE\n    soma ← 0.0\n    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n        soma ← soma + (temperaturas[i] - media) * (temperaturas[i] - media)\n    FIM PARA\n    RETORNAR RAIZ_QUADRADA(soma / quantidade)\nFIM\n\nFUNÇÃO exibirMenu(): void\nINÍCIO\n    ESCREVER \"=== MENU PRINCIPAL ===\"\n    ESCREVER \"1. Registrar temperaturas\"\n    ESCREVER \"2. Relatório por dia\"\n    ESCREVER \"3. Relatório mensal\"\n    ESCREVER \"0. Sair\"\nFIM\n\nFUNÇÃO VALIDAR_DATA(data: string): booleano\nINÍCIO\n    SE tamanho(data) ≠ 10 OU data[2] ≠ '/' OU data[5] ≠ '/' ENTÃO\n        RETORNAR FALSO\n    FIM SE\n    TENTAR\n        dia ← CONVERTER_PARA_INTEIRO(data[0:2])\n        mes ← CONVERTER_PARA_INTEIRO(data[3:5])\n        ano ← CONVERTER_PARA_INTEIRO(data[6:10])\n        SE dia ≥ 1 E dia ≤ 31 E mes ≥ 1 E mes ≤ 12 E ano ≥ 2000 E ano ≤ 2100 ENTÃO\n            RETORNAR VERDADEIRO\n        FIM SE\n    SENÃO\n        RETORNAR FALSO\n    FIM TENTAR\n    RETORNAR FALSO\nFIM\n\nFUNÇÃO VALIDAR_MES_ANO(mesAno: string): booleano\nINÍCIO\n    SE tamanho(mesAno) ≠ 7 OU mesAno[2] ≠ '/' ENTÃO\n        RETORNAR FALSO\n    FIM SE\n    TENTAR\n        mes ← CONVERTER_PARA_INTEIRO(mesAno[0:2])\n        ano ← CONVERTER_PARA_INTEIRO(mesAno[3:7])\n        SE mes ≥ 1 E mes ≤ 12 E ano ≥ 2000 E ano ≤ 2100 ENTÃO\n            RETORNAR VERDADEIRO\n        FIM SE\n    SENÃO\n        RETORNAR FALSO\n    FIM TENTAR\n    RETORNAR FALSO\nFIM\n\nFUNÇÃO FORMATAR_HORA(indice: inteiro): string\nINÍCIO\n    hora ← indice\n    RETORNAR to_string(hora) + \":00\"\nFIM\n\n\n7.2.5.2 Decomposição: Divisão de Tarefas para o Problema L2\nO problema L2 propõe um sistema para gerenciar dados de temperatura coletados por sensores durante um mês, armazenando até 30 temperaturas diárias em um array, salvando em um arquivo CSV e gerando estatísticas (média, extremos, desvio padrão) e relatórios. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.\nAluno 1: Função lerTemperaturas e Validação de Entrada\nResponsabilidades:\n\nImplementar lerTemperaturas(float temperaturas[], int& quantidade, string data) para coletar até 30 temperaturas diárias (em °C, com uma casa decimal) via linha de comando, separadas por vírgulas, associadas a uma data específica.\nValidar:\n\nTemperaturas como valores float, com uma casa decimal (ex.: 23.5);\nQuantidade de temperaturas não exceder 30;\nData no formato “DD/MM/AAAA” (ex.: 01/07/2025);\nNão zerar quantidade para preservar registros anteriores;\n\nPermitir entrada de múltiplas temperaturas em uma única linha (ex.: “23.5,24.0,22.8”) ou uma por vez até o usuário indicar “sair”;\nTratar buffer de entrada adequadamente (ex.: corrigir uso de std::cin.ignore em C++).\n\nTarefas específicas:\n\nEscrever a função com entrada via getline para data e temperaturas;\nValidar data (ex.: verificar formato “DD/MM/AAAA” com 10 caracteres e barras corretas);\nValidar temperaturas (ex.: converter com stod, verificar uma casa decimal usando round);\nAdicionar temperaturas ao array a partir do índice quantidade;\nTestar isoladamente com entradas válidas (ex.: “01/07/2025,23.5,24.0”) e inválidas (ex.: “01-07-2025”, “23.55”, ““).\n\nInterface:\n\nRecebe temperaturas[], quantidade e data como parâmetros;\nFornece dados válidos para gravarTemperaturas e análises.\n\nAluno 2: Função gravarTemperaturas e Inicialização do Arquivo\nResponsabilidades:\n\nImplementar gravarTemperaturas(const float temperaturas[], int quantidade, const string& data) para gravar temperaturas em temperaturas.csv (formato: “Data,Hora,Temperatura”);\nAdicionar registros ao arquivo (ex.: std::ios::app em C++) sem sobrescrever dados anteriores;\nImplementar inicializarArquivo() para criar o arquivo CSV com cabeçalho “Data,Hora,Temperatura” se não existir;\nVerificar erros ao abrir/escrever no arquivo.\n\nTarefas específicas:\n\nGravar cada temperatura com data, hora (ex.: “00:00” a “23:00”) e valor em uma linha do CSV;\nVerificar abertura do arquivo e exibir mensagens de erro;\nTestar isoladamente com diferentes quantidades de temperaturas e verificar o arquivo gerado.\n\nInterface:\n\nRecebe temperaturas[], quantidade e data de lerTemperaturas;\nProduz um arquivo CSV lido por lerDadosTemperaturas.\n\nAluno 3: Função lerDadosTemperaturas e Carregamento Inicial\nResponsabilidades:\n\nImplementar lerDadosTemperaturas(float temperaturas[], int& quantidade, const string& dataFiltro = \"\") para ler o arquivo CSV e preencher o array com temperaturas de um dia específico ou todos os dados;\nSuportar filtragem por dataFiltro (ex.: “01/07/2025”) ou leitura completa se vazio;\nAlertar se o número de temperaturas exceder 30 para um dia;\nCarregar dados do arquivo no início do programa (no main) para sincronizar o array local;\n\nTarefas específicas:\n\nLer o CSV, ignorar o cabeçalho e preencher o array com temperaturas;\nImplementar filtragem por dataFiltro quando não vazio;\nContar registros e alertar se exceder 30 por dia;\nModificar o main para chamar lerDadosTemperaturas no início;\nTestar com arquivos CSV vazios, com menos de 30 temperaturas e com múltiplos dias.\n\nInterface:\n\nLê o arquivo CSV de gravarTemperaturas;\nFornece dados para calcularEstatisticas e encontrarExtremos.\n\nAluno 4: Funções calcularEstatisticas, encontrarExtremos, calcularDesvio, Relatório e Interface do Usuário\nResponsabilidades:\n\nImplementar calcularEstatisticas(const float temperaturas[], int quantidade, float& media) para calcular a média das temperaturas;\nImplementar encontrarExtremos(const float temperaturas[], int quantidade, float& minima, float& maxima) para identificar temperaturas mínima e máxima;\nImplementar calcularDesvio(const float temperaturas[], int quantidade, float media) para calcular o desvio padrão;\nImplementar o relatório completo (opção 3 do menu) para listar estatísticas do mês (média, extremos, desvio padrão, dias com temperaturas extremas);\nEscrever exibirMenu() e gerenciar a interface no main, corrigindo problemas de buffer (ex.: std::cin.ignore em C++);\nGarantir saídas formatadas (ex.: uma casa decimal para temperaturas e média, duas casas para desvio padrão).\n\nTarefas específicas:\n\nCalcular média, extremos e desvio padrão para um dia ou mês;\nIdentificar dias com temperaturas extremas (ex.: fora de 2 desvios padrão da média mensal);\nChamar lerDadosTemperaturas com filtro de data para relatórios diários;\nImplementar relatório completo no main, usando lerDadosTemperaturas sem filtro;\nCorrigir std::cin.ignore no main (ex.: std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') após leitura de opção);\nTestar com busca de dias existentes/inexistentes, relatórios diários e mensais.\n\nInterface:\n\nUsa dados de lerDadosTemperaturas para exibir resultados;\nInterage com o usuário, fornecendo datas para lerTemperaturas e relatórios.\n\n\n\n7.2.5.3 Considerações para Integração\nInterfaces:\n\nOs alunos devem concordar com o formato do CSV (“Data,Hora,Temperatura”) e a estrutura do array temperaturas[];\nO array armazena até 30 temperaturas por dia, e quantidade rastreia o número de registros.\n\nDepuração:\n\nCada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos);\n\nPassos importantes da integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir inicializarArquivo e gravarTemperaturas do Aluno 2;\nAdicionar lerDadosTemperaturas do Aluno 3, ajustando o main para carregar dados iniciais;\nIncluir lerTemperaturas do Aluno 1, calcularEstatisticas, encontrarExtremos e calcularDesvio do Aluno 4.\n\nResolução de conflitos:\n\nDiscutir problemas imediatamente na sala (ex.: formato do CSV, validação de data);\nTestar o programa completo com cenários como registrar temperaturas, buscar por dia e exibir relatórios.\n\nDepuração:\n\nVerificar registro de temperaturas, busca por dia, e relatório mensal com estatísticas;\nTestar casos extremos (arquivo vazio, data inválida, mais de 30 temperaturas).\n\n\n\n7.2.5.4 Código C++23\nO código correspondente ao problema L2 pode ser encontrado em https://onlinegdb.com/zAYiGjouh.\n\n\n\n7.2.6 M2\nUm laboratório de pesquisas precisa de uma calculadora que mantenha histórico completo das operações para auditoria e análise posterior. A calculadora deve realizar operações complexas e permitir análise estatística do histórico. Desenvolva uma calculadora científica que execute operações matemáticas avançadas, mantenha um array com histórico das operações, permita buscar operações anteriores e calcule estatísticas sobre o uso.\nFunções a implementar:\n\nFunções próprias: adicionarHistorico(), mostrarHistorico(), buscarOperacao(), analisarUso()\nFunções padrão: sin(), cos(), tan(), exp(), log10()\n\nEntrada: Expressões matemáticas e comandos de histórico Saída: Resultados, histórico completo e análises estatísticas de uso\n\n7.2.6.1 Algoritmização: Pseudocódigo\nALGORITMO CalculadoraCientifica\n\n    // Constantes\n    MAX_OPERACOES ← 100\n    ARQUIVO ← \"historico.csv\"\n\n    // Declaração de arrays\n    historico[MAX_OPERACOES]: string\n    quantidade: inteiro\n\nINÍCIO\n    // Inicializar sistema\n    ESCREVER \"=== Calculadora Científica com Histórico ===\"\n    ESCREVER \"Inicializando sistema...\"\n    inicializarArquivo()\n\n    // Carregar dados existentes\n    mostrarHistorico(historico, quantidade)\n\n    FAÇA\n        exibirMenu()\n        ESCREVER \"Escolha uma opção: \"\n        LER opcao\n\n        SE opcao = 1 ENTÃO\n            ESCREVER \"Digite a expressão matemática (ou 'sair'): \"\n            LER expressao\n            SE expressao ≠ \"sair\" ENTÃO\n                SE VALIDAR_EXPRESSAO(expressao) ENTÃO\n                    resultado ← CALCULAR_EXPRESSAO(expressao)\n                    adicionarHistorico(historico, quantidade, expressao, resultado)\n                    gravarHistorico(historico, quantidade)\n                    ESCREVER \"Resultado: \", ARREDONDAR(resultado, 2)\n                SENÃO\n                    ESCREVER \"Expressão inválida! Use sin(), cos(), tan(), exp(), log10() ou operações básicas.\"\n                FIM SE\n            FIM SE\n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite a expressão para busca (ex.: 'sin', ou vazio para todas): \"\n            LER expressaoFiltro\n            buscarOperacao(expressaoFiltro)\n        SENÃO SE opcao = 3 ENTÃO\n            historicoTemp[MAX_OPERACOES]: string\n            totalRegistros: inteiro\n            SE mostrarHistorico(historicoTemp, totalRegistros) = FALSO ENTÃO\n                ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n            SENÃO SE totalRegistros = 0 ENTÃO\n                ESCREVER \"Nenhuma operação encontrada!\"\n            SENÃO\n                ESCREVER \"=== RELATÓRIO COMPLETO ===\"\n                PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n                    SEPARAR(historicoTemp[i], \",\", expressao, resultadoStr)\n                    TENTAR\n                        resultado ← CONVERTER_PARA_REAL(resultadoStr)\n                        ESCREVER \"Operação \", i + 1, \": \", expressao, \" = \", ARREDONDAR(resultado, 2)\n                    SENÃO\n                        ESCREVER \"Erro ao processar resultado em: \", historicoTemp[i]\n                    FIM TENTAR\n                FIM PARA\n                ESCREVER \"Total de operações: \", totalRegistros\n                analisarUso(historicoTemp, totalRegistros)\n            FIM SE\n        SENÃO SE opcao = 0 ENTÃO\n            ESCREVER \"Encerrando sistema...\"\n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n\n        SE opcao ≠ 0 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    ENQUANTO opcao ≠ 0\n\nFIM\n\nFUNÇÃO adicionarHistorico(historico: string[], quantidade: inteiro, expressao: string, resultado: real): void\nINÍCIO\n    SE quantidade ≥ MAX_OPERACOES ENTÃO\n        ESCREVER \"Limite de operações atingido!\"\n        RETORNAR\n    FIM SE\n\n    SE expressao = \"\" OU expressao CONTER \",\" ENTÃO\n        ESCREVER \"Expressão inválida! Deve ser não vazia e sem vírgulas.\"\n        RETORNAR\n    FIM SE\n\n    historico[quantidade] ← expressao + \",\" + to_string(ARREDONDAR(resultado, 2))\n    quantidade ← quantidade + 1\nFIM\n\nFUNÇÃO gravarHistorico(historico: string[], quantidade: inteiro): void\nINÍCIO\n    ABRIR arquivo(ARQUIVO, APPEND)\n    SE arquivo NÃO ABERTO ENTÃO\n        ESCREVER \"Erro ao abrir arquivo para gravação!\"\n        RETORNAR\n    FIM SE\n\n    PARA i DE quantidade - 1 ATÉ quantidade - 1 FAÇA\n        ESCREVER_ARQUIVO(arquivo, historico[i])\n    FIM PARA\n    FECHAR arquivo\nFIM\n\nFUNÇÃO mostrarHistorico(historico: string[], quantidade: inteiro, expressaoFiltro: string = \"\"): booleano\nINÍCIO\n    ABRIR arquivo(ARQUIVO, LEITURA)\n    SE arquivo NÃO ABERTO ENTÃO\n        RETORNAR FALSO\n    FIM SE\n\n    quantidade ← 0\n    LER_LINHA(arquivo, linha)\n    SE linha CONTER \"Expressao\" ENTÃO\n        // Cabeçalho detectado\n    SENÃO\n        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)\n    FIM SE\n\n    ENQUANTO LER_LINHA(arquivo, linha) E quantidade &lt; MAX_OPERACOES FAÇA\n        SEPARAR(linha, \",\", expressao, resultadoStr)\n        SE expressaoFiltro = \"\" OU expressao CONTER expressaoFiltro ENTÃO\n            TENTAR\n                resultado ← CONVERTER_PARA_REAL(resultadoStr)\n                historico[quantidade] ← linha\n                quantidade ← quantidade + 1\n            SENÃO\n                // Ignorar linhas inválidas\n            FIM TENTAR\n        FIM SE\n    FIM ENQUANTO\n\n    SE quantidade = MAX_OPERACOES E MAIS_LINHAS(arquivo) ENTÃO\n        ESCREVER \"Aviso: Mais registros no arquivo do que o limite de \", MAX_OPERACOES\n    FIM SE\n\n    FECHAR arquivo\n    RETORNAR VERDADEIRO\nFIM\n\nFUNÇÃO buscarOperacao(expressao: string): void\nINÍCIO\n    historicoTemp[MAX_OPERACOES]: string\n    totalRegistros: inteiro\n\n    SE mostrarHistorico(historicoTemp, totalRegistros, expressao) = FALSO ENTÃO\n        ESCREVER \"Erro ao ler dados!\"\n        RETORNAR\n    FIM SE\n\n    SE totalRegistros = 0 ENTÃO\n        ESCREVER \"Nenhuma operação encontrada para '\", expressao, \"'!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER \"=== OPERAÇÕES COM '\", expressao, \"' ===\"\n    PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n        SEPARAR(historicoTemp[i], \",\", expressaoEncontrada, resultadoStr)\n        TENTAR\n            resultado ← CONVERTER_PARA_REAL(resultadoStr)\n            ESCREVER \"Operação \", i + 1, \": \", expressaoEncontrada, \" = \", ARREDONDAR(resultado, 2)\n        SENÃO\n            ESCREVER \"Erro ao processar resultado em: \", historicoTemp[i]\n        FIM TENTAR\n    FIM PARA\n    ESCREVER \"Total de operações encontradas: \", totalRegistros\nFIM\n\nFUNÇÃO analisarUso(historico: string[], quantidade: inteiro): void\nINÍCIO\n    contSin ← 0\n    contCos ← 0\n    contTan ← 0\n    contExp ← 0\n    contLog ← 0\n    contOutros ← 0\n\n    PARA i DE 0 ATÉ quantidade - 1 FAÇA\n        SEPARAR(historico[i], \",\", expressao, resultadoStr)\n        SE expressao CONTER \"sin(\" ENTÃO\n            contSin ← contSin + 1\n        SENÃO SE expressao CONTER \"cos(\" ENTÃO\n            contCos ← contCos + 1\n        SENÃO SE expressao CONTER \"tan(\" ENTÃO\n            contTan ← contTan + 1\n        SENÃO SE expressao CONTER \"exp(\" ENTÃO\n            contExp ← contExp + 1\n        SENÃO SE expressao CONTER \"log10(\" ENTÃO\n            contLog ← contLog + 1\n        SENÃO\n            contOutros ← contOutros + 1\n        FIM SE\n    FIM PARA\n\n    ESCREVER \"=== ANÁLISE DE USO ===\"\n    ESCREVER \"Operações com sin: \", contSin\n    ESCREVER \"Operações com cos: \", contCos\n    ESCREVER \"Operações com tan: \", contTan\n    ESCREVER \"Operações com exp: \", contExp\n    ESCREVER \"Operações com log10: \", contLog\n    ESCREVER \"Outras operações: \", contOutros\nFIM\n\nFUNÇÃO inicializarArquivo(): void\nINÍCIO\n    SE ARQUIVO NÃO EXISTIR ENTÃO\n        ABRIR arquivo(ARQUIVO, ESCRITA)\n        SE arquivo ABERTO ENTÃO\n            ESCREVER_ARQUIVO(arquivo, \"Expressao,Resultado\")\n            FECHAR arquivo\n            ESCREVER \"Arquivo de dados criado: \", ARQUIVO\n        SENÃO\n            ESCREVER \"Erro ao criar arquivo de dados!\"\n        FIM SE\n    SENÃO\n        ESCREVER \"Arquivo de dados encontrado: \", ARQUIVO\n    FIM SE\nFIM\n\nFUNÇÃO exibirMenu(): void\nINÍCIO\n    ESCREVER \"=== MENU PRINCIPAL ===\"\n    ESCREVER \"1. Realizar operação\"\n    ESCREVER \"2. Buscar operações por expressão\"\n    ESCREVER \"3. Relatório completo\"\n    ESCREVER \"0. Sair\"\nFIM\n\nFUNÇÃO VALIDAR_EXPRESSAO(expressao: string): booleano\nINÍCIO\n    SE expressao = \"\" ENTÃO\n        RETORNAR FALSO\n    FIM SE\n    // Verifica se a expressão contém funções válidas ou operações básicas\n    SE expressao CONTER \"sin(\" OU expressao CONTER \"cos(\" OU expressao CONTER \"tan(\" OU\n       expressao CONTER \"exp(\" OU expressao CONTER \"log10(\" OU\n       expressao CONTER \"+\" OU expressao CONTER \"-\" OU expressao CONTER \"*\" OU expressao CONTER \"/\" ENTÃO\n        RETORNAR VERDADEIRO\n    FIM SE\n    RETORNAR FALSO\nFIM\n\nFUNÇÃO CALCULAR_EXPRESSAO(expressao: string): real\nINÍCIO\n    // Implementação simplificada: supõe que a expressão é válida e usa funções padrão\n    SE expressao CONTER \"sin(\" ENTÃO\n        valor ← EXTRAIR_NUMERO(expressao)\n        RETORNAR SIN(valor)\n    SENÃO SE expressao CONTER \"cos(\" ENTÃO\n        valor ← EXTRAIR_NUMERO(expressao)\n        RETORNAR COS(valor)\n    SENÃO SE expressao CONTER \"tan(\" ENTÃO\n        valor ← EXTRAIR_NUMERO(expressao)\n        RETORNAR TAN(valor)\n    SENÃO SE expressao CONTER \"exp(\" ENTÃO\n        valor ← EXTRAIR_NUMERO(expressao)\n        RETORNAR EXP(valor)\n    SENÃO SE expressao CONTER \"log10(\" ENTÃO\n        valor ← EXTRAIR_NUMERO(expressao)\n        RETORNAR LOG10(valor)\n    SENÃO\n        // Supõe operação básica (ex.: \"2 + 3\")\n        TENTAR\n            resultado ← AVALIAR_OPERACAO_BASICA(expressao)\n            RETORNAR resultado\n        SENÃO\n            RETORNAR 0.0\n        FIM TENTAR\n    FIM SE\nFIM\n\n\n7.2.6.2 Decomposição: Divisão de Tarefas para o Problema M2\nO problema M2 propõe uma calculadora científica que executa operações matemáticas avançadas, armazena um histórico de operações em um array, permite consultas ao histórico e realiza análises estatísticas do uso. O histórico é salvo em um arquivo CSV para auditoria. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.\nAluno 1: Função adicionarHistorico e Validação de Entrada\nResponsabilidades:\n\nImplementar adicionarHistorico(string historico[], int& quantidade, string expressao, real resultado) para coletar e armazenar expressões matemáticas (string) e seus resultados (real) no array de histórico;\nValidar:\n\nExpressão não vazia e sem vírgulas (para evitar corromper o CSV);\nResultado como número real válido;\nQuantidade não exceder MAX_OPERACOES (definido como 100, por exemplo);\n\nInterpretar expressões matemáticas (ex.: “sin(3.14)”, “2 + 3 * 4”, “log10(100)”) e calcular resultados usando sin, cos, tan, exp, log10;\nTratar buffer de entrada adequadamente (ex.: corrigir uso de std::cin.ignore em C++).\n\nTarefas específicas:\n\nEscrever a função para ler expressões via getline e calcular resultados;\nValidar expressão (ex.: if (expressao.empty() || expressao.find(',') != string::npos) em C++);\nAdicionar par “expressao,resultado” ao array a partir do índice quantidade;\nTestar isoladamente com expressões válidas (ex.: “sin(0)”, “2 + 2”) e inválidas (ex.: ““,”sin,a”).\n\nInterface:\n\nRecebe historico[], quantidade, expressao e resultado como parâmetros;\nFornece dados válidos para gravarHistorico e análises.\n\nAluno 2: Função gravarHistorico e Inicialização do Arquivo\nResponsabilidades:\n\nImplementar gravarHistorico(const string historico[], int quantidade) para gravar o histórico em historico.csv (formato: “Expressao,Resultado”);\nAdicionar registros ao arquivo (ex.: std::ios::app em C++) para preservar o histórico anterior;\nImplementar inicializarArquivo() para criar o arquivo CSV com cabeçalho “Expressao,Resultado” se não existir;\nVerificar erros ao abrir/escrever no arquivo.\n\nTarefas específicas:\n\nGravar cada entrada do histórico (expressão e resultado) em uma linha do CSV;\nVerificar abertura do arquivo e exibir mensagens de erro;\nTestar isoladamente com diferentes tamanhos de arrays e verificar o arquivo gerado.\n\nInterface:\n\nRecebe historico[] e quantidade de adicionarHistorico;\nProduz um arquivo CSV lido por mostrarHistorico.\n\nAluno 3: Função mostrarHistorico e Carregamento Inicial\nResponsabilidades:\n\nImplementar mostrarHistorico(string historico[], int& quantidade, const string& expressaoFiltro = \"\") para ler o arquivo CSV e preencher o array com o histórico, filtrando por expressão (substring) se especificado;\nSuportar leitura de todo o histórico ou filtragem por expressaoFiltro;\nAlertar se o número de operações exceder MAX_OPERACOES;\nCarregar dados do arquivo no início do programa (no main) para sincronizar o array local.\n\nTarefas específicas:\n\nLer o CSV, ignorar o cabeçalho e preencher o array com strings no formato “expressao,resultado”;\nImplementar filtragem por expressaoFiltro quando não vazio;\nContar registros e alertar se exceder MAX_OPERACOES;\nModificar o main para chamar mostrarHistorico no início;\nTestar com arquivos CSV vazios, com poucas operações e com mais de 100.\n\nInterface:\n\nLê o arquivo CSV de gravarHistorico;\nFornece dados para buscarOperacao e análises.\n\nAluno 4: Função buscarOperacao, analisarUso, Relatório e Interface do Usuário\nResponsabilidades:\n\nImplementar buscarOperacao(const string& expressao) para exibir operações cujo nome (ex.: “sin”, “cos”) ou expressão completa contenha a substring fornecida;\nImplementar analisarUso(const string historico[], int quantidade) para calcular estatísticas de uso (ex.: número de operações por tipo, frequência de cada função);\nImplementar o relatório completo (opção 3 do menu) para listar todo o histórico e estatísticas de uso;\nEscrever exibirMenu() e gerenciar a interface no main, corrigindo problemas de buffer (ex.: std::cin.ignore em C++);\nGarantir saídas formatadas (ex.: resultados com duas casas decimais, mensagens claras).\n\nTarefas específicas:\n\nChamar mostrarHistorico com filtro de expressão para buscas;\nImplementar análise estatística (ex.: contar uso de sin, cos, etc.);\nImplementar relatório completo no main, usando mostrarHistorico sem filtro;\nCorrigir std::cin.ignore no main (ex.: std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') após leitura de opção);\nTestar com busca de expressões existentes/inexistentes e relatórios.\n\nInterface:\n\nUsa dados de mostrarHistorico para exibir resultados;\nInterage com o usuário, fornecendo expressões para adicionarHistorico e buscarOperacao.\n\n\n\n7.2.6.3 Considerações para Integração\nInterfaces:\n\nOs alunos devem concordar com o formato do CSV (“Expressao,Resultado”) e a estrutura do array historico[] (strings no formato “expressao,resultado”);\nO array armazena até MAX_OPERACOES entradas, e quantidade rastreia o número de registros.\n\nDepuração:\n\nCada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, arrays pré-preenchidos).\n\nPassos importantes da integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir inicializarArquivo e gravarHistorico do Aluno 2;\nAdicionar mostrarHistorico do Aluno 3, ajustando o main para carregar dados iniciais;\nIncluir adicionarHistorico, buscarOperacao e analisarUso do Aluno 4.\n\nResolução de conflitos:\n\nDiscutir problemas imediatamente na sala (ex.: formato do CSV, validação de expressões);\nTestar o programa completo com cenários como adicionar operações, buscar por expressão e exibir relatórios.\n\nDepuração:\n\nVerificar registro de operações, busca por expressão, e relatório com estatísticas.\nTestar casos extremos (arquivo vazio, expressão inválida, mais de 100 operações).\n\n\n\n7.2.6.4 Código C++23\nO código correspondente ao problema M2 pode ser encontrado em https://onlinegdb.com/UHaBupDCz.\n\n\n\n7.2.7 N2\nUma loja de departamentos precisa organizar as vendas diárias por categoria de produtos. Cada categoria (ex.: “Roupas”, “Eletrônicos”) contém uma lista de valores de vendas (decimais). O programa deve usar vetores de vetores para armazenar as vendas, salvar em disco e permitir consultas. Desenvolva um sistema que registre vendas por categoria, mantenha os dados em vetores de vetores, salve em um arquivo CSV e permita consultar todas as vendas ou as de uma categoria específica.\nFunções a implementar:\n\nFunções próprias: registrarVendas(), salvarVendas(), lerVendas(), buscarVendasCategoria()\nFunções padrão: getline(), stod(), to_string()\n\nEntrada: Nome da categoria (string) e valores de vendas (decimais, positivos) Saída: Lista de todas as vendas por categoria ou vendas de uma categoria específica, com soma total das vendas\n\n7.2.7.1 Algoritmização: Pseudocódigo\nALGORITMO GerenciadorVendas\n\n    // Constantes\n    MAX_CATEGORIAS ← 50\n    ARQUIVO ← \"vendas.csv\"\n\n    // Declaração de vetores\n    vendas: vetor de vetores de real\n    categorias: vetor de string\n    numCategorias: inteiro\n\nINÍCIO\n    // Inicializar sistema\n    ESCREVER \"=== Sistema de Gerenciamento de Vendas ===\"\n    ESCREVER \"Inicializando sistema...\"\n    inicializarArquivo()\n\n    // Carregar dados existentes\n    lerVendas(vendas, categorias, numCategorias)\n\n    FAÇA\n        exibirMenu()\n        ESCREVER \"Escolha uma opção: \"\n        LER opcao\n\n        SE opcao = 1 ENTÃO\n            registrarVendas(vendas, categorias, numCategorias)\n            salvarVendas(vendas, categorias, numCategorias)\n            ESCREVER \"Venda(s) registrada(s).\"\n        SENÃO SE opcao = 2 ENTÃO\n            ESCREVER \"Digite a categoria para busca: \"\n            LER categoria\n            buscarVendasCategoria(categoria)\n        SENÃO SE opcao = 3 ENTÃO\n            vendasTemp: vetor de vetores de real\n            categoriasTemp: vetor de string\n            totalRegistros: inteiro\n            SE lerVendas(vendasTemp, categoriasTemp, totalRegistros) = FALSO ENTÃO\n                ESCREVER \"Erro ao ler dados ou arquivo não encontrado!\"\n            SENÃO SE totalRegistros = 0 ENTÃO\n                ESCREVER \"Nenhuma venda encontrada!\"\n            SENÃO\n                ESCREVER \"=== RELATÓRIO COMPLETO ===\"\n                somaTotal ← 0.0\n                PARA i DE 0 ATÉ totalRegistros - 1 FAÇA\n                    ESCREVER \"Categoria: \", categoriasTemp[i]\n                    somaCategoria ← 0.0\n                    PARA CADA valor EM vendasTemp[i] FAÇA\n                        ESCREVER \"  Venda: R$\", ARREDONDAR(valor, 2)\n                        somaCategoria ← somaCategoria + valor\n                    FIM PARA\n                    ESCREVER \"  Soma da categoria: R$\", ARREDONDAR(somaCategoria, 2)\n                    somaTotal ← somaTotal + somaCategoria\n                FIM PARA\n                ESCREVER \"Total de categorias: \", totalRegistros\n                ESCREVER \"Soma total das vendas: R$\", ARREDONDAR(somaTotal, 2)\n            FIM SE\n        SENÃO SE opcao = 0 ENTÃO\n            ESCREVER \"Encerrando sistema...\"\n        SENÃO\n            ESCREVER \"Opção inválida! Tente novamente.\"\n        FIM SE\n\n        SE opcao ≠ 0 ENTÃO\n            ESCREVER \"Pressione Enter para continuar...\"\n            LER pausa\n        FIM SE\n    ENQUANTO opcao ≠ 0\n\nFIM\n\nFUNÇÃO registrarVendas(vendas: vetor de vetores de real, categorias: vetor de string, numCategorias: inteiro): void\nINÍCIO\n    FAÇA\n        ESCREVER \"Digite a categoria (ou 'sair' para encerrar): \"\n        LER categoria\n        SE categoria = \"sair\" ENTÃO\n            RETORNAR\n        FIM SE\n\n        SE categoria = \"\" OU categoria CONTER \",\" ENTÃO\n            ESCREVER \"Categoria inválida! Deve ser não vazia e sem vírgulas.\"\n            CONTINUAR\n        FIM SE\n\n        indiceCategoria ← -1\n        PARA i DE 0 ATÉ numCategorias - 1 FAÇA\n            SE categorias[i] = categoria ENTÃO\n                indiceCategoria ← i\n                SAIR\n            FIM SE\n        FIM PARA\n\n        SE indiceCategoria = -1 ENTÃO\n            SE numCategorias ≥ MAX_CATEGORIAS ENTÃO\n                ESCREVER \"Limite de categorias atingido!\"\n                RETORNAR\n            FIM SE\n            categorias[numCategorias] ← categoria\n            vendas[numCategorias]: novo vetor de real\n            indiceCategoria ← numCategorias\n            numCategorias ← numCategorias + 1\n        FIM SE\n\n        ESCREVER \"Digite o valor da venda (positivo, ou 'sair'): \"\n        LER entrada\n        SE entrada = \"sair\" ENTÃO\n            CONTINUAR\n        FIM SE\n\n        TENTAR\n            valor ← CONVERTER_PARA_REAL(entrada)\n            SE valor &gt; 0 ENTÃO\n                vendas[indiceCategoria].ADICIONAR(valor)\n            SENÃO\n                ESCREVER \"Valor inválido! Deve ser positivo.\"\n            FIM SE\n        SENÃO\n            ESCREVER \"Valor inválido para venda. Ignorado.\"\n        FIM TENTAR\n    ENQUANTO VERDADEIRO\nFIM\n\nFUNÇÃO salvarVendas(vendas: vetor de vetores de real, categorias: vetor de string, numCategorias: inteiro): void\nINÍCIO\n    ABRIR arquivo(ARQUIVO, SOBRESCREVER)\n    SE arquivo NÃO ABERTO ENTÃO\n        ESCREVER \"Erro ao abrir arquivo para gravação!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER_ARQUIVO(arquivo, \"Categoria,Valor\")\n    PARA i DE 0 ATÉ numCategorias - 1 FAÇA\n        PARA CADA valor EM vendas[i] FAÇA\n            ESCREVER_ARQUIVO(arquivo, categorias[i], \",\", ARREDONDAR(valor, 2))\n        FIM PARA\n    FIM PARA\n    FECHAR arquivo\nFIM\n\nFUNÇÃO lerVendas(vendas: vetor de vetores de real, categorias: vetor de string, numCategorias: inteiro, categoriaFiltro: string = \"\"): booleano\nINÍCIO\n    ABRIR arquivo(ARQUIVO, LEITURA)\n    SE arquivo NÃO ABERTO ENTÃO\n        RETORNAR FALSO\n    FIM SE\n\n    numCategorias ← 0\n    vendas.LIMPAR()\n    categorias.LIMPAR()\n\n    LER_LINHA(arquivo, linha)\n    SE linha CONTER \"Categoria\" ENTÃO\n        // Cabeçalho detectado\n    SENÃO\n        REPOSICIONAR_ARQUIVO(arquivo, INÍCIO)\n    FIM SE\n\n    ENQUANTO LER_LINHA(arquivo, linha) FAÇA\n        SEPARAR(linha, \",\", categoria, valorStr)\n        SE categoriaFiltro = \"\" OU categoria = categoriaFiltro ENTÃO\n            TENTAR\n                valor ← CONVERTER_PARA_REAL(valorStr)\n                indiceCategoria ← -1\n                PARA i DE 0 ATÉ numCategorias - 1 FAÇA\n                    SE categorias[i] = categoria ENTÃO\n                        indiceCategoria ← i\n                        SAIR\n                    FIM SE\n                FIM PARA\n                SE indiceCategoria = -1 ENTÃO\n                    categorias[numCategorias] ← categoria\n                    vendas[numCategorias]: novo vetor de real\n                    indiceCategoria ← numCategorias\n                    numCategorias ← numCategorias + 1\n                FIM SE\n                vendas[indiceCategoria].ADICIONAR(valor)\n            SENÃO\n                // Ignorar linhas inválidas\n            FIM TENTAR\n        FIM SE\n    FIM ENQUANTO\n\n    FECHAR arquivo\n    RETORNAR VERDADEIRO\nFIM\n\nFUNÇÃO buscarVendasCategoria(categoria: string): void\nINÍCIO\n    vendasTemp: vetor de vetores de real\n    categoriasTemp: vetor de string\n    totalRegistros: inteiro\n\n    SE lerVendas(vendasTemp, categoriasTemp, totalRegistros, categoria) = FALSO ENTÃO\n        ESCREVER \"Erro ao ler dados!\"\n        RETORNAR\n    FIM SE\n\n    SE totalRegistros = 0 ENTÃO\n        ESCREVER \"Nenhuma venda encontrada para '\", categoria, \"'!\"\n        RETORNAR\n    FIM SE\n\n    ESCREVER \"=== VENDAS DA CATEGORIA \", categoria, \" ===\"\n    somaCategoria ← 0.0\n    PARA CADA valor EM vendasTemp[0] FAÇA\n        ESCREVER \"Venda: R$\", ARREDONDAR(valor, 2)\n        somaCategoria ← somaCategoria + valor\n    FIM PARA\n    ESCREVER \"Soma da categoria: R$\", ARREDONDAR(somaCategoria, 2)\n    ESCREVER \"Total de vendas: \", tamanho(vendasTemp[0])\nFIM\n\nFUNÇÃO inicializarArquivo(): void\nINÍCIO\n    SE ARQUIVO NÃO EXISTIR ENTÃO\n        ABRIR arquivo(ARQUIVO, ESCRITA)\n        SE arquivo ABERTO ENTÃO\n            ESCREVER_ARQUIVO(arquivo, \"Categoria,Valor\")\n            FECHAR arquivo\n            ESCREVER \"Arquivo de dados criado: \", ARQUIVO\n        SENÃO\n            ESCREVER \"Erro ao criar arquivo de dados!\"\n        FIM SE\n    SENÃO\n        ESCREVER \"Arquivo de dados encontrado: \", ARQUIVO\n    FIM SE\nFIM\n\nFUNÇÃO exibirMenu(): void\nINÍCIO\n    ESCREVER \"=== MENU PRINCIPAL ===\"\n    ESCREVER \"1. Registrar vendas\"\n    ESCREVER \"2. Buscar vendas por categoria\"\n    ESCREVER \"3. Relatório completo\"\n    ESCREVER \"0. Sair\"\nFIM\n\n\n7.2.7.2 Decomposição: Divisão de Tarefas para o Problema N2\nO problema N2 propõe um sistema para gerenciar vendas diárias de uma loja de departamentos, organizadas por categorias de produtos, usando vetores de vetores para armazenar valores de vendas (decimais), com persistência em arquivo CSV e funcionalidades de registro, salvamento, leitura e consulta por categoria. Abaixo está a divisão de tarefas entre quatro alunos, trabalhando independentemente na mesma sala, sem controle de versão, com interfaces claras para facilitar a integração. O pseudocódigo completo é apresentado em seguida.\nAluno 1: Função registrarVendas e Validação de Entrada\nResponsabilidades:\n\nImplementar registrarVendas(vetor de vetores de real vendas, vetor de string categorias, inteiro& numCategorias) para coletar nome da categoria (string) e valores de vendas (decimais, positivos).\nValidar:\n\nNome da categoria não vazio e sem vírgulas (para evitar corromper o CSV);\nValores de vendas como decimais positivos, usando stod com tratamento de exceções;\nPermitir múltiplas vendas por categoria até o usuário indicar “sair”;\n\nAdicionar nova categoria ao vetor categorias se não existir, ou atualizar o vetor de vendas da categoria existente.\n\nTarefas específicas:\n\nEscrever a função com entrada via getline para categoria e valores de vendas;\nValidar categoria (ex.: if (categoria.empty() || categoria.find(',') != string::npos) em C++);\nValidar vendas (ex.: converter com stod, verificar se positivo);\nAdicionar vendas ao vetor de vetores, criando nova entrada em categorias se necessário;\nTestar isoladamente com entradas válidas (ex.: “Roupas,29.99,49.99”) e inválidas (ex.: ““,”Eletrônicos,pão”, “-10.0”).\n\nInterface:\n\nRecebe vendas (vetor de vetores de real), categorias (vetor de string) e numCategorias como parâmetros;\nFornece dados válidos para salvarVendas e consultas.\n\nAluno 2: Função salvarVendas e Inicialização do Arquivo\nResponsabilidades:\n\nImplementar salvarVendas(const vetor de vetores de real vendas, const vetor de string categorias, inteiro numCategorias) para gravar vendas em vendas.csv (formato: “Categoria,Valor”);\nSobrescrever o arquivo (ex.: std::ios::trunc em C++) para evitar duplicatas;\nImplementar inicializarArquivo() para criar o arquivo CSV com cabeçalho “Categoria,Valor” se não existir.\nVerificar erros ao abrir/escrever no arquivo;\n\nTarefas específicas:\n\nGravar cada venda com sua categoria em uma linha do CSV, sobrescrevendo o arquivo;\nPreservar o cabeçalho ao sobrescrever;\nVerificar abertura do arquivo e exibir mensagens de erro;\nTestar isoladamente com diferentes tamanhos de vetores e verificar o arquivo gerado.\n\nInterface:\n\nRecebe vendas, categorias e numCategorias de registrarVendas;\nProduz um arquivo CSV lido por lerVendas.\n\nAluno 3: Função lerVendas e Carregamento Inicial\nResponsabilidades:\n\nImplementar lerVendas(vetor de vetores de real vendas, vetor de string categorias, inteiro& numCategorias, const string& categoriaFiltro = \"\") para ler o arquivo CSV e preencher os vetores;\nSuportar leitura de todas as vendas ou filtragem por categoria (exata);\nCarregar dados do arquivo no início do programa (no main) para sincronizar os vetores locais.\n\nTarefas específicas:\n\nLer o CSV, ignorar o cabeçalho e preencher vendas e categorias;\nImplementar filtragem por categoriaFiltro quando não vazio;\nModificar o main para chamar lerVendas no início;\nTestar com arquivos CSV vazios, com poucas vendas e com múltiplas categorias.\n\nInterface:\n\nLê o arquivo CSV de salvarVendas;\nFornece dados para buscarVendasCategoria e relatório completo.\n\nAluno 4: Função buscarVendasCategoria, Relatório e Interface do Usuário\nResponsabilidades:\n\nImplementar buscarVendasCategoria(const string& categoria) para exibir vendas de uma categoria específica, com soma dos valores;\nImplementar o relatório completo (opção 3 do menu) para listar todas as vendas por categoria e a soma total;\nEscrever exibirMenu() e gerenciar a interface no main, corrigindo problemas de buffer (ex.: std::cin.ignore em C++);\nGarantir saídas formatadas (ex.: valores com duas casas decimais, mensagens claras).\n\nTarefas específicas:\n\nChamar lerVendas com filtro de categoria e exibir resultados com soma;\nImplementar relatório completo no main, usando lerVendas sem filtro;\nCorrigir std::cin.ignore no main (ex.: std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n') após leitura de opção);\nTestar com busca de categorias existentes/inexistentes e relatórios.\n\nInterface:\n\nUsa dados de lerVendas para exibir resultados;\nInterage com o usuário, fornecendo categorias para registrarVendas e buscarVendasCategoria.\n\n\n\n7.2.7.3 Considerações para Integração\nInterfaces:\n\nOs alunos devem concordar com o formato do CSV (“Categoria,Valor”) e a estrutura dos vetores (vendas como vetor de vetores de real, categorias como vetor de string);\nO número de categorias é rastreado por numCategorias.\n\nTestes unitários:\n\nCada aluno deve depurar sua parte isoladamente, simulando entradas/saídas (ex.: arquivos de teste, vetores pré-preenchidos).\n\nPassos importantes da integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir inicializarArquivo e salvarVendas do Aluno 2;\nAdicionar lerVendas do Aluno 3, ajustando o main para carregar dados iniciais;\nIncluir registrarVendas do Aluno 1 e buscarVendasCategoria do Aluno 4.\n\nResolução de conflitos:\n\nDiscutir problemas imediatamente na sala (ex.: formato do CSV, tratamento de buffer);\nTestar o programa completo com cenários como registrar vendas, buscar por categoria e exibir relatórios.\n\nTeste conjunto:\n\nVerificar registro de vendas, busca por categoria, e relatório completo com soma total;\nTestar casos extremos (arquivo vazio, categoria não encontrada, múltiplas vendas);\n\n\n\n7.2.7.4 Código C++23\nO código correspondente ao problema N2 pode ser encontrado em https://onlinegdb.com/t5M4rGaOm3.\n\n\n\n\n[1] PYTHON SOFTWARE FOUNDATION. The Python Language Reference. Disponível em: &lt;https://docs.python.org/3/reference/index.html&gt;. Acesso em: 13 jul. 2025. \n\n\n[2] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. Information technology – Programming languages – C++. Geneva, Switzerland: International Organization for Standardization (ISO), 2020. Disponível em: &lt;https://isocpp.org/std/the-standard&gt;.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>**Módulo 2**: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span>"
    ]
  },
  {
    "objectID": "desenv3.html",
    "href": "desenv3.html",
    "title": "8  Módulo 3: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados",
    "section": "",
    "text": "8.1 Atividade A3: O Desafio da Ordenação\nO objetivo desta atividade é levar os alunos a deduzir, formalizar e analisar algoritmos de ordenação através da experimentação prática, aplicando princípios da neurociência cognitiva a fim de maximizar a retenção e transferência do conhecimento. O foco desta disciplina está na aplicação das teorias da descoberta ativa, prática de recuperação estruturada e desenvolvimento metacognitivo (3).\nMateriais: para cada grupo prepare os seguintes materiais:\nDuração Total: 90 minutos (distribuição baseada na teoria do spacing effect para melhor consolidação)",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span>"
    ]
  },
  {
    "objectID": "desenv3.html#sec-Atividade-A3",
    "href": "desenv3.html#sec-Atividade-A3",
    "title": "8  Módulo 3: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados",
    "section": "",
    "text": "Um conjunto de 7-9 cartas numeradas;\nEnvelope A: contendo cartas em ordem aleatória, para cada grupo (ex: [3, 1, 6, 2, 5, 4]);\nEnvelope B: contendo cartas representando o “melhor caso”, para cada grupo (ex: [1, 2, 3, 5, 4, 6], quase ordenado);\nEnvelope C: contendo cartas representando o “pior caso”, para cada grupo (ex: [8, 7, 6, 5, 4, 3], ordem inversa);\nFolhas para rascunho de pseudocódigo/fluxograma;\nFolhas para a Tabela de Rastreio para depuração;\nCanetas azuis, vermelhas e verdes para marcação de comparações e trocas, para cada grupo;\nFolha de Reflexão Metacognitiva.\nQuadro branco e marcadores coloridos, para o professor apresentar os conceitos e guiar a discussão.\n\n\n\n8.1.1 Etapa 0: Ativação de Esquemas e Retrieval Practice (10 minutos)\nFundamentação: A ativação de conhecimento prévio facilita a criação de conexões neurais mais robustas (1).\nMaterial: Quadro branco, marcadores coloridos, alunos divididos em grupos.\n\nWarm-up - Retrieval Practice (5 min):\n\nInstrução: “Sem consultar qualquer material, online ou impresso, listem em 2 minutos tudo que sabem sobre:\n\nComo identificar eficiência de algoritmos;\nEstratégias que usam para resolver problemas de ordenação no dia a dia.\n\nObjetivo: ativar estruturas cognitivas relacionadas ao conhecimento necessário, antes da nova aprendizagem.\n\nAtivação de Esquemas (5 min):\n\nInstrução: Antes de abrir os envelopes, ordenem estes cenários do dia a dia:\n\nFila de banco por chegada\nProdutos por preço\n\nEmails por prioridade\n\nQue estratégias mentais vocês usaram? Anotem 2-3 padrões comuns.”\nObjetivo: estabelecer conexões entre conhecimento cotidiano e algoritmos formais\n\n\nNota: Informe aos alunos que os envelopes, cartas, canetas, serão devolvidos no final da tarefa juntamente com os pseudocódigos e fluxogramas que eles criarem. Este material será usado na próxima aula.\n\n\n8.1.2 Etapa 1: Descoberta Estruturada com Decomposição (22 minutos)\nFundamentação: A decomposição com o agrupamento de tarefas, reduz sobrecarga cognitiva permitindo um processamento mais profundo (1).\n\n8.1.2.1 Sub-etapa 1a: Descoberta Pura (8 min)\nFundamentação: A descoberta ativa promove maior engajamento e retenção (3). Material: Envelope A (cartas aleatórias); Folhas em branco para Tabela de Rastreio, rascunho e observações; canetas coloridas (azuis, vermelhas e verdes).\n\nFormação: Organizar turma em grupos de 4-5 alunos\nDesafio Inicial:\n\nEntregar apenas Envelope A (Aleatório);\nInstrução: “Anotem a posição inicial das cartas no envelope”;\nInstrução: “Ordenem estas cartas e durante a ordenação criem um conjunto de regras que qualquer pessoa possa seguir”;\nFoco: Apenas na lógica, sem formalização.\n\n\n\n\n8.1.2.2 Sub-etapa 1b: Formalização (7 min)\n\nInstrução: “Agora convertam sua estratégia para pseudocódigo ou fluxograma”\nPerguntas guia:\n\nQual parte foi mais difícil de entender?\nVocês perceberam algum padrão nas trocas?\nComo verificar se o algoritmo está correto?\n\n\n\n\n8.1.2.3 Sub-etapa 1c: Depuração com Tabela de Rastreio (8 min)\n\nEntregar Tabela de Rastreio;\nInstrução: “Executem o algoritmo passo a passo na tabela para provar que funciona”;\nUsar canetas de cores diferentes para comparações e trocas;\nObjetivo: Metacognição acerca do processo algorítmico.\n\n\n\n8.1.2.4 Sub-etapa 1d: Consolidação - Retrieval Practice (2 min)\nFundamentação: A recuperação ativa fortalece a consolidação de memória (2).\n\nInstrução: “Fechem as anotações. Expliquem para o colega ao lado a lógica do algoritmo sem consultar anotações”.\n\n\n\n\n8.1.3 Etapa 2: Predição e Teste de Eficiência (18 minutos)\nFundamentação: A predição ativa o processamento elaborativo, melhorando compreensão (4).\n\n8.1.3.1 Sub-etapa 2a: Elaborative Prediction (5 min)\n\nAntes de entregar Envelopes 2 e 3:\nInstrução: “Baseado na lógica do algoritmo, expliquem, no papel, em linguagem natural, como ele se comportaria em três casos:\n\nMelhor caso: ___ comparações, ___ trocas;\nPior caso: ___ comparações, ___ trocas;\nJustifiquem as suas predições”;\n\n\n\n\n8.1.3.2 Sub-etapa 2b: Teste e Coleta de Dados (13 min)\n\nEntregar Envelopes 2 e 3;\nInstrução: “Usem exatamente o mesmo algoritmo para os três casos. Contem comparações e trocas”;\nComparar predições com resultados reais;\nCriar tabela de resultados, conforme o modelo abaixo:\n\n\n\n\nTable 8.1: Tabela modelo para resultados de predições e comparações.\n\n\n\n\n\n\n\n\n\n\n\n\nCaso\nPredição Comp.\nReal Comp.\nPredição Trocas\nReal Trocas\n\n\n\n\nAleatório\n(valor)\n(valor)\n(valor)\n(valor)\n\n\nMelhor\n(valor)\n(valor)\n(valor)\n(valor)\n\n\nPior\n(valor)\n(valor)\n(valor)\n(valor)\n\n\n\n\n\n\n\n\n\n8.1.4 Etapa 3: Apresentação a partir do Questionamento (20 minutos)\nFundamentação: Perguntas elaborativas aprofundam compreensão e criam conexões causais (5).\n\n8.1.4.1 Sub-etapa 3a: Recuperação Antes da Apresentação (3 min)\n\nInstrução: “Antes de apresentar, reconstituam mentalmente todo o processo sem consultar anotações”\n\n\n\n8.1.4.2 Sub-etapa 3b: Apresentação Estruturada (17 min)\nCada grupo apresenta:\n\nFluxograma/pseudocódigo no quadro;\nTabela de resultados (predições vs realidade);\nGráfico visual de comparações/trocas por caso.\n\nPerguntas do Professor (Elaborative Interrogation):\n\n“Por que esse algoritmo precisou de mais trocas neste caso?”\n“Como isso se relaciona com complexidade algorítmica?”\n“Que aconteceria com 1000 elementos?”\n“Em que situação prática isso seria problemático?”\n\nConexões pelo Professor:\n\nBubble Sort: “Essa estratégia de vizinhos é o Bubble Sort. Observem como o pior caso explodiu. Por quê?”\nSelection Sort: “O Selection Sort sempre tem poucas trocas. Quando isso é vantajoso?”\nInsertion Sort: “O Insertion Sort foi eficiente no melhor caso. Quando usar?”\n\nNota: existe a possibilidade de que os alunos apliquem algoritmos como o quick sort, merge sort ou outros algoritmos de ordenação mais avançados. O professor deve estar preparado para discutir as vantagens e desvantagens desses algoritmos em relação aos apresentados.\n\n\n\n8.1.5 Etapa 4: Transfer Learning e Metacognição (12 minutos)\nFundamentação: A transferência para novos contextos consolida aprendizagem profunda (ROHRER; TAYLOR, 2007).\n\n8.1.5.1 Sub-etapa 4a: Transfer Tasks (7 min)\nInstrução: “Respondam, em papel, as perguntas a seguir referentes a aplicação dos algoritmos a situações reais:\n\nComo ordenariam playlist de 10.000 músicas em smartphone com pouca memória?\nComo ordenariam lista de emergências médicas por gravidade?\nQue modificações fariam nos algoritmos para cada caso?”\n\n\n\n8.1.5.2 Sub-etapa 4b: Consolidação e Conexões (3 min)\nInstrução: “Discutam em grupo e anotem rapidamente:\n\nQue situação do dia a dia de vocês se beneficiaria mais de algoritmos de ordenação eficientes?\nEntre os algoritmos que descobriram hoje, qual escolheriam para organizar uma biblioteca com 50.000 livros? Por quê?\nIdentifiquem um exemplo no qual a simplicidade do algoritmo seria mais importante que a eficiência.”\n\nObjetivo: Consolidar conexões entre os algoritmos estudados e aplicações práticas, e reforçar a importância do contexto na escolha de soluções algorítmicas.\n\n\n\n8.1.6 Etapa 5: Reflexão Metacognitiva (10 minutos)\nFundamentação: Reflexão metacognitiva melhora aprendizagem futura (6).\n\n8.1.6.1 Sub-etapa 5a: Reflexão Individual (5 min)\nInstrução: “Cada um de vocês deve escrever uma reflexão individual sobre o processo de aprendizagem de hoje, respondendo às seguintes perguntas:\n\n“Que momento foi mais difícil no processo? Por quê?”\n“Quando vocês ‘clicaram’ com a solução? O que mudou?”\n“Se fossem ensinar para um calouro, que passo fariam diferente?”\n“Que conexões veem entre esta atividade e problemas reais de programação?”\n\n\n\n8.1.6.2 Sub-etapa 5b: Discussão Final Guiada (5 min)\nO professor deve conduzir uma discussão final, na qual os alunos compartilham suas reflexões e insights. Perguntas adicionais podem incluir:\n\n“Observando todos os dados, qual algoritmo é mais eficiente para lista quase ordenada?”\n“Qual sofre mais com ordem inversa? Por que isso acontece neurologicamente?”\n“Se troca fosse custosa mas comparação barata, qual seria melhor?”\n“Para 1000 itens, como cresceria o número de operações? Linear ou quadrático?”\n“Existe um algoritmo ‘melhor’ universal? Por que não?”\n“Em fita magnética sequencial, qual seria mais adequado?”\n“Em lista encadeada, qual ficaria mais difícil?”\n\n\n\n\n8.1.7 Sessão de Follow-up - Spacing Effect (Aula seguinte - 15 min)\nFundamentação: O spacing effect demonstra que distribuição temporal consolida memória de longo prazo (CEPEDA et al., 2006).\n\n8.1.7.1 Retrieval Practice Diferido:\n\nReconstrução (3 min): “Sem material, desenhem o algoritmo que criaram”;\nPredição Escalada (2 min): “Para 100 elementos invertidos, quantas comparações aproximadamente?”;\nAplicação Contextual (5 min): “Identifiquem situação real ideal para cada algoritmo”;\nMini-quiz Adaptativo (5 min): “Dados 3 arrays, escolham algoritmo mais eficiente”;\n\n\n\n8.1.7.2 Avaliação do Aprendizado\nA avaliação será baseada em peers review e autoavaliação, com foco nos seguintes indicadores de sucesso:\n\nImediato: Criação correta de algoritmo + depuração eficaz;\nTransferência: Aplicação adequada a contextos novos;\nRetenção: Performance no follow-up sem consulta;\nMetacognição: Reflexões demonstrando awareness do processo.\n\nA avaliação deve ser realizada de acordo com as seguintes métricas de resultados:\n\nPrecisão nas predições vs resultados reais\nQualidade das justificativas causais\nAdequação das aplicações de transfer\nProfundidade das reflexões metacognitivas\n\nPara que a avaliação seja eficaz, o professor deve garantir que os alunos tenham acesso a um feedback construtivo e que as reflexões sejam discutidas em grupo, promovendo um ambiente de aprendizagem colaborativa. A devolutiva deve ser feita pelo grupo que avaliou. Para tornar este processo de avaliação uniforme, existe uma ferramenta online disponível para auxiliar na avaliação em https://frankalcantara.com/raciocinio/ava/modulo3-1.html",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span>"
    ]
  },
  {
    "objectID": "desenv3.html#atividade-b3-algoritmos-de-ordenação",
    "href": "desenv3.html#atividade-b3-algoritmos-de-ordenação",
    "title": "8  Módulo 3: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados",
    "section": "8.2 Atividade B3: Algoritmos de Ordenação",
    "text": "8.2 Atividade B3: Algoritmos de Ordenação\nNa Atividade Section 8.1 os alunos descobriram os algoritmos de ordenação mais comuns. Se o resultado desta atividade foi satisfatório, ou seja, os alunos realmente descobriram os algoritmos, então esta atividade se resume à implementação dos algoritmos descobertos, a partir dos fluxogramas ou pseudocódigos criados pelos alunos.\nMaterial Necessário:: computadores com ambiente de programação configurado, acesso à internet para pesquisa e os fluxogramas ou pseudocódigos criados na atividade anterior.\nObjetivo: Implementar os algoritmos de ordenação descobertos na atividade anterior, analisando a eficiência e complexidade de cada um.\n\nDistribua entre os grupos os fluxogramas, ou pseudocódigos, criados na atividade anterior. Assegure-se de que cada grupo tenha um fluxograma, ou pseudocódigo, diferente daquele criado na aula anterior;\nCada grupo irá implementar cada um dos algoritmos de ordenação criados na atividade anterior, ou seja, todos os grupos irão implementar todos os algoritmos da atividade anterior. A implementação deve ser feita em um único arquivo de código, com uma função para cada algoritmo de ordenação. A função deve receber como parâmetro uma lista de números e retornar a lista ordenada;\nApós a implementação, cada grupo deve analisar a eficiência do algoritmo, medindo o tempo de execução e o número de comparações e trocas realizadas. Para isso, cada algoritmo deverá ordenar três listas diferentes de números aleatórios, uma lista quase ordenada e uma lista ordenada em ordem inversa. O resultado deve ser documentado em uma tabela e entregue ao professor.\n\nNota: como é a primeira vez que os alunos implementam algoritmos usando as funções de medida de tempo pode ser necessário que o professor explique como usar essas funções. Os professores que optarem pelo Python podem usar a função time.perf_counter(), a função time.process_time() ou o módulo timeit para medições rigorosas do tempo de execução de cada algoritmo. Um código em C++ 23 capaz de carregar os textos gerados no formato criado na página de avaliação disponível no gerador de csv está apresentado pode ser visto na Listing 8.1.\n\n\n\nListing 8.1\n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n#include &lt;iomanip&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Estrutura para armazenar os dados do CSV\nstruct DataSet {\n    vector&lt;int&gt; lista_aleatoria;\n    vector&lt;int&gt; lista_80_ordenada;\n    vector&lt;int&gt; lista_decrescente;\n};\n\n// Estrutura para armazenar resultados de tempo\nstruct ResultadoTempo {\n    double tempo_aleatorio;\n    double tempo_80_ordenado;\n    double tempo_decrescente;\n};\n\n// ==================== PROTÓTIPOS DAS FUNÇÕES ====================\nDataSet lerCSV(const string& nomeArquivo);\nvoid bubbleSort(vector&lt;int&gt;& arr);\nvoid insertionSort(vector&lt;int&gt;& arr);\nvoid selectionSort(vector&lt;int&gt;& arr);\nvoid mergeSort(vector&lt;int&gt;& arr);\nvoid mergeSortRecursivo(vector&lt;int&gt;& arr, int esquerda, int direita);\nvoid merge(vector&lt;int&gt;& arr, int esquerda, int meio, int direita);\ntemplate&lt;typename Func&gt; double medirTempo(vector&lt;int&gt; dados, Func algoritmo);\nbool estaOrdenado(const vector&lt;int&gt;& arr);\nvoid testarAlgoritmos(const DataSet& dados);\nvoid exibirTabelaResultados(const vector&lt;pair&lt;string, ResultadoTempo&gt;&gt;& resultados);\nvoid analisarResultados(const vector&lt;pair&lt;string, ResultadoTempo&gt;&gt;& resultados);\n\n// Função para ler o arquivo CSV\nDataSet lerCSV(const string& nomeArquivo) {\n    DataSet dados;\n    ifstream arquivo(nomeArquivo);\n    string linha;\n\n    if (!arquivo.is_open()) {\n        cerr &lt;&lt; \"Erro: Não foi possível abrir o arquivo \" &lt;&lt; nomeArquivo &lt;&lt; std::endl;\n        return dados;\n    }\n\n    // Pular o cabeçalho\n    getline(arquivo, linha);\n\n    // Ler os dados\n    while (getline(arquivo, linha)) {\n        stringstream ss(linha);\n        string valor;\n\n        // Ler Lista_Aleatoria\n        if (getline(ss, valor, ',')) {\n            dados.lista_aleatoria.push_back(stoi(valor));\n        }\n\n        // Ler Lista_80_Ordenada\n        if (getline(ss, valor, ',')) {\n            dados.lista_80_ordenada.push_back(stoi(valor));\n        }\n\n        // Ler Lista_Decrescente\n        if (getline(ss, valor, ',')) {\n            dados.lista_decrescente.push_back(stoi(valor));\n        }\n    }\n\n    arquivo.close();\n    std::cout &lt;&lt; \"Arquivo CSV carregado com sucesso!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Dados carregados: \" &lt;&lt; dados.lista_aleatoria.size() &lt;&lt; \" elementos por lista\" &lt;&lt; std::endl;\n    return dados;\n}\n\n// ==================== ALGORITMOS DE ORDENAÇÃO ====================\n\n// Bubble Sort\nvoid bubbleSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        bool trocou = false;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                trocou = true;\n            }\n        }\n        // Otimização: se não houve trocas, o array já está ordenado\n        if (!trocou) break;\n    }\n}\n\n// Insertion Sort\nvoid insertionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) {\n        int chave = arr[i];\n        int j = i - 1;\n\n        // Move elementos maiores que a chave uma posição à frente\n        while (j &gt;= 0 && arr[j] &gt; chave) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = chave;\n    }\n}\n\n// Selection Sort\nvoid selectionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIdx = i;\n\n        // Encontra o menor elemento no array não ordenado\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n\n        // Troca o menor elemento encontrado com o primeiro elemento\n        if (minIdx != i) {\n            swap(arr[i], arr[minIdx]);\n        }\n    }\n}\n\n// Merge Sort - Função auxiliar para merge\nvoid merge(vector&lt;int&gt;& arr, int esquerda, int meio, int direita) {\n    int n1 = meio - esquerda + 1;\n    int n2 = direita - meio;\n\n    // Arrays temporários\n    vector&lt;int&gt; L(n1), R(n2);\n\n    // Copia dados para arrays temporários\n    for (int i = 0; i &lt; n1; i++)\n        L[i] = arr[esquerda + i];\n    for (int j = 0; j &lt; n2; j++)\n        R[j] = arr[meio + 1 + j];\n\n    // Merge os arrays temporários de volta em arr[esquerda..direita]\n    int i = 0, j = 0, k = esquerda;\n\n    while (i &lt; n1 && j &lt; n2) {\n        if (L[i] &lt;= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copia os elementos restantes de L[], se houver\n    while (i &lt; n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copia os elementos restantes de R[], se houver\n    while (j &lt; n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// Merge Sort - Função principal\nvoid mergeSortRecursivo(vector&lt;int&gt;& arr, int esquerda, int direita) {\n    if (esquerda &lt; direita) {\n        int meio = esquerda + (direita - esquerda) / 2;\n\n        // Ordena primeira e segunda metades\n        mergeSortRecursivo(arr, esquerda, meio);\n        mergeSortRecursivo(arr, meio + 1, direita);\n\n        // Merge as duas metades ordenadas\n        merge(arr, esquerda, meio, direita);\n    }\n}\n\n// Wrapper para Merge Sort\nvoid mergeSort(vector&lt;int&gt;& arr) {\n    if (arr.size() &gt; 1) {\n        mergeSortRecursivo(arr, 0, arr.size() - 1);\n    }\n}\n\n// ==================== FUNÇÕES DE TESTE E MEDIÇÃO ====================\n\n// Função para medir tempo de execução de um algoritmo\ntemplate&lt;typename Func&gt;\ndouble medirTempo(vector&lt;int&gt; dados, Func algoritmo) {\n    auto inicio = high_resolution_clock::now();\n    algoritmo(dados);\n    auto fim = high_resolution_clock::now();\n\n    auto duracao = duration_cast&lt;microseconds&gt;(fim - inicio);\n    return duracao.count() / 1000.0; // Retorna em milissegundos\n}\n\n// Função para verificar se um array está ordenado\nbool estaOrdenado(const vector&lt;int&gt;& arr) {\n    for (size_t i = 1; i &lt; arr.size(); i++) {\n        if (arr[i] &lt; arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Função para testar todos os algoritmos\nvoid testarAlgoritmos(const DataSet& dados) {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"INICIANDO TESTES DE ALGORITMOS DE ORDENAÇÃO\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n\n    // Armazenar resultados\n    vector&lt;pair&lt;string, ResultadoTempo&gt;&gt; resultados;\n\n    // Teste Bubble Sort\n    std::cout &lt;&lt; \"\\nTestando Bubble Sort...\" &lt;&lt; std::endl;\n    ResultadoTempo tempos_bubble;\n    tempos_bubble.tempo_aleatorio = medirTempo(dados.lista_aleatoria, bubbleSort);\n    tempos_bubble.tempo_80_ordenado = medirTempo(dados.lista_80_ordenada, bubbleSort);\n    tempos_bubble.tempo_decrescente = medirTempo(dados.lista_decrescente, bubbleSort);\n    resultados.push_back({ \"Bubble Sort\", tempos_bubble });\n\n    // Teste Insertion Sort\n    std::cout &lt;&lt; \"Testando Insertion Sort...\" &lt;&lt; std::endl;\n    ResultadoTempo tempos_insertion;\n    tempos_insertion.tempo_aleatorio = medirTempo(dados.lista_aleatoria, insertionSort);\n    tempos_insertion.tempo_80_ordenado = medirTempo(dados.lista_80_ordenada, insertionSort);\n    tempos_insertion.tempo_decrescente = medirTempo(dados.lista_decrescente, insertionSort);\n    resultados.push_back({ \"Insertion Sort\", tempos_insertion });\n\n    // Teste Selection Sort\n    std::cout &lt;&lt; \"Testando Selection Sort...\" &lt;&lt; std::endl;\n    ResultadoTempo tempos_selection;\n    tempos_selection.tempo_aleatorio = medirTempo(dados.lista_aleatoria, selectionSort);\n    tempos_selection.tempo_80_ordenado = medirTempo(dados.lista_80_ordenada, selectionSort);\n    tempos_selection.tempo_decrescente = medirTempo(dados.lista_decrescente, selectionSort);\n    resultados.push_back({ \"Selection Sort\", tempos_selection });\n\n    // Teste Merge Sort\n    std::cout &lt;&lt; \"Testando Merge Sort...\" &lt;&lt; std::endl;\n    ResultadoTempo tempos_merge;\n    tempos_merge.tempo_aleatorio = medirTempo(dados.lista_aleatoria, mergeSort);\n    tempos_merge.tempo_80_ordenado = medirTempo(dados.lista_80_ordenada, mergeSort);\n    tempos_merge.tempo_decrescente = medirTempo(dados.lista_decrescente, mergeSort);\n    resultados.push_back({ \"Merge Sort\", tempos_merge });\n\n    // Verificação de integridade (teste com uma pequena amostra)\n    std::cout &lt;&lt; \"\\nVerificando integridade dos algoritmos...\" &lt;&lt; std::endl;\n    vector&lt;int&gt; teste = { 64, 34, 25, 12, 22, 11, 90 };\n    vector&lt;int&gt; copia_teste;\n\n    copia_teste = teste; bubbleSort(copia_teste);\n    std::cout &lt;&lt; \"Bubble Sort: \" &lt;&lt; (estaOrdenado(copia_teste) ? \"✓ OK\" : \"✗ ERRO\") &lt;&lt; std::endl;\n\n    copia_teste = teste; insertionSort(copia_teste);\n    std::cout &lt;&lt; \"Insertion Sort: \" &lt;&lt; (estaOrdenado(copia_teste) ? \"✓ OK\" : \"✗ ERRO\") &lt;&lt; std::endl;\n\n    copia_teste = teste; selectionSort(copia_teste);\n    std::cout &lt;&lt; \"Selection Sort: \" &lt;&lt; (estaOrdenado(copia_teste) ? \"✓ OK\" : \"✗ ERRO\") &lt;&lt; std::endl;\n\n    copia_teste = teste; mergeSort(copia_teste);\n    std::cout &lt;&lt; \"Merge Sort: \" &lt;&lt; (estaOrdenado(copia_teste) ? \"✓ OK\" : \"✗ ERRO\") &lt;&lt; std::endl;\n\n    // Exibir tabela de resultados\n    exibirTabelaResultados(resultados);\n}\n\n// Função para exibir tabela formatada de resultados\nvoid exibirTabelaResultados(const vector&lt;pair&lt;string, ResultadoTempo&gt;&gt;& resultados) {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; string(100, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"TABELA DE COMPARAÇÃO DE TEMPOS DE EXECUÇÃO (em milissegundos)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(100, '=') &lt;&lt; std::endl;\n\n    // Cabeçalho\n    std::cout &lt;&lt; left &lt;&lt; setw(20) &lt;&lt; \"ALGORITMO\"\n        &lt;&lt; right &lt;&lt; setw(20) &lt;&lt; \"LISTA ALEATÓRIA\"\n        &lt;&lt; setw(20) &lt;&lt; \"LISTA 80% ORD.\"\n        &lt;&lt; setw(20) &lt;&lt; \"LISTA DECRESCENTE\"\n        &lt;&lt; setw(20) &lt;&lt; \"MÉDIA\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(100, '-') &lt;&lt; std::endl;\n\n    // Dados\n    for (const auto& resultado : resultados) {\n        double media = (resultado.second.tempo_aleatorio +\n            resultado.second.tempo_80_ordenado +\n            resultado.second.tempo_decrescente) / 3.0;\n\n        std::cout &lt;&lt; left &lt;&lt; setw(20) &lt;&lt; resultado.first\n            &lt;&lt; right &lt;&lt; setw(20) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; resultado.second.tempo_aleatorio\n            &lt;&lt; setw(20) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; resultado.second.tempo_80_ordenado\n            &lt;&lt; setw(20) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; resultado.second.tempo_decrescente\n            &lt;&lt; setw(20) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; media &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; string(100, '=') &lt;&lt; std::endl;\n\n    // Análise dos resultados\n    analisarResultados(resultados);\n}\n\n// Função para análise automática dos resultados\nvoid analisarResultados(const vector&lt;pair&lt;string, ResultadoTempo&gt;&gt;& resultados) {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"ANÁLISE DOS RESULTADOS\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n\n    // Encontrar o mais rápido para cada tipo de lista\n    string mais_rapido_aleatorio, mais_rapido_80, mais_rapido_decrescente;\n    double menor_tempo_aleatorio = numeric_limits&lt;double&gt;::max();\n    double menor_tempo_80 = numeric_limits&lt;double&gt;::max();\n    double menor_tempo_decrescente = numeric_limits&lt;double&gt;::max();\n\n    for (const auto& resultado : resultados) {\n        if (resultado.second.tempo_aleatorio &lt; menor_tempo_aleatorio) {\n            menor_tempo_aleatorio = resultado.second.tempo_aleatorio;\n            mais_rapido_aleatorio = resultado.first;\n        }\n        if (resultado.second.tempo_80_ordenado &lt; menor_tempo_80) {\n            menor_tempo_80 = resultado.second.tempo_80_ordenado;\n            mais_rapido_80 = resultado.first;\n        }\n        if (resultado.second.tempo_decrescente &lt; menor_tempo_decrescente) {\n            menor_tempo_decrescente = resultado.second.tempo_decrescente;\n            mais_rapido_decrescente = resultado.first;\n        }\n    }\n\n    std::cout &lt;&lt; \"MELHOR DESEMPENHO POR CATEGORIA:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   • Lista Aleatória: \" &lt;&lt; mais_rapido_aleatorio\n        &lt;&lt; \" (\" &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; menor_tempo_aleatorio &lt;&lt; \"ms)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   • Lista 80% Ordenada: \" &lt;&lt; mais_rapido_80\n        &lt;&lt; \" (\" &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; menor_tempo_80 &lt;&lt; \"ms)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   • Lista Decrescente: \" &lt;&lt; mais_rapido_decrescente\n        &lt;&lt; \" (\" &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; menor_tempo_decrescente &lt;&lt; \"ms)\" &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\nOBSERVAÇÕES:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   • Merge Sort geralmente tem melhor desempenho geral (O(n log n))\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   • Insertion Sort é eficiente para listas quase ordenadas\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   • Bubble Sort é o menos eficiente para listas grandes\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   • Selection Sort tem desempenho consistente mas não otimizado\" &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\nDICA PEDAGÓGICA:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   Esta diferença demonstra a importância da análise de complexidade\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   algorítmica na escolha do algoritmo adequado para cada situação.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n}\n\n// Função principal\nint main() {\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"ANALISADOR DE ALGORITMOS DE ORDENAÇÃO\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Desenvolvido para a disciplina de Raciocínio Algorítmico\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n\n    string nomeArquivo;\n    std::cout &lt;&lt; \"\\nDigite o nome do arquivo CSV (ex: dados_algoritmos.csv): \";\n    getline(std::cin, nomeArquivo);\n\n    // Carregar dados do CSV\n    DataSet dados = lerCSV(nomeArquivo);\n\n    if (dados.lista_aleatoria.empty()) {\n        cerr &lt;&lt; \"Erro: Não foi possível carregar os dados. Verifique o arquivo.\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    // Verificar tamanho dos dados\n    std::cout &lt;&lt; \"\\nEstatísticas dos dados carregados:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Lista Aleatória: \" &lt;&lt; dados.lista_aleatoria.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Lista 80% Ordenada: \" &lt;&lt; dados.lista_80_ordenada.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Lista Decrescente: \" &lt;&lt; dados.lista_decrescente.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n\n    // Executar testes\n    testarAlgoritmos(dados);\n\n    std::cout &lt;&lt; \"\\nPressione Enter para finalizar...\";\n    std::cin.get();\n\n    return 0;\n}\n\n\n\n\n8.2.1 Análise Esperada:\nCom base nas atividades realizadas e nos resultados obtidos, espera-se que os alunos identifiquem e compreendam os seguintes pontos, consolidando seu aprendizado sobre a implementação e aplicação de estruturas de dados e algoritmos:\n\n8.2.1.1 Sobre Algoritmos de Ordenação Implementados:\n\nBubble Sort O(n²): algoritmo mais simples, mas menos eficiente para listas grandes;\nInsertion Sort O(n²): muito eficiente para listas pequenas ou quase ordenadas;\nSelection Sort O(n²): comportamento consistente, mas não adaptativo;\nMerge Sort O(n log n): mantém eficiência mesmo com listas grandes.\n\nNota: o uso da notação Big O é apenas informativo e serve como métrica de comparação.\n\n\n8.2.1.2 Comparações de Performance:\n\nLista de números aleatória: Merge Sort demonstra superioridade clara;\nLista de números quase ordenada: Insertion Sort pode superar algoritmos mais complexos;\nLista de números em ordem inversa: representa o pior caso para a maioria dos algoritmos;\nEscalabilidade: diferença dramática entre algoritmos de complexidade diferentes.\n\n\n\n8.2.1.3 Sobre Implementação Prática:\n\nSimplicidade vs Eficiência: algoritmos simples nem sempre são os melhores;\nAdaptabilidade: alguns algoritmos se beneficiam de dados parcialmente ordenados;\nEstabilidade: preservação da ordem relativa de elementos iguais;\nUso de memória: algoritmos in-place vs algoritmos que requerem memória adicional.\n\n\n\n8.2.1.4 Insights sobre Medição de Performance:\n\nTempo de execução: varia significativamente entre algoritmos e tipos de dados;\nNúmero de comparações: métrica importante para entender complexidade;\nNúmero de trocas: impacta performance quando movimentação de dados é custosa;\nComportamento assintótico: como o desempenho muda com o tamanho dos dados.\n\n\n\n8.2.1.5 Conexões com Conceitos Fundamentais:\n\nAnálise de complexidade: importância da notação Big O na prática;\nTrade-offs: balanceamento entre simplicidade, eficiência e uso de recursos;\nEscolha de algoritmos: contexto determina qual algoritmo é mais apropriado;\nOtimização prematura: nem sempre o algoritmo mais eficiente é necessário.\n\n\n\n\n8.2.2 Perguntas para Reflexão:\n\nPor que o Insertion Sort pode ser mais rápido que o Merge Sort em listas pequenas?\nEm que situações você escolheria Bubble Sort mesmo sabendo que é menos eficiente?\nComo o custo de movimentação de dados afeta a escolha entre diferentes algoritmos?\nQual algoritmo você usaria para ordenar uma lista de 10 milhões de elementos? Por quê?\nPor que é importante medir tanto o tempo quanto o número de operações?\nComo os resultados mudariam se os dados fossem strings em vez de números?\nQue outros fatores além da eficiência deveriam influenciar a escolha de um algoritmo?\nComo estes conceitos se aplicam a problemas de ordenação no mundo real?\n\n\n\n8.2.3 Extensões para Alunos Avançados:\n\nImplementar Quick Sort e comparar com os algoritmos básicos;\nAnalisar o comportamento com diferentes tamanhos de dados (100, 1000, 10000 elementos);\nImplementar versões otimizadas dos algoritmos (Bubble Sort com flag, Insertion Sort binário);\nCriar visualizações gráficas do processo de ordenação;\nComparar performance com funções de ordenação das bibliotecas padrão;\nInvestigar algoritmos híbridos (Timsort, Introsort);\nImplementar algoritmos de ordenação externa para dados que não cabem na memória.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span>"
    ]
  },
  {
    "objectID": "desenv3.html#atividade-c3-onde-está",
    "href": "desenv3.html#atividade-c3-onde-está",
    "title": "8  Módulo 3: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados",
    "section": "8.3 Atividade C3: Onde Está …?",
    "text": "8.3 Atividade C3: Onde Está …?\nO objetivo desta atividade é levar os alunos a deduzirem, formalizarem e analisarem algoritmos de busca através da experimentação prática, aplicando princípios da neurociência cognitiva para melhorar a retenção e transferência do conhecimento. O foco está na aplicação das teorias da descoberta ativa, prática de recuperação estruturada e desenvolvimento metacognitivo ((1), (2), (3)).\nMateriais: para cada grupo:\n\nUm conjunto de 15 cartas numeradas (1 a 15);\nEnvelope A: contendo cartas em ordem aleatória (ex: [7, 2, 11, 4, 15, 1, 9, 13, 6, 3, 12, 8, 10, 5, 14]);\nEnvelope B: contendo cartas em ordem crescente (ex: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\nEnvelope C: contendo cartas em ordem decrescente (ex: [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);\nCartões de “Missão” com números específicos para buscar (ex: “Encontre o 8”, “Encontre o 3”, “Encontre o 12”);\nFolhas para rascunho de pseudocódigo/fluxograma;\nFolhas para Tabela de Rastreio para depuração;\nCanetas coloridas para marcar verificações e estratégias;\nFolha de Reflexão Metacognitiva.\nQuadro branco e marcadores coloridos para o professor apresentar conceitos e guiar discussão.\n\nDuração Total: 90 minutos (distribuição baseada na teoria de spacing effect para melhor consolidação)\n\n8.3.1 Etapa 0: Ativação de Esquemas e Retrieval Practice (10 minutos)\nFundamentação: A ativação de conhecimento prévio facilita a criação de conexões neurais mais robustas (1).\nMaterial: Quadro branco, marcadores coloridos, alunos divididos em grupos.\n\nWarm-up - Retrieval Practice (5 min):\n\nInstrução: “Sem consultar qualquer material, listem em 2 minutos tudo que sabem sobre:\n\nComo procurar algo em um conjunto de dados;\nEstratégias que usam para encontrar informações no dia a dia.\n\nObjetivo: ativar estruturas cognitivas relacionadas ao conhecimento necessário, antes da nova aprendizagem.\n\nAtivação de Esquemas (5 min):\n\nInstrução: “Antes de abrir os envelopes, descrevam como encontrariam:\n\nUm nome específico em uma agenda telefônica;\nUm livro específico em uma biblioteca;\nUma música específica em uma playlist;\n\nQue estratégias mentais vocês usam? Anotem 2-3 padrões comuns.”\nObjetivo: estabelecer conexões entre conhecimento cotidiano e algoritmos formais\n\n\nNota: Informar aos alunos que os envelopes, cartas, canetas serão devolvidos no final da tarefa juntamente com os pseudocódigos e fluxogramas criados. Este material será usado na próxima aula.\n\n\n8.3.2 Etapa 1: Descoberta Estruturada com Decomposição (22 minutos)\nFundamentação: A decomposição com agrupamento de tarefas reduz sobrecarga cognitiva permitindo processamento mais profundo (1).\n\n8.3.2.1 Sub-etapa 1a: Descoberta Pura (6 min)\nFundamentação: A descoberta ativa promove maior engajamento e retenção (3). Material: Envelope A (cartas aleatórias); Cartão de Missão “Encontre o X” (cada grupo um número diferente); Folhas em branco para Tabela de Rastreio, rascunho e observações; canetas coloridas.\n\nFormação: Organizar turma em grupos de 4-5 alunos\nDesafio Inicial:\n\nEntregar apenas Envelope A (Aleatório) e primeira missão;\nInstrução: “Anotar a posição inicial das cartas no envelope”;\nInstrução: “Encontrem o número especificado no seu cartão de missão nestas cartas e criem um conjunto de regras que qualquer pessoa possa seguir para encontrar qualquer número solicitado”;\nFoco: Apenas na lógica, sem formalização.\nImportante: Contar quantas cartas verificaram até encontrar o número indicado na sua missão.\n\n\n\n\n8.3.2.2 Sub-etapa 1b: Formalização (6 min)\n\nInstrução: “Agora convertam sua estratégia para pseudocódigo ou fluxograma”\nPerguntas guia:\n\nQual foi o número máximo de verificações necessárias?\nExiste uma forma de garantir que sempre encontrarão o número?\nComo verificar se o algoritmo está correto?\n\n\n\n\n8.3.2.3 Sub-etapa 1c: Depuração com Tabela de Rastreio (6 min)\n\nInstrução: “Executem o algoritmo passo a passo na tabela para encontrar o número especificado. Registrem cada verificação e troca de posição”;\nUsar canetas de cores diferentes para marcar verificações;\nObjetivo: Metacognição acerca do processo algorítmico.\n\n\n\n8.3.2.4 Sub-etapa 1d: Consolidação - Retrieval Practice (4 min)\nFundamentação: A recuperação ativa fortalece a consolidação de memória (2).\n\nInstrução: “Fechem as anotações. Expliquem para o colega ao lado a lógica do algoritmo sem consultar anotações”.\n\n\n\n\n8.3.3 Etapa 2: Predição e Teste de Eficiência (20 minutos)\nFundamentação: A predição ativa o processamento elaborativo, melhorando compreensão (4).\n\n8.3.3.1 Sub-etapa 2a: Elaborative Prediction (6 min)\n\nAntes de entregar Envelopes B e C:\nInstrução: “Baseado na lógica do algoritmo, expliquem, no papel, em linguagem natural, como ele se comportaria em três casos diferentes:\n\nCartas aleatórias: ___ verificações máximas;\nCartas ordenadas crescente: ___ verificações máximas;\nCartas ordenadas decrescente: ___ verificações máximas;\nJustifiquem as suas predições”;\n\n\n\n\n8.3.3.2 Sub-etapa 2b: Teste e Descoberta de Otimização (14 min)\n\nEntregar Envelopes B e C;\nInstrução: “Usem exatamente o mesmo algoritmo para os três casos. Busquem o número que seja o número especificado +1 em cada conjunto”;\nPrimeira rodada (4 min): Aplicar algoritmo original;\nPausa para reflexão (3 min): “Observando as cartas ordenadas, existe uma forma mais eficiente?”;\nSegunda rodada (4 min): Testar estratégia otimizada se descobriram;\nComparar predições com resultados reais (3 min);\nCriar tabela de resultados:\n\n\nModelo de tabela para registrar resultados.{#tbl-resultados2}\n\n\n\n\n\n\n\n\nCaso\nAlgoritmo Original\nAlgoritmo Otimizado\nDiferença\n\n\n\n\nAleatório\n(valor)\n(valor)\n(valor)\n\n\nOrdenado Cresc.\n(valor)\n(valor)\n(valor)\n\n\nOrdenado Decresc.\n(valor)\n(valor)\n(valor)\n\n\n\nNota: a busca binária não é natural. Ela foi, provavelmente, um avanço evolutivo então, pode ser que que o professor tenha que induzir esta descoberta. Reforçando a sugestão: “Observando as cartas ordenadas, existe uma forma mais eficiente?”\n\n\n\n8.3.4 Etapa 3: Apresentação a partir do Questionamento (18 minutos)\nFundamentação: Perguntas elaborativas aprofundam compreensão e criam conexões causais (5).\n\n8.3.4.1 Sub-etapa 3a: Recuperação Antes da Apresentação (3 min)\n\nInstrução: “Antes de apresentar, reconstituam mentalmente todo o processo sem consultar anotações”. Todavia, apenas os grupos que descobriram a busca binária, ou algum outro algoritmo otimizado, devem participar da apresentação.\n\n\n\n8.3.4.2 Sub-etapa 3b: Apresentação Estruturada (15 min)\nCada grupo apresenta:\n\nFluxograma/pseudocódigo do algoritmo original no quadro;\nFluxograma/pseudocódigo do algoritmo otimizado (se descobriram);\nTabela de resultados (predições vs realidade);\nGráfico visual de verificações por caso.\n\nPerguntas do Professor (Elaborative Interrogation):\n\n“Por que o algoritmo otimizado foi mais eficiente com cartas ordenadas?”\n“O que acontece se buscarmos o primeiro número da lista ordenada?”\n“E se buscarmos o último número?”\n“Como isso se relaciona com eficiência algorítmica?”\n“Que aconteceria com 1000 cartas?”\n“Em que situação prática cada algoritmo seria melhor?”\n\nConexões pelo Professor:\n\nBusca Linear: “Essa estratégia sequencial é a Busca Linear. Sempre funciona, mas qual é o custo?”\nBusca Binária: “A estratégia de dividir ao meio é a Busca Binária. Por que só funciona com dados ordenados?”\n\nAlém das perguntas, o professor pode destacar a complexidade dos algoritmos, talvez com uma introdução fluída e superficial à notação Big O, para que os alunos entendam que a eficiência não é apenas sobre o número de verificações, mas também sobre como o algoritmo escala com o tamanho dos dados.\n\n\n\n8.3.5 Etapa 4: Transfer Learning e Metacognição (10 minutos)\nFundamentação: A transferência para novos contextos consolida a aprendizagem profunda (2).\n\n8.3.5.1 Sub-etapa 4a: Transfer Tasks (7 min)\nInstrução: “Respondam, em papel, as perguntas a seguir referentes à aplicação dos algoritmos a situações reais:\n\nComo buscariam um contato específico em uma agenda telefônica de 10.000 nomes?\nComo encontrariam uma palavra específica em um dicionário?\nComo buscariam um produto específico em um catálogo online não-ordenado?\nQue modificações fariam nos algoritmos para cada caso?”\n\n\n\n8.3.5.2 Sub-etapa 4b: Consolidação e Conexões (3 min)\nInstrução: “Discutam em grupo e anotem rapidamente:\n\nQue situação do dia a dia de vocês se beneficiaria mais de algoritmos de busca eficientes?\nEntre os algoritmos que descobriram hoje, qual escolheriam para encontrar um contato específico em uma agenda de 100.000 pessoas? Por quê?\nIdentifiquem um exemplo no qual a busca linear seria mais apropriada que a busca binária, mesmo com dados ordenados.”\n\nObjetivo: Consolidar conexões entre os algoritmos estudados e aplicações práticas, reforçando a importância da estrutura dos dados na escolha de estratégias de busca.\n\n\n\n8.3.6 Etapa 5: Reflexão Metacognitiva (10 minutos)\nFundamentação: Reflexão metacognitiva melhora aprendizagem futura (6).\n\n8.3.6.1 Sub-etapa 5a: Reflexão Individual (5 min)\nInstrução: “Cada um deve escrever uma reflexão individual sobre o processo de descoberta de hoje, respondendo às seguintes perguntas:\n\n“Que momento foi mais confuso no processo? Por quê?”\n“Quando vocês ‘clicaram’ com a solução da pilha? O que mudou?”\n“Como a pilha resolve o problema de precedência de operadores?”\n“Que conexões veem entre esta atividade e problemas reais de programação?”\n\n\n\n8.3.6.2 Sub-etapa 5b: Discussão Final Guiada (5 min)\nO professor deve conduzir uma discussão final na qual os alunos compartilham suas reflexões e insights. Perguntas adicionais podem incluir:\n\n“Por que a pilha funciona melhor que tentar resolver mentalmente?”\n“Qual é a vantagem de eliminar parênteses?”\n“Como isso se relaciona com o modo que computadores ‘pensam’?”\n“Em que outras situações uma estrutura LIFO seria útil?”\n“Como vocês aplicariam este conceito em desenvolvimento de software?”\n“Que outros problemas matemáticos poderiam se beneficiar desta abordagem?” ### Sessão de Follow-up - Spacing Effect (Aula seguinte - 12 min)\n\nFundamentação: O spacing effect demonstra que distribuição temporal consolida memória de longo prazo (5).\n\n\n8.3.6.3 Retrieval Practice Diferido:\n\nReconstrução (3 min): “Sem material, desenhem os dois algoritmos que descobriram”;\nPredição Escalada (2 min): “Para 1000 elementos ordenados, quantas verificações máximas para cada algoritmo?”;\nAplicação Contextual (4 min): “Identifiquem situação real ideal para cada algoritmo”;\nMini-quiz Adaptativo (3 min): “Dados 3 cenários, escolham algoritmo mais eficiente”;\n\n\n\n\n8.3.7 Avaliação do Aprendizado\nA avaliação será baseada em peer review e autoavaliação, com foco em:\n\n8.3.7.1 Indicadores de Sucesso:\n\nImediato: Criação correta de algoritmo + depuração eficaz\nTransferência: Aplicação adequada a contextos novos\n\nRetenção: Performance no follow-up sem consulta\nMetacognição: Reflexões demonstrando awareness do processo\n\n\n\n8.3.7.2 Métricas Quantitativas:\n\nPrecisão nas predições vs resultados reais\nQualidade das justificativas causais\nAdequação das aplicações de transfer\nProfundidade das reflexões metacognitivas\n\nFerramenta online de avaliação disponível em: https://frankalcantara.com/raciocinio/ava/modulo3-3.html",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span>"
    ]
  },
  {
    "objectID": "desenv3.html#atividade-d3-algoritmos-de-busca",
    "href": "desenv3.html#atividade-d3-algoritmos-de-busca",
    "title": "8  Módulo 3: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados",
    "section": "8.4 Atividade D3: Algoritmos de Busca",
    "text": "8.4 Atividade D3: Algoritmos de Busca\nNa Atividade C3 os alunos descobriram os algoritmos de busca mais comuns. Se o resultado foi satisfatório, ou seja, os alunos realmente descobriram os algoritmos, então esta atividade se resume à implementação dos algoritmos descobertos, a partir dos fluxogramas ou pseudocódigos criados pelos alunos.\nMaterial Necessário: computadores com ambiente de programação configurado, acesso à internet para pesquisa e os fluxogramas ou pseudocódigos criados na atividade anterior.\nObjetivo: Implementar os algoritmos de busca descobertos na atividade anterior, analisando a eficiência e complexidade de cada um.\n\n8.4.1 Procedimento:\n\nDistribua entre os grupos os fluxogramas ou pseudocódigos, criados na atividade anterior.\nCertifique-se de que cada grupo tenha um fluxograma ou pseudocódigo, diferente daquele criado na aula anterior;\nCada grupo irá implementar cada um dos algoritmos de busca criados na atividade anterior, ou seja, todos os grupos irão implementar todos os algoritmos da atividade anterior. A implementação deve ser feita em uma única folha de código, com uma função para cada algoritmo de busca. A função deve receber como parâmetros uma lista de números e um valor a ser buscado, retornando a posição do elemento (ou -1 se não encontrado);\nApós a implementação, cada grupo deve analisar a eficiência do algoritmo, medindo o tempo de execução e o número de comparações realizadas. Para isso, cada algoritmo deverá buscar elementos específicos em três listas diferentes: uma lista de números aleatórios, uma lista ordenada crescente e uma lista ordenada decrescente. O resultado deve ser documentado em uma tabela e entregue ao professor.\n\nNota: veja a nota no exercício anterior sobre o uso de bibliotecas em Python para medição de tempos.\n\n\n8.4.2 Exemplo de código base para medição:\nOs alunos podem usar este código base em C++ 23 para carregar dados e medir performance dos algoritmos de busca. O código é compatível com arquivos CSV gerados pela ferramenta disponível no gerador de csv.\nUm exemplo de código em C++ 23 para medir o tempo de execução dos algoritmos de busca que os alunos irão implementar pode ser visto na Listing 8.2.\n\n\n\nListing 8.2\n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n#include &lt;iomanip&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits&gt;\n#include &lt;set&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Estrutura para armazenar os dados do CSV\nstruct DataSet {\n    vector&lt;int&gt; lista_aleatoria;\n    vector&lt;int&gt; lista_ordenada_cresc;\n    vector&lt;int&gt; lista_ordenada_decresc;\n    vector&lt;int&gt; elementos_busca;\n};\n\n// Estrutura para armazenar resultados de busca\nstruct ResultadoBusca {\n    bool encontrado;\n    int posicao;\n    int comparacoes;\n    double tempo_ms;\n    int elemento_buscado;\n};\n\n// Estrutura para armazenar estatísticas de um algoritmo\nstruct EstatisticasAlgoritmo {\n    string nome;\n    int total_comparacoes;\n    double tempo_total_ms;\n    int elementos_encontrados;\n    int elementos_nao_encontrados;\n    double tempo_medio_ms;\n    double comparacoes_medias;\n};\n\n// ==================== PROTÓTIPOS DAS FUNÇÕES ====================\nDataSet lerCSV(const string& nomeArquivo);\nvector&lt;int&gt; extrairElementosBusca(const string& nomeArquivo);\nResultadoBusca buscaLinear(const vector&lt;int&gt;& arr, int alvo);\nResultadoBusca buscaBinaria(const vector&lt;int&gt;& arr, int alvo);\nvoid testarAlgoritmos(const DataSet& dados);\nvoid exibirResultadosDetalhados(const vector&lt;ResultadoBusca&gt;& resultados, \n                                const string& nomeAlgoritmo, \n                                const string& tipoLista);\nvoid exibirEstatisticasComparativas(const vector&lt;EstatisticasAlgoritmo&gt;& stats);\nEstatisticasAlgoritmo calcularEstatisticas(const vector&lt;ResultadoBusca&gt;& resultados, \n                                           const string& nome);\nvoid demonstrarComplexidade(size_t tamanho);\nbool validarListaOrdenada(const vector&lt;int&gt;& arr, bool crescente = true);\n\n// Função para ler o arquivo CSV\nDataSet lerCSV(const string& nomeArquivo) {\n    DataSet dados;\n    ifstream arquivo(nomeArquivo);\n    string linha;\n\n    if (!arquivo.is_open()) {\n        cerr &lt;&lt; \"Erro: Não foi possível abrir o arquivo \" &lt;&lt; nomeArquivo &lt;&lt; std::endl;\n        return dados;\n    }\n\n    // Pular o cabeçalho\n    getline(arquivo, linha);\n\n    // Ler os dados\n    while (getline(arquivo, linha)) {\n        // Ignorar linhas de comentário\n        if (linha.empty() || linha[0] == '#') {\n            continue;\n        }\n        \n        stringstream ss(linha);\n        string valor;\n\n        // Ler Lista_Aleatoria\n        if (getline(ss, valor, ',') && !valor.empty()) {\n            dados.lista_aleatoria.push_back(stoi(valor));\n        }\n\n        // Ler Lista_Ordenada_Crescente\n        if (getline(ss, valor, ',') && !valor.empty()) {\n            dados.lista_ordenada_cresc.push_back(stoi(valor));\n        }\n\n        // Ler Lista_Ordenada_Decrescente\n        if (getline(ss, valor, ',') && !valor.empty()) {\n            dados.lista_ordenada_decresc.push_back(stoi(valor));\n        }\n    }\n\n    arquivo.close();\n    \n    // Extrair elementos de busca do arquivo\n    dados.elementos_busca = extrairElementosBusca(nomeArquivo);\n    \n    std::cout &lt;&lt; \"Arquivo CSV carregado com sucesso!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Dados carregados: \" &lt;&lt; dados.lista_aleatoria.size() &lt;&lt; \" elementos por lista\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Elementos para busca: \" &lt;&lt; dados.elementos_busca.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n    return dados;\n}\n\n// Função para extrair elementos de busca dos comentários do CSV\nvector&lt;int&gt; extrairElementosBusca(const string& nomeArquivo) {\n    vector&lt;int&gt; elementos;\n    ifstream arquivo(nomeArquivo);\n    string linha;\n    \n    if (!arquivo.is_open()) {\n        return elementos;\n    }\n    \n    while (getline(arquivo, linha)) {\n        if (linha.find(\"# Elementos para Buscar:\") != string::npos) {\n            // Próxima linha contém os elementos\n            if (getline(arquivo, linha)) {\n                linha = linha.substr(2); // Remove \"# \"\n                stringstream ss(linha);\n                string numero;\n                \n                while (getline(ss, numero, ',')) {\n                    // Remove espaços em branco\n                    numero.erase(0, numero.find_first_not_of(\" \\t\"));\n                    numero.erase(numero.find_last_not_of(\" \\t\") + 1);\n                    \n                    if (!numero.empty()) {\n                        elementos.push_back(stoi(numero));\n                    }\n                }\n            }\n            break;\n        }\n    }\n    \n    arquivo.close();\n    \n    // Se não encontrou elementos no arquivo, criar alguns padrão\n    if (elementos.empty()) {\n        elementos = {1, 100, 500, 999, 1500, 2000, 5000, 7500, 9999, 10000};\n    }\n    \n    return elementos;\n}\n\n// ==================== ALGORITMOS DE BUSCA ====================\n\n// Busca Linear\nResultadoBusca buscaLinear(const vector&lt;int&gt;& arr, int alvo) {\n    auto inicio = high_resolution_clock::now();\n    \n    ResultadoBusca resultado = {false, -1, 0, 0.0, alvo};\n    \n    for (size_t i = 0; i &lt; arr.size(); i++) {\n        resultado.comparacoes++;\n        if (arr[i] == alvo) {\n            resultado.encontrado = true;\n            resultado.posicao = static_cast&lt;int&gt;(i);\n            break;\n        }\n    }\n    \n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;microseconds&gt;(fim - inicio);\n    resultado.tempo_ms = duracao.count() / 1000.0;\n    \n    return resultado;\n}\n\n// Busca Binária\nResultadoBusca buscaBinaria(const vector&lt;int&gt;& arr, int alvo) {\n    auto inicio = high_resolution_clock::now();\n    \n    ResultadoBusca resultado = {false, -1, 0, 0.0, alvo};\n    int esquerda = 0;\n    int direita = static_cast&lt;int&gt;(arr.size()) - 1;\n    \n    while (esquerda &lt;= direita) {\n        int meio = esquerda + (direita - esquerda) / 2;\n        resultado.comparacoes++;\n        \n        if (arr[meio] == alvo) {\n            resultado.encontrado = true;\n            resultado.posicao = meio;\n            break;\n        } else if (arr[meio] &lt; alvo) {\n            esquerda = meio + 1;\n        } else {\n            direita = meio - 1;\n        }\n    }\n    \n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;microseconds&gt;(fim - inicio);\n    resultado.tempo_ms = duracao.count() / 1000.0;\n    \n    return resultado;\n}\n\n// ==================== FUNÇÕES DE TESTE E ANÁLISE ====================\n\n// Função para calcular estatísticas de um algoritmo\nEstatisticasAlgoritmo calcularEstatisticas(const vector&lt;ResultadoBusca&gt;& resultados, \n                                           const string& nome) {\n    EstatisticasAlgoritmo stats;\n    stats.nome = nome;\n    stats.total_comparacoes = 0;\n    stats.tempo_total_ms = 0.0;\n    stats.elementos_encontrados = 0;\n    stats.elementos_nao_encontrados = 0;\n    \n    for (const auto& resultado : resultados) {\n        stats.total_comparacoes += resultado.comparacoes;\n        stats.tempo_total_ms += resultado.tempo_ms;\n        \n        if (resultado.encontrado) {\n            stats.elementos_encontrados++;\n        } else {\n            stats.elementos_nao_encontrados++;\n        }\n    }\n    \n    stats.tempo_medio_ms = stats.tempo_total_ms / resultados.size();\n    stats.comparacoes_medias = static_cast&lt;double&gt;(stats.total_comparacoes) / resultados.size();\n    \n    return stats;\n}\n\n// Função para validar se uma lista está ordenada\nbool validarListaOrdenada(const vector&lt;int&gt;& arr, bool crescente) {\n    for (size_t i = 1; i &lt; arr.size(); i++) {\n        if (crescente) {\n            if (arr[i] &lt; arr[i-1]) return false;\n        } else {\n            if (arr[i] &gt; arr[i-1]) return false;\n        }\n    }\n    return true;\n}\n\n// Função para testar todos os algoritmos\nvoid testarAlgoritmos(const DataSet& dados) {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"INICIANDO TESTES DE ALGORITMOS DE BUSCA\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n\n    // Validar listas ordenadas\n    std::cout &lt;&lt; \"\\nValidando integridade das listas:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Lista ordenada crescente: \" &lt;&lt; (validarListaOrdenada(dados.lista_ordenada_cresc, true) ? \"✓ OK\" : \"✗ ERRO\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Lista ordenada decrescente: \" &lt;&lt; (validarListaOrdenada(dados.lista_ordenada_decresc, false) ? \"✓ OK\" : \"✗ ERRO\") &lt;&lt; std::endl;\n\n    // Armazenar todos os resultados para análise comparativa\n    vector&lt;vector&lt;ResultadoBusca&gt;&gt; resultados_linear(3); // 0=aleatória, 1=ordenada_cresc, 2=ordenada_decresc\n    vector&lt;vector&lt;ResultadoBusca&gt;&gt; resultados_binaria(3);\n    \n    vector&lt;string&gt; tipos_lista = {\"Lista Aleatória\", \"Lista Ordenada Crescente\", \"Lista Ordenada Decrescente\"};\n    vector&lt;vector&lt;int&gt;&gt; listas = {dados.lista_aleatoria, dados.lista_ordenada_cresc, dados.lista_ordenada_decresc};\n\n    // Testar cada tipo de lista\n    for (size_t i = 0; i &lt; listas.size(); i++) {\n        std::cout &lt;&lt; \"\\n\" &lt;&lt; string(60, '-') &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"TESTANDO: \" &lt;&lt; tipos_lista[i] &lt;&lt; std::endl;\n        std::cout &lt;&lt; string(60, '-') &lt;&lt; std::endl;\n\n        // Testar busca linear\n        std::cout &lt;&lt; \"\\n• Executando Busca Linear...\" &lt;&lt; std::endl;\n        for (int elemento : dados.elementos_busca) {\n            ResultadoBusca resultado = buscaLinear(listas[i], elemento);\n            resultados_linear[i].push_back(resultado);\n        }\n\n        // Testar busca binária (apenas em listas ordenadas)\n        if (i &gt; 0) { // Pular lista aleatória para busca binária\n            std::cout &lt;&lt; \"• Executando Busca Binária...\" &lt;&lt; std::endl;\n            for (int elemento : dados.elementos_busca) {\n                ResultadoBusca resultado = buscaBinaria(listas[i], elemento);\n                resultados_binaria[i].push_back(resultado);\n            }\n        }\n    }\n\n    // Exibir resultados detalhados\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"ANÁLISE DETALHADA DOS RESULTADOS\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n\n    for (size_t i = 0; i &lt; 3; i++) {\n        std::cout &lt;&lt; \"\\n\" &lt;&lt; tipos_lista[i] &lt;&lt; \":\" &lt;&lt; std::endl;\n        exibirResultadosDetalhados(resultados_linear[i], \"Busca Linear\", tipos_lista[i]);\n        \n        if (i &gt; 0 && !resultados_binaria[i].empty()) {\n            exibirResultadosDetalhados(resultados_binaria[i], \"Busca Binária\", tipos_lista[i]);\n        }\n    }\n\n    // Análise comparativa\n    vector&lt;EstatisticasAlgoritmo&gt; todas_estatisticas;\n    \n    // Calcular estatísticas para busca linear\n    for (size_t i = 0; i &lt; 3; i++) {\n        string nome = \"Linear (\" + tipos_lista[i] + \")\";\n        todas_estatisticas.push_back(calcularEstatisticas(resultados_linear[i], nome));\n    }\n    \n    // Calcular estatísticas para busca binária\n    for (size_t i = 1; i &lt; 3; i++) { // Apenas listas ordenadas\n        string nome = \"Binária (\" + tipos_lista[i] + \")\";\n        todas_estatisticas.push_back(calcularEstatisticas(resultados_binaria[i], nome));\n    }\n\n    exibirEstatisticasComparativas(todas_estatisticas);\n    demonstrarComplexidade(dados.lista_aleatoria.size());\n}\n\n// Função para exibir resultados detalhados\nvoid exibirResultadosDetalhados(const vector&lt;ResultadoBusca&gt;& resultados, \n                                const string& nomeAlgoritmo, \n                                const string& tipoLista) {\n    std::cout &lt;&lt; \"\\n  \" &lt;&lt; nomeAlgoritmo &lt;&lt; \":\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  \" &lt;&lt; string(50, '.') &lt;&lt; std::endl;\n    \n    int encontrados = 0;\n    int total_comparacoes = 0;\n    double tempo_total = 0.0;\n    \n    for (const auto& resultado : resultados) {\n        if (resultado.encontrado) encontrados++;\n        total_comparacoes += resultado.comparacoes;\n        tempo_total += resultado.tempo_ms;\n    }\n    \n    std::cout &lt;&lt; \"    Elementos encontrados: \" &lt;&lt; encontrados &lt;&lt; \"/\" &lt;&lt; resultados.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"    Comparações médias: \" &lt;&lt; fixed &lt;&lt; setprecision(1) \n         &lt;&lt; (double)total_comparacoes / resultados.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"    Tempo médio: \" &lt;&lt; fixed &lt;&lt; setprecision(3) \n         &lt;&lt; tempo_total / resultados.size() &lt;&lt; \"ms\" &lt;&lt; std::endl;\n}\n\n// Função para exibir estatísticas comparativas\nvoid exibirEstatisticasComparativas(const vector&lt;EstatisticasAlgoritmo&gt;& stats) {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"COMPARAÇÃO DE PERFORMANCE DOS ALGORITMOS\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; left &lt;&lt; setw(30) &lt;&lt; \"ALGORITMO\"\n         &lt;&lt; right &lt;&lt; setw(15) &lt;&lt; \"COMP. MÉDIAS\"\n         &lt;&lt; setw(15) &lt;&lt; \"TEMPO MÉDIO (ms)\"\n         &lt;&lt; setw(12) &lt;&lt; \"ENCONTRADOS\"\n         &lt;&lt; setw(8) &lt;&lt; \"TAXA\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '-') &lt;&lt; std::endl;\n\n    for (const auto& stat : stats) {\n        double taxa_sucesso = (double)stat.elementos_encontrados / \n                             (stat.elementos_encontrados + stat.elementos_nao_encontrados) * 100;\n        \n        std::cout &lt;&lt; left &lt;&lt; setw(30) &lt;&lt; stat.nome\n             &lt;&lt; right &lt;&lt; setw(15) &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; stat.comparacoes_medias\n             &lt;&lt; setw(15) &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; stat.tempo_medio_ms\n             &lt;&lt; setw(12) &lt;&lt; stat.elementos_encontrados\n             &lt;&lt; setw(7) &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; taxa_sucesso &lt;&lt; \"%\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n}\n\n// Função para demonstrar complexidade algorítmica\nvoid demonstrarComplexidade(size_t tamanho) {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"ANÁLISE DE COMPLEXIDADE ALGORÍTMICA\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    \n    std::cout &lt;&lt; \"Para \" &lt;&lt; tamanho &lt;&lt; \" elementos:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Busca Linear (O(n)):\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  - Melhor caso: 1 comparação\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  - Caso médio: \" &lt;&lt; tamanho/2 &lt;&lt; \" comparações\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  - Pior caso: \" &lt;&lt; tamanho &lt;&lt; \" comparações\" &lt;&lt; std::endl;\n    \n    int log_binario = static_cast&lt;int&gt;(ceil(log2(tamanho)));\n    std::cout &lt;&lt; \"\\n• Busca Binária (O(log n)):\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  - Melhor caso: 1 comparação\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  - Caso médio: \" &lt;&lt; log_binario-1 &lt;&lt; \" comparações\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  - Pior caso: \" &lt;&lt; log_binario &lt;&lt; \" comparações\" &lt;&lt; std::endl;\n    \n    double vantagem = (double)tamanho / log_binario;\n    std::cout &lt;&lt; \"\\n• Vantagem da Busca Binária: \" &lt;&lt; fixed &lt;&lt; setprecision(1) \n         &lt;&lt; vantagem &lt;&lt; \"x mais rápida no pior caso\" &lt;&lt; std::endl;\n    \n    std::cout &lt;&lt; \"\\nOBSERVAÇÃO IMPORTANTE:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"A busca binária só funciona em listas ORDENADAS!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Para listas não ordenadas, a busca linear é a única opção viável.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n}\n\n// Função principal\nint main() {\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"ANALISADOR DE ALGORITMOS DE BUSCA\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Desenvolvido para a disciplina de Raciocínio Algorítmico\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Atividade C3: Onde Está...?\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; string(80, '=') &lt;&lt; std::endl;\n\n    string nomeArquivo;\n    std::cout &lt;&lt; \"\\nDigite o nome do arquivo CSV (ex: dados_busca.csv): \";\n    getline(std::cin, nomeArquivo);\n\n    // Carregar dados do CSV\n    DataSet dados = lerCSV(nomeArquivo);\n\n    if (dados.lista_aleatoria.empty()) {\n        cerr &lt;&lt; \"Erro: Não foi possível carregar os dados. Verifique o arquivo.\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    // Verificar tamanho dos dados\n    std::cout &lt;&lt; \"\\nEstatísticas dos dados carregados:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Lista Aleatória: \" &lt;&lt; dados.lista_aleatoria.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Lista Ordenada Crescente: \" &lt;&lt; dados.lista_ordenada_cresc.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Lista Ordenada Decrescente: \" &lt;&lt; dados.lista_ordenada_decresc.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Elementos para buscar: \" &lt;&lt; dados.elementos_busca.size() &lt;&lt; \" elementos\" &lt;&lt; std::endl;\n\n    // Executar testes\n    testarAlgoritmos(dados);\n\n    std::cout &lt;&lt; \"\\nPressione Enter para finalizar...\";\n    std::cin.get();\n\n    return 0;\n}\n\n\n\n\n\n8.4.3 Análise Esperada:\nCom base nas atividades realizadas e nos resultados obtidos, espera-se que os alunos identifiquem e compreendam os seguintes pontos, consolidando seu aprendizado sobre a implementação e aplicação de estruturas de dados e algoritmos:\n\n8.4.3.1 Sobre Busca Linear O(n):\n\nFunciona sempre: em qualquer lista, ordenada ou não\nComportamento previsível: verifica elementos sequencialmente\nPior caso: precisa verificar todos os elementos\nMelhor caso: encontra o elemento na primeira posição\nCaso médio: encontra o elemento na metade da lista\n\n\n\n8.4.3.2 Sobre Busca Binária O(log n):\n\nRequer ordenação: só funciona em listas ordenadas\nMuito mais eficiente: para listas grandes, diferença é dramática\nEstratégia “dividir para conquistar”: elimina metade dos elementos a cada comparação\nCrescimento logarítmico: para 1000 elementos, máximo 10 comparações\n\n\n\n8.4.3.3 Comparações Práticas:\n\nPara 1000 elementos: Linear = até 1000 comparações, Binária = até 10 comparações\nPara 1.000.000 elementos: Linear = até 1.000.000 comparações, Binária = até 20 comparações\nTrade-off importante: custo de ordenação vs benefício da busca binária\n\n\n\n8.4.3.4 Insights Pedagógicos:\n\nA importância da estrutura dos dados na escolha do algoritmo\nQuando usar cada algoritmo:\n\nBusca linear: dados não ordenados, poucas buscas\nBusca binária: dados ordenados, muitas buscas\n\nA diferença entre complexidade teórica e performance prática\nComo o tamanho dos dados afeta dramaticamente a performance\n\n\n\n8.4.3.5 Conexões com o Mundo Real:\n\nAgenda telefônica: exemplo clássico de busca binária\nBases de dados: índices funcionam como busca binária\nAlgoritmos de busca web: combinam múltiplas estratégias\nJogos de adivinhação: “maior/menor” é busca binária\n\n\n\n\n8.4.4 Perguntas para Reflexão:\n\nPor que a busca binária só funciona em listas ordenadas?\nEm que situações você usaria busca linear mesmo tendo dados ordenados?\nComo o custo de ordenação afeta a escolha do algoritmo?\nQue outros algoritmos do dia a dia seguem a estratégia “dividir para conquistar”?\n\n\n\n8.4.5 Extensões para Alunos Avançados:\n\nBusca Ternária: dividir array em três partes em vez de duas, analisar se melhora performance teórica e prática comparada à busca binária\nBusca com Múltiplos Critérios: implementar busca por ranges (encontrar todos elementos entre dois valores), busca aproximada (elemento mais próximo)\nBenchmark Extensivo: criar suite de testes com diferentes tamanhos (1K a 10M elementos), diferentes distribuições de dados (gaussiana, exponencial, uniforme)\nImplementação de Índices: criar estruturas de índice simples (como B-trees básicas) e comparar com busca direta",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span>"
    ]
  },
  {
    "objectID": "desenv3.html#atividade-e3-criando-os-enemigos-da-hp",
    "href": "desenv3.html#atividade-e3-criando-os-enemigos-da-hp",
    "title": "8  Módulo 3: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados",
    "section": "8.5 Atividade E3: Criando os Enemigos da HP",
    "text": "8.5 Atividade E3: Criando os Enemigos da HP\nO objetivo desta atividade é levar os alunos a deduzir, formalizar e analisar o uso de pilha (stack) para avaliação de expressões matemáticas através da experimentação prática com notação polonesa reversa, aplicando princípios da neurociência cognitiva para maximizar a retenção e transferência do conhecimento. O foco está na aplicação das teorias da descoberta ativa, prática de recuperação estruturada e desenvolvimento metacognitivo ((1), (2), (3)).\nMateriais: para cada grupo de alunos:\n\nCartas de números (0-9, múltiplas cópias de cada);\nCartas de operadores (+, -, ×, ÷);\nPilha física (pequena caixa ou área delimitada na mesa);\nExpressões matemáticas em cartões (3 níveis de dificuldade);\nCalculadora tradicional para verificação;\nFolhas para anotações e cálculos intermediários;\nFolha para a Tabela de rastreio para depuração do processo;\nCronômetro para medir tempo de resolução;\nFolha para reflexão metacognitiva.\nQuadro branco e marcadores coloridos para o professor apresentar conceitos e guiar discussão.\n\nDuração Total: 90 minutos (distribuição baseada na teoria de spacing effect para melhor consolidação)\n\n8.5.1 Etapa 0: Ativação de Esquemas e Retrieval Practice (10 minutos)\nFundamentação: A ativação do conhecimento prévio facilita a criação de conexões neurais mais robustas (1).\nMaterial: Quadro branco, marcadores coloridos, alunos divididos em grupos. Arranjar mesas para induzir interação em grupos pequenos.\n\nWarm-up - Retrieval Practice (5 min):\n\nInstrução: “Sem consultar qualquer material, listem em 2 minutos tudo que sabem sobre:\n\nComo resolver expressões matemáticas complexas;\nProblemas que vocês tiveram com precedência de operadores;\nEstratégias que usaram para não se confundir com parênteses.”\n\nObjetivo: ativar estruturas cognitivas relacionadas a cálculos e ordem de operações.\n\nAtivação de Esquemas (5 min):\n\nInstrução: “Tentem resolver mentalmente, sem qualquer anotação, as seguintes expressões:\n\n\\(3 + 4 \\times 2\\);\n\\(2 \\times 3 + 4 \\times 5\\);\n\\(((3 + 4) \\times 2) + 1\\)\n\nDiscutam em grupo: os pontos nos quais sentiram dificuldade? Que estratégias usaram?“;\nObjetivo: estabelecer uma espécie frustração produtiva (1) com expressões complexas.\n\n\nNota: Informar aos alunos que as cartas, pilha e anotações serão reutilizadas ao longo da atividade para comparação de métodos.\n\n\n8.5.2 Etapa 1: Descoberta Estruturada com Decomposição (22 minutos)\nFundamentação: A descoberta de limitações motiva a busca por soluções mais eficientes (1).\n\n8.5.2.1 Sub-etapa 1a: Desafio das Expressões Complexas (10 min)\nFundamentação: Expor os alunos a problemas genuinamente difíceis cria necessidade cognitiva para ferramentas melhores (3). Material: Cartões com expressões matemáticas complexas; papel para cálculos; cronômetro.\n\nFormação: Organizar turma em grupos de 4-5 alunos\nDesafio Inicial:\n\nEntregar cartões com expressões como:\n\n\\(15 3 5 + \\times\\);\n\\(2 3 + 4 5 + \\times\\);\n\\(8 2 ÷ 3 + 1 -\\);\n\nImportante: o professor deve evitar explicar que se trata da notação polonesa reversa;\nInstrução: “Estas são expressões matemáticas escritas de forma especial. Tentem descobrir como calcular o resultado.”;\nCronometragem: é importante registrar quanto tempo os alunos gastam tentando descobrir o padrão e resolver as expressões.\n\n\n\n\n8.5.2.2 Sub-etapa 1b: Reflexão sobre Dificuldades (6 min)\n\nInstrução: “Anotem as dificuldades que encontraram:”;\nPerguntas guia:\n\nPor que essas expressões são confusas?\nComo vocês normalmente resolvem cálculos?\nO que falta nessas expressões para ficarem claras?\nExiste algum padrão que vocês conseguem identificar?\n\n\n\n\n8.5.2.3 Sub-etapa 1c: Tentativa de Solução Colaborativa (6 min)\n\nInstrução: “Trabalhem em grupo para tentar resolver pelo menos uma expressão”\nObservar estratégias emergentes\nNão dar dicas ainda - deixar a descoberta acontecer naturalmente\nObjetivo: Documentar as abordagens intuitivas antes da intervenção\n\n\n\n\n8.5.3 Etapa 2: Introdução da Ferramenta Pilha (20 minutos)\nFundamentação: Introduzir a solução após estabelecer a necessidade maximiza o impacto da descoberta (4).\n\n8.5.3.1 Sub-etapa 2a: Demonstração Guiada (10 min)\nMaterial: Pilha física, cartas de números e operadores.\n\nRegras da Pilha Mágica:\n\nNúmero: sempre colocar na pilha\nOperador: tirar dois números da pilha, fazer a operação, colocar resultado de volta\nResultado final: único número que sobra na pilha\n\nDemonstração com 15 3 5 + ×:\n\n15 → pilha: [15]\n3 → pilha: [15, 3]\n\n5 → pilha: [15, 3, 5]\n+ → tira 5 e 3, calcula 3+5=8, coloca 8 → pilha: [15, 8]\n× → tira 8 e 15, calcula 15×8=120, coloca 120 → pilha: [120]\nResultado: 120\n\n\n\n\n8.5.3.2 Sub-etapa 2b: Prática Guiada (5 min)\n\nInstrução: “Agora tentem resolver usando a pilha as outras expressões do desafio inicial”\n2 3 + 4 5 + × (esperado: 35)\n8 2 ÷ 3 + 1 - (esperado: 6)\nAcompanhar grupo por grupo, corrigir uso da pilha\nUsar cartas físicas para manipulação tátil\n\n\n\n8.5.3.3 Sub-etapa 2c: Comparação de Eficiência (5 min)\n\nInstrução: “Comparem o tempo que levaram agora versus na primeira tentativa”\nCriar tabela:\n\n\nModelo de tabela para comparação de eficiência.{#tabela-eficiencia3}\n\n\nExpressão\nTempo Sem Pilha\nTempo Com Pilha\nDiferença\n\n\n\n\n15 3 5 + ×\n(valor) min\n(valor) min\n(valor) min\n\n\n2 3 + 4 5 + ×\n(valor) min\n(valor) min\n(valor) min\n\n\n\n\n\n\n8.5.4 Etapa 3: Formalização e Algoritmo (18 minutos)\nFundamentação: A formalização após descoberta prática consolida o aprendizado (5).\n\n8.5.4.1 Sub-etapa 3a: Criação do Algoritmo (10 min)\n\nInstrução: “Criem um algoritmo passo-a-passo para qualquer pessoa conseguir usar a ‘pilha mágica’”\n\nOs alunos devem criar um algoritmo na forma de fluxograma, ou pseudocódigo, que descreva o processo de avaliação de expressões em notação polonesa reversa usando pilha.\nNota: talvez seja necessário que o professor chame a atenção para as tarefas mínimas que devem ser incluídas no algoritmo, como “inicializar pilha”, “empilhar número”, “desempilhar dois números”, “aplicar operador” e “empilhar resultado”. Apenas para complementar a estrutura que os alunos criaram.\n\n\n8.5.4.2 Sub-etapa 3b: Teste com Expressões Mais Complexas (8 min)\n\nNovos desafios:\n\n\\(1 2 + 3 4 + \\times\\) (esperado: 21);\n\\(6 2 \\div 3 \\times 4 +\\) (esperado: 13);\n\\(5 1 2 + 4 \\times + 3 -\\) (esperado: 14);\n\nUsar tabela de rastreio para depuração:\n\n\nModelo de tabela de rastreio para depuração.{#tabela-rastreio3}\n\n\nPasso\nSímbolo\nAção\nEstado da Pilha\n\n\n\n\n1\n5\nempilhar\n[5]\n\n\n2\n1\nempilhar\n[5, 1]\n\n\n3\n2\nempilhar\n[5, 1, 2]\n\n\n4\n+\ncalcular 1+2=3\n[5, 3]\n\n\n…\n…\n…\n…\n\n\n\n\n\n\n8.5.5 Etapa 4: Transfer Learning e Conexões (10 minutos)\nFundamentação: A transferência para novos contextos consolida a aprendizagem profunda (2).\n\n8.5.5.1 Sub-etapa 4a: Conversão de Notações (5 min)\nInstrução: “Convertam estas expressões tradicionais para notação polonesa reversa e resolvam:”\n\n3 + 4 × 2 → 3 4 2 × + (esperado: 11)\n(2 + 3) × 4 → 2 3 + 4 × (esperado: 20)\n\n2 × (3 + 4) + 1 → 2 3 4 + × 1 + (esperado: 15)\n\nInsight esperado: A notação polonesa reversa elimina a necessidade de parênteses e ambiguidade de precedência.\n\n\n8.5.5.2 Sub-etapa 4b: Conexões com Mundo Real (5 min)\nInstrução: “Onde mais vocês acham que essa estratégia é usada?”\nDiscussão guiada:\n\nCalculadoras HP: ainda usam RPN hoje;\nCompiladores: convertem expressões para pilha antes de avaliar;\nMáquinas virtuais: Java, Python usam pilha para operações;\nUndo/Redo: mesma estrutura LIFO para desfazer ações.\n\n\n\n\n8.5.6 Etapa 5: Reflexão Metacognitiva (10 minutos)\nFundamentação: Reflexão metacognitiva melhora aprendizagem futura (6).\n\n8.5.6.1 Sub-etapa 5a: Reflexão Individual (5 min)\nInstrução: “Cada um deve escrever uma reflexão individual sobre o processo de descoberta de hoje:”\n\n“Que momento foi mais confuso no processo? Por quê?”\n“Quando vocês ‘clicaram’ com a solução da pilha? O que mudou?”\n“Como a pilha resolve o problema de precedência de operadores?”\n“Que conexões veem entre esta atividade e programação de computadores?”\n\n\n\n8.5.6.2 Sub-etapa 5b: Discussão Final Guiada (5 min)\nO professor deve conduzir discussão na qual alunos compartilham reflexões:\n\n“Por que a pilha funciona melhor que tentar resolver mentalmente?”\n“Qual é a vantagem de eliminar parênteses?”\n“Como isso se relaciona com o modo que computadores ‘pensam’?”\n“Em que outras situações uma estrutura LIFO seria útil?”\n\n\n\n\n8.5.7 Sessão de Follow-up - Spacing Effect (Aula seguinte - 12 min)\nFundamentação: O spacing effect demonstra que distribuição temporal consolida memória de longo prazo (5).\n\n8.5.7.1 Retrieval Practice Diferido:\n\nReconstrução (3 min): “Sem material, expliquem o algoritmo da pilha para RPN”\nAplicação Prática (4 min): “Resolvam 4 2 + 3 × 1 - usando apenas papel”\nConversão (3 min): “Convertam (2+3)×4-1 para RPN e resolvam”\nConexão (2 min): “Identifiquem 2 situações do dia a dia que usam LIFO”\n\n\n\n\n8.5.8 Avaliação do Aprendizado\nA avaliação será baseada em peer review e autoavaliação, com foco nos seguintes indicadores de sucesso:\n\nImediato: Uso correto da pilha para avaliar expressões RPN\nTransferência: Conversão correta de notação infixa para RPN\n\nRetenção: Performance no follow-up sem consulta\nMetacognição: Reflexões demonstrando compreensão do conceito LIFO\n\nEstes indicadores devem ser avaliados segundo as seguintes métricas:\n\nTempo de resolução (antes vs depois da pilha)\nPrecisão na avaliação de expressões\nQualidade das conversões infixa→RPN Profundidade das reflexões metacognitivas\n\nFerramenta online de avaliação disponível em: https://frankalcantara.com/raciocinio/ava/modulo3-5.html\n\n\n8.5.9 Análise Esperada:\nCom base nas atividades realizadas e nos resultados obtidos, espera-se que os alunos identifiquem e compreendam os seguintes pontos, consolidando seu aprendizado sobre a implementação e aplicação de estruturas de dados e algoritmos:\n\n8.5.9.1 Sobre Pilha para Avaliação de Expressões:\n\nElimina ambiguidade: não precisa de parênteses nem regras de precedência\nProcesso sistemático: sempre funciona, sem exceções\nEficiência cognitiva: reduz carga mental para expressões complexas\nOrdem natural: LIFO espelha como operações são aninhadas\n\n\n\n8.5.9.2 Sobre Notação Polonesa Reversa (RPN):\n\nSem parênteses: estrutura inerente da pilha resolve precedência\nAvaliação linear: processa da esquerda para direita, sem backtracking\nMenos erros: impossível criar expressões ambíguas\nComputacionalmente eficiente: compiladores usam este método\n\n\n\n8.5.9.3 Conexões Fundamentais:\n\nEstrutura de dados apropriada resolve problemas naturalmente\nLIFO aparece em múltiplos contextos (undo, call stack, parsing)\nAbstrações matemáticas têm implementações práticas em computação\nFerramentas simples (pilha) resolvem problemas complexos (precedência)\n\n\n\n8.5.9.4 Insights Pedagógicos:\n\nA frustração inicial motiva busca por soluções melhores\nManipulação física (cartas) reforça conceitos abstratos\nDescoberta guiada é mais eficaz que apresentação direta\nAplicação imediata consolida aprendizado teórico\n\n\n\n\n8.5.10 Extensões Possíveis:\nPara alunos avançados, o professor pode propor:\n\nImplementar calculadora RPN em código;\nConverter expressões com múltiplos níveis de parênteses;\nExplorar notação polonesa normal (operador antes dos operandos);\nAnalisar como compiladores fazem parsing de expressões;\nCriar visualizações do processo de avaliação.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span>"
    ]
  },
  {
    "objectID": "desenv3.html#atividade-f3-implementação-de-pilha-para-avaliação-de-expressões",
    "href": "desenv3.html#atividade-f3-implementação-de-pilha-para-avaliação-de-expressões",
    "title": "8  Módulo 3: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados",
    "section": "8.6 Atividade F3: Implementação de Pilha para Avaliação de Expressões",
    "text": "8.6 Atividade F3: Implementação de Pilha para Avaliação de Expressões\nNa Atividade E3 os alunos descobriram como usar a estrutura de dados pilha para avaliar expressões em notação polonesa reversa e possivelmente como converter expressões da notação infixa para a notação polonesa reversa. Se o resultado desta atividade foi satisfatório, ou seja, os alunos realmente compreenderam o conceito de pilha e sua aplicação, então a atividade F3 se resume à implementação dos algoritmos descobertos, a partir dos fluxogramas ou pseudocódigos criados pelos alunos.\nMaterial Necessário: computadores com ambiente de programação configurado, acesso à internet para pesquisa e os fluxogramas ou pseudocódigos criados na atividade anterior.\nObjetivo: Implementar a estrutura de dados pilha e os algoritmos para avaliação de expressões em notação polonesa reversa descobertos na atividade anterior, analisando a eficiência e precisão de cada implementação.\n\n8.6.1 Procedimento:\n\nDistribua entre os grupos os fluxogramas, ou pseudocódigos, criados na atividade anterior. Certifique-se de que cada grupo tenha um fluxograma, ou pseudocódigo, diferente daquele criado por este mesmo grupo na aula anterior;\nCada grupo irá implementar cada um dos algoritmos criados na atividade anterior, ou seja, todos os grupos irão implementar todos os algoritmos da atividade anterior. A implementação deve ser feita em uma única folha de código, com as seguintes funções:\n\nUma estrutura para implementar a pilha;\nUma função para avaliar expressões em notação polonesa reversa;\nUma função para converter expressões da notação infixa para RPN (se foi descoberta);\nFunção principal para testar e medir performance;\n\nApós a implementação, cada grupo deve analisar a eficiência dos algoritmos, medindo o tempo de execução e a precisão dos resultados. Para isso, cada algoritmo deverá processar três conjuntos diferentes de expressões: expressões simples, expressões complexas e expressões com múltiplos níveis de operações. O resultado deve ser documentado em uma tabela e entregue ao professor.\n\nNota: Como é a primeira vez que os alunos implementam estruturas de dados customizadas, pode ser necessário que o professor reveja, ou explique os conceitos básicos de arrays, vetores, listas e registros. O professor pode demonstrar como usar vetores (vector) em C++ ou listas em Python para implementar a pilha.\n\n\n8.6.2 Exemplo de código base para medição:\nOs alunos podem usar este código base em C++ 23 para implementar e testar sua estrutura de pilha.\nUm exemplo de código em C++ 23 para implementar e medir o tempo de execução dos algoritmos de pilha que os alunos irão desenvolver pode ser visto no código Listing 8.3. Este código inclui a estrutura de pilha, funções básicas para manipulação da pilha, tokenização de expressões, avaliação de expressões em notação polonesa reversa e medição de tempo de execução. Contudo,, neste código foi utilizada uma pilha simples, para armazenar strings, na tentativa de criar um código parecido com os pseudocódigos que são criados por alunos que ainda não são proficients em estruturas de dados.\n\n\n\nListing 8.3\n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n#include &lt;iomanip&gt;\n#include &lt;cctype&gt;\n#include &lt;cmath&gt;\n\n// ==================== ESTRUTURA SIMPLES DA PILHA ====================\n\nstruct Pilha {\n    std::vector&lt;std::string&gt; elementos;\n    int topo;\n    \n    Pilha() : topo(-1) {}\n};\n\n// Estruturas para dados de teste\nstruct ConjuntoExpressoes {\n    std::vector&lt;std::string&gt; expressoes_simples;\n    std::vector&lt;std::string&gt; expressoes_complexas;\n    std::vector&lt;std::string&gt; expressoes_infixas;\n    std::vector&lt;double&gt; resultados_esperados_simples;\n    std::vector&lt;double&gt; resultados_esperados_complexas;\n    std::vector&lt;double&gt; resultados_esperados_infixas;\n};\n\nstruct ResultadoTeste {\n    double resultado_calculado;\n    double resultado_esperado;\n    double tempo_ms;\n    bool sucesso;\n    std::string erro;\n    int operacoes_realizadas;\n};\n\nstruct EstatisticasTeste {\n    std::string nome;\n    int sucessos;\n    int erros;\n    double tempo_medio_ms;\n    double operacoes_medias;\n    double precisao_percentual;\n};\n\n// ==================== FUNÇÕES BÁSICAS DA PILHA ====================\n\nvoid empilhar(Pilha& pilha, const std::string& elemento) {\n    pilha.elementos.push_back(elemento);\n    pilha.topo++;\n}\n\nstd::string desempilhar(Pilha& pilha) {\n    if (pilha.topo &lt; 0) {\n        throw std::runtime_error(\"Erro: tentativa de desempilhar pilha vazia\");\n    }\n    std::string elemento = pilha.elementos[pilha.topo];\n    pilha.elementos.pop_back();\n    pilha.topo--;\n    return elemento;\n}\n\nbool pilhaVazia(const Pilha& pilha) {\n    return pilha.topo &lt; 0;\n}\n\nint tamanhoPilha(const Pilha& pilha) {\n    return pilha.topo + 1;\n}\n\nstd::string topo(const Pilha& pilha) {\n    if (pilha.topo &lt; 0) {\n        throw std::runtime_error(\"Erro: pilha vazia\");\n    }\n    return pilha.elementos[pilha.topo];\n}\n\nvoid limparPilha(Pilha& pilha) {\n    pilha.elementos.clear();\n    pilha.topo = -1;\n}\n\nvoid mostrarPilha(const Pilha& pilha) {\n    std::cout &lt;&lt; \"Pilha [topo -&gt; base]: \";\n    for (int i = pilha.topo; i &gt;= 0; i--) {\n        std::cout &lt;&lt; pilha.elementos[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\n// ==================== FUNÇÕES AUXILIARES ====================\n\nbool ehOperador(const std::string& token) {\n    return token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\" || token == \"^\";\n}\n\nbool ehNumero(const std::string& token) {\n    if (token.empty()) return false;\n    \n    bool ponto_decimal = false;\n    std::size_t inicio = 0;\n    \n    if (token[0] == '-' || token[0] == '+') {\n        if (token.length() == 1) return false;\n        inicio = 1;\n    }\n    \n    for (std::size_t i = inicio; i &lt; token.length(); i++) {\n        if (token[i] == '.') {\n            if (ponto_decimal) return false;\n            ponto_decimal = true;\n        } else if (!std::isdigit(token[i])) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nstd::vector&lt;std::string&gt; tokenizar(const std::string& expressao) {\n    std::vector&lt;std::string&gt; tokens;\n    std::string token_atual = \"\";\n    \n    for (char c : expressao) {\n        if (std::isspace(c)) {\n            if (!token_atual.empty()) {\n                tokens.push_back(token_atual);\n                token_atual = \"\";\n            }\n        } else {\n            token_atual += c;\n        }\n    }\n    \n    if (!token_atual.empty()) {\n        tokens.push_back(token_atual);\n    }\n    \n    return tokens;\n}\n\ndouble calcularOperacao(double a, double b, const std::string& operador) {\n    if (operador == \"+\") return a + b;\n    if (operador == \"-\") return a - b;\n    if (operador == \"*\") return a * b;\n    if (operador == \"/\") {\n        if (b == 0) throw std::runtime_error(\"Erro: divisão por zero\");\n        return a / b;\n    }\n    if (operador == \"^\") return std::pow(a, b);\n    \n    throw std::runtime_error(\"Erro: operador desconhecido: \" + operador);\n}\n\nstd::string doubleParaString(double valor) {\n    std::ostringstream oss;\n    oss &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; valor;\n    std::string resultado = oss.str();\n    \n    // Remover zeros desnecessários\n    std::size_t ponto = resultado.find('.');\n    if (ponto != std::string::npos) {\n        while (resultado.back() == '0') {\n            resultado.pop_back();\n        }\n        if (resultado.back() == '.') {\n            resultado.pop_back();\n        }\n    }\n    \n    return resultado;\n}\n\n// ==================== ALGORITMO PRINCIPAL RPN ====================\n\ndouble avaliarRPN(const std::string& expressao, int& operacoes) {\n    Pilha pilha;\n    std::vector&lt;std::string&gt; tokens = tokenizar(expressao);\n    operacoes = 0;\n    \n    std::cout &lt;&lt; \"\\nProcessando expressão RPN: \" &lt;&lt; expressao &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(50, '-') &lt;&lt; std::endl;\n    \n    for (const std::string& token : tokens) {\n        std::cout &lt;&lt; \"Token: '\" &lt;&lt; token &lt;&lt; \"' | \";\n        \n        if (ehNumero(token)) {\n            // É um número - empilhar\n            empilhar(pilha, token);\n            operacoes++;\n            std::cout &lt;&lt; \"Empilhando número\" &lt;&lt; std::endl;\n        } else if (ehOperador(token)) {\n            // É um operador - processar operação\n            if (tamanhoPilha(pilha) &lt; 2) {\n                throw std::runtime_error(\"Erro: operandos insuficientes para operador \" + token);\n            }\n            \n            // Desempilhar dois operandos (ordem importante!)\n            std::string b_str = desempilhar(pilha);  // segundo operando\n            std::string a_str = desempilhar(pilha);  // primeiro operando\n            \n            double a = std::stod(a_str);\n            double b = std::stod(b_str);\n            \n            // Calcular resultado\n            double resultado = calcularOperacao(a, b, token);\n            \n            // Empilhar resultado como string\n            std::string resultado_str = doubleParaString(resultado);\n            empilhar(pilha, resultado_str);\n            \n            operacoes += 3; // 2 desempilhamentos + 1 empilhamento\n            \n            std::cout &lt;&lt; \"Operação: \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; token &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; resultado &lt;&lt; std::endl;\n        } else {\n            throw std::runtime_error(\"Erro: token inválido: \" + token);\n        }\n        \n        mostrarPilha(pilha);\n        std::cout &lt;&lt; std::endl;\n    }\n    \n    // Verificar resultado final\n    if (tamanhoPilha(pilha) != 1) {\n        throw std::runtime_error(\"Erro: expressão RPN inválida - resultado final com \" + \n                          std::to_string(tamanhoPilha(pilha)) + \" elementos na pilha\");\n    }\n    \n    return std::stod(topo(pilha));\n}\n\n// ==================== CONVERSÃO INFIXA PARA RPN ====================\n\nint precedencia(const std::string& op) {\n    if (op == \"+\" || op == \"-\") return 1;\n    if (op == \"*\" || op == \"/\") return 2;\n    if (op == \"^\") return 3;\n    return 0;\n}\n\nstd::string infixaParaRPN(const std::string& expressao) {\n    Pilha operadores;\n    std::string resultado = \"\";\n    std::string numero_atual = \"\";\n    \n    std::cout &lt;&lt; \"\\nConvertendo infixa para RPN: \" &lt;&lt; expressao &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(50, '-') &lt;&lt; std::endl;\n    \n    auto finalizarNumero = [&]() {\n        if (!numero_atual.empty()) {\n            if (!resultado.empty()) resultado += \" \";\n            resultado += numero_atual;\n            std::cout &lt;&lt; \"Adicionando número '\" &lt;&lt; numero_atual &lt;&lt; \"' ao resultado\" &lt;&lt; std::endl;\n            numero_atual = \"\";\n        }\n    };\n    \n    for (std::size_t i = 0; i &lt; expressao.length(); i++) {\n        char c = expressao[i];\n        \n        if (std::isspace(c)) {\n            finalizarNumero();\n            continue;\n        }\n        \n        if (std::isdigit(c) || c == '.') {\n            numero_atual += c;\n        } else if (c == '-' && (i == 0 || expressao[i-1] == '(' || ehOperador(std::string(1, expressao[i-1])))) {\n            // Número negativo\n            numero_atual += c;\n        } else if (ehOperador(std::string(1, c))) {\n            finalizarNumero();\n            \n            std::string op_atual(1, c);\n            \n            // Desempilhar operadores com precedência maior ou igual\n            while (!pilhaVazia(operadores) && topo(operadores) != \"(\" &&\n                   precedencia(topo(operadores)) &gt;= precedencia(op_atual)) {\n                if (!resultado.empty()) resultado += \" \";\n                std::string op = desempilhar(operadores);\n                resultado += op;\n                std::cout &lt;&lt; \"Movendo operador '\" &lt;&lt; op &lt;&lt; \"' para resultado\" &lt;&lt; std::endl;\n            }\n            \n            empilhar(operadores, op_atual);\n            std::cout &lt;&lt; \"Empilhando operador '\" &lt;&lt; op_atual &lt;&lt; \"'\" &lt;&lt; std::endl;\n        } else if (c == '(') {\n            finalizarNumero();\n            empilhar(operadores, \"(\");\n            std::cout &lt;&lt; \"Empilhando '('\" &lt;&lt; std::endl;\n        } else if (c == ')') {\n            finalizarNumero();\n            \n            // Desempilhar até encontrar '('\n            while (!pilhaVazia(operadores) && topo(operadores) != \"(\") {\n                if (!resultado.empty()) resultado += \" \";\n                std::string op = desempilhar(operadores);\n                resultado += op;\n                std::cout &lt;&lt; \"Movendo operador '\" &lt;&lt; op &lt;&lt; \"' para resultado (parênteses)\" &lt;&lt; std::endl;\n            }\n            \n            if (pilhaVazia(operadores)) {\n                throw std::runtime_error(\"Erro: parênteses não balanceados\");\n            }\n            \n            desempilhar(operadores); // Remove '('\n            std::cout &lt;&lt; \"Removendo '(' correspondente\" &lt;&lt; std::endl;\n        }\n        \n        mostrarPilha(operadores);\n    }\n    \n    finalizarNumero();\n    \n    // Desempilhar operadores restantes\n    while (!pilhaVazia(operadores)) {\n        if (topo(operadores) == \"(\" || topo(operadores) == \")\") {\n            throw std::runtime_error(\"Erro: parênteses não balanceados\");\n        }\n        if (!resultado.empty()) resultado += \" \";\n        std::string op = desempilhar(operadores);\n        resultado += op;\n        std::cout &lt;&lt; \"Movendo operador final '\" &lt;&lt; op &lt;&lt; \"' para resultado\" &lt;&lt; std::endl;\n    }\n    \n    std::cout &lt;&lt; \"Resultado RPN: \" &lt;&lt; resultado &lt;&lt; std::endl;\n    return resultado;\n}\n\n// ==================== FUNÇÕES DE TESTE E LEITURA ====================\n\nConjuntoExpressoes lerExpressoes(const std::string& nomeArquivo) {\n    ConjuntoExpressoes dados;\n    std::ifstream arquivo(nomeArquivo);\n    std::string linha;\n    \n    if (!arquivo.is_open()) {\n        std::cerr &lt;&lt; \"Erro: Não foi possível abrir o arquivo \" &lt;&lt; nomeArquivo &lt;&lt; std::endl;\n        return dados;\n    }\n    \n    std::string secao_atual = \"\";\n    \n    while (std::getline(arquivo, linha)) {\n        if (linha.empty() || linha[0] == '#') {\n            if (linha.find(\"# Expressões Simples\") != std::string::npos) {\n                secao_atual = \"simples\";\n            } else if (linha.find(\"# Expressões Complexas\") != std::string::npos) {\n                secao_atual = \"complexas\";\n            } else if (linha.find(\"# Expressões Infixas\") != std::string::npos) {\n                secao_atual = \"infixas\";\n            }\n            continue;\n        }\n        \n        std::stringstream ss(linha);\n        std::string expressao, resultado_str;\n        \n        if (std::getline(ss, expressao, ',') && std::getline(ss, resultado_str)) {\n            // Remover espaços extras\n            expressao.erase(std::find_first_not_of(expressao, \" \\t\"));\n            expressao.erase(std::find_last_not_of(expressao, \" \\t\") + 1);\n            resultado_str.erase(std::find_first_not_of(resultado_str, \" \\t\"));\n            resultado_str.erase(std::find_last_not_of(resultado_str, \" \\t\") + 1);\n            \n            double resultado = std::stod(resultado_str);\n            \n            if (secao_atual == \"simples\") {\n                dados.expressoes_simples.push_back(expressao);\n                dados.resultados_esperados_simples.push_back(resultado);\n            } else if (secao_atual == \"complexas\") {\n                dados.expressoes_complexas.push_back(expressao);\n                dados.resultados_esperados_complexas.push_back(resultado);\n            } else if (secao_atual == \"infixas\") {\n                dados.expressoes_infixas.push_back(expressao);\n                dados.resultados_esperados_infixas.push_back(resultado);\n            }\n        }\n    }\n    \n    arquivo.close();\n    std::cout &lt;&lt; \"Arquivo carregado com sucesso!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Expressões simples: \" &lt;&lt; dados.expressoes_simples.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Expressões complexas: \" &lt;&lt; dados.expressoes_complexas.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Expressões infixas: \" &lt;&lt; dados.expressoes_infixas.size() &lt;&lt; std::endl;\n    \n    return dados;\n}\n\nResultadoTeste medirTempo(const std::string& expressao, double esperado) {\n    ResultadoTeste resultado;\n    resultado.resultado_esperado = esperado;\n    resultado.sucesso = false;\n    resultado.operacoes_realizadas = 0;\n    \n    try {\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; inicio = std::chrono::high_resolution_clock::now();\n        resultado.resultado_calculado = avaliarRPN(expressao, resultado.operacoes_realizadas);\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; fim = std::chrono::high_resolution_clock::now();\n        \n        std::chrono::duration&lt;double, std::micro&gt; duracao = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(fim - inicio);\n        resultado.tempo_ms = duracao.count() / 1000.0;\n        \n        // Verificar precisão (tolerância para erros de ponto flutuante)\n        double diferenca = std::abs(resultado.resultado_calculado - esperado);\n        resultado.sucesso = (diferenca &lt; 0.001);\n        \n        if (!resultado.sucesso) {\n            resultado.erro = \"Resultado incorreto: esperado \" + std::to_string(esperado) + \n                           \", obtido \" + std::to_string(resultado.resultado_calculado);\n        }\n        \n    } catch (const std::exception& e) {\n        resultado.erro = e.what();\n        resultado.resultado_calculado = 0.0;\n        resultado.tempo_ms = 0.0;\n    }\n    \n    return resultado;\n}\n\nEstatisticasTeste calcularEstatisticas(const std::vector&lt;ResultadoTeste&gt;& resultados, const std::string& nome) {\n    EstatisticasTeste stats;\n    stats.nome = nome;\n    stats.sucessos = 0;\n    stats.erros = 0;\n    double tempo_total = 0.0;\n    double operacoes_total = 0.0;\n    \n    for (const ResultadoTeste& resultado : resultados) {\n        if (resultado.sucesso) {\n            stats.sucessos++;\n        } else {\n            stats.erros++;\n        }\n        tempo_total += resultado.tempo_ms;\n        operacoes_total += resultado.operacoes_realizadas;\n    }\n    \n    if (!resultados.empty()) {\n        stats.tempo_medio_ms = tempo_total / resultados.size();\n        stats.operacoes_medias = operacoes_total / resultados.size();\n        stats.precisao_percentual = (double)stats.sucessos / resultados.size() * 100.0;\n    }\n    \n    return stats;\n}\n\nvoid demonstrarUsoBasico() {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; std::string(60, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"DEMONSTRAÇÃO BÁSICA DA PILHA DE STRINGS\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(60, '=') &lt;&lt; std::endl;\n    \n    Pilha pilha_demo;\n    \n    std::cout &lt;&lt; \"1. Criando pilha vazia...\" &lt;&lt; std::endl;\n    mostrarPilha(pilha_demo);\n    \n    std::cout &lt;&lt; \"\\n2. Empilhando elementos: '10', '20', '30'\" &lt;&lt; std::endl;\n    empilhar(pilha_demo, \"10\");\n    mostrarPilha(pilha_demo);\n    empilhar(pilha_demo, \"20\");\n    mostrarPilha(pilha_demo);\n    empilhar(pilha_demo, \"30\");\n    mostrarPilha(pilha_demo);\n    \n    std::cout &lt;&lt; \"\\n3. Desempilhando elementos:\" &lt;&lt; std::endl;\n    while (!pilhaVazia(pilha_demo)) {\n        std::string elemento = desempilhar(pilha_demo);\n        std::cout &lt;&lt; \"Desempilhado: '\" &lt;&lt; elemento &lt;&lt; \"'\" &lt;&lt; std::endl;\n        mostrarPilha(pilha_demo);\n    }\n    \n    std::cout &lt;&lt; \"\\n4. Testando avaliação RPN simples: '5 3 +'\" &lt;&lt; std::endl;\n    int ops = 0;\n    double resultado = avaliarRPN(\"5 3 +\", ops);\n    std::cout &lt;&lt; \"Resultado final: \" &lt;&lt; resultado &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Total de operações: \" &lt;&lt; ops &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(60, '=') &lt;&lt; std::endl;\n}\n\nvoid testarAlgoritmos(const ConjuntoExpressoes& dados) {\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"INICIANDO TESTES DE ALGORITMOS DE PILHA\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n\n    demonstrarUsoBasico();\n\n    std::vector&lt;std::vector&lt;ResultadoTeste&gt;&gt; todos_resultados(3);\n    std::vector&lt;std::string&gt; tipos_teste = {\"Expressões Simples RPN\", \"Expressões Complexas RPN\", \"Conversão Infixa→RPN\"};\n\n    // Testar expressões RPN simples\n    if (!dados.expressoes_simples.empty()) {\n        std::cout &lt;&lt; \"\\n\" &lt;&lt; std::string(60, '-') &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"TESTANDO: Expressões RPN Simples\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; std::string(60, '-') &lt;&lt; std::endl;\n        \n        for (std::size_t i = 0; i &lt; dados.expressoes_simples.size(); i++) {\n            std::cout &lt;&lt; \"\\nTeste \" &lt;&lt; (i+1) &lt;&lt; \" de \" &lt;&lt; dados.expressoes_simples.size() &lt;&lt; std::endl;\n            ResultadoTeste resultado = medirTempo(dados.expressoes_simples[i], \n                                                dados.resultados_esperados_simples[i]);\n            todos_resultados[0].push_back(resultado);\n            \n            if (!resultado.sucesso) {\n                std::cout &lt;&lt; \"ERRO: \" &lt;&lt; resultado.erro &lt;&lt; std::endl;\n            } else {\n                std::cout &lt;&lt; \"SUCESSO: \" &lt;&lt; resultado.resultado_calculado &lt;&lt; std::endl;\n            }\n        }\n    }\n\n    // Testar expressões RPN complexas\n    if (!dados.expressoes_complexas.empty()) {\n        std::cout &lt;&lt; \"\\n\" &lt;&lt; std::string(60, '-') &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"TESTANDO: Expressões RPN Complexas\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; std::string(60, '-') &lt;&lt; std::endl;\n        \n        for (std::size_t i = 0; i &lt; dados.expressoes_complexas.size(); i++) {\n            std::cout &lt;&lt; \"\\nTeste \" &lt;&lt; (i+1) &lt;&lt; \" de \" &lt;&lt; dados.expressoes_complexas.size() &lt;&lt; std::endl;\n            ResultadoTeste resultado = medirTempo(dados.expressoes_complexas[i], \n                                                dados.resultados_esperados_complexas[i]);\n            todos_resultados[1].push_back(resultado);\n            \n            if (!resultado.sucesso) {\n                std::cout &lt;&lt; \"ERRO: \" &lt;&lt; resultado.erro &lt;&lt; std::endl;\n            } else {\n                std::cout &lt;&lt; \"SUCESSO: \" &lt;&lt; resultado.resultado_calculado &lt;&lt; std::endl;\n            }\n        }\n    }\n\n    // Testar conversão infixa para RPN\n    if (!dados.expressoes_infixas.empty()) {\n        std::cout &lt;&lt; \"\\n\" &lt;&lt; std::string(60, '-') &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"TESTANDO: Conversão Infixa para RPN\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; std::string(60, '-') &lt;&lt; std::endl;\n        \n        for (std::size_t i = 0; i &lt; dados.expressoes_infixas.size(); i++) {\n            std::cout &lt;&lt; \"\\nTeste \" &lt;&lt; (i+1) &lt;&lt; \" de \" &lt;&lt; dados.expressoes_infixas.size() &lt;&lt; std::endl;\n            try {\n                std::string rpn = infixaParaRPN(dados.expressoes_infixas[i]);\n                ResultadoTeste resultado = medirTempo(rpn, dados.resultados_esperados_infixas[i]);\n                todos_resultados[2].push_back(resultado);\n                \n                if (!resultado.sucesso) {\n                    std::cout &lt;&lt; \"ERRO: \" &lt;&lt; resultado.erro &lt;&lt; std::endl;\n                } else {\n                    std::cout &lt;&lt; \"SUCESSO: \" &lt;&lt; resultado.resultado_calculado &lt;&lt; std::endl;\n                }\n            } catch (const std::exception& e) {\n                ResultadoTeste resultado_erro;\n                resultado_erro.sucesso = false;\n                resultado_erro.erro = e.what();\n                resultado_erro.tempo_ms = 0.0;\n                resultado_erro.operacoes_realizadas = 0;\n                todos_resultados[2].push_back(resultado_erro);\n                std::cout &lt;&lt; \"ERRO: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n            }\n        }\n    }\n\n    // Resumo final\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"RESUMO DOS TESTES\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n\n    for (std::size_t i = 0; i &lt; todos_resultados.size(); i++) {\n        if (!todos_resultados[i].empty()) {\n            EstatisticasTeste stats = calcularEstatisticas(todos_resultados[i], tipos_teste[i]);\n            std::cout &lt;&lt; \"\\n\" &lt;&lt; stats.nome &lt;&lt; \":\" &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"  Sucessos: \" &lt;&lt; stats.sucessos &lt;&lt; \"/\" &lt;&lt; (stats.sucessos + stats.erros) &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"  Precisão: \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; stats.precisao_percentual &lt;&lt; \"%\" &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"  Tempo médio: \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; stats.tempo_medio_ms &lt;&lt; \"ms\" &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"  Operações médias: \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; stats.operacoes_medias &lt;&lt; std::endl;\n        }\n    }\n\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"CONCEITOS DEMONSTRADOS\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Pilha como vetor de strings simples\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Processamento sequencial de tokens RPN\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Operações aritméticas usando desempilhamento ordenado\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Conversão de notação infixa para RPN\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Precedência de operadores e parênteses\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"• Estrutura LIFO (Last In, First Out)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n}\n\nint main() {\n    std::cout &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"IMPLEMENTAÇÃO SIMPLES DE PILHA COM STRINGS\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Desenvolvido para a disciplina de Raciocínio Algorítmico\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Atividade F3: Pilha de Strings para Avaliação RPN\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::string(80, '=') &lt;&lt; std::endl;\n\n    std::string nomeArquivo;\n    std::cout &lt;&lt; \"\\nDigite o nome do arquivo de teste (ex: dados_pilha.csv): \";\n    std::getline(std::cin, nomeArquivo);\n\n    ConjuntoExpressoes dados = lerExpressoes(nomeArquivo);\n\n    if (dados.expressoes_simples.empty() && dados.expressoes_complexas.empty()) {\n        std::cerr &lt;&lt; \"Erro: Não foi possível carregar expressões de teste. Verifique o arquivo.\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    testarAlgoritmos(dados);\n\n    std::cout &lt;&lt; \"\\nPressione Enter para finalizar...\";\n    std::cin.get();\n\n    return 0;\n}\n\n\n\n\n\n8.6.3 Análise Esperada:\nCom base nas atividades realizadas e nos resultados obtidos, espera-se que os alunos identifiquem e compreendam os seguintes pontos, consolidando seu aprendizado sobre a implementação e aplicação de estruturas de dados e algoritmos:\n\n8.6.3.1 Sobre a Estrutura de Dados Pilha:\n\nOperações básicas: empilhar, desempilhar, topo, vazia são todas \\(O(1)\\);\nComportamento LIFO: Last In, First Out - fundamental para muitas aplicações;\nSimplicidade: implementação direta usando array dinâmico (vector);\nRobustez: verificações de erro evitam operações inválidas.\n\n\n\n8.6.3.2 Sobre Avaliação de Expressões RPN:\n\nAlgoritmo determinístico: sempre funciona da mesma forma;\nSem ambiguidade: não precisa de regras de precedência;\nEficiência: processamento linear, \\(O(n)\\) no qual \\(n\\) é o número de tokens;\nFacilidade de implementação: lógica clara e direta.\n\n\n\n8.6.3.3 Sobre Conversão Infixa para RPN:\n\nComplexidade adicional: mais difícil que avaliação RPN;\nGerenciamento de parênteses: requer cuidado especial;\nVerificação de validade: muitas oportunidades para erro de sintaxe.\n\n\n\n8.6.3.4 Comparações de Performance:\n\nExpressões simples: tempo quase instantâneo, principalmente sobrecarga de função;\nExpressões complexas: crescimento linear com número de operações;\nConversão infixa: tempo adicional para parsing, mas resultado equivalente;\nOperações de pilha: métrica interessante para complexidade algorítmica.\n\n\n\n8.6.3.5 Insights Pedagógicos:\n\nEstrutura adequada: pilha resolve naturalmente o problema de avaliação;\nAbstração poderosa: oculta complexidade da precedência de operadores;\nImplementação incremental: construir do simples para o complexo;\nCasos de erro: importante considerar entradas inválidas.\n\n\n\n\n8.6.4 Perguntas para Reflexão:\n\nPor que a pilha é a estrutura ideal para avaliação de expressões RPN?\nComo o algoritmo de conversão infixa→RPN gerencia precedência de operadores?\nQue aconteceria se usássemos uma fila em vez de pilha para RPN?\nComo esta implementação se relaciona com compiladores reais?\nQue otimizações poderiam ser feitas para expressões muito grandes?\n\n\n\n8.6.5 Extensões para Alunos Avançados:\n\nImplementar suporte a funções matemáticas (sin, cos, log);\nAdicionar variáveis e constantes às expressões;\nCriar interface gráfica para visualizar o funcionamento da pilha;\nImplementar otimizações para expressões com muitas constantes;\nComparar performance com biblioteca padrão (std::stack).\n\n\n\n\n\n[1] SWELLER, J. Cognitive load theory. Psychology of Learning and Motivation, v. 55, p. 37–76, 2011. \n\n\n[2] ROHRER, D.; TAYLOR, K. The shuffling of mathematics problems improves learning. Instructional Science, v. 35, n. 6, p. 481–498, 2007. \n\n\n[3] ROEDIGER, H. L.; BUTLER, A. C. The critical role of retrieval practice in long-term retention. Trends in Cognitive Sciences, v. 15, n. 1, p. 20–27, 2011. \n\n\n[4] CHI, M. T. H. et al. Eliciting self-explanations improves understanding. Cognitive Science, v. 18, n. 3, p. 439–477, 1994. \n\n\n[5] CEPEDA, N. J. et al. Distributed practice in verbal recall tasks: A review and quantitative synthesis. Psychological Bulletin, v. 132, n. 3, p. 354–380, 2006. \n\n\n[6] SCHRAW, G.; MOSHMAN, D. Metacognitive theories. Educational Psychology Review, v. 7, n. 4, p. 351–371, 1995.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>**Módulo 3**: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span>"
    ]
  },
  {
    "objectID": "desenv4.html",
    "href": "desenv4.html",
    "title": "9  Módulo 4: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos",
    "section": "",
    "text": "9.1 Depuração Sistemática\nEsta etapa final do aprendizado se concentrará na Depuração Sistemática, uma competência fundamental para o desenvolvimento de software robusto. Serão exercitadas algumas das técnicas formais para a identificação de erros, métodos de teste e procedimentos para o rastreamento da execução de programas.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Módulo 4**: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span>"
    ]
  },
  {
    "objectID": "desenv4.html#depuração-sistemática",
    "href": "desenv4.html#depuração-sistemática",
    "title": "9  Módulo 4: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos",
    "section": "",
    "text": "Princípios de Teste de Software: serão abordados os fundamentos do teste de software, incluindo teste de unidade e teste de integração. A abordagem será prática, por meio de um conjunto de exercícios que permitirão aos alunos aplicar os conceitos em cenários controlados.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Módulo 4**: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span>"
    ]
  },
  {
    "objectID": "desenv4.html#controle-de-versão-e-colaboração",
    "href": "desenv4.html#controle-de-versão-e-colaboração",
    "title": "9  Módulo 4: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos",
    "section": "9.2 Controle de Versão e Colaboração",
    "text": "9.2 Controle de Versão e Colaboração\n\nSistemas de Controle de Versão: introdução aos sistemas de controle de versão, com foco no projeto Git (1) e na plataforma GitHub (2). O objetivo é demonstrar como essas ferramentas facilitam o desenvolvimento colaborativo, o gerenciamento de alterações e o rastreamento de erros em projetos de software. Estes sistemas serão utilizados para versionar o código desenvolvido pelos alunos, permitindo que eles aprendam a colaborar efetivamente em projetos de programação mesmo que não estejam fisicamente juntos.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Módulo 4**: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span>"
    ]
  },
  {
    "objectID": "desenv4.html#exercícios-sistemas-complexos-com-testes-e-controle-de-versão",
    "href": "desenv4.html#exercícios-sistemas-complexos-com-testes-e-controle-de-versão",
    "title": "9  Módulo 4: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos",
    "section": "9.3 Exercícios: Sistemas Complexos com Testes e Controle de Versão",
    "text": "9.3 Exercícios: Sistemas Complexos com Testes e Controle de Versão\nEstes exercícios são os mais complexos e desafiadores da disciplina. Ainda assim, eles foram planejados para serem acessíveis, exigindo a aplicação de todos os conceitos aprendidos, de forma progressiva. Caberá ao professor apresentar a teoria de testes unitários, testes de integração e controle de versão, de forma lúdica, fluida e interativa. Os exercícios também foram projetados para serem aplicados com a Técnica da Sequência de Fibonacci. Todavia, existem \\(8\\) exercícios, em vez dos \\(7\\) (1, 1, 2, 3) que usamos antes. Este execício extra, o A4 pode ser usado pelo professor para introduzir os conceitos necessários.\nTodos os exercícios foram planejados considerando que os alunos poderão usar as ferramentas de busca e inquisição baseadas em Inteligência Artificial, para auxiliar na resolução dos problemas complementando conhecimentos que não estejam diretamente ligados a resolução do problema ou ao Raciocínio Algorítmico. Por exemplo, o professor deve incentivar o uso dessas ferramentas para desenvolver testes automatizados no Github. A ideia é que os alunos aprendam a usar essas ferramentas como ferramentas de suporte ao processo de aprendizado e resolução de problemas sem perder a autonomia e o controle sobre seu próprio aprendizado.\n\n9.3.1 Par 1: Sistema de Biblioteca Digital\n\n9.3.1.1 A4: O Bibliotecário Virtual Inteligente**\nUma biblioteca universitária precisa modernizar seu sistema de gestão, criando um programa que gerencie empréstimos, devoluções, multas e recomendações de livros. O sistema deve trabalhar com múltiplos arquivos CSV (livros.csv, usuarios.csv, emprestimos.csv) e oferecer funcionalidades como busca inteligente, cálculo automático de multas e sugestões personalizadas baseadas no histórico de leitura.\nFunções a implementar:\n\nEstruturas de dados: arrays para livros, usuários e empréstimos; estruturas para representar cada entidade;\nFunções de validação: validarLivro(), validarUsuario(), validarDataEmprestimo(), validarCPF();\nFunções de cálculo: calcularMulta(), calcularPrazoVencimento(), calcularCompatibilidadeLeitura();\nFunções de busca: buscarLivroPorTitulo(), buscarLivroPorAutor(), buscarUsuarioPorCPF(), verificarDisponibilidade();\nFunções de recomendação: sugerirLivrosSimilares(), analisarHistoricoUsuario(), gerarRecomendacaoPersonalizada();\nFunções de relatório: gerarRelatorioEmprestimos(), gerarRelatorioMultas(), gerarEstatisticasGerais();\nFunções de persistência: salvarLivros(), carregarLivros(), salvarEmprestimos(), carregarEmprestimos().\n\nEntrada: dados de livros (ISBN, título, autor, categoria, ano), usuários (CPF, nome, curso, semestre) e empréstimos (data, prazo, status).\nSaída: Sistema interativo com menus para todas as operações, relatórios formatados e recomendações personalizadas.\n\n9.3.1.1.1 Decomposição: Divisão de Tarefas para o Problema A4\nAluno 1: Módulo de Validação + Testes de Persistência\n\nDesenvolver: validarLivro(), validarUsuario(), validarDataEmprestimo(), validarCPF();\nTestar: Funções de persistência do Aluno 4 (salvarLivros(), carregarLivros(), salvarEmprestimos(), carregarEmprestimos());\nTestes a criar: testarSalvarLivros(), testarCarregarLivros(), testarSalvarEmprestimos(), testarCarregarEmprestimos();\nFoco: Garantir entrada de dados válida e verificar se persistência funciona corretamente.\n\nAluno 2: Módulo de Cálculos + Testes de Validação\n\nDesenvolver: calcularMulta(), calcularPrazoVencimento(), calcularCompatibilidadeLeitura(), verificarDisponibilidade();\nTestar: Funções de validação do Aluno 1 (validarLivro(), validarUsuario(), validarDataEmprestimo(), validarCPF());\nTestes a criar: testarValidarLivro(), testarValidarUsuario(), testarValidarDataEmprestimo(), testarValidarCPF();\nFoco: Algoritmos de cálculo precisos e validação robusta de entrada.\n\nAluno 3: Módulo de Busca e Relatórios + Testes de Cálculos\n\nDesenvolver: buscarLivroPorTitulo(), buscarLivroPorAutor(), buscarUsuarioPorCPF(), gerarRelatorioEmprestimos(), gerarRelatorioMultas(), gerarEstatisticasGerais();\nTestar: Funções de cálculo do Aluno 2 (calcularMulta(), calcularPrazoVencimento(), calcularCompatibilidadeLeitura(), verificarDisponibilidade());\nTestes a criar: testarCalcularMulta(), testarCalcularPrazoVencimento(), testarCalcularCompatibilidadeLeitura(), testarVerificarDisponibilidade();\nFoco: Busca eficiente e relatórios informativos com cálculos corretos.\n\nAluno 4: Módulo de Recomendação e Persistência + Testes de Busca\n\nDesenvolver: sugerirLivrosSimilares(), analisarHistoricoUsuario(), gerarRecomendacaoPersonalizada(), salvarLivros(), carregarLivros(), salvarEmprestimos(), carregarEmprestimos();\nTestar: Funções de busca e relatórios do Aluno 3 (buscarLivroPorTitulo(), buscarLivroPorAutor(), buscarUsuarioPorCPF(), gerarRelatorioEmprestimos(), gerarRelatorioMultas(), gerarEstatisticasGerais());\nTestes a criar: testarBuscarLivroPorTitulo(), testarBuscarLivroPorAutor(), testarBuscarUsuarioPorCPF(), testarGerarRelatorioEmprestimos(), testarGerarRelatorioMultas(), testarGerarEstatisticasGerais();\nFoco: Sistema de recomendação inteligente e verificação da precisão das buscas.\n\n\n\n\n9.3.1.2 B4: Testando a Biblioteca dos Sonhos\nImplementação completa do sistema da biblioteca com todas as funções de A4, agora com foco na integração entre módulos e refinamento dos testes. Cada aluno implementa suas funções de A4 e melhora os testes que já desenvolveu, criando cenários mais complexos e edge cases.\nFunções a implementar:\n\nTodas as funções de A4 totalmente implementadas;\nAprimoramento dos testes unitários com mais cenários;\nInterface principal integrando todos os módulos;\nSistema de logs para rastrear operações.\n\nEntrada: Datasets de teste mais complexos com casos extremos e dados corrompidos;\nSaída: Sistema robusto com testes abrangentes e relatórios de qualidade\n\n9.3.1.2.1 Decomposição: Divisão de Tarefas para o Problema B4\nAluno 1: Refinamento de Validação + Testes Avançados de Persistência\n\nImplementar: versões robustas das funções de validação de A4;\nExpandir testes: criar 3-4 cenários de teste para cada função de persistência;\nCasos extremos: arquivos corrompidos, dados inconsistentes, limites de memória;\nFoco: validação à prova de falhas e persistência confiável.\n\nAluno 2: Otimização de Cálculos + Testes Complexos de Validação\n\nImplementar: versões otimizadas das funções de cálculo de A4;\nExpandir testes: criar 3-4 cenários para cada função de validação;\nCasos extremos: datas inválidas, CPFs mal formados, dados vazios;\nFoco: cálculos precisos e validação abrangente.\n\nAluno 3: Interface Principal + Testes de Performance de Cálculos\n\nImplementar: interface que integra busca e relatórios de A4;\nExpandir testes: testar performance e precisão dos cálculos;\nCasos extremos: grandes volumes de dados, cálculos com overflow;\nFoco: interface intuitiva e verificação de performance.\n\nAluno 4: Sistema de Logs + Testes de Integração de Busca\n\nImplementar: sistema de recomendação e persistência de A4 + logs;\nExpandir testes: testar busca com grandes datasets;\nCasos extremos: buscas com critérios inexistentes, dados duplicados;\nFoco: rastreabilidade do sistema e busca robusta.\n\n\n\n\n\n9.3.2 Par 2: Sistema de Delivery de Comida\n\n9.3.2.1 C4: O Delivery que Nunca Falha**\nUma startup de delivery precisa de um sistema robusto que gerencie pedidos, calcule fretes, estime tempos de entrega e processe pagamentos. O sistema deve trabalhar com dados de restaurantes, pratos, clientes e entregadores, oferecendo funcionalidades como aplicação de descontos promocionais, rastreamento de pedidos e análise de satisfação do cliente.\nFunções a implementar:\n\nEstruturas de dados: arrays para restaurantes, pratos, clientes, pedidos e entregadores;\nFunções de validação: validarPedido(), validarEnderecoEntrega(), validarFormaPagamento(), validarPromocao();\nFunções de cálculo: calcularFrete(), calcularDesconto(), calcularTaxaServico(), calcularTempoEstimado();\nFunções de processamento: processarPagamento(), alocarEntregador(), atualizarStatusPedido(), confirmarEntrega();\nFunções de rastreamento: rastrearPedido(), notificarCliente(), atualizarLocalizacao(), calcularTempoRestante();\nFunções de análise: avaliarRestaurante(), analisarSatisfacao(), gerarRelatorioVendas(), identificarProblemasEntrega();\nFunções de persistência: salvarPedidos(), carregarRestaurantes(), salvarAvaliacoes(), carregarHistorico();\n\nEntrada: Dados de restaurantes (nome, endereço, cardápio, avaliação), pedidos (itens, quantidade, observações) e informações de entrega.\nSaída: Interface de pedidos com cálculos em tempo real, sistema de rastreamento e relatórios de performance.\n\n9.3.2.1.1 Decomposição: Divisão de Tarefas para o Problema C4\nAluno 1: Módulo de Validação + Testes de Análise\n\nDesenvolver: validarPedido(), validarEnderecoEntrega(), validarFormaPagamento(), validarPromocao();\nTestar: Funções de análise do Aluno 4 (avaliarRestaurante(), analisarSatisfacao(), gerarRelatorioVendas(), identificarProblemasEntrega());\nTestes a criar: testarAvaliarRestaurante(), testarAnalisarSatisfacao(), testarGerarRelatorioVendas(), testarIdentificarProblemasEntrega();\nFoco: Entrada de dados confiável e verificação da qualidade das análises.\n\nAluno 2: Módulo de Cálculos + Testes de Validação\n\nDesenvolver: calcularFrete(), calcularDesconto(), calcularTaxaServico(), calcularTempoEstimado();\nTestar: Funções de validação do Aluno 1 (validarPedido(), validarEnderecoEntrega(), validarFormaPagamento(), validarPromocao());\nTestes a criar: testarValidarPedido(), testarValidarEnderecoEntrega(), testarValidarFormaPagamento(), testarValidarPromocao();\nFoco: Cálculos financeiros precisos e validação robusta.\n\nAluno 3: Módulo de Processamento + Testes de Cálculos\n\nDesenvolver: processarPagamento(), alocarEntregador(), atualizarStatusPedido(), confirmarEntrega();\nTestar: Funções de cálculo do Aluno 2 (calcularFrete(), calcularDesconto(), calcularTaxaServico(), calcularTempoEstimado());\nTestes a criar: testarCalcularFrete(), testarCalcularDesconto(), testarCalcularTaxaServico(), testarCalcularTempoEstimado();\nFoco: Fluxo de processamento eficiente e cálculos corretos.\n\nAluno 4: Módulo de Rastreamento e Análise + Testes de Processamento\n\nDesenvolver: rastrearPedido(), notificarCliente(), atualizarLocalizacao(), calcularTempoRestante(), avaliarRestaurante(), analisarSatisfacao(), gerarRelatorioVendas(), identificarProblemasEntrega();\nTestar: Funções de processamento do Aluno 3 (processarPagamento(), alocarEntregador(), atualizarStatusPedido(), confirmarEntrega());\nTestes a criar: testarProcessarPagamento(), testarAlocarEntregador(), testarAtualizarStatusPedido(), testarConfirmarEntrega();\nFoco: Sistema de rastreamento em tempo real e verificação do processamento\n\n\n\n\n9.3.2.2 D4: Integrando o Restaurante Digital\nImplementação completa do sistema de delivery com foco em fluxos integrados. O sistema deve demonstrar como validação, cálculos, processamento e rastreamento trabalham em conjunto, simulando o fluxo completo desde o pedido até a entrega.\nFunções a implementar:\n\nTodas as funções de C4 implementadas e integradas;\nFluxos completos de negócio (pedido → pagamento → entrega);\nTratamento de erros em cenários reais;\nMétricas de performance do sistema.\n\nEntrada: Simulação de múltiplos pedidos simultâneos com cenários de stress.\nSaída: Sistema integrado com relatórios de fluxo e métricas de performance.\n\n9.3.2.2.1 Decomposição: Divisão de Tarefas para o Problema D4\nAluno 1: Coordenação de Fluxos + Testes de Stress de Análise\n\nImplementar: sistema que coordena validação com outros módulos;\nExpandir testes: testar análises com grandes volumes de dados;\nCenários complexos: múltiplos pedidos simultâneos, análises em tempo real;\nFoco: coordenação entre módulos e robustez das análises.\n\nAluno 2: Otimização de Performance + Testes de Integração de Validação\n\nImplementar: versões otimizadas dos cálculos para alta demanda;\nExpandir testes: testar validação em cenários de stress;\nCenários complexos: validação de centenas de pedidos por minuto;\nFoco: performance sob carga e validação eficiente.\n\nAluno 3: Tratamento de Erros + Testes de Fluxo de Cálculos\n\nImplementar: sistema robusto de processamento com recuperação de erros;\nExpandir testes: testar cálculos em cenários de falha;\nCenários complexos: falhas de rede, timeouts, dados corrompidos;\nFoco: resiliência do sistema e confiabilidade dos cálculos.\n\nAluno 4: Monitoramento e Métricas + Testes End-to-End\n\nImplementar: sistema de monitoramento do rastreamento e análise;\nExpandir testes: testes completos do fluxo pedido → entrega;\nCenários complexos: fluxos com falhas e recuperação automática;\nFoco: observabilidade do sistema e testes de ponta a ponta.\n\n\n\n\n\n9.3.3 Par 3: Sistema de Rede Social Universitária\n\n9.3.3.1 E4: A Rede Social da Turma**\nUma universidade quer criar uma rede social interna para conectar estudantes, professores e funcionários. O sistema deve gerenciar perfis, conexões, posts, eventos e grupos de estudo, oferecendo funcionalidades como feed personalizado, sistema de compatibilidade acadêmica e análise de sentimentos das postagens.\nFunções a implementar:\n\nEstruturas de dados: arrays para usuários, posts, conexões, grupos e eventos;\nFunções de validação: validarUsuario(), validarPost(), validarEvento(), validarGrupo();\nFunções de compatibilidade: calcularCompatibilidadeAcademica(), sugerirAmigos(), analisarInteressesComuns(), identificarGruposRelevantes();\nFunções de conteúdo: filtrarPosts(), ordenarFeed(), moderarConteudo(), analisarSentimento();\nFunções sociais: criarConexao(), removerConexao(), bloquearUsuario(), reportarConteudo();\nFunções de eventos: criarEvento(), confirmarPresenca(), notificarParticipantes(), gerarResumoEvento();\nFunções de análise: gerarEstatisticasPerfil(), analisarEngajamento(), identificarTendencias(), gerarRelatorioAtividade().\n\nEntrada: dados de usuários (matrícula, curso, interesses), posts (texto, imagens, tags) e eventos (data, local, descrição).\nSaída: interface social com feed personalizado, sugestões de conexões e análise de atividade.\n\n9.3.3.1.1 Decomposição: Divisão de Tarefas para o Problema E4\nAluno 1: Módulo de Validação + Testes de Eventos\n\nDesenvolver: validarUsuario(), validarPost(), validarEvento(), validarGrupo();\nTestar: Funções de eventos do Aluno 4 (criarEvento(), confirmarPresenca(), notificarParticipantes(), gerarResumoEvento());\nTestes a criar: testarCriarEvento(), testarConfirmarPresenca(), testarNotificarParticipantes(), testarGerarResumoEvento();\nFoco: Validação robusta de conteúdo social e funcionamento dos eventos.\n\nAluno 2: Módulo de Compatibilidade + Testes de Validação\n\nDesenvolver: calcularCompatibilidadeAcademica(), sugerirAmigos(), analisarInteressesComuns(), identificarGruposRelevantes();\nTestar: Funções de validação do Aluno 1 (validarUsuario(), validarPost(), validarEvento(), validarGrupo());\nTestes a criar: testarValidarUsuario(), testarValidarPost(), testarValidarEvento(), testarValidarGrupo();\nFoco: Algoritmos sociais inteligentes e validação de entrada.\n\nAluno 3: Módulo de Conteúdo e Social + Testes de Compatibilidade\n\nDesenvolver: filtrarPosts(), ordenarFeed(), moderarConteudo(), analisarSentimento(), criarConexao(), removerConexao(), bloquearUsuario(), reportarConteudo();\nTestar: Funções de compatibilidade do Aluno 2 (calcularCompatibilidadeAcademica(), sugerirAmigos(), analisarInteressesComuns(), identificarGruposRelevantes());\nTestes a criar: testarCalcularCompatibilidadeAcademica(), testarSugerirAmigos(), testarAnalisarInteressesComuns(), testarIdentificarGruposRelevantes();\nFoco: curadoria de conteúdo e verificação dos algoritmos sociais.\n\nAluno 4: Módulo de Eventos e Análise + Testes de Conteúdo\n\nDesenvolver: criarEvento(), confirmarPresenca(), notificarParticipantes(), gerarResumoEvento(), gerarEstatisticasPerfil(), analisarEngajamento(), identificarTendencias(), gerarRelatorioAtividade();\nTestar: Funções de conteúdo do Aluno 3 (filtrarPosts(), ordenarFeed(), moderarConteudo(), analisarSentimento(), criarConexao(), removerConexao(), bloquearUsuario(), reportarConteudo());\nTestes a criar: testarFiltrarPosts(), testarOrdenarFeed(), testarModerarConteudo(), testarAnalisarSentimento(), testarCriarConexao(), testarRemoverConexao(), testarBloquearUsuario(), testarReportarConteudo();\nFoco: gestão de eventos e verificação da curadoria de conteúdo.\n\n\n\n\n9.3.3.2 F4: Conectando a Universidade**\nImplementação completa da rede social com foco em desenvolvimento colaborativo usando Git. O sistema deve demonstrar fluxos de trabalho em equipe, resolução de conflitos de merge e implementação de features em paralelo usando controle de versão.\nFunções a implementar:\n\nTodas as funções de E4 implementadas com controle de versão;\nWorkflow de desenvolvimento usando Git (branches, pull requests);\nResolução colaborativa de conflitos de merge;\nDocumentação e versionamento do código.\n\nEntrada: desenvolvimento colaborativo com múltiplas features em paralelo.\nSaída: sistema integrado com histórico completo de desenvolvimento no Git.\n\n9.3.3.2.1 Decomposição: Divisão de Tarefas para o Problema F4\nAluno 1: Feature Branch ‘validation’ + Gestão de Conflitos\n\nImplementar: módulo de validação de E4 em branch separada;\nGit workflow: criar branch feature/validation, commits regulares;\nResolução de conflitos: coordenar merges com outras features;\nFoco: desenvolvimento isolado e integração colaborativa.\n\nAluno 2: Feature Branch ‘social-algorithms’ + Code Review\n\nImplementar: módulo de compatibilidade de E4 em branch separada;\nGit workflow: branch feature/social-algorithms, pull requests;\nCode review: revisar código dos outros alunos antes do merge;\nFoco: qualidade de código e revisão colaborativa.\n\nAluno 3: Feature Branch ‘content-curation’ + Documentação\n\nImplementar: módulo de conteúdo de E4 em branch separada;\nGit workflow: branch feature/content-curation, documentação no Git;\nDocumentação: README, comentários, wiki do projeto;\nFoco: funcionalidades principais e documentação clara.\n\nAluno 4: Branch ‘events-analytics’ + Integração Final\n\nImplementar: módulo de eventos de E4 em branch separada;\nGit workflow: branch feature/events-analytics, coordenação de merges;\nIntegração: merge final de todas as features na branch main;\nFoco: coordenação geral e integração do projeto.\n\n\n\n\n\n9.3.4 Par 4: Sistema de E-commerce Estudantil (COM TESTES DE INTEGRAÇÃO)\n\n9.3.4.1 G4: A Loja Virtual dos Universitários\nEstudantes universitários querem criar um marketplace para vender e trocar itens entre colegas (livros usados, eletrônicos, roupas, materiais de estudo). O sistema deve gerenciar produtos, vendedores, compradores, transações e avaliações, oferecendo funcionalidades como busca inteligente, sistema de reputação e cálculo automático de preços baseado em condição do produto.\nFunções a implementar:\n\nEstruturas de dados: Arrays para produtos, usuários, transações, avaliações e categorias;\nFunções de validação: validarProduto(), validarTransacao(), validarAvaliacao(), validarPagamento();\nFunções de precificação: calcularPrecoFinal(), aplicarDesconto(), calcularFrete(), estimarDepreciacao();\nFunções de estoque: gerenciarEstoque(), verificarDisponibilidade(), reservarProduto(), atualizarQuantidade();\nFunções de busca: buscarProdutos(), filtrarPorCategoria(), ordenarResultados(), buscarVendedor();\nFunções de recomendação: recomendarProdutos(), analisarHistoricoCompras(), sugerirSimilares(), identificarTendencias();\nFunções de avaliação: processarAvaliacao(), calcularReputacao(), gerarRelatorioVendedor(), moderarComentarios();\nFunções financeiras: processarPagamento(), calcularComissao(), gerarFatura(), processarEstorno().\n\nINTRODUÇÃO A TESTES DE INTEGRAÇÃO: Neste exercício, além dos testes unitários simples, cada aluno criará testes de integração que verificam como seus módulos interagem com os de outros alunos.\nEntrada: dados de produtos (nome, categoria, condição, preço), usuários vendedores/compradores e transações.\nSaída: marketplace funcional com sistema de busca, avaliações e relatórios de vendas.\n\n9.3.4.1.1 Decomposição: Divisão de Tarefas para o Problema G4\nAluno 1: Módulo de Validação + Testes de Integração Financeiro\n\nDesenvolver: validarProduto(), validarTransacao(), validarAvaliacao(), validarPagamento();\nTestar unitário: Funções financeiras do Aluno 4 (processarPagamento(), calcularComissao(), gerarFatura(), processarEstorno());\nTestes de integração: testarFluxoValidacaoParaPagamento() - verificar se dados validados fluem corretamente para o módulo financeiro;\nFoco: Validação robusta e integração com sistema financeiro.\n\nAluno 2: Módulo de Precificação e Estoque + Testes de Integração Validação\n\nDesenvolver: calcularPrecoFinal(), aplicarDesconto(), calcularFrete(), estimarDepreciacao(), gerenciarEstoque(), verificarDisponibilidade(), reservarProduto(), atualizarQuantidade();\nTestar unitário: Funções de validação do Aluno 1 (validarProduto(), validarTransacao(), validarAvaliacao(), validarPagamento());\nTestes de integração: testarFluxoProdutoValidadoParaEstoque() - verificar se produtos validados são corretamente adicionados ao estoque;\nFoco: Gestão de preços/estoque e integração com validação.\n\nAluno 3: Módulo de Busca e Recomendação + Testes de Integração Estoque\n\nDesenvolver: buscarProdutos(), filtrarPorCategoria(), ordenarResultados(), buscarVendedor(), recomendarProdutos(), analisarHistoricoCompras(), sugerirSimilares(), identificarTendencias();\nTestar unitário: Funções de estoque do Aluno 2 (gerenciarEstoque(), verificarDisponibilidade(), reservarProduto(), atualizarQuantidade());\nTestes de integração: testarBuscaComEstoqueAtualizado() - verificar se busca reflete mudanças de estoque em tempo real;\nFoco: Sistema de busca inteligente e integração com estoque.\n\nAluno 4: Módulo Financeiro e Avaliação + Testes de Integração Busca\n\nDesenvolver: processarPagamento(), calcularComissao(), gerarFatura(), processarEstorno(), processarAvaliacao(), calcularReputacao(), gerarRelatorioVendedor(), moderarComentarios();\nTestar unitário: Funções de busca do Aluno 3 (buscarProdutos(), filtrarPorCategoria(), ordenarResultados(), buscarVendedor());\nTestes de integração: testarCompraCompletaComBusca() - verificar fluxo completo: busca → seleção → pagamento → avaliação;\nFoco: Sistema financeiro e integração com todo o fluxo de compra.\n\n\n\n\n9.3.4.2 H4: Lançando o Marketplace da Turma\nProjeto final integrando todas as competências do módulo: testes unitários, testes de integração avançados e controle de versão com CI/CD. O sistema deve demonstrar um pipeline completo de desenvolvimento com automated testing, code review e releases via GitHub.\nFERRAMENTAS DE TESTE DE INTEGRAÇÃO:\n\nPython: pytest com fixtures e mocks;\nC++: doctest ou Catch2 com seções de integração.\n\nFunções a implementar:\n\nimplementação completa de todas as funções do G4;\ntestes unitários e de integração para todas as funções;\nPipeline CI/CD básico usando GitHub Actions;\nTestes automatizados com framework de teste;\nSistema de releases e versionamento semântico.\n\nEntrada: desenvolvimento colaborativo com múltiplas features, releases e hotfixes.\nSaída: marketplace funcional com pipeline de desenvolvimento profissional completo.\n\n9.3.4.2.1 Decomposição: Divisão de Tarefas para o Problema H4\nAluno 1: Implementação Core + Suite de Testes Unitários\n\nImplementar: módulo de validação de G4 com melhorias;\nFramework de teste: Configurar pytest (Python) ou doctest (C++) no projeto;\nTestes automatizados: Criar 20+ testes unitários com cobertura \\(&gt;80\\%\\);\nCI/CD: Configurar GitHub Actions para executar testes automaticamente;\nFoco: Base sólida com testes automatizados.\n\nAluno 2: Features Avançadas + Testes de Integração\n\nImplementar: Módulo de precificação/estoque de G4 com otimizações;\nTestes de integração: Usar framework para testar interação entre módulos;\nPerformance testing: Testes de carga e stress usando ferramentas do framework;\nMocks e fixtures: Criar dados de teste reutilizáveis;\nFoco: Testes sofisticados e análise de performance.\n\nAluno 3: Interface e UX + Testes End-to-End\n\nImplementar: Módulo de busca/recomendação de G4 com interface melhorada;\nTestes end-to-end: Testar fluxos completos de usuário;\nDocumentação: Criar documentação técnica e de usuário;\nCode coverage: Gerar relatórios de cobertura de código;\nFoco: Experiência do usuário e testes abrangentes.\n\nAluno 4: DevOps e Release Management + Integração Contínua\n\nImplementar: Módulo financeiro de G4 com logging e monitoramento;\nDevOps: Configurar pipeline completo de CI/CD no GitHub;\nRelease management: Implementar versionamento semântico e releases automatizadas;\nQuality gates: Configurar verificações automáticas de qualidade;\nMonitoring: Sistema básico de logs e métricas;\nFoco: Automação e gestão de releases profissional.",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Módulo 4**: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span>"
    ]
  },
  {
    "objectID": "desenv4.html#metodologia-de-testes-unitários-simples",
    "href": "desenv4.html#metodologia-de-testes-unitários-simples",
    "title": "9  Módulo 4: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos",
    "section": "9.4 Metodologia de Testes Unitários Simples",
    "text": "9.4 Metodologia de Testes Unitários Simples\n\n9.4.1 Para Exercícios A4-F4 (Sem Frameworks)\nOs testes devem ser funções simples que retornam true se o teste passou ou false se falhou:\nExemplo em C++:\nbool testarValidarLivro() {\n    // Teste caso válido\n    if (!validarLivro(\"1234567890123\", \"Algoritmos\", \"Cormen\", 2020)) {\n        cout &lt;&lt; \"ERRO: Livro válido rejeitado\" &lt;&lt; endl;\n        return false;\n    }\n    \n    // Teste caso inválido - ISBN curto\n    if (validarLivro(\"123\", \"Título\", \"Autor\", 2020)) {\n        cout &lt;&lt; \"ERRO: ISBN inválido aceito\" &lt;&lt; endl;\n        return false;\n    }\n    \n    // Teste caso inválido - ano futuro\n    if (validarLivro(\"1234567890123\", \"Título\", \"Autor\", 2030)) {\n        cout &lt;&lt; \"ERRO: Ano futuro aceito\" &lt;&lt; endl;\n        return false;\n    }\n    \n    cout &lt;&lt; \"✓ testarValidarLivro passou em todos os casos\" &lt;&lt; endl;\n    return true;\n}\nExemplo em Python:\ndef testar_validar_livro():\n    # Teste caso válido\n    if not validar_livro(\"1234567890123\", \"Algoritmos\", \"Cormen\", 2020):\n        print(\"ERRO: Livro válido rejeitado\")\n        return False\n    \n    # Teste caso inválido - ISBN curto\n    if validar_livro(\"123\", \"Título\", \"Autor\", 2020):\n        print(\"ERRO: ISBN inválido aceito\")\n        return False\n    \n    # Teste caso inválido - ano futuro\n    if validar_livro(\"1234567890123\", \"Título\", \"Autor\", 2030):\n        print(\"ERRO: Ano futuro aceito\")\n        return False\n    \n    print(\"✓ testar_validar_livro passou em todos os casos\")\n    return True\n\n\n9.4.2 Para Exercícios G4-H4 (Com Frameworks)\nPython com pytest:\nimport pytest\n\ndef test_validar_produto():\n    assert validar_produto(\"Notebook Dell\", \"Eletrônicos\", \"Usado\", 1500.0)\n    assert not validar_produto(\"\", \"Eletrônicos\", \"Usado\", 1500.0)  # Nome vazio\n    assert not validar_produto(\"Notebook\", \"Categoria_Inexistente\", \"Usado\", 1500.0)\n\ndef test_integracao_validacao_estoque():\n    # Teste de integração\n    produto = {\"nome\": \"iPhone 12\", \"categoria\": \"Eletrônicos\", \"preco\": 2000.0}\n    assert validar_produto(produto[\"nome\"], produto[\"categoria\"], \"Novo\", produto[\"preco\"])\n    assert adicionar_ao_estoque(produto)\n    assert verificar_disponibilidade(produto[\"nome\"]) &gt; 0\nC++ com doctest:\n#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include \"doctest.h\"\n\nTEST_CASE(\"Validação de produto\") {\n    CHECK(validarProduto(\"Notebook Dell\", \"Eletrônicos\", \"Usado\", 1500.0));\n    CHECK_FALSE(validarProduto(\"\", \"Eletrônicos\", \"Usado\", 1500.0)); // Nome vazio\n}\n\nTEST_CASE(\"Integração validação-estoque\") {\n    Produto p = {\"iPhone 12\", \"Eletrônicos\", 2000.0, \"Novo\"};\n    REQUIRE(validarProduto(p.nome, p.categoria, p.condicao, p.preco));\n    REQUIRE(adicionarAoEstoque(p));\n    CHECK(verificarDisponibilidade(p.nome) &gt; 0);\n}",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Módulo 4**: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span>"
    ]
  },
  {
    "objectID": "desenv4.html#rubrica-e-tecnologia-de-avaliação",
    "href": "desenv4.html#rubrica-e-tecnologia-de-avaliação",
    "title": "9  Módulo 4: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos",
    "section": "9.5 Rubrica e Tecnologia de Avaliação",
    "text": "9.5 Rubrica e Tecnologia de Avaliação\nA avaliação dos exercicios pode, e deve ser completamente automatizada usando ferramentas de Inteligência Artificial integradas ao Github Classroom (3), para verificar a implementação e os testes. Os critérios de avaliação podem incluir:\n\nFuncionalidade: \\(25\\%\\) - Sistema funciona conforme especificado\nQualidade dos Testes: \\(30\\%\\) - Cobertura, cenários e qualidade dos testes\nColaboração: \\(25\\%\\) - Divisão de tarefas e trabalho em equipe efetivo\nControle de Versão: \\(20\\%\\) - Uso adequado do Git (F4 e H4)\n\n\n9.5.1 Visão Geral da Avaliação\nPúblico-alvo: alunos do primeiro período de Computação;\nModalidade: avaliação automatizada via GitHub Classroom integrado a ferramentas de Inteligência Artificial;\nA tabela Table 9.1 resume os critérios de avaliação e seus pesos:\n\n\n\nTable 9.1: Tabela de Rubrica de Avaliação.\n\n\n\n\n\nCritério\nPeso\nPontos Máximos\n\n\n\n\nFuncionalidade\n25%\n25\n\n\nQualidade dos Testes\n30%\n30\n\n\nColaboração\n25%\n25\n\n\nControle de Versão\n20%\n20\n\n\nTOTAL\n100%\n100\n\n\n\n\n\n\n\n\n9.5.2 Critério 1: Funcionalidade (25 pontos)\nDescrição: sistema implementado funciona conforme especificação, com todas as funções operacionais e requisitos atendidos. A tabela Table 9.2 define os níveis de funcionalidade e seus indicadores quantitativos:\n\n\n\nTable 9.2: Tabela de Níveis de Funcionalidade para Avaliação.\n\n\n\n\n\n\n\n\n\n\n\nNível\nPontos\nDescrição\nIndicadores Quantitativos\n\n\n\n\nAvançado\n22-25\nSistema funciona perfeitamente em todos os cenários testados\n• 90-100% das funções implementadas• 0 erros de compilação• 0 crashes durante execução• Todos os requisitos funcionais atendidos\n\n\nProficiente\n18-21\nSistema funciona bem na maioria dos cenários\n• 75-89% das funções implementadas• 0 erros de compilação• Máximo 1 crash em cenários extremos• 80%+ dos requisitos atendidos\n\n\nDesenvolvendo\n12-17\nSistema funciona parcialmente com algumas limitações\n• 50-74% das funções implementadas• Máximo 2 erros menores de compilação• Funciona para casos básicos• 60%+ dos requisitos atendidos\n\n\nIniciante\n0-11\nSistema não funciona ou funciona de forma muito limitada\n• Menos de 50% das funções implementadas• Múltiplos erros de compilação• Falhas frequentes de execução• Menos de 60% dos requisitos atendidos\n\n\n\n\n\n\n\n9.5.2.1 Métricas Automatizadas\n\nCompilação bem-sucedida (Python: execução sem SyntaxError, C++: g++ sem erros);\nExecução de casos de teste básicos sem crashes;\nCobertura de implementação das funções especificadas;\nValidação de entrada e tratamento de erros.\n\n\n\n\n9.5.3 Critério 2: Qualidade dos Testes (30 pontos)\nDescrição: Testes unitários e de integração demonstram compreensão da verificação de software e cobertura adequada dos cenários. A tabela Table 9.3 define os níveis de qualidade dos testes e seus indicadores quantitativos:\n\n\n\nTable 9.3: Tabela de Níveis de Qualidade dos Testes para Avaliação.\n\n\n\n\n\n\n\n\n\n\n\nNível\nPontos\nDescrição\nIndicadores Quantitativos\n\n\n\n\nAvançado\n26-30\nTestes abrangentes com cenários complexos e edge cases\n• 15+ testes unitários implementados• 90%+ dos testes passando• Inclui casos extremos e erro• Testes claros e bem documentados• Divisão cruzada implementada corretamente\n\n\nProficiente\n21-25\nTestes adequados cobrindo cenários principais\n• 10-14 testes unitários implementados• 80-89% dos testes passando• Inclui alguns casos de erro• Maioria dos testes compreensíveis• Divisão cruzada parcialmente implementada\n\n\nDesenvolvendo\n13-20\nTestes básicos cobrindo funcionalidades principais\n• 6-9 testes unitários implementados• 70-79% dos testes passando• Casos básicos cobertos• Testes simples mas funcionais• Tentativa de divisão cruzada\n\n\nIniciante\n0-12\nTestes insuficientes ou inadequados\n• Menos de 6 testes implementados• Menos de 70% dos testes passando• Testes muito simples ou não funcionais• Sem divisão cruzada adequada\n\n\n\n\n\n\n\n9.5.3.1 Critérios Específicos por Exercício\n\n9.5.3.1.1 A4-F4: Testes Unitários Simples\n\nFunções testarFuncaoX() retornando bool;\nCasos válidos e inválidos testados;\nMensagens informativas de erro;\nCada aluno testa funções de outro aluno.\n\n\n\n9.5.3.1.2 G4-H4: Testes de Integração\n\nUso de framework (pytest/doctest);\nTestes de fluxo completo entre módulos;\nMocks e fixtures apropriados;\nTestes de performance e stress.\n\n\n\n9.5.3.1.3 Métricas Automatizadas\n\nNúmero de testes implementados vs especificados;\nTaxa de sucesso dos testes (% que passam);\nCobertura de casos de uso (normal, erro, extremo);\nQualidade da nomenclatura e documentação dos testes.\n\n\n\n\n\n9.5.4 Critério 3: Colaboração (25 pontos)\nDescrição: Trabalho em equipe efetivo com divisão clara de responsabilidades e integração colaborativa. A tabela Table 9.4 define os níveis de colaboração e seus indicadores quantitativos:\n\n\n\nTable 9.4: Tabela de Níveis de Colaboração para Avaliação.\n\n\n\n\n\n\n\n\n\n\n\nNível\nPontos\nDescrição\nIndicadores Quantitativos\n\n\n\n\nAvançado\n22-25\nColaboração exemplar com divisão equilibrada e integração perfeita\n• 4 alunos contribuindo ativamente• Commits equilibrados (15-35% cada)• Integração sem conflitos• Documentação colaborativa clara• Peer review efetivo\n\n\nProficiente\n18-21\nBoa colaboração com divisão adequada\n• 3-4 alunos contribuindo• Distribuição razoável de commits• Poucos conflitos de integração• Documentação adequada• Algum peer review\n\n\nDesenvolvendo\n12-17\nColaboração básica com algumas falhas de coordenação\n• 2-3 alunos contribuindo significativamente• Distribuição desigual de trabalho• Alguns problemas de integração• Documentação mínima\n\n\nIniciante\n0-11\nColaboração inadequada ou trabalho individual disfarçado\n• 1-2 alunos fazendo a maioria do trabalho• Commits concentrados• Falhas graves de integração• Pouca ou nenhuma documentação colaborativa\n\n\n\n\n\n\n\n9.5.4.1 Métricas Automatizadas:\n\nDistribuição de commits por autor;\nNúmero de pull requests e code reviews;\nFrequência de commits ao longo do tempo;\nResolução de conflitos de merge;\nQualidade das mensagens de commit.\n\n\n\n\n9.5.5 Critério 4: Controle de Versão (20 pontos)\nDescrição: uso adequado do Git e GitHub para versionamento, colaboração e integração contínua.\nNota: Aplicável apenas aos exercícios F4 e H4. A tabela Table 9.5 define os níveis de controle de versão e seus indicadores quantitativos:\n\n\n\nTable 9.5: Tabela de Níveis de Controle de Versão para Avaliação.\n\n\n\n\n\n\n\n\n\n\n\nNível\nPontos\nDescrição\nIndicadores Quantitativos\n\n\n\n\nAvançado\n18-20\nUso profissional do Git com workflow completo\n• Branches organizadas (feature/bugfix)• Pull requests com code review• Mensagens de commit descritivas• CI/CD funcionando (H4)• Releases com versionamento semântico• README e documentação atualizados\n\n\nProficiente\n14-17\nUso competente do Git com boas práticas\n• Uso básico de branches• Alguns pull requests• Mensagens de commit adequadas• Tentativa de CI/CD• Documentação básica\n\n\nDesenvolvendo\n10-13\nUso básico do Git com tentativas de organização\n• Commits regulares• Tentativa de usar branches• Mensagens de commit simples mas claras• Estrutura básica de projeto\n\n\nIniciante\n0-9\nUso inadequado ou mínimo do Git\n• Poucos commits• Trabalho apenas na branch main• Mensagens vagas ou inadequadas• Sem organização do projeto\n\n\n\n\n\n\n\n9.5.5.1 Métricas Automatizadas\n\nNúmero e frequência de commits;\nUso de branches (feature, develop, main);\nPull requests criados e merged;\nQualidade das mensagens de commit (comprimento, clareza);\nConfiguração de CI/CD (GitHub Actions);\nEstrutura do repositório (README, .gitignore, estrutura de pastas).",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Módulo 4**: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span>"
    ]
  },
  {
    "objectID": "desenv4.html#sistema-de-avaliação-automática",
    "href": "desenv4.html#sistema-de-avaliação-automática",
    "title": "9  Módulo 4: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos",
    "section": "9.6 Sistema de Avaliação Automática",
    "text": "9.6 Sistema de Avaliação Automática\nEste sistema de avaliação foi especialmente desenvolvido considerando que os estudantes estão em seu primeiro período de contato com a Ciência e Engenharia de Computação, priorizando o processo de descoberta e aprendizado sobre a perfeição do produto final. Os critérios reconhecem as limitações naturais de alunos iniciantes, valorizando tentativas bem-intencionadas, colaboração efetiva e compreensão dos conceitos fundamentais. O feedback gerado pelos relatórios automáticos terão caráter construtivo, fornecendo orientações específicas para melhorias em vez de simplesmente atribuir pontuações, ajudando os estudantes a identificarem próximos passos concretos em seu desenvolvimento.\nO sistema mantém flexibilidade para ajustes baseados na performance geral da turma, permitindo calibrações quando necessário para garantir que os critérios permaneçam desafiadores mas alcançáveis. Todos os critérios de avaliação, métricas e expectativas são compartilhados com os alunos antes do início das atividades, garantindo transparência total no processo avaliativo e permitindo que os estudantes compreendam exatamente o que é esperado deles, promovendo assim um ambiente de aprendizagem mais justo e direcionado.\nTodo o texto desta seção pode ser usado como prompt para um sistema de Inteligência Artificial que esteja integrado ao Github Classroom. Esta integração será responsável por gerar os relatórios de avaliação, feedback e sugestões de melhoria para cada aluno, com base nos critérios e métricas definidos nas seções a seguir.\n\n9.6.1 Fluxo de Avaliação:\n\nAnálise Automática do Repositório:\n\nClonagem e análise da estrutura do projeto;\nCompilação/execução automática do código;\nExecução da suíte de testes;\nAnálise de métricas Git.\n\nGeração de Relatório:\n\nPontuação automática por critério;\nIdentificação de pontos fortes e fracos;\nSugestões de melhoria específicas;\nComparação com padrões da turma.\n\nValidação Manual (quando necessário):\n\nRevisão de casos ambíguos;\nVerificação de funcionalidades complexas;\nAvaliação de aspectos qualitativos.\n\n\n\n\n9.6.2 Tolerâncias para Primeiro Período:\n\nCompilação: Avisos permitidos, mas sem erros fatais;\nTestes: Foco na implementação correta vs performance;\nGit: Ênfase no uso básico correto vs workflows avançados;\nDocumentação: Clara e útil vs detalhada e profissional.\n\n\n\n9.6.3 Feedback Personalizado\nPara cada critério de avaliação, o sistema deve fornecer feedback específico e orientações para melhorias.\nFuncionalidade:\n\nLista de funções implementadas vs especificadas;\nCasos de teste que falharam com explicações;\nSugestões de correção para erros comuns.\n\nQualidade dos Testes:\n\nComparação de cobertura com expectativa;\nIdentificação de cenários não testados;\nExemplos de melhorias nos testes existentes.\n\nColaboração:\n\nGráfico de contribuições por membro;\nIdentificação de desequilíbrios no trabalho;\nSugestões para melhor distribuição de tarefas.\n\nControle de Versão:\n\nAnálise do histórico de commits;\nSugestões de workflow Git;\nBoas práticas não implementadas.\n\n\n\n9.6.4 Critérios de Aprovação\nPara aprovação no módulo: o aluno deve atingir pelo menos:\n\nPontuação mínima: \\(70\\) pontos (\\(70\\%\\));\nCritérios obrigatórios:\n\nFuncionalidade \\(≥ 15\\) pontos;\nQualidade dos Testes \\(≥ 18\\) pontos;\nPelo menos um critério em nível “Proficiente”;\n\n\n\n\n\n\n[1] THE GIT PROJECT. Git. https://git-scm.com/, 2025. \n\n\n[2] GITHUB, INC. GitHub: Where the world builds software.\nurlhttps://github.com/, 2025. \n\n\n[3] GitHub classroom. https://classroom.github.com/, [s.d.].",
    "crumbs": [
      "Disciplina Raciocínio Algorítmico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Módulo 4**: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span>"
    ]
  },
  {
    "objectID": "referencias.html",
    "href": "referencias.html",
    "title": "Referências",
    "section": "",
    "text": "[1] AI\nINDEX STEERING COMMITTEE. 2025 AI Index Report.\nStanford, CA: Stanford Institute for Human-Centered Artificial\nIntelligence, 2025. Disponível em: &lt;https://hai.stanford.edu/ai-index/2025-ai-index-report&gt;.\nAcesso em: 10 jul. 2025.\n\n\n[2] BERGMANN, J.; SAMS, A. Flip your\nclassroom: reach every student in every class every day.\nEugene: ISTE, 2012. \n\n\n[3] BIRD, R.; DE MOOR, O. Algebra of\nProgramming. [s.l.] Prentice Hall, 1997. \n\n\n[4] BRACKMANN, C. P. et al. Unplugged versus\nplugged-in: examining basic programming achievement and computational\nthinking of 6th-grade students. Journal of Computer Science\nEducation, 2022. \n\n\n[5] BRASIL. Lei nº 9.394, de 20 de dezembro\nde 1996. Estabelece as diretrizes e bases da educação\nnacional., 1996. Disponível em: &lt;https://www.planalto.gov.br/ccivil_03/leis/l9394.htm&gt;.\nAcesso em: 11 jul. 2025\n\n\n[6] BRASIL. Parecer CNE/CES nº 261, de 9 de\nnovembro de 2006. Solicita pronunciamento desta Câmara sobre a duração\ndo curso de Bacharelado em Educação Física e sua carga horária.\nDiário Oficial da UniãoBrasília, DF, 18 jan. 2007.\nDisponível em: &lt;http://portal.mec.gov.br/cne/arquivos/pdf/2006/pces261_06.pdf&gt;.\nAcesso em: 11 jul. 2025\n\n\n[7] BRASIL. Resolução nº 2, de 18 de junho\nde 2007. Dispõe sobre carga horária mínima e procedimentos relativos à\nintegralização e duração dos cursos de graduação, bacharelados, na\nmodalidade presencial. Diário Oficial da\nUniãoBrasília, DF, 19 jun. 2007. Disponível em: &lt;http://portal.mec.gov.br/cne/arquivos/pdf/2007/rces002_07.pdf&gt;.\nAcesso em: 11 jul. 2025\n\n\n[8] BRASIL. Síntese de área: Ciência da\nComputação (Bacharelado/Licenciatura). Brasília, DF: Ministério\nda Educação, Instituto Nacional de Estudos e Pesquisas Educacionais\nAnísio Teixeira (Inep), Diretoria de Avaliação da Educação Superior\n(Daes), 2021. Disponível em: &lt;https://download.inep.gov.br/educacao_superior/enade/relatorio_sintese/2021/Enade_2021_Relatorios_Sintese_Area_Ciencia_Computacao.pdf&gt;.\nAcesso em: 10 jul. 2025.\n\n\n[9] CARDIFF SCHOOL OF COMPUTER SCIENCE AND\nINFORMATICS. CM1101: Computational\nThinking. https://data.cardiff.ac.uk/legacy/grails/module/CM1101.html,\n2025. \n\n\n[10] CARDIFF SCHOOL OF COMPUTER SCIENCE AND\nINFORMATICS. CM1103: Problem Solving with\nPython. https://data.cardiff.ac.uk/legacy/grails/module/CM1103/24A.html,\n2025. \n\n\n[11] CARNEGIE MELLON CENTER OF COMPUTATIONAL\nTHINKING. What is Computational Thinking.,\n[s.d.][s.d.]. Disponível em: &lt;https://www.cs.cmu.edu/~CompThink/&gt;.\nAcesso em: 6 jul. 2025\n\n\n[12] CARNEGIE MELLON ROBOTICS ACADEMY.\nCoding and Computational Thinking with VEX V5.,\n[s.d.][s.d.]. Disponível em: &lt;https://www.cmu.edu/roboticsacademy/roboticscurriculum/VEX%20Curriculum/coding_v5.html&gt;.\nAcesso em: 6 jul. 2025\n\n\n[13] CHUI, M. et al. The state of AI in\n2022—and a half decade in review. [s.l.] McKinsey &\nCompany, 2022. Disponível em: &lt;https://www.mckinsey.com/~/media/mckinsey/business%20functions/quantumblack/our%20insights/the%20state%20of%20ai%20in%202022%20and%20a%20half%20decade%20in%20review/the-state-of-ai-in-2022-and-a-half-decade-in-review.pdf&gt;.\nAcesso em: 10 jul. 2025.\n\n\n[14] COMPUTER SCIENCE TEACHERS ASSOCIATION.\nComputational Thinking: A Definition for K-12., 2011.\nDisponível em: &lt;https://csteachers.org/teaching-computational-thinking-in-early-elementary/&gt;.\nAcesso em: 7 jul. 2025\n\n\n[15] CURZON, P. et al. Computational Thinking. Em:\nFINCHER, S. A.; ROBINS, A. V. (Eds.). The Cambridge Handbook of\nComputing Education Research. Cambridge: Cambridge University\nPress, 2019. p. 513–546. \n\n\n[16] DENNING, P. J.; TEDRE, M. Computational\nThinking. Cambridge, MA: The MIT Press, 2019. \n\n\n[17] ETH ZÜRICH. Computational\nThinking., 2020. Disponível em: &lt;https://disco.ethz.ch/courses/hs20/coti/lecturenotes/script.pdf&gt;.\nAcesso em: 6 jul. 2025\n\n\n[18] ETH ZURICH. Flipped\nClassroom. https://ethz.ch/en/the-eth-zurich/education/educational-development/planning-teaching/flipped-classroom.html,\n2025. Acesso em: 15 jul. 2025\n\n\n[19] ETH ZURICH. Programming for\nbeginners. https://ethz.ch/en/studies/bachelor/beginning-your-studies/subject-related-preparation/programming-beginners.html,\n2025. Acesso em: 15 jul. 2025\n\n\n[20] EHL HOSPITALITY BUSINESS SCHOOL. Course\nCatalogue: Undergraduate Programs. Lausanne,\nChur-Passugg, Singapore: EHL Hospitality Business School,\n2023-2024. \n\n\n[21] EUROPEAN COMMISSION. Digital Education\nAction Plan 2021-2027., 2021. Disponível em: &lt;https://education.ec.europa.eu/focus-topics/digital-education/action-plan&gt;.\nAcesso em: 6 jul. 2025\n\n\n[22] EUROPEAN COMMISSION. ECTS Users’\nGuide. LuxembourgPublications Office of the European Union,\n2015. Disponível em: &lt;https://education.ec.europa.eu/sites/default/files/document-library-docs/ects-users-guide_en.pdf&gt;.\nAcesso em: 7 jul. 2025\n\n\n[23] FELIPUSSI, A. L.; PADUA, C. C. S.\nRelato de aulas com robô programável e Pensamento\nComputacional. Anais do 12º Congresso Brasileiro de Informática\nna Educação. Anais...Recife: SBC, 2023. \n\n\n[24] FRAUCHES, C. Educação Superior\nComentada: Políticas, diretrizes, legislação e normas do ensino\nsuperior. ABMES, Colunas, 4 jul. 2011. Disponível em: &lt;https://www.abmes.org.br/colunas/detalhe/255/educacao-superior-comentada-politicas-diretrizes-legislacao-e-normas-do-ensino-superior&gt;.\nAcesso em: 11 jul. 2025\n\n\n[25] FUTURA, C. P. O ensino do pensamento\ncomputacional no Brasil na era digital. São Paulo: Fundação\nRoberto Marinho, 2023. \n\n\n[26] GIBBONS, J. Algorithm Design with\nHaskell. University of Oxford, 2020. Acesso em: 10 jul.\n2025\n\n\n[27] GIBBONS, J. Functional Algorithm Design, Part\n0. SIGPLAN Blog, 2020. \n\n\n[28] GROVER, S.; PEA, R. Computational thinking\nin K–12: A review of the state of the field. Educational\nResearcher, v. 42, n. 1, p. 38–43, 2013. \n\n\n[29] GÜNDOĞDU, F. et al. Exploring mathematical\nreasoning skills. ScienceDirect, 2023. \n\n\n[30] HARISMAN, Y. et al. Exploring Students’\nMathematical Reasoning Behavior. Education Sciences, v.\n13, 2023. \n\n\n[31] HIEBERT, J.; LEFEVRE, P. Conceptual and\nprocedural knowledge in mathematics: An introductory analysis. Em:\nHIEBERT, J. (Ed.). Conceptual and procedural knowledge: The case\nof mathematics. Hillsdale, NJ: Lawrence Erlbaum Associates,\n1986. p. 1–27. \n\n\n[32] HOARE, C. A. R. An Axiomatic\nBasis for Computer Programming. Communications of the\nACM, v. 12, n. 10, p. 576–580, 1969. \n\n\n[33] HORA, N. DA. O ensino do pensamento\ncomputacional no Brasil na era digital. Futura, 9 fev. 2022.\nDisponível em: &lt;https://futura.frm.org.br/conteudo/professores/artigo/o-ensino-do-pensamento-computacional-no-brasil-na-era-digital&gt;.\nAcesso em: 9 jul. 2025\n\n\n[34] HSU, T.-C.; CHANG, Y.-S.; CHEN, S.-Y. Teaching AI with\ngames: the impact of generative AI drawing on computational thinking\nskills. Education and Information Technologies,\n2025. \n\n\n[35] HURRELL, D. P. Conceptual knowledge OR\nProcedural knowledge OR Conceptual knowledge AND Procedural knowledge:\nwhy the conjunction is important for teachers. Australian\nJournal of Teacher Education, v. 46, n. 2, p. art. 4, 2021.\n\n\n\n[36] IMPERIAL COLLEGE LONDON. Programme\nSpecification 2024-25: MEng Computing. https://www.imperial.ac.uk/media/imperial-college/study/programme-specifications/computing/24x2f25/G401-MEng-Computing-2024-25.pdf,\n2024. \n\n\n[37] IMPERIAL COLLEGE LONDON. I-X –\nReimagining the university in an age of rapid innovation. https://www.imperial.ac.uk/stories/ix-rapid-innovation/,\n2020. \n\n\n[38] KALDEWAIJ, A. Programming: The\nDerivation of Algorithms. [s.l.] Prentice Hall, 1990. \n\n\n[39] KONG, S. et al. Pensamento\nComputacional na Educação: perspectivas internacionais. São\nPaulo: Penso, 2020. \n\n\n[40] LEHMANN, T. H. How\ncurrent perspectives on algorithmic thinking can be applied to students’\nengagement in algorithmatizing tasks. Mathematics Education\nResearch Journal, v. 36, n. 3, p. 609–643, 2024. \n\n\n[41] LEHMANN, T. H. Using algorithmic thinking to\ndesign algorithms: The case of critical path analysis. The\nJournal of Mathematical Behavior, v. 71, p. 101079, 2023.\n\n\n\n[42] LI, Y. et al. Computational Thinking Is More\nabout Thinking than Computing. Journal for STEM Education\nResearch, v. 3, n. 1, p. 1–18, 2020. \n\n\n[43] LITHNER, J. A research framework for\nalgorithmic and creative reasoning. Educational Studies in\nMathematics, v. 67, n. 3, p. 255–276, 2008. \n\n\n[44] MASSACHUSETTS INSTITUTE OF TECHNOLOGY.\nA computational thinking requirement for MIT undergraduates:\nReport of the working group on computational thinking., 2017.\nDisponível em: &lt;https://facultygovernance.mit.edu/sites/default/files/reports/2017-01_computational_thinking_requirement_FINAL_CLEAN.pdf&gt;.\nAcesso em: 11 jul. 2025\n\n\n[45] MASSACHUSETTS INSTITUTE OF TECHNOLOGY.\nGeneral Institute Requirements. MIT Course\nCatalog, [s.d.]. Disponível em: &lt;https://catalog.mit.edu/mit/undergraduate-education/general-institute-requirements/&gt;.\nAcesso em: 11 jul. 2025\n\n\n[46] MEDEIROS, W. M. Pensamento\nComputacional ou Programação? Uma análise de práticas pedagógicas com\nScratch. Dissertação (Mestrado em Educação)—Uberlândia: UFU,\n2024.\n\n\n[47] NATIONAL COUNCIL OF TEACHERS OF MATHEMATICS –\nNCTM. Principles\nand Standards for School Mathematics. Reston, VA: NCTM,\n2000. \n\n\n[48] NATIONAL CENTER FOR EDUCATION STATISTICS\n(NCES). Glossary: Credit Hour. Washington, D.C.U.S.\nDepartment of Education, 2010. Disponível em: &lt;https://www.naicu.edu/media/l3ckll0r/20101214_credithourbkgrnd12-13-10.pdf&gt;.\nAcesso em: 7 jul. 2025\n\n\n[49] NETFLIX, INC. Chaos\nEngineering., 2021. Disponível em: &lt;https://netflix.github.io/chaosmonkey/&gt;.\nAcesso em: 10 jul. 2025\n\n\n[50] NEW YORK HALL OF SCIENCE. Computational\nThinking School Strategy Guide., [s.d.][s.d.]. Disponível em:\n&lt;https://nysci.org/pdf/NYSCI-Computational-Thinking-School-Strategy-Guide-04-09-2024.pdf&gt;.\nAcesso em: 6 jul. 2025\n\n\n[51] PAPERT, S. Logo: Computadores e\nEducação. São Paulo: Brasiliense, 1985. \n\n\n[52] PENN STATE UNIVERSITY. Computer Science\n(CMPSC) - University Bulletin - Penn State., [s.d.]a[s.d.]a.\nDisponível em: &lt;https://bulletins.psu.edu/university-course-descriptions/undergraduate/cmpsc/&gt;.\nAcesso em: 6 jul. 2025\n\n\n[53] POLAT, E.; YILMAZ, R. M. Unplugged versus\nplugged-in: examining basic programming achievement and computational\nthinking of 6th-grade students. Education and Information\nTechnologies, v. 27, p. 9145–9179, 2022. \n\n\n[54] RIBEIRO, L. et al. Entendendo o Pensamento\nComputacional: além da programação. Revista Brasileira de\nInformática na Educação, v. 25, n. 3, p. 45–62, 2017. \n\n\n[55] SAIDIN, N. D. et al. Benefits and\nchallenges of applying computational thinking in education.\nInternational Journal of Information and Education\nTechnology, v. 11, n. 5, p. 248–254, 2021. \n\n\n[56] SBC (SOCIEDADE BRASILEIRA DE COMPUTAÇÃO).\nReferenciais de Formação em Computação: Educação\nBásica. Porto AlegreSBC, 2017. \n\n\n[57] SCRATCH FOUNDATION. Scratch.,\n[s.d.][s.d.]. Disponível em: &lt;https://scratch.mit.edu/&gt;. Acesso\nem: 7 jul. 2025\n\n\n[58] SENTANCE, S. et al. Creating cool\nstuff: Pupils’ experience of the BBC micro:bit. Proceedings of\nthe ACM SIGCSE Technical Symposium. Anais...Seattle:\nACM, 2017. \n\n\n[59] SILVA QUINTO, W. A. et al. Explorando o impacto da\nInteligência Artificial na formação do pensamento crítico entre\nacadêmicos de T.I. na Região Norte do Brasil. Caderno\nPedagógico, v. 22, n. 7, 2025. \n\n\n[60] TEDRE, M.; DENNING, P. J. The Long\nQuest for Computational Thinking. Proceedings of the 16th Koli\nCalling Conference on Computing Education Research.\nAnais...Koli, Finland: nov. 2016. \n\n\n[61] TSAI, C.-Y.; YANG, Y.-F. The impact of\nunplugged activities on developing computational thinking skills in\nelementary school students. Journal of Educational Technology\n& Society, v. 22, n. 3, p. 77–89, 2019. \n\n\n[62] UNIVERSITY OF CAMBRIDGE. Department of\nComputer Science and Technology. Algorithms 1., [s.d.]a[s.d.]a.\nDisponível em: &lt;https://www.cl.cam.ac.uk/teaching/2324/Algorithm1/&gt;.\nAcesso em: 12 jul. 2025\n\n\n[63] UNIVERSITY OF CAMBRIDGE. Faculty of\nEducation. Computational Thinking Challenge., [s.d.]b[s.d.]b.\nDisponível em: &lt;https://www.educ.cam.ac.uk/research/programmes/computationalthinking/&gt;.\nAcesso em: 12 jul. 2025\n\n\n[64] DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLOGY.\nAlgorithms 1. University of Cambridge; https://www.cl.cam.ac.uk/teaching/2324/Algorithm1/,\n2024. \n\n\n[65] DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLOGY.\nAlgorithms 2. University of Cambridge; https://www.cl.cam.ac.uk/teaching/2324/Algorithm2/,\n2024. \n\n\n[66] DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLOGY.\nCourse pages 2023-24. University of Cambridge; https://www.cl.cam.ac.uk/teaching/2324/, 2024. \n\n\n[67] DEPARTMENT OF COMPUTER SCIENCE, UNIVERSITY OF\nOXFORD. Computer Science. University of Oxford; https://www.cs.ox.ac.uk/teaching/bacompsci/, 2024.\n\n\n\n[68] DEPARTMENT OF COMPUTER SCIENCE, UNIVERSITY OF\nOXFORD. Mathematics and Computer Science. University of\nOxford; https://www.cs.ox.ac.uk/teaching/mcs/, 2024. \n\n\n[69] UNIVERSITY OF OXFORD. Oxford University\nComputing Challenge and related programs., [s.d.]b[s.d.]b.\nDisponível em: &lt;https://www.raspberrypi.org/blog/uk-bebras-oxford-university-computing-challenge-2022/&gt;.\nAcesso em: 12 jul. 2025\n\n\n[70] UNIVERSITY OF YORK. Computational\nThinking: Foundations and Fundamentals. YorkDepartment of\nComputer Science, 2020. \n\n\n[71] UNIVERSITY OF OXFORD. UK Bebras\nparticipants in the Oxford University Computing Challenge.,\n[s.d.]d[s.d.]d. Disponível em: &lt;https://www.raspberrypi.org/blog/uk-bebras-oxford-university-computing-challenge-2022/&gt;.\nAcesso em: 12 jul. 2025\n\n\n[72] UKCT CHALLENGES. About Us.\nUKCT Challenges; https://ukctchallenges.org/about/, 2024. \n\n\n[73] WING, J. M. Computational\nthinking. Communications of the ACM, v. 49, n. 3,\np. 33–35, mar. 2006. \n\n\n[74] XIAMEN UNIVERSITY. Overseas Education\nCollege. Credits. XiamenOEC, [s.d.][s.d.]. Disponível em:\n&lt;https://oec.xmu.edu.cn/en/Study/Credits.htm&gt;.\nAcesso em: 8 jul. 2025\n\n\n[75] KOSMYNA, N. et al. Your Brain on\nChatGPT: Accumulation of Cognitive Debt when Using an AI Assistant for\nEssay Writing Task., 2025. Disponível em: &lt;https://arxiv.org/abs/2506.08872&gt;\n\n\n[76] BRENNAN, K.; RESNICK, M. New\nframeworks for studying and assessing the development of computational\nthinking. Proceedings of the 2012 Annual Meeting of the\nAmerican Educational Research Association.\nAnais...Vancouver, Canada: 2012. \n\n\n[77] ARA’UJO, A. L. S. DE O.; ANDRADE, W. L. DE;\nGUERRERO, D. D. S. Um mapeamento\nsistem’atico sobre a\navaliaç ao do pensamento\ncomputacional no Brasil. Anais do V Congresso\nBrasileiro de Inform’atica na\nEducaç ao (CBIE).\nAnais...2016. \n\n\n[78] PROJECT OLYMPUS, CARNEGIE MELLON UNIVERSITY.\nPROBE Projects. https://www.cmu.edu/project-olympus/probe-projects/index.html,\n[s.d.]. \n\n\n[79] OPEN LEARNING INITIATIVE, CARNEGIE MELLON\nUNIVERSITY. Principles of Computation with Python — Open\n& Free. https://oli.cmu.edu/courses/principles-of-computation-with-python-open-free/,\n[s.d.]. \n\n\n[80] HARVARD UNIVERSITY. CS50: Introduction\nto Computer Science., 2025. Disponível em: &lt;https://pll.harvard.edu/course/cs50-introduction-computer-science&gt;\n\n\n[81] HARVARD UNIVERSITY. Syllabus - CS50:\nComputer Science Courses and Programs from Harvard., 2025.\nDisponível em: &lt;https://cs50.harvard.edu/syllabus&gt;\n\n\n[82] STANFORD UNIVERSITY. CS106A\nSyllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1258/syllabus&gt;\n\n\n[83] STANFORD UNIVERSITY. CS106B\nSyllabus., 2025. Disponível em: &lt;https://web.stanford.edu/class/cs106b/syllabus&gt;\n\n\n[84] STANFORD UNIVERSITY. Programming\nMethodology - Stanford Engineering Everywhere | CS106A., 2025.\nDisponível em: &lt;https://see.stanford.edu/course/cs106a&gt;\n\n\n[85] VEX ROBOTICS. VEX Robotics\nOfficial Website. https://www.vexrobotics.com/, 2025. \n\n\n[86] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION.\nInformation technology – Programming languages –\nC. Geneva, Switzerland: International Organization\nfor Standardization (ISO), 2018. Disponível em: &lt;https://www.iso.org/standard/74528.html&gt;.\n\n\n[87] PYTHON SOFTWARE FOUNDATION. The\nPython Language Reference. Disponível em: &lt;https://docs.python.org/3/reference/index.html&gt;.\nAcesso em: 13 jul. 2025. \n\n\n[88] FREDOVERFLOW. Karel The\nRobot. Disponível em: &lt;https://github.com/fredoverflow/karel&gt;.\nAcesso em: 13 jul. 2025. \n\n\n[89] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION.\nInformation technology – Programming languages –\nC++. Geneva, Switzerland: International\nOrganization for Standardization (ISO), 2020. Disponível em:\n&lt;https://isocpp.org/std/the-standard&gt;.\n\n\n[90] CAMBRIDGE UNIVERSITY. Cambridge\nMathematics., 2025. \n\n\n[91] RYCROFT-SMITH, L.; CONNOLLY, C. Comparing\nconceptions of mathematical and computational thinking cycles.\nCambridge Espresso, 2019. \n\n\n[92] GOULD, T.; RYCROFT-SMITH, L. Establishing\nconcepts of ratio. Instant, Cambridge Mathematics,\n2022. \n\n\n[93] KIRWAN, C.; COSTELLO, E.; DONLON, E. ADAPTTER: Developing a\nFramework for Teaching Computational Thinking in Second-Level Schools by\nDesign Research. TechTrends, v. 66, n. 4, p.\n495–509, 2022. \n\n\n[94] WEINTROP, D.; WILENSKY, U. Using Unplugged\nActivities in Adult Programming Education. Proceedings of\nthe 46th ACM Technical Symposium on Computer Science Education (SIGCSE\n’15). Anais...New York, NY, USA: ACM, 2015. \n\n\n[95] CURZON, P.; MCOWAN, P.; BLACKWELL, A. Unplugged\napproaches to the teaching of computing to adults. Journal of\nComputing Sciences in Colleges, v. 29, n. 4, p. 90–97, 2014.\n\n\n\n[96] LEIFER, L. A. Project Based Learning in\nDesign Education. Proceedings of the 1970 Conference on Design\nMethods. Anais...1970. \n\n\n[97] KIM, Y. Computational\nThinking. Em: Educational Technology: An Online Handbook for\nPre-K-12. [s.l.] EdTech Books, 2021. \n\n\n[98] BELL, T. et al. Computer Science Unplugged:\nschool students doing real computing without computers.\nArticle, 2009. \n\n\n[99] HUANG, R. et al. Computational Thinking and the\nNew Curriculum Standards of Information Technology for Senior High\nSchools in China. Em: ABELSON, H.; KONG, S.-C. (Eds.).\nComputational Thinking Curricula in K–12: International\nImplementations. Cambridge, Massachusetts; London, England: The\nMIT Press, 2020. \n\n\n[100] WONG, M. M. Y. et al. Self-development\nThrough Service-Oriented Stress-Adaption-Growth (SOSAG) Process in the\nEngagement of Computational Thinking Co-teaching Education. Em:\nKONG, S.-C.; ABELSON, H. (Eds.). Computational Thinking\nEducation. Singapore: Springer Nature Singapore Pte Ltd., 2019.\n\n\n\n[101] ŽIVKOVIĆ, M. XLogo4Schools.\nSourceForge, 2014. Disponível em: &lt;http://sourceforge.net/projects/xlogo4schools&gt;\n\n\n[102] WATTENHOFER, R. Computational\nThinking. [s.l.] ETH Zürich, 2020. \n\n\n[103] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION.\nISO/IEC 13211-1:1995 - Information technology – Programming\nlanguages – Prolog – Part 1: General core. [s.l.] ISO/IEC,\n1995. \n\n\n[104] LEROY, X. et al. The OCaml system: Documentation and\nuser’s manual. [s.l.] INRIA (Institut National de Recherche\nen Informatique et en Automatique), 2025. \n\n\n[105] GOSLING, J. et al. The Java®\nLanguage Specification, Java SE 22 Edition. Redwood City,\nCalifornia: Oracle America, Inc., 2024. \n\n\n[106] SMITH, J. A. C. B.; GROVER, S.; SMITH, A. L.\nMeasuring Computational Thinking and Computer Science Outcomes:\nA Resource for CS for All Researchers. [s.l.] U.S. Department\nof Education, mar. 2021. Disponível em: &lt;https://www.ed.gov/sites/ed/files/2021/03/CSCTOutcomes_508.pdf&gt;.\n\n\n[107] KONG, S.-C. Learning Composite\nand Prime Numbers Through Developing an App: An Example of Computational\nThinking Development Through Primary Mathematics Learning. Em: KONG,\nS.-C.; ABELSON, H. (Eds.). Computational Thinking\nEducation. Singapore: Springer, 2019. p. 155–177. \n\n\n[108] AMENDUM, M. L. B. et al. Computational\nThinking Rubric for Problem Solving. Newark, DE: The College\nSchool, University of Delaware, 2018. Disponível em: &lt;https://cpb-us-w2.wpmucdn.com/sites.udel.edu/dist/4/8672/files/2018/12/Computational-Thinking-Rubric-2ktkkgv.pdf&gt;.\n\n\n[109] RASPBERRY PI FOUNDATION. The UK Bebras\nChallenge. https://www.bebras.uk/, 2025. \n\n\n[110] HIJÓN-NEIRA, R. et al. Computational\nThinking Measurement of CS University Students in the AI Era.\nPreprints.org, maio 2024. \n\n\n[111] ROMÁN-GONZÁLEZ, M.; MORENO-LEÓN, J.; ROBLES, G.\nCombining\nAssessment Tools for a Comprehensive Evaluation of Computational\nThinking Interventions. Em: KONG, S.-C.; ABELSON, H. (Eds.).\nComputational Thinking Education. [s.l.] Springer,\n2019. p. 85–100. \n\n\n[112] BARAK, B. Chapter 15: NP, NP\ncompleteness, and the Cook-Levin Theorem. https://introtcs.org/public/ch15_nptime.html, 2023.\n\n\n\n[113] MURRAY, R. M.; LI, Z.; SASTRY, S. S. A\nMathematical Introduction to Robotic Manipulation. [s.l.] CRC\nPress, 1994. \n\n\n[114] GÉRON, A. Hands-On Machine Learning\nwith Scikit-Learn, Keras & TensorFlow: Concepts, Tools, and\nTechniques to Build Intelligent Systems. 2nd. ed. [s.l.]\nO’Reilly Media, Inc., 2019. \n\n\n[115] HERLIHY, M.; SHAVIT, N. The Art of\nMultiprocessor Programming. Revised Reprint ed. Waltham, MA,\nUSA: Morgan Kaufmann Publishers Inc., 2012. \n\n\n[116] TANENBAUM, A. S.; BOS, H. Modern\nOperating Systems. 4th. ed. USA: Prentice Hall Press, 2015.\n\n\n\n[117] MILLER, G. A. The\nmagical number seven, plus or minus two: Some limits on our capacity for\nprocessing information. Psychological Review, v.\n63, n. 2, p. 81–97, 1956. \n\n\n[118] FRIGG, R. Models and representation:\nWhy structures are not enough. London: London School of\nEconomics, 2002. Disponível em: &lt;https://romanfrigg.org/wp-content/uploads/writings/Models_and_Representation.pdf&gt;.\n\n\n[119] MUGGLETON, S. Inductive logic programming:\nTheory and methods. Journal of Logic Programming, v.\n19, n. 20, p. 629–679, 1991. \n\n\n[120] ALCANTARA, F. C. DE. Fluxograma\nInterativo. https://frankalcantara.com/fluxograma/index.html,\n[s.d.]. \n\n\n[121] TEACHING LONDON COMPUTING. Algorithmic\nThinking., 2023. Disponível em: &lt;https://teachinglondoncomputing.org/resources/developing-computational-thinking/algorithmic-thinking/&gt;\n\n\n[122] PRITCHARD, T. A. Using\nflowcharts, code and animation for improved comprehension and ability in\nnovice programming. tese de doutorado—[s.l.] University of\nSouth Wales, 2018.\n\n\n[123] ALI, F. Effect\nof Flowcharts on Code Comprehension of Novice Programmers.\nmathesis—[s.l.] Chemnitz University of Technology, 2022.\n\n\n[124] SOCIEDADE BRASILEIRA DE COMPUTAÇÃO.\nNota Técnica da Sociedade Brasileira de Computação sobre a\nBNCC-EF e a BNCC-EM. Porto Alegre, RS, Brasil:\nSociedade Brasileira de Computação (SBC); https://www.sbc.org.br/wp-content/uploads/2024/07/Nota-t-cnica-sobre-a-BNCC-Ensino-m-dio-e-fundamental-2018.pdf,\n2018. \n\n\n[125] KRAMER, J. Is Abstraction the Key to\nComputing? Communications of the ACM, v. 50, n. 4,\np. 36–42, 2007. \n\n\n[126] WINSLOW, L. E. Programming pedagogy – a\npsychological overview. ACM SIGCSE Bulletin, v. 28,\nn. 3, p. 17–22, 1996. \n\n\n[127] MIROLO, C. et al. Abstraction in Computer\nScience Education: An Overview. Informatics in\nEducation, v. 20, n. 4, p. 615–639, 2021. \n\n\n[128] LEINONEN, J.; HELLAS, A.; IHANTOLA, P.\nHow Can “Vibe-Coding” Transform Programming\nEducation? Communications of the ACM, maio 2024. Disponível em:\n&lt;https://cacm.acm.org/blogcacm/how-can-vibe-coding-transform-programming-education/&gt;\n\n\n[129] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION.\nInformation processing – Documentation symbols and conventions\nfor data, program and system flowcharts, program network charts and\nsystem resources charts. Geneva, CHInternational Organization\nfor Standardization, 1985. \n\n\n[130] ANDRZEJEWSKA, M.; STOLIŃSKA, A. Do Structured\nFlowcharts Outperform Pseudocode? Evidence From Eye Movements.\nIEEE Access, v. 10, p. 132965–132975, 2022. \n\n\n[131] THREEKUNPRAPA, A.; YASRI, P. Patterns of\nComputational Thinking Development while Solving Unplugged Coding\nActivities Coupled with the 3S Approach for Self-Directed Learning.\nEuropean Journal of Educational Research, v. 9, n. 3,\np. 1025–1045, 2020. \n\n\n[132] SCANLAN, D. A. Structured Flowcharts Outperform\nPseudocode: An Experimental Comparison. IEEE\nSoftware, v. 6, n. 5, p. 28–36, 1989. \n\n\n[133] SIOZOU, S.; TSELIOS, N.; KOMIS, V.\nEffect of algorithms’ multiple representations in the context of\nprogramming education. Proceedings of the 4th Pan-Hellenic\nConference “Informatics and Education”.\nAnais...Patras, Greece: 2008. Disponível em: &lt;https://www.researchgate.net/publication/220373268_Effect_of_algorithms'_multiple_representations_in_the_context_of_programming_education&gt;\n\n\n[134] THE KNOWLEDGE ACADEMY. Differences\nBetween Flowchart and Pseudocode: A Detailed Comparison., 2025.\nDisponível em: &lt;https://www.theknowledgeacademy.com/blog/flowchart-vs-pseudocode/&gt;\n\n\n[135] MEN, N. et al. Hybrid\nBeamforming for RIS-Aided Multiuser Millimeter Wave\nSystems. 2022 IEEE 95th Vehicular Technology Conference:\n(VTC2022-Spring). Anais...2022. \n\n\n[136] LEVESON, N. G. Engineering a\nSafer World: Systems Thinking Applied to Safety. Cambridge,\nMA: MIT Press, 2012. \n\n\n[137] KELLEHER, C. D.; PAUSCH, R. Exploring the role of\nvisualization and engagement in computer science education.\nACM SIGCSE Bulletin, v. 39, n. 3, p. 213–217, 2007.\n\n\n\n[138] 21, I. J. 1/SC 22/WG. ISO/IEC\n14882:2024 - Programming languages — C++. [s.l.] International\nOrganization for Standardization, 2024. Disponível em: &lt;https://www.iso.org/standard/82312.html&gt;.\n\n\n[139] YANOFSKY, N. S. Towards a Definition of an\nAlgorithm. Journal of Logic and Computation, v. 21,\nn. 2, p. 253–286, 2011. \n\n\n[140] TYLDUM, M. O Jogo da\nImitação. Filme; Black Bear Pictures,\n2014. \n\n\n[141] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION.\nInformation processing – Documentation symbols and conventions\nfor data, program and system flowcharts, program network charts and\nsystem resources charts. [s.l.] International Organization for\nStandardization, 1985. Disponível em: &lt;https://cdn.standards.iteh.ai/samples/11955/1b7dd254a2a54fd7a89d616dc0570e18/ISO-5807-1985.pdf&gt;.\n\n\n[142] OSA, T. et al. An Algorithmic Perspective on\nImitation Learning. Found. Trends Robotics, v. 7,\np. 1–179, 2018. \n\n\n[143] ZARE, M. et al. A Survey of Imitation\nLearning: Algorithms, Recent Developments, and Challenges.\nIEEE Transactions on Cybernetics, v. 54, p. 7173–7186,\n2023. \n\n\n[144] BISHOP, J. Artificial Intelligence\nIs Stupid and Causal Reasoning Will Not Fix It. Frontiers in\nPsychology, v. 11, 2020. \n\n\n[145] BISHOP, J. M. Artificial Intelligence\nIs Stupid and Causal Reasoning Will Not Fix It. Frontiers in\nPsychology, v. 11, p. 513474, 2020. \n\n\n[146] CEPEDA, N. J. et al. Distributed practice\nin verbal recall tasks: A review and quantitative synthesis.\nPsychological Bulletin, v. 132, n. 3, p. 354–380, 2006.\n\n\n\n[147] CHI, M. T. H. et al. Eliciting\nself-explanations improves understanding. Cognitive\nScience, v. 18, n. 3, p. 439–477, 1994. \n\n\n[148] ROEDIGER, H. L.; BUTLER, A. C. The critical role of\nretrieval practice in long-term retention. Trends in\nCognitive Sciences, v. 15, n. 1, p. 20–27, 2011. \n\n\n[149] ROHRER, D.; TAYLOR, K. The shuffling of\nmathematics problems improves learning. Instructional\nScience, v. 35, n. 6, p. 481–498, 2007. \n\n\n[150] SCHRAW, G.; MOSHMAN, D. Metacognitive theories.\nEducational Psychology Review, v. 7, n. 4, p. 351–371,\n1995. \n\n\n[151] SWELLER, J. Cognitive load\ntheory. Psychology of Learning and Motivation, v.\n55, p. 37–76, 2011. \n\n\n[152] THE GIT PROJECT. Git. https://git-scm.com/, 2025.\n\n\n\n[153] GITHUB, INC. GitHub: Where the world\nbuilds software.\nurlhttps://github.com/, 2025. \n\n\n[154] GitHub Classroom. https://classroom.github.com/, [s.d.].",
    "crumbs": [
      "Referências"
    ]
  }
]