<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Virando a Mesa no Jogo da Imitação - 4&nbsp; Definição e Princípios da Metodologia DAAD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 1em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./desen.html" rel="next">
<link href="./inte.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro.html">Contextualização e Pesquisa</a></li><li class="breadcrumb-item"><a href="./def.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Definição e Princípios da Metodologia DAAD</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Virando a Mesa no Jogo da Imitação</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/raciocionio" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Contextualização e Pesquisa</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Referencial Teórico: Pensamento Computacional, Raciocínio Algorítmico e DAAD</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./inte.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Analisando Currículos Internacionais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./def.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Definição e Princípios da Metodologia DAAD</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Disciplina Raciocínio Algorítmico</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Projeto de Disciplina de Raciocínio Algorítmico</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title"><strong>Módulo 1</strong>: Semanas 1-3 (12 Horas-Aula): Introdução ao Raciocínio Algorítmico e Decomposição</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title"><strong>Módulo 2</strong>: Semanas 4-8 (20 Horas-Aula): Abstração e Reconhecimento de Padrões</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title"><strong>Módulo 3</strong>: Semanas 9-13 (20 Horas-Aula): Algoritmização e Estruturas de Dados</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desenv4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title"><strong>Módulo 4</strong>: Semanas 14-16 (12 Horas-Aula): Depuração e Aplicação em Projetos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#metodologias-semelhantes-ao-daad" id="toc-metodologias-semelhantes-ao-daad" class="nav-link active" data-scroll-target="#metodologias-semelhantes-ao-daad"><span class="header-section-number">4.1</span> Metodologias Semelhantes ao DAAD</a></li>
  <li><a href="#inovações-do-daad" id="toc-inovações-do-daad" class="nav-link" data-scroll-target="#inovações-do-daad"><span class="header-section-number">4.2</span> Inovações do DAAD</a></li>
  <li><a href="#metodologia-daad-estrutura-e-fases" id="toc-metodologia-daad-estrutura-e-fases" class="nav-link" data-scroll-target="#metodologia-daad-estrutura-e-fases"><span class="header-section-number">4.3</span> Metodologia DAAD: Estrutura e Fases</a>
  <ul class="collapse">
  <li><a href="#decomposição-quebrando-a-complexidade" id="toc-decomposição-quebrando-a-complexidade" class="nav-link" data-scroll-target="#decomposição-quebrando-a-complexidade"><span class="header-section-number">4.3.1</span> Decomposição: Quebrando a Complexidade</a></li>
  <li><a href="#abstração-focando-no-essencial" id="toc-abstração-focando-no-essencial" class="nav-link" data-scroll-target="#abstração-focando-no-essencial"><span class="header-section-number">4.3.2</span> Abstração: Focando no Essencial</a></li>
  <li><a href="#algoritmização-desenvolvendo-soluções-sistemáticas" id="toc-algoritmização-desenvolvendo-soluções-sistemáticas" class="nav-link" data-scroll-target="#algoritmização-desenvolvendo-soluções-sistemáticas"><span class="header-section-number">4.3.3</span> Algoritmização: Desenvolvendo Soluções Sistemáticas</a></li>
  <li><a href="#depuração-identificando-e-corrigindo-erros" id="toc-depuração-identificando-e-corrigindo-erros" class="nav-link" data-scroll-target="#depuração-identificando-e-corrigindo-erros"><span class="header-section-number">4.3.4</span> Depuração: Identificando e Corrigindo Erros</a></li>
  </ul></li>
  <li><a href="#ferramentas-de-abstração-na-metodologia-daad" id="toc-ferramentas-de-abstração-na-metodologia-daad" class="nav-link" data-scroll-target="#ferramentas-de-abstração-na-metodologia-daad"><span class="header-section-number">4.4</span> Ferramentas de Abstração na Metodologia DAAD</a>
  <ul class="collapse">
  <li><a href="#fluxogramas" id="toc-fluxogramas" class="nav-link" data-scroll-target="#fluxogramas"><span class="header-section-number">4.4.1</span> Fluxogramas</a></li>
  <li><a href="#pseudocódigo" id="toc-pseudocódigo" class="nav-link" data-scroll-target="#pseudocódigo"><span class="header-section-number">4.4.2</span> Pseudocódigo</a></li>
  <li><a href="#tabelas-de-rastreio" id="toc-tabelas-de-rastreio" class="nav-link" data-scroll-target="#tabelas-de-rastreio"><span class="header-section-number">4.4.3</span> Tabelas de Rastreio</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/raciocionio/edit/main/def.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/raciocionio/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro.html">Contextualização e Pesquisa</a></li><li class="breadcrumb-item"><a href="./def.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Definição e Princípios da Metodologia DAAD</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-def" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Definição e Princípios da Metodologia DAAD</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\def-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>O <strong>Pensamento Computacional</strong>, incluindo os elementos da Metodologia <strong>DAAD</strong>, é considerado uma habilidade básica e estruturante para o desenvolvimento científico, tecnológico e econômico no século XXI <span class="citation" data-cites="Curzon2019">(<a href="referencias.html#ref-Curzon2019" role="doc-biblioref">1</a>)</span>. Sua relevância se estende além das fronteiras da ciência da computação, sendo essencial para a resolução de problemas em diversas áreas <em>STEM</em> (Ciência, Tecnologia, Engenharia e Matemática) e <em>No-STEM</em> <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Kong2020" role="doc-biblioref">3</a>)</span>. Profissionais da computação, por sua própria natureza, utilizam intrinsecamente essas habilidades: pensar abstratamente, operar em múltiplos níveis de abstração, abstrair ideias para gerenciar a complexidade, e empregar a iteração, a depuração e o teste de software como práticas rotineiras <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>. Diversos estudos e frameworks listam o <strong>Pensamento Algorítmico</strong> ou o Design de Algoritmos como um dos principais componentes ou habilidades do <strong>Pensamento Computacional</strong> <span class="citation" data-cites="Hijn-Neira2024">(<a href="referencias.html#ref-Hijn-Neira2024" role="doc-biblioref">5</a>)</span>. Finalmente, o <strong>Raciocínio Algorítmico</strong> é uma habilidade fundamental e um componente central do <strong>Pensamento Computacional</strong> <span class="citation" data-cites="Huang2020ComputationalThinking">(<a href="referencias.html#ref-Huang2020ComputationalThinking" role="doc-biblioref">6</a>)</span>. Ele implica a capacidade de compreender, testar, aprimorar ou projetar um algoritmo <span class="citation" data-cites="Hijn-Neira2024">(<a href="referencias.html#ref-Hijn-Neira2024" role="doc-biblioref">5</a>)</span>. Este tipo de raciocínio é, de fato, a orientação mental e o processo de pensamento que alicerça a aplicação da Metodologia <strong>DAAD</strong> <span class="citation" data-cites="Li2020">(<a href="referencias.html#ref-TedreDenning2016" role="doc-biblioref">8</a>)</span>.</p>
<p>Para entender a Metodologia <strong>DAAD</strong>, acrônimo de <strong>P</strong>roblem Decomposition, <strong>A</strong>bstraction, Algorithm <strong>D</strong>esign e <strong>D</strong>ebugging, estrutura-se como uma aplicação pedagógica direta dos componentes fundamentais do <strong>Pensamento Computacional</strong> <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span> adaptados para a realidade do ensino de <strong>Raciocínio Algorítmico</strong> nos cursos de graduação no Brasil, especificamente aqueles dos cursos relacionados às áreas de ciências, matemática, computação e engenharia.</p>
<p>Na Metodologia <strong>DAAD</strong> a fase <strong>Decomposição</strong>, decomposição do problema, é a manifestação prática da ação de <strong>Decomposição</strong>, fragmentando desafios complexos em subproblemas gerenciáveis e facilmente descritíveis em estruturas de comandos ou fluxogramas. A fase <strong>Abstração</strong> reflete diretamente o pilar homônimo do modelo <strong>Pensamento Computacional</strong>, filtrando detalhes irrelevantes para isolar padrões essenciais, incorporando implicitamente o <em>reconhecimento de padrões</em>. A fase <strong>Algoritmização</strong> materializa o pilar <em>design algorítmico</em> do trabalho de <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>, transformando abstrações em sequências executáveis, por meio de ferramentas de apoio ao <strong>Raciocínio Algorítmico</strong> como fluxogramas e pseudocódigos, enquanto promove a generalização ao transferir soluções para contextos análogos, porém mais amplos. Finalmente, A fase <strong>Depuração</strong> substitui o processo de modelagem computacional através de refinamento iterativo, validando soluções contra comportamentos esperados do sistema <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>.</p>
<p>Nesta proposta, o termo <strong>Depuração</strong> será mantido ampliando seu sentido e uso. Nesta metodologia, a fase <strong>Depuração</strong> irá além do sentido computacional de encontrar erros em programas. A <strong>Depuração</strong> tem um sentido mais amplo e representa purificar substâncias e sistemas, corrigir erros e eliminar elementos indesejados. Assim, ainda que esta seja uma fase própria do ciclo completo, a <strong>Depuração</strong> representa o processo de correção e adaptação que será empregado em todos os processos e fases de ensino usando a Metodologia <strong>DAAD</strong>, <strong>D</strong>ecomposição, <strong>A</strong>bstração, <strong>A</strong>lgoritmização e <strong>D</strong>epuração.</p>
<p>Esta sinergia, entre <strong>Pensamento Computacional</strong> e <strong>Raciocínio Algorítmico</strong> posiciona a Metodologia <strong>DAAD</strong> como uma estrutura operacional para consolidar a teoria do <strong>Raciocínio Algorítmico</strong> em práticas educacionais tangíveis, mantendo a essência holística da proposta original de Wing (2006)<span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Wing2006" role="doc-biblioref">2</a>)</span> e Lehmann (2023)<span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>.</p>
<section id="metodologias-semelhantes-ao-daad" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="metodologias-semelhantes-ao-daad"><span class="header-section-number">4.1</span> Metodologias Semelhantes ao DAAD</h2>
<p>A Metodologia <strong>DAAD</strong> se distingue de outras abordagens pedagógicas de <strong>Pensamento Computacional</strong> por sua ênfase na <strong>Depuração</strong> como etapa essencial do processo de aprendizado. A seguir, são apresentadas algumas metodologias concorrentes e suas diferenças em relação ao <strong>DAAD</strong>.</p>
<p>A abordagem dos <strong>Quatro Pilares do Pensamento Computacional</strong>, desenvolvida pela Universidade de York, estrutura-se em decomposição, reconhecimento de padrões, abstração e pensamento algorítmico. Essa metodologia enfatiza a fragmentação de problemas complexos e a identificação de regularidades, mas não formaliza etapas de validação, limitando-se à concepção teórica de soluções <span class="citation" data-cites="YorkCT2020">(<a href="referencias.html#ref-Sentance2017" role="doc-biblioref">10</a>)</span>.</p>
<p>A <strong>Abordagem por Atividades Desplugadas</strong>, proposta por <span class="citation" data-cites="Brackmann2022">(<a href="referencias.html#ref-Brackmann2022" role="doc-biblioref">11</a>)</span>, prioriza intervenções pedagógicas sem uso de tecnologia, utilizando recursos físicos, como quebra-cabeças, para desenvolver abstração e decomposição. Embora eficaz em contextos com infraestrutura limitada, sua aplicação tende a focar em modelagem de <em>hardware</em> em detrimento do design sistemático de algoritmos, além de carecer de sequencialidade didática clara <span class="citation" data-cites="Brackmann2022">(<a href="referencias.html#ref-Sentance2017" role="doc-biblioref">10</a>)</span>.</p>
<p>A metodologia de Wing (2006) <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Wing2006" role="doc-biblioref">2</a>)</span>, base teórica seminal, define pilares como decomposição, abstração, design algorítmico e generalização. Wing enfatiza que a generalização de soluções permite aplicação em múltiplos contextos, porém não integra explicitamente mecanismos de depuração ou validação, sejam eles iterativos ou não, concentrando-se na fase de concepção em vez do refinamento prático <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Kurkovsky2013" role="doc-biblioref">12</a>)</span>. Essas lacunas são supridas pela Metodologia <strong>DAAD</strong>, que incorpora a <strong>D</strong>epuração como etapa fundamental para testar robustez, eficiência e escalabilidade de algoritmos em cenários reais, como em sistemas embarcados ou otimização NP-Difícil<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, consolidando um ciclo completo de desenvolvimento <span class="citation" data-cites="Sentance2017">(<a href="referencias.html#ref-Kurkovsky2013" role="doc-biblioref">12</a>)</span>. A <a href="#tbl-competidores" class="quarto-xref">Table&nbsp;<span>4.1</span></a> resume estas metodologias.</p>
<div id="tbl-competidores" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-competidores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.1: Propostas metodológicas de aplicação pedagógica dos conceitos de Pensamento Computacional
</figcaption>
<div aria-describedby="tbl-competidores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 35%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Metodologia</strong></th>
<th><strong>Instituição/Referência</strong></th>
<th><strong>Componentes-Chave</strong></th>
<th><strong>Diferenças para o DAAD</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Quatro Pilares do PC</strong></td>
<td>University of York</td>
<td>1. Decomposição<br>2. Reconhecimento de padrões<br>3. Abstração<br>4. Pensamento algorítmico</td>
<td>• Substitui <em>Decomposição</em> por <em>Reconhecimento de padrões</em><br>• Não inclui refinamento iterativo após implementação</td>
</tr>
<tr class="even">
<td><strong>Abordagem por Atividades Desplugadas</strong></td>
<td>Brackmann (2022)</td>
<td>• Problemas físicos (ex.: quebra-cabeças)<br>• Modelagem conceitual sem código<br>• Ênfase em abstração</td>
<td>• Foco em <em>hardware</em> vs.&nbsp;<em>solução algorítmica</em><br>• Menos estruturada em etapas sequenciais</td>
</tr>
<tr class="odd">
<td><strong>Metodologia de Wing (2006)</strong></td>
<td>Wing (2006)</td>
<td>• Decomposição<br>• Abstração<br>• Design algorítmico<br>• Generalização</td>
<td>• Não formaliza <em>Decomposição</em> como pilar independente<br>• <em>Generalização</em> ≠ <em>Validação prática iterativa</em></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="inovações-do-daad" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="inovações-do-daad"><span class="header-section-number">4.2</span> Inovações do DAAD</h2>
<p>A diferença <em>sine qua non</em> do <strong>DAAD</strong> em relação aos outros modelos é a integração explícita de <strong>Depuração</strong> <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>. Uma fase do processo de aprendizado dedicada à eliminação e correção de problemas, mas também valida soluções. Essa abordagem de Lehmann (2023) <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span> corrige a lacuna de modelos que ignoram o refinamento pós-implementação, promovendo uma compreensão mais profunda e prática do desenvolvimento de algoritmos.</p>
<p>Na Abordagem de York (2020) <span class="citation" data-cites="YorkCT2020">(<a href="referencias.html#ref-YorkCT2020" role="doc-biblioref">9</a>)</span>, o reconhecimento de padrões é estático, enquanto no <strong>DAAD</strong> a abstração é dinâmica, preparação para depuração. O modelo original de Wing (2006) <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Wing2006" role="doc-biblioref">2</a>)</span> trata generalização como resultado, enquanto no <strong>DAAD</strong> a <strong>Depuração</strong> torna-a processual através de iteração. Finalmente, a Abordagem <strong>Desplugada</strong> de Brackmann (2022) <span class="citation" data-cites="Brackmann2022">(<a href="referencias.html#ref-Brackmann2022" role="doc-biblioref">11</a>)</span> enfatiza modelagem física, mantém abstração como conceito teórico, já na Metodologia <strong>DAAD</strong> vincula-se à rastreabilidade durante validação, enquanto a Metodologia <strong>DAAD</strong> prioriza soluções algorítmicas e validação prática.</p>
<p>A estrutura do <strong>DAAD</strong> também inclui uma sequência pedagógica otimizada em ordenação lógica: <strong>Problema → Abstração → Algoritmo → Validação</strong>. O que contrasta com os modelos fragmentados, como as metodologias de York <span class="citation" data-cites="YorkCT2020">(<a href="referencias.html#ref-YorkCT2020" role="doc-biblioref">9</a>)</span> e Wing <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Wing2006" role="doc-biblioref">2</a>)</span> que não articulam nenhuma ordem de transição entre etapas. Além disso, como o objetivo é criar um <em>framework</em> pedagógico para a disciplina de <strong>Raciocínio Algorítmico</strong>, inicialmente, e depois progredir para todas as disciplinas dos cursos de Ciência e Engenharia da Computação, a Metodologia <strong>DAAD</strong> enfatiza a criação de algoritmos robustos e eficientes, alinhando-se às demandas do mercado de trabalho. Portanto, a Metodologia <strong>DAAD</strong> inclui a aplicação de técnicas avançadas de depuração, como testes de estresse e análise de casos limites, que vão além da simples correção de erros sintáticos. Suportando processos de depuração sistemática alinhados às demandas industriais à medida que a complexidade das disciplinas aumenta ao longo do curso.</p>
<p>A relação entre as fases do <strong>DAAD</strong> e a solução de problemas pode ser validada por meio da análise de problemas simples típicos das disciplinas introdutórias dos cursos de Ciência e Engenharia da Computação. A <a href="#fig-problemas1" class="quarto-xref">Figure&nbsp;<span>4.1</span></a> apresenta exemplos de problemas simples que podem ser resolvidos usando a Metodologia <strong>DAAD</strong>. Esses problemas são comuns em disciplinas introdutórias e ilustram como cada fase do <strong>DAAD</strong> pode ser aplicada para chegar a uma solução eficaz.</p>
<div class="#fig-problemas1">
<div id="fig-problemas1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-problemas1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/text8.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-problemas1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.1: Exemplos de problemas simples que podem ser resolvidos usando a metodologia DAAD.
</figcaption>
</figure>
</div>
</div>
<p>A Metodologia <strong>DAAD</strong> foi concebida para ir além das disciplinas introdutórias e além dos cursos de Ciência e Engenharia da Computação. O objetivo é que a Metodologia <strong>DAAD</strong> ajude a criar a capacidade de resolver problemas complexos de forma sistemática, promovendo uma compreensão profunda dos processos envolvidos na criação de soluções em qualquer área do conhecimento. Entretanto, como a prova de conceito aqui proposta diz respeito aos cursos de Ciência e Engenharia da Computação, a seguir são apresentados exemplos de aplicação do <strong>DAAD</strong> em contextos mais avançados, que demonstram sua versatilidade e aplicabilidade em problemas complexos e multidisciplinares.</p>
<ol type="1">
<li><strong>Otimização Algorítmica para Problemas NP-Difíceis</strong>: usando um modelo de decomposição baseado usando o Teorema Cook-Levin para problemas NP-completos, com métricas de validação de Dolan-Moré <span class="citation" data-cites="barak2023chapter15">(<a href="referencias.html#ref-barak2023chapter15" role="doc-biblioref">13</a>)</span>.</li>
</ol>
<ul>
<li><strong>Decomposição</strong>: fragmentação de problemas de otimização combinatorial (ex.: problema do caixeiro viajante) em subproblemas de roteamento local e conexões inter-regionais, permitindo abordagens <em>divide-et-conquer</em>, dividir e conquistar.<br>
</li>
<li><strong>Algoritmização</strong>: implementação de meta-heurísticas para busca de soluções ótimas em espaços de estado complexos.<br>
</li>
<li><strong>Depuração</strong>: validação via análise de falhas entre soluções heurísticas e limites teóricos, utilizando perfis de desempenho para avaliação estatística .</li>
</ul>
<ol start="2" type="1">
<li><strong>Engenharia de Sistemas Embarcados</strong>: usando <em>framework</em> de abstração conforme definido por Wilhelm (2008) para sistemas tempo-real, com validação por Henzinger (2007), teremos:</li>
</ol>
<ul>
<li><strong>Abstração</strong>: modelagem de invariantes temporais e de consumo energético através de <strong>W</strong>orst-<strong>C</strong>ase <strong>E</strong>xecution <strong>T</strong>ime, <strong>WCET</strong>, e máquinas de estado de consumo, filtrando variáveis não essenciais ao cumprimento de restrições rígidas de tempo real.<br>
</li>
<li><strong>Algoritmização</strong>: síntese de algoritmos com garantias formais (ex.: controle PID com provas de estabilidade usando a Função de Lyapunov <span class="citation" data-cites="Murray1994">(<a href="referencias.html#ref-Murray1994" role="doc-biblioref">14</a>)</span>) atendendo a requisitos de segurança.<br>
</li>
<li><strong>Depuração</strong>: verificação <strong>H</strong>ardware-<strong>I</strong>n-the-<strong>L</strong>oop, <strong>HIL</strong>, com injeção de falhas sistêmicas e análise de violações de datas limites via acompanhamento e registro, em tempo real.</li>
</ul>
<ol start="3" type="1">
<li><strong>Desenvolvimento de Pipeline de Aprendizado de Máquina</strong>: usando com referência o trabalho de Geron (2019) <span class="citation" data-cites="Geron2019">(<a href="referencias.html#ref-Geron2019" role="doc-biblioref">15</a>)</span>, que descreve a construção de sistemas de aprendizado de máquina como um processo iterativo e sistemático, teremos:</li>
</ol>
<ul>
<li><strong>Decomposição</strong>: fragmentação do fluxo de trabalho em coleta de dados, pré-processamento, seleção de modelo, treinamento e avaliação.<br>
</li>
<li><strong>Abstração</strong>: identificação de características essenciais nos dados (ex.: seleção de funcionalidades via análise de componente principal, PCA, ou análise de importância) .<br>
</li>
<li><strong>Algoritmização</strong>: projeto de arquitetura de redes neurais ou ajuste de hiperparâmetros de algoritmos de classificação.<br>
</li>
<li><strong>Depuração</strong>: validação cruzada, análise de superajuste, <em>overfitting</em> e ajuste de modelos com base em métricas de precisão.</li>
</ul>
<ol start="4" type="1">
<li><strong>Desenvolvimento de Sistemas Concorrentes</strong>: usando como referência o trabalho de Herlihy (2015)<span class="citation" data-cites="Herlihy2012">(<a href="referencias.html#ref-Herlihy2012" role="doc-biblioref">16</a>)</span>, que aborda a construção de sistemas concorrentes e distribuídos, teremos:</li>
</ol>
<ul>
<li><strong>Decomposição</strong>: divisão do sistema em tarefas concorrentes (ex.: <em>threads</em> para E/S, processamento e comunicação).<br>
</li>
<li><strong>Abstração</strong>: isolamento de seções críticas e recursos compartilhados (ex.: <em>buffer</em> de mensagens).<br>
</li>
<li><strong>Algoritmização</strong>: criação de protocolos de sincronização (ex.: semáforos, <em>mutexes</em>) e algoritmos de exclusão mútua.<br>
</li>
<li><strong>Depuração</strong>: teste de estresse para detecção de <em>deadlocks</em> e condições de corrida com ferramentas como <em>Valgrind</em> ou <em>TSan</em> .</li>
</ul>
<ol start="5" type="1">
<li><strong>Desenvolvimento de Sistemas Distribuídos</strong>: este caso requer a aplicação dos princípios de decomposição hierárquica e depuração em falhas não determinísticas, seguindo o modelo de Tanenbaum (2015) <span class="citation" data-cites="Tanenbaum2015">(<a href="referencias.html#ref-Tanenbaum2015" role="doc-biblioref">17</a>)</span> para sistemas distribuídos.</li>
</ol>
<ul>
<li><strong>Decomposição</strong>: divisão de sistemas complexos em microsserviços independentes (ex.: separação de módulos de autenticação, processamento de pagamentos e gerenciamento de dados) para tratamento paralelo.</li>
<li><strong>Algoritmização</strong>: implementação de protocolos de consenso como <em>Raft</em> ou <em>Paxos</em> para garantir consistência entre nós distribuídos.</li>
<li><strong>Depuração</strong>: simulação de falhas em cascata e testes de partição de rede com ferramentas como <em>Chaos Monkey</em> para validar resiliência<span class="citation" data-cites="Netflix2021">(<a href="referencias.html#ref-Netflix2021" role="doc-biblioref">18</a>)</span>.</li>
</ul>
</section>
<section id="metodologia-daad-estrutura-e-fases" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="metodologia-daad-estrutura-e-fases"><span class="header-section-number">4.3</span> Metodologia DAAD: Estrutura e Fases</h2>
<p>A Metodologia <strong>DAAD</strong> é composta por quatro fases principais: <strong>Decomposição</strong>, <strong>Abstração</strong>, <strong>Algoritmização</strong> e <strong>Depuração</strong>. Cada fase desempenha um papel importante na resolução de problemas complexos, permitindo que os alunos desenvolvam habilidades de raciocínio e análise. A seguir, são apresentadas as fases da Metodologia <strong>DAAD</strong> e suas respectivas definições.</p>
<p>A Metodologia <strong>DAAD</strong> pode ser representada visualmente como um ciclo contínuo, no qual cada fase se conecta à próxima, formando um processo iterativo de resolução de problemas. A <a href="#fig-daad" class="quarto-xref">Figure&nbsp;<span>4.2</span></a> ilustra essa representação, destacando as fases de <strong>Decomposição</strong>, <strong>Abstração</strong>, <strong>Algoritmização</strong> e <strong>Depuração</strong>.</p>
<div class="#fig-daad">
<div id="fig-daad" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-daad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/DAAD.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-daad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.2: Representação visual da metodologia DAAD.
</figcaption>
</figure>
</div>
</div>
<p>A representação visual da Metodologia <strong>DAAD</strong> enfatiza a natureza cíclica e interconectada do processo de resolução de problemas. Porém, contém uma deficiência, pois não representa a natureza iterativa da metodologia; talvez uma espiral fosse mais adequada. Contudo, como a espiral é, em si própria, uma representação complexa, a representação em ciclo parece mais adequada para o ensino inicial da Metodologia <strong>DAAD</strong>. A característica iterativa e cíclica da Metodologia <strong>DAAD</strong> pode ser percebida por meio do detalhamento das fases da Metodologia <strong>DAAD</strong>.</p>
<section id="decomposição-quebrando-a-complexidade" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="decomposição-quebrando-a-complexidade"><span class="header-section-number">4.3.1</span> Decomposição: Quebrando a Complexidade</h3>
<p>A <strong>D</strong>ecomposição é o processo analítico pelo qual problemas ou conceitos complexos são divididos em partes menores e mais gerenciáveis <span class="citation" data-cites="Smith2021">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>. Esse passo é necessário para a construção de uma resolução eficaz de problemas, transformando situações que inicialmente parecem complexas e limitantes em elementos mais simples e acessíveis <span class="citation" data-cites="Kong2019">(<a href="referencias.html#ref-Kong2019" role="doc-biblioref">23</a>)</span>. Miller (1956) descobriu que a memória humana está limitada a 7 ± 2 elementos, o que implica que a decomposição de informações complexas em partes menores pode facilitar a compreensão e a retenção <span class="citation" data-cites="Miller1956">(<a href="referencias.html#ref-Miller1956" role="doc-biblioref">24</a>)</span>. Ao dividir um problema grande em subproblemas, torna-se mais fácil analisar cada componente isoladamente e, posteriormente, integrar as soluções para resolver o problema original <span class="citation" data-cites="Saidin2021">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>.</p>
<p>Dividir o problema em partes menores, fragmentos, é o primeiro problema que o aluno precisa resolver usando a própria Metodologia <strong>DAAD</strong>.</p>
<p>Uma das formas de transformar os fragmentos resultantes do processo de decomposição é a modelagem e análise. Um modelo funciona como uma representação abstrata de situações do mundo real <span class="citation" data-cites="Frigg2002">(<a href="referencias.html#ref-Frigg2002" role="doc-biblioref">25</a>)</span> e é útil em soluções de engenharia e computação. O processo de modelagem começa com o reconhecimento de padrões e a correspondência de padrões.</p>
<p>Estes processos envolvem a identificação de similaridades e diferenças entre as partes menores do problema. Esta identificação de similaridades e diferenças ajuda a categorizar os fragmentos do problema em uma sequência específica <span class="citation" data-cites="Curzon2019">(<a href="referencias.html#ref-Curzon2019" role="doc-biblioref">1</a>)</span>. No contexto da <strong>Decomposição</strong>, a correspondência de padrões oferece oportunidades interessantes. Os padrões descobertos podem ser transferidos para problemas similares, evitando reiniciar processos do zero.</p>
<p>O próximo passo é a generalização dos fragmentos, mediante a eliminação de detalhes irrelevantes <span class="citation" data-cites="DenningTedre2019">(<a href="referencias.html#ref-DenningTedre2019" role="doc-biblioref">26</a>)</span>. Aqui, dentro da <strong>Decomposição</strong> surge um processo de <strong>Abstração</strong> baseado na lógica indutiva. A lógica indutiva baseia-se no princípio de que conclusões gerais podem ser derivadas de observações e experiências empíricas. Como essas conclusões indutivas contêm incerteza inerente, seu grau de confiabilidade depende do número de observações realizadas <span class="citation" data-cites="muggleton1991inductive">(<a href="referencias.html#ref-muggleton1991inductive" role="doc-biblioref">27</a>)</span>. Contudo, o uso da indução permite a formulação de regras gerais a partir de casos individuais e permite a definição apurada dos fragmentos em que o problema deve ser resolvido. Neste ponto, a <strong>Decomposição</strong> exige a dedução. A dedução requer conhecimento das regras e limites do problema que está sendo resolvido. A essência do uso da <strong>Abstração</strong> na decomposição reside na eliminação de detalhes irrelevantes e no foco em elementos essenciais, simplificando estruturas complexas e permitindo ênfases específicas <span class="citation" data-cites="Kong2020">(<a href="referencias.html#ref-Kong2020" role="doc-biblioref">3</a>)</span>.</p>
<p>A definição das partes resultantes da <strong>Decomposição</strong> requer que os fragmentos encontrados sejam validados. A validação é o processo de garantir que as partes do problema sejam adequadas para a solução do problema original e que funcionem em conjunto. Para isso, é importante organizar as partes em uma forma que permita a avaliação. Esta organização é chamada de <strong>Algoritmização</strong>. A validação pode ser feita por meio de testes, simulações ou outras técnicas que garantam que as partes sejam adequadas para a solução do problema original <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>. Este processo de validação é, na verdade, a aplicação dos conceitos de <strong>Depuração</strong>.</p>
<p>No contexto da engenharia, a decomposição é empregada para desmembrar tarefas complexas, como a simulação de construção, em segmentos menores e mais fáceis de gerenciar <span class="citation" data-cites="Araujo2016">(<a href="referencias.html#ref-Hijn-Neira2024" role="doc-biblioref">5</a>)</span>. Na ciência da computação, a <strong>Decomposição</strong> visa quebrar um problema ou sistema complexo em partes que são mais fáceis de conceber, entender, programar e manter <span class="citation" data-cites="Smith2021">(<a href="referencias.html#ref-Smith2021" role="doc-biblioref">19</a>)</span>.</p>
<p>Exemplos clássicos <em>unplugged</em> incluem a divisão da tarefa de fazer um bolo em etapas menores, como preparar a massa, assar o bolo, fazer a cobertura e aplicá-la. Todos os exemplos de tarefas diárias, como fazer um sanduíche, montar um quebra-cabeça ou organizar uma festa, podem ser vistos como exemplos de <strong>Decomposição</strong>. Desmembrar uma tarefa como fazer um bolo, ou outras tarefas diárias, em etapas menores e mais gerenciáveis busca facilitar a execução e o entendimento do processo como um todo, o que reflete diretamente o propósito da <strong>Decomposição</strong>: quebrar um problema ou sistema complexo em partes que são mais fáceis de conceber, entender, programar ou manter <span class="citation" data-cites="Smith2021">(<a href="referencias.html#ref-Wing2006" role="doc-biblioref">2</a>)</span>.</p>
</section>
<section id="abstração-focando-no-essencial" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="abstração-focando-no-essencial"><span class="header-section-number">4.3.2</span> Abstração: Focando no Essencial</h3>
<p>A <strong>A</strong>bstração é uma técnica central do <strong>Pensamento Computacional</strong> que se concentra em identificar informações importantes e relevantes, enquanto ignora detalhes desnecessários ou irrelevantes, facilitando uma compreensão mais clara das questões essenciais <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Curzon2019" role="doc-biblioref">1</a>)</span> referentes ao problema que precisa ser resolvido. A abstração é o processo de generalizar detalhes concretos para direcionar a atenção para aspectos de maior importância <span class="citation" data-cites="DenningTedre2019">(<a href="referencias.html#ref-DenningTedre2019" role="doc-biblioref">26</a>)</span>.</p>
<p>A abstração é considerada o processo de pensamento de mais alto nível no <strong>Pensamento Computacional</strong>, conferindo a capacidade de escalar e gerenciar a complexidade <span class="citation" data-cites="DenningTedre2019">(<a href="referencias.html#ref-DenningTedre2019" role="doc-biblioref">26</a>)</span>. A sua presença é tão difundida na ciência da computação que a sua descrição concisa é um desafio, e embora haja um consenso sobre a sua centralidade <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Curzon2019" role="doc-biblioref">1</a>)</span>, as definições exatas podem variar entre os investigadores. Porém, unindo as definições, podemos afirmar que:</p>
<p>A <strong>Abstração</strong> é o processo cognitivo de redução da complexidade que envolve a criação de representações gerais de processos ou grupos de objetos mediante a remoção sistemática de informações desnecessárias e o foco seletivo nos elementos essenciais de uma situação específica <span class="citation" data-cites="NYSCI">(<a href="referencias.html#ref-NYSCI" role="doc-biblioref">21</a>)</span>. Este processo permite a formulação de afirmações gerais que resumem exemplos particulares sobre conceitos, procedimentos, relações e modelos subjacentes <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>, constituindo uma estratégia fundamental para lidar com a complexidade <span class="citation" data-cites="GroverPea2013">(<a href="referencias.html#ref-GroverPea2013" role="doc-biblioref">29</a>)</span>.</p>
<p>A <strong>Abstração</strong> caracteriza-se pela capacidade de identificar padrões e realizar generalizações a partir de instâncias específicas, criando representações que sejam não apenas apropriadas para o propósito imediato, mas também reutilizáveis em contextos diferentes <span class="citation" data-cites="Kong2019">(<a href="referencias.html#ref-Kong2019" role="doc-biblioref">23</a>)</span>. Esta habilidade cognitiva permite que soluções desenvolvidas para problemas específicos possam ser adaptadas e aplicadas a situações análogas, otimizando o processo de resolução de problemas e promovendo a transferência de conhecimento entre domínios distintos.</p>
<p>No contexto do <strong>Raciocínio Algorítmico</strong> e do <strong>Pensamento Computacional</strong>, a <strong>Abstração</strong> funciona como uma ferramenta indispensável para a simplificação de estruturas complexas e terá impacto na <strong>Decomposição</strong> e <strong>Algoritmização</strong>. A <strong>Abstração</strong> permite que os solucionadores de problemas concentrem seus recursos cognitivos nos aspectos mais relevantes e significativos de uma situação, descartando detalhes que não contribuem para a compreensão ou resolução do problema em questão <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Kong2020" role="doc-biblioref">3</a>)</span>.</p>
<p>Como a <strong>abstração</strong> também é caracterizada como a habilidade de construir representações utilizando os componentes essenciais que demonstram o funcionamento do problema ou sistema <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>. Exemplos ilustrativos, <em>unplugged</em>, de <strong>Abstração</strong> incluem o uso de mapas, que simplificam o mundo real ao omitir detalhes desnecessários e, principalmente <strong>fluxogramas</strong>.</p>
<p>Os fluxogramas funcionam como ferramentas de abstração porque simplificam processos complexos em representações visuais que eliminam detalhes de implementação específicos. Além disso, os fluxogramas identificam padrões estruturais (sequências, decisões, repetições) e removem informações desnecessárias como sintaxe específica, permitindo que programadores se concentrem no essencial do problema. Finalmente, fluxogramas podem ser realizados completamente <em>unplugged</em>, sem o uso de computadores, o que os torna uma ferramenta acessível para ensinar abstração e raciocínio algorítmico utilizando as vantagens cognitivas do ensino <em>unplugged</em><span class="citation" data-cites="weintrop2015unplugged">(<a href="referencias.html#ref-weintrop2015unplugged" role="doc-biblioref">30</a>)</span>. O uso de fluxogramas induz a <strong>Algoritmização</strong>.</p>
</section>
<section id="algoritmização-desenvolvendo-soluções-sistemáticas" class="level3" data-number="4.3.3">
<h3 data-number="4.3.3" class="anchored" data-anchor-id="algoritmização-desenvolvendo-soluções-sistemáticas"><span class="header-section-number">4.3.3</span> Algoritmização: Desenvolvendo Soluções Sistemáticas</h3>
<p>A <strong>A</strong>lgoritmização, ou Design de Algoritmos para Wing (2006) <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Wing2006" role="doc-biblioref">2</a>)</span>, envolve a criação de instruções passo a passo ou procedimentos para resolver um problema. Um algoritmo é definido como uma sequência finita de instruções matematicamente rigorosas, tipicamente utilizadas para resolver uma classe específica de problemas ou para realizar uma computação <span class="citation" data-cites="Wing2006">(<a href="referencias.html#ref-Kim2021ComputationalThinking" role="doc-biblioref">31</a>)</span>. Para fazer um algoritmo, é necessário decompor o problema em partes menores, identificar padrões e abstrair os detalhes irrelevantes, seguindo as etapas da Metodologia <strong>DAAD</strong>. A <strong>Algoritmização</strong> é a fase em que as soluções são formalizadas e estruturadas, permitindo que sejam implementadas de forma sistemática e eficiente <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-Lehmann2023" role="doc-biblioref">4</a>)</span>.</p>
<p>A <strong>Algoritmização</strong> baseia-se na premissa de que as soluções para os problemas não se limitam a respostas pontuais, mas sim a algoritmos que podem fornecer respostas sempre que necessário para casos gerais <span class="citation" data-cites="Saidin2021">(<a href="referencias.html#ref-Saidin2021" role="doc-biblioref">22</a>)</span>. É o processo de construir um esquema de passos ordenados que podem ser seguidos para fornecer soluções para todos os problemas constituintes necessários para resolver o problema original. A capacidade de expressar uma solução na forma de um algoritmo demonstra uma compreensão mais profunda do problema <span class="citation" data-cites="Gundogdu2023">(<a href="referencias.html#ref-Lehmann2024" role="doc-biblioref">33</a>)</span>. A eficiência, em termos de velocidade ou uso de memória, é uma consideração importante na criação de algoritmos <span class="citation" data-cites="Lehmann2024">(<a href="referencias.html#ref-Lehmann2024" role="doc-biblioref">33</a>)</span> sempre que o objetivo final for transformar o algoritmo em uma solução computacional.</p>
<p>As abstrações necessárias ao entendimento de algoritmos podem ser expressas de várias formas, incluindo linguagem natural, pseudocódigo, fluxogramas e diagramas <span class="citation" data-cites="Kim2021ComputationalThinking">(<a href="referencias.html#ref-Kim2021ComputationalThinking" role="doc-biblioref">31</a>)</span>. Neste contexto, destacam-se os fluxogramas e o pseudocódigo como ferramentas de apoio.</p>
<p>O pseudocódigo atua como uma ponte entre a abstração visual e a escrita de código real, descrevendo algoritmos em linguagem natural estruturada. O pseudocódigo facilita a compreensão de estruturas condicionais <span class="citation" data-cites="Hijn-Neira2024">(<a href="referencias.html#ref-TedreDenning2016" role="doc-biblioref">8</a>)</span>. Expressar um processo como um algoritmo, o que o pseudocódigo permite, força a precisão na formulação e leva a uma compreensão mais profunda do problema do que outros meios de pensamento tradicionais <span class="citation" data-cites="TedreDenning2016">(<a href="referencias.html#ref-TedreDenning2016" role="doc-biblioref">8</a>)</span>.</p>
<p>O fluxograma permite que os alunos visualizem estruturas de controle como condicionais e laços, além do fluxo de dados e pontos de parada. Um exemplo prático envolve representar a tomada de decisão para identificar se um número é positivo ou negativo, conectando etapas como leitura do valor, verificação da condição e saída do resultado em uma sequência gráfica. A <a href="desenv1.html#fig-fluxograma1" class="quarto-xref">Figure&nbsp;<span>6.1</span></a> ilustra um exemplo de fluxograma que pode ser usado para ensinar a <strong>Algoritmização</strong> em uma ferramenta que remove o fator <em>unplugged</em> porém permite a <strong>Depuração</strong> independente <span class="citation" data-cites="AlcantaraFluxograma">(<a href="referencias.html#ref-AlcantaraFluxograma" role="doc-biblioref">34</a>)</span>.</p>
<div class="#fig-fluxograma1">
<div id="fig-fluxograma1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fluxograma1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fluxo1.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fluxograma1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.3: Exemplo de fluxograma que pode ser usado para ensinar a Algoritmização.
</figcaption>
</figure>
</div>
</div>
</section>
<section id="depuração-identificando-e-corrigindo-erros" class="level3" data-number="4.3.4">
<h3 data-number="4.3.4" class="anchored" data-anchor-id="depuração-identificando-e-corrigindo-erros"><span class="header-section-number">4.3.4</span> Depuração: Identificando e Corrigindo Erros</h3>
<p>A <strong>D</strong>epuração é a fase responsável por encontrar e remover erros, imperfeições ou elementos indesejáveis durante todas as fases da Metodologia <strong>DAAD</strong>. Na computação, a depuração, <em>debugging</em>, é o processo de identificar, isolar e corrigir erros em programas de computador, garantindo que eles funcionem conforme o esperado <span class="citation" data-cites="Kim2021ComputationalThinking">(<a href="referencias.html#ref-Kim2021ComputationalThinking" role="doc-biblioref">31</a>)</span>.</p>
<p>O processo de depuração envolve a identificação do erro, a análise de sua causa, registrando as mudanças de estado do programa e os valores dos dados, a correção do problema e a validação da correção por meio de testes <span class="citation" data-cites="Lehmann2023">(<a href="referencias.html#ref-GroverPea2013" role="doc-biblioref">29</a>)</span>. É uma atividade iterativa que contribui para a construção do conhecimento e o aprendizado de estratégias de resolução de problemas <span class="citation" data-cites="Brennan2012">(<a href="referencias.html#ref-Brennan2012" role="doc-biblioref">35</a>)</span>.</p>
<p>O trabalho de Brennan e Resnick (2012) <span class="citation" data-cites="Brennan2012">(<a href="referencias.html#ref-Brennan2012" role="doc-biblioref">35</a>)</span> estabelece a <strong>Depuração</strong> como uma das práticas computacionais fundamentais. Esta abordagem reconhece debugging não como habilidade isolada, mas como componente integrado do processo de resolução de problemas. A <strong>Depuração</strong> pode ser sintetizada em cinco etapas: validar; identificar; representar; localizar e corrigir. Esta sistematização oferece <em>framework</em> pedagógico aplicável a diferentes faixas etárias, desde educação infantil até ensino superior, com adaptações apropriadas para cada nível de desenvolvimento cognitivo <span class="citation" data-cites="Brennan2012">(<a href="referencias.html#ref-Brennan2012" role="doc-biblioref">35</a>)</span>.</p>
<p>Nas fases de <strong>Decomposição</strong> e <strong>Abstração</strong>, a <strong>Depuração</strong> atua como um processo de refinamento contínuo. Cada fase requer uma técnica específica para identificar e corrigir problemas, garantindo que o processo de resolução de problemas seja robusto e eficiente. Por exemplo, na <strong>Decomposição</strong>, a depuração pode envolver a verificação da clareza e viabilidade dos subproblemas identificados. Na <strong>Abstração</strong>, a depuração pode se concentrar na eliminação de detalhes irrelevantes que possam obscurecer a compreensão do problema. Nestes dois casos, a representação de conceitos em palavras simples pode ser a forma mais eficiente.</p>
<p>Neste cenário, fluxogramas oferecem representação visual clara da lógica algorítmica, facilitando identificação de caminhos de execução problemáticos. Estratégias eficazes incluem a análise visual através do rastreamento do fluxo do algoritmo identificando pontos de falha. Tanto o fluxograma quanto o pseudocódigo são ferramentas valiosas para a <strong>Depuração</strong>, pois permitem que os alunos visualizem a lógica do algoritmo e identifiquem possíveis erros de forma mais intuitiva. Tabelas de rastreamento, nas quais os alunos registram valores de variáveis e estados do programa durante a execução, são úteis para identificar erros lógicos e comportamentais.</p>
</section>
</section>
<section id="ferramentas-de-abstração-na-metodologia-daad" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="ferramentas-de-abstração-na-metodologia-daad"><span class="header-section-number">4.4</span> Ferramentas de Abstração na Metodologia DAAD</h2>
<p>As ferramentas de abstração e apoio à Metodologia <strong>DAAD</strong> incluem uma variedade de recursos visuais e interativos que facilitam a compreensão e aplicação das fases do processo. Algumas dessas ferramentas são:</p>
<section id="fluxogramas" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="fluxogramas"><span class="header-section-number">4.4.1</span> Fluxogramas</h3>
<p>Representações visuais que ilustram a lógica do algoritmo, permitindo identificar facilmente os passos e decisões envolvidas. Historicamente, o fluxograma — uma representação visual padronizada de processos — emergiu como uma das principais ferramentas para construir essa ponte entre o pensamento humano e a lógica computacional na década de 1960. No entanto, sua prevalência e utilidade são temas de um debate contínuo e vigoroso na academia, refletindo uma tensão mais ampla entre a teoria da carga cognitiva, a necessidade de aprendizado e a rápida evolução dos paradigmas de programação. A persistência dos fluxogramas em contextos educacionais é sustentada por vantagens pedagógicas claras, validadas por estudos empíricos.</p>
<ul>
<li><p><strong>Redução da Carga Cognitiva</strong>: A principal vantagem é a separação da lógica da sintaxe. Ferramentas visuais como os fluxogramas reduzem a carga extrínseca, permitindo que os alunos dediquem seus recursos cognitivos à tarefa mais fundamental de estruturar uma solução <span class="citation" data-cites="Pritchard2018">(<a href="referencias.html#ref-Pritchard2018" role="doc-biblioref">36</a>)</span>.</p></li>
<li><p><strong>Clareza Visual e Desempenho Superior em Compreensão</strong>: Um estudo empírico de 2022, que utilizou rastreamento ocular, descobriu que, ao analisar algoritmos, os participantes foram significativamente mais rápidos, cometeram menos erros e tiveram maior confiança em suas soluções ao usar fluxogramas estruturados em comparação com o pseudocódigo <span class="citation" data-cites="Ali2022">(<a href="referencias.html#ref-Ali2022" role="doc-biblioref">37</a>)</span>.</p></li>
<li><p><strong>Alavanca para a Programação Textual (Scaffolding)</strong>: Pesquisas recentes demonstram que a habilidade de resolver problemas usando fluxogramas é um forte preditor da habilidade de resolver os mesmos problemas em uma linguagem textual como o Python <span class="citation" data-cites="Pritchard2018">(<a href="referencias.html#ref-Pritchard2018" role="doc-biblioref">36</a>)</span>.</p></li>
<li><p><strong>Aplicações Modernas e Inovadoras</strong>: A defesa moderna dos fluxogramas não se concentra no desenho manual, mas em sua integração em ambientes de software interativos. Ferramentas como o <em>Progranimate</em> permitem que os alunos construam fluxogramas dinâmicos que são sincronizados visualmente com o código gerado e uma animação da execução do programa <span class="citation" data-cites="Pritchard2018">(<a href="referencias.html#ref-Pritchard2018" role="doc-biblioref">36</a>)</span>.</p></li>
</ul>
<p>A crítica mais contundente ao uso de fluxogramas surge da sua inadequação aos paradigmas modernos. Os fluxogramas são inerentemente procedurais e sequenciais. Eles são inadequados para representar paradigmas como Programação Orientada a Objetos (POO), recursividade e concorrência <span class="citation" data-cites="SBC2018BNCC">(<a href="referencias.html#ref-SBC2018BNCC" role="doc-biblioref">38</a>)</span>. Para modelar sistemas complexos e orientados a objetos, a indústria e a academia utilizam a Linguagem de Modelagem Unificada (UML). Apesar disso, a evolução histórica das ferramentas de ensino de programação, desde os fluxogramas e pseudocódigo, passando pelas linguagens baseadas em blocos como o Scratch, até aos modernos assistentes de IA, pode ser vista como uma busca contínua por um ponto ótimo de abstração. Cada geração de ferramentas tenta minimizar a carga cognitiva extrínseca (relacionada com a sintaxe e o ambiente de desenvolvimento) sem sacrificar a carga cognitiva essencial, o próprio <strong>Raciocínio Algorítmico</strong> <span class="citation" data-cites="leinonen2024how">(<a href="referencias.html#ref-leinonen2024how" role="doc-biblioref">39</a>)</span>. Esta trajetória não é aleatória; é uma otimização pedagógica impulsionada pela teoria da carga cognitiva, que procura libertar os recursos mentais do aluno para que se possam concentrar no que é verdadeiramente fundamental: a arte de resolver problemas.</p>
<p>A principal vantagem pedagógica do fluxograma reside na sua clareza visual. Ao representar um algoritmo como um diagrama, ele transforma um processo temporal e abstrato num artefacto espacial e concreto, permitindo que os alunos visualizem um constructo físico que representa o fluxo de controle, os pontos de decisão e a sequência de operações. Para isso, na Metodologia <strong>DAAD</strong>, como proposta neste documento, os alunos poderão utilizar apenas 4 dos símbolos usados para fluxogramas <span class="citation" data-cites="iso1985">(<a href="referencias.html#ref-iso1985" role="doc-biblioref">40</a>)</span>, como pode ser visto na <a href="#fig-simb" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>.</p>
<div class="#fig-simb">
<div id="fig-simb" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-simb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/simbolosbasicos.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-simb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.4: Símbolos usados para fluxogramas na metodologia DAAD.
</figcaption>
</figure>
</div>
</div>
<p>A simplicidade dos símbolos utilizados na Metodologia <strong>DAAD</strong>, em relação aos símbolos tradicionais de fluxogramas<span class="citation" data-cites="iso5807:1985">(<a href="referencias.html#ref-iso5807:1985" role="doc-biblioref">41</a>)</span>, permite que os alunos se concentrem na lógica do algoritmo, e internalizem as abstrações básicas para a solução de problemas usando o <strong>Raciocínio Algorítmico</strong>. Algumas pesquisas corroboram a eficácia dos fluxogramas na educação de programação:</p>
<ul>
<li><p><strong>Eficiência na Compreensão</strong>: uma quantidade significativa de evidências empíricas sugere que os fluxogramas são superiores ao pseudocódigo em tarefas de compreensão de algoritmos. Estudos controlados, alguns utilizando tecnologia de <em>eye-tracking</em> para medir objetivamente a atenção, descobriram que os participantes analisavam algoritmos representados por fluxogramas de forma significativamente mais rápida e com menos erros do que quando representados por pseudocódigo <span class="citation" data-cites="andrzejewska2022structured">(<a href="referencias.html#ref-andrzejewska2022structured" role="doc-biblioref">42</a>)</span>.</p></li>
<li><p><strong>Impacto da Complexidade</strong>: a vantagem dos fluxogramas parece aumentar com a complexidade do algoritmo. Para problemas mais complexos, a diferença no tempo de análise e na taxa de erro a favor dos fluxogramas torna-se ainda mais pronunciada <span class="citation" data-cites="andrzejewska2022structured">(<a href="referencias.html#ref-andrzejewska2022structured" role="doc-biblioref">42</a>)</span>.</p></li>
<li><p><strong>Confiança e Preferência do Aluno</strong>: os alunos não só têm um desempenho melhor com fluxogramas, como também relatam sentir-se mais confiantes nas suas soluções e expressam uma clara preferência pela representação visual. Num estudo seminal de Scanlan (1989) <span class="citation" data-cites="scanlan1989structured">(<a href="referencias.html#ref-scanlan1989structured" role="doc-biblioref">43</a>)</span>, os alunos que usaram fluxogramas demonstraram uma melhor compreensão, maior confiança, cometeram menos erros e necessitaram de menos tempo de aprendizagem em comparação com os que usaram pseudocódigo <span class="citation" data-cites="threekunprapa2020patterns">(<a href="referencias.html#ref-threekunprapa2020patterns" role="doc-biblioref">44</a>)</span>.</p></li>
<li><p><strong>Base Cognitiva</strong>: acredita-se que a representação visual e espacial dos fluxogramas estimula ambos os hemisférios cerebrais, enquanto o pseudocódigo, sendo textual, estimula predominantemente o hemisfério esquerdo, associado ao processamento lógico e linguístico. Esta estimulação mais holística pode tornar os fluxogramas mais acessíveis a uma gama mais vasta de estilos de aprendizagem <span class="citation" data-cites="siozou2008effect">(<a href="referencias.html#ref-siozou2008effect" role="doc-biblioref">45</a>)</span>.</p></li>
</ul>
<p>A <a href="#fig-fluxograma2" class="quarto-xref">Figure&nbsp;<span>4.5</span></a> ilustra um exemplo de fluxograma que pode ser usado para ensinar a <strong>Abstração</strong> e a <strong>Algoritmização</strong> em uma ferramenta que remove o fator <em>unplugged</em> porém permite a <strong>Depuração</strong> independente.</p>
<div class="#fig-fluxograma2">
<div id="fig-fluxograma2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fluxograma2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fluxo-exemplo.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fluxograma2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.5: Exemplo de fluxograma que pode ser usado para ensinar a Abstração e a Algoritmização.
</figcaption>
</figure>
</div>
</div>
<p>A análise da literatura e da prática curricular revela um paradoxo notável. Por um lado, a investigação empírica, particularmente estudos controlados recentes, demonstra que os fluxogramas podem ser uma ferramenta de abstração eficaz para programadores iniciantes. Eles superam consistentemente o pseudocódigo em tarefas de compreensão visual, reduzem o tempo de aprendizagem e a taxa de erros, e aumentam a confiança dos alunos <span class="citation" data-cites="andrzejewska2022structured">(<a href="referencias.html#ref-andrzejewska2022structured" role="doc-biblioref">42</a>)</span>. Por outro lado, esta eficácia teórica contrasta fortemente com sua ausência quase total na prática pedagógica das principais universidades pesquisadas neste estudo <span class="citation" data-cites="harvard_cs50_intro">(<a href="referencias.html#ref-CambridgeAlgorithms" role="doc-biblioref">48</a>)</span>. Estas instituições, que definem as tendências na educação em ciência da computação, relegaram os fluxogramas a um papel secundário em favor da codificação direta em linguagens de alto nível como Python <span class="citation" data-cites="PythonDocs">(<a href="referencias.html#ref-PythonDocs" role="doc-biblioref">49</a>)</span>, ou do uso de linguagens baseadas em blocos como o Scratch <span class="citation" data-cites="ScratchFoundation">(<a href="referencias.html#ref-ScratchFoundation" role="doc-biblioref">50</a>)</span> como um passo introdutório. E aqui reside o dilema que o <em>framework</em> proposto por este estudo para a Metodologia <strong>DAAD</strong> pretende resolver usando as vantagens cognitivas dos fluxogramas sem sacrificar a carga cognitiva necessária aos paradigmas modernos.</p>
<p>A solução está no equilíbrio. A pedagogia de <strong>Raciocínio Algorítmico</strong> não deve adotar uma rejeição total dos fluxogramas, mas sim um reposicionamento estratégico do seu papel no currículo. Em vez de serem vistos como uma ferramenta universal para o design de algoritmos, devem ser empregados como uma ferramenta de nicho, com um propósito pedagógico específico e limitado. O seu uso ideal é como uma ferramenta introdutória e transitória para alunos iniciantes. O objetivo deve ser o de visualizar explicitamente as três estruturas de controlo fundamentais da programação estruturada: atribuição, decisão e iteração (laços).</p>
</section>
<section id="pseudocódigo" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="pseudocódigo"><span class="header-section-number">4.4.2</span> Pseudocódigo</h3>
<p>O pseudocódigo é uma forma de descrever algoritmos em linguagem natural, que ajuda os alunos a entender a lógica sem se preocupar com a sintaxe de uma linguagem de programação específica. A sua estrutura textual do pseudocódigo assemelha-se à estrutura de uma linguagem de programação real, o que pode, teoricamente, facilitar a transição final para a codificação. Além disso, o pseudocódigo parece ser mais adequado para descrever algoritmos complexos em detalhe, nos quais um fluxograma se tornaria visualmente poluído e ilegível <span class="citation" data-cites="knowledgeacademy2025flowchart">(<a href="referencias.html#ref-knowledgeacademy2025flowchart" role="doc-biblioref">51</a>)</span>.</p>
<p>Tipicamente, o pseudocódigo utiliza uma linguagem simples e direta, evitando jargões técnicos. Muitas vezes, é escrito em uma mistura de inglês simples, ou português, com uma estrutura semelhante à de programação, o que o torna acessível tanto para programadores quanto para não programadores. Como o exemplo podemos criar um pseudocódigo baseado no fluxograma da <a href="#fig-fluxograma2" class="quarto-xref">Figure&nbsp;<span>4.5</span></a>:</p>
<div id="lst-algoritmo1" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-algoritmo1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;4.1
</figcaption>
<div aria-describedby="lst-algoritmo1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="lst-algoritmo1" class="shell"><code>ALGORITMO EncontrarMaximo
INÍCIO
    // Entrada dos dados
    LEIA a
    LEIA b
    
    // Processo de decisão
    SE a &gt; b ENTÃO
        max ← a
    SENÃO
        max ← b
    FIM SE
    
    // Saída do resultado
    ESCREVA max
FIM</code></pre>
</div>
</figure>
</div>
<p>O pseudocódigo, como o apresentado na <a href="#lst-algoritmo1" class="quarto-xref">Listing&nbsp;<span>4.1</span></a>, deve ser independente de linguagem, o que significa que pode ser convertido para qualquer linguagem de programação. Foca na lógica do algoritmo, não na sintaxe de uma linguagem de programação específica, mas permite a inclusão de estruturas de controle como loops, condicionais e variáveis, facilitando a compreensão dos conceitos fundamentais de programação. Necessariamente precisa ser fácil de ler e entender.</p>
<p>Além da vantagem clara de interpretação, sendo baseado em texto, o pseudocódigo é inerentemente mais fácil e rápido de escrever e modificar <span class="citation" data-cites="knowledgeacademy2025flowchart">(<a href="referencias.html#ref-knowledgeacademy2025flowchart" role="doc-biblioref">51</a>)</span>. Apesar da forte evidência a favor dos fluxogramas em tarefas de compreensão, alguns estudos não encontraram diferenças estatisticamente significativas no desempenho dos alunos, sugerindo que a eficácia de cada ferramenta pode ser dependente da tarefa específica <span class="citation" data-cites="andrzejewska2022structured">(<a href="referencias.html#ref-andrzejewska2022structured" role="doc-biblioref">42</a>)</span>.</p>
<p>O <em>framework</em> proposto por este estudo para a Metodologia <strong>DAAD</strong> propõe o uso do pseudocódigo como uma ferramenta de abstração complementar aos fluxogramas. O pseudocódigo pode ser usado para descrever algoritmos mais complexos, nos quais a clareza visual dos fluxogramas pode não ser suficiente. A combinação de fluxogramas e pseudocódigo permite que os alunos desenvolvam uma compreensão mais profunda dos conceitos de programação, aproveitando as vantagens de ambas as ferramentas. O objetivo é usar o pseudocódigo para fazer a ponte para o pensamento textual; e, finalmente, introduzir uma linguagem de programação completa.</p>
</section>
<section id="tabelas-de-rastreio" class="level3" data-number="4.4.3">
<h3 data-number="4.4.3" class="anchored" data-anchor-id="tabelas-de-rastreio"><span class="header-section-number">4.4.3</span> Tabelas de Rastreio</h3>
<p>As Tabelas de Rastreio são estruturas que permitem aos alunos registrar e acompanhar os valores das variáveis e os estados do programa durante a execução, facilitando a identificação de erros. Também são conhecidas como tabelas de rastreio, tabelas de execução, tabelas de acompanhamento ou teste de bancada. Elas são uma ferramenta valiosa para o ensino do <strong>Raciocínio Algorítmico</strong> e da <strong>Depuração</strong>, pois permitem que os alunos visualizem o fluxo de controle e as mudanças de estado do programa de forma sistemática. Estas tabelas funcionam como uma simulação manual da execução de um programa, permitindo acompanhar o estado das variáveis e o fluxo de controle passo a passo.</p>
<p>Basicamente, uma tabela de rastreio é composta por:</p>
<ul>
<li><strong>Colunas para variáveis</strong>: cada variável do programa tem sua própria coluna;</li>
<li><strong>Coluna de linha/instrução</strong>: indica qual linha do código está sendo executada;</li>
<li><strong>Colunas de saída</strong>: registram valores impressos ou exibidos;</li>
<li><strong>Linhas</strong>: cada linha representa um momento na execução.</li>
</ul>
<p>O processo de construção de uma tabela de rastreio envolve a execução do código linha por linha, registrando as mudanças nas variáveis e quaisquer saídas produzidas. Isso permite que os alunos vejam como o estado do programa evolui ao longo do tempo e identifiquem em que pontos ocorrem erros ou comportamentos inesperados. Para entender tabelas de rastreio, considere que o fluxograma da <a href="#fig-fluxograma2" class="quarto-xref">Figure&nbsp;<span>4.5</span></a> representado pelo pseudocódigo da <a href="#lst-algoritmo1" class="quarto-xref">Listing&nbsp;<span>4.1</span></a> pode ser executado por um programa com os dados de entrada <code>a = 15</code>, <code>b = 8</code>. Neste caso, a tabela de rastreio seria:</p>
<div id="tbl-rastreio1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-rastreio1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.2: Tabela de rastreio de exemplo para o pseudocódigo da <a href="#lst-algoritmo1" class="quarto-xref">Listing&nbsp;<span>4.1</span></a>.
</figcaption>
<div aria-describedby="tbl-rastreio1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 14%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 14%">
<col style="width: 10%">
<col style="width: 14%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Linha</th>
<th>a</th>
<th>b</th>
<th>a &gt; b</th>
<th>max</th>
<th>Saída</th>
<th>Observações</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Início do algoritmo</td>
</tr>
<tr class="even">
<td>2</td>
<td>15</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Leitura do primeiro valor</td>
</tr>
<tr class="odd">
<td>3</td>
<td>15</td>
<td>8</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Leitura do segundo valor</td>
</tr>
<tr class="even">
<td>4</td>
<td>15</td>
<td>8</td>
<td>True</td>
<td>-</td>
<td>-</td>
<td>Avaliação da condição: 15 &gt; 8</td>
</tr>
<tr class="odd">
<td>5</td>
<td>15</td>
<td>8</td>
<td>True</td>
<td>15</td>
<td>-</td>
<td>Executa ramo verdadeiro</td>
</tr>
<tr class="even">
<td>9</td>
<td>15</td>
<td>8</td>
<td>True</td>
<td>15</td>
<td>15</td>
<td>Exibe o resultado</td>
</tr>
<tr class="odd">
<td>10</td>
<td>15</td>
<td>8</td>
<td>True</td>
<td>15</td>
<td>15</td>
<td>Fim do algoritmo</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>A pesquisa do grupo de trabalho <em><strong>I</strong>nnovation and <strong>T</strong>echnology in <strong>C</strong>omputer <strong>S</strong>cience <strong>E</strong>ducation</em>, <strong>ITiCSE</strong><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, forneceu evidências interessantes sobre visualização e engajamento. O estudo marco <em>Exploring the Role of Visualization and Engagement in Computer Science Education</em><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> estabeleceu que tabelas de rastreio requerem engajamento ativo do aluno para serem educacionalmente valiosas, com resultados de aprendizado correlacionados diretamente aos níveis de engajamento <span class="citation" data-cites="Kelleher2007">(<a href="referencias.html#ref-Kelleher2007" role="doc-biblioref">52</a>)</span>. Além disso, O artigo IEEE de 2023 <em>Generating Trace Table for Java Programs</em><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> estendeu conceitos de tabela de rastreio usando implementações baseadas em Excel projetadas em torno de diagramas de sequência UML, facilitando a compreensão de comportamento dinâmico incluindo polimorfismo e ligação dinâmica <span class="citation" data-cites="Men2022">(<a href="referencias.html#ref-Men2022" role="doc-biblioref">53</a>)</span>. As duas pesquisas parecem destacar a eficiência de tabelas de rastreio como ferramenta de ensino, notadamente para <strong>Depuração</strong> e <strong>Abstração</strong>. Finalmente os cursos de introdução de Stanford combinam tabelas de rastreio com abordagens sistemáticas de depuração<span class="citation" data-cites="stanford_cs106a_syllabus">(<a href="referencias.html#ref-stanford_cs106b_syllabus" role="doc-biblioref">54</a>)</span>. A metodologia de Stanford advoga por rastreamento estratégico em vez de exaustivo, reconhecendo que rastreamentos completos de programa são frequentemente impraticáveis para sistemas complexos.</p>
<p>Essas ferramentas são essenciais para apoiar a Metodologia <strong>DAAD</strong>, pois proporcionam representações claras e acessíveis dos conceitos envolvidos, facilitando a compreensão e a aplicação das fases do processo de resolução de problemas e permitem a interação <em>unplugged</em> com os conceitos de <strong>Raciocínio Algorítmico</strong>. A combinação de fluxogramas, pseudocódigo e tabelas de rastreio oferece uma abordagem abrangente para o ensino do <strong>Pensamento Computacional</strong>, permitindo que os alunos desenvolvam habilidades essenciais de resolução de problemas e programação adequadas às suas capacidades individuais.</p>


<div id="refs" class="references csl-bib-body" data-entry-spacing="1" role="list" style="display: none">
<div id="ref-Curzon2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">CURZON, P. et al. Computational thinking. In: FINCHER, S. A.; ROBINS, A. V. (Eds.). <strong>The cambridge handbook of computing education research</strong>. Cambridge: Cambridge University Press, 2019. p. 513–546. </div>
</div>
<div id="ref-Wing2006" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">WING, J. M. <a href="https://doi.org/10.1145/1118178.1118215">Computational thinking</a>. <strong>Communications of the ACM</strong>, v. 49, n. 3, p. 33–35, Mar. 2006. </div>
</div>
<div id="ref-Kong2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">KONG, S. et al. <strong>Pensamento computacional na educação: Perspectivas internacionais</strong>. São Paulo: Penso, 2020. </div>
</div>
<div id="ref-Lehmann2023" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">LEHMANN, T. H. Using algorithmic thinking to design algorithms: The case of critical path analysis. <strong>The Journal of Mathematical Behavior</strong>, v. 71, p. 101079, 2023. </div>
</div>
<div id="ref-Hijn-Neira2024" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">HIJÓN-NEIRA, R. et al. <a href="https://doi.org/10.20944/preprints202405.1203.v1">Computational thinking measurement of CS university students in the AI era</a>. <strong>Preprints.org</strong>, May 2024. </div>
</div>
<div id="ref-Huang2020ComputationalThinking" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">HUANG, R. et al. Computational thinking and the new curriculum standards of information technology for senior high schools in china. In: ABELSON, H.; KONG, S.-C. (Eds.). <strong>Computational thinking curricula in k–12: International implementations</strong>. Cambridge, Massachusetts; London, England: The MIT Press, 2020. </div>
</div>
<div id="ref-Li2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">LI, Y. et al. Computational thinking is more about thinking than computing. <strong>Journal for STEM Education Research</strong>, v. 3, n. 1, p. 1–18, 2020. </div>
</div>
<div id="ref-TedreDenning2016" class="csl-entry" role="listitem">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">TEDRE, M.; DENNING, P. J. <strong>The long quest for computational thinking</strong>. Proceedings of the 16th koli calling conference on computing education research. <strong>Anais</strong>...Koli, Finland: Nov. 2016. </div>
</div>
<div id="ref-YorkCT2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">UNIVERSITY OF YORK. <strong>Computational thinking: Foundations and fundamentals</strong>. YorkDepartment of Computer Science, 2020. </div>
</div>
<div id="ref-Sentance2017" class="csl-entry" role="listitem">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">SENTANCE, S. et al. <strong>Creating cool stuff: Pupils’ experience of the BBC micro:bit</strong>. Proceedings of the ACM SIGCSE technical symposium. <strong>Anais</strong>...Seattle: ACM, 2017. </div>
</div>
<div id="ref-Brackmann2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">BRACKMANN, C. P. et al. Unplugged versus plugged-in: Examining basic programming achievement and computational thinking of 6th-grade students. <strong>Journal of Computer Science Education</strong>, 2022. </div>
</div>
<div id="ref-Kurkovsky2013" class="csl-entry" role="listitem">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">KURKOVSKY, S. Mobile computing and robotics in one course: Teaching design patterns. <strong>Journal of Computing Sciences in Colleges</strong>, v. 28, n. 6, p. 67–73, 2013. </div>
</div>
<div id="ref-barak2023chapter15" class="csl-entry" role="listitem">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">BARAK, B. <strong>Chapter 15: NP, NP completeness, and the cook-levin theorem</strong>. <a href="https://introtcs.org/public/ch15_nptime.html " class="uri">https://introtcs.org/public/ch15_nptime.html</a>, 2023. </div>
</div>
<div id="ref-Murray1994" class="csl-entry" role="listitem">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">MURRAY, R. M.; LI, Z.; SASTRY, S. S. <strong>A mathematical introduction to robotic manipulation</strong>. [s.l.] CRC Press, 1994. </div>
</div>
<div id="ref-Geron2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">GÉRON, A. <strong>Hands-on machine learning with scikit-learn, keras &amp; TensorFlow: Concepts, tools, and techniques to build intelligent systems</strong>. 2nd. ed. [s.l.] O’Reilly Media, Inc., 2019. </div>
</div>
<div id="ref-Herlihy2012" class="csl-entry" role="listitem">
<div class="csl-left-margin">[16] </div><div class="csl-right-inline">HERLIHY, M.; SHAVIT, N. <strong>The art of multiprocessor programming</strong>. Revised Reprint ed. Waltham, MA, USA: Morgan Kaufmann Publishers Inc., 2012. </div>
</div>
<div id="ref-Tanenbaum2015" class="csl-entry" role="listitem">
<div class="csl-left-margin">[17] </div><div class="csl-right-inline">TANENBAUM, A. S.; BOS, H. <strong>Modern operating systems</strong>. 4th. ed. USA: Prentice Hall Press, 2015. </div>
</div>
<div id="ref-Netflix2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[18] </div><div class="csl-right-inline">NETFLIX, INC. <strong>Chaos engineering</strong>., 2021. Disponível em: &lt;<a href="https://netflix.github.io/chaosmonkey/">https://netflix.github.io/chaosmonkey/</a>&gt;. Acesso em: 10 jul. 2025</div>
</div>
<div id="ref-Smith2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[19] </div><div class="csl-right-inline">SMITH, J. A. C. B.; GROVER, S.; SMITH, A. L. <strong>Measuring computational thinking and computer science outcomes: A resource for CS for all researchers</strong>. [s.l.] U.S. Department of Education, Mar. 2021. Disponível em: &lt;<a href="https://www.ed.gov/sites/ed/files/2021/03/CSCTOutcomes_508.pdf">https://www.ed.gov/sites/ed/files/2021/03/CSCTOutcomes_508.pdf</a>&gt;.</div>
</div>
<div id="ref-MITCT2017" class="csl-entry" role="listitem">
<div class="csl-left-margin">[20] </div><div class="csl-right-inline">MASSACHUSETTS INSTITUTE OF TECHNOLOGY. <strong>A computational thinking requirement for MIT undergraduates: Report of the working group on computational thinking</strong>., 2017. Disponível em: &lt;<a href="https://facultygovernance.mit.edu/sites/default/files/reports/2017-01_computational_thinking_requirement_FINAL_CLEAN.pdf">https://facultygovernance.mit.edu/sites/default/files/reports/2017-01_computational_thinking_requirement_FINAL_CLEAN.pdf</a>&gt;. Acesso em: 11 jul. 2025</div>
</div>
<div id="ref-NYSCI" class="csl-entry" role="listitem">
<div class="csl-left-margin">[21] </div><div class="csl-right-inline">NEW YORK HALL OF SCIENCE. <strong>Computational thinking school strategy guide</strong>., [s.d.][s.d.]. Disponível em: &lt;<a href="https://nysci.org/pdf/NYSCI-Computational-Thinking-School-Strategy-Guide-04-09-2024.pdf">https://nysci.org/pdf/NYSCI-Computational-Thinking-School-Strategy-Guide-04-09-2024.pdf</a>&gt;. Acesso em: 6 jul. 2025</div>
</div>
<div id="ref-Saidin2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[22] </div><div class="csl-right-inline">SAIDIN, N. D. et al. <a href="https://doi.org/10.18178/ijiet.2021.11.5.1519">Benefits and challenges of applying computational thinking in education</a>. <strong>International Journal of Information and Education Technology</strong>, v. 11, n. 5, p. 248–254, 2021. </div>
</div>
<div id="ref-Kong2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">[23] </div><div class="csl-right-inline">KONG, S.-C. <a href="https://doi.org/10.1007/978-981-13-6528-7_9">Learning composite and prime numbers through developing an app: An example of computational thinking development through primary mathematics learning</a>. In: KONG, S.-C.; ABELSON, H. (Eds.). <strong>Computational thinking education</strong>. Singapore: Springer, 2019. p. 155–177. </div>
</div>
<div id="ref-Miller1956" class="csl-entry" role="listitem">
<div class="csl-left-margin">[24] </div><div class="csl-right-inline">MILLER, G. A. <a href="https://labs.la.utexas.edu/gilden/files/2016/04/MagicNumberSeven-Miller1956.pdf">The magical number seven, plus or minus two: Some limits on our capacity for processing information</a>. <strong>Psychological Review</strong>, v. 63, n. 2, p. 81–97, 1956. </div>
</div>
<div id="ref-Frigg2002" class="csl-entry" role="listitem">
<div class="csl-left-margin">[25] </div><div class="csl-right-inline">FRIGG, R. <strong>Models and representation: Why structures are not enough</strong>. London: London School of Economics, 2002. Disponível em: &lt;<a href="https://romanfrigg.org/wp-content/uploads/writings/Models_and_Representation.pdf">https://romanfrigg.org/wp-content/uploads/writings/Models_and_Representation.pdf</a>&gt;.</div>
</div>
<div id="ref-DenningTedre2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">[26] </div><div class="csl-right-inline">DENNING, P. J.; TEDRE, M. <strong>Computational thinking</strong>. Cambridge, MA: The MIT Press, 2019. </div>
</div>
<div id="ref-muggleton1991inductive" class="csl-entry" role="listitem">
<div class="csl-left-margin">[27] </div><div class="csl-right-inline">MUGGLETON, S. Inductive logic programming: Theory and methods. <strong>Journal of Logic Programming</strong>, v. 19, n. 20, p. 629–679, 1991. </div>
</div>
<div id="ref-Araujo2016" class="csl-entry" role="listitem">
<div class="csl-left-margin">[28] </div><div class="csl-right-inline">ARA’UJO, A. L. S. DE O.; ANDRADE, W. L. DE; GUERRERO, D. D. S. <strong><a href="https://doi.org/10.5753/cbie.sbie.2016.714"><span class="nocase">Um mapeamento sistem<span>’<span class="nocase">a</span></span>tico sobre a avalia<span class="nocase">ç</span><span>&nbsp;<span class="nocase">a</span></span>o do pensamento computacional no Brasil</span></a></strong>. Anais do v congresso brasileiro de inform<span>’<span class="nocase">a</span></span>tica na educa<span>ç</span><span>&nbsp;<span class="nocase">a</span></span>o (CBIE). <strong>Anais</strong>...2016. </div>
</div>
<div id="ref-GroverPea2013" class="csl-entry" role="listitem">
<div class="csl-left-margin">[29] </div><div class="csl-right-inline">GROVER, S.; PEA, R. <a href="https://doi.org/10.3102/0013189X12463051">Computational thinking in k–12: A review of the state of the field</a>. <strong>Educational Researcher</strong>, v. 42, n. 1, p. 38–43, 2013. </div>
</div>
<div id="ref-weintrop2015unplugged" class="csl-entry" role="listitem">
<div class="csl-left-margin">[30] </div><div class="csl-right-inline">WEINTROP, D.; WILENSKY, U. <strong><a href="https://doi.org/10.1145/2676723.2677278">Using unplugged activities in adult programming education</a></strong>. Proceedings of the 46th ACM technical symposium on computer science education (SIGCSE ’15). <strong>Anais</strong>...New York, NY, USA: ACM, 2015. </div>
</div>
<div id="ref-Kim2021ComputationalThinking" class="csl-entry" role="listitem">
<div class="csl-left-margin">[31] </div><div class="csl-right-inline">KIM, Y. <a href="https://edtechbooks.org/k12handbook/computational_thinking">Computational thinking</a>. In: <strong>Educational technology: An online handbook for pre-k-12</strong>. [s.l.] EdTech Books, 2021. </div>
</div>
<div id="ref-Gundogdu2023" class="csl-entry" role="listitem">
<div class="csl-left-margin">[32] </div><div class="csl-right-inline">GÜNDOĞDU, F. et al. Exploring mathematical reasoning skills. <strong>ScienceDirect</strong>, 2023. </div>
</div>
<div id="ref-Lehmann2024" class="csl-entry" role="listitem">
<div class="csl-left-margin">[33] </div><div class="csl-right-inline">LEHMANN, T. H. <a href="https://link.springer.com/article/10.1007/s13394-023-00462-0">How current perspectives on algorithmic thinking can be applied to students’ engagement in algorithmatizing tasks</a>. <strong>Mathematics Education Research Journal</strong>, v. 36, n. 3, p. 609–643, 2024. </div>
</div>
<div id="ref-AlcantaraFluxograma" class="csl-entry" role="listitem">
<div class="csl-left-margin">[34] </div><div class="csl-right-inline">ALCANTARA, F. C. DE. <strong>Fluxograma interativo</strong>. <a href="https://frankalcantara.com/fluxograma/index.html" class="uri">https://frankalcantara.com/fluxograma/index.html</a>, [s.d.]. </div>
</div>
<div id="ref-Brennan2012" class="csl-entry" role="listitem">
<div class="csl-left-margin">[35] </div><div class="csl-right-inline">BRENNAN, K.; RESNICK, M. <strong><span class="nocase">New frameworks for studying and assessing the development of computational thinking</span></strong>. Proceedings of the 2012 annual meeting of the american educational research association. <strong>Anais</strong>...Vancouver, Canada: 2012. </div>
</div>
<div id="ref-Pritchard2018" class="csl-entry" role="listitem">
<div class="csl-left-margin">[36] </div><div class="csl-right-inline">PRITCHARD, T. A. <strong><a href="https://pure.southwales.ac.uk/en/studentTheses/using-flowcharts-code-and-animation-for-improved-comprehension-an">Using flowcharts, code and animation for improved comprehension and ability in novice programming</a></strong>. PhD thesis—[s.l.] University of South Wales, 2018.</div>
</div>
<div id="ref-Ali2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[37] </div><div class="csl-right-inline">ALI, F. <strong><a href="https://www.tu-chemnitz.de/informatik//ST/lectures/Masters%20Thesis%20Pdfs/2022%20Master%20-%20Effect%20of%20Flowcharts%20on%20Code%20Comprehension%20of%20Novice%20Programmers.pdf">Effect of flowcharts on code comprehension of novice programmers</a></strong>. Master’s thesis—[s.l.] Chemnitz University of Technology, 2022.</div>
</div>
<div id="ref-SBC2018BNCC" class="csl-entry" role="listitem">
<div class="csl-left-margin">[38] </div><div class="csl-right-inline">SOCIEDADE BRASILEIRA DE COMPUTAÇÃO. <strong><span class="nocase">Nota Técnica da Sociedade Brasileira de Computação sobre a BNCC-EF e a BNCC-EM</span></strong>. Porto Alegre, RS, Brasil: <span>Sociedade Brasileira de Computação (SBC)</span>; <a href="https://www.sbc.org.br/wp-content/uploads/2024/07/Nota-t-cnica-sobre-a-BNCC-Ensino-m-dio-e-fundamental-2018.pdf" class="uri">https://www.sbc.org.br/wp-content/uploads/2024/07/Nota-t-cnica-sobre-a-BNCC-Ensino-m-dio-e-fundamental-2018.pdf</a>, 2018. </div>
</div>
<div id="ref-leinonen2024how" class="csl-entry" role="listitem">
<div class="csl-left-margin">[39] </div><div class="csl-right-inline">LEINONEN, J.; HELLAS, A.; IHANTOLA, P. <strong>How can <span>“vibe-coding”</span> transform programming education?</strong> Communications of the ACM, May 2024. Disponível em: &lt;<a href="https://cacm.acm.org/blogcacm/how-can-vibe-coding-transform-programming-education/">https://cacm.acm.org/blogcacm/how-can-vibe-coding-transform-programming-education/</a>&gt;</div>
</div>
<div id="ref-iso1985" class="csl-entry" role="listitem">
<div class="csl-left-margin">[40] </div><div class="csl-right-inline">INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. <strong>Information processing – documentation symbols and conventions for data, program and system flowcharts, program network charts and system resources charts</strong>. [s.l.] International Organization for Standardization, 1985. Disponível em: &lt;<a href="https://cdn.standards.iteh.ai/samples/11955/1b7dd254a2a54fd7a89d616dc0570e18/ISO-5807-1985.pdf">https://cdn.standards.iteh.ai/samples/11955/1b7dd254a2a54fd7a89d616dc0570e18/ISO-5807-1985.pdf</a>&gt;.</div>
</div>
<div id="ref-iso5807:1985" class="csl-entry" role="listitem">
<div class="csl-left-margin">[41] </div><div class="csl-right-inline">INTERNATIONAL ORGANIZATION FOR STANDARDIZATION. <strong>Information processing – documentation symbols and conventions for data, program and system flowcharts, program network charts and system resources charts</strong>. Geneva, CHInternational Organization for Standardization, 1985. </div>
</div>
<div id="ref-andrzejewska2022structured" class="csl-entry" role="listitem">
<div class="csl-left-margin">[42] </div><div class="csl-right-inline">ANDRZEJEWSKA, M.; STOLIŃSKA, A. <a href="https://doi.org/10.1109/ACCESS.2022.3230981">Do structured flowcharts outperform pseudocode? Evidence from eye movements</a>. <strong>IEEE Access</strong>, v. 10, p. 132965–132975, 2022. </div>
</div>
<div id="ref-scanlan1989structured" class="csl-entry" role="listitem">
<div class="csl-left-margin">[43] </div><div class="csl-right-inline">SCANLAN, D. A. <a href="https://doi.org/10.1109/52.35587">Structured flowcharts outperform pseudocode: An experimental comparison</a>. <strong>IEEE Software</strong>, v. 6, n. 5, p. 28–36, 1989. </div>
</div>
<div id="ref-threekunprapa2020patterns" class="csl-entry" role="listitem">
<div class="csl-left-margin">[44] </div><div class="csl-right-inline">THREEKUNPRAPA, A.; YASRI, P. <a href="https://doi.org/10.12973/eu-jer.9.3.1025">Patterns of computational thinking development while solving unplugged coding activities coupled with the 3S approach for self-directed learning</a>. <strong>European Journal of Educational Research</strong>, v. 9, n. 3, p. 1025–1045, 2020. </div>
</div>
<div id="ref-siozou2008effect" class="csl-entry" role="listitem">
<div class="csl-left-margin">[45] </div><div class="csl-right-inline">SIOZOU, S.; TSELIOS, N.; KOMIS, V. <strong>Effect of algorithms’ multiple representations in the context of programming education</strong>. Proceedings of the 4th pan-hellenic conference <span>“informatics and education.”</span> <strong>Anais</strong>...Patras, Greece: 2008. Disponível em: &lt;<a href="https://www.researchgate.net/publication/220373268_Effect_of_algorithms'_multiple_representations_in_the_context_of_programming_education">https://www.researchgate.net/publication/220373268_Effect_of_algorithms'_multiple_representations_in_the_context_of_programming_education</a>&gt;</div>
</div>
<div id="ref-harvard_cs50_intro" class="csl-entry" role="listitem">
<div class="csl-left-margin">[46] </div><div class="csl-right-inline">HARVARD UNIVERSITY. <strong>CS50: Introduction to computer science</strong>., 2025. Disponível em: &lt;<a href="https://pll.harvard.edu/course/cs50-introduction-computer-science">https://pll.harvard.edu/course/cs50-introduction-computer-science</a>&gt;</div>
</div>
<div id="ref-stanford_cs106a_syllabus" class="csl-entry" role="listitem">
<div class="csl-left-margin">[47] </div><div class="csl-right-inline">STANFORD UNIVERSITY. <strong>CS106A syllabus</strong>., 2025. Disponível em: &lt;<a href="https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1258/syllabus">https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1258/syllabus</a>&gt;</div>
</div>
<div id="ref-CambridgeAlgorithms" class="csl-entry" role="listitem">
<div class="csl-left-margin">[48] </div><div class="csl-right-inline">UNIVERSITY OF CAMBRIDGE. <strong>Department of computer science and technology. Algorithms 1</strong>., [s.d.]a[s.d.]a. Disponível em: &lt;<a href="https://www.cl.cam.ac.uk/teaching/2324/Algorithm1/">https://www.cl.cam.ac.uk/teaching/2324/Algorithm1/</a>&gt;. Acesso em: 12 jul. 2025</div>
</div>
<div id="ref-PythonDocs" class="csl-entry" role="listitem">
<div class="csl-left-margin">[49] </div><div class="csl-right-inline">PYTHON SOFTWARE FOUNDATION. <strong><span>The Python Language Reference</span></strong>. Disponível em: &lt;<a href="https://docs.python.org/3/reference/index.html">https://docs.python.org/3/reference/index.html</a>&gt;. Acesso em: 13 jul. 2025. </div>
</div>
<div id="ref-ScratchFoundation" class="csl-entry" role="listitem">
<div class="csl-left-margin">[50] </div><div class="csl-right-inline">SCRATCH FOUNDATION. <strong>Scratch</strong>., [s.d.][s.d.]. Disponível em: &lt;<a href="https://scratch.mit.edu/">https://scratch.mit.edu/</a>&gt;. Acesso em: 7 jul. 2025</div>
</div>
<div id="ref-knowledgeacademy2025flowchart" class="csl-entry" role="listitem">
<div class="csl-left-margin">[51] </div><div class="csl-right-inline">THE KNOWLEDGE ACADEMY. <strong>Differences between flowchart and pseudocode: A detailed comparison</strong>., 2025. Disponível em: &lt;<a href="https://www.theknowledgeacademy.com/blog/flowchart-vs-pseudocode/">https://www.theknowledgeacademy.com/blog/flowchart-vs-pseudocode/</a>&gt;</div>
</div>
<div id="ref-Kelleher2007" class="csl-entry" role="listitem">
<div class="csl-left-margin">[52] </div><div class="csl-right-inline">KELLEHER, C. D.; PAUSCH, R. <a href="https://doi.org/10.1145/1268784.1268848">Exploring the role of visualization and engagement in computer science education</a>. <strong>ACM SIGCSE Bulletin</strong>, v. 39, n. 3, p. 213–217, 2007. </div>
</div>
<div id="ref-Men2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[53] </div><div class="csl-right-inline">MEN, N. et al. <strong><a href="https://doi.org/10.1109/VTC2022-Spring54318.2022.9894565">Hybrid beamforming for RIS-aided multiuser millimeter wave systems</a></strong>. 2022 IEEE 95th vehicular technology conference: (VTC2022-spring). <strong>Anais</strong>...2022. </div>
</div>
<div id="ref-stanford_cs106b_syllabus" class="csl-entry" role="listitem">
<div class="csl-left-margin">[54] </div><div class="csl-right-inline">STANFORD UNIVERSITY. <strong>CS106B syllabus</strong>., 2025. Disponível em: &lt;<a href="https://web.stanford.edu/class/cs106b/syllabus">https://web.stanford.edu/class/cs106b/syllabus</a>&gt;</div>
</div>
</div>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Problema NP-Difícil: Classe de problemas computacionais considerados altamente complexos, cuja solução exata em tempo razoável é improvável. Resolver tais problemas frequentemente requer algoritmos heurísticos ou aproximados.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>em tradução livre, Inovação e Tecnologia na Educação em Ciência da Computação, ITiCSE é um grupo de trabalho da ACM SIGCSE, que visa melhorar a educação em ciência da computação por meio de visualização e engajamento.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>em tradução livre, Explorando o Papel da Visualização e do Engajamento na Educação em Ciência da Computação.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>em tradução livre, Gerando Tabela de Rastreio para Programas Java.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./inte.html" class="pagination-link" aria-label="Analisando Currículos Internacionais">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Analisando Currículos Internacionais</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./desen.html" class="pagination-link" aria-label="Projeto de Disciplina de Raciocínio Algorítmico">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Projeto de Disciplina de Raciocínio Algorítmico</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/raciocionio/edit/main/def.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/raciocionio/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>