<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 7&nbsp; Formas Normais Organizando o Pensamento Lógico</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06-clausulas-de-horn-e-prolog.html" rel="next">
<link href="./04-logica-predicativa-e-quantificadores.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução ao Paradigma da Programação Lógica</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-introducao-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introdução Prática ao Prolog com Swish</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Proposicional</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">A Arte da Prova e Análise de Argumentos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Cláusulas de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Raciocínio Algorítmico: Criando Mundos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Desafios, Problemas e Mistérios</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Solução dos Exercícios</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-Sol-Proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Lógica Proposicional </span></span></a><a href="02-fundamentos-logica-proposicional.html" class="quarto-xref"><span>Chapter 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-Sol-Predicativa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Lógica Predicativa </span></span></a><a href="04-logica-predicativa-e-quantificadores.html" class="quarto-xref"><span>Chapter 6</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-Sol-Normais.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Formas Normais </span></span></a><a href="#sec-formas-normais" class="quarto-xref"><span>Chapter 7</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#formas-normais-lógica-proposicional" id="toc-formas-normais-lógica-proposicional" class="nav-link active" data-scroll-target="#formas-normais-lógica-proposicional"><span class="header-section-number">7.1</span> Formas Normais, Lógica Proposicional</a>
  <ul class="collapse">
  <li><a href="#forma-normal-negativa" id="toc-forma-normal-negativa" class="nav-link" data-scroll-target="#forma-normal-negativa"><span class="header-section-number">7.1.1</span> Forma Normal Negativa</a></li>
  <li><a href="#forma-normal-disjuntiva" id="toc-forma-normal-disjuntiva" class="nav-link" data-scroll-target="#forma-normal-disjuntiva"><span class="header-section-number">7.1.2</span> Forma Normal Disjuntiva</a></li>
  <li><a href="#forma-normal-conjuntiva" id="toc-forma-normal-conjuntiva" class="nav-link" data-scroll-target="#forma-normal-conjuntiva"><span class="header-section-number">7.1.3</span> Forma Normal Conjuntiva</a></li>
  <li><a href="#usando-a-tabela-verdade-para-gerar-formas-normais" id="toc-usando-a-tabela-verdade-para-gerar-formas-normais" class="nav-link" data-scroll-target="#usando-a-tabela-verdade-para-gerar-formas-normais"><span class="header-section-number">7.1.4</span> Usando a Tabela-Verdade para Gerar Formas Normais</a></li>
  </ul></li>
  <li><a href="#formas-normais-lógica-predicativa-e-quantificadores" id="toc-formas-normais-lógica-predicativa-e-quantificadores" class="nav-link" data-scroll-target="#formas-normais-lógica-predicativa-e-quantificadores"><span class="header-section-number">7.2</span> Formas Normais, Lógica Predicativa e Quantificadores</a>
  <ul class="collapse">
  <li><a href="#forma-normal-prenex" id="toc-forma-normal-prenex" class="nav-link" data-scroll-target="#forma-normal-prenex"><span class="header-section-number">7.2.1</span> Forma Normal Prenex</a></li>
  <li><a href="#skolemização" id="toc-skolemização" class="nav-link" data-scroll-target="#skolemização"><span class="header-section-number">7.2.2</span> Skolemização</a></li>
  <li><a href="#expansão-do-vocabulário-e-conexão-com-programação-lógica" id="toc-expansão-do-vocabulário-e-conexão-com-programação-lógica" class="nav-link" data-scroll-target="#expansão-do-vocabulário-e-conexão-com-programação-lógica"><span class="header-section-number">7.2.3</span> Expansão do Vocabulário e Conexão com Programação Lógica</a></li>
  <li><a href="#sec-exercicios-skolemizacao" id="toc-sec-exercicios-skolemizacao" class="nav-link" data-scroll-target="#sec-exercicios-skolemizacao"><span class="header-section-number">7.2.4</span> Exercícios de Skolemização</a></li>
  </ul></li>
  <li><a href="#formas-normais-prenex" id="toc-formas-normais-prenex" class="nav-link" data-scroll-target="#formas-normais-prenex"><span class="header-section-number">7.3</span> Formas Normais Prenex</a>
  <ul class="collapse">
  <li><a href="#algoritmo-para-conversão-na-forma-normal-prenex" id="toc-algoritmo-para-conversão-na-forma-normal-prenex" class="nav-link" data-scroll-target="#algoritmo-para-conversão-na-forma-normal-prenex"><span class="header-section-number">7.3.1</span> Algoritmo para Conversão na Forma Normal Prenex</a></li>
  <li><a href="#forma-normal-negativa-prenex" id="toc-forma-normal-negativa-prenex" class="nav-link" data-scroll-target="#forma-normal-negativa-prenex"><span class="header-section-number">7.3.2</span> Forma Normal Negativa Prenex</a></li>
  <li><a href="#algoritmo-para-forma-normal-disjuntiva-prenex-fnd-prenex" id="toc-algoritmo-para-forma-normal-disjuntiva-prenex-fnd-prenex" class="nav-link" data-scroll-target="#algoritmo-para-forma-normal-disjuntiva-prenex-fnd-prenex"><span class="header-section-number">7.3.3</span> Algoritmo para Forma Normal Disjuntiva Prenex (FND Prenex)</a></li>
  <li><a href="#algoritmo-para-forma-normal-conjuntiva-prenex-fnc-prenex" id="toc-algoritmo-para-forma-normal-conjuntiva-prenex-fnc-prenex" class="nav-link" data-scroll-target="#algoritmo-para-forma-normal-conjuntiva-prenex-fnc-prenex"><span class="header-section-number">7.3.4</span> Algoritmo para Forma Normal Conjuntiva Prenex (FNC Prenex)</a></li>
  <li><a href="#sec-exercicios-formas-normais-prenex" id="toc-sec-exercicios-formas-normais-prenex" class="nav-link" data-scroll-target="#sec-exercicios-formas-normais-prenex"><span class="header-section-number">7.3.5</span> Exercícios Formas Normais Prenex</a></li>
  </ul></li>
  <li><a href="#sec-predicativa-conexao-prolog" id="toc-sec-predicativa-conexao-prolog" class="nav-link" data-scroll-target="#sec-predicativa-conexao-prolog"><span class="header-section-number">7.4</span> Exercícios de Conexão com Prolog</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/05-formas-normais-e-skolemizacao.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-formas-normais" class="quarto-section-identifier"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\05-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>Neste porto da nossa jornada a aventureira leitora verá que as formas normais são como as diferentes rotas de navegação padronizadas que organizam o tráfego marítimo em um porto movimentado. Assim como um capitão de porto pode reorganizar águas caóticas em canais bem definidos com rotas padronizadas, as formas normais reorganizam fórmulas lógicas complexas em estruturas elegantes e uniformes.</p>
<p>A criativa leitora pode se imaginar tentando navegar em águas desconhecidas sem cartas náuticas, onde as correntes se cruzam caoticamente, sem padrão ou lógica. Seria como tentar compreender uma fórmula lógica sem forma normal, possível, mas desnecessariamente árduo. As formas normais fornecem um mapa claro e consistente para navegar pelas complexidades da lógica, permitindo que a leitora veja o panorama completo de maneira organizada.</p>
<p>Consideremos, por exemplo, a tarefa de comparar duas proposições para determinar se são equivalentes. Sem uma forma padronizada de representar proposições, essa tarefa pode se tornar complexa e demorada. No entanto, ao utilizar as formas normais, cada proposição é expressa de uma forma padrão, tornando a comparação direta e simples. Além disso, as formas normais também desempenham um papel importante na simplificação de proposições. Ao expressar uma proposição em sua forma normal, é mais fácil identificar oportunidades de simplificação, removendo redundâncias ou simplificando a estrutura lógica. As formas normais não são apenas uma ferramenta para lidar com a complexidade da <strong>Lógica Proposicional</strong>, mas também uma metodologia que facilita a compreensão e manipulação de proposições lógicas.</p>
<section id="formas-normais-lógica-proposicional" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="formas-normais-lógica-proposicional"><span class="header-section-number">7.1</span> Formas Normais, Lógica Proposicional</h2>
<p>Existem várias formas normais na <strong>Lógica Proposicional</strong>, cada uma com suas próprias regras e aplicações. A seguir, a esforçada leitora encontrará uma descrição resumida das formas normais, destacando algumas das principais:</p>
<ol type="1">
<li><p><strong>Forma Normal Negativa</strong>: Uma proposição está na Forma Normal Negativa se as operações de negação <span class="math inline">\(\neg\)</span> aparecerem apenas imediatamente antes das variáveis. Isso é conseguido aplicando as leis de De Morgan e eliminando as duplas negações.</p>
<p><span class="math display">\[\neg (A \wedge B) \equiv (\neg A \vee \neg B)\]</span></p></li>
<li><p><strong>Forma Normal Conjuntiva</strong>: uma proposição está na Forma Normal Conjuntiva se for uma conjunção, operação <strong>E</strong>, <span class="math inline">\(\wedge\)</span>, de uma ou mais cláusulas, nas quais, cada cláusula é uma disjunção, operação <strong>OU</strong>, <span class="math inline">\(\vee\)</span>, de literais. Em outras palavras, é uma série de cláusulas conectadas por <strong>Es</strong>, nas quais, cada cláusula é composta de variáveis conectadas por <strong>OUs</strong>. <strong>Uma forma normal conjuntiva é uma conjunção de disjunções</strong>.</p>
<p><span class="math display">\[(A \vee B) \wedge (C \vee D) \wedge (B \vee D) \wedge (A \vee C)\]</span></p></li>
<li><p><strong>Forma Normal Disjuntiva</strong>: uma proposição está na Forma Normal Disjuntiva se for uma disjunção de uma ou mais cláusulas, na qual cada cláusula é uma conjunção de literais. Ou seja, é uma série de cláusulas conectadas por <strong>OUs</strong>, nas quais cada cláusula é composta de variáveis conectadas por <strong>Es</strong>, conjunções. <strong>A forma normal disjuntiva é uma disjunção de conjunções</strong>.</p>
<p><span class="math display">\[(A \wedge B) \vee (C \wedge D) \vee (A \wedge C) \vee (B \wedge D)\]</span></p></li>
<li><p><strong>Forma Normal Prenex</strong>: uma proposição está na Forma Normal Prenex se todos os quantificadores, para a <strong>Lógica de Primeira Ordem</strong>, estiverem à esquerda, precedendo uma matriz quantificadora livre. Esta forma é útil na <strong>Lógica de Primeira Ordem</strong> e na teoria da prova.</p>
<p><span class="math display">\[\forall x \exists y \forall z (P(x,y) \wedge \neg Q(z))\]</span></p></li>
<li><p><strong>Forma Normal Skolem</strong>: na <strong>Lógica de Primeira Ordem</strong>, uma fórmula está na Forma Normal de Skolem se estiver na Forma Normal Prenex e se todos os quantificadores existenciais forem eliminados. Isto é realizado através de um processo conhecido como Skolemização. Por exemplo, dada a fórmula:</p></li>
</ol>
<p><span class="math display">\[\forall x \exists y (P(x,y))\]</span></p>
<p>Sua forma após a Skolemização, que preserva a satisfatibilidade, será:</p>
<p><span class="math display">\[\forall x (P(x, \mathbf{\mathbf{f}}(x)))\]</span></p>
<p>Nosso objetivo, neste livro, é rever a matemática que suporta a Programação Lógica, entre as principais formas normais, para este objetivo, precisamos destacar duas formas:</p>
<ol type="a">
<li><p><strong>Forma Normal Conjuntiva</strong>: a Forma Normal Conjuntiva é importante na Programação Lógica porque muitos sistemas de inferência, como a resolução, funcionam em fórmulas que estão na Forma Normal Conjuntiva. Além disso, os programas em Prolog, a linguagem de Programação Lógica que escolhemos, são formados por Cláusulas de Horn, que são um tipo específico de cláusula na Forma Normal Conjuntiva, cláusulas que possuem, no máximo, um literal positivo.</p></li>
<li><p><strong>Forma Normal de Skolem</strong>: a Forma Normal de Skolem é útil na Programação Lógica porque a Skolemização, o processo de remover quantificadores existenciais transformando-os em funções de quantificadores universais, permite uma forma mais eficiente de representação e processamento de fórmulas lógicas. Essa forma normal é frequentemente usada em <strong>Lógica de Primeira Ordem</strong> e teoria da prova, ambas fundamentais para a Programação Lógica.</p></li>
</ol>
<p>Para entender como conseguimos resolver problemas complexos de lógica, teremos que explorar essas formas normais em detalhes. Começando com a mais simples de todas, a Forma Normal Negativa.</p>
<section id="forma-normal-negativa" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="forma-normal-negativa"><span class="header-section-number">7.1.1</span> Forma Normal Negativa</h3>
<p>A Forma Normal Negativa é como um capitão experiente que ajusta as velas de seu navio. Assim como o capitão remove o excesso de pano e reorganiza as velas para que cada uma capture o vento diretamente, a Forma Normal Negativa move cada negação para o mais próximo possível de seu alvo, os átomos da fórmula.”</p>
<p>É como o processo de desenrolar as linhas de pesca emaranhadas: pegamos cada fio de negação e o seguimos até sua extremidade natural, eliminando as voltas e os nós desnecessários que encontramos no caminho.</p>
<p>Uma fórmula está na Forma Normal Negativa se:</p>
<ol type="a">
<li><p>todos os operadores de negação <span class="math inline">\(\neg\)</span> são aplicados diretamente aos átomos, variáveis ou constantes.</p></li>
<li><p>usaremos apenas a negação <span class="math inline">\(\neg\)</span>, a conjunção <span class="math inline">\(\wedge\)</span>, e a disjunção <span class="math inline">\(\vee\)</span>.</p></li>
</ol>
<p>Converter uma fórmula para a Forma Normal Negativa envolve os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar os Bicondicionais</strong>: substitua todas as ocorrências de <span class="math inline">\(A\leftrightarrow B\)</span> Por <span class="math inline">\(A\rightarrow B \wedge B\rightarrow A\)</span>.</p></li>
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \vee B\)</span>.</p></li>
<li><p><strong>Aplicar as Leis de De Morgan</strong>: Use as leis de De Morgan para mover as negações para dentro, aplicando:</p>
<ul>
<li><span class="math inline">\(\neg (A \wedge  B) \equiv \neg A \vee \neg B\)</span>;</li>
<li><span class="math inline">\(\neg (A \vee B) \equiv \neg A \wedge  \neg B\)</span>.</li>
</ul></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Substitua qualquer dupla negação <span class="math inline">\(\neg \neg A\)</span> Por <span class="math inline">\(A\)</span>.</p></li>
</ol>
<section id="exemplo-1" class="level4" data-number="7.1.1.1">
<h4 data-number="7.1.1.1" class="anchored" data-anchor-id="exemplo-1"><span class="header-section-number">7.1.1.1</span> Exemplo 1</h4>
<p>Converta a fórmula <span class="math inline">\(\neg (A \wedge  (B \rightarrow C))\)</span> Para Forma Normal Negativa</p>
<p>Para converter a fórmula, seguimos o processo passo a passo para mover as negações para o interior da expressão até que elas se apliquem apenas aos átomos.</p>
<ol type="1">
<li><p><strong>Eliminar Implicações</strong>: Primeiro, substituímos a implicação <span class="math inline">\(B \rightarrow C\)</span> por sua equivalência <span class="math inline">\(\neg B \vee C\)</span>.</p>
<p><span class="math display">\[\neg (A \wedge  (\neg B \vee C))\]</span></p></li>
<li><p><strong>Aplicar Lei de De Morgan (na Conjunção)</strong>: Em seguida, aplicamos a lei de De Morgan <span class="math inline">\(\neg(P \wedge  Q) \equiv \neg P \vee \neg Q\)</span> na conjunção principal.</p>
<p><span class="math display">\[\neg A \vee \neg(\neg B \vee C)\]</span></p></li>
<li><p><strong>Aplicar Lei de De Morgan (na Disjunção)</strong>: Agora, aplicamos a lei de De Morgan <span class="math inline">\(\neg(P \vee Q) \equiv \neg P \wedge  \neg Q\)</span> na parte direita da expressão.</p>
<p><span class="math display">\[\neg A \vee (\neg\neg B \wedge  \neg C)\]</span></p></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Finalmente, removemos a dupla negação <span class="math inline">\(\neg\neg B\)</span>, que é equivalente a <span class="math inline">\(B\)</span>.</p>
<p><span class="math display">\[\neg A \vee (B \wedge  \neg C)\]</span></p>
<p>A fórmula resultante está na Forma Normal Negativa. os operadores de negação (<span class="math inline">\(\neg\)</span>) aplicam-se diretamente aos átomos <span class="math inline">\(A\)</span> e <span class="math inline">\(C\)</span>.</p></li>
</ol>
</section>
<section id="exemplo-2" class="level4" data-number="7.1.1.2">
<h4 data-number="7.1.1.2" class="anchored" data-anchor-id="exemplo-2"><span class="header-section-number">7.1.1.2</span> Exemplo 2</h4>
<p>Converta a fórmula <span class="math inline">\((A \rightarrow B) \wedge  \neg (C \vee D)\)</span> Para Forma Normal Negativa</p>
<p>Neste exemplo, ambos os lados da conjunção principal (<span class="math inline">\(\wedge\)</span>) são tratados para se adequarem à Forma Normal Negativa.</p>
<ol type="1">
<li><p><strong>Eliminar Implicações</strong>: O primeiro passo é converter a implicação <span class="math inline">\(A \rightarrow B\)</span> em sua equivalência, <span class="math inline">\(\neg A \vee B\)</span>. A segunda parte da fórmula não possui implicações.</p>
<p><span class="math display">\[(\neg A \vee B) \wedge  \neg (C \vee D)\]</span></p></li>
<li><p><strong>Aplicar Lei de De Morgan</strong>: A seguir, aplicamos a lei de De Morgan na expressão <span class="math inline">\(\neg (C \vee D)\)</span> para mover a negação para o interior dos parênteses.</p>
<p><span class="math display">\[(\neg A \vee B) \wedge (\neg C \wedge \neg D)\]</span></p></li>
</ol>
<p>A fórmula já se encontra na Forma Normal Negativa. Todos os operadores de negação estão aplicados diretamente aos átomos (<span class="math inline">\(A\)</span>, <span class="math inline">\(C\)</span> e <span class="math inline">\(D\)</span>). Não há duplas negações que precisem ser eliminadas neste caso.</p>
</section>
</section>
<section id="forma-normal-disjuntiva" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="forma-normal-disjuntiva"><span class="header-section-number">7.1.2</span> Forma Normal Disjuntiva</h3>
<p>A Forma Normal Disjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma disjunção de conjunções. Trata-se de uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico.</p>
<p>Uma fórmula está na Forma Normal Disjuntiva se puder ser escrita como:</p>
<p><span class="math display">\[(C_1 \wedge  C_2 \wedge  \ldots) \vee (D_1 \wedge  D_2 \wedge  \ldots) \vee \ldots\]</span></p>
<p>Na qual, cada <span class="math inline">\(C_i\)</span> e <span class="math inline">\(D_i\)</span> representam literais. Ou seja, ou representam uma variável ou sua negação. Com um pouco mais de formalidade matemática podemos afirmar que uma <strong>Fórmula Bem Formada</strong> está na Forma Normal Disjuntiva quando está na forma:</p>
<p><span class="math display">\[\bigvee_{i=1}^{m} \left( \bigwedge_{j=1}^{n} L_{ij} \right)\]</span></p>
<p>Converter uma fórmula para Forma Normal Disjuntiva é como identificar todas as combinações de ventos e correntes que levam o navio ao porto desejado. A fórmula original é a rota complexa, a disjunção de todas as opções de rotas. Cada termo da Forma Normal Disjuntiva que encontramos é como um cenário único e completo, uma conjunção de condições marítimas, que, por si só, garante que o navio chegue ao destino.</p>
<p>Para esta conversão, a intrépida leitora deve seguir os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar os Bicondicionais</strong>: substitua todas as ocorrências de <span class="math inline">\(A\leftrightarrow B\)</span> Por <span class="math inline">\(A\rightarrow B \wedge B\rightarrow A\)</span>.</p></li>
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \vee B\)</span>.</p></li>
<li><p><strong>Aplicar as Leis de De Morgan</strong>: use as leis de De Morgan para mover as negações para dentro, aplicando:</p>
<ul>
<li><span class="math inline">\(\neg (A \wedge  B) \equiv \neg A \vee \neg B\)</span></li>
<li><span class="math inline">\(\neg (A \vee B) \equiv \neg A \wedge  \neg B\)</span></li>
</ul></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Substitua qualquer dupla negação <span class="math inline">\(\neg \neg A\)</span> Por <span class="math inline">\(A\)</span>.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong>: Use a lei distributiva para expandir a fórmula, transformando-a em uma disjunção de conjunções.</p></li>
</ol>
<section id="exemplo-1-1" class="level4" data-number="7.1.2.1">
<h4 data-number="7.1.2.1" class="anchored" data-anchor-id="exemplo-1-1"><span class="header-section-number">7.1.2.1</span> Exemplo 1</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[
(A \rightarrow B) \wedge  (C \vee \neg (D \wedge  E))
\]</span></p>
<p>O objetivo é convertê-la para uma disjunção de conjunções.</p>
<ol type="1">
<li><p><strong>Converter para a Forma Normal Negativa</strong></p>
<p>Primeiro, realizamos os passos iniciais para eliminar implicações e mover as negações para o interior da fórmula, o que nos dará uma forma intermediária.</p>
<ul>
<li><p>Eliminar Implicações (<span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>):</p>
<p><span class="math display">\[(\neg A \vee B) \wedge  (C \vee \neg (D \wedge  E))\]</span></p></li>
<li><p>Aplicar a Lei de De Morgan (<span class="math inline">\(\neg (D \wedge  E) \equiv \neg D \vee \neg E\)</span>):</p>
<p><span class="math display">\[(\neg A \vee B) \wedge  (C \vee \neg D \vee \neg E)\]</span></p></li>
</ul>
<p>Neste ponto, a fórmula encontra-se na <strong>Forma Normal Conjuntiva</strong> . O passo seguinte é aplicar a distributividade para alcançar a Forma Normal Disjuntiva.</p></li>
<li><p><strong>Aplicar a Lei Distributiva (Parte 1)</strong></p>
<p>Usamos a lei distributiva <span class="math inline">\(P \wedge  (Q \vee R) \equiv (P \wedge  Q) \vee (P \wedge  R)\)</span>. Vamos tratar o termo <span class="math inline">\((\neg A \vee B)\)</span> como uma única unidade, <span class="math inline">\(X\)</span>, e distribuí-lo sobre <span class="math inline">\((C \vee \neg D \vee \neg E)\)</span>.</p>
<p><span class="math display">\[
  \underbrace{(\neg A \vee B)}_{X} \wedge  (C \vee \neg D \vee \neg E) \equiv (X \wedge  C) \vee (X \wedge  \neg D) \vee (X \wedge  \neg E)
\]</span></p>
<p>Substituindo <span class="math inline">\(X\)</span> de volta, obtemos:</p>
<p><span class="math display">\[
  ((\neg A \vee B) \wedge  C) \vee ((\neg A \vee B) \wedge  \neg D) \vee ((\neg A \vee B) \wedge  \neg E)
\]</span></p></li>
<li><p><strong>Aplicar a Lei Distributiva (Parte 2)</strong></p>
<p>Agora, aplicamos a lei distributiva <span class="math inline">\((P \vee Q) \wedge  R \equiv (P \wedge  R) \vee (Q \wedge  R)\)</span> em cada uma das três cláusulas da expressão acima.</p>
<ul>
<li>Primeiro termo: <span class="math inline">\((\neg A \wedge  C) \vee (B \wedge  C)\)</span>;</li>
<li>Segundo termo: <span class="math inline">\((\neg A \wedge  \neg D) \vee (B \wedge  \neg D)\)</span>;</li>
<li>Terceiro termo: <span class="math inline">\((\neg A \wedge  \neg E) \vee (B \wedge  \neg E)\)</span>.</li>
</ul></li>
<li><p><strong>Forma Normal Disjuntiva</strong></p>
<p>Unindo todos os termos expandidos com o operador <span class="math inline">\(\vee\)</span>, chegamos à Forma Normal Disjuntiva final.</p>
<p><span class="math display">\[
(\neg A \wedge  C) \vee (B \wedge  C) \vee (\neg A \wedge  \neg D) \vee (B \wedge  \neg D) \vee (\neg A \wedge  \neg E) \vee (B \wedge  \neg E)
\]</span></p>
<p>A expressão agora é uma disjunção de múltiplas conjunções, que é a definição da Forma Normal Disjuntiva.</p></li>
</ol>
</section>
<section id="exemplo-2-1" class="level4" data-number="7.1.2.2">
<h4 data-number="7.1.2.2" class="anchored" data-anchor-id="exemplo-2-1"><span class="header-section-number">7.1.2.2</span> Exemplo 2</h4>
<p>Considere:</p>
<p><span class="math display">\[(\neg A \wedge  (B \rightarrow C)) \vee (D \wedge  \neg (E \rightarrow F))\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações</p>
<p><span class="math display">\[(\neg A \wedge  (\neg B \vee C)) \vee (D \wedge  \neg (\neg E \vee F)) \equiv (\neg A \wedge  (\neg B \vee C)) \vee (D \wedge  (E \wedge  \neg F))\]</span></p></li>
<li><p>Distribuir a Disjunção</p>
<p><span class="math display">\[(\neg A \wedge  \neg B \vee \neg A \wedge  C) \vee (D \wedge  E \wedge  \neg F)\]</span></p></li>
<li><p>Distribuir a Disjunção Novamente</p>
<p><span class="math display">\[\neg A \wedge  \neg B \vee \neg A \wedge  C \vee D \wedge  E \wedge  \neg F\]</span></p></li>
</ol>
</section>
<section id="exemplo-3" class="level4" data-number="7.1.2.3">
<h4 data-number="7.1.2.3" class="anchored" data-anchor-id="exemplo-3"><span class="header-section-number">7.1.2.3</span> Exemplo 3</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(P \rightarrow Q) \rightarrow (R \vee S)\]</span></p>
<ol type="1">
<li><p>Remover as implicações (<span class="math inline">\(\rightarrow\)</span>):</p>
<p><span class="math display">\[P \rightarrow Q \equiv \neg P \vee Q\]</span></p></li>
<li><p>Substituir a expressão original com a equivalência encontrada no passo 1:</p>
<p><span class="math display">\[(\neg P \vee Q) \rightarrow (R \vee S)\]</span></p></li>
<li><p>Aplicar novamente a equivalência para remover a implicação:</p>
<p><span class="math display">\[\neg (\neg P \vee Q) \vee (R \vee S)\]</span></p></li>
<li><p>Aplicar a lei de De Morgan para expandir a negação:</p>
<p><span class="math display">\[(P \wedge \neg Q) \vee (R \vee S)\]</span></p></li>
</ol>
</section>
<section id="exemplo-4" class="level4" data-number="7.1.2.4">
<h4 data-number="7.1.2.4" class="anchored" data-anchor-id="exemplo-4"><span class="header-section-number">7.1.2.4</span> Exemplo 4</h4>
<p>Considere a fórmula que representa a negação de uma bicondicional, que é logicamente equivalente a uma operação de “ou exclusivo” (XOR):</p>
<p><span class="math display">\[
\neg(P \leftrightarrow Q)
\]</span></p>
<p>Vamos convertê-la para a Forma Normal Disjuntiva.</p>
<ol type="1">
<li><p><strong>Eliminar a Bicondicional</strong></p>
<p>O primeiro passo é substituir o operador de bicondicional (<span class="math inline">\(A \leftrightarrow B\)</span>) por sua definição equivalente: <span class="math inline">\((A \rightarrow B) \wedge  (B \rightarrow A)\)</span>.</p>
<p><span class="math display">\[
\neg((P \rightarrow Q) \wedge  (Q \rightarrow P))
\]</span></p></li>
<li><p><strong>Eliminar as Implicações</strong></p>
<p>Agora, convertemos as duas implicações internas em suas formas disjuntivas, usando a regra <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>.</p>
<p><span class="math display">\[
\neg((\neg P \vee Q) \wedge  (\neg Q \vee P))
\]</span></p></li>
<li><p><strong>Aplicar a Lei de De Morgan</strong></p>
<p>Aplicamos a lei de De Morgan na negação que cobre toda a expressão, transformando a conjunção (<span class="math inline">\(\wedge\)</span>) em disjunção (<span class="math inline">\(\vee\)</span>) e movendo a negação para os termos internos.</p>
<p><span class="math display">\[
\neg(\neg P \vee Q) \vee \neg(\neg Q \vee P)
\]</span></p></li>
<li><p><strong>Aplicar a Lei de De Morgan Novamente e Simplificar</strong></p>
<p>Para finalizar, aplicamos a lei de De Morgan em cada um dos termos e removemos as duplas negações (<span class="math inline">\(\neg\neg A \equiv A\)</span>) que surgem no processo.</p>
<p><span class="math display">\[
(\neg\neg P \wedge  \neg Q) \vee (\neg\neg Q \wedge  \neg P)
\]</span></p>
<p>Simplificando, obtemos a Forma Normal Disjuntiva final:</p>
<p><span class="math display">\[
(P \wedge  \neg Q) \vee (\neg P \wedge  Q)
\]</span></p>
<p>A expressão resultante é uma disjunção de duas conjunções, o que corresponde perfeitamente à definição da Forma Normal Disjuntiva.</p></li>
</ol>
</section>
<section id="exemplo-5" class="level4" data-number="7.1.2.5">
<h4 data-number="7.1.2.5" class="anchored" data-anchor-id="exemplo-5"><span class="header-section-number">7.1.2.5</span> Exemplo 5</h4>
<p>Considere a seguinte fórmula com uma implicação principal e uma bicondicional aninhada: <span class="math display">\[
\neg(P \wedge  Q) \rightarrow (R \leftrightarrow S)
\]</span> Nosso objetivo é convertê-la para a Forma Normal Disjuntiva.</p>
<ol type="1">
<li><p><strong>Eliminar a Implicação Principal</strong></p>
<p>Utilizando a equivalência <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>, removemos o operador de implicação principal da fórmula.</p>
<p><span class="math display">\[
\neg(\neg(P \wedge  Q)) \vee (R \leftrightarrow S)
\]</span></p></li>
<li><p><strong>Eliminar a Dupla Negação</strong></p>
<p>A expressão <span class="math inline">\(\neg(\neg(P \wedge  Q))\)</span> simplifica-se diretamente para <span class="math inline">\((P \wedge  Q)\)</span>, resultando em:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee (R \leftrightarrow S)
\]</span></p></li>
<li><p><strong>Eliminar a Bicondicional</strong></p>
<p>Substituímos a bicondicional <span class="math inline">\(R \leftrightarrow S\)</span> por sua definição equivalente: <span class="math inline">\((R \rightarrow S) \wedge  (S \rightarrow R)\)</span>.</p>
<p><span class="math display">\[
(P \wedge  Q) \vee ((R \rightarrow S) \wedge  (S \rightarrow R))
\]</span></p>
<p>Em seguida, eliminamos as implicações restantes:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee ((\neg R \vee S) \wedge  (\neg S \vee R))
\]</span></p>
<p>Note que a expressão ainda não está em Forma Normal Disjuntiva. A parte direita é uma conjunção.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong></p>
<p>Para que toda a expressão se torne uma disjunção de conjunções, precisamos converter a parte <span class="math inline">\((\neg R \vee S) \wedge  (\neg S \vee R)\)</span> para Forma Normal Disjuntiva. Fazemos isso aplicando a distributividade:</p>
<p><span class="math display">\[
(\neg R \vee S) \wedge  (\neg S \vee R) \equiv (\neg R \wedge  \neg S) \vee (\neg R \wedge  R) \vee (S \wedge  \neg S) \vee (S \wedge  R)
\]</span></p>
<p>As cláusulas <span class="math inline">\((\neg R \wedge  R)\)</span> e <span class="math inline">\((S \wedge  \neg S)\)</span> são contradições (sempre falsas), então podem ser removidas, simplificando a expressão para:</p>
<p><span class="math display">\[
(\neg R \wedge  \neg S) \vee (S \wedge  R)
\]</span></p></li>
<li><p><strong>Forma Normal Disjuntiva</strong></p>
<p>Agora, substituímos a Forma Normal Disjuntiva que acabamos de derivar de volta na fórmula principal:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee ((\neg R \wedge  \neg S) \vee (S \wedge  R))
\]</span></p>
<p>Como o operador <span class="math inline">\(\vee\)</span> é associativo, podemos remover os parênteses extras, chegando à Forma Normal Disjuntiva final:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee (\neg R \wedge  \neg S) \vee (S \wedge  R)
\]</span></p>
<p>A fórmula final está corretamente expressa como uma disjunção de três conjunções de literais.</p></li>
</ol>
<p>A Forma Normal Disjuntiva é útil porque qualquer fórmula lógica pode ser representada desta forma. Além disso, essa representação é única, com exceção da ordem dos literais e das cláusulas.</p>
</section>
<section id="sec-exercicios-conversao-fnd" class="level4" data-number="7.1.2.6">
<h4 data-number="7.1.2.6" class="anchored" data-anchor-id="sec-exercicios-conversao-fnd"><span class="header-section-number">7.1.2.6</span> Exercícios de Conversão para Forma Normal Disjuntiva</h4>
<p><strong>1.</strong> Converta a seguinte fórmula para Forma Normal Disjuntiva:</p>
<p><span class="math display">\[
((P \leftrightarrow Q) \rightarrow R) \wedge \neg(R \rightarrow (P \vee Q))
\]</span></p>
<p><strong>2.</strong> Converta para Forma Normal Disjuntiva a fórmula que representa a negação de uma tautologia clássica:</p>
<p><span class="math display">\[
\neg((P \rightarrow (Q \rightarrow R)) \rightarrow ((P \rightarrow Q) \rightarrow (P \rightarrow R)))
\]</span></p>
<p><strong>3.</strong> Dada a fórmula com múltiplas bicondicionais aninhadas, obtenha sua Forma Normal Disjuntiva:</p>
<p><span class="math display">\[
(P \leftrightarrow (Q \leftrightarrow R)) \vee \neg(P \wedge Q \wedge R)
\]</span></p>
<p><strong>4.</strong> Converta a seguinte fórmula complexa para Forma Normal Disjuntiva:</p>
<p><span class="math display">\[
\neg((P \vee Q) \rightarrow (R \wedge S)) \leftrightarrow (P \rightarrow \neg Q)
\]</span></p>
<p><strong>5.</strong> Transforme em Forma Normal Disjuntiva a fórmula:</p>
<p><span class="math display">\[
((P \wedge Q) \rightarrow (R \vee S)) \wedge ((R \rightarrow P) \vee (S \rightarrow Q))
\]</span></p>
<p><strong>6.</strong> Obtenha a Forma Normal Disjuntiva para:</p>
<p><span class="math display">\[
\neg(P \leftrightarrow \neg Q) \rightarrow ((P \wedge R) \vee (Q \wedge \neg R))
\]</span></p>
<p><strong>7.</strong> Converta para Forma Normal Disjuntiva a fórmula que combina negação de implicação com bicondicional:</p>
<p><span class="math display">\[
\neg((P \rightarrow Q) \wedge (Q \rightarrow R)) \leftrightarrow (P \wedge \neg R)
\]</span></p>
</section>
</section>
<section id="forma-normal-conjuntiva" class="level3" data-number="7.1.3">
<h3 data-number="7.1.3" class="anchored" data-anchor-id="forma-normal-conjuntiva"><span class="header-section-number">7.1.3</span> Forma Normal Conjuntiva</h3>
<p>A Forma Normal Conjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma conjunção de disjunções. Em outras palavras, é uma expressão lógica na forma de uma <em>conjunção de disjunções</em>. É uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico e simplificação de fórmulas.</p>
<p>A diferença entre Forma Normal Conjuntiva e Forma Normal Disjuntiva é como a diferença entre dois estilos de organização de uma biblioteca:</p>
<p>A Forma Normal Conjuntiva é como uma esquadra naval na qual cada embarcação, conjunção, deve ter pelo menos um tripulante qualificado, disjunção. Você só fica satisfeito se TODAS as embarcações tiverem alguém capacitado a bordo.</p>
<p>Dizemos que uma fórmula está na Forma Normal Conjuntiva se puder ser expressa na forma:</p>
<p><span class="math display">\[(D_1 \vee D_2 \vee \ldots \vee D_n) \wedge  (E_1 \vee E_2 \vee \ldots \vee E_m) \wedge  \ldots\]</span></p>
<p>Na qual, <span class="math inline">\(D_1, \ldots , D_n\)</span> e $ E_1, ,E_m $ representam literais. Podemos dizer que a Forma Normal Conjuntiva acontece quando a <strong>Fórmula Bem Formada</strong> está na forma:</p>
<p><span class="math display">\[\bigwedge_{i=1}^{m} \left( \bigvee_{j=1}^{n} L_{ij} \right)\]</span></p>
<p>Converter uma fórmula <strong>proposicional</strong> para a Forma Normal Conjuntiva é um processo algorítmico que garante que a expressão final seja uma conjunção de disjunções. Os passos são os seguintes:</p>
<ol type="1">
<li><p><strong>Eliminar Bicondicionais</strong>: Substitua todas as ocorrências da bicondicional pela sua definição baseada em implicações.</p>
<p><span class="math display">\[
A \leftrightarrow B \equiv (A \rightarrow B) \wedge  (B \rightarrow A)
\]</span></p></li>
<li><p><strong>Eliminar Implicações</strong>: Em seguida, remova todas as implicações, trocando-as por sua equivalência com o uso de disjunção e negação.</p>
<p><span class="math display">\[
A \rightarrow B \equiv \neg A \vee B
\]</span></p></li>
<li><p><strong>Mover Negações para o Interior (Converter para Forma Normal Negativa)</strong>: Use as Leis de De Morgan e a Lei da Dupla Negação para mover todos os operadores de negação (<span class="math inline">\(\neg\)</span>) para dentro da expressão, até que eles se apliquem apenas diretamente às variáveis atômicas. As regras principais são:</p>
<ul>
<li><span class="math inline">\(\neg(A \wedge  B) \equiv \neg A \vee \neg B\)</span></li>
<li><span class="math inline">\(\neg(A \vee B) \equiv \neg A \wedge  \neg B\)</span></li>
<li><span class="math inline">\(\neg\neg A \equiv A\)</span></li>
</ul>
<p>Ao final deste passo, a fórmula estará em Forma Normal Negativa .</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong>: Para finalizar, aplique a lei distributiva para garantir que nenhuma conjunção (<span class="math inline">\(\wedge\)</span>) esteja aninhada dentro de uma disjunção (<span class="math inline">\(\vee\)</span>). A regra chave é distribuir o <span class="math inline">\(\vee\)</span> sobre o <span class="math inline">\(\wedge\)</span>.</p>
<p><span class="math display">\[
A \vee (B \wedge  C) \equiv (A \vee B) \wedge  (A \vee C)
\]</span></p>
<p>Este passo deve ser repetido até que a fórmula inteira seja uma conjunção de cláusulas, nas quais cada cláusula é uma disjunção de literais, satisfazendo a definição da Forma Normal Conjuntiva.</p></li>
</ol>
<section id="exemplo-1-2" class="level4" data-number="7.1.3.1">
<h4 data-number="7.1.3.1" class="anchored" data-anchor-id="exemplo-1-2"><span class="header-section-number">7.1.3.1</span> Exemplo 1</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(A \wedge  B) \rightarrow (C \vee D)\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações:</p>
<p><span class="math display">\[\neg (A \wedge  B) \vee (C \vee D) \equiv (\neg A \vee \neg B) \vee (C \vee D)\]</span></p></li>
</ol>
<p>Neste ponto temos <span class="math inline">\((\neg A \vee \neg B) \vee (C \vee D)\)</span> e podemos remover os parênteses obtendo:</p>
<p><span class="math display">\[\neg A \vee \neg B \vee C \vee D\]</span></p>
<p>Aqui a atenta leitora deve observar que temos uma única cláusula, ou seja, uma Forma Normal Conjuntiva com apenas uma cláusula. Nenhuma outra simplificação é necessária.</p>
</section>
<section id="exemplo-2-2" class="level4" data-number="7.1.3.2">
<h4 data-number="7.1.3.2" class="anchored" data-anchor-id="exemplo-2-2"><span class="header-section-number">7.1.3.2</span> Exemplo 2</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(A \wedge  \neg B) \vee (\neg C \wedge  D) \rightarrow (E \vee F)\]</span></p>
<ol type="1">
<li>Eliminar Implicações (usando a equivalência <span class="math inline">\(P \rightarrow Q \equiv \neg P \vee Q\)</span>):</li>
</ol>
<p><span class="math display">\[\neg ((A \wedge  \neg B) \vee (\neg C \wedge  D)) \vee (E \vee F)\]</span></p>
<ol start="2" type="1">
<li>Mover a Negação para Dentro (usando Leis de De Morgan):</li>
</ol>
<p><span class="math display">\[((\neg A \vee B) \wedge (C \vee \neg D)) \vee (E \vee F)\]</span></p>
<ol start="3" type="1">
<li>Distribuir a Disjunção sobre a Conjunção (usando a equivalência <span class="math inline">\((P \wedge Q) \vee R \equiv (P \vee R) \wedge (Q \vee R)\)</span>):</li>
</ol>
<p><span class="math display">\[(\neg A \vee B \vee E \vee F) \wedge (C \vee \neg D \vee E \vee F)\]</span></p>
</section>
<section id="exemplo-3-1" class="level4" data-number="7.1.3.3">
<h4 data-number="7.1.3.3" class="anchored" data-anchor-id="exemplo-3-1"><span class="header-section-number">7.1.3.3</span> Exemplo 3</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[
(P \wedge (Q \vee R)) \vee (\neg P \wedge \neg Q)
\]</span></p>
<p><strong>Conversão para Forma Normal Conjuntiva</strong>:</p>
<ol type="1">
<li><p><strong>Aplicar a lei distributiva no primeiro termo</strong>: expandir <span class="math inline">\((P \wedge (Q \vee R))\)</span> usando <span class="math inline">\(A \wedge (B \vee C) \equiv (A \wedge B) \vee (A \wedge C)\)</span></p>
<p><span class="math display">\[
  (P \wedge Q) \vee (P \wedge R) \vee (\neg P \wedge \neg Q)
  \]</span></p>
<p>Neste ponto, temos uma <strong>Forma Normal Disjuntiva</strong> .</p></li>
<li><p><strong>Construir a tabela-verdade para determinar a Forma Normal Conjuntiva</strong>:</p></li>
</ol>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 30%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(P\)</span></th>
<th><span class="math inline">\(Q\)</span></th>
<th><span class="math inline">\(R\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \wedge Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \wedge R\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\neg P \wedge \neg Q\)</span></th>
<th style="text-align: center;">Resultado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li><p><strong>Identificar as linhas falsas</strong>: as linhas 4, 5 e 6 têm resultado falso.</p></li>
<li><p><strong>Construir cláusulas excludentes</strong>: para cada linha falsa, criamos uma cláusula que a “proíbe”:</p>
<ul>
<li><strong>Linha 4</strong> (P=T, Q=F, R=F): Para excluir esta combinação, criamos <span class="math inline">\((\neg P \vee Q \vee R)\)</span></li>
<li><strong>Linha 5</strong> (P=F, Q=T, R=T): Para excluir esta combinação, criamos <span class="math inline">\((P \vee \neg Q \vee \neg R)\)</span><br>
</li>
<li><strong>Linha 6</strong> (P=F, Q=T, R=F): Para excluir esta combinação, criamos <span class="math inline">\((P \vee \neg Q \vee R)\)</span></li>
</ul></li>
<li><p><strong>Formar a Forma Normal Conjuntiva</strong>: a conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:</p>
<p><span class="math display">\[
(\neg P \vee Q \vee R) \wedge (P \vee \neg Q \vee \neg R) \wedge (P \vee \neg Q \vee R)
\]</span></p></li>
<li><p><strong>Simplificação</strong>: podemos aplicar a lei da resolução nas duas últimas cláusulas:</p>
<p>De <span class="math inline">\((P \vee \neg Q \vee \neg R) \wedge (P \vee \neg Q \vee R)\)</span>, obtemos <span class="math inline">\((P \vee \neg Q)\)</span> (eliminando <span class="math inline">\(R\)</span> e <span class="math inline">\(\neg R\)</span>).</p>
<p><strong>Forma Normal Conjuntiva simplificada</strong>:</p>
<p><span class="math display">\[
(\neg P \vee Q \vee R) \wedge (P \vee \neg Q)
\]</span></p></li>
</ol>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Observação importante - Por que a conversão direta não funciona</strong>:</p>
<p>A conversão direta de Forma Normal Disjuntiva para Forma Normal Conjuntiva através de distributividade simples frequentemente resulta em uma explosão exponencial de termos. Vamos ver por que:</p>
<p>Para converter <span class="math inline">\((P \wedge Q) \vee (P \wedge R) \vee (\neg P \wedge \neg Q)\)</span> diretamente para Forma Normal Conjuntiva, precisaríamos aplicar a distributividade do <span class="math inline">\(\wedge\)</span> sobre <span class="math inline">\(\vee\)</span>, usando a regra <span class="math inline">\((A \vee B) \wedge (C \vee D) \equiv (A \wedge C) \vee (A \wedge D) \vee (B \wedge C) \vee (B \wedge D)\)</span>.</p>
<p>Se tentássemos aplicar isso sistematicamente:</p>
<ol type="1">
<li>Primeiro, agruparíamos: <span class="math inline">\(((P \wedge Q) \vee (P \wedge R)) \vee (\neg P \wedge \neg Q)\)</span>;</li>
<li>Cada aplicação de distributividade duplicaria o número de termos;</li>
<li>Com 3 termos conjuntivos originais, cada um com 2 literais, a expansão completa geraria <span class="math inline">\(2^3 = 8\)</span> combinações possíveis;</li>
<li>Muitas dessas combinações seriam tautológicas ou contraditórias, requerendo simplificação adicional.</li>
</ol>
<p><strong>Exemplo da complexidade</strong>: Aplicando distributividade apenas ao primeiro passo:</p>
<ul>
<li><span class="math inline">\((P \wedge Q) \vee (P \wedge R)\)</span> precisa ser convertido para Forma Normal Conjuntiva</li>
<li>Isso exigiria criar “pseudo-literais” para cada conjunção</li>
<li>A expressão resultante seria muito mais complexa que a Forma Normal Conjuntiva obtida pela tabela-verdade</li>
</ul>
<p><strong>Por isso, métodos alternativos são preferíveis</strong>:</p>
<ul>
<li><strong>Tabela-verdade</strong>: Identifica diretamente as condições falsas, gerando a Forma Normal Conjuntiva mínima</li>
<li><strong>Algoritmo de Tseitin</strong>: Introduz variáveis auxiliares para evitar explosão exponencial</li>
<li><strong>Resolução reversa</strong>: Constrói cláusulas incrementalmente</li>
</ul>
<p>A abordagem pela tabela-verdade, embora limitada a fórmulas proposicionais pequenas, é mais sistemática e garante uma Forma Normal Conjuntiva correta sem a complexidade da distributividade direta.</p>
</div>
</div>
</section>
<section id="exemplo-4-1" class="level4" data-number="7.1.3.4">
<h4 data-number="7.1.3.4" class="anchored" data-anchor-id="exemplo-4-1"><span class="header-section-number">7.1.3.4</span> Exemplo 4</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[ \neg ((P \wedge Q) \vee \neg (R \wedge S))\]</span></p>
<ol type="1">
<li><p>Aplicando a Lei de De Morgan na expressão inteira:</p>
<p><span class="math display">\[
\begin{align*}
\neg ((P \wedge Q) \vee \neg (R \wedge S)) &amp;\equiv \neg (P \wedge Q) \wedge (R \wedge S) \quad \text{(Lei de De Morgan)}
\end{align*}
\]</span></p></li>
<li><p>aplicando a Lei de De Morgan nos termos internos:</p>
<p><span class="math display">\[
\begin{align*}
\neg (P \wedge Q) \wedge (R \wedge S) &amp;\equiv (\neg P \vee \neg Q) \wedge (R \wedge S) \quad \text{(Lei de De Morgan)}
\end{align*}
\]</span></p></li>
</ol>
</section>
<section id="exemplo-5-1" class="level4" data-number="7.1.3.5">
<h4 data-number="7.1.3.5" class="anchored" data-anchor-id="exemplo-5-1"><span class="header-section-number">7.1.3.5</span> Exemplo 5</h4>
<p>Considere a seguinte fórmula, que é a negação da Lei de Peirce (uma conhecida tautologia na lógica clássica):</p>
<p><span class="math display">\[
\neg (((P \rightarrow Q) \rightarrow P) \rightarrow P)
\]</span></p>
<p>Nosso objetivo é converter esta fórmula para a Forma Normal Conjuntiva para determinar sua natureza.</p>
<ol type="1">
<li><p><strong>Eliminar a Implicação Mais Externa</strong></p>
<p>Aplicamos a regra <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span> na implicação principal.</p>
<p><span class="math display">\[
\neg (\neg((P \rightarrow Q) \rightarrow P) \vee P)
\]</span></p></li>
<li><p><strong>Aplicar a Lei de De Morgan</strong></p>
<p>Agora, aplicamos a lei <span class="math inline">\(\neg(A \vee B) \equiv \neg A \wedge  \neg B\)</span> na fórmula.</p>
<p><span class="math display">\[
\neg\neg((P \rightarrow Q) \rightarrow P) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Eliminar a Dupla Negação</strong></p>
<p>A dupla negação é removida, simplificando a expressão.</p>
<p><span class="math display">\[
((P \rightarrow Q) \rightarrow P) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Eliminar as Implicações Restantes</strong></p>
<p>Continuamos eliminando as implicações de dentro para fora.</p>
<p><span class="math display">\[
(\neg(P \rightarrow Q) \vee P) \wedge  \neg P
\]</span></p>
<p><span class="math display">\[
(\neg(\neg P \vee Q) \vee P) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Mover a Negação para o Interior</strong></p>
<p>Aplicamos a Lei de De Morgan no primeiro termo aninhado.</p>
<p><span class="math display">\[
((P \wedge  \neg Q) \vee P) \wedge  \neg P
\]</span></p>
<p>Neste ponto, a expressão <span class="math inline">\(((P \wedge  \neg Q) \vee P) \wedge  \neg P\)</span> está em Forma Normal Disjuntiva. Para prosseguir com a conversão para Forma Normal Conjuntiva, precisamos aplicar a lei distributiva nela.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong></p>
<p>Distribuímos <span class="math inline">\(\vee P\)</span> sobre <span class="math inline">\((P \wedge  \neg Q)\)</span> usando a regra <span class="math inline">\((A \wedge  B) \vee C \equiv (A \vee C) \wedge  (B \vee C)\)</span>.</p>
<p><span class="math display">\[
((P \vee P) \wedge  (\neg Q \vee P)) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Simplificar e Reassociar</strong></p>
<p>Simplificamos <span class="math inline">\((P \vee P)\)</span> para <span class="math inline">\(P\)</span> (Idempotência) e reassociamos os termos para agrupar <span class="math inline">\(P\)</span> e <span class="math inline">\(\neg P\)</span>.</p>
<p><span class="math display">\[
(P \wedge  (\neg Q \vee P)) \wedge  \neg P
\]</span></p>
<p><span class="math display">\[
(P \wedge  \neg P) \wedge  (\neg Q \vee P)
\]</span></p></li>
<li><p><strong>Resultado</strong></p>
<p>A expressão <span class="math inline">\((P \wedge  \neg P)\)</span> é uma contradição, equivalente a <span class="math inline">\(Falso\)</span> (<span class="math inline">\(F\)</span>). Qualquer conjunção com <span class="math inline">\(F\)</span> resulta em <span class="math inline">\(F\)</span>.</p>
<p><span class="math display">\[
F \wedge  (\neg Q \vee P)
\]</span></p>
<p><span class="math display">\[
F
\]</span></p>
<p>A fórmula original é uma contradição. A Forma Normal Conjuntiva de uma contradição pode ser representada simplesmente como <span class="math inline">\(F\)</span>, ou por qualquer conjunção contraditória, como <span class="math inline">\((P \wedge  \neg P)\)</span>.</p></li>
</ol>
<p>::: {calout-note} <strong>Negação da Lei de Peirce</strong></p>
<pre><code>A *Lei de Peirce* é uma tautologia fundamental da lógica clássica, formulada como:

$$((P \rightarrow Q) \rightarrow P) \rightarrow P$$

A *negação da Lei de Peirce* é expressa por:

$$\neg(((P \rightarrow Q) \rightarrow P) \rightarrow P)$$

Esta negação representa uma fórmula que é:

- Sempre falsa na lógica clássica (sendo a negação de uma tautologia);
- Satisfazível em alguns sistemas de lógica intuicionista;
- Um exemplo importante de fórmula que distingue lógica clássica de lógica intuicionista.

Para entender melhor, considere que a a *lógica clássica* é baseada em princípios fundamentais como:

- **Princípio do Terceiro Excluído**: para qualquer proposição $P$, ou $P$ é verdadeira ou $\neg P$ é verdadeira: $P \vee \neg P$;
- **Princípio da Não-Contradição**: uma proposição não pode ser simultaneamente verdadeira e falsa: $\neg(P \wedge \neg P)$;
- **Reductio ad Absurdum**: se assumir $\neg P$ leva a uma contradição, então $P$ deve ser verdadeira.

Por outro lado, a *lógica intuicionista*, desenvolvida por [Brouwer](https://en.wikipedia.org/wiki/L._E._J._Brouwer) e formalizada por [Heyting](https://en.wikipedia.org/wiki/Arend_Heyting), rejeita o princípio do terceiro excluído. Principais características:

- Uma proposição só é considerada verdadeira se existe uma *prova construtiva* de sua verdade;
- A negação de uma proposição $\neg P$ significa que assumir $P$ leva a uma contradição;
- $P \vee \neg P$ não é universalmente válida - requer demonstração específica para cada $P$.

**Diferenças Fundamentais entre a Lógica Clássica e a Intuicionista**

- **Interpretação da Implicação**: Na lógica clássica, $P \rightarrow Q$ é falsa apenas quando $P$ é verdadeira e $Q$ é falsa. Na lógica intuicionista, $P \rightarrow Q$ requer uma construção que transforme qualquer prova de $P$ em uma prova de $Q$

- **Existência**: Na lógica clássica, provar $\exists x \, P(x)$ pode ser feito mostrando que $\neg \forall x \, \neg P(x)$. Na lógica intuicionista, é necessário fornecer um exemplo específico

- **Dupla Negação**: $\neg \neg P \rightarrow P$ é válida na lógica clássica, mas não na intuicionista

Na lógica intuicionista, a negação da Lei de Peirce não é uma contradição. O princípio do terceiro excluído não é universalmente válido. Isso significa que existem modelos intuicionistas nos quais:

$$\neg(((P \rightarrow Q) \rightarrow P) \rightarrow P)$$

pode ser verdadeira, demonstrando uma diferença fundamental entre os sistemas lógicos clássico e intuicionista.

A fórmula original $(((P \rightarrow Q) \rightarrow P) \rightarrow P)$ é equivalente ao *reductio ad absurdum* e ao princípio do terceiro excluído na lógica clássica.</code></pre>
<p>:::</p>
</section>
<section id="exemplo-6" class="level4" data-number="7.1.3.6">
<h4 data-number="7.1.3.6" class="anchored" data-anchor-id="exemplo-6"><span class="header-section-number">7.1.3.6</span> Exemplo 6</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(P \rightarrow Q) \leftrightarrow (P \rightarrow R)\]</span></p>
<ol type="1">
<li><p>Começamos pela definição de equivalência e implicação:</p>
<p><span class="math display">\[(P \rightarrow Q) \leftrightarrow (P \rightarrow R)\]</span></p></li>
<li><p>Aplicamos as definições de implicação:</p>
<p><span class="math display">\[(\neg P \vee Q) \leftrightarrow (\neg P \vee R)\]</span></p></li>
<li><p>Agora, aplicamos a definição de equivalência, transformando-a em uma conjunção de duas implicações:</p>
<p><span class="math display">\[((\neg P \vee Q) \rightarrow (\neg P \vee R)) \wedge  ((\neg P \vee R) \rightarrow (\neg P \vee Q))\]</span></p></li>
<li><p>Em seguida, aplicamos a definição de implicação novamente para cada uma das implicações internas:</p>
<p><span class="math display">\[(\neg (\neg P \vee Q) \vee (\neg P \vee R)) \wedge  (\neg (\neg P \vee R) \vee (\neg P \vee Q))\]</span></p></li>
<li><p>Vamos aplicar a lei de De Morgan e a lei da dupla negação para simplificar a expressão:</p>
<p><span class="math display">\[((P \wedge  \neg Q) \vee (\neg P \vee R)) \wedge  ((P \wedge  \neg R) \vee (\neg P \vee Q))\]</span></p></li>
<li><p>Aplicando a lei distributiva para desenvolver cada conjunção interna em disjunções:</p>
<p><span class="math display">\[((P \vee (\neg P \vee R)) \wedge  (\neg Q \vee (\neg P \vee R))) \wedge  ((P \vee (\neg P \vee Q)) \wedge  (\neg R \vee (\neg P \vee Q)))\]</span></p></li>
</ol>
<p>A aplicação das equivalências não é, nem de longe, a única forma de percorrer a rota da conversão de uma <strong>Fórmula Bem Formada</strong> em Forma Normal Conjuntiva.</p>
</section>
<section id="sec-exercicios-conversao-fnc" class="level4" data-number="7.1.3.7">
<h4 data-number="7.1.3.7" class="anchored" data-anchor-id="sec-exercicios-conversao-fnc"><span class="header-section-number">7.1.3.7</span> Exercícios de Conversão para Forma Normal Conjuntiva</h4>
<p><strong>1.</strong> Converta a seguinte fórmula para Forma Normal Conjuntiva:</p>
<p><span class="math display">\[(P \leftrightarrow Q) \rightarrow ((P \wedge R) \vee (Q \wedge \neg R))\]</span></p>
<p><span class="math display">\[(P \leftrightarrow Q) \rightarrow ((P \wedge R) \vee (Q \wedge \neg R))\]</span></p>
<p><strong>2.</strong> Transforme em Forma Normal Conjuntiva a fórmula: <span class="math display">\[\neg((P \rightarrow Q) \vee (Q \rightarrow P)) \wedge (P \vee Q)\]</span></p>
<p><strong>3.</strong> Converta para Forma Normal Conjuntiva a negação de uma tautologia distributiva:</p>
<p><span class="math display">\[\neg((P \wedge (Q \vee R)) \leftrightarrow ((P \wedge Q) \vee (P \wedge R)))\]</span></p>
<p><strong>4.</strong> Obtenha a Forma Normal Conjuntiva para:</p>
<p><span class="math display">\[((P \vee Q) \rightarrow R) \leftrightarrow (P \rightarrow R) \wedge (Q \rightarrow R)\]</span></p>
<p><strong>5.</strong> Converta a seguinte fórmula complexa para Forma Normal Conjuntiva:</p>
<p><span class="math display">\[(P \rightarrow (Q \rightarrow R)) \wedge \neg((P \wedge Q) \rightarrow R)\]</span></p>
<p><strong>6.</strong> Transforme em Forma Normal Conjuntiva:</p>
<p><span class="math display">\[((P \leftrightarrow Q) \vee (Q \leftrightarrow R)) \wedge \neg(P \leftrightarrow R)\]</span></p>
<p><strong>7.</strong> Converta para Forma Normal Conjuntiva a fórmula:</p>
<p><span class="math display">\[\neg(P \rightarrow (Q \vee R)) \vee ((P \wedge \neg Q) \rightarrow R)\]</span></p>
</section>
</section>
<section id="usando-a-tabela-verdade-para-gerar-formas-normais" class="level3" data-number="7.1.4">
<h3 data-number="7.1.4" class="anchored" data-anchor-id="usando-a-tabela-verdade-para-gerar-formas-normais"><span class="header-section-number">7.1.4</span> Usando a Tabela-Verdade para Gerar Formas Normais</h3>
<p>A tabela-verdade é nosso navegador experiente que mapeia todas as rotas possíveis em águas desconhecidas das possibilidades lógicas. Como um cartógrafo naval que registra cada banco de areia e recife em uma nova rota marítima, a tabela-verdade cataloga cada combinação possível de verdades e falsidades, criando uma carta náutica completa do oceano lógico que a leitora deverá percorrer em busca da verdade.</p>
<p>Para entender este conceito com um pouco mais de formalidade, considere a <strong>Fórmula Bem Formada</strong> dada por: <span class="math inline">\((A \vee B) \rightarrow (C \wedge  \neg A)\)</span>, se encontrarmos sua Tabela Verdade, poderemos encontrar, tanto a Forma Normal Conjuntiva quanto a Forma Normal Disjuntiva. Basta fixar nosso olhar nas linhas da verdade, ou da falsidade.</p>
<section id="gerando-a-forma-normal-disjuntiva" class="level4" data-number="7.1.4.1">
<h4 data-number="7.1.4.1" class="anchored" data-anchor-id="gerando-a-forma-normal-disjuntiva"><span class="header-section-number">7.1.4.1</span> Gerando a Forma Normal Disjuntiva</h4>
<p>Para transformar <span class="math inline">\((A \vee B) \rightarrow (C \wedge \neg A)\)</span> na sua Forma Normal Conjuntiva, como um timoneiro disciplinado seguindo o roteiro de navegação, devemos seguir rigidamente, os seguintes passos:</p>
<ol type="1">
<li><p>Criar a Tabela-Verdade</p>
<p><span class="math display">\[
\begin{array}{cccc|c|c|c}
A &amp; B &amp; C &amp; \neg A &amp; A \vee B &amp; C \wedge  \neg A &amp; (A \vee B) \rightarrow (C \wedge  \neg A) \\
\hline
T &amp; T &amp; T &amp; F &amp; T &amp; F &amp; F \\
T &amp; T &amp; F &amp; F &amp; T &amp; F &amp; F \\
T &amp; F &amp; T &amp; F &amp; T &amp; F &amp; F \\
T &amp; F &amp; F &amp; F &amp; T &amp; F &amp; F \\
F &amp; T &amp; T &amp; T &amp; T &amp; T &amp; T \\
F &amp; T &amp; F &amp; T &amp; T &amp; F &amp; F \\
F &amp; F &amp; T &amp; T &amp; F &amp; T &amp; T \\
F &amp; F &amp; F &amp; T &amp; F &amp; T &amp; T \\
\end{array}
\]</span></p></li>
<li><p>Identificar as Linhas com Resultado Verdadeiro</p>
<p>As linhas 5, 7 e 8 têm resultado verdadeiro.</p></li>
<li><p>Construir a Forma Normal Disjuntiva usando as linhas com resultados verdadeiros:</p></li>
</ol>
<p>Neste passo, nosso objetivo é construir uma expressão que seja verdadeira nas linhas 5, 7 e 8 (as linhas nas quais o resultado é verdadeiro), e falsa em todos os outros casos. Para fazer isso, criamos uma disjunção (uma expressão <em>OR</em>) para cada linha verdadeira que reflete as condições das variáveis nesta linha, e então unimos essas disjunções com uma conjunção (uma operação <strong>AND</strong>) para criar a Forma Normal Disjuntiva desejada:</p>
<ol type="a">
<li><p><strong>Primeiro Termo Correspondente a Linha 5:</strong> <span class="math inline">\((\neg A \wedge  B \wedge  C)\)</span> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é verdadeiro e <span class="math inline">\(C\)</span> é verdadeiro, o que corresponde à linha 5 da tabela.</p></li>
<li><p><strong>Segundo Termo Correspondente a Linha 7:</strong> <span class="math inline">\((\neg A \wedge  \neg B \wedge  C)\)</span> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é falso e <span class="math inline">\(C\)</span> é verdadeiro, o que corresponde à linha 7 da tabela.</p></li>
<li><p><strong>Terceiro Correspondente a Linha 8:</strong> <span class="math inline">\((\neg A \wedge  \neg B \wedge  \neg C)\)</span> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é falso e <span class="math inline">\(C\)</span> é falso, o que corresponde à linha 8 da tabela.</p></li>
</ol>
<p>Finalmente, unimos estes termos com operações OR (<span class="math inline">\(\vee\)</span>) para criar a expressão Forma Normal Disjuntiva completa:</p>
<p><span class="math display">\[
(A \vee B) \rightarrow (C \wedge  \neg A) = (\neg A \wedge  B \wedge  C) \vee (\neg A \wedge  \neg B \wedge  C) \vee (\neg A \wedge  \neg B \wedge  \neg C)
\]</span></p>
<p>A expressão acima será verdadeira se qualquer um dos termos (ou seja, qualquer uma das linhas 5, 7 ou 8 da tabela) for verdadeiro, garantindo que a expressão capture exatamente as condições em que <span class="math inline">\((A \vee B) \rightarrow (C \wedge  \neg A)\)</span> é verdadeira de acordo com a tabela-verdade.</p>
</section>
<section id="gerando-a-forma-normal-conjuntiva" class="level4" data-number="7.1.4.2">
<h4 data-number="7.1.4.2" class="anchored" data-anchor-id="gerando-a-forma-normal-conjuntiva"><span class="header-section-number">7.1.4.2</span> Gerando a Forma Normal Conjuntiva</h4>
<p>Para transformar <span class="math inline">\((A \vee B) \rightarrow (C \wedge  \neg A)\)</span> em sua Forma Normal Conjuntiva usando a tabela-verdade, devemos nos concentrar nas linhas nas quais a fórmula é <strong>falsa</strong> e criar cláusulas que “proíbam” essas combinações de valores.</p>
<p><strong>Princípio fundamental</strong>: Para cada linha falsa, criamos uma cláusula que será verdadeira <strong>exceto</strong> naquela linha específica.</p>
<ol type="1">
<li><p><strong>Identificar as Linhas com Resultado Falso</strong></p>
<p>As linhas 1, 2, 3, 4 e 6 têm resultado falso.</p></li>
<li><p><strong>Construir Cláusulas Excludentes</strong>: para cada linha falsa, criamos uma cláusula que “proíbe” aquela combinação específica de valores de verdade:</p>
<p><strong>Regra de construção</strong>: Para cada linha falsa, se uma variável tem valor V (verdadeiro), colocamos sua negação na cláusula; se tem valor F (falso), colocamos a variável sem negação.</p>
<ul>
<li><strong>Linha 1</strong> (A=V, B=V, C=V): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee \neg B \vee \neg C)\)</span></li>
<li><strong>Linha 2</strong> (A=V, B=V, C=F): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee \neg B \vee C)\)</span><br>
</li>
<li><strong>Linha 3</strong> (A=V, B=F, C=V): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee B \vee \neg C)\)</span></li>
<li><strong>Linha 4</strong> (A=V, B=F, C=F): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee B \vee C)\)</span></li>
<li><strong>Linha 6</strong> (A=F, B=V, C=F): Para excluir esta combinação, criamos <span class="math inline">\((A \vee \neg B \vee C)\)</span></li>
</ul></li>
<li><p><strong>Formar a Forma Normal Conjuntiva</strong>: A conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:</p>
<p><span class="math display">\[\begin{align*}
(A \vee B) \rightarrow (C \wedge  \neg A) &amp;\equiv (\neg A \vee \neg B \vee \neg C) \\
&amp;\wedge (\neg A \vee \neg B \vee C) \\
&amp;\wedge (\neg A \vee B \vee \neg C) \\
&amp;\wedge (\neg A \vee B \vee C) \\
&amp;\wedge (A \vee \neg B \vee C)
\end{align*}\]</span></p></li>
</ol>
<p><strong>Verificação</strong>: Cada cláusula é falsa apenas na linha correspondente da tabela-verdade. A conjunção de todas as cláusulas será verdadeira exceto quando pelo menos uma cláusula for falsa, o que acontece exatamente nas linhas na quais a fórmula original é falsa.</p>
<p>A atenta leitora deve perceber que cada cláusula funciona como uma boia de sinalização que impede navegação em águas perigosas. Cada cláusula exclui uma rota específica (linha falsa) do mapa lógico, garantindo que a expressão final seja verdadeira em todas as outras rotas (linhas verdadeiras).</p>
</section>
</section>
</section>
<section id="formas-normais-lógica-predicativa-e-quantificadores" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="formas-normais-lógica-predicativa-e-quantificadores"><span class="header-section-number">7.2</span> Formas Normais, Lógica Predicativa e Quantificadores</h2>
<section id="forma-normal-prenex" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="forma-normal-prenex"><span class="header-section-number">7.2.1</span> Forma Normal Prenex</h3>
<p>A Forma Normal Prenex é como um almirante experiente organizando a cadeia de comando antes de uma operação naval complexa.</p>
<p>A criativa leitora pode imaginar uma esquadra na qual as ordens estão sendo transmitidas de forma caótica, alguns capitães recebem instruções diretas, outros recebem ordens através de subordinados, e as responsabilidades estão misturadas com as tarefas operacionais. A Forma Normal Prenex é como este almirante que, antes de qualquer manobra, convoca todos os comandantes para a ponte principal, estabelecendo claramente a hierarquia completa, quem comanda o quê e em que ordem, antes de transmitir as instruções operacionais.</p>
<p>Assim como o almirante separa completamente a estrutura de comando (todos os quantificadores universais <span class="math inline">\(\forall\)</span> e existenciais <span class="math inline">\(\exists\)</span> movidos para frente) das ordens de execução (a matriz livre de quantificadores), a Forma Normal Prenex cria uma divisão clara entre “quem decide” e “o que fazer”.</p>
<p>Com um pouco de formalidade a atenta leitora verá que a Forma Normal Prenex é uma padronização para fórmulas da lógica de primeira ordem. Nela, todos os quantificadores são deslocados para a frente da fórmula, deixando a matriz da fórmula livre de quantificadores. A Forma Normal Prenex apresenta três características principais:</p>
<ol type="1">
<li><p><strong>Facilitação da Manipulação Lógica</strong>: ao separar os quantificadores da matriz, a Forma Normal Prenex simplifica a análise e manipulação da estrutura lógica da fórmula;</p></li>
<li><p><strong>Preparação para Outras Formas Normais</strong>: serve como uma etapa intermediária na conversão para outras formas normais, como as Forma Normal Conjuntiva e Forma Normal Disjuntiva;</p></li>
<li><p><strong>Uso em Provas Automáticas</strong>: é amplamente empregada em métodos de prova automática, tornando o raciocínio sobre quantificadores mais acessível.</p></li>
</ol>
<p><strong>Exemplo de conversão para Forma Normal Prenex</strong>:</p>
<p>Considere a fórmula original que <strong>não</strong> está em Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \exists z R(z)
\]</span></p>
<p>Para convertê-la para Forma Normal Prenex, seguimos os passos:</p>
<ol type="1">
<li><strong>Padronizar variáveis</strong>: renomear variáveis para evitar conflitos</li>
</ol>
<p><span class="math display">\[
\forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \exists w R(w)
\]</span></p>
<ol start="2" type="1">
<li><strong>Eliminar implicações</strong>: substituir <span class="math inline">\(P(x) \rightarrow Q(x,y)\)</span> por <span class="math inline">\(\neg P(x) \vee Q(x,y)\)</span></li>
</ol>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y)) \wedge \exists w R(w)
\]</span></p>
<ol start="3" type="1">
<li><strong>Mover quantificadores para fora</strong>: extrair <span class="math inline">\(\exists y\)</span> e <span class="math inline">\(\exists w\)</span> para a frente, preservando a ordem relativa</li>
</ol>
<p><span class="math display">\[
\exists w \forall x \exists y (R(w) \wedge (\neg P(x) \vee Q(x,y)))
\]</span></p>
<p><strong>Exemplo de fórmula já em Forma Normal Prenex</strong>:</p>
<p>A fórmula a seguir <strong>já está</strong> em Forma Normal Prenex e não precisa de conversão:</p>
<p><span class="math display">\[
\exists x \forall y (P(x,y) \wedge Q(y))
\]</span></p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Ordem Crítica dos Quantificadores</strong></p>
<p>A ordem relativa entre quantificadores de tipos diferentes <strong>não pode ser alterada</strong> sem modificar o significado lógico:</p>
<ul>
<li><span class="math inline">\(\exists x \forall y \, P(x,y)\)</span>: “Existe um x específico que funciona para todos os y”;</li>
<li><span class="math inline">\(\forall y \exists x \, P(x,y)\)</span>: “Para cada y, pode existir um x diferente”.</li>
</ul>
<p><strong>Exemplo prático</strong>:</p>
<ul>
<li><span class="math inline">\(\exists x \forall y \, \text{AmaX}(x,y)\)</span>: “Existe uma pessoa que ama todo mundo”;</li>
<li><span class="math inline">\(\forall y \exists x \, \text{AmaX}(x,y)\)</span>: “Todo mundo é amado por alguém”.</li>
</ul>
<p>Apenas quantificadores do <strong>mesmo tipo</strong> podem ser reordenados sem alterar o significado:</p>
<ul>
<li><span class="math inline">\(\forall x \forall y \, P(x,y) \equiv \forall y \forall x \, P(x,y)\)</span>;</li>
<li><span class="math inline">\(\exists x \exists y \, P(x,y) \equiv \exists y \exists x \, P(x,y)\)</span>.</li>
</ul>
</div>
</div>
<p><strong>IMPORTANTE</strong>: Quantificadores de tipos diferentes <strong>não podem ser trocados de ordem</strong> sem alterar o significado lógico. As fórmulas <span class="math inline">\(\exists x \forall y \phi(x,y)\)</span> e <span class="math inline">\(\forall y \exists x \phi(x,y)\)</span> <strong>não são equivalentes</strong>. A primeira é logicamente mais forte (existe um <span class="math inline">\(x\)</span> específico que funciona para todos os <span class="math inline">\(y\)</span>), enquanto a segunda é mais fraca (para cada <span class="math inline">\(y\)</span>, pode existir um <span class="math inline">\(x\)</span> diferente).</p>
<p>Uma fórmula na Forma Normal Prenex segue uma estrutura específica definida por:</p>
<p><span class="math display">\[
Q_1 x_1 \, Q_2 x_2 \, \ldots \, Q_n x_n \, M(x_1, x_2, \ldots, x_n)
\]</span></p>
<p>Nessa estrutura:</p>
<ul>
<li><span class="math inline">\(Q_i\)</span> são quantificadores, podendo ser universais <span class="math inline">\(\forall\)</span> ou existenciais <span class="math inline">\(\exists\)</span>;</li>
<li><span class="math inline">\(x_i\)</span> são as variáveis vinculadas pelos quantificadores;</li>
<li><span class="math inline">\(M(x_1, x_2, \ldots, x_n)\)</span> representa a matriz da fórmula, uma expressão lógica sem quantificadores.</li>
</ul>
<p>Converter uma fórmula para a Forma Normal Prenex envolve os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação por disjunções e negações;</p></li>
<li><p><strong>Mover Negações para Dentro</strong>: use as leis de De Morgan para mover as negações para dentro dos quantificadores e proposições;</p></li>
<li><p><strong>Padronizar Variáveis</strong>: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas;</p></li>
<li><p><strong>Mover Quantificadores para Fora</strong>: mova todos os quantificadores para a esquerda da expressão, mantendo a ordem relativa quando necessário para preservar o significado.</p></li>
</ol>
<p>A Forma Normal Prenex é uma representação canônica de fórmulas da lógica de primeira ordem que separa claramente os quantificadores da matriz da fórmula. Ela é uma ferramenta amplamente utilizada na lógica e na teoria da prova, e sua compreensão é essencial para trabalhar com lógica de primeira ordem, especialmente na <strong>Lógica de Primeira Ordem</strong> e teoria da prova, ambas aplicadas na Programação Lógica.</p>
<section id="regras-de-equivalência-prenex" class="level4" data-number="7.2.1.1">
<h4 data-number="7.2.1.1" class="anchored" data-anchor-id="regras-de-equivalência-prenex"><span class="header-section-number">7.2.1.1</span> Regras de Equivalência Prenex</h4>
<p>A Forma Prenex de uma fórmula lógica com quantificadores contém todos os quantificadores para o início da fórmula. Existem algumas regras de equivalência que preservam a Forma Prenex quando aplicadas a uma fórmula:</p>
<p><strong>1. Comutatividade de quantificadores do mesmo tipo</strong>: a ordem dos quantificadores do mesmo tipo pode ser trocada em uma fórmula na Forma Prenex. Por exemplo:</p>
<p><span class="math display">\[
\forall x \forall y \ P(x,y) \Leftrightarrow \forall y \forall x \ P(x,y)
\]</span></p>
<p>Isso ocorre porque a ordem dos quantificadores universais <span class="math inline">\(\forall x\)</span> e <span class="math inline">\(\forall y\)</span> não altera o significado lógico da fórmula. Essa propriedade é conhecida como comutatividade dos quantificadores.</p>
<p><strong>2. Associatividade de quantificadores do mesmo tipo</strong>: quantificadores do mesmo tipo podem ser agrupados de forma associativa em uma Forma Prenex. Por exemplo:</p>
<p><span class="math display">\[
\forall x \forall y \forall z \ P(x,y,z) \Leftrightarrow \forall x (\forall y \forall z \ P(x,y,z))
\]</span></p>
<p>Novamente, o agrupamento dos quantificadores universais não muda o significado da fórmula. Essa é a propriedade associativa.</p>
<p><strong>3. Distributividade de quantificadores sobre operadores lógicos</strong>: existem regras específicas para a distribuição de quantificadores:</p>
<ul>
<li>O quantificador universal distribui sobre conjunção:</li>
</ul>
<p><span class="math display">\[
\forall x (P(x) \wedge Q(x)) \Leftrightarrow (\forall x \ P(x)) \wedge (\forall x \ Q(x))
\]</span></p>
<ul>
<li>O quantificador existencial distribui sobre disjunção:</li>
</ul>
<p><span class="math display">\[
\exists x (P(x) \vee Q(x)) \Leftrightarrow (\exists x \ P(x)) \vee (\exists x \ Q(x))
\]</span></p>
<p>Note que <span class="math inline">\(\forall\)</span> não distribui sobre <span class="math inline">\(\vee\)</span> e <span class="math inline">\(\exists\)</span> não distribui sobre <span class="math inline">\(\wedge\)</span>.</p>
</section>
<section id="conversão-para-formas-normais-conjuntiva-e-disjuntiva" class="level4" data-number="7.2.1.2">
<h4 data-number="7.2.1.2" class="anchored" data-anchor-id="conversão-para-formas-normais-conjuntiva-e-disjuntiva"><span class="header-section-number">7.2.1.2</span> Conversão para Formas Normais Conjuntiva e Disjuntiva</h4>
<p>A conversão para formas clausais (CNF/DNF) em lógica de primeira ordem segue estes passos:</p>
<p><strong>1. Eliminar Implicações</strong>: substitua todas as ocorrências de implicação da forma <span class="math inline">\(A \rightarrow B\)</span> por <span class="math inline">\(\neg A \vee B\)</span>.</p>
<p><strong>2. Mover a Negação para Dentro</strong>: use as leis de De Morgan para mover a negação para dentro dos quantificadores e das proposições:</p>
<ul>
<li><span class="math inline">\(\neg \forall x P(x) \Leftrightarrow \exists x \neg P(x)\)</span></li>
<li><span class="math inline">\(\neg \exists x P(x) \Leftrightarrow \forall x \neg P(x)\)</span></li>
</ul>
<p><strong>3. Padronizar Variáveis</strong>: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas, renomeando-as se necessário.</p>
<p><strong>4. Converter para Forma Normal Prenex</strong>: mova todos os quantificadores para o prefixo, preservando a ordem relativa.</p>
<p><strong>5. Eliminar os Quantificadores Existenciais (Skolemização)</strong>: substitua cada quantificador existencial <span class="math inline">\(\exists x\)</span> por um novo termo constante ou Função Skolem, dependendo das variáveis quantificadas universalmente à esquerda no prefixo Prenex:</p>
<ol type="1">
<li><p><strong>Se o quantificador existencial não tem quantificadores universais à sua esquerda</strong>: Substitua <span class="math inline">\(\exists x P(x)\)</span> por <span class="math inline">\(P(c)\)</span>, sendo que <span class="math inline">\(c\)</span> é uma nova constante.</p></li>
<li><p><strong>Se o quantificador existencial tem quantificadores universais à sua esquerda</strong>: Substitua <span class="math inline">\(\exists x P(x)\)</span> por <span class="math inline">\(P(\mathbf{\mathbf{f}}(y_1, y_2, \ldots, y_n))\)</span>, sendo que <span class="math inline">\(\mathbf{\mathbf{f}}\)</span> é uma nova função Skolem, e <span class="math inline">\(y_1, y_2, \ldots, y_n\)</span> são as variáveis universais à esquerda do quantificador existencial.</p></li>
</ol>
<p><strong>6. Eliminar os Quantificadores Universais</strong>: remova os quantificadores universais, deixando apenas a matriz da fórmula. As variáveis que eram ligadas pelo quantificador universal agora são tratadas como variáveis livres na matriz da fórmula.</p>
<p><strong>7. Conversão para Forma Normal Conjuntiva ou Forma Normal Disjuntiva</strong>:</p>
<ul>
<li><strong>Para Forma Normal Conjuntiva</strong>: use as leis distributivas para converter a matriz em uma conjunção de disjunções (cláusulas)</li>
<li><strong>Para Forma Normal Disjuntiva</strong>: use as leis distributivas para converter a matriz em uma disjunção de conjunções</li>
</ul>
</section>
<section id="exemplo-1---duas-fórmulas-logicamente-equivalentes" class="level4" data-number="7.2.1.3">
<h4 data-number="7.2.1.3" class="anchored" data-anchor-id="exemplo-1---duas-fórmulas-logicamente-equivalentes"><span class="header-section-number">7.2.1.3</span> Exemplo 1 - Duas fórmulas logicamente equivalentes</h4>
<p>Vamos considerar duas fórmulas logicamente equivalentes, uma na Forma Prenex e outra não. Considere a fórmula original:</p>
<p><span class="math display">\[
\forall x \exists y (P(x) \rightarrow Q(y))
\]</span></p>
<p>Se convertida para a Forma Prenex teremos:</p>
<p><span class="math display">\[
\exists y \forall x (P(x) \rightarrow Q(y))
\]</span></p>
<p>A equivalência pode ser demonstrada por meio do seguinte raciocínio: seja <span class="math inline">\(I\)</span> uma interpretação (estrutura) para os predicados <span class="math inline">\(P\)</span> e <span class="math inline">\(Q\)</span> em um domínio não vazio.</p>
<p>Suponha <span class="math inline">\(I\)</span> satisfaz <span class="math inline">\(\forall x \exists y (P(x) \rightarrow Q(y))\)</span>. Existem dois casos a considerar:</p>
<ul>
<li>Se não existe nenhum <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> seja verdadeiro, então a implicação é vacuamente verdadeira para todos os <span class="math inline">\(x\)</span>, e qualquer <span class="math inline">\(y\)</span> satisfará <span class="math inline">\(\exists y \forall x (P(x) \rightarrow Q(y))\)</span></li>
<li>Se existe pelo menos um <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> é verdadeiro, então deve existir um <span class="math inline">\(y\)</span> correspondente tal que <span class="math inline">\(Q(y)\)</span> é verdadeiro. Este mesmo <span class="math inline">\(y\)</span> funcionará para todos os <span class="math inline">\(x\)</span>, satisfazendo <span class="math inline">\(\exists y \forall x (P(x) \rightarrow Q(y))\)</span></li>
</ul>
<p>Assim, existe um <span class="math inline">\(y\)</span> fixo que satisfaz a condição para todo <span class="math inline">\(x\)</span>, preservando a equivalência. O raciocínio inverso também se aplica. Portanto, as fórmulas são logicamente equivalentes.</p>
</section>
<section id="exemplo-2---conversão-para-forma-prenex" class="level4" data-number="7.2.1.4">
<h4 data-number="7.2.1.4" class="anchored" data-anchor-id="exemplo-2---conversão-para-forma-prenex"><span class="header-section-number">7.2.1.4</span> Exemplo 2 - Conversão para Forma Prenex</h4>
<p>A fórmula:</p>
<p><span class="math display">\[
\forall x (P(x) \rightarrow \exists y Q(x,y))
\]</span></p>
<p>Pode ser convertida para Forma Normal Prenex seguindo os passos:</p>
<ol type="1">
<li><strong>Eliminar implicação</strong>: substituir <span class="math inline">\(P(x) \rightarrow \exists y Q(x,y)\)</span> por <span class="math inline">\(\neg P(x) \vee \exists y Q(x,y)\)</span></li>
</ol>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y))
\]</span></p>
<ol start="2" type="1">
<li><strong>Mover quantificadores para fora</strong>: extrair <span class="math inline">\(\exists y\)</span> para a frente, preservando a ordem (<span class="math inline">\(\forall\)</span> antes de <span class="math inline">\(\exists\)</span>)</li>
</ol>
<p><span class="math display">\[
\forall x \exists y (\neg P(x) \vee Q(x,y))
\]</span></p>
<p>A ordem dos quantificadores deve ser preservada para manter o significado original da fórmula.</p>
</section>
<section id="exemplo-3---conversão-para-forma-normal-conjuntiva" class="level4" data-number="7.2.1.5">
<h4 data-number="7.2.1.5" class="anchored" data-anchor-id="exemplo-3---conversão-para-forma-normal-conjuntiva"><span class="header-section-number">7.2.1.5</span> Exemplo 3 - Conversão para Forma Normal Conjuntiva</h4>
<p>Considere a fórmula original em Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x \exists y (P(x) \wedge Q(y))
\]</span></p>
<p>Siga os passos para conversão para Forma Normal Conjuntiva:</p>
<ol type="1">
<li><strong>Eliminar os Quantificadores Existenciais (Skolemização)</strong>: O quantificador existencial <span class="math inline">\(\exists y\)</span> tem um quantificador universal <span class="math inline">\(\forall x\)</span> à sua esquerda, então substitua por uma função Skolem <span class="math inline">\(\mathbf{\mathbf{f}}(x)\)</span>:</li>
</ol>
<p><span class="math display">\[
\forall x (P(x) \wedge Q(\mathbf{\mathbf{f}}(x)))
\]</span></p>
<ol start="2" type="1">
<li><strong>Eliminar os Quantificadores Universais</strong>: Remova <span class="math inline">\(\forall x\)</span>, tratando <span class="math inline">\(x\)</span> como variável livre:</li>
</ol>
<p><span class="math display">\[
P(x) \wedge Q(\mathbf{\mathbf{f}}(x))
\]</span></p>
<ol start="3" type="1">
<li><strong>Conversão para Forma Normal Conjuntiva</strong>: A matriz já é uma conjunção de literais, resultando em cláusulas:</li>
</ol>
<p><span class="math display">\[
P(x) \wedge Q(\mathbf{\mathbf{f}}(x))
\]</span></p>
<p>Isso equivale a duas cláusulas: <span class="math inline">\(\{P(x)\}\)</span> e <span class="math inline">\(\{Q(\mathbf{f}(x))\}\)</span>.</p>
</section>
<section id="exemplo-4-fórmula-complexa-com-estrutura-mista" class="level4" data-number="7.2.1.6">
<h4 data-number="7.2.1.6" class="anchored" data-anchor-id="exemplo-4-fórmula-complexa-com-estrutura-mista"><span class="header-section-number">7.2.1.6</span> Exemplo 4: Fórmula Complexa com Estrutura Mista</h4>
<p><strong>Fórmula Original</strong>:</p>
<p><span class="math display">\[
\forall x (\exists y \, P(x,y) \rightarrow \forall z \exists w \, R(x,z,w))
\]</span></p>
<p><strong>Conversão para Forma Normal Prenex</strong>:</p>
<p>Precisamos mover todos os quantificadores para o início da fórmula, seguindo as regras de equivalência lógica.</p>
<p><strong>Passo 1</strong>: Renomear variáveis ligadas para evitar conflitos. Como não há variáveis com mesmo nome em escopos diferentes, podemos prosseguir.</p>
<p><strong>Passo 2</strong>: Eliminar a implicação usando <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>:</p>
<p><span class="math display">\[
\forall x (\neg \exists y \, P(x,y) \vee \forall z \exists w \, R(x,z,w))
\]</span></p>
<p><strong>Passo 3</strong>: Aplicar a negação ao quantificador existencial usando <span class="math inline">\(\neg \exists y \, P(x,y) \equiv \forall y \neg P(x,y)\)</span>:</p>
<p><span class="math display">\[
\forall x (\forall y \neg P(x,y) \vee \forall z \exists w \, R(x,z,w))
\]</span></p>
<p><strong>Passo 4</strong>: Mover os quantificadores internos para fora. Para mover quantificadores através de disjunção, precisamos garantir que as variáveis não ocorrem livres no outro disjunto:</p>
<ul>
<li><span class="math inline">\(\forall y\)</span> pode sair já que <span class="math inline">\(y\)</span> não ocorre em <span class="math inline">\(R(x,z,w)\)</span>;</li>
<li><span class="math inline">\(\forall z\)</span> e <span class="math inline">\(\exists w\)</span> podem sair, isso porque <span class="math inline">\(z\)</span> e <span class="math inline">\(w\)</span> não ocorrem em <span class="math inline">\(P(x,y)\)</span>.</li>
</ul>
<p><span class="math display">\[
\forall x \forall y \forall z \exists w (\neg P(x,y) \vee R(x,z,w))
\]</span></p>
<p>Nota: Quando movemos <span class="math inline">\(\forall\)</span> através de <span class="math inline">\(\vee\)</span>, usamos a equivalência: <span class="math inline">\((\forall y \, A(y)) \vee B \equiv \forall y \, (A(y) \vee B)\)</span> quando <span class="math inline">\(y\)</span> não ocorre livre em <span class="math inline">\(B\)</span>.</p>
<p><strong>Passo 5</strong>: Reordenar quantificadores (opcional para clareza). Como quantificadores universais consecutivos podem ser permutados, podemos manter a ordem atual:</p>
<p><span class="math display">\[
\forall x \exists y \forall z \exists w (\neg P(x,y) \vee R(x,z,w))
\]</span></p>
<p>Note que reordenamos para <span class="math inline">\(\exists y\)</span> antes de <span class="math inline">\(\forall z\)</span> para manter uma apresentação mais natural, mas isso não afeta a skolemização.</p>
<p><strong>Aplicação da Skolemização</strong>:</p>
<p>Agora identificamos as variáveis existenciais e suas dependências:</p>
<ol type="1">
<li><span class="math inline">\(\exists y\)</span>: Precedido por <span class="math inline">\(\forall x\)</span> Função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span></li>
<li><span class="math inline">\(\exists w\)</span>: Precedido por <span class="math inline">\(\forall x\)</span> e <span class="math inline">\(\forall z\)</span> Função Skolem <span class="math inline">\(\mathbf{f}(x,z)\)</span></li>
</ol>
<p><strong>Resultado após Skolemização</strong>:</p>
<p><span class="math display">\[
\forall x \forall z (\neg P(x, \mathbf{f}(x)) \vee R(x, z, \mathbf{f}(x,z)))
\]</span></p>
<p><strong>Forma com Quantificadores Implícitos</strong>:</p>
<p><span class="math display">\[
\neg P(x, \mathbf{f}(x)) \vee R(x, z, \mathbf{f}(x,z))
\]</span></p>
<p><strong>Observação</strong>: Esta última fórmula representa uma cláusula na Forma Normal Conjuntiva, pronta para uso em métodos de inferência como a resolução. A função <span class="math inline">\(\mathbf{f}(x)\)</span> captura a dependência de <span class="math inline">\(y\)</span> em relação a <span class="math inline">\(x\)</span>, enquanto <span class="math inline">\(\mathbf{f}(x,z)\)</span> captura a dependência de <span class="math inline">\(w\)</span> em relação tanto a <span class="math inline">\(x\)</span> quanto a <span class="math inline">\(z\)</span>.</p>
</section>
<section id="exemplo-5---conversão-para-forma-normal-conjuntiva" class="level4" data-number="7.2.1.7">
<h4 data-number="7.2.1.7" class="anchored" data-anchor-id="exemplo-5---conversão-para-forma-normal-conjuntiva"><span class="header-section-number">7.2.1.7</span> Exemplo 5 - Conversão para Forma Normal Conjuntiva</h4>
<p>Considere a fórmula original em Forma Normal Prenex:</p>
<p><span class="math display">\[
\exists x \forall y (P(x) \vee Q(y))
\]</span></p>
<p>Siga os passos para conversão para Forma Normal Conjuntiva:</p>
<ol type="1">
<li><strong>Eliminar os Quantificadores Existenciais (Skolemização)</strong>: O quantificador existencial <span class="math inline">\(\exists x\)</span> não tem quantificadores universais à sua esquerda, então substitua por uma constante Skolem <span class="math inline">\(c\)</span>:</li>
</ol>
<p><span class="math display">\[
\forall y (P(c) \vee Q(y))
\]</span></p>
<ol start="2" type="1">
<li><strong>Eliminar os Quantificadores Universais</strong>: Remova <span class="math inline">\(\forall y\)</span>:</li>
</ol>
<p><span class="math display">\[
P(c) \vee Q(y)
\]</span></p>
<ol start="3" type="1">
<li><strong>Conversão para Forma Normal Conjuntiva</strong>: A matriz é uma disjunção, resultando em uma cláusula única:</li>
</ol>
<p><span class="math display">\[
P(c) \vee Q(y)
\]</span></p>
<p>Isso equivale à cláusula: <span class="math inline">\(\{P(c), Q(y)\}\)</span>.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Preservação vs.&nbsp;Equivalência na Skolemização</strong></p>
<p>A Skolemização é um processo que preserva a satisfatibilidade mas <strong>não preserva a equivalência lógica</strong>. Isso significa:</p>
<ul>
<li>Se a fórmula original é satisfatível, a fórmula skolemizada também será;</li>
<li>Se a fórmula original é insatisfatível, a fórmula skolemizada também será;</li>
<li>Porém, a fórmula skolemizada pode ser verdadeira em modelos onde a original é falsa.</li>
</ul>
<p>Esta distinção é fundamental em:</p>
<ul>
<li><strong>Provas por refutação</strong>: nas quais buscamos inconsistência (adequado para Skolemização);</li>
<li><strong>Verificação de modelos</strong>: na qual precisamos preservar verdade (Skolemização inadequada);</li>
<li><strong>Sistemas como Prolog</strong>: que utilizam formas clausais skolemizadas para inferência.</li>
</ul>
<p>Por isso a Skolemização é apropriada para métodos de prova automática como resolução, mas não para verificação direta de satisfação de fórmulas.</p>
<p>A esforçada leitora deve entender a diferença entre preservar satisfatibilidade e preservar equivalência lógica:</p>
<ul>
<li><p><strong>Preservação de Satisfatibilidade</strong>: Se existe um modelo <span class="math inline">\(\mathcal{M}\)</span> que satisfaz a fórmula original <span class="math inline">\(\phi\)</span>, então existe um modelo <span class="math inline">\(\mathcal{M}'\)</span> (possivelmente expandido) que satisfaz <span class="math inline">\(\text{Skolem}(\phi)\)</span>. Reciprocamente, se <span class="math inline">\(\text{Skolem}(\phi)\)</span> é satisfatível, então <span class="math inline">\(\phi\)</span> também é satisfatível.</p></li>
<li><p><strong>Não-Preservação de Equivalência</strong>: As fórmulas <span class="math inline">\(\phi\)</span> e <span class="math inline">\(\text{Skolem}(\phi)\)</span> não são logicamente equivalentes porque:</p>
<ul>
<li>As funções Skolem introduzem novos símbolos funcionais que não existiam no vocabulário original</li>
<li>A interpretação destes novos símbolos é fixada de forma específica</li>
<li>A fórmula skolemizada é mais “específica” que a original</li>
</ul></li>
</ul>
<p><strong>Exemplo Ilustrativo</strong>: Considere a fórmula <span class="math inline">\(\exists x \, P(x)\)</span>. Após skolemização, obtemos <span class="math inline">\(P(c)\)</span>, onde <span class="math inline">\(c\)</span> é uma constante Skolem.</p>
<ul>
<li>A fórmula original afirma: “existe algum elemento com propriedade <span class="math inline">\(P\)</span>”</li>
<li>A fórmula skolemizada afirma: “o elemento específico <span class="math inline">\(c\)</span> tem propriedade <span class="math inline">\(P\)</span>”</li>
</ul>
<p>Embora ambas sejam satisfatíveis nos mesmos casos (quando há pelo menos um elemento com propriedade <span class="math inline">\(P\)</span>), elas não são equivalentes. A segunda faz uma afirmação mais forte sobre um elemento específico.</p>
<p>Esta distinção é fundamental para entender por que a Skolemização é adequada para provar teoremas (onde só precisamos preservar satisfatibilidade) mas não para transformações que exigem equivalência lógica exata.</p>
</div>
</div>
<blockquote class="blockquote">
<p>A conversão para Forma Normal Conjuntiva, forma clausal, é amplamente utilizada em métodos de prova automática como resolução. A conversão para Forma Normal Disjuntiva é menos comum, mas pode ser aplicada em alguns contextos de análise lógica. <strong>OBSERVAÇÃO: a Skolemização, eliminação dos quantificadores existenciais, pode alterar a interpretação da fórmula em alguns modelos, mas preserva a satisfatibilidade, sendo apropriada para provas automáticas</strong>.</p>
</blockquote>
</section>
<section id="sec-exercicios-conversao-forma-normal-prenex" class="level4" data-number="7.2.1.8">
<h4 data-number="7.2.1.8" class="anchored" data-anchor-id="sec-exercicios-conversao-forma-normal-prenex"><span class="header-section-number">7.2.1.8</span> Exercícios de Conversão para Forma Normal Prenex</h4>
<p><strong>1.</strong> Converta a seguinte fórmula para Forma Normal Prenex:</p>
<p><span class="math display">\[
P(x) \wedge \forall y Q(y)
\]</span></p>
<p><strong>2.</strong> Converta a fórmula abaixo para Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x (P(x) \rightarrow Q(x)) \wedge \exists y R(y)
\]</span></p>
<p><strong>3.</strong> Transforme a seguinte fórmula em Forma Normal Prenex:</p>
<p><span class="math display">\[
\neg \forall x P(x) \vee \exists y Q(y)
\]</span></p>
<p><strong>4.</strong> Converta para Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x \exists y P(x,y) \rightarrow \exists z \forall w Q(z,w)
\]</span></p>
<p><strong>5.</strong> Transforme a fórmula em Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x (P(x) \leftrightarrow \exists y Q(x,y)) \vee \forall z R(z)
\]</span></p>
<p><strong>6.</strong> Converta para Forma Normal Prenex:</p>
<p><span class="math display">\[
\neg(\forall x (P(x) \rightarrow \exists y Q(x,y))) \wedge \exists z (\forall w R(z,w) \vee S(z))
\]</span></p>
<p><strong>7.</strong> Transforme a seguinte fórmula em Forma Normal Prenex:</p>
<p>$ (x y P(x,y)) (z (Q(z) w R(z,w)) u S(u)) $</p>
</section>
</section>
<section id="skolemização" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="skolemização"><span class="header-section-number">7.2.2</span> Skolemização</h3>
<p>A Skolemização é como um pescador veterano que transforma indicações vagas de cardumes em coordenadas precisas de pesca. Quando encontramos uma afirmação do tipo ‘há peixes por aqui’, a Skolemização nos permite dizer ’muito bem, vamos marcar este ponto específico no GPS”.</p>
<p>A criativa leitora pode se imaginar como um mestre de porto organizando o registro de embarcações: em vez de deixar referências vagas como ‘existe um navio cargueiro’, o mestre de porto cria um sistema de registro que permite localizar exatamente qual embarcação estamos procurando, baseados nas necessidades que definem nossos critérios de busca.</p>
<p>Formalmente a <strong>Skolemização</strong> é um procedimento algorítmico que elimina quantificadores existenciais de fórmulas lógicas de primeira ordem, substituindo variáveis existencialmente quantificadas por termos funcionais específicos. Este processo preserva a satisfatibilidade da fórmula original, mas não preserva a equivalência lógica. Matematicamente dizemos:</p>
<p>Dada uma fórmula <span class="math inline">\(\phi\)</span> em Forma Normal Prenex:</p>
<p><span class="math display">\[
Q_1 x_1 \, Q_2 x_2 \, \ldots \, Q_n x_n \, M(x_1, x_2, \ldots, x_n)
\]</span></p>
<p>Na qual <span class="math inline">\(Q_i \in \{\forall, \exists\}\)</span> e <span class="math inline">\(M\)</span> é a matriz livre de quantificadores, a Skolemização procede da seguinte forma:</p>
<p>Para cada quantificador existencial <span class="math inline">\(\exists x_i\)</span> na sequência de quantificadores:</p>
<ol type="1">
<li><p><strong>Se não há quantificadores universais precedentes</strong>: substitua <span class="math inline">\(x_i\)</span> por uma <strong>Constante Skolem</strong> <span class="math inline">\(c_i\)</span>. A <strong>Constante Skolem</strong> é como batizar um navio com nome fixo, “Santa Maria sempre será Santa Maria”, independente da rota ou tripulação.</p></li>
<li><p><strong>Se há quantificadores universais</strong> <span class="math inline">\(\forall y_1, \forall y_2, \ldots, \forall y_k\)</span> precedentes: substitua <span class="math inline">\(x_i\)</span> por uma <strong>Função Skolem</strong> <span class="math inline">\(\mathbf{f}_i(y_1, y_2, \ldots, y_k)\)</span>. A <strong>Função Skolem</strong> é como designar um papel dinâmico, “o navio de apoio da embarcação principal”, no qual a identidade específica muda dependendo de qual é a embarcação principal, mas a relação permanece consistente.</p></li>
</ol>
<p>Para entender a skolemização vamos usar a seguinte notação:</p>
<ul>
<li><strong>Constantes Skolem</strong>: <span class="math inline">\(c, c_1, c_2, \ldots\)</span>;</li>
<li><strong>Funções Skolem</strong>: <span class="math inline">\(\mathbf{f}(x), \mathbf{f}(x,y), \mathbf{h}(x,y,z), \ldots\)</span>;</li>
<li><strong>Resultado da Skolemização de</strong> <span class="math inline">\(\phi\)</span>: <span class="math inline">\(Skolem(\phi)\)</span>.</li>
</ul>
<p>Antes de vermos os exemplos, é importante entender o que a Skolemização de fato realiza. Ela transforma uma fórmula, mas não de qualquer maneira. O processo garante alguns resultados importantes, enquanto altera outros. Pense nisso como as “regras de navegação” do nosso mestre de porto:</p>
<ol type="1">
<li><p><strong>A possibilidade de sucesso é mantida.</strong> Se a afirmação original “há peixes por aqui” (<span class="math inline">\(\phi\)</span>) era verdadeira (ou seja, era <em>satisfatível</em>), então a nova afirmação “vamos pescar neste ponto específico <span class="math inline">\(c\)</span>” (<span class="math inline">\(Skolem(\phi)\)</span>) também pode ser verdadeira. A Skolemização não inventa uma solução que não existia, ela apenas dá um nome concreto a uma possibilidade que já era válida. Por isso, dizemos que ela <strong>preserva a satisfatibilidade</strong>.</p></li>
<li><ol start="2" type="1">
<li><strong>A nova fórmula é mais específica que a original.</strong> Este é um ponto-chave. A afirmação “existe um navio cargueiro” não tem o mesmo significado lógico que “o navio em questão é o <em>Pérola Negra</em>”. A segunda é uma versão muito mais comprometida da primeira, pois faz uma escolha existencial específica via constantes ou funções Skolem. Formalmente, a fórmula skolemizada <span class="math inline">\(Skolem(\phi)\)</span> implica logicamente a fórmula original <span class="math inline">\(\phi\)</span> (ou seja, <span class="math inline">\(Skolem(\phi) \models \phi\)</span>), mas o inverso não é verdadeiro, já que <span class="math inline">\(\phi\)</span> permite múltiplas escolhas existenciais, enquanto <span class="math inline">\(Skolem(\phi)\)</span> se compromete com uma específica. Por isso, a fórmula skolemizada <strong>não é logicamente equivalente</strong> à original.</li>
</ol></li>
<li><p><strong>As ambiguidades “existe um…” são eliminadas.</strong> Este é o objetivo central do processo. Ao final, não teremos mais quantificadores existenciais. Todas as referências vagas são substituídas por “coordenadas no GPS” (constantes) ou por “funções de apoio” (funções Skolem).</p></li>
<li><p><strong>As dependências são mapeadas de forma clara.</strong> Quando a identidade de um elemento depende de outro (o “navio de apoio” que depende da “embarcação principal” <span class="math inline">\(\forall x\)</span>), a função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span> garante que essa relação seja consistente e determinística. Para cada <span class="math inline">\(x\)</span>, a escolha de <span class="math inline">\(y\)</span> será sempre a mesma.</p></li>
</ol>
<p>Com estas regras em mente, vamos ver como o processo funciona na prática, começando com um exemplo simples que envolve um quantificador universal e um existencial.</p>
<p>Considere a fórmula:</p>
<p><span class="math display">\[\forall x \exists y P(x,y)\]</span></p>
<p>Ao aplicar a Skolemização, a variável existencial <span class="math inline">\(y\)</span> é substituída por uma Função de Skolem <span class="math inline">\(\mathbf{f}(x)\)</span>:</p>
<p><span class="math display">\[P(x,\mathbf{f}(x))\]</span></p>
<p>Para uma fórmula com dois quantificadores universais e dois existenciais:</p>
<p><span class="math display">\[\forall x \forall z \exists y \exists w R(x,y,z,w)\]</span></p>
<p>A Skolemização resultará em:</p>
<p><span class="math display">\[\forall x \forall z R(x,\mathbf{f}(x),z,\mathbf{g}(x,z))\]</span></p>
<p><span class="math inline">\(\mathbf{f}(x)\)</span> e $ (x,z)$ são Funções Skolem introduzidas para substituir as variáveis existenciais <span class="math inline">\(y\)</span> e $w $ respectivamente. A escolha entre Constante e Função Skolem é como decidir entre definir valores definitivos ou sua ação e aplicação:</p>
<p>Se nossa expedição marítima já tem os tripulantes estabelecidos, as variáveis universais, então nosso novo tripulante existencial precisa se adaptar a eles através de uma função. Isso pode ser feito com as fórmulas lógicas seguindo os seguintes passos:</p>
<p><strong>Passo 1: Identificar os Quantificadores Existenciais</strong>: comece identificando os quantificadores existenciais na fórmula.</p>
<p><strong>Passo 2: Determinar se a Variável Existencial Depende de Variáveis Universais</strong>: para cada variável ligada a um quantificador existencial, determinamos se ela depende ou não de alguma variável universal. Isso significa verificar se existem quantificadores universais que precedem (ou “dominam”) a variável existencial na sequência de quantificadores da forma prenex.</p>
<ul>
<li>Um quantificador universal <span class="math inline">\(\forall x\)</span> <strong>precede</strong> ou <strong>domina</strong> um quantificador existencial <span class="math inline">\(\exists y\)</span> quando <span class="math inline">\(\forall x\)</span> aparece à esquerda de <span class="math inline">\(\exists y\)</span> na forma prenex;</li>
<li>A variável existencial <strong>depende</strong> de todas as variáveis universais que a precedem;</li>
<li>Se a variável existencial não é precedida por nenhum quantificador universal, usamos uma <strong>Constante de Skolem</strong>;</li>
<li>Se a variável existencial é precedida por variáveis universais <span class="math inline">\(x_1, x_2, \ldots, x_k\)</span>, usamos uma <strong>Função de Skolem</strong> <span class="math inline">\(\mathbf{f}(x_1, x_2, \ldots, x_k)\)</span> que recebe como parâmetros exatamente essas variáveis.</li>
</ul>
<p><strong>Exemplo de precedência</strong>: Na fórmula <span class="math inline">\(\forall x \exists y \forall z \exists w \, P(x,y,z,w)\)</span>:</p>
<ul>
<li><span class="math inline">\(\exists y\)</span> é precedido apenas por <span class="math inline">\(\forall x\)</span>, logo usamos <span class="math inline">\(\mathbf{f}(x)\)</span>;</li>
<li><span class="math inline">\(\exists w\)</span> é precedido por <span class="math inline">\(\forall x\)</span> e <span class="math inline">\(\forall z\)</span>, logo usamos <span class="math inline">\(\mathbf{g}(x,z)\)</span>.</li>
</ul>
<p><strong>Passo 3: Substituir as Variáveis Existenciais</strong>: agora, substituímos todas as variáveis existenciais na fórmula original de acordo com as decisões tomadas no Passo 2. Se usarmos Constantes de Skolem, substituímos as variáveis existenciais diretamente pelas constantes. Se usarmos Funções de Skolem, substituímos as variáveis existenciais pelas funções de Skolem aplicadas às variáveis universais apropriadas.</p>
<section id="exemplo-1-quantificador-existencial-simples" class="level4" data-number="7.2.2.1">
<h4 data-number="7.2.2.1" class="anchored" data-anchor-id="exemplo-1-quantificador-existencial-simples"><span class="header-section-number">7.2.2.1</span> Exemplo 1: Quantificador Existencial Simples</h4>
<p><strong>Fórmula Original</strong>:</p>
<p><span class="math display">\[
\exists x \, P(x)
\]</span></p>
<p><strong>Aplicação da Skolemização</strong>:</p>
<ul>
<li>O quantificador existencial <span class="math inline">\(\exists x\)</span> não possui quantificadores universais precedentes;</li>
<li>Substituímos <span class="math inline">\(x\)</span> por uma Constante Skolem <span class="math inline">\(c\)</span>.</li>
</ul>
<p><strong>Resultado</strong>:</p>
<p><span class="math display">\[
P(c)
\]</span></p>
</section>
<section id="exemplo-2-universal-seguido-de-existencial" class="level4" data-number="7.2.2.2">
<h4 data-number="7.2.2.2" class="anchored" data-anchor-id="exemplo-2-universal-seguido-de-existencial"><span class="header-section-number">7.2.2.2</span> Exemplo 2: Universal Seguido de Existencial</h4>
<p><strong>Fórmula Original</strong>:</p>
<p><span class="math display">\[
\forall x \exists y \, R(x,y)
\]</span></p>
<p><strong>Aplicação da Skolemização</strong>:</p>
<ul>
<li>O quantificador existencial <span class="math inline">\(\exists y\)</span> é precedido pelo quantificador universal <span class="math inline">\(\forall x\)</span></li>
<li>Substituímos <span class="math inline">\(y\)</span> por uma Função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span> que depende de <span class="math inline">\(x\)</span></li>
</ul>
<p><strong>Resultado</strong>:</p>
<p><span class="math display">\[
\forall x \, R(x, \mathbf{f}(x))
\]</span></p>
<p><strong>Forma com Quantificadores Implícitos</strong>:</p>
<p><span class="math display">\[
R(x, \mathbf{f}(x))
\]</span></p>
</section>
<section id="exemplo-3-múltiplos-quantificadores-com-dependências" class="level4" data-number="7.2.2.3">
<h4 data-number="7.2.2.3" class="anchored" data-anchor-id="exemplo-3-múltiplos-quantificadores-com-dependências"><span class="header-section-number">7.2.2.3</span> Exemplo 3: Múltiplos Quantificadores com Dependências</h4>
<p><strong>Fórmula Original</strong>:</p>
<p><span class="math display">\[
\exists u \forall x \exists y \forall z \exists w \, Q(u,x,y,z,w)
\]</span></p>
<p><strong>Aplicação da Skolemização</strong>:</p>
<ol type="1">
<li><span class="math inline">\(\exists u\)</span>: Não há universais precedentes Constante Skolem <span class="math inline">\(c_1\)</span></li>
<li><span class="math inline">\(\exists y\)</span>: Precedido por <span class="math inline">\(\forall x\)</span> Função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span><br>
</li>
<li><span class="math inline">\(\exists w\)</span>: Precedido por <span class="math inline">\(\forall x\)</span> e <span class="math inline">\(\forall z\)</span> Função Skolem <span class="math inline">\(\mathbf{g}(x,z)\)</span></li>
</ol>
<p><strong>Resultado</strong>:</p>
<p><span class="math display">\[
\forall x \forall z \, Q(c_1, x, \mathbf{f}(x), z, \mathbf{g}(x,z))
\]</span></p>
<p><strong>Forma com Quantificadores Implícitos</strong>:</p>
<p><span class="math display">\[
Q(c_1, x, \mathbf{f}(x), z, \mathbf{g}(x,z))
\]</span></p>
</section>
<section id="exemplo-4-fórmula-complexa-com-estrutura-mista-versão-corrigida" class="level4" data-number="7.2.2.4">
<h4 data-number="7.2.2.4" class="anchored" data-anchor-id="exemplo-4-fórmula-complexa-com-estrutura-mista-versão-corrigida"><span class="header-section-number">7.2.2.4</span> Exemplo 4: Fórmula Complexa com Estrutura Mista (Versão Corrigida)</h4>
<p><strong>Fórmula Original</strong>:</p>
<p><span class="math display">\[
\forall x (\exists y , P(x,y) \rightarrow \forall z \exists w , R(x,z,w))
\]</span></p>
<p><strong>Conversão para Forma Normal Prenex</strong>:</p>
<p>Precisamos mover todos os quantificadores para o início da fórmula, seguindo as regras de equivalência lógica.</p>
<p><strong>Passo 1</strong>: Renomear variáveis ligadas para evitar conflitos. Como não há variáveis com mesmo nome em escopos diferentes, podemos prosseguir.</p>
<p><strong>Passo 2</strong>: Eliminar a implicação usando <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>:</p>
<p><span class="math display">\[
\forall x (\neg \exists y , P(x,y) \vee \forall z \exists w , R(x,z,w))
\]</span></p>
<p><strong>Passo 3</strong>: Aplicar a negação ao quantificador existencial usando <span class="math inline">\(\neg \exists y \, \phi \equiv \forall y \neg \phi\)</span>:</p>
<p><span class="math display">\[
\forall x (\forall y \neg P(x,y) \vee \forall z \exists w , R(x,z,w))
\]</span></p>
<p><strong>Passo 4</strong>: Mover os quantificadores internos para fora. Como as variáveis dos disjuntos são distintas, podemos mover os quantificadores para o início da fórmula.</p>
<p><span class="math display">\[
\forall x \forall y \forall z \exists w (\neg P(x,y) \vee R(x,z,w))
\]</span></p>
<p>Esta é a Forma Normal Prenex correta da fórmula original.</p>
<p><strong>Aplicação da Skolemização</strong>:</p>
<p>Agora, identificamos a única variável existencial e suas dependências universais:</p>
<ol type="1">
<li><span class="math inline">\(\exists w\)</span>: É precedido pelos quantificadores universais <span class="math inline">\(\forall x\)</span>, <span class="math inline">\(\forall y\)</span> e <span class="math inline">\(\forall z\)</span>. Portanto, substituímos <span class="math inline">\(w\)</span> por uma Função Skolem <span class="math inline">\(\mathbf{g}(x,y,z)\)</span> que depende dessas três variáveis.</li>
</ol>
<p><strong>Resultado após Skolemização</strong>:</p>
<p><span class="math display">\[
\forall x \forall y \forall z (\neg P(x,y) \vee R(x, z, \mathbf{g}(x,y,z)))
\]</span></p>
<p><strong>Após tornar os quantificadores universais implícitos</strong>:</p>
<p><span class="math display">\[
\neg P(x,y) \vee R(x, z, \mathbf{g}(x,y,z))
\]</span></p>
<p><strong>Observação</strong>: Esta última fórmula representa uma cláusula pronta para uso em métodos de inferência como a resolução. A função Skolem <span class="math inline">\(\mathbf{g}(x,y,z)\)</span> captura corretamente a dependência da escolha de <span class="math inline">\(w\)</span> em relação a todas as variáveis universais que a precediam no escopo: <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> e <span class="math inline">\(z\)</span>.</p>
</section>
<section id="exemplo-5-conversão-em-formas-normais-conjuntiva-e-disjuntiva" class="level4" data-number="7.2.2.5">
<h4 data-number="7.2.2.5" class="anchored" data-anchor-id="exemplo-5-conversão-em-formas-normais-conjuntiva-e-disjuntiva"><span class="header-section-number">7.2.2.5</span> Exemplo 5: Conversão em Formas Normais, Conjuntiva e Disjuntiva</h4>
<p>Considere a sentença: <strong>Todos os alunos estudam ou alguns professores ensinam matemática</strong>, que em lógica de primeira ordem pode ser representada por:</p>
<p><span class="math display">\[
\forall x(\text{Aluno}(x) \rightarrow \text{Estuda}(x)) \vee \exists y(\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p>
<p><strong>Conversão para Forma Normal Conjuntiva</strong>:</p>
<ol type="1">
<li><p><strong>Eliminar implicações</strong>: converter <span class="math inline">\(A \rightarrow B\)</span> em <span class="math inline">\(\neg A \vee B\)</span>.</p>
<p><span class="math display">\[
\forall x(\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee \exists y(\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p></li>
<li><p><strong>Padronizar variáveis</strong>: as variáveis <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> já são distintas e não há conflito de escopo. Nenhuma alteração é necessária.</p></li>
<li><p><strong>Converter para Forma Normal Prenex</strong>: mover todos os quantificadores para a frente da fórmula.</p>
<p><span class="math display">\[
\forall x \exists y ((\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y)))
\]</span></p></li>
<li><p><strong>Skolemização</strong>: eliminar o quantificador existencial <span class="math inline">\(\exists y\)</span>. Como <span class="math inline">\(y\)</span> está no escopo de <span class="math inline">\(\forall x\)</span>, ele é substituído por uma função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span>.</p>
<p><span class="math display">\[
\forall x ((\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(\mathbf{f}(x)) \wedge \text{EnsinaMatemática}(\mathbf{f}(x))))
\]</span></p></li>
<li><p><strong>Aplicar distributividade</strong>: distribuir <span class="math inline">\(\vee\)</span> sobre <span class="math inline">\(\wedge\)</span> usando a regra <span class="math inline">\((P \vee (Q \wedge R)) \equiv ((P \vee Q) \wedge (P \vee R))\)</span>.</p>
<p><span class="math display">\[
\forall x ((\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{Professor}(\mathbf{f}(x))) \wedge (\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{EnsinaMatemática}(\mathbf{f}(x))))
\]</span></p></li>
<li><p><strong>Remover quantificadores universais</strong>: na forma clausal, os quantificadores universais são implícitos.</p>
<p><span class="math display">\[
(\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{Professor}(\mathbf{f}(x))) \wedge (\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{EnsinaMatemática}(\mathbf{f}(x)))
\]</span></p></li>
</ol>
<p><strong>Resultado em Forma Normal Conjuntiva</strong>: a fórmula está na Forma Normal Conjuntiva, representada como uma conjunção de duas cláusulas.</p>
<p><strong>Conversão para Forma Normal Disjuntiva</strong>: a conversão para Forma Normal Disjuntiva segue um caminho diferente e <strong>não utiliza Skolemização</strong>. O ponto de partida correto é a Forma Normal Prenex (passo 3 da conversão anterior).</p>
<ol type="1">
<li><p><strong>Ponto de Partida (Forma Normal Prenex)</strong>:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y)))
\]</span></p></li>
<li><p><strong>Analisar a Matriz da Fórmula</strong>: A matriz é a parte da fórmula sem os quantificadores. Vamos analisá-la:</p>
<p><span class="math display">\[
(\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p>
<p>Uma fórmula está em Forma Normal Disjuntiva se for uma disjunção de conjunções de literais. Simplificando a expressão acima (removendo parênteses por associatividade), obtemos:</p>
<p><span class="math display">\[
\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p>
<p>Esta estrutura já corresponde a uma Forma Normal Disjuntiva. Ela é uma disjunção (termos ligados por <span class="math inline">\(\vee\)</span>) de três termos: <span class="math inline">\(\neg \text{Aluno}(x)\)</span>, <span class="math inline">\(\text{Estuda}(x)\)</span> e a conjunção <span class="math inline">\((\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))\)</span>. Nenhum passo de distribuição é necessário.</p></li>
</ol>
<p><strong>Resultado em Forma Normal Disjuntiva</strong>: a Forma Normal Disjuntiva da fórmula, mantendo os quantificadores, é:</p>
<p><span class="math display">\[
\forall x \exists y (\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y)))
\]</span></p>
<p><strong>Observação</strong>: a estrutura da fórmula original, uma grande disjunção (<span class="math inline">\(P \vee Q\)</span>), faz com que ela seja naturalmente próxima da Forma Normal Disjuntiva, exigindo poucos ou nenhum passo de conversão. Em contraste, para chegar à Forma Normal Conjuntiva, foi necessário aplicar a lei da distributividade, resultando em uma expressão mais complexa.</p>
<div class="{callout-note}">
<p><strong>Nota</strong>: a forma resultante após Skolemização e conversão para FNC, quando todos os quantificadores universais são removidos (ficam implícitos), resulta em um conjunto de cláusulas - exatamente o formato necessário para o método de resolução e para identificar cláusulas de Horn, como veremos no próximo capítulo.</p>
</div>
</section>
</section>
<section id="expansão-do-vocabulário-e-conexão-com-programação-lógica" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="expansão-do-vocabulário-e-conexão-com-programação-lógica"><span class="header-section-number">7.2.3</span> Expansão do Vocabulário e Conexão com Programação Lógica</h3>
<p>Ao introduzir constantes e funções Skolem, a Skolemização adiciona novos identificadores ao alfabeto que definimos para a <strong>Lógica de Primeira Ordem</strong>. Pense nisso como registrar novos navios ou rotas no sistema do mestre de porto: uma constante Skolem <span class="math inline">\(c\)</span> é como um navio recém-batizado, e uma função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span> é como uma regra para nomear navios de apoio com base na embarcação principal <span class="math inline">\(x\)</span>. Esses novos símbolos são essenciais quando transformamos fórmulas em <strong>cláusulas</strong>, que são as unidades básicas usadas em sistemas de programação lógica, como o Prolog.</p>
<p>Essa expansão do vocabulário também nos conecta ao <strong>teorema de Herbrand</strong>, uma ideia fundamental em programação lógica. O teorema garante que, após a Skolemização, podemos verificar se uma fórmula é satisfatível testando combinações finitas de termos. Isso é especialmente importante para <strong>cláusulas de Horn</strong>, um tipo especial de cláusula com no máximo um literal positivo, que forma a base de programas em Prolog. Assim, a Skolemização não apenas elimina ambiguidades existenciais, mas também prepara o terreno para sistemas automatizados que navegam por essas cláusulas em busca de respostas lógicas.</p>
</section>
<section id="sec-exercicios-skolemizacao" class="level3" data-number="7.2.4">
<h3 data-number="7.2.4" class="anchored" data-anchor-id="sec-exercicios-skolemizacao"><span class="header-section-number">7.2.4</span> Exercícios de Skolemização</h3>
<p><strong>1.</strong> Aplique a Skolemização na seguinte fórmula simples:</p>
<p><span class="math display">\[\exists x \, P(x)\]</span></p>
<p><strong>2.</strong> Converta a fórmula abaixo aplicando a Skolemização:</p>
<p><span class="math display">\[\forall x \exists y \, Q(x,y)\]</span></p>
<p><strong>3.</strong> Aplique a Skolemização na fórmula com múltiplos quantificadores:</p>
<p><span class="math display">\[\exists a \forall x \exists y \forall z \exists w \, R(a,x,y,z,w)\]</span></p>
<p><strong>4.</strong> Dada a fórmula com implicação, primeiro converta para Forma Normal Prenex e depois aplique a Skolemização:</p>
<p><span class="math display">\[\forall x (P(x) \rightarrow \exists y \, Q(x,y)) \wedge \exists z \, R(z)\]</span></p>
<p><strong>5.</strong> Converta a seguinte fórmula complexa para Forma Normal Prenex e depois aplique a Skolemização:</p>
<p><span class="math display">\[\neg(\exists x \forall y \, P(x,y)) \vee (\forall z \exists w \, S(z,w) \wedge \exists u \, T(u))\]</span></p>
<p><strong>6.</strong> Para a fórmula que representa “Todo estudante tem um professor que ensina uma disciplina que o estudante estuda”:</p>
<p><span class="math display">\[\forall x (\text{Estudante}(x) \rightarrow \exists y (\text{Professor}(y) \wedge \exists z (\text{Disciplina}(z) \wedge \text{Ensina}(y,z) \wedge \text{Estuda}(x,z))))\]</span></p>
<p>Converta para Forma Normal Prenex e aplique a Skolemização.</p>
<p><strong>7.</strong> Dada a fórmula que combina quantificadores universais e existenciais em uma estrutura condicional complexa:</p>
<p><span class="math display">\[(\forall x \exists y \, P(x,y)) \rightarrow (\exists u \forall v \exists w \, Q(u,v,w) \wedge \forall s \, R(s))\]</span></p>
<p>Realize a conversão completa: elimine implicações, converta para Forma Normal Prenex e aplique a Skolemização.</p>
</section>
</section>
<section id="formas-normais-prenex" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="formas-normais-prenex"><span class="header-section-number">7.3</span> Formas Normais Prenex</h2>
<p>Agora que já conhecemos as Formas Normais Prenex e a Skolemização, podemos explorar as formas normais considerando a existência de quantificadores. Neste caso, podemos definir um algoritmo para converter fórmulas lógicas em suas respectivas Formas Normais Prenex. Começando com a própria Forma Normal Prenex.</p>
<section id="algoritmo-para-conversão-na-forma-normal-prenex" class="level3" data-number="7.3.1">
<h3 data-number="7.3.1" class="anchored" data-anchor-id="algoritmo-para-conversão-na-forma-normal-prenex"><span class="header-section-number">7.3.1</span> Algoritmo para Conversão na Forma Normal Prenex</h3>
<p>A Forma Normal Prenex (FNP) é uma representação de fórmulas lógicas onde todos os quantificadores estão no início da fórmula, seguidos por uma parte livre de quantificadores. Essa estrutura é útil para a aplicação de técnicas de resolução em lógica de primeira ordem.</p>
<p><strong>Entrada</strong>: Fórmula <span class="math inline">\(A\)</span>. <strong>Saída</strong>: Fórmula <span class="math inline">\(B\)</span> em FNP tal que <span class="math inline">\(A \equiv B\)</span>.</p>
<ol type="1">
<li><strong>repita</strong>
<ol type="1">
<li>para todas as subfórmulas <span class="math inline">\(X, Y, Z \in A\)</span> faça
<ol type="1">
<li>se <span class="math inline">\((X \rightarrow Y)\)</span> redefina como <span class="math inline">\((\neg X \vee Y)\)</span></li>
<li>se <span class="math inline">\((X \leftrightarrow Y)\)</span> redefina como <span class="math inline">\((X \wedge Y) \vee (\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \vee Y)\)</span> redefina como <span class="math inline">\((\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \wedge Y)\)</span> redefina como <span class="math inline">\((\neg X \vee \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg\neg X\)</span> redefina como <span class="math inline">\(X\)</span></li>
<li>se <span class="math inline">\(\neg\forall x P(x)\)</span> redefina como <span class="math inline">\(\exists x \neg P(x)\)</span></li>
<li>se <span class="math inline">\(\neg\exists x P(x)\)</span> redefina como <span class="math inline">\(\forall x \neg P(x)\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (P(x) \vee Y)\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \vee Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (P(x) \vee Y)\)</span></li>
<li>se <span class="math inline">\(Y \vee (\forall x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (Y \vee P(x))\)</span></li>
<li>se <span class="math inline">\(Y \vee (\exists x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (Y \vee P(x))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \wedge Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (P(x) \wedge Y)\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (P(x) \wedge Y)\)</span></li>
<li>se <span class="math inline">\(Y \wedge (\forall x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (Y \wedge P(x))\)</span></li>
<li>se <span class="math inline">\(Y \wedge (\exists x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (Y \wedge P(x))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \wedge (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \forall y (P(x) \wedge Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \vee (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \exists y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \forall y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \exists y (P(x) \wedge Q(y))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \exists y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \forall y (P(x) \wedge Q(y))\)</span></li>
</ol></li>
<li>fim</li>
</ol></li>
<li><strong>até não ocorrerem substituições</strong></li>
<li>Renomeie variáveis ligadas para evitar conflitos de escopo</li>
<li>Mova todos os quantificadores restantes para o início da fórmula (prenexação final)</li>
</ol>
<section id="exemplo-1-3" class="level4" data-number="7.3.1.1">
<h4 data-number="7.3.1.1" class="anchored" data-anchor-id="exemplo-1-3"><span class="header-section-number">7.3.1.1</span> Exemplo 1</h4>
<p><strong>Fórmula inicial</strong>: $ x (P(x) y Q(x,y)) (z R(z)) $</p>
<p><strong>Solução</strong>:</p>
<p><strong>Passo 1</strong>: Eliminar Implicações</p>
<p>Primeiro, removemos a implicação <span class="math inline">\(P(x) \rightarrow \exists y Q(x,y)\)</span>, aplicando a regra <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>:</p>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y)) \wedge \neg(\exists z R(z))
\]</span></p>
<p><strong>Passo 2</strong>: Mover Negações para Dentro (FNN)</p>
<p>Em seguida, aplicamos a regra de negação do quantificador existencial, <span class="math inline">\(\neg\exists z \equiv \forall z \neg\)</span>, na segunda parte da fórmula:</p>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y)) \wedge \forall z \neg R(z)
\]</span></p>
<p><strong>Passo 3</strong>: Mover Quantificadores para o Início (Prenexação)</p>
<p>Agora, movemos todos os quantificadores para o início da fórmula. É fundamental observar a ordem correta:</p>
<ul>
<li>O quantificador <span class="math inline">\(\exists y\)</span> está no escopo de <span class="math inline">\(\forall x\)</span>. Isso significa que a escolha de <span class="math inline">\(y\)</span> pode depender de <span class="math inline">\(x\)</span>. Para preservar essa dependência, <span class="math inline">\(\forall x\)</span> deve vir antes de <span class="math inline">\(\exists y\)</span> na forma prenex.</li>
<li>O quantificador <span class="math inline">\(\forall z\)</span> vem de uma conjunção independente e pode ser movido para o início junto com os outros.</li>
</ul>
<p>Seguindo essa lógica, a ordem correta dos quantificadores é <span class="math inline">\(\forall x \exists y \forall z\)</span>.</p>
<p><span class="math display">\[
\forall x \exists y \forall z ((\neg P(x) \vee Q(x,y)) \wedge \neg R(z))
\]</span></p>
<p><strong>Resultado</strong>: A fórmula final em FNP, com a ordem dos quantificadores justificada para manter o sentido lógico original, é:</p>
<p><span class="math display">\[
\forall x \exists y \forall z ((\neg P(x) \vee Q(x,y)) \wedge \neg R(z))
\]</span></p>
</section>
<section id="exemplo-2-3" class="level4" data-number="7.3.1.2">
<h4 data-number="7.3.1.2" class="anchored" data-anchor-id="exemplo-2-3"><span class="header-section-number">7.3.1.2</span> Exemplo 2</h4>
<p><strong>Fórmula inicial</strong>: $ (x P(x) y Q(y)) $</p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><p><strong>Eliminar equivalências (passo 1.1.2):</strong> Primeiro, substituímos o operador de equivalência <span class="math inline">\(A \leftrightarrow B\)</span> por <span class="math inline">\((A \wedge B) \vee (\neg A \wedge \neg B)\)</span>. <span class="math display">\[ \neg((\forall x P(x) \wedge \exists y Q(y)) \vee (\neg \forall x P(x) \wedge \neg \exists y Q(y))) \]</span></p></li>
<li><p><strong>Aplicar a lei de De Morgan para a negação de disjunção (passo 1.1.3):</strong> Movemos a negação principal para dentro, trocando <span class="math inline">\(\vee\)</span> por <span class="math inline">\(\wedge\)</span>. <span class="math display">\[ \neg(\forall x P(x) \wedge \exists y Q(y)) \wedge \neg(\neg \forall x P(x) \wedge \neg \exists y Q(y)) \]</span></p></li>
<li><p><strong>Aplicar a lei de De Morgan para a negação de conjunção (passo 1.1.4):</strong> Continuamos a mover as negações para dentro das duas cláusulas. <span class="math display">\[ (\neg \forall x P(x) \vee \neg \exists y Q(y)) \wedge (\neg\neg \forall x P(x) \vee \neg\neg \exists y Q(y)) \]</span></p></li>
<li><p><strong>Eliminar duplas negações (passo 1.1.5):</strong> Removemos as duplas negações na segunda parte da fórmula. <span class="math display">\[ (\neg \forall x P(x) \vee \neg \exists y Q(y)) \wedge (\forall x P(x) \vee \exists y Q(y)) \]</span></p></li>
<li><p><strong>Aplicar regras de negação de quantificadores (passos 1.1.6 e 1.1.7):</strong> Esta é a conversão para a Forma Normal Negativa (FNN), o passo onde o erro original ocorreu. <span class="math display">\[ (\exists x \neg P(x) \vee \forall y \neg Q(y)) \wedge (\forall x P(x) \vee \exists y Q(y)) \]</span></p></li>
<li><p><strong>Renomear variáveis ligadas (passo 3):</strong> Para evitar conflitos ao mover os quantificadores, renomeamos as variáveis <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> na segunda cláusula para <span class="math inline">\(z\)</span> e <span class="math inline">\(w\)</span>. <span class="math display">\[ (\exists x \neg P(x) \vee \forall y \neg Q(y)) \wedge (\forall z P(z) \vee \exists w Q(w)) \]</span></p></li>
<li><p><strong>Mover quantificadores para a esquerda (prenexação, passo 4):</strong> Movemos todos os quantificadores para o início da fórmula para obter a Forma Normal Prenex. <span class="math display">\[ \exists x \forall y \forall z \exists w ((\neg P(x) \vee \neg Q(y)) \wedge (P(z) \vee Q(w))) \]</span></p></li>
</ol>
<p><strong>Resultado:</strong> $ x y z w ((P(x) Q(y)) (P(z) Q(w))) $</p>
</section>
<section id="exemplo-3-2" class="level4" data-number="7.3.1.3">
<h4 data-number="7.3.1.3" class="anchored" data-anchor-id="exemplo-3-2"><span class="header-section-number">7.3.1.3</span> Exemplo 3</h4>
<p><strong>Fórmula inicial</strong>: $ (x P(x) y Q(y)) z R(z) $</p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><p><strong>Eliminar implicações (passo 1.1.1)</strong>: <span class="math display">\[\neg(\exists x P(x) \vee \forall y Q(y)) \vee \forall z R(z)\]</span></p></li>
<li><p><strong>Aplicar as leis de De Morgan para mover negações para dentro (passo 1.1.2, 1.1.7 e 1.1.8)</strong>: <span class="math display">\[(\forall x \neg P(x) \wedge \exists y \neg Q(y)) \vee \forall z R(z)\]</span></p></li>
<li><p><strong>Renomear variáveis</strong>: (não necessário neste caso).</p></li>
<li><p><strong>Mover quantificadores para a esquerda (prenexação, passo 4)</strong>: <span class="math display">\[\forall x \exists y \forall z ((\neg P(x) \wedge \neg Q(y)) \vee R(z))\]</span></p></li>
</ol>
<p><strong>Resultado:</strong></p>
<p><span class="math display">\[\forall x \exists y \forall z ((\neg P(x) \wedge \neg Q(y)) \vee R(z))\]</span></p>
</section>
<section id="exemplo-4-2" class="level4" data-number="7.3.1.4">
<h4 data-number="7.3.1.4" class="anchored" data-anchor-id="exemplo-4-2"><span class="header-section-number">7.3.1.4</span> Exemplo 4</h4>
<p><strong>Fórmula inicial</strong>: $ (x y P(x,y)) (z w Q(z,w) u R(u)) $</p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><p><strong>Aplicar as leis de De Morgan para mover negações para dentro (passo 1.1.7 e 1.1.8)</strong>:</p></li>
<li><p><span class="math display">\[(\exists x \forall y \neg P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall u R(u))\]</span></p></li>
<li><p><strong>Renomear variáveis (passo 3)</strong>:</p></li>
<li><p><span class="math display">\[(\exists x \forall y \neg P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall v R(v))\]</span></p></li>
<li><p><strong>Mover quantificadores para a esquerda (prenexação, passo 4)</strong>: <span class="math display">\[\exists x \forall y \exists z \forall w \forall v ((\neg P(x,y)) \vee (Q(z,w) \wedge R(v)))\]</span></p></li>
</ol>
<p><strong>Resultado:</strong></p>
<p><span class="math display">\[\exists x \forall y \exists z \forall w \forall v ((\neg P(x,y)) \vee (Q(z,w) \wedge R(v)))\]</span></p>
</section>
<section id="exemplo-5-2" class="level4" data-number="7.3.1.5">
<h4 data-number="7.3.1.5" class="anchored" data-anchor-id="exemplo-5-2"><span class="header-section-number">7.3.1.5</span> Exemplo 5</h4>
<p><strong>Fórmula inicial</strong>: $ x (y P(x,y) z Q(x,z)) (w R(w)) $</p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><p><strong>Eliminar implicações (passo 1.1.1)</strong>:</p>
<p><span class="math display">\[\forall x (\neg \exists y P(x,y) \vee \forall z Q(x,z)) \wedge \neg(\exists w R(w))\]</span></p></li>
<li><p><strong>Aplicar as leis de De Morgan para mover negações para dentro (passo 1.1.7 e 1.1.8)</strong>: <span class="math display">\[\forall x (\forall y \neg P(x,y) \vee \forall z Q(x,z)) \wedge \forall w \neg R(w)\]</span></p></li>
<li><p><strong>Renomear variáveis (passo 3)</strong>:</p></li>
<li><p><span class="math display">\[\forall x (\forall y \neg P(x,y) \vee \forall z Q(x,z)) \wedge \forall v \neg R(v)\]</span></p></li>
<li><p><strong>Mover quantificadores para a esquerda (prenexação, passo 4)</strong>:</p>
<p><span class="math display">\[\forall x \forall y \forall z \forall v ((\neg P(x,y) \vee Q(x,z)) \wedge \neg R(v))\]</span></p></li>
</ol>
<p><strong>Resultado:</strong></p>
<p><span class="math display">\[\forall x \forall y \forall z \forall v ((\neg P(x,y) \vee Q(x,z)) \wedge \neg R(v))\]</span></p>
</section>
</section>
<section id="forma-normal-negativa-prenex" class="level3" data-number="7.3.2">
<h3 data-number="7.3.2" class="anchored" data-anchor-id="forma-normal-negativa-prenex"><span class="header-section-number">7.3.2</span> Forma Normal Negativa Prenex</h3>
<p>A Forma Normal Negativa Prenex (FNNP) é uma variação da Forma Normal Prenex que se concentra em manter as negações no nível mais externo possível, enquanto ainda obedece à estrutura prenex. Isso é útil em contextos onde a preservação da negação é crítica para a interpretação da fórmula.</p>
<section id="algoritmo-para-forma-normal-negativa-fnn" class="level4" data-number="7.3.2.1">
<h4 data-number="7.3.2.1" class="anchored" data-anchor-id="algoritmo-para-forma-normal-negativa-fnn"><span class="header-section-number">7.3.2.1</span> Algoritmo para Forma Normal Negativa (FNN)</h4>
<p>Entrada: Fórmula <span class="math inline">\(A\)</span>. Saída: Fórmula <span class="math inline">\(B\)</span> em FNN tal que <span class="math inline">\(A \equiv B\)</span>.</p>
<ol type="1">
<li><strong>repita</strong></li>
<li>para todas as subfórmulas <span class="math inline">\(X, Y \in A\)</span> faça
<ol type="1">
<li>se <span class="math inline">\((X \rightarrow Y)\)</span> redefina como <span class="math inline">\((\neg X \vee Y)\)</span></li>
<li>se <span class="math inline">\((X \leftrightarrow Y)\)</span> redefina como <span class="math inline">\((X \wedge Y) \vee (\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \vee Y)\)</span> redefina como <span class="math inline">\((\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \wedge Y)\)</span> redefina como <span class="math inline">\((\neg X \vee \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg\neg X\)</span> redefina como <span class="math inline">\(X\)</span></li>
<li>se <span class="math inline">\(\neg\forall x P(x)\)</span> redefina como <span class="math inline">\(\exists x \neg P(x)\)</span></li>
<li>se <span class="math inline">\(\neg\exists x P(x)\)</span> redefina como <span class="math inline">\(\forall x \neg P(x)\)</span></li>
</ol></li>
<li>fim</li>
<li><strong>até não ocorrerem substituições</strong></li>
</ol>
</section>
<section id="exemplo-1-4" class="level4" data-number="7.3.2.2">
<h4 data-number="7.3.2.2" class="anchored" data-anchor-id="exemplo-1-4"><span class="header-section-number">7.3.2.2</span> Exemplo 1</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg(P \rightarrow (Q \vee R))\)</span></p>
<p><strong>Solução</strong>: 1. Eliminar implicações (passo 1.1.1): <span class="math inline">\(\neg(\neg P \vee (Q \vee R))\)</span>; 2. Aplicar lei de De Morgan para negação de disjunção (passo 1.1.3): <span class="math inline">\(P \wedge \neg(Q \vee R)\)</span>; 3. Aplicar novamente lei de De Morgan para negação de disjunção (passo 1.1.3): <span class="math inline">\(P \wedge (\neg Q \wedge \neg R)\)</span>.</p>
<p><strong>Resultado final</strong>: <span class="math inline">\(P \wedge (\neg Q \wedge \neg R)\)</span></p>
</section>
<section id="exemplo-2-4" class="level4" data-number="7.3.2.3">
<h4 data-number="7.3.2.3" class="anchored" data-anchor-id="exemplo-2-4"><span class="header-section-number">7.3.2.3</span> Exemplo 2</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg(\forall x P(x) \leftrightarrow \exists y Q(y))\)</span></p>
<p><strong>Solução</strong>: 1. Eliminar equivalências (passo 1.1.2):</p>
<p><span class="math display">\[\neg((\forall x P(x) \wedge \exists y Q(y)) \vee (\neg \forall x P(x) \wedge \neg \exists y Q(y)))\]</span></p>
<ol start="2" type="1">
<li>Aplicar lei de De Morgan para negação de disjunção (passo 1.1.3):</li>
</ol>
<p><span class="math display">\[(\neg(\forall x P(x) \wedge \exists y Q(y))) \wedge (\neg(\neg \forall x P(x) \wedge \neg \exists y Q(y)))\]</span></p>
<ol start="3" type="1">
<li>Aplicar lei de De Morgan para negação de conjunção (passo 1.1.4):</li>
</ol>
<p><span class="math display">\[(\neg \forall x P(x) \vee \neg \exists y Q(y)) \wedge (\forall x P(x) \vee \exists y Q(y))\]</span></p>
<ol start="4" type="1">
<li>Aplicar lei de De Morgan para negação de quantificadores (passos 1.1.6 e 1.1.7):</li>
</ol>
<p><span class="math display">\[(\exists x \neg P(x) \vee \forall y \neg Q(y)) \wedge (\forall x P(x) \vee \exists y Q(y))\]</span></p>
<p><strong>Resultado</strong>:</p>
<p><span class="math display">\[(\exists x \neg P(x) \vee \forall y \neg Q(y)) \wedge (\forall x P(x) \vee \exists y Q(y))\]</span></p>
</section>
<section id="exemplo-2-5" class="level4" data-number="7.3.2.4">
<h4 data-number="7.3.2.4" class="anchored" data-anchor-id="exemplo-2-5"><span class="header-section-number">7.3.2.4</span> Exemplo 2</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg(\forall x (P(x) \rightarrow \exists y Q(x,y)))\)</span></p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li>Eliminar implicações (passo 1.1.1):</li>
</ol>
<p><span class="math display">\[\neg(\forall x (\neg P(x) \vee \exists y Q(x,y)))\]</span></p>
<ol start="2" type="1">
<li>Aplicar lei de De Morgan para negação de quantificador universal (passo 1.1.6):</li>
</ol>
<p><span class="math display">\[\exists x \neg(\neg P(x) \vee \exists y Q(x,y))\]</span></p>
<ol start="3" type="1">
<li>Aplicar lei de De Morgan para negação de disjunção (passo 1.1.3):</li>
</ol>
<p><span class="math display">\[\exists x (P(x) \wedge \neg(\exists y Q(x,y)))\]</span></p>
<ol start="4" type="1">
<li>Aplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.7):</li>
</ol>
<p><span class="math display">\[\exists x (P(x) \wedge \forall y \neg Q(x,y))\]</span></p>
<p>Resultado:</p>
<p><span class="math display">\[\exists x (P(x) \wedge \forall y \neg Q(x,y))\]</span></p>
</section>
<section id="exemplo-4-3" class="level4" data-number="7.3.2.5">
<h4 data-number="7.3.2.5" class="anchored" data-anchor-id="exemplo-4-3"><span class="header-section-number">7.3.2.5</span> Exemplo 4</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg(\forall x (P(x) \vee Q(x)) \rightarrow \exists y R(y))\)</span></p>
<p><strong>Solução</strong>: 1. Eliminar implicações (passo 1.1.1):</p>
<p><span class="math display">\[\neg(\neg(\forall x (P(x) \vee Q(x))) \vee \exists y R(y))\]</span></p>
<ol start="2" type="1">
<li>Aplicar lei de De Morgan para negação de disjunção (passo 1.1.3):</li>
</ol>
<p><span class="math display">\[\neg\neg(\forall x (P(x) \vee Q(x))) \wedge \neg(\exists y R(y))\]</span></p>
<ol start="3" type="1">
<li>Eliminar dupla negação (passo 1.1.5):</li>
</ol>
<p><span class="math display">\[(\forall x (P(x) \vee Q(x))) \wedge \neg(\exists y R(y))\]</span></p>
<ol start="4" type="1">
<li>Aplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.7):</li>
</ol>
<p><span class="math display">\[(\forall x (P(x) \vee Q(x))) \wedge (\forall y \neg R(y))\]</span></p>
<p>Resultado:</p>
<p><span class="math display">\[(\forall x (P(x) \vee Q(x))) \wedge (\forall y \neg R(y))\]</span></p>
</section>
</section>
<section id="algoritmo-para-forma-normal-disjuntiva-prenex-fnd-prenex" class="level3" data-number="7.3.3">
<h3 data-number="7.3.3" class="anchored" data-anchor-id="algoritmo-para-forma-normal-disjuntiva-prenex-fnd-prenex"><span class="header-section-number">7.3.3</span> Algoritmo para Forma Normal Disjuntiva Prenex (FND Prenex)</h3>
<p><strong>Entrada</strong>: Fórmula <span class="math inline">\(A\)</span>. <strong>Saída</strong>: Fórmula <span class="math inline">\(B\)</span> em FND Prenex tal que <span class="math inline">\(A \equiv B\)</span>.</p>
<ol type="1">
<li><strong>repita</strong>
<ol type="1">
<li>para todas as subfórmulas <span class="math inline">\(X, Y, Z \in A\)</span> faça
<ol type="1">
<li>se <span class="math inline">\((X \rightarrow Y)\)</span> redefina como <span class="math inline">\((\neg X \vee Y)\)</span></li>
<li>se <span class="math inline">\((X \leftrightarrow Y)\)</span> redefina como <span class="math inline">\((X \wedge Y) \vee (\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \vee Y)\)</span> redefina como <span class="math inline">\((\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \wedge Y)\)</span> redefina como <span class="math inline">\((\neg X \vee \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg\neg X\)</span> redefina como <span class="math inline">\(X\)</span></li>
<li>se <span class="math inline">\(X \wedge (Y \vee Z)\)</span> redefina como <span class="math inline">\((X \wedge Y) \vee (X \wedge Z)\)</span></li>
<li>se <span class="math inline">\((X \vee Y) \wedge Z\)</span> redefina como <span class="math inline">\((X \wedge Z) \vee (Y \wedge Z)\)</span></li>
<li>se <span class="math inline">\(\neg\forall x P(x)\)</span> redefina como <span class="math inline">\(\exists x \neg P(x)\)</span></li>
<li>se <span class="math inline">\(\neg\exists x P(x)\)</span> redefina como <span class="math inline">\(\forall x \neg P(x)\)</span></li>
<li>se <span class="math inline">\(\forall x P(x)\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(P\)</span>, redefina como <span class="math inline">\(P\)</span></li>
<li>se <span class="math inline">\(\exists x P(x)\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(P\)</span>, redefina como <span class="math inline">\(P\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (P(x) \vee Y)\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \vee Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (P(x) \vee Y)\)</span></li>
<li>se <span class="math inline">\(Y \vee (\forall x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (Y \vee P(x))\)</span></li>
<li>se <span class="math inline">\(Y \vee (\exists x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (Y \vee P(x))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \wedge Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (P(x) \wedge Y)\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (P(x) \wedge Y)\)</span></li>
<li>se <span class="math inline">\(Y \wedge (\forall x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (Y \wedge P(x))\)</span></li>
<li>se <span class="math inline">\(Y \wedge (\exists x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (Y \wedge P(x))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \wedge (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \forall y (P(x) \wedge Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \vee (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \exists y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \forall y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \exists y (P(x) \wedge Q(y))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \exists y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \forall y (P(x) \wedge Q(y))\)</span></li>
</ol></li>
<li>fim</li>
</ol></li>
<li><strong>até não ocorrerem substituições</strong></li>
<li>Renomeie variáveis ligadas para evitar conflitos</li>
<li>Mova todos os quantificadores para o início da fórmula (prenexação)</li>
</ol>
<section id="exemplo-1-5" class="level4" data-number="7.3.3.1">
<h4 data-number="7.3.3.1" class="anchored" data-anchor-id="exemplo-1-5"><span class="header-section-number">7.3.3.1</span> Exemplo 1</h4>
<p><strong>Fórmula inicial</strong>: $ x y (P(x) Q(y)) (z R(z)) $</p>
<p><strong>Passo 1: Remover Implicações</strong>: primeiro, removemos a implicação <span class="math inline">\(P(x) \rightarrow Q(y)\)</span>, aplicando a regra <span class="math inline">\(X \rightarrow Y \equiv \neg X \vee Y\)</span>:</p>
<p><span class="math display">\[
\forall x \exists y (\neg P(x) \vee Q(y)) \wedge \neg(\forall z R(z))
\]</span></p>
<p><strong>Passo 2: Mover Negações para Dentro (FNN)</strong>: aplicamos a regra de negação do quantificador universal na segunda parte da fórmula:</p>
<p><span class="math display">\[
\forall x \exists y (\neg P(x) \vee Q(y)) \wedge \exists z \neg R(z)
\]</span></p>
<p><strong>Passo 3: Mover Quantificadores para o Início (Prenexação)</strong>: renomeamos a variável <span class="math inline">\(z\)</span> para <span class="math inline">\(w\)</span> para evitar conflitos e movemos todos os quantificadores para o início:</p>
<p><span class="math display">\[
\forall x \exists y \exists w ((\neg P(x) \vee Q(y)) \wedge \neg R(w))
\]</span></p>
<p><strong>Passo 4: Distribuir <span class="math inline">\(\land\)</span> sobre <span class="math inline">\(\lor\)</span></strong>: a matriz <span class="math inline">\((\neg P(x) \vee Q(y)) \wedge \neg R(w)\)</span> ainda não está em FND. Para convertê-la, aplicamos a lei distributiva da conjunção sobre a disjunção. A expressão tem a forma <span class="math inline">\((X \vee Y) \land Z\)</span>, que é equivalente a <span class="math inline">\((X \land Z) \lor (Y \land Z)\)</span>:</p>
<p><span class="math display">\[
\forall x \exists y \exists w ((\neg P(x) \wedge \neg R(w)) \lor (Q(y) \wedge \neg R(w)))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final está em FND Prenex, pois sua matriz é uma disjunção de duas cláusulas conjuntivas:</p>
<p><span class="math display">\[
\forall x \exists y \exists w ((\neg P(x) \wedge \neg R(w)) \lor (Q(y) \wedge \neg R(w)))
\]</span></p>
</section>
<section id="exemplo-2-6" class="level4" data-number="7.3.3.2">
<h4 data-number="7.3.3.2" class="anchored" data-anchor-id="exemplo-2-6"><span class="header-section-number">7.3.3.2</span> Exemplo 2</h4>
<p><strong>Fórmula inicial</strong>: $ (x P(x) y Q(y)) $</p>
<p><strong>Passo 1: Remover Implicações</strong>: primeiro, removemos a implicação $ x P(x) y Q(y) $:</p>
<p><span class="math display">\[
\neg(\neg(\forall x P(x)) \vee \exists y Q(y))
\]</span></p>
<p><strong>Passo 2: Mover Negações para Dentro (FNN)</strong>: aplicamos a lei de De Morgan, eliminamos a dupla negação e aplicamos a regra de negação do quantificador existencial:</p>
<p><span class="math display">\[
\neg\neg(\forall x P(x)) \wedge \neg(\exists y Q(y))
\]</span></p>
<p><span class="math display">\[
(\forall x P(x)) \wedge (\forall y \neg Q(y))
\]</span></p>
<p><strong>Passo 3: Mover Quantificadores para o Início (Prenexação)</strong>: renomeamos a variável <span class="math inline">\(y\)</span> para <span class="math inline">\(z\)</span> e movemos os quantificadores para o início da fórmula:</p>
<p><span class="math display">\[
\forall x \forall z (P(x) \wedge \neg Q(z))
\]</span></p>
<p><strong>Passo 4: Analisar a Matriz para FND</strong>: a matriz da fórmula é <span class="math inline">\(P(x) \wedge \neg Q(z)\)</span>. Uma fórmula em FND é uma disjunção de uma ou mais conjunções de literais. Uma única conjunção de literais, como neste caso, é considerada uma forma válida de FND. Portanto, a matriz já está na forma desejada e nenhuma distribuição é necessária.</p>
<p><strong>Resultado</strong>: a fórmula final em FND é:</p>
<p><span class="math display">\[
\forall x \forall z (P(x) \wedge \neg Q(z))
\]</span></p>
</section>
<section id="exemplo-3-3" class="level4" data-number="7.3.3.3">
<h4 data-number="7.3.3.3" class="anchored" data-anchor-id="exemplo-3-3"><span class="header-section-number">7.3.3.3</span> Exemplo 3</h4>
<p><strong>Fórmula inicial</strong>: $ (x P(x) y Q(y)) z R(z) $</p>
<p><strong>Solução</strong>:</p>
<p><strong>Passo 1: Eliminar Implicações</strong>: primeiro, removemos a implicação principal, aplicando a regra <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>:</p>
<p><span class="math display">\[
\neg(\exists x P(x) \vee \forall y Q(y)) \vee \forall z R(z)
\]</span></p>
<p><strong>Passo 2: Aplicar a Lei de De Morgan na Disjunção</strong>: em seguida, aplicamos a lei de De Morgan à parte negada da fórmula, transformando <span class="math inline">\(\neg(A \vee B)\)</span> em <span class="math inline">\((\neg A \wedge \neg B)\)</span>:</p>
<p><span class="math display">\[
(\neg\exists x P(x) \wedge \neg\forall y Q(y)) \vee \forall z R(z)
\]</span></p>
<p><strong>Passo 3: Mover Negações para Dentro dos Quantificadores (FNN)</strong>: agora, movemos as negações para dentro dos quantificadores, aplicando as regras <span class="math inline">\(\neg\exists x \equiv \forall x \neg\)</span> e <span class="math inline">\(\neg\forall y \equiv \exists y \neg\)</span>:</p>
<p><span class="math display">\[
(\forall x \neg P(x) \wedge \exists y \neg Q(y)) \vee \forall z R(z)
\]</span></p>
<p><strong>Passo 4: Mover Quantificadores para o Início (Prenexação)</strong>: finalmente, movemos todos os quantificadores para o início da fórmula para obter a Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x \exists y \forall z ((\neg P(x) \wedge \neg Q(y)) \vee R(z))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final em FNP, com todos os passos detalhados, é:</p>
<p><span class="math display">\[
\forall x \exists y \forall z ((\neg P(x) \wedge \neg Q(y)) \vee R(z))
\]</span></p>
</section>
<section id="exemplo-4-4" class="level4" data-number="7.3.3.4">
<h4 data-number="7.3.3.4" class="anchored" data-anchor-id="exemplo-4-4"><span class="header-section-number">7.3.3.4</span> Exemplo 4</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg(\forall x \exists y P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall u R(u))\)</span></p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><p><strong>Aplicar a lei de De Morgan para negação de quantificador universal (passo 1.1.8):</strong></p>
<p><span class="math display">\[(\exists x \neg(\exists y P(x,y))) \vee (\exists z \forall w Q(z,w) \wedge \forall u R(u))\]</span></p></li>
<li><p><strong>Aplicar a lei de De Morgan para negação de quantificador existencial (passo 1.1.9):</strong></p>
<p><span class="math display">\[(\exists x \forall y \neg P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall u R(u))\]</span></p></li>
<li><p><strong>Renomear variáveis ligadas (passo 3):</strong> para garantir que cada quantificador tenha uma variável única, renomeamos <span class="math inline">\(u\)</span> para <span class="math inline">\(v\)</span>.</p>
<p><span class="math display">\[(\exists x \forall y \neg P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall v R(v))\]</span></p></li>
<li><p><strong>Mover quantificadores para o início (prenexação, passo 4):</strong></p>
<p><span class="math display">\[\exists x \forall y \exists z \forall w \forall v ((\neg P(x,y)) \vee (Q(z,w) \wedge R(v)))\]</span></p></li>
<li><p><strong>Analisar a matriz para FND:</strong> a matriz da fórmula é <span class="math inline">\((\neg P(x,y)) \vee (Q(z,w) \wedge R(v))\)</span>. Esta expressão já está na Forma Normal Disjuntiva, pois consiste em uma disjunção (<code>∨</code>) onde os operandos são um literal (<code>¬P(x,y)</code>) e uma conjunção de literais (<code>Q(z,w) \wedge R(v)</code>). Nenhuma aplicação da lei distributiva é necessária.</p></li>
</ol>
<p><strong>Resultado:</strong></p>
<p><span class="math display">\[\exists x \forall y \exists z \forall w \forall v ((\neg P(x,y)) \vee (Q(z,w) \wedge R(v)))\]</span></p>
</section>
<section id="exemplo-5-3" class="level4" data-number="7.3.3.5">
<h4 data-number="7.3.3.5" class="anchored" data-anchor-id="exemplo-5-3"><span class="header-section-number">7.3.3.5</span> Exemplo 5</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \neg(\exists z \forall w R(z,w))\)</span></p>
<p><strong>Passo 1: Remover Implicações</strong>: primeiro, removemos a implicação $ P(x) y Q(x,y) $:</p>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y)) \wedge \neg(\exists z \forall w R(z,w))
\]</span></p>
<p><strong>Passo 2: Mover Negações para Dentro (FNN)</strong>: aplicamos as leis de De Morgan para quantificadores na segunda parte da fórmula para mover a negação para dentro:</p>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y)) \wedge (\forall z \exists w \neg R(z,w))
\]</span></p>
<p><strong>Passo 3: Mover Quantificadores para o Início (Prenexação)</strong>: renomeamos as variáveis <span class="math inline">\(z\)</span> e <span class="math inline">\(w\)</span> para <span class="math inline">\(u\)</span> e <span class="math inline">\(v\)</span> para evitar conflitos e movemos todos os quantificadores para o início:</p>
<p><span class="math display">\[
\forall x \exists y \forall u \exists v ((\neg P(x) \vee Q(x,y)) \wedge \neg R(u,v))
\]</span></p>
<p><strong>Passo 4: Distribuir <span class="math inline">\(\land\)</span> sobre <span class="math inline">\(\lor\)</span></strong>: a matriz <span class="math inline">\((\neg P(x) \vee Q(x,y)) \wedge \neg R(u,v)\)</span> ainda não está em FND. Para convertê-la, aplicamos a lei distributiva da conjunção sobre a disjunção. A expressão tem a forma <span class="math inline">\((X \vee Y) \land Z\)</span>, que é equivalente a <span class="math inline">\((X \land Z) \lor (Y \land Z)\)</span>:</p>
<p><span class="math display">\[
\forall x \exists y \forall u \exists v ((\neg P(x) \wedge \neg R(u,v)) \lor (Q(x,y) \wedge \neg R(u,v)))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final está em FND, pois sua matriz é uma disjunção de duas cláusulas conjuntivas:</p>
<p><span class="math display">\[
\forall x \exists y \forall u \exists v ((\neg P(x) \wedge \neg R(u,v)) \lor (Q(x,y) \wedge \neg R(u,v)))
\]</span></p>
</section>
</section>
<section id="algoritmo-para-forma-normal-conjuntiva-prenex-fnc-prenex" class="level3" data-number="7.3.4">
<h3 data-number="7.3.4" class="anchored" data-anchor-id="algoritmo-para-forma-normal-conjuntiva-prenex-fnc-prenex"><span class="header-section-number">7.3.4</span> Algoritmo para Forma Normal Conjuntiva Prenex (FNC Prenex)</h3>
<p><strong>Entrada</strong>: Fórmula <span class="math inline">\(A\)</span>. <strong>Saída</strong>: Fórmula <span class="math inline">\(B\)</span> em FNC Prenex tal que <span class="math inline">\(A \equiv B\)</span>.</p>
<ol type="1">
<li><strong>repita</strong>
<ol type="1">
<li>para todas as subfórmulas <span class="math inline">\(X, Y, Z \in A\)</span> faça
<ol type="1">
<li>se <span class="math inline">\((X \rightarrow Y)\)</span> redefina como <span class="math inline">\((\neg X \vee Y)\)</span></li>
<li>se <span class="math inline">\((X \leftrightarrow Y)\)</span> redefina como <span class="math inline">\((X \wedge Y) \vee (\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \vee Y)\)</span> redefina como <span class="math inline">\((\neg X \wedge \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg(X \wedge Y)\)</span> redefina como <span class="math inline">\((\neg X \vee \neg Y)\)</span></li>
<li>se <span class="math inline">\(\neg\neg X\)</span> redefina como <span class="math inline">\(X\)</span></li>
<li>se <span class="math inline">\((X \wedge Y) \vee Z\)</span> redefina como <span class="math inline">\((X \vee Z) \wedge (Y \vee Z)\)</span></li>
<li>se <span class="math inline">\(X \vee (Y \wedge Z)\)</span> redefina como <span class="math inline">\((X \vee Y) \wedge (X \vee Z)\)</span></li>
<li>se <span class="math inline">\(\neg\forall x P(x)\)</span> redefina como <span class="math inline">\(\exists x \neg P(x)\)</span></li>
<li>se <span class="math inline">\(\neg\exists x P(x)\)</span> redefina como <span class="math inline">\(\forall x \neg P(x)\)</span></li>
<li>se <span class="math inline">\(\forall x P(x)\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(P\)</span>, redefina como <span class="math inline">\(P\)</span></li>
<li>se <span class="math inline">\(\exists x P(x)\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(P\)</span>, redefina como <span class="math inline">\(P\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (P(x) \vee Y)\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \vee Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (P(x) \vee Y)\)</span></li>
<li>se <span class="math inline">\(Y \vee (\forall x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (Y \vee P(x))\)</span></li>
<li>se <span class="math inline">\(Y \vee (\exists x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (Y \vee P(x))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \wedge Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (P(x) \wedge Y)\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge Y\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (P(x) \wedge Y)\)</span></li>
<li>se <span class="math inline">\(Y \wedge (\forall x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\forall x (Y \wedge P(x))\)</span></li>
<li>se <span class="math inline">\(Y \wedge (\exists x P(x))\)</span> onde <span class="math inline">\(x\)</span> não ocorre livre em <span class="math inline">\(Y\)</span>, redefina como <span class="math inline">\(\exists x (Y \wedge P(x))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \wedge (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \forall y (P(x) \wedge Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \vee (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \exists y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \forall y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \exists y (P(x) \wedge Q(y))\)</span></li>
<li>se <span class="math inline">\((\forall x P(x)) \vee (\exists y Q(y))\)</span> redefina como <span class="math inline">\(\forall x \exists y (P(x) \vee Q(y))\)</span></li>
<li>se <span class="math inline">\((\exists x P(x)) \wedge (\forall y Q(y))\)</span> redefina como <span class="math inline">\(\exists x \forall y (P(x) \wedge Q(y))\)</span></li>
</ol></li>
<li>fim</li>
</ol></li>
<li><strong>até não ocorrerem substituições</strong></li>
<li>Renomeie variáveis ligadas para evitar conflitos</li>
<li>Mova todos os quantificadores para o início da fórmula (prenexação)</li>
</ol>
<section id="exemplo-1-6" class="level4" data-number="7.3.4.1">
<h4 data-number="7.3.4.1" class="anchored" data-anchor-id="exemplo-1-6"><span class="header-section-number">7.3.4.1</span> Exemplo 1</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\forall x (P(x) \rightarrow Q(x)) \wedge \neg(\exists y R(y))\)</span></p>
<p><strong>Solução</strong>: 1. <strong>Eliminar implicações (passo 1.1.1)</strong>:</p>
<p><span class="math display">\[\forall x (\neg P(x) \vee Q(x)) \wedge \neg(\exists y R(y))\]</span></p>
<ol start="2" type="1">
<li><strong>Aplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8)</strong>:</li>
</ol>
<p><span class="math display">\[\forall x (\neg P(x) \vee Q(x)) \wedge \forall y \neg R(y)\]</span></p>
<ol start="4" type="1">
<li><p><strong>Não há mais substituições a serem feitas</strong>.</p></li>
<li><p><strong>Renomear variáveis ligadas (passo 3)</strong>:</p></li>
</ol>
<p><span class="math display">\[\forall x (\neg P(x) \vee Q(x)) \wedge \forall z \neg R(z)\]</span></p>
<ol start="6" type="1">
<li><strong>Mover quantificadores para o início (prenexação, passo 4)</strong>:</li>
</ol>
<p><span class="math display">\[\forall x \forall z ((\neg P(x) \vee Q(x)) \wedge \neg R(z))\]</span></p>
<p><strong>Resultado</strong>:</p>
<p><span class="math display">\[\forall x \forall z ((\neg P(x) \vee Q(x)) \wedge \neg R(z))\]</span></p>
</section>
<section id="exemplo-2-7" class="level4" data-number="7.3.4.2">
<h4 data-number="7.3.4.2" class="anchored" data-anchor-id="exemplo-2-7"><span class="header-section-number">7.3.4.2</span> Exemplo 2</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg(\forall x P(x) \rightarrow \exists y Q(y))\)</span></p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><strong>Eliminar implicações (passo 1.1.1)</strong>:</li>
</ol>
<p><span class="math display">\[\neg(\neg(\forall x P(x)) \vee \exists y Q(y))\]</span></p>
<ol start="2" type="1">
<li><strong>Aplicar lei de De Morgan para negação de disjunção (passo 1.1.2)</strong>:</li>
</ol>
<p><span class="math display">\[\neg\neg(\forall x P(x)) \wedge \neg(\exists y Q(y))\]</span></p>
<ol start="3" type="1">
<li><strong>Eliminar dupla negação (passo 1.1.4)</strong>:</li>
</ol>
<p><span class="math display">\[(\forall x P(x)) \wedge \neg(\exists y Q(y))\]</span></p>
<ol start="4" type="1">
<li><strong>Aplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8)</strong>:</li>
</ol>
<p><span class="math display">\[(\forall x P(x)) \wedge (\forall y \neg Q(y))\]</span></p>
<ol start="5" type="1">
<li><strong>Não há mais substituições a serem feitas</strong>.</li>
<li><strong>Renomear variáveis ligadas (passo 3)</strong>: não é necessário neste caso.</li>
<li><strong>Mover quantificadores para o início (prenexação, passo 4)</strong>:</li>
</ol>
<p><span class="math display">\[\forall x \forall y (P(x) \wedge \neg Q(y))\]</span></p>
<p><strong>Resultado</strong>: <span class="math inline">\(\forall x \forall y (P(x) \wedge \neg Q(y))\)</span></p>
</section>
<section id="exemplo-3-4" class="level4" data-number="7.3.4.3">
<h4 data-number="7.3.4.3" class="anchored" data-anchor-id="exemplo-3-4"><span class="header-section-number">7.3.4.3</span> Exemplo 3</h4>
<p><strong>Fórmula inicial</strong>: $ (P Q) (R (S T)) $</p>
<p><strong>Solução</strong>:</p>
<p><strong>Passo 1: Eliminar Implicações</strong>: primeiro, removemos a implicação <span class="math inline">\(R \rightarrow (S \wedge T)\)</span>, aplicando a regra <span class="math inline">\(X \rightarrow Y \equiv \neg X \vee Y\)</span>:</p>
<p><span class="math display">\[
(P \vee Q) \wedge (\neg R \vee (S \wedge T))
\]</span></p>
<p><strong>Passo 2: Analisar a Matriz para FNC</strong>: a matriz da fórmula precisa ser uma conjunção de disjunções de literais. A primeira cláusula, <span class="math inline">\((P \vee Q)\)</span>, já está nesse formato. No entanto, a segunda cláusula, <span class="math inline">\((\neg R \vee (S \wedge T))\)</span>, contém uma conjunção dentro de uma disjunção, o que impede que a fórmula esteja em FNC. Portanto, precisamos aplicar a distributividade.</p>
<p><strong>Passo 3: Distribuir <span class="math inline">\(\lor\)</span> sobre <span class="math inline">\(\land\)</span></strong>: aplicamos a lei distributiva da disjunção sobre a conjunção na cláusula <span class="math inline">\((\neg R \vee (S \wedge T))\)</span>. A regra é <span class="math inline">\(X \vee (Y \wedge Z) \equiv (X \vee Y) \wedge (X \vee Z)\)</span>:</p>
<p><span class="math display">\[
(P \vee Q) \wedge ((\neg R \vee S) \wedge (\neg R \vee T))
\]</span></p>
<p><strong>Passo 4: Simplificar a Fórmula</strong>: pela propriedade associativa da conjunção, podemos remover os parênteses extras para obter a forma final.</p>
<p><span class="math display">\[
(P \vee Q) \wedge (\neg R \vee S) \wedge (\neg R \vee T)
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final está em FNC, pois é uma conjunção de três cláusulas, onde cada uma é uma disjunção de literais:</p>
<p><span class="math display">\[
(P \vee Q) \wedge (\neg R \vee S) \wedge (\neg R \vee T)
\]</span></p>
</section>
<section id="exemplo-4-5" class="level4" data-number="7.3.4.4">
<h4 data-number="7.3.4.4" class="anchored" data-anchor-id="exemplo-4-5"><span class="header-section-number">7.3.4.4</span> Exemplo 4</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg(\forall x \exists y P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall u R(u))\)</span></p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><strong>Aplicar lei de De Morgan para negação de quantificador universal (passo 1.1.7)</strong>:</li>
</ol>
<p><span class="math display">\[(\exists x \neg(\exists y P(x,y))) \vee (\exists z \forall w Q(z,w) \wedge \forall u R(u))\]</span></p>
<ol start="2" type="1">
<li><strong>Aplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8)</strong>:</li>
</ol>
<p><span class="math display">\[(\exists x \forall y \neg P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall u R(u))\]</span></p>
<ol start="3" type="1">
<li><strong>Não há mais substituições a serem feitas</strong>.</li>
<li><strong>Renomear variáveis ligadas (passo 3)</strong>:</li>
</ol>
<p><span class="math display">\[(\exists x \forall y \neg P(x,y)) \vee (\exists z \forall w Q(z,w) \wedge \forall v R(v))\]</span></p>
<ol start="5" type="1">
<li><strong>Mover quantificadores para o início (prenexação, passo 4)</strong>:</li>
</ol>
<p><span class="math display">\[\exists x \forall y \exists z \forall w \forall v ((\neg P(x,y)) \vee (Q(z,w) \wedge R(v)))\]</span></p>
<ol start="6" type="1">
<li><strong>Distribuir <span class="math inline">\(\vee\)</span> sobre <span class="math inline">\(\wedge\)</span> (passo 1.1.6)</strong>:</li>
</ol>
<p><span class="math display">\[\exists x \forall y \exists z \forall w \forall v ((\neg P(x,y) \vee Q(z,w)) \wedge (\neg P(x,y) \vee R(v)))\]</span></p>
<p><strong>Resultado final</strong>:</p>
<p><span class="math display">\[\exists x \forall y \exists z \forall w \forall v ((\neg P(x,y) \vee Q(z,w)) \wedge (\neg P(x,y) \vee R(v)))\]</span></p>
</section>
<section id="exemplo-5-4" class="level4" data-number="7.3.4.5">
<h4 data-number="7.3.4.5" class="anchored" data-anchor-id="exemplo-5-4"><span class="header-section-number">7.3.4.5</span> Exemplo 5</h4>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\forall x (P(x) \vee (Q(x) \wedge R(x))) \wedge \neg(\exists y S(y))\)</span></p>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><strong>Aplicar distribuição (passo 1.1.6)</strong>:</li>
</ol>
<p><span class="math display">\[\forall x ((P(x) \vee Q(x)) \wedge (P(x) \vee R(x))) \wedge \neg(\exists y S(y))\]</span></p>
<ol start="2" type="1">
<li><strong>Aplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8)</strong>:</li>
</ol>
<p><span class="math display">\[\forall x ((P(x) \vee Q(x)) \wedge (P(x) \vee R(x))) \wedge \forall y \neg S(y)\]</span></p>
<ol start="3" type="1">
<li><strong>Não há mais substituições a serem feitas</strong>.</li>
<li><strong>Renomear variáveis ligadas (passo 3)</strong>:</li>
</ol>
<p><span class="math display">\[\forall x ((P(x) \vee Q(x)) \wedge (P(x) \vee R(x))) \wedge \forall z \neg S(z)\]</span></p>
<ol start="5" type="1">
<li><strong>Mover quantificadores para o início (prenexação, passo 4)</strong>:</li>
</ol>
<p><span class="math display">\[\forall x \forall z (((P(x) \vee Q(x)) \wedge (P(x) \vee R(x))) \wedge \neg S(z))\]</span></p>
<p><strong>Resultado</strong>:</p>
<p><span class="math display">\[\forall x \forall z (((P(x) \vee Q(x)) \wedge (P(x) \vee R(x))) \wedge \neg S(z))\]</span></p>
</section>
</section>
<section id="sec-exercicios-formas-normais-prenex" class="level3" data-number="7.3.5">
<h3 data-number="7.3.5" class="anchored" data-anchor-id="sec-exercicios-formas-normais-prenex"><span class="header-section-number">7.3.5</span> Exercícios Formas Normais Prenex</h3>
<p>Vou resolver cada um desses exercícios utilizando os algoritmos que definimos para FNC e FND. Começaremos com a fórmula em Lógica de Primeiro Grau e aplicaremos os algoritmos passo a passo.</p>
<section id="exercício-1" class="level4" data-number="7.3.5.1">
<h4 data-number="7.3.5.1" class="anchored" data-anchor-id="exercício-1"><span class="header-section-number">7.3.5.1</span> Exercício 1:</h4>
<p>Transforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: <em>Todos os alunos estudam ou alguns professores ensinam matemática</em>.</p>
<p><strong>Solução</strong></p>
<p>Expressando a sentença em Lógica de Primeiro Grau, teremos:</p>
<p><span class="math display">\[(\forall x (A(x) \rightarrow E(x))) \lor (\exists y (P(y) \land M(y)))\]</span></p>
<section id="solução-para-fnc" class="level5" data-number="7.3.5.1.1">
<h5 data-number="7.3.5.1.1" class="anchored" data-anchor-id="solução-para-fnc"><span class="header-section-number">7.3.5.1.1</span> Solução para FNC:</h5>
<p><strong>Passo 1: Remover Implicações</strong>: primeiro, removemos a implicação <span class="math inline">\(A(x) \rightarrow E(x)\)</span>, aplicando a regra <span class="math inline">\(X \rightarrow Y \equiv \neg X \vee Y\)</span>:</p>
<p><span class="math display">\[
(\forall x (\neg A(x) \vee E(x))) \lor (\exists y (P(y) \land M(y)))
\]</span></p>
<p><strong>Passo 2: Mover Quantificadores para o Início (Prenexação)</strong>: movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex. Como as variáveis <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> são independentes, a ordem entre <span class="math inline">\(\forall x\)</span> e <span class="math inline">\(\exists y\)</span> pode ser escolhida livremente.</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee E(x)) \lor (P(y) \land M(y)))
\]</span></p>
<p><strong>Passo 3: Distribuir <span class="math inline">\(\lor\)</span> sobre <span class="math inline">\(\land\)</span></strong>: agora, para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma <span class="math inline">\(Z \lor (X \land Y)\)</span>, que é equivalente a <span class="math inline">\((Z \lor X) \land (Z \lor Y)\)</span>:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee E(x) \vee P(y)) \land (\neg A(x) \vee E(x) \vee M(y)))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final em FNC é:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee E(x) \vee P(y)) \land (\neg A(x) \vee E(x) \vee M(y)))
\]</span></p>
</section>
<section id="solução-para-fnd" class="level5" data-number="7.3.5.1.2">
<h5 data-number="7.3.5.1.2" class="anchored" data-anchor-id="solução-para-fnd"><span class="header-section-number">7.3.5.1.2</span> Solução para FND:</h5>
<p><strong>Passo 1: Remover Implicações e Realizar a Prenexação</strong>: os passos iniciais são idênticos aos da conversão para FNC. Removemos as implicações e movemos os quantificadores para obter a forma prenex.</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee E(x)) \lor (P(y) \land M(y)))
\]</span></p>
<p><strong>Passo 2: Analisar a Matriz</strong>: o algoritmo para FND exige que a matriz da fórmula seja uma disjunção de conjunções de literais. Analisando a matriz <span class="math inline">\((\neg A(x) \vee E(x)) \lor (P(y) \land M(y))\)</span>, notamos que ela já satisfaz essa condição. Ela é uma disjunção entre os literais <span class="math inline">\(\neg A(x)\)</span>, <span class="math inline">\(E(x)\)</span> e a conjunção <span class="math inline">\((P(y) \land M(y))\)</span>. Assim, nenhuma etapa adicional de distribuição é necessária.</p>
<p><strong>Resultado</strong>: a fórmula final em FND é:</p>
<p><span class="math display">\[
\forall x \exists y (\neg A(x) \vee E(x) \vee (P(y) \land M(y)))
\]</span></p>
</section>
</section>
<section id="exercício-2" class="level4" data-number="7.3.5.2">
<h4 data-number="7.3.5.2" class="anchored" data-anchor-id="exercício-2"><span class="header-section-number">7.3.5.2</span> Exercício 2</h4>
<p>Transforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: <em>Algum aluno estuda e todo professor ensina</em>.</p>
<p><strong>Solução</strong>: Representando a sentença em Lógica de Primeiro Grau, teremos:</p>
<p><span class="math display">\[(\exists x (A(x) \land E(x))) \land (\forall y (P(y) \rightarrow N(y)))\]</span></p>
<section id="solução-para-fnd-1" class="level5" data-number="7.3.5.2.1">
<h5 data-number="7.3.5.2.1" class="anchored" data-anchor-id="solução-para-fnd-1"><span class="header-section-number">7.3.5.2.1</span> Solução para FND:</h5>
<p><strong>Passo 1: Remover Implicações</strong>: primeiro, removemos a implicação <span class="math inline">\(P(y) \rightarrow N(y)\)</span>, aplicando a regra <span class="math inline">\(X \rightarrow Y \equiv \neg X \vee Y\)</span>:</p>
<p><span class="math display">\[
(\exists x (A(x) \land E(x))) \land (\forall y (\neg P(y) \lor N(y)))
\]</span></p>
<p><strong>Passo 2: Mover Quantificadores para o Início (Prenexação)</strong>: movemos os quantificadores para o início da fórmula. A fórmula resultante está na Forma Normal Prenex.</p>
<p><span class="math display">\[
\exists x \forall y ((A(x) \land E(x)) \land (\neg P(y) \lor N(y)))
\]</span></p>
<p><strong>Passo 3: Distribuir <span class="math inline">\(\land\)</span> sobre <span class="math inline">\(\lor\)</span></strong>: a matriz da fórmula, <span class="math inline">\((A(x) \land E(x)) \land (\neg P(y) \lor N(y))\)</span>, ainda não está em FND. Para convertê-la, aplicamos a lei distributiva da conjunção sobre a disjunção. A expressão tem a forma <span class="math inline">\(Z \land (X \lor Y)\)</span>, que é equivalente a <span class="math inline">\((Z \land X) \lor (Z \land Y)\)</span>:</p>
<p><span class="math display">\[
\exists x \forall y (((A(x) \land E(x)) \land \neg P(y)) \lor ((A(x) \land E(x)) \land N(y)))
\]</span></p>
<p><strong>Passo 4: Simplificar a Matriz</strong>: podemos remover os parênteses internos nas cláusulas conjuntivas para obter a forma final.</p>
<p><span class="math display">\[
\exists x \forall y ((A(x) \land E(x) \land \neg P(y)) \lor (A(x) \land E(x) \land N(y)))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final está em FND, pois sua matriz é uma disjunção de duas cláusulas conjuntivas:</p>
<p><span class="math display">\[
\exists x \forall y ((A(x) \land E(x) \land \neg P(y)) \lor (A(x) \land E(x) \land N(y)))
\]</span></p>
</section>
</section>
<section id="exercício-3" class="level4" data-number="7.3.5.3">
<h4 data-number="7.3.5.3" class="anchored" data-anchor-id="exercício-3"><span class="header-section-number">7.3.5.3</span> Exercício 3</h4>
<p>Transforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: <em>Todo estudante é inteligente ou algum professor é sábio</em>.</p>
<p>Transformando a sentença em Lógica de Primeiro Grau, teremos:</p>
<p><span class="math display">\[(\forall x (E(x) \rightarrow I(x))) \lor (\exists y (P(y) \land S(y)))\]</span></p>
<section id="solução-para-fnc-1" class="level5" data-number="7.3.5.3.1">
<h5 data-number="7.3.5.3.1" class="anchored" data-anchor-id="solução-para-fnc-1"><span class="header-section-number">7.3.5.3.1</span> Solução para FNC:</h5>
<p><strong>Passo 1: Remover Implicações</strong>: primeiro, removemos a implicação <span class="math inline">\(E(x) \rightarrow I(x)\)</span>, aplicando a regra <span class="math inline">\(X \rightarrow Y \equiv \neg X \vee Y\)</span>:</p>
<p><span class="math display">\[
(\forall x (\neg E(x) \vee I(x))) \lor (\exists y (P(y) \land S(y)))
\]</span></p>
<p><strong>Passo 2: Mover Quantificadores para o Início (Prenexação)</strong>: movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex.</p>
<p><span class="math display">\[
\forall x \exists y ((\neg E(x) \vee I(x)) \lor (P(y) \land S(y)))
\]</span></p>
<p><strong>Passo 3: Distribuir <span class="math inline">\(\lor\)</span> sobre <span class="math inline">\(\land\)</span></strong>: para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma <span class="math inline">\(Z \lor (X \land Y)\)</span>, que é equivalente a <span class="math inline">\((Z \lor X) \land (Z \lor Y)\)</span>:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg E(x) \vee I(x) \vee P(y)) \land (\neg E(x) \vee I(x) \vee S(y)))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final em FNC é:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg E(x) \vee I(x) \vee P(y)) \land (\neg E(x) \vee I(x) \vee S(y)))
\]</span></p>
</section>
<section id="solução-para-fnd-2" class="level5" data-number="7.3.5.3.2">
<h5 data-number="7.3.5.3.2" class="anchored" data-anchor-id="solução-para-fnd-2"><span class="header-section-number">7.3.5.3.2</span> Solução para FND:</h5>
<p><strong>Passo 1: Remover Implicações e Realizar a Prenexação</strong>: os passos iniciais são os mesmos da conversão para FNC, resultando na forma prenex:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg E(x) \vee I(x)) \lor (P(y) \land S(y)))
\]</span></p>
<p><strong>Passo 2: Analisar a Matriz</strong>: o algoritmo para FND exige que a matriz seja uma disjunção de conjunções. Analisando a matriz <span class="math inline">\((\neg E(x) \vee I(x)) \lor (P(y) \land S(y))\)</span>, notamos que ela já satisfaz essa condição. É uma disjunção de literais (<span class="math inline">\(\neg E(x)\)</span>, <span class="math inline">\(I(x)\)</span>) e uma conjunção (<span class="math inline">\((P(y) \land S(y))\)</span>). Nenhuma etapa de distribuição é necessária.</p>
<p><strong>Resultado</strong>: a fórmula final em FND é:</p>
<p><span class="math display">\[
\forall x \exists y (\neg E(x) \vee I(x) \vee (P(y) \land S(y)))
\]</span></p>
</section>
</section>
<section id="exercício-4" class="level4" data-number="7.3.5.4">
<h4 data-number="7.3.5.4" class="anchored" data-anchor-id="exercício-4"><span class="header-section-number">7.3.5.4</span> Exercício 4</h4>
<p>Transforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: <em>Todo animal corre ou algum pássaro voa</em>.</p>
<p>Em Lógica de Primeiro Grau, teremos:</p>
<p><span class="math display">\[(\forall x (A(x) \rightarrow C(x))) \lor (\exists y (P(y) \land V(y)))\]</span></p>
<section id="solução-para-fnc-2" class="level5" data-number="7.3.5.4.1">
<h5 data-number="7.3.5.4.1" class="anchored" data-anchor-id="solução-para-fnc-2"><span class="header-section-number">7.3.5.4.1</span> Solução para FNC:</h5>
<p><strong>Passo 1: Remover Implicações</strong>: primeiro, removemos a implicação <span class="math inline">\(A(x) \rightarrow C(x)\)</span>, aplicando a regra <span class="math inline">\(X \rightarrow Y \equiv \neg X \vee Y\)</span>:</p>
<p><span class="math display">\[
(\forall x (\neg A(x) \vee C(x))) \lor (\exists y (P(y) \land V(y)))
\]</span></p>
<p><strong>Passo 2: Mover Quantificadores para o Início (Prenexação)</strong>: movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex.</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee C(x)) \lor (P(y) \land V(y)))
\]</span></p>
<p><strong>Passo 3: Distribuir <span class="math inline">\(\lor\)</span> sobre <span class="math inline">\(\land\)</span></strong>: para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma <span class="math inline">\(Z \lor (X \land Y)\)</span>, que é equivalente a <span class="math inline">\((Z \lor X) \land (Z \lor Y)\)</span>:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee C(x) \vee P(y)) \land (\neg A(x) \vee C(x) \vee V(y)))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final em FNC é:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee C(x) \vee P(y)) \land (\neg A(x) \vee C(x) \vee V(y)))
\]</span></p>
</section>
<section id="solução-para-fnd-3" class="level5" data-number="7.3.5.4.2">
<h5 data-number="7.3.5.4.2" class="anchored" data-anchor-id="solução-para-fnd-3"><span class="header-section-number">7.3.5.4.2</span> Solução para FND:</h5>
<p><strong>Passo 1: Remover Implicações e Realizar a Prenexação</strong>: os passos iniciais são os mesmos da conversão para FNC, resultando na forma prenex:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg A(x) \vee C(x)) \lor (P(y) \land V(y)))
\]</span></p>
<p><strong>Passo 2: Analisar a Matriz</strong>: o algoritmo para FND exige que a matriz seja uma disjunção de conjunções. Analisando a matriz <span class="math inline">\((\neg A(x) \vee C(x)) \lor (P(y) \land V(y))\)</span>, notamos que ela já satisfaz essa condição. É uma disjunção de literais (<span class="math inline">\(\neg A(x)\)</span>, <span class="math inline">\(C(x)\)</span>) e uma conjunção (<span class="math inline">\((P(y) \land V(y))\)</span>). Nenhuma etapa de distribuição é necessária.</p>
<p><strong>Resultado</strong>: a fórmula final em FND é:</p>
<p><span class="math display">\[
\forall x \exists y (\neg A(x) \vee C(x) \vee (P(y) \land V(y)))
\]</span></p>
</section>
</section>
<section id="exercício-5" class="level4" data-number="7.3.5.5">
<h4 data-number="7.3.5.5" class="anchored" data-anchor-id="exercício-5"><span class="header-section-number">7.3.5.5</span> Exercício 5</h4>
<p>Converta a seguinte fórmula para a Forma Normal Conjuntiva Prenex (FNCP).</p>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\(\neg (\forall x (P(x) \rightarrow \exists y Q(x,y)) \leftrightarrow \exists z R(z))\)</span></p>
<p><strong>Solução</strong></p>
<section id="solução-para-fnc-3" class="level5" data-number="7.3.5.5.1">
<h5 data-number="7.3.5.5.1" class="anchored" data-anchor-id="solução-para-fnc-3"><span class="header-section-number">7.3.5.5.1</span> Solução para FNC:</h5>
<p><strong>Passo 1: Eliminar a Equivalência (<span class="math inline">\(\leftrightarrow\)</span>)</strong>: A fórmula tem a estrutura <span class="math inline">\(\neg(A \leftrightarrow B)\)</span>. Primeiro, expandimos a bicondicional usando a regra <span class="math inline">\(A \leftrightarrow B \equiv (A \wedge B) \vee (\neg A \wedge \neg B)\)</span>, e aplicamos a negação externa.</p>
<p><span class="math display">\[
\neg ((\forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \exists z R(z)) \vee (\neg \forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \neg \exists z R(z)))
\]</span></p>
<p>Aplicando a lei de De Morgan na disjunção principal, obtemos:</p>
<p><span class="math display">\[
\neg (\forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \exists z R(z)) \wedge \neg (\neg \forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \neg \exists z R(z))
\]</span></p>
<p>Aplicando a lei de De Morgan novamente em ambas as conjunções:</p>
<p><span class="math display">\[
(\neg \forall x (P(x) \rightarrow \exists y Q(x,y)) \vee \neg \exists z R(z)) \wedge (\neg \neg \forall x (P(x) \rightarrow \exists y Q(x,y)) \vee \neg \neg \exists z R(z))
\]</span></p>
<p><strong>Passo 2: Eliminar Implicações e Duplas Negações</strong>: Agora, eliminamos as implicações e as duplas negações, e movemos as negações para dentro (conversão para FNN).</p>
<p><span class="math display">\[
(\exists x \neg (P(x) \rightarrow \exists y Q(x,y)) \vee \forall z \neg R(z)) \wedge (\forall x (P(x) \rightarrow \exists y Q(x,y)) \vee \exists z R(z))
\]</span></p>
<p><span class="math display">\[
(\exists x \neg (\neg P(x) \vee \exists y Q(x,y)) \vee \forall z \neg R(z)) \wedge (\forall x (\neg P(x) \vee \exists y Q(x,y)) \vee \exists z R(z))
\]</span></p>
<p><span class="math display">\[
(\exists x (P(x) \wedge \forall y \neg Q(x,y)) \vee \forall z \neg R(z)) \wedge (\forall x (\neg P(x) \vee \exists y Q(x,y)) \vee \exists z R(z))
\]</span></p>
<p><strong>Passo 3: Renomear Variáveis e Prenexação</strong>: Renomeamos as variáveis para evitar conflitos de escopo (<span class="math inline">\(x \rightarrow u, y \rightarrow v, z \rightarrow w\)</span>) e movemos todos os quantificadores para o início. A ordem dos quantificadores é <span class="math inline">\(\exists x \forall y \forall z\)</span> da primeira parte, e <span class="math inline">\(\forall u \exists v \exists w\)</span> da segunda.</p>
<p><span class="math display">\[
\exists x \forall y \forall z \forall u \exists v \exists w [ ( (P(x) \wedge \neg Q(x,y)) \vee \neg R(z) ) \wedge ( (\neg P(u) \vee Q(u,v)) \vee R(w) ) ]
\]</span></p>
<p><strong>Passo 4: Converter a Matriz para FNC</strong>: A matriz precisa ser uma conjunção de disjunções. A primeira parte, <span class="math inline">\((P(x) \wedge \neg Q(x,y)) \vee \neg R(z)\)</span>, precisa ser distribuída: <span class="math inline">\((P(x) \vee \neg R(z)) \wedge (\neg Q(x,y) \vee \neg R(z))\)</span>. A segunda parte, <span class="math inline">\((\neg P(u) \vee Q(u,v)) \vee R(w)\)</span>, já está na forma disjuntiva.</p>
<p><span class="math display">\[
\exists x \forall y \forall z \forall u \exists v \exists w [ (P(x) \vee \neg R(z)) \wedge (\neg Q(x,y) \vee \neg R(z)) \wedge (\neg P(u) \vee Q(u,v) \vee R(w)) ]
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final em FNCP é:</p>
<p><span class="math display">\[
\exists x \forall y \forall z \forall u \exists v \exists w [ (P(x) \vee \neg R(z)) \wedge (\neg Q(x,y) \vee \neg R(z)) \wedge (\neg P(u) \vee Q(u,v) \vee R(w)) ]
\]</span></p>
</section>
</section>
<section id="exercício-6" class="level4" data-number="7.3.5.6">
<h4 data-number="7.3.5.6" class="anchored" data-anchor-id="exercício-6"><span class="header-section-number">7.3.5.6</span> Exercício 6</h4>
<p>Converta a seguinte fórmula para a Forma Normal Disjuntiva Prenex (FNDP).</p>
<p><strong>Fórmula inicial</strong>: <span class="math inline">\((\exists x P(x) \rightarrow \forall y Q(y)) \wedge (\exists z R(z) \rightarrow \forall w S(w))\)</span></p>
<p><strong>Solução</strong></p>
<section id="solução-para-fnd-4" class="level5" data-number="7.3.5.6.1">
<h5 data-number="7.3.5.6.1" class="anchored" data-anchor-id="solução-para-fnd-4"><span class="header-section-number">7.3.5.6.1</span> Solução para FND:</h5>
<p><strong>Passo 1: Eliminar Implicações</strong>: Removemos as implicações em ambas as cláusulas da conjunção.</p>
<p><span class="math display">\[
(\neg \exists x P(x) \vee \forall y Q(y)) \wedge (\neg \exists z R(z) \vee \forall w S(w))
\]</span></p>
<p><strong>Passo 2: Mover Negações para Dentro (FNN)</strong>: Aplicamos as regras de negação dos quantificadores.</p>
<p><span class="math display">\[
(\forall x \neg P(x) \vee \forall y Q(y)) \wedge (\forall z \neg R(z) \vee \forall w S(w))
\]</span></p>
<p><strong>Passo 3: Prenexação</strong>: Renomeamos as variáveis na segunda cláusula para evitar conflitos (<span class="math inline">\(z \rightarrow u, w \rightarrow v\)</span>) e movemos todos os quantificadores para o início da fórmula.</p>
<p><span class="math display">\[
\forall x \forall y \forall u \forall v [ (\neg P(x) \vee Q(y)) \wedge (\neg R(u) \vee S(v)) ]
\]</span></p>
<p><strong>Passo 4: Converter a Matriz para FND</strong>: A matriz atual, <span class="math inline">\((\neg P(x) \vee Q(y)) \wedge (\neg R(u) \vee S(v))\)</span>, tem a forma <span class="math inline">\((A \vee B) \wedge (C \vee D)\)</span>, que não está em FND. Precisamos aplicar a lei distributiva para convertê-la em uma disjunção de conjunções. Distribuindo <span class="math inline">\((A \vee B)\)</span> sobre <span class="math inline">\((C \vee D)\)</span>, obtemos: <span class="math inline">\(((A \vee B) \wedge C) \vee ((A \vee B) \wedge D)\)</span>. Isso expande para: <span class="math inline">\((A \wedge C) \vee (B \wedge C) \vee (A \wedge D) \vee (B \wedge D)\)</span>.</p>
<p>Aplicando aos nossos literais:</p>
<p><span class="math display">\[
(\neg P(x) \wedge \neg R(u)) \vee (Q(y) \wedge \neg R(u)) \vee (\neg P(x) \wedge S(v)) \vee (Q(y) \wedge S(v))
\]</span></p>
<p><strong>Resultado</strong>: a fórmula final em FNDP, com a matriz distribuída, é:</p>
<p><span class="math display">\[
\forall x \forall y \forall u \forall v [ (\neg P(x) \wedge \neg R(u)) \vee (Q(y) \wedge \neg R(u)) \vee (\neg P(x) \wedge S(v)) \vee (Q(y) \wedge S(v)) ]
\]</span></p>
</section>
</section>
<section id="exercício-7" class="level4" data-number="7.3.5.7">
<h4 data-number="7.3.5.7" class="anchored" data-anchor-id="exercício-7"><span class="header-section-number">7.3.5.7</span> Exercício 7</h4>
<p>Transforme a sentença a seguir em Forma Normal Conjuntiva Prenex (FNCP) e Forma Normal Disjuntiva Prenex (FNDP): <em>Se para todo problema existe uma solução, então não é verdade que todos os problemas são difíceis</em>.</p>
<p><strong>Solução</strong></p>
<p>Primeiro, formalizamos a sentença: * <span class="math inline">\(P(x)\)</span>: <span class="math inline">\(x\)</span> é um problema. * <span class="math inline">\(S(x,y)\)</span>: <span class="math inline">\(y\)</span> é uma solução para <span class="math inline">\(x\)</span>. * <span class="math inline">\(D(x)\)</span>: <span class="math inline">\(x\)</span> é difícil.</p>
<p>A fórmula em lógica de primeira ordem é:</p>
<p><span class="math display">\[
(\forall x (P(x) \rightarrow \exists y S(x,y))) \rightarrow (\neg \forall z (P(z) \rightarrow D(z)))
\]</span></p>
<p><strong>Passo 1: Eliminar Implicações e Mover Negações (FNN)</strong>: Começamos eliminando a implicação principal e, em seguida, as internas.</p>
<p><span class="math display">\[
\neg (\forall x (\neg P(x) \vee \exists y S(x,y))) \vee (\neg \forall z (\neg P(z) \vee D(z)))
\]</span></p>
<p>Agora, movemos as negações para dentro dos quantificadores.</p>
<p><span class="math display">\[
(\exists x \neg (\neg P(x) \vee \exists y S(x,y))) \vee (\exists z \neg (\neg P(z) \vee D(z)))
\]</span></p>
<p>Aplicamos a lei de De Morgan nas disjunções.</p>
<p><span class="math display">\[
(\exists x (P(x) \wedge \neg \exists y S(x,y))) \vee (\exists z (P(z) \wedge \neg D(z)))
\]</span></p>
<p>Finalizamos a conversão para FNN.</p>
<p><span class="math display">\[
(\exists x (P(x) \wedge \forall y \neg S(x,y))) \vee (\exists z (P(z) \wedge \neg D(z)))
\]</span></p>
<p><strong>Passo 2: Prenexação</strong>: Renomeamos a variável <span class="math inline">\(z\)</span> para <span class="math inline">\(w\)</span> para evitar conflito e movemos os quantificadores para o início.</p>
<p><span class="math display">\[
\exists x \forall y \exists w [ (P(x) \wedge \neg S(x,y)) \vee (P(w) \wedge \neg D(w)) ]
\]</span></p>
<p>Esta é a Forma Normal Prenex. Agora, vamos converter a matriz para FNC e FND. A matriz é <span class="math inline">\((P(x) \wedge \neg S(x,y)) \vee (P(w) \wedge \neg D(w))\)</span>.</p>
<section id="solução-para-fnd-5" class="level5" data-number="7.3.5.7.1">
<h5 data-number="7.3.5.7.1" class="anchored" data-anchor-id="solução-para-fnd-5"><span class="header-section-number">7.3.5.7.1</span> Solução para FND:</h5>
<p>A matriz <span class="math inline">\((P(x) \wedge \neg S(x,y)) \vee (P(w) \wedge \neg D(w))\)</span> já está na Forma Normal Disjuntiva, pois é uma disjunção de duas conjunções de literais. Portanto, nenhum passo adicional de distribuição é necessário.</p>
<p><strong>Resultado (FNDP)</strong>:</p>
<p><span class="math display">\[
\exists x \forall y \exists w [ (P(x) \wedge \neg S(x,y)) \vee (P(w) \wedge \neg D(w)) ]
\]</span></p>
</section>
<section id="solução-para-fnc-4" class="level5" data-number="7.3.5.7.2">
<h5 data-number="7.3.5.7.2" class="anchored" data-anchor-id="solução-para-fnc-4"><span class="header-section-number">7.3.5.7.2</span> Solução para FNC:</h5>
<p>Para converter a matriz para FNC, precisamos distribuir a disjunção sobre a conjunção. A matriz tem a forma <span class="math inline">\((A \wedge B) \vee (C \wedge D)\)</span>. Aplicando a distributividade, obtemos <span class="math inline">\(( (A \wedge B) \vee C ) \wedge ( (A \wedge B) \vee D )\)</span>. Expandindo novamente, resulta em <span class="math inline">\((A \vee C) \wedge (B \vee C) \wedge (A \vee D) \wedge (B \vee D)\)</span>.</p>
<p>Aplicando aos nossos literais, a matriz se torna:</p>
<p><span class="math display">\[
(P(x) \vee P(w)) \wedge (\neg S(x,y) \vee P(w)) \wedge (P(x) \vee \neg D(w)) \wedge (\neg S(x,y) \vee \neg D(w))
\]</span></p>
<p><strong>Resultado (FNCP)</strong>:</p>
<p><span class="math display">\[
\exists x \forall y \exists w [ (P(x) \vee P(w)) \wedge (\neg S(x,y) \vee P(w)) \wedge (P(x) \vee \neg D(w)) \wedge (\neg S(x,y) \vee \neg D(w)) ]
\]</span></p>
</section>
</section>
</section>
</section>
<section id="sec-predicativa-conexao-prolog" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="sec-predicativa-conexao-prolog"><span class="header-section-number">7.4</span> Exercícios de Conexão com Prolog</h2>
<p>A conversão de fórmulas para uma <strong>Forma Normal</strong> (seja Conjuntiva - <strong>Forma Normal Conjuntiva</strong>, ou Disjuntiva - <strong>Forma Normal Disjuntiva</strong>) é um processo algorítmico que permite a padronização e a manipulação de expressões lógicas por computadores. Este conjunto de questões foca nesta habilidade, que é a base para o funcionamento de provadores de teoremas e do mecanismo de resolução do Prolog.</p>
<p><strong>Questão 1: Conversão Básica</strong>: dada a seguinte fórmula lógica, que representa uma regra de negócio simples: “Se o pedido (<span class="math inline">\(P\)</span>) foi aprovado, então a nota fiscal (<span class="math inline">\(N\)</span>) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (<span class="math inline">\(E\)</span>).” Fórmula:</p>
<p><span class="math display">\[(P \to N) \wedge \neg (N \wedge \neg E)\]</span></p>
<p>Converta esta fórmula para:</p>
<ol type="1">
<li>A Forma Normal Conjuntiva.<br>
</li>
<li>A Forma Normal Disjuntiva.</li>
</ol>
<p><strong>Questão 2: Cenários de Ativação de Sistema</strong>: um sistema de irrigação automática (<span class="math inline">\(I\)</span>) é ativado se o sensor de umidade do solo indicar que está seco (<span class="math inline">\(S\)</span>) ou se não choveu nas últimas 24 horas (<span class="math inline">\(\neg C\)</span>) e a temperatura está alta (<span class="math inline">\(T\)</span>).</p>
<ol type="1">
<li>Modele a condição de ativação (<span class="math inline">\(I\)</span>) como uma fórmula lógica.<br>
</li>
<li>Converta a fórmula para a Forma Normal Disjuntiva. O que cada termo da Forma Normal Disjuntiva representa em termos de cenários práticos de ativação?</li>
</ol>
<p><strong>Questão 3: Verificação de Consistência de Regras</strong>: as regras de configuração de um firewall são:</p>
<ol type="1">
<li>Se uma conexão é da rede interna (<span class="math inline">\(I\)</span>), ela é permitida (<span class="math inline">\(P\)</span>).<br>
</li>
<li>Se uma conexão não é da rede interna, ela só é permitida se for uma conexão segura (<span class="math inline">\(S\)</span>).<br>
</li>
<li>Uma conexão segura nunca vem da rede interna.</li>
</ol>
<p>Modele as três regras como uma única fórmula. Converta-a para a Forma Normal Conjuntiva. A Forma Normal Conjuntiva resultante indica se as regras são consistentes? O que aconteceria se uma conexão fosse segura e viesse da rede interna?</p>
<p><strong>Questão 4: Equivalência de Políticas de Segurança</strong>: dois administradores de sistemas escreveram políticas de acesso a um servidor de desenvolvimento.</p>
<ul>
<li><p><strong>Política de Alice</strong>: “Um desenvolvedor (<span class="math inline">\(D\)</span>) pode acessar o servidor se tiver uma chave de acesso (<span class="math inline">\(C\)</span>), ou se não tiver uma chave de acesso mas estiver trabalhando em um projeto crítico (<span class="math inline">\(P\)</span>).”</p></li>
<li><p><strong>Política de Beto</strong>: “Um desenvolvedor (<span class="math inline">\(D\)</span>) pode acessar o servidor se estiver trabalhando em um projeto crítico (<span class="math inline">\(P\)</span>), ou se tiver uma chave de acesso (<span class="math inline">\(C\)</span>).”</p></li>
</ul>
<p>Modele as duas políticas como fórmulas lógicas e converta ambas para a Forma Normal Disjuntiva Mínima. Elas são logicamente equivalentes?</p>
<p><strong>Questão 5: Eliminando a Bicondicional</strong>: uma regra de um e-commerce afirma: “Um cliente recebe frete grátis (<span class="math inline">\(F\)</span>) se, e somente se, ele for um membro Prime (<span class="math inline">\(P\)</span>) ou o valor do seu pedido for superior a R$100 (<span class="math inline">\(V\)</span>).”</p>
<p>Fórmula:</p>
<p><span class="math display">\[F \leftrightarrow (P \vee V)\]</span></p>
<p>Converta esta fórmula para a Forma Normal Conjuntiva. Cada cláusula da Forma Normal Conjuntiva representa que tipo de restrição no sistema?</p>
<p><strong>Questão 6: Simplificação de Circuito Lógico</strong>: a saída de um circuito lógico com três entradas (<span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>) é descrita pela seguinte tabela verdade:</p>
<table class="table">
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(C\)</span></th>
<th>Saída</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>Escreva a Forma Normal Disjuntiva canônica a partir da tabela.</p></li>
<li><p>Use um Mapa de Karnaugh ou álgebra booleana para encontrar a Forma Normal Disjuntiva mínima.</p></li>
</ol>
<p><strong>Questão 7: Validando uma Inferência (Tautologia)</strong>: considere que “Todos os leões são mamíferos” e “Simba é um leão”, podemos concluir “Simba é um mamífero”. Prove que a estrutura lógica desta inferência é uma tautologia:</p>
<p><span class="math display">\[((\forall x(L(x) \to M(x))) \wedge L(S)) \to M(S)\]</span></p>
<p><strong>Questão 8: Problema de Satisfatibilidade (SAT)</strong>: três programadores (Ana, Beto, Carla) precisam ser alocados para um projeto. As restrições são:</p>
<ol type="1">
<li>Pelo menos um dos três deve ser alocado;<br>
</li>
<li>Ana e Beto não podem trabalhar juntos;</li>
<li>Se Carla for alocada, então Ana também deve ser.</li>
</ol>
<p>Sejam <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> as proposições “Ana foi alocada”, “Beto foi alocado” e “Carla foi alocada”. Modele as três restrições e converta-as para um conjunto de cláusulas em Forma Normal Conjuntiva. O conjunto de restrições é satisfatível? Se sim, apresente uma alocação válida.</p>
<p><strong>Questão 9: Forma Normal Prenex</strong>: a conversão para Forma Normal Clausal, que veremos no próximo capítulo, muitas vezes começa com a conversão para a Forma Normal Prenex, na qual todos os quantificadores são movidos para o início da fórmula.<br>
Converta a seguinte fórmula para a Forma Normal Prenex:</p>
<p><span class="math display">\[\forall x (P(x) \to (\exists y (Q(y) \wedge R(x,y)))) \vee \exists z S(z)\]</span></p>
<p><strong>Questão 10: O Princípio da Resolução</strong>: o Princípio da Resolução é um método de inferência que opera sobre cláusulas em Forma Normal Conjuntiva. Dadas duas cláusulas <span class="math inline">\((\neg P \vee Q)\)</span> e <span class="math inline">\((P \vee R)\)</span>, podemos inferir a cláusula resolvente <span class="math inline">\((Q \vee R)\)</span>.<br>
Use o Princípio da Resolução para provar que o seguinte conjunto de cláusulas é inconsistente (leva à cláusula vazia, <span class="math inline">\(\square\)</span>):</p>
<ol type="1">
<li><span class="math inline">\(\neg P \vee \neg Q \vee R\)</span>;<br>
</li>
<li><span class="math inline">\(P \vee R\)</span>;<br>
</li>
<li><span class="math inline">\(Q\)</span>;<br>
</li>
<li><span class="math inline">\(\neg R\)</span>.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./04-logica-predicativa-e-quantificadores.html" class="pagination-link" aria-label="Lógica de Primeira Ordem: Lógica Predicativa">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./06-clausulas-de-horn-e-prolog.html" class="pagination-link" aria-label="Cláusulas de Horn">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Cláusulas de Horn</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/05-formas-normais-e-skolemizacao.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>