<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 7&nbsp; Formas Normais Organizando o Pensamento Lógico</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06-construcao-de-mundos-logicos.html" rel="next">
<link href="./04-logica-predicativa-e-quantificadores.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução ao Paradigma da Programação Lógica</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-introducao-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introdução Prática ao Prolog com Swish</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Proposicional</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">A Arte da Prova e Análise de Argumentos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Mundos na <strong>Lógica de Primeira Ordem</strong></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Cláusulas de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Problemas Interessantes Resolvidos com <strong>Lógica Proposicional</strong> e Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Solucao-Exercicios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Solução dos Exercícios</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#formas-normais-básicas" id="toc-formas-normais-básicas" class="nav-link active" data-scroll-target="#formas-normais-básicas"><span class="header-section-number">7.1</span> Formas Normais Básicas</a>
  <ul class="collapse">
  <li><a href="#forma-normal-negativa" id="toc-forma-normal-negativa" class="nav-link" data-scroll-target="#forma-normal-negativa"><span class="header-section-number">7.1.1</span> Forma Normal Negativa</a></li>
  <li><a href="#forma-normal-disjuntiva" id="toc-forma-normal-disjuntiva" class="nav-link" data-scroll-target="#forma-normal-disjuntiva"><span class="header-section-number">7.1.2</span> Forma Normal Disjuntiva</a></li>
  <li><a href="#forma-normal-conjuntiva" id="toc-forma-normal-conjuntiva" class="nav-link" data-scroll-target="#forma-normal-conjuntiva"><span class="header-section-number">7.1.3</span> Forma Normal Conjuntiva</a></li>
  <li><a href="#usando-a-tabela-verdade-para-gerar-formas-normais" id="toc-usando-a-tabela-verdade-para-gerar-formas-normais" class="nav-link" data-scroll-target="#usando-a-tabela-verdade-para-gerar-formas-normais"><span class="header-section-number">7.1.4</span> Usando a Tabela-Verdade para Gerar Formas Normais</a></li>
  </ul></li>
  <li><a href="#formas-normais-avançadas" id="toc-formas-normais-avançadas" class="nav-link" data-scroll-target="#formas-normais-avançadas"><span class="header-section-number">7.2</span> Formas Normais Avançadas</a>
  <ul class="collapse">
  <li><a href="#forma-normal-prenex" id="toc-forma-normal-prenex" class="nav-link" data-scroll-target="#forma-normal-prenex"><span class="header-section-number">7.2.1</span> Forma Normal Prenex</a></li>
  <li><a href="#skolemização" id="toc-skolemização" class="nav-link" data-scroll-target="#skolemização"><span class="header-section-number">7.2.2</span> Skolemização</a></li>
  </ul></li>
  <li><a href="#sec-predicativa-conexao-prolog" id="toc-sec-predicativa-conexao-prolog" class="nav-link" data-scroll-target="#sec-predicativa-conexao-prolog"><span class="header-section-number">7.3</span> Exercícios de Conexão com Prolog</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/05-formas-normais-e-skolemizacao.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-formas-normais" class="quarto-section-identifier"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\05-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>Neste porto da nossa jornada a aventureira leitora verá que as formas normais são como as diferentes rotas de navegação padronizadas que organizam o tráfego marítimo em um porto movimentado. Assim como um capitão de porto pode reorganizar águas caóticas em canais bem definidos com rotas padronizadas, as formas normais reorganizam fórmulas lógicas complexas em estruturas elegantes e uniformes.</p>
<p>A criativa leitora pode se imaginar tentando navegar em águas desconhecidas sem cartas náuticas, onde as correntes se cruzam caoticamente, sem padrão ou lógica. Seria como tentar compreender uma fórmula lógica sem forma normal, possível, mas desnecessariamente árduo. As formas normais fornecem um mapa claro e consistente para navegar pelas complexidades da lógica, permitindo que a leitora veja o panorama completo de maneira organizada.</p>
<p>Consideremos, por exemplo, a tarefa de comparar duas proposições para determinar se são equivalentes. Sem uma forma padronizada de representar proposições, essa tarefa pode se tornar complexa e demorada. No entanto, ao utilizar as formas normais, cada proposição é expressa de uma forma padrão, tornando a comparação direta e simples. Além disso, as formas normais também desempenham um papel importante na simplificação de proposições. Ao expressar uma proposição em sua forma normal, é mais fácil identificar oportunidades de simplificação, removendo redundâncias ou simplificando a estrutura lógica. As formas normais não são apenas uma ferramenta para lidar com a complexidade da <strong>Lógica Proposicional</strong>, mas também uma metodologia que facilita a compreensão e manipulação de proposições lógicas.</p>
<section id="formas-normais-básicas" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="formas-normais-básicas"><span class="header-section-number">7.1</span> Formas Normais Básicas</h2>
<p>Existem várias formas normais na <strong>Lógica Proposicional</strong>, cada uma com suas próprias regras e aplicações. A seguir, a esforçada leitora encontrará uma descrição resumida das formas normais, destacando algumas das principais:</p>
<ol type="1">
<li><p><strong>Forma Normal Negativa</strong>: Uma proposição está na Forma Normal Negativa se as operações de negação <span class="math inline">\(\neg\)</span> aparecerem apenas imediatamente antes das variáveis. Isso é conseguido aplicando as leis de De Morgan e eliminando as duplas negações.</p>
<p><span class="math display">\[\neg (A \wedge B) \equiv (\neg A \vee \neg B)\]</span></p></li>
<li><p><strong>Forma Normal Conjuntiva</strong>: uma proposição está na Forma Normal Conjuntiva se for uma conjunção, operação <strong>E</strong>, <span class="math inline">\(\wedge\)</span>, de uma ou mais cláusulas, nas quais, cada cláusula é uma disjunção, operação <strong>OU</strong>, <span class="math inline">\(\vee\)</span>, de literais. Em outras palavras, é uma série de cláusulas conectadas por <strong>Es</strong>, nas quais, cada cláusula é composta de variáveis conectadas por <strong>OUs</strong>. <strong>Uma forma normal conjuntiva é uma conjunção de disjunções</strong>.</p>
<p><span class="math display">\[(A \vee B) \wedge (C \vee D) \wedge (B \vee D) \wedge (A \vee C)\]</span></p></li>
<li><p><strong>Forma Normal Disjuntiva</strong>: uma proposição está na Forma Normal Disjuntiva se for uma disjunção de uma ou mais cláusulas, na qual cada cláusula é uma conjunção de literais. Ou seja, é uma série de cláusulas conectadas por <strong>OUs</strong>, nas quais cada cláusula é composta de variáveis conectadas por <strong>Es</strong>, conjunções. <strong>A forma normal disjuntiva é uma disjunção de conjunções</strong>.</p>
<p><span class="math display">\[(A \wedge B) \vee (C \wedge D) \vee (A \wedge C) \vee (B \wedge D)\]</span></p></li>
<li><p><strong>Forma Normal Prenex</strong>: uma proposição está na Forma Normal Prenex se todos os quantificadores, para a <strong>Lógica de Primeira Ordem</strong>, estiverem à esquerda, precedendo uma matriz quantificadora livre. Esta forma é útil na <strong>Lógica de Primeira Ordem</strong> e na teoria da prova.</p>
<p><span class="math display">\[\forall x \exists y \forall z (P(x,y) \wedge \neg Q(z))\]</span></p></li>
<li><p><strong>Forma Normal Skolem</strong>: na <strong>Lógica de Primeira Ordem</strong>, uma fórmula está na Forma Normal de Skolem se estiver na Forma Normal Prenex e se todos os quantificadores existenciais forem eliminados. Isto é realizado através de um processo conhecido como Skolemização. Por exemplo, dada a fórmula:</p></li>
</ol>
<p><span class="math display">\[\forall x \exists y (P(x,y))\]</span></p>
<p>Sua forma após a Skolemização, que preserva a satisfatibilidade, será:</p>
<p><span class="math display">\[\forall x (P(x, \mathbf{\mathbf{f}}(x)))\]</span></p>
<p>Nosso objetivo, neste livro, é rever a matemática que suporta a Programação Lógica, entre as principais formas normais, para este objetivo, precisamos destacar duas formas:</p>
<ol type="a">
<li><p><strong>Forma Normal Conjuntiva</strong>: a Forma Normal Conjuntiva é importante na Programação Lógica porque muitos sistemas de inferência, como a resolução, funcionam em fórmulas que estão na Forma Normal Conjuntiva. Além disso, os programas em Prolog, a linguagem de Programação Lógica que escolhemos, são formados por Cláusulas de Horn, que são um tipo específico de cláusula na Forma Normal Conjuntiva, cláusulas que possuem, no máximo, um literal positivo.</p></li>
<li><p><strong>Forma Normal de Skolem</strong>: a Forma Normal de Skolem é útil na Programação Lógica porque a Skolemização, o processo de remover quantificadores existenciais transformando-os em funções de quantificadores universais, permite uma forma mais eficiente de representação e processamento de fórmulas lógicas. Essa forma normal é frequentemente usada em <strong>Lógica de Primeira Ordem</strong> e teoria da prova, ambas fundamentais para a Programação Lógica.</p></li>
</ol>
<p>Para entender como conseguimos resolver problemas complexos de lógica, teremos que explorar essas formas normais em detalhes. Começando com a mais simples de todas, a Forma Normal Negativa.</p>
<section id="forma-normal-negativa" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="forma-normal-negativa"><span class="header-section-number">7.1.1</span> Forma Normal Negativa</h3>
<p>A Forma Normal Negativa é como um capitão experiente que ajusta as velas de seu navio. Assim como o capitão remove o excesso de pano e reorganiza as velas para que cada uma capture o vento diretamente, a Forma Normal Negativa move cada negação para o mais próximo possível de seu alvo, os átomos da fórmula.”</p>
<p>É como o processo de desenrolar as linhas de pesca emaranhadas: pegamos cada fio de negação e o seguimos até sua extremidade natural, eliminando as voltas e os nós desnecessários que encontramos no caminho.</p>
<p>Uma fórmula está na Forma Normal Negativa se:</p>
<ol type="a">
<li><p>todos os operadores de negação <span class="math inline">\(\neg\)</span> são aplicados diretamente aos átomos, variáveis ou constantes.</p></li>
<li><p>usaremos apenas a negação <span class="math inline">\(\neg\)</span>, a conjunção <span class="math inline">\(\wedge\)</span>, e a disjunção <span class="math inline">\(\vee\)</span>.</p></li>
</ol>
<p>Converter uma fórmula para a Forma Normal Negativa envolve os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar os Bicondicionais</strong>: substitua todas as ocorrências de <span class="math inline">\(A\leftrightarrow B\)</span> Por <span class="math inline">\(A\rightarrow B \wedge B\rightarrow A\)</span>.</p></li>
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \vee B\)</span>.</p></li>
<li><p><strong>Aplicar as Leis de De Morgan</strong>: Use as leis de De Morgan para mover as negações para dentro, aplicando:</p>
<ul>
<li><span class="math inline">\(\neg (A \wedge  B) \equiv \neg A \vee \neg B\)</span>;</li>
<li><span class="math inline">\(\neg (A \vee B) \equiv \neg A \wedge  \neg B\)</span>.</li>
</ul></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Substitua qualquer dupla negação <span class="math inline">\(\neg \neg A\)</span> Por <span class="math inline">\(A\)</span>.</p></li>
</ol>
<section id="exemplo-1" class="level4" data-number="7.1.1.1">
<h4 data-number="7.1.1.1" class="anchored" data-anchor-id="exemplo-1"><span class="header-section-number">7.1.1.1</span> Exemplo 1</h4>
<p>Converta a fórmula <span class="math inline">\(\neg (A \wedge  (B \rightarrow C))\)</span> Para Forma Normal Negativa</p>
<p>Para converter a fórmula, seguimos o processo passo a passo para mover as negações para o interior da expressão até que elas se apliquem apenas aos átomos.</p>
<ol type="1">
<li><p><strong>Eliminar Implicações</strong>: Primeiro, substituímos a implicação <span class="math inline">\(B \rightarrow C\)</span> por sua equivalência <span class="math inline">\(\neg B \vee C\)</span>.</p>
<p><span class="math display">\[\neg (A \wedge  (\neg B \vee C))\]</span></p></li>
<li><p><strong>Aplicar Lei de De Morgan (na Conjunção)</strong>: Em seguida, aplicamos a lei de De Morgan <span class="math inline">\(\neg(P \wedge  Q) \equiv \neg P \vee \neg Q\)</span> na conjunção principal.</p>
<p><span class="math display">\[\neg A \vee \neg(\neg B \vee C)\]</span></p></li>
<li><p><strong>Aplicar Lei de De Morgan (na Disjunção)</strong>: Agora, aplicamos a lei de De Morgan <span class="math inline">\(\neg(P \vee Q) \equiv \neg P \wedge  \neg Q\)</span> na parte direita da expressão.</p>
<p><span class="math display">\[\neg A \vee (\neg\neg B \wedge  \neg C)\]</span></p></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Finalmente, removemos a dupla negação <span class="math inline">\(\neg\neg B\)</span>, que é equivalente a <span class="math inline">\(B\)</span>.</p>
<p><span class="math display">\[\neg A \vee (B \wedge  \neg C)\]</span></p>
<p>A fórmula resultante está na Forma Normal Negativa, pois os operadores de negação (<span class="math inline">\(\neg\)</span>) aplicam-se diretamente aos átomos <span class="math inline">\(A\)</span> e <span class="math inline">\(C\)</span>.</p></li>
</ol>
</section>
<section id="exemplo-2" class="level4" data-number="7.1.1.2">
<h4 data-number="7.1.1.2" class="anchored" data-anchor-id="exemplo-2"><span class="header-section-number">7.1.1.2</span> Exemplo 2</h4>
<p>Converta a fórmula <span class="math inline">\((A \rightarrow B) \wedge  \neg (C \vee D)\)</span> Para Forma Normal Negativa</p>
<p>Neste exemplo, ambos os lados da conjunção principal (<span class="math inline">\(\wedge\)</span>) são tratados para se adequarem à Forma Normal Negativa.</p>
<ol type="1">
<li><p><strong>Eliminar Implicações</strong>: O primeiro passo é converter a implicação <span class="math inline">\(A \rightarrow B\)</span> em sua equivalência, <span class="math inline">\(\neg A \vee B\)</span>. A segunda parte da fórmula não possui implicações.</p>
<p><span class="math display">\[(\neg A \vee B) \wedge  \neg (C \vee D)\]</span></p></li>
<li><p><strong>Aplicar Lei de De Morgan</strong>: A seguir, aplicamos a lei de De Morgan na expressão <span class="math inline">\(\neg (C \vee D)\)</span> para mover a negação para o interior dos parênteses.</p>
<p><span class="math display">\[(\neg A \vee B) \wedge (\neg C \wedge \neg D)\]</span></p></li>
</ol>
<p>A fórmula final já se encontra na Forma Normal Negativa , pois todos os operadores de negação estão aplicados diretamente aos átomos (<span class="math inline">\(A\)</span>, <span class="math inline">\(C\)</span> e <span class="math inline">\(D\)</span>). Não há duplas negações que precisem ser eliminadas neste caso.</p>
</section>
</section>
<section id="forma-normal-disjuntiva" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="forma-normal-disjuntiva"><span class="header-section-number">7.1.2</span> Forma Normal Disjuntiva</h3>
<p>A Forma Normal Disjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma disjunção de conjunções. Trata-se de uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico.</p>
<p>Uma fórmula está na Forma Normal Disjuntiva se puder ser escrita como:</p>
<p><span class="math display">\[(C_1 \wedge  C_2 \wedge  \ldots) \vee (D_1 \wedge  D_2 \wedge  \ldots) \vee\]</span></p>
<p>Na qual, cada <span class="math inline">\(C_i\)</span> e <span class="math inline">\(D_i\)</span> é um literal. Ou seja, é uma variável ou sua negação. Com um pouco mais de formalidade matemática podemos afirmar que uma <strong>Fórmula Bem Formada</strong> está na Forma Normal Disjuntiva quando está na forma:</p>
<p><span class="math display">\[\bigvee_{i=1}^{m} \left( \bigwedge_{j=1}^{n} L_{ij} \right)\]</span></p>
<p>Converter uma fórmula para Forma Normal Disjuntiva é como identificar todas as combinações de ventos e correntes que levam o navio ao porto desejado. A fórmula original é a rota complexa, a disjunção de todas as opções de rotas. Cada termo da Forma Normal Disjuntiva final é como um cenário único e completo, uma conjunção de condições marítimas, que, por si só, garante que o navio chegue ao destino.</p>
<p>Para esta conversão, a intrépida leitora deve seguir os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar os Bicondicionais</strong>: substitua todas as ocorrências de <span class="math inline">\(A\leftrightarrow B\)</span> Por <span class="math inline">\(A\rightarrow B \wedge B\rightarrow A\)</span>.</p></li>
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \vee B\)</span>.</p></li>
<li><p><strong>Aplicar as Leis de De Morgan</strong>: use as leis de De Morgan para mover as negações para dentro, aplicando:</p>
<ul>
<li><span class="math inline">\(\neg (A \wedge  B) \equiv \neg A \vee \neg B\)</span></li>
<li><span class="math inline">\(\neg (A \vee B) \equiv \neg A \wedge  \neg B\)</span></li>
</ul></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Substitua qualquer dupla negação <span class="math inline">\(\neg \neg A\)</span> Por <span class="math inline">\(A\)</span>.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong>: Use a lei distributiva para expandir a fórmula, transformando-a em uma disjunção de conjunções.</p></li>
</ol>
<section id="exemplo-1-1" class="level4" data-number="7.1.2.1">
<h4 data-number="7.1.2.1" class="anchored" data-anchor-id="exemplo-1-1"><span class="header-section-number">7.1.2.1</span> Exemplo 1</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[
(A \rightarrow B) \wedge  (C \vee \neg (D \wedge  E))
\]</span></p>
<p>O objetivo é convertê-la para uma disjunção de conjunções.</p>
<ol type="1">
<li><p><strong>Converter para a Forma Normal Negativa </strong></p>
<p>Primeiro, realizamos os passos iniciais para eliminar implicações e mover as negações para o interior da fórmula, o que nos dará uma forma intermediária.</p>
<ul>
<li><p>Eliminar Implicações (<span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>):</p>
<p><span class="math display">\[(\neg A \vee B) \wedge  (C \vee \neg (D \wedge  E))\]</span></p></li>
<li><p>Aplicar a Lei de De Morgan (<span class="math inline">\(\neg (D \wedge  E) \equiv \neg D \vee \neg E\)</span>):</p>
<p><span class="math display">\[(\neg A \vee B) \wedge  (C \vee \neg D \vee \neg E)\]</span></p></li>
</ul>
<p>Neste ponto, a fórmula encontra-se na <strong>Forma Normal Conjuntiva </strong>. O passo seguinte é aplicar a distributividade para alcançar a Forma Normal Disjuntiva.</p></li>
<li><p><strong>Aplicar a Lei Distributiva (Parte 1)</strong></p>
<p>Usamos a lei distributiva <span class="math inline">\(P \wedge  (Q \vee R) \equiv (P \wedge  Q) \vee (P \wedge  R)\)</span>. Vamos tratar o termo <span class="math inline">\((\neg A \vee B)\)</span> como uma única unidade, <span class="math inline">\(X\)</span>, e distribuí-lo sobre <span class="math inline">\((C \vee \neg D \vee \neg E)\)</span>.</p>
<p><span class="math display">\[
\underbrace{(\neg A \vee B)}_{X} \wedge  (C \vee \neg D \vee \neg E) \equiv (X \wedge  C) \vee (X \wedge  \neg D) \vee (X \wedge  \neg E)
\]</span></p>
<p>Substituindo <span class="math inline">\(X\)</span> de volta, obtemos:</p>
<p><span class="math display">\[
((\neg A \vee B) \wedge  C) \vee ((\neg A \vee B) \wedge  \neg D) \vee ((\neg A \vee B) \wedge  \neg E)
\]</span></p></li>
<li><p><strong>Aplicar a Lei Distributiva (Parte 2)</strong></p>
<p>Agora, aplicamos a lei distributiva <span class="math inline">\((P \vee Q) \wedge  R \equiv (P \wedge  R) \vee (Q \wedge  R)\)</span> em cada uma das três cláusulas da expressão acima.</p>
<ul>
<li>Primeiro termo: <span class="math inline">\((\neg A \wedge  C) \vee (B \wedge  C)\)</span>;</li>
<li>Segundo termo: <span class="math inline">\((\neg A \wedge  \neg D) \vee (B \wedge  \neg D)\)</span>;</li>
<li>Terceiro termo: <span class="math inline">\((\neg A \wedge  \neg E) \vee (B \wedge  \neg E)\)</span>.</li>
</ul></li>
<li><p><strong>Forma Normal Disjuntiva Final</strong></p>
<p>Unindo todos os termos expandidos com o operador <span class="math inline">\(\vee\)</span>, chegamos à Forma Normal Disjuntiva final.</p>
<p><span class="math display">\[
(\neg A \wedge  C) \vee (B \wedge  C) \vee (\neg A \wedge  \neg D) \vee (B \wedge  \neg D) \vee (\neg A \wedge  \neg E) \vee (B \wedge  \neg E)
\]</span></p>
<p>A expressão agora é uma disjunção de múltiplas conjunções, que é a definição da Forma Normal Disjuntiva.</p></li>
</ol>
</section>
<section id="exemplo-2-1" class="level4" data-number="7.1.2.2">
<h4 data-number="7.1.2.2" class="anchored" data-anchor-id="exemplo-2-1"><span class="header-section-number">7.1.2.2</span> Exemplo 2</h4>
<p>Considere:</p>
<p><span class="math display">\[(\neg A \wedge  (B \rightarrow C)) \vee (D \wedge  \neg (E \rightarrow F))\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações</p>
<p><span class="math display">\[(\neg A \wedge  (\neg B \vee C)) \vee (D \wedge  \neg (\neg E \vee F)) \equiv (\neg A \wedge  (\neg B \vee C)) \vee (D \wedge  (E \wedge  \neg F))\]</span></p></li>
<li><p>Distribuir a Disjunção</p>
<p><span class="math display">\[(\neg A \wedge  \neg B \vee \neg A \wedge  C) \vee (D \wedge  E \wedge  \neg F)\]</span></p></li>
<li><p>Distribuir a Disjunção Novamente</p>
<p><span class="math display">\[\neg A \wedge  \neg B \vee \neg A \wedge  C \vee D \wedge  E \wedge  \neg F\]</span></p></li>
</ol>
</section>
<section id="exemplo-3" class="level4" data-number="7.1.2.3">
<h4 data-number="7.1.2.3" class="anchored" data-anchor-id="exemplo-3"><span class="header-section-number">7.1.2.3</span> Exemplo 3</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(P \rightarrow Q) \rightarrow (R \vee S)\]</span></p>
<ol type="1">
<li><p>Remover as implicações (<span class="math inline">\(\rightarrow\)</span>):</p>
<p><span class="math display">\[P \rightarrow Q \equiv \neg P \vee Q\]</span></p></li>
<li><p>Substituir a expressão original com a equivalência encontrada no passo 1:</p>
<p><span class="math display">\[(\neg P \vee Q) \rightarrow (R \vee S)\]</span></p></li>
<li><p>Aplicar novamente a equivalência para remover a implicação:</p>
<p><span class="math display">\[\neg (\neg P \vee Q) \vee (R \vee S)\]</span></p></li>
<li><p>Aplicar a lei de De Morgan para expandir a negação:</p>
<p><span class="math display">\[(P \wedge \neg Q) \vee (R \vee S)\]</span></p></li>
</ol>
</section>
<section id="exemplo-4" class="level4" data-number="7.1.2.4">
<h4 data-number="7.1.2.4" class="anchored" data-anchor-id="exemplo-4"><span class="header-section-number">7.1.2.4</span> Exemplo 4</h4>
<p>Considere a fórmula que representa a negação de uma bicondicional, que é logicamente equivalente a uma operação de “ou exclusivo” (XOR):</p>
<p><span class="math display">\[
\neg(P \leftrightarrow Q)
\]</span></p>
<p>Vamos convertê-la para a Forma Normal Disjuntiva.</p>
<ol type="1">
<li><p><strong>Eliminar a Bicondicional</strong></p>
<p>O primeiro passo é substituir o operador de bicondicional (<span class="math inline">\(A \leftrightarrow B\)</span>) por sua definição equivalente: <span class="math inline">\((A \rightarrow B) \wedge  (B \rightarrow A)\)</span>.</p>
<p><span class="math display">\[
\neg((P \rightarrow Q) \wedge  (Q \rightarrow P))
\]</span></p></li>
<li><p><strong>Eliminar as Implicações</strong></p>
<p>Agora, convertemos as duas implicações internas em suas formas disjuntivas, usando a regra <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>.</p>
<p><span class="math display">\[
\neg((\neg P \vee Q) \wedge  (\neg Q \vee P))
\]</span></p></li>
<li><p><strong>Aplicar a Lei de De Morgan</strong></p>
<p>Aplicamos a lei de De Morgan na negação que cobre toda a expressão, transformando a conjunção (<span class="math inline">\(\wedge\)</span>) em disjunção (<span class="math inline">\(\vee\)</span>) e movendo a negação para os termos internos.</p>
<p><span class="math display">\[
\neg(\neg P \vee Q) \vee \neg(\neg Q \vee P)
\]</span></p></li>
<li><p><strong>Aplicar a Lei de De Morgan Novamente e Simplificar</strong></p>
<p>Para finalizar, aplicamos a lei de De Morgan em cada um dos termos e removemos as duplas negações (<span class="math inline">\(\neg\neg A \equiv A\)</span>) que surgem no processo.</p>
<p><span class="math display">\[
(\neg\neg P \wedge  \neg Q) \vee (\neg\neg Q \wedge  \neg P)
\]</span></p>
<p>Simplificando, obtemos a Forma Normal Disjuntiva final:</p>
<p><span class="math display">\[
(P \wedge  \neg Q) \vee (\neg P \wedge  Q)
\]</span></p>
<p>A expressão resultante é uma disjunção de duas conjunções, o que corresponde perfeitamente à definição da Forma Normal Disjuntiva.</p></li>
</ol>
</section>
<section id="exemplo-5" class="level4" data-number="7.1.2.5">
<h4 data-number="7.1.2.5" class="anchored" data-anchor-id="exemplo-5"><span class="header-section-number">7.1.2.5</span> Exemplo 5</h4>
<p>Considere a seguinte fórmula com uma implicação principal e uma bicondicional aninhada: <span class="math display">\[
\neg(P \wedge  Q) \rightarrow (R \leftrightarrow S)
\]</span> Nosso objetivo é convertê-la para a Forma Normal Disjuntiva.</p>
<ol type="1">
<li><p><strong>Eliminar a Implicação Principal</strong></p>
<p>Utilizando a equivalência <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span>, removemos o operador de implicação principal da fórmula.</p>
<p><span class="math display">\[
\neg(\neg(P \wedge  Q)) \vee (R \leftrightarrow S)
\]</span></p></li>
<li><p><strong>Eliminar a Dupla Negação</strong></p>
<p>A expressão <span class="math inline">\(\neg(\neg(P \wedge  Q))\)</span> simplifica-se diretamente para <span class="math inline">\((P \wedge  Q)\)</span>, resultando em:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee (R \leftrightarrow S)
\]</span></p></li>
<li><p><strong>Eliminar a Bicondicional</strong></p>
<p>Substituímos a bicondicional <span class="math inline">\(R \leftrightarrow S\)</span> por sua definição equivalente: <span class="math inline">\((R \rightarrow S) \wedge  (S \rightarrow R)\)</span>.</p>
<p><span class="math display">\[
(P \wedge  Q) \vee ((R \rightarrow S) \wedge  (S \rightarrow R))
\]</span></p>
<p>Em seguida, eliminamos as implicações restantes:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee ((\neg R \vee S) \wedge  (\neg S \vee R))
\]</span></p>
<p>Note que a expressão ainda não está em Forma Normal Disjuntiva, pois a parte direita é uma conjunção.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong></p>
<p>Para que toda a expressão se torne uma disjunção de conjunções, precisamos converter a parte <span class="math inline">\((\neg R \vee S) \wedge  (\neg S \vee R)\)</span> para Forma Normal Disjuntiva. Fazemos isso aplicando a distributividade:</p>
<p><span class="math display">\[
(\neg R \vee S) \wedge  (\neg S \vee R) \equiv (\neg R \wedge  \neg S) \vee (\neg R \wedge  R) \vee (S \wedge  \neg S) \vee (S \wedge  R)
\]</span></p>
<p>As cláusulas <span class="math inline">\((\neg R \wedge  R)\)</span> e <span class="math inline">\((S \wedge  \neg S)\)</span> são contradições (sempre falsas), então podem ser removidas, simplificando a expressão para:</p>
<p><span class="math display">\[
(\neg R \wedge  \neg S) \vee (S \wedge  R)
\]</span></p></li>
<li><p><strong>Forma Normal Disjuntiva Final</strong></p>
<p>Agora, substituímos a Forma Normal Disjuntiva que acabamos de derivar de volta na fórmula principal:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee ((\neg R \wedge  \neg S) \vee (S \wedge  R))
\]</span></p>
<p>Como o operador <span class="math inline">\(\vee\)</span> é associativo, podemos remover os parênteses extras, chegando à Forma Normal Disjuntiva final:</p>
<p><span class="math display">\[
(P \wedge  Q) \vee (\neg R \wedge  \neg S) \vee (S \wedge  R)
\]</span></p>
<p>A fórmula final está corretamente expressa como uma disjunção de três conjunções de literais.</p></li>
</ol>
<p>A Forma Normal Disjuntiva é útil porque qualquer fórmula lógica pode ser representada desta forma. Além disso, essa representação é única, com exceção da ordem dos literais e das cláusulas.</p>
</section>
<section id="sec-exercicios-conversao-fnd" class="level4" data-number="7.1.2.6">
<h4 data-number="7.1.2.6" class="anchored" data-anchor-id="sec-exercicios-conversao-fnd"><span class="header-section-number">7.1.2.6</span> Exercícios de Conversão para Forma Normal Disjuntiva</h4>
<p><strong>1.</strong> Converta a seguinte fórmula para Forma Normal Disjuntiva:</p>
<p><span class="math display">\[
((P \leftrightarrow Q) \rightarrow R) \wedge \neg(R \rightarrow (P \vee Q))
\]</span></p>
<p><strong>2.</strong> Converta para Forma Normal Disjuntiva a fórmula que representa a negação de uma tautologia clássica:</p>
<p><span class="math display">\[
\neg((P \rightarrow (Q \rightarrow R)) \rightarrow ((P \rightarrow Q) \rightarrow (P \rightarrow R)))
\]</span></p>
<p><strong>3.</strong> Dada a fórmula com múltiplas bicondicionais aninhadas, obtenha sua Forma Normal Disjuntiva:</p>
<p><span class="math display">\[
(P \leftrightarrow (Q \leftrightarrow R)) \vee \neg(P \wedge Q \wedge R)
\]</span></p>
<p><strong>4.</strong> Converta a seguinte fórmula complexa para Forma Normal Disjuntiva:</p>
<p><span class="math display">\[
\neg((P \vee Q) \rightarrow (R \wedge S)) \leftrightarrow (P \rightarrow \neg Q)
\]</span></p>
<p><strong>5.</strong> Transforme em Forma Normal Disjuntiva a fórmula:</p>
<p><span class="math display">\[
((P \wedge Q) \rightarrow (R \vee S)) \wedge ((R \rightarrow P) \vee (S \rightarrow Q))
\]</span></p>
<p><strong>6.</strong> Obtenha a Forma Normal Disjuntiva para:</p>
<p><span class="math display">\[
\neg(P \leftrightarrow \neg Q) \rightarrow ((P \wedge R) \vee (Q \wedge \neg R))
\]</span></p>
<p><strong>7.</strong> Converta para Forma Normal Disjuntiva a fórmula que combina negação de implicação com bicondicional:</p>
<p><span class="math display">\[
\neg((P \rightarrow Q) \wedge (Q \rightarrow R)) \leftrightarrow (P \wedge \neg R)
\]</span></p>
</section>
</section>
<section id="forma-normal-conjuntiva" class="level3" data-number="7.1.3">
<h3 data-number="7.1.3" class="anchored" data-anchor-id="forma-normal-conjuntiva"><span class="header-section-number">7.1.3</span> Forma Normal Conjuntiva</h3>
<p>A Forma Normal Conjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma conjunção de disjunções. Em outras palavras, é uma expressão lógica na forma de uma <em>conjunção de disjunções</em>. É uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico e simplificação de fórmulas.</p>
<p>A diferença entre Forma Normal Conjuntiva e Forma Normal Disjuntiva é como a diferença entre dois estilos de organização de uma biblioteca:</p>
<p>A Forma Normal Conjuntiva é como uma esquadra naval na qual cada embarcação, conjunção, deve ter pelo menos um tripulante qualificado, disjunção. Você só fica satisfeito se TODAS as embarcações tiverem alguém capacitado a bordo.</p>
<p>Dizemos que uma fórmula está na Forma Normal Conjuntiva se puder ser expressa na forma:</p>
<p><span class="math display">\[(D_1 \vee D_2 \vee \ldots \vee D_n) \wedge  (E_1 \vee E_2 \vee \ldots \vee E_m) \wedge  \ldots\]</span></p>
<p>Na qual, <span class="math inline">\(D_1, \ldots , D_n\)</span> e $ E_1, ,E_m $ representam literais. Podemos dizer que a Forma Normal Conjuntiva acontece quando a <strong>Fórmula Bem Formada</strong> está na forma:</p>
<p><span class="math display">\[\bigwedge_{i=1}^{m} \left( \bigvee_{j=1}^{n} L_{ij} \right)\]</span></p>
<p>Converter uma fórmula <strong>proposicional</strong> para a Forma Normal Conjuntiva é um processo algorítmico que garante que a expressão final seja uma conjunção de disjunções. Os passos são os seguintes:</p>
<ol type="1">
<li><p><strong>Eliminar Bicondicionais</strong>: Substitua todas as ocorrências da bicondicional pela sua definição baseada em implicações.</p>
<p><span class="math display">\[
A \leftrightarrow B \equiv (A \rightarrow B) \wedge  (B \rightarrow A)
\]</span></p></li>
<li><p><strong>Eliminar Implicações</strong>: Em seguida, remova todas as implicações, trocando-as por sua equivalência com o uso de disjunção e negação.</p>
<p><span class="math display">\[
A \rightarrow B \equiv \neg A \vee B
\]</span></p></li>
<li><p><strong>Mover Negações para o Interior (Converter para Forma Normal Negativa)</strong>: Use as Leis de De Morgan e a Lei da Dupla Negação para mover todos os operadores de negação (<span class="math inline">\(\neg\)</span>) para dentro da expressão, até que eles se apliquem apenas diretamente às variáveis atômicas. As regras principais são:</p>
<ul>
<li><span class="math inline">\(\neg(A \wedge  B) \equiv \neg A \vee \neg B\)</span></li>
<li><span class="math inline">\(\neg(A \vee B) \equiv \neg A \wedge  \neg B\)</span></li>
<li><span class="math inline">\(\neg\neg A \equiv A\)</span></li>
</ul>
<p>Ao final deste passo, a fórmula estará em Forma Normal Negativa .</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong>: Para finalizar, aplique a lei distributiva para garantir que nenhuma conjunção (<span class="math inline">\(\wedge\)</span>) esteja aninhada dentro de uma disjunção (<span class="math inline">\(\vee\)</span>). A regra chave é distribuir o <span class="math inline">\(\vee\)</span> sobre o <span class="math inline">\(\wedge\)</span>.</p>
<p><span class="math display">\[
A \vee (B \wedge  C) \equiv (A \vee B) \wedge  (A \vee C)
\]</span></p>
<p>Este passo deve ser repetido até que a fórmula inteira seja uma conjunção de cláusulas, nas quais cada cláusula é uma disjunção de literais, satisfazendo a definição da Forma Normal Conjuntiva.</p></li>
</ol>
<section id="exemplo-1-2" class="level4" data-number="7.1.3.1">
<h4 data-number="7.1.3.1" class="anchored" data-anchor-id="exemplo-1-2"><span class="header-section-number">7.1.3.1</span> Exemplo 1</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(A \wedge  B) \rightarrow (C \vee D)\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações:</p>
<p><span class="math display">\[\neg (A \wedge  B) \vee (C \vee D) \equiv (\neg A \vee \neg B) \vee (C \vee D)\]</span></p></li>
</ol>
<p>Neste ponto temos <span class="math inline">\((\neg A \vee \neg B) \vee (C \vee D)\)</span> e podemos remover os parênteses obtendo:</p>
<p><span class="math display">\[\neg A \vee \neg B \vee C \vee D\]</span></p>
<p>Aqui a atenta leitora deve observar que temos uma única cláusula, ou seja, uma Forma Normal Conjuntiva com apenas uma cláusula. Nenhuma outra simplificação é necessária.</p>
</section>
<section id="exemplo-2-2" class="level4" data-number="7.1.3.2">
<h4 data-number="7.1.3.2" class="anchored" data-anchor-id="exemplo-2-2"><span class="header-section-number">7.1.3.2</span> Exemplo 2</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(A \wedge  \neg B) \vee (\neg C \wedge  D) \rightarrow (E \vee F)\]</span></p>
<ol type="1">
<li>Eliminar Implicações (usando a equivalência <span class="math inline">\(P \rightarrow Q \equiv \neg P \vee Q\)</span>):</li>
</ol>
<p><span class="math display">\[\neg ((A \wedge  \neg B) \vee (\neg C \wedge  D)) \vee (E \vee F)\]</span></p>
<ol start="2" type="1">
<li>Mover a Negação para Dentro (usando Leis de De Morgan):</li>
</ol>
<p><span class="math display">\[((\neg A \vee B) \wedge (C \vee \neg D)) \vee (E \vee F)\]</span></p>
<ol start="3" type="1">
<li>Distribuir a Disjunção sobre a Conjunção (usando a equivalência <span class="math inline">\((P \wedge Q) \vee R \equiv (P \vee R) \wedge (Q \vee R)\)</span>):</li>
</ol>
<p><span class="math display">\[(\neg A \vee B \vee E \vee F) \wedge (C \vee \neg D \vee E \vee F)\]</span></p>
</section>
<section id="exemplo-3-1" class="level4" data-number="7.1.3.3">
<h4 data-number="7.1.3.3" class="anchored" data-anchor-id="exemplo-3-1"><span class="header-section-number">7.1.3.3</span> Exemplo 3</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[
(P \wedge (Q \vee R)) \vee (\neg P \wedge \neg Q)
\]</span></p>
<p><strong>Conversão para Forma Normal Conjuntiva :</strong></p>
<ol type="1">
<li><p><strong>Aplicar a lei distributiva no primeiro termo</strong>: expandir <span class="math inline">\((P \wedge (Q \vee R))\)</span> usando <span class="math inline">\(A \wedge (B \vee C) \equiv (A \wedge B) \vee (A \wedge C)\)</span></p>
<p><span class="math display">\[
(P \wedge Q) \vee (P \wedge R) \vee (\neg P \wedge \neg Q)
\]</span></p>
<p>Neste ponto, temos uma <strong>Forma Normal Disjuntiva </strong>.</p></li>
<li><p><strong>Construir a tabela-verdade para determinar a Forma Normal Conjuntiva</strong>:</p>
<p><span class="math display">\[
\begin{array}{ccc|c|c|c}
P &amp; Q &amp; R &amp; P \wedge Q &amp; P \wedge R &amp; \neg P \wedge \neg Q &amp; \text{Resultado} \\
\hline
T &amp; T &amp; T &amp; T &amp; T &amp; F &amp; T \\
T &amp; T &amp; F &amp; T &amp; F &amp; F &amp; T \\
T &amp; F &amp; T &amp; F &amp; T &amp; F &amp; T \\
T &amp; F &amp; F &amp; F &amp; F &amp; F &amp; F \\
F &amp; T &amp; T &amp; F &amp; F &amp; F &amp; F \\
F &amp; T &amp; F &amp; F &amp; F &amp; F &amp; F \\
F &amp; F &amp; T &amp; F &amp; F &amp; T &amp; T \\
F &amp; F &amp; F &amp; F &amp; F &amp; T &amp; T \\
\end{array}
\]</span></p></li>
<li><p><strong>Identificar as linhas falsas</strong>: as linhas 4, 5 e 6 têm resultado falso.</p></li>
<li><p><strong>Construir cláusulas excludentes</strong>: para cada linha falsa, criamos uma cláusula que a “proíbe”:</p>
<ul>
<li><strong>Linha 4</strong> (P=T, Q=F, R=F): Para excluir esta combinação, criamos <span class="math inline">\((\neg P \vee Q \vee R)\)</span></li>
<li><strong>Linha 5</strong> (P=F, Q=T, R=T): Para excluir esta combinação, criamos <span class="math inline">\((P \vee \neg Q \vee \neg R)\)</span><br>
</li>
<li><strong>Linha 6</strong> (P=F, Q=T, R=F): Para excluir esta combinação, criamos <span class="math inline">\((P \vee \neg Q \vee R)\)</span></li>
</ul></li>
<li><p><strong>Formar a Forma Normal Conjuntiva</strong>: a conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:</p>
<p><span class="math display">\[
(\neg P \vee Q \vee R) \wedge (P \vee \neg Q \vee \neg R) \wedge (P \vee \neg Q \vee R)
\]</span></p></li>
<li><p><strong>Simplificação</strong>: podemos aplicar a lei da resolução nas duas últimas cláusulas:</p>
<p>De <span class="math inline">\((P \vee \neg Q \vee \neg R) \wedge (P \vee \neg Q \vee R)\)</span>, obtemos <span class="math inline">\((P \vee \neg Q)\)</span> (eliminando <span class="math inline">\(R\)</span> e <span class="math inline">\(\neg R\)</span>).</p>
<p><strong>Forma Normal Conjuntiva final simplificada</strong>:</p>
<p><span class="math display">\[
(\neg P \vee Q \vee R) \wedge (P \vee \neg Q)
\]</span></p></li>
</ol>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Observação importante - Por que a conversão direta não funciona</strong>:</p>
<p>A conversão direta de Forma Normal Disjuntiva para Forma Normal Conjuntiva através de distributividade simples frequentemente resulta em uma explosão exponencial de termos. Vamos ver por que:</p>
<p>Para converter <span class="math inline">\((P \wedge Q) \vee (P \wedge R) \vee (\neg P \wedge \neg Q)\)</span> diretamente para Forma Normal Conjuntiva, precisaríamos aplicar a distributividade do <span class="math inline">\(\wedge\)</span> sobre <span class="math inline">\(\vee\)</span>, usando a regra <span class="math inline">\((A \vee B) \wedge (C \vee D) \equiv (A \wedge C) \vee (A \wedge D) \vee (B \wedge C) \vee (B \wedge D)\)</span>.</p>
<p>Se tentássemos aplicar isso sistematicamente:</p>
<ol type="1">
<li>Primeiro, agruparíamos: <span class="math inline">\(((P \wedge Q) \vee (P \wedge R)) \vee (\neg P \wedge \neg Q)\)</span>;</li>
<li>Cada aplicação de distributividade duplicaria o número de termos;</li>
<li>Com 3 termos conjuntivos originais, cada um com 2 literais, a expansão completa geraria <span class="math inline">\(2^3 = 8\)</span> combinações possíveis;</li>
<li>Muitas dessas combinações seriam tautológicas ou contraditórias, requerendo simplificação adicional.</li>
</ol>
<p><strong>Exemplo da complexidade</strong>: Aplicando distributividade apenas ao primeiro passo:</p>
<ul>
<li><span class="math inline">\((P \wedge Q) \vee (P \wedge R)\)</span> precisa ser convertido para Forma Normal Conjuntiva</li>
<li>Isso exigiria criar “pseudo-literais” para cada conjunção</li>
<li>A expressão resultante seria muito mais complexa que a Forma Normal Conjuntiva obtida pela tabela-verdade</li>
</ul>
<p><strong>Por isso, métodos alternativos são preferíveis</strong>:</p>
<ul>
<li><strong>Tabela-verdade</strong>: Identifica diretamente as condições falsas, gerando a Forma Normal Conjuntiva mínima</li>
<li><strong>Algoritmo de Tseitin</strong>: Introduz variáveis auxiliares para evitar explosão exponencial</li>
<li><strong>Resolução reversa</strong>: Constrói cláusulas incrementalmente</li>
</ul>
<p>A abordagem pela tabela-verdade, embora limitada a fórmulas proposicionais pequenas, é mais sistemática e garante uma Forma Normal Conjuntiva correta sem a complexidade da distributividade direta.</p>
</div>
</div>
</section>
<section id="exemplo-4-1" class="level4" data-number="7.1.3.4">
<h4 data-number="7.1.3.4" class="anchored" data-anchor-id="exemplo-4-1"><span class="header-section-number">7.1.3.4</span> Exemplo 4</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[ \neg ((P \wedge Q) \vee \neg (R \wedge S))\]</span></p>
<ol type="1">
<li><p>Aplicando a Lei de De Morgan na expressão inteira:</p>
<p><span class="math display">\[
\begin{align*}
\neg ((P \wedge Q) \vee \neg (R \wedge S)) &amp;\equiv \neg (P \wedge Q) \wedge (R \wedge S) \quad \text{(Lei de De Morgan)}
\end{align*}
\]</span></p></li>
<li><p>aplicando a Lei de De Morgan nos termos internos:</p>
<p><span class="math display">\[
\begin{align*}
\neg (P \wedge Q) \wedge (R \wedge S) &amp;\equiv (\neg P \vee \neg Q) \wedge (R \wedge S) \quad \text{(Lei de De Morgan)}
\end{align*}
\]</span></p></li>
</ol>
</section>
<section id="exemplo-5-1" class="level4" data-number="7.1.3.5">
<h4 data-number="7.1.3.5" class="anchored" data-anchor-id="exemplo-5-1"><span class="header-section-number">7.1.3.5</span> Exemplo 5</h4>
<p>Considere a seguinte fórmula, que é a negação da Lei de Peirce (uma conhecida tautologia na lógica clássica):</p>
<p><span class="math display">\[
\neg (((P \rightarrow Q) \rightarrow P) \rightarrow P)
\]</span></p>
<p>Nosso objetivo é converter esta fórmula para a Forma Normal Conjuntiva para determinar sua natureza.</p>
<ol type="1">
<li><p><strong>Eliminar a Implicação Mais Externa</strong></p>
<p>Aplicamos a regra <span class="math inline">\(A \rightarrow B \equiv \neg A \vee B\)</span> na implicação principal.</p>
<p><span class="math display">\[
\neg (\neg((P \rightarrow Q) \rightarrow P) \vee P)
\]</span></p></li>
<li><p><strong>Aplicar a Lei de De Morgan</strong></p>
<p>Agora, aplicamos a lei <span class="math inline">\(\neg(A \vee B) \equiv \neg A \wedge  \neg B\)</span> na fórmula.</p>
<p><span class="math display">\[
\neg\neg((P \rightarrow Q) \rightarrow P) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Eliminar a Dupla Negação</strong></p>
<p>A dupla negação é removida, simplificando a expressão.</p>
<p><span class="math display">\[
((P \rightarrow Q) \rightarrow P) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Eliminar as Implicações Restantes</strong></p>
<p>Continuamos eliminando as implicações de dentro para fora.</p>
<p><span class="math display">\[
(\neg(P \rightarrow Q) \vee P) \wedge  \neg P
\]</span></p>
<p><span class="math display">\[
(\neg(\neg P \vee Q) \vee P) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Mover a Negação para o Interior</strong></p>
<p>Aplicamos a Lei de De Morgan no primeiro termo aninhado.</p>
<p><span class="math display">\[
((P \wedge  \neg Q) \vee P) \wedge  \neg P
\]</span></p>
<p>Neste ponto, a expressão <span class="math inline">\(((P \wedge  \neg Q) \vee P) \wedge  \neg P\)</span> está em Forma Normal Disjuntiva. Para prosseguir com a conversão para Forma Normal Conjuntiva, precisamos aplicar a lei distributiva nela.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong></p>
<p>Distribuímos <span class="math inline">\(\vee P\)</span> sobre <span class="math inline">\((P \wedge  \neg Q)\)</span> usando a regra <span class="math inline">\((A \wedge  B) \vee C \equiv (A \vee C) \wedge  (B \vee C)\)</span>.</p>
<p><span class="math display">\[
((P \vee P) \wedge  (\neg Q \vee P)) \wedge  \neg P
\]</span></p></li>
<li><p><strong>Simplificar e Reassociar</strong></p>
<p>Simplificamos <span class="math inline">\((P \vee P)\)</span> para <span class="math inline">\(P\)</span> (Idempotência) e reassociamos os termos para agrupar <span class="math inline">\(P\)</span> e <span class="math inline">\(\neg P\)</span>.</p>
<p><span class="math display">\[
(P \wedge  (\neg Q \vee P)) \wedge  \neg P
\]</span></p>
<p><span class="math display">\[
(P \wedge  \neg P) \wedge  (\neg Q \vee P)
\]</span></p></li>
<li><p><strong>Resultado Final</strong></p>
<p>A expressão <span class="math inline">\((P \wedge  \neg P)\)</span> é uma contradição, equivalente a <span class="math inline">\(Falso\)</span> (<span class="math inline">\(F\)</span>). Qualquer conjunção com <span class="math inline">\(F\)</span> resulta em <span class="math inline">\(F\)</span>.</p>
<p><span class="math display">\[
F \wedge  (\neg Q \vee P)
\]</span></p>
<p><span class="math display">\[
F
\]</span></p>
<p>A fórmula original é uma contradição. A Forma Normal Conjuntiva de uma contradição pode ser representada simplesmente como <span class="math inline">\(F\)</span>, ou por qualquer conjunção contraditória, como <span class="math inline">\((P \wedge  \neg P)\)</span>.</p>
<div class="{calout-note}">
<p><strong>Negação da Lei de Peirce</strong></p>
<p>A <em>Lei de Peirce</em> é uma tautologia fundamental da lógica clássica, formulada como:</p>
<p><span class="math display">\[((P \rightarrow Q) \rightarrow P) \rightarrow P\]</span></p>
<p>A <em>negação da Lei de Peirce</em> é expressa por:</p>
<p><span class="math display">\[\neg(((P \rightarrow Q) \rightarrow P) \rightarrow P)\]</span></p>
<p>Esta negação representa uma fórmula que é:</p>
<ul>
<li>Sempre falsa na lógica clássica (sendo a negação de uma tautologia);</li>
<li>Satisfazível em alguns sistemas de lógica intuicionista;</li>
<li>Um exemplo importante de fórmula que distingue lógica clássica de lógica intuicionista.</li>
</ul>
<p>Para entender melhor, considere que a a <em>lógica clássica</em> é baseada em princípios fundamentais como:</p>
<ul>
<li><strong>Princípio do Terceiro Excluído</strong>: para qualquer proposição <span class="math inline">\(P\)</span>, ou <span class="math inline">\(P\)</span> é verdadeira ou <span class="math inline">\(\neg P\)</span> é verdadeira: <span class="math inline">\(P \vee \neg P\)</span>;</li>
<li><strong>Princípio da Não-Contradição</strong>: uma proposição não pode ser simultaneamente verdadeira e falsa: <span class="math inline">\(\neg(P \wedge \neg P)\)</span>;</li>
<li><strong>Reductio ad Absurdum</strong>: se assumir <span class="math inline">\(\neg P\)</span> leva a uma contradição, então <span class="math inline">\(P\)</span> deve ser verdadeira.</li>
</ul>
<p>Por outro lado, a <em>lógica intuicionista</em>, desenvolvida por <a href="https://en.wikipedia.org/wiki/L._E._J._Brouwer">Brouwer</a> e formalizada por <a href="https://en.wikipedia.org/wiki/Arend_Heyting">Heyting</a>, rejeita o princípio do terceiro excluído. Principais características:</p>
<ul>
<li>Uma proposição só é considerada verdadeira se existe uma <em>prova construtiva</em> de sua verdade;</li>
<li>A negação de uma proposição <span class="math inline">\(\neg P\)</span> significa que assumir <span class="math inline">\(P\)</span> leva a uma contradição;</li>
<li><span class="math inline">\(P \vee \neg P\)</span> não é universalmente válida - requer demonstração específica para cada <span class="math inline">\(P\)</span>.</li>
</ul>
<p><strong>Diferenças Fundamentais entre a Lógica Clássica e a Intuicionista</strong></p>
<ul>
<li><p><strong>Interpretação da Implicação</strong>: Na lógica clássica, <span class="math inline">\(P \rightarrow Q\)</span> é falsa apenas quando <span class="math inline">\(P\)</span> é verdadeira e <span class="math inline">\(Q\)</span> é falsa. Na lógica intuicionista, <span class="math inline">\(P \rightarrow Q\)</span> requer uma construção que transforme qualquer prova de <span class="math inline">\(P\)</span> em uma prova de <span class="math inline">\(Q\)</span></p></li>
<li><p><strong>Existência</strong>: Na lógica clássica, provar <span class="math inline">\(\exists x \, P(x)\)</span> pode ser feito mostrando que <span class="math inline">\(\neg \forall x \, \neg P(x)\)</span>. Na lógica intuicionista, é necessário fornecer um exemplo específico</p></li>
<li><p><strong>Dupla Negação</strong>: <span class="math inline">\(\neg \neg P \rightarrow P\)</span> é válida na lógica clássica, mas não na intuicionista</p></li>
</ul>
<p>Na lógica intuicionista, a negação da Lei de Peirce não é uma contradição, pois o princípio do terceiro excluído não é universalmente válido. Isso significa que existem modelos intuicionistas nos quais:</p>
<p><span class="math display">\[\neg(((P \rightarrow Q) \rightarrow P) \rightarrow P)\]</span></p>
<p>pode ser verdadeira, demonstrando uma diferença fundamental entre os sistemas lógicos clássico e intuicionista.</p>
<p>A fórmula original <span class="math inline">\((((P \rightarrow Q) \rightarrow P) \rightarrow P)\)</span> é equivalente ao <em>reductio ad absurdum</em> e ao princípio do terceiro excluído na lógica clássica.</p>
</div></li>
</ol>
</section>
<section id="exemplo-6" class="level4" data-number="7.1.3.6">
<h4 data-number="7.1.3.6" class="anchored" data-anchor-id="exemplo-6"><span class="header-section-number">7.1.3.6</span> Exemplo 6</h4>
<p>Considere a fórmula:</p>
<p><span class="math display">\[(P \rightarrow Q) \leftrightarrow (P \rightarrow R)\]</span></p>
<ol type="1">
<li><p>Começamos pela definição de equivalência e implicação:</p>
<p><span class="math display">\[(P \rightarrow Q) \leftrightarrow (P \rightarrow R)\]</span></p></li>
<li><p>Aplicamos as definições de implicação:</p>
<p><span class="math display">\[(\neg P \vee Q) \leftrightarrow (\neg P \vee R)\]</span></p></li>
<li><p>Agora, aplicamos a definição de equivalência, transformando-a em uma conjunção de duas implicações:</p>
<p><span class="math display">\[((\neg P \vee Q) \rightarrow (\neg P \vee R)) \wedge  ((\neg P \vee R) \rightarrow (\neg P \vee Q))\]</span></p></li>
<li><p>Em seguida, aplicamos a definição de implicação novamente para cada uma das implicações internas:</p>
<p><span class="math display">\[(\neg (\neg P \vee Q) \vee (\neg P \vee R)) \wedge  (\neg (\neg P \vee R) \vee (\neg P \vee Q))\]</span></p></li>
<li><p>Vamos aplicar a lei de De Morgan e a lei da dupla negação para simplificar a expressão:</p>
<p><span class="math display">\[((P \wedge  \neg Q) \vee (\neg P \vee R)) \wedge  ((P \wedge  \neg R) \vee (\neg P \vee Q))\]</span></p></li>
<li><p>Aplicando a lei distributiva para desenvolver cada conjunção interna em disjunções:</p>
<p><span class="math display">\[((P \vee (\neg P \vee R)) \wedge  (\neg Q \vee (\neg P \vee R))) \wedge  ((P \vee (\neg P \vee Q)) \wedge  (\neg R \vee (\neg P \vee Q)))\]</span></p></li>
</ol>
<p>A aplicação das equivalências não é, nem de longe, a única forma de percorrer a rota da conversão de uma <strong>Fórmula Bem Formada</strong> em Forma Normal Conjuntiva.</p>
</section>
<section id="sec-exercicios-conversao-fnc" class="level4" data-number="7.1.3.7">
<h4 data-number="7.1.3.7" class="anchored" data-anchor-id="sec-exercicios-conversao-fnc"><span class="header-section-number">7.1.3.7</span> Exercícios de Conversão para Forma Normal Conjuntiva</h4>
<p><strong>1.</strong> Converta a seguinte fórmula para Forma Normal Conjuntiva:</p>
<p><span class="math display">\[(P \leftrightarrow Q) \rightarrow ((P \wedge R) \vee (Q \wedge \neg R))\]</span></p>
<p><span class="math display">\[(P \leftrightarrow Q) \rightarrow ((P \wedge R) \vee (Q \wedge \neg R))\]</span></p>
<p><strong>2.</strong> Transforme em Forma Normal Conjuntiva a fórmula: <span class="math display">\[\neg((P \rightarrow Q) \vee (Q \rightarrow P)) \wedge (P \vee Q)\]</span></p>
<p><strong>3.</strong> Converta para Forma Normal Conjuntiva a negação de uma tautologia distributiva:</p>
<p><span class="math display">\[\neg((P \wedge (Q \vee R)) \leftrightarrow ((P \wedge Q) \vee (P \wedge R)))\]</span></p>
<p><strong>4.</strong> Obtenha a Forma Normal Conjuntiva para:</p>
<p><span class="math display">\[((P \vee Q) \rightarrow R) \leftrightarrow (P \rightarrow R) \wedge (Q \rightarrow R)\]</span></p>
<p><strong>5.</strong> Converta a seguinte fórmula complexa para Forma Normal Conjuntiva:</p>
<p><span class="math display">\[(P \rightarrow (Q \rightarrow R)) \wedge \neg((P \wedge Q) \rightarrow R)\]</span></p>
<p><strong>6.</strong> Transforme em Forma Normal Conjuntiva:</p>
<p><span class="math display">\[((P \leftrightarrow Q) \vee (Q \leftrightarrow R)) \wedge \neg(P \leftrightarrow R)\]</span></p>
<p><strong>7.</strong> Converta para Forma Normal Conjuntiva a fórmula:</p>
<p><span class="math display">\[\neg(P \rightarrow (Q \vee R)) \vee ((P \wedge \neg Q) \rightarrow R)\]</span></p>
</section>
</section>
<section id="usando-a-tabela-verdade-para-gerar-formas-normais" class="level3" data-number="7.1.4">
<h3 data-number="7.1.4" class="anchored" data-anchor-id="usando-a-tabela-verdade-para-gerar-formas-normais"><span class="header-section-number">7.1.4</span> Usando a Tabela-Verdade para Gerar Formas Normais</h3>
<p>A tabela-verdade é nosso navegador experiente que mapeia todas as rotas possíveis em águas desconhecidas das possibilidades lógicas. Como um cartógrafo naval que registra cada banco de areia e recife em uma nova rota marítima, a tabela-verdade cataloga cada combinação possível de verdades e falsidades, criando uma carta náutica completa do oceano lógico que a leitora deverá percorrer em busca da verdade.</p>
<p>Para entender este conceito com um pouco mais de formalidade, considere a <strong>Fórmula Bem Formada</strong> dada por: <span class="math inline">\((A \vee B) \rightarrow (C \wedge  \neg A)\)</span>, se encontrarmos sua Tabela Verdade, poderemos encontrar, tanto a Forma Normal Conjuntiva quanto a Forma Normal Disjuntiva. Basta fixar nosso olhar nas linhas da verdade, ou da falsidade.</p>
<section id="gerando-a-forma-normal-disjuntiva" class="level4" data-number="7.1.4.1">
<h4 data-number="7.1.4.1" class="anchored" data-anchor-id="gerando-a-forma-normal-disjuntiva"><span class="header-section-number">7.1.4.1</span> Gerando a Forma Normal Disjuntiva</h4>
<p>Para transformar <span class="math inline">\((A \vee B) \rightarrow (C \wedge \neg A)\)</span> na sua Forma Normal Conjuntiva, como um timoneiro disciplinado seguindo o roteiro de navegação, devemos seguir rigidamente, os seguintes passos:</p>
<ol type="1">
<li><p>Criar a Tabela-Verdade</p>
<p><span class="math display">\[
\begin{array}{cccc|c|c|c}
A &amp; B &amp; C &amp; \neg A &amp; A \vee B &amp; C \wedge  \neg A &amp; (A \vee B) \rightarrow (C \wedge  \neg A) \\
\hline
T &amp; T &amp; T &amp; F &amp; T &amp; F &amp; F \\
T &amp; T &amp; F &amp; F &amp; T &amp; F &amp; F \\
T &amp; F &amp; T &amp; F &amp; T &amp; F &amp; F \\
T &amp; F &amp; F &amp; F &amp; T &amp; F &amp; F \\
F &amp; T &amp; T &amp; T &amp; T &amp; T &amp; T \\
F &amp; T &amp; F &amp; T &amp; T &amp; F &amp; F \\
F &amp; F &amp; T &amp; T &amp; F &amp; T &amp; T \\
F &amp; F &amp; F &amp; T &amp; F &amp; T &amp; T \\
\end{array}
\]</span></p></li>
<li><p>Identificar as Linhas com Resultado Verdadeiro</p>
<p>As linhas 5, 7 e 8 têm resultado verdadeiro.</p></li>
<li><p>Construir a Forma Normal Disjuntiva usando as linhas com resultados verdadeiros:</p></li>
</ol>
<p>Neste passo, nosso objetivo é construir uma expressão que seja verdadeira nas linhas 5, 7 e 8 (as linhas nas quais o resultado é verdadeiro), e falsa em todos os outros casos. Para fazer isso, criamos uma disjunção (uma expressão <em>OR</em>) para cada linha verdadeira que reflete as condições das variáveis nesta linha, e então unimos essas disjunções com uma conjunção (uma operação <strong>AND</strong>) para criar a Forma Normal Disjuntiva desejada:</p>
<ol type="a">
<li><p><strong>Primeiro Termo Correspondente a Linha 5: <span class="math inline">\((\neg A \wedge  B \wedge  C)\)</span></strong> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é verdadeiro e <span class="math inline">\(C\)</span> é verdadeiro, o que corresponde à linha 5 da tabela.</p></li>
<li><p><strong>Segundo Termo Correspondente a Linha 7: <span class="math inline">\((\neg A \wedge  \neg B \wedge  C)\)</span></strong> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é falso e <span class="math inline">\(C\)</span> é verdadeiro, o que corresponde à linha 7 da tabela.</p></li>
<li><p><strong>Terceiro Correspondente a Linha 8: <span class="math inline">\((\neg A \wedge  \neg B \wedge  \neg C)\)</span></strong> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é falso e <span class="math inline">\(C\)</span> é falso, o que corresponde à linha 8 da tabela.</p></li>
</ol>
<p>Finalmente, unimos estes termos com operações OR (<span class="math inline">\(\vee\)</span>) para criar a expressão Forma Normal Disjuntiva completa:</p>
<p><span class="math display">\[
(A \vee B) \rightarrow (C \wedge  \neg A) = (\neg A \wedge  B \wedge  C) \vee (\neg A \wedge  \neg B \wedge  C) \vee (\neg A \wedge  \neg B \wedge  \neg C)
\]</span></p>
<p>A expressão acima será verdadeira se qualquer um dos termos (ou seja, qualquer uma das linhas 5, 7 ou 8 da tabela) for verdadeiro, garantindo que a expressão capture exatamente as condições em que <span class="math inline">\((A \vee B) \rightarrow (C \wedge  \neg A)\)</span> é verdadeira de acordo com a tabela-verdade.</p>
</section>
<section id="gerando-a-forma-normal-conjuntiva" class="level4" data-number="7.1.4.2">
<h4 data-number="7.1.4.2" class="anchored" data-anchor-id="gerando-a-forma-normal-conjuntiva"><span class="header-section-number">7.1.4.2</span> Gerando a Forma Normal Conjuntiva</h4>
<p>Para transformar <span class="math inline">\((A \vee B) \rightarrow (C \wedge  \neg A)\)</span> em sua Forma Normal Conjuntiva usando a tabela-verdade, devemos nos concentrar nas linhas nas quais a fórmula é <strong>falsa</strong> e criar cláusulas que “proíbam” essas combinações de valores.</p>
<p><strong>Princípio fundamental</strong>: Para cada linha falsa, criamos uma cláusula que será verdadeira <strong>exceto</strong> naquela linha específica.</p>
<ol type="1">
<li><p><strong>Identificar as Linhas com Resultado Falso</strong></p>
<p>As linhas 1, 2, 3, 4 e 6 têm resultado falso.</p></li>
<li><p><strong>Construir Cláusulas Excludentes</strong>: para cada linha falsa, criamos uma cláusula que “proíbe” aquela combinação específica de valores de verdade:</p>
<p><strong>Regra de construção</strong>: Para cada linha falsa, se uma variável tem valor V (verdadeiro), colocamos sua negação na cláusula; se tem valor F (falso), colocamos a variável sem negação.</p>
<ul>
<li><strong>Linha 1</strong> (A=V, B=V, C=V): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee \neg B \vee \neg C)\)</span></li>
<li><strong>Linha 2</strong> (A=V, B=V, C=F): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee \neg B \vee C)\)</span><br>
</li>
<li><strong>Linha 3</strong> (A=V, B=F, C=V): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee B \vee \neg C)\)</span></li>
<li><strong>Linha 4</strong> (A=V, B=F, C=F): Para excluir esta combinação, criamos <span class="math inline">\((\neg A \vee B \vee C)\)</span></li>
<li><strong>Linha 6</strong> (A=F, B=V, C=F): Para excluir esta combinação, criamos <span class="math inline">\((A \vee \neg B \vee C)\)</span></li>
</ul></li>
<li><p><strong>Formar a Forma Normal Conjuntiva</strong>: A conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:</p>
<p><span class="math display">\[\begin{align*}
(A \vee B) \rightarrow (C \wedge  \neg A) &amp;\equiv (\neg A \vee \neg B \vee \neg C) \\
&amp;\wedge (\neg A \vee \neg B \vee C) \\
&amp;\wedge (\neg A \vee B \vee \neg C) \\
&amp;\wedge (\neg A \vee B \vee C) \\
&amp;\wedge (A \vee \neg B \vee C)
\end{align*}\]</span></p></li>
</ol>
<p><strong>Verificação</strong>: Cada cláusula é falsa apenas na linha correspondente da tabela-verdade. A conjunção de todas as cláusulas será verdadeira exceto quando pelo menos uma cláusula for falsa, o que acontece exatamente nas linhas na quais a fórmula original é falsa.</p>
<p>A atenta leitora deve perceber que cada cláusula funciona como uma boia de sinalização que impede navegação em águas perigosas. Cada cláusula exclui uma rota específica (linha falsa) do mapa lógico, garantindo que a expressão final seja verdadeira em todas as outras rotas (linhas verdadeiras).</p>
</section>
</section>
</section>
<section id="formas-normais-avançadas" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="formas-normais-avançadas"><span class="header-section-number">7.2</span> Formas Normais Avançadas</h2>
<section id="forma-normal-prenex" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="forma-normal-prenex"><span class="header-section-number">7.2.1</span> Forma Normal Prenex</h3>
<p>A Forma Normal Prenex é como um almirante experiente organizando a cadeia de comando antes de uma operação naval complexa.</p>
<p>A criativa leitora pode imaginar uma esquadra na qual as ordens estão sendo transmitidas de forma caótica, alguns capitães recebem instruções diretas, outros recebem ordens através de subordinados, e as responsabilidades estão misturadas com as tarefas operacionais. A Forma Normal Prenex é como este almirante que, antes de qualquer manobra, convoca todos os comandantes para a ponte principal, estabelecendo claramente a hierarquia completa, quem comanda o quê e em que ordem, antes de transmitir as instruções operacionais.</p>
<p>Assim como o almirante separa completamente a estrutura de comando (todos os quantificadores universais <span class="math inline">\(\forall\)</span> e existenciais <span class="math inline">\(\exists\)</span> movidos para frente) das ordens de execução (a matriz livre de quantificadores), a Forma Normal Prenex cria uma divisão clara entre “quem decide” e “o que fazer”.</p>
<p>Com um pouco de formalidade a atenta leitora verá que a Forma Normal Prenex é uma padronização para fórmulas da lógica de primeira ordem. Nela, todos os quantificadores são deslocados para a frente da fórmula, deixando a matriz da fórmula livre de quantificadores. A Forma Normal Prenex apresenta três características principais:</p>
<ol type="1">
<li><p><strong>Facilitação da Manipulação Lógica</strong>: ao separar os quantificadores da matriz, a Forma Normal Prenex simplifica a análise e manipulação da estrutura lógica da fórmula;</p></li>
<li><p><strong>Preparação para Outras Formas Normais</strong>: serve como uma etapa intermediária na conversão para outras formas normais, como as Forma Normal Conjuntiva e Forma Normal Disjuntiva;</p></li>
<li><p><strong>Uso em Provas Automáticas</strong>: é amplamente empregada em métodos de prova automática, tornando o raciocínio sobre quantificadores mais acessível.</p></li>
</ol>
<p><strong>Exemplo de conversão para Forma Normal Prenex:</strong></p>
<p>Considere a fórmula original que <strong>não</strong> está em Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \exists z R(z)
\]</span></p>
<p>Para convertê-la para Forma Normal Prenex, seguimos os passos:</p>
<ol type="1">
<li><strong>Padronizar variáveis</strong>: renomear variáveis para evitar conflitos</li>
</ol>
<p><span class="math display">\[
\forall x (P(x) \rightarrow \exists y Q(x,y)) \wedge \exists w R(w)
\]</span></p>
<ol start="2" type="1">
<li><strong>Eliminar implicações</strong>: substituir <span class="math inline">\(P(x) \rightarrow Q(x,y)\)</span> por <span class="math inline">\(\neg P(x) \vee Q(x,y)\)</span></li>
</ol>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y)) \wedge \exists w R(w)
\]</span></p>
<ol start="3" type="1">
<li><strong>Mover quantificadores para fora</strong>: extrair <span class="math inline">\(\exists y\)</span> e <span class="math inline">\(\exists w\)</span> para a frente, preservando a ordem relativa</li>
</ol>
<p><span class="math display">\[
\exists w \forall x \exists y (R(w) \wedge (\neg P(x) \vee Q(x,y)))
\]</span></p>
<p><strong>Exemplo de fórmula já em Forma Normal Prenex:</strong></p>
<p>A fórmula a seguir <strong>já está</strong> em Forma Normal Prenex e não precisa de conversão:</p>
<p><span class="math display">\[
\exists x \forall y (P(x,y) \wedge Q(y))
\]</span></p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Ordem Crítica dos Quantificadores</strong></p>
<p>A ordem relativa entre quantificadores de tipos diferentes <strong>não pode ser alterada</strong> sem modificar o significado lógico:</p>
<ul>
<li><span class="math inline">\(\exists x \forall y \, P(x,y)\)</span>: “Existe um x específico que funciona para todos os y”;</li>
<li><span class="math inline">\(\forall y \exists x \, P(x,y)\)</span>: “Para cada y, pode existir um x diferente”.</li>
</ul>
<p><strong>Exemplo prático</strong>:</p>
<ul>
<li><span class="math inline">\(\exists x \forall y \, \text{AmaX}(x,y)\)</span>: “Existe uma pessoa que ama todo mundo”;</li>
<li><span class="math inline">\(\forall y \exists x \, \text{AmaX}(x,y)\)</span>: “Todo mundo é amado por alguém”.</li>
</ul>
<p>Apenas quantificadores do <strong>mesmo tipo</strong> podem ser reordenados sem alterar o significado:</p>
<ul>
<li><span class="math inline">\(\forall x \forall y \, P(x,y) \equiv \forall y \forall x \, P(x,y)\)</span>;</li>
<li><span class="math inline">\(\exists x \exists y \, P(x,y) \equiv \exists y \exists x \, P(x,y)\)</span>.</li>
</ul>
</div>
</div>
<p><strong>IMPORTANTE</strong>: Quantificadores de tipos diferentes <strong>não podem ser trocados de ordem</strong> sem alterar o significado lógico. As fórmulas <span class="math inline">\(\exists x \forall y \phi(x,y)\)</span> e <span class="math inline">\(\forall y \exists x \phi(x,y)\)</span> <strong>não são equivalentes</strong>. A primeira é logicamente mais forte (existe um <span class="math inline">\(x\)</span> específico que funciona para todos os <span class="math inline">\(y\)</span>), enquanto a segunda é mais fraca (para cada <span class="math inline">\(y\)</span>, pode existir um <span class="math inline">\(x\)</span> diferente).</p>
<p>Uma fórmula na Forma Normal Prenex segue uma estrutura específica definida por:</p>
<p><span class="math display">\[
Q_1 x_1 \, Q_2 x_2 \, \ldots \, Q_n x_n \, M(x_1, x_2, \ldots, x_n)
\]</span></p>
<p>Nessa estrutura:</p>
<ul>
<li><span class="math inline">\(Q_i\)</span> são quantificadores, podendo ser universais <span class="math inline">\(\forall\)</span> ou existenciais <span class="math inline">\(\exists\)</span>;</li>
<li><span class="math inline">\(x_i\)</span> são as variáveis vinculadas pelos quantificadores;</li>
<li><span class="math inline">\(M(x_1, x_2, \ldots, x_n)\)</span> representa a matriz da fórmula, uma expressão lógica sem quantificadores.</li>
</ul>
<p>Converter uma fórmula para a Forma Normal Prenex envolve os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação por disjunções e negações;</p></li>
<li><p><strong>Mover Negações para Dentro</strong>: use as leis de De Morgan para mover as negações para dentro dos quantificadores e proposições;</p></li>
<li><p><strong>Padronizar Variáveis</strong>: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas;</p></li>
<li><p><strong>Mover Quantificadores para Fora</strong>: mova todos os quantificadores para a esquerda da expressão, mantendo a ordem relativa quando necessário para preservar o significado.</p></li>
</ol>
<p>A Forma Normal Prenex é uma representação canônica de fórmulas da lógica de primeira ordem que separa claramente os quantificadores da matriz da fórmula. Ela é uma ferramenta amplamente utilizada na lógica e na teoria da prova, e sua compreensão é essencial para trabalhar com lógica de primeira ordem, especialmente na <strong>Lógica de Primeira Ordem</strong> e teoria da prova, ambas aplicadas na Programação Lógica.</p>
<section id="regras-de-equivalência-prenex" class="level4" data-number="7.2.1.1">
<h4 data-number="7.2.1.1" class="anchored" data-anchor-id="regras-de-equivalência-prenex"><span class="header-section-number">7.2.1.1</span> Regras de Equivalência Prenex</h4>
<p>A Forma Prenex de uma fórmula lógica com quantificadores contém todos os quantificadores para o início da fórmula. Existem algumas regras de equivalência que preservam a Forma Prenex quando aplicadas a uma fórmula:</p>
<p><strong>1. Comutatividade de quantificadores do mesmo tipo</strong>: a ordem dos quantificadores do mesmo tipo pode ser trocada em uma fórmula na Forma Prenex. Por exemplo:</p>
<p><span class="math display">\[
\forall x \forall y \ P(x,y) \Leftrightarrow \forall y \forall x \ P(x,y)
\]</span></p>
<p>Isso ocorre porque a ordem dos quantificadores universais <span class="math inline">\(\forall x\)</span> e <span class="math inline">\(\forall y\)</span> não altera o significado lógico da fórmula. Essa propriedade é conhecida como comutatividade dos quantificadores.</p>
<p><strong>2. Associatividade de quantificadores do mesmo tipo</strong>: quantificadores do mesmo tipo podem ser agrupados de forma associativa em uma Forma Prenex. Por exemplo:</p>
<p><span class="math display">\[
\forall x \forall y \forall z \ P(x,y,z) \Leftrightarrow \forall x (\forall y \forall z \ P(x,y,z))
\]</span></p>
<p>Novamente, o agrupamento dos quantificadores universais não muda o significado da fórmula. Essa é a propriedade associativa.</p>
<p><strong>3. Distributividade de quantificadores sobre operadores lógicos</strong>: existem regras específicas para a distribuição de quantificadores:</p>
<ul>
<li>O quantificador universal distribui sobre conjunção:</li>
</ul>
<p><span class="math display">\[
\forall x (P(x) \wedge Q(x)) \Leftrightarrow (\forall x \ P(x)) \wedge (\forall x \ Q(x))
\]</span></p>
<ul>
<li>O quantificador existencial distribui sobre disjunção:</li>
</ul>
<p><span class="math display">\[
\exists x (P(x) \vee Q(x)) \Leftrightarrow (\exists x \ P(x)) \vee (\exists x \ Q(x))
\]</span></p>
<p>Note que <span class="math inline">\(\forall\)</span> não distribui sobre <span class="math inline">\(\vee\)</span> e <span class="math inline">\(\exists\)</span> não distribui sobre <span class="math inline">\(\wedge\)</span>.</p>
</section>
<section id="conversão-para-formas-normais-conjuntiva-e-disjuntiva" class="level4" data-number="7.2.1.2">
<h4 data-number="7.2.1.2" class="anchored" data-anchor-id="conversão-para-formas-normais-conjuntiva-e-disjuntiva"><span class="header-section-number">7.2.1.2</span> Conversão para Formas Normais Conjuntiva e Disjuntiva</h4>
<p>A conversão para formas clausais (CNF/DNF) em lógica de primeira ordem segue estes passos:</p>
<p><strong>1. Eliminar Implicações</strong>: substitua todas as ocorrências de implicação da forma <span class="math inline">\(A \rightarrow B\)</span> por <span class="math inline">\(\neg A \vee B\)</span>.</p>
<p><strong>2. Mover a Negação para Dentro</strong>: use as leis de De Morgan para mover a negação para dentro dos quantificadores e das proposições:</p>
<ul>
<li><span class="math inline">\(\neg \forall x P(x) \Leftrightarrow \exists x \neg P(x)\)</span></li>
<li><span class="math inline">\(\neg \exists x P(x) \Leftrightarrow \forall x \neg P(x)\)</span></li>
</ul>
<p><strong>3. Padronizar Variáveis</strong>: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas, renomeando-as se necessário.</p>
<p><strong>4. Converter para Forma Normal Prenex</strong>: mova todos os quantificadores para o prefixo, preservando a ordem relativa.</p>
<p><strong>5. Eliminar os Quantificadores Existenciais (Skolemização)</strong>: substitua cada quantificador existencial <span class="math inline">\(\exists x\)</span> por um novo termo constante ou Função Skolem, dependendo das variáveis quantificadas universalmente à esquerda no prefixo Prenex:</p>
<ol type="1">
<li><p><strong>Se o quantificador existencial não tem quantificadores universais à sua esquerda</strong>: Substitua <span class="math inline">\(\exists x P(x)\)</span> por <span class="math inline">\(P(c)\)</span>, sendo que <span class="math inline">\(c\)</span> é uma nova constante.</p></li>
<li><p><strong>Se o quantificador existencial tem quantificadores universais à sua esquerda</strong>: Substitua <span class="math inline">\(\exists x P(x)\)</span> por <span class="math inline">\(P(\mathbf{\mathbf{f}}(y_1, y_2, \ldots, y_n))\)</span>, sendo que <span class="math inline">\(\mathbf{\mathbf{f}}\)</span> é uma nova função Skolem, e <span class="math inline">\(y_1, y_2, \ldots, y_n\)</span> são as variáveis universais à esquerda do quantificador existencial.</p></li>
</ol>
<p><strong>6. Eliminar os Quantificadores Universais</strong>: remova os quantificadores universais, deixando apenas a matriz da fórmula. As variáveis que eram ligadas pelo quantificador universal agora são tratadas como variáveis livres na matriz da fórmula.</p>
<p><strong>7. Conversão para Forma Normal Conjuntiva ou Forma Normal Disjuntiva</strong>:</p>
<ul>
<li><strong>Para Forma Normal Conjuntiva</strong>: use as leis distributivas para converter a matriz em uma conjunção de disjunções (cláusulas)</li>
<li><strong>Para Forma Normal Disjuntiva</strong>: use as leis distributivas para converter a matriz em uma disjunção de conjunções</li>
</ul>
</section>
<section id="exemplo-1---duas-fórmulas-logicamente-equivalentes" class="level4" data-number="7.2.1.3">
<h4 data-number="7.2.1.3" class="anchored" data-anchor-id="exemplo-1---duas-fórmulas-logicamente-equivalentes"><span class="header-section-number">7.2.1.3</span> Exemplo 1 - Duas fórmulas logicamente equivalentes</h4>
<p>Vamos considerar duas fórmulas logicamente equivalentes, uma na Forma Prenex e outra não. Considere a fórmula original:</p>
<p><span class="math display">\[
\forall x \exists y (P(x) \rightarrow Q(y))
\]</span></p>
<p>Se convertida para a Forma Prenex teremos:</p>
<p><span class="math display">\[
\exists y \forall x (P(x) \rightarrow Q(y))
\]</span></p>
<p>A equivalência pode ser demonstrada por meio do seguinte raciocínio: seja <span class="math inline">\(I\)</span> uma interpretação (estrutura) para os predicados <span class="math inline">\(P\)</span> e <span class="math inline">\(Q\)</span> em um domínio não vazio.</p>
<p>Suponha <span class="math inline">\(I\)</span> satisfaz <span class="math inline">\(\forall x \exists y (P(x) \rightarrow Q(y))\)</span>. Existem dois casos a considerar:</p>
<ul>
<li>Se não existe nenhum <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> seja verdadeiro, então a implicação é vacuamente verdadeira para todos os <span class="math inline">\(x\)</span>, e qualquer <span class="math inline">\(y\)</span> satisfará <span class="math inline">\(\exists y \forall x (P(x) \rightarrow Q(y))\)</span></li>
<li>Se existe pelo menos um <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> é verdadeiro, então deve existir um <span class="math inline">\(y\)</span> correspondente tal que <span class="math inline">\(Q(y)\)</span> é verdadeiro. Este mesmo <span class="math inline">\(y\)</span> funcionará para todos os <span class="math inline">\(x\)</span>, satisfazendo <span class="math inline">\(\exists y \forall x (P(x) \rightarrow Q(y))\)</span></li>
</ul>
<p>Assim, existe um <span class="math inline">\(y\)</span> fixo que satisfaz a condição para todo <span class="math inline">\(x\)</span>, preservando a equivalência. O raciocínio inverso também se aplica. Portanto, as fórmulas são logicamente equivalentes.</p>
</section>
<section id="exemplo-2---conversão-para-forma-prenex" class="level4" data-number="7.2.1.4">
<h4 data-number="7.2.1.4" class="anchored" data-anchor-id="exemplo-2---conversão-para-forma-prenex"><span class="header-section-number">7.2.1.4</span> Exemplo 2 - Conversão para Forma Prenex</h4>
<p>A fórmula:</p>
<p><span class="math display">\[
\forall x (P(x) \rightarrow \exists y Q(x,y))
\]</span></p>
<p>Pode ser convertida para Forma Normal Prenex seguindo os passos:</p>
<ol type="1">
<li><strong>Eliminar implicação</strong>: substituir <span class="math inline">\(P(x) \rightarrow \exists y Q(x,y)\)</span> por <span class="math inline">\(\neg P(x) \vee \exists y Q(x,y)\)</span></li>
</ol>
<p><span class="math display">\[
\forall x (\neg P(x) \vee \exists y Q(x,y))
\]</span></p>
<ol start="2" type="1">
<li><strong>Mover quantificadores para fora</strong>: extrair <span class="math inline">\(\exists y\)</span> para a frente, preservando a ordem (∀ antes de ∃)</li>
</ol>
<p><span class="math display">\[
\forall x \exists y (\neg P(x) \vee Q(x,y))
\]</span></p>
<p>A ordem dos quantificadores deve ser preservada para manter o significado original da fórmula.</p>
</section>
<section id="exemplo-3---conversão-para-forma-normal-conjuntiva" class="level4" data-number="7.2.1.5">
<h4 data-number="7.2.1.5" class="anchored" data-anchor-id="exemplo-3---conversão-para-forma-normal-conjuntiva"><span class="header-section-number">7.2.1.5</span> Exemplo 3 - Conversão para Forma Normal Conjuntiva</h4>
<p>Considere a fórmula original em Forma Normal Prenex:</p>
<p><span class="math display">\[
\forall x \exists y (P(x) \wedge Q(y))
\]</span></p>
<p>Siga os passos para conversão para Forma Normal Conjuntiva:</p>
<ol type="1">
<li><strong>Eliminar os Quantificadores Existenciais (Skolemização)</strong>: O quantificador existencial <span class="math inline">\(\exists y\)</span> tem um quantificador universal <span class="math inline">\(\forall x\)</span> à sua esquerda, então substitua por uma função Skolem <span class="math inline">\(\mathbf{\mathbf{f}}(x)\)</span>:</li>
</ol>
<p><span class="math display">\[
\forall x (P(x) \wedge Q(\mathbf{\mathbf{f}}(x)))
\]</span></p>
<ol start="2" type="1">
<li><strong>Eliminar os Quantificadores Universais</strong>: Remova <span class="math inline">\(\forall x\)</span>, tratando <span class="math inline">\(x\)</span> como variável livre:</li>
</ol>
<p><span class="math display">\[
P(x) \wedge Q(\mathbf{\mathbf{f}}(x))
\]</span></p>
<ol start="3" type="1">
<li><strong>Conversão para Forma Normal Conjuntiva</strong>: A matriz já é uma conjunção de literais, resultando em cláusulas:</li>
</ol>
<p><span class="math display">\[
P(x) \wedge Q(\mathbf{\mathbf{f}}(x))
\]</span></p>
<p>Isso equivale a duas cláusulas: <span class="math inline">\(\{P(x)\}\)</span> e <span class="math inline">\(\{Q(\mathbf{f}(x))\}\)</span>.</p>
</section>
<section id="exemplo-4---conversão-para-forma-normal-conjuntiva" class="level4" data-number="7.2.1.6">
<h4 data-number="7.2.1.6" class="anchored" data-anchor-id="exemplo-4---conversão-para-forma-normal-conjuntiva"><span class="header-section-number">7.2.1.6</span> Exemplo 4 - Conversão para Forma Normal Conjuntiva</h4>
<p>Considere a fórmula original:</p>
<p><span class="math display">\[
\forall x (P(x) \rightarrow \exists y Q(x,y))
\]</span></p>
<p>Primeiro, converta para Forma Normal Prenex (como no Exemplo 2):</p>
<p><span class="math display">\[
\forall x \exists y (\neg P(x) \vee Q(x,y))
\]</span></p>
<p>Siga os passos para conversão para Forma Normal Conjuntiva:</p>
<ol type="1">
<li><strong>Eliminar os Quantificadores Existenciais (Skolemização)</strong>: O quantificador existencial <span class="math inline">\(\exists y\)</span> tem <span class="math inline">\(\forall x\)</span> à sua esquerda, então substitua por <span class="math inline">\(\mathbf{f}(x)\)</span>:</li>
</ol>
<p><span class="math display">\[
\forall x (\neg P(x) \vee Q(x, \mathbf{f}(x)))
\]</span></p>
<ol start="2" type="1">
<li><strong>Eliminar os Quantificadores Universais</strong>: Remova <span class="math inline">\(\forall x\)</span>:</li>
</ol>
<p><span class="math display">\[
\neg P(x) \vee Q(x, \mathbf{f}(x))
\]</span></p>
<ol start="3" type="1">
<li><strong>Conversão para Forma Normal Conjuntiva</strong>: A matriz já é uma disjunção (cláusula única):</li>
</ol>
<p><span class="math display">\[
\neg P(x) \vee Q(x, \mathbf{f}(x))
\]</span></p>
<p>Isso resulta na cláusula: <span class="math inline">\(\{\neg P(x), Q(x, \mathbf{f}(x))\}\)</span>.</p>
</section>
<section id="exemplo-5---conversão-para-forma-normal-conjuntiva" class="level4" data-number="7.2.1.7">
<h4 data-number="7.2.1.7" class="anchored" data-anchor-id="exemplo-5---conversão-para-forma-normal-conjuntiva"><span class="header-section-number">7.2.1.7</span> Exemplo 5 - Conversão para Forma Normal Conjuntiva</h4>
<p>Considere a fórmula original em Forma Normal Prenex:</p>
<p><span class="math display">\[
\exists x \forall y (P(x) \vee Q(y))
\]</span></p>
<p>Siga os passos para conversão para Forma Normal Conjuntiva:</p>
<ol type="1">
<li><strong>Eliminar os Quantificadores Existenciais (Skolemização)</strong>: O quantificador existencial <span class="math inline">\(\exists x\)</span> não tem quantificadores universais à sua esquerda, então substitua por uma constante Skolem <span class="math inline">\(c\)</span>:</li>
</ol>
<p><span class="math display">\[
\forall y (P(c) \vee Q(y))
\]</span></p>
<ol start="2" type="1">
<li><strong>Eliminar os Quantificadores Universais</strong>: Remova <span class="math inline">\(\forall y\)</span>:</li>
</ol>
<p><span class="math display">\[
P(c) \vee Q(y)
\]</span></p>
<ol start="3" type="1">
<li><strong>Conversão para Forma Normal Conjuntiva</strong>: A matriz é uma disjunção, resultando em uma cláusula única:</li>
</ol>
<p><span class="math display">\[
P(c) \vee Q(y)
\]</span></p>
<p>Isso equivale à cláusula: <span class="math inline">\(\{P(c), Q(y)\}\)</span>.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Preservação vs.&nbsp;Equivalência na Skolemização</strong></p>
<p>A Skolemização é um processo que preserva a satisfatibilidade mas <strong>não preserva a equivalência lógica</strong>. Isso significa:</p>
<ul>
<li>Se a fórmula original é satisfatível, a fórmula skolemizada também será;</li>
<li>Se a fórmula original é insatisfatível, a fórmula skolemizada também será;</li>
<li><strong>Porém</strong>, a fórmula skolemizada pode ser verdadeira em modelos onde a original é falsa.</li>
</ul>
<p>Esta distinção é fundamental em: - <strong>Provas por refutação</strong>: onde buscamos inconsistência (adequado para Skolemização); - <strong>Verificação de modelos</strong>: onde precisamos preservar verdade (Skolemização inadequada); - <strong>Sistemas como Prolog</strong>: que utilizam formas clausais skolemizadas para inferência.</p>
<p>Por isso a Skolemização é apropriada para métodos de prova automática como resolução, mas não para verificação direta de satisfação de fórmulas.</p>
</div>
</div>
<blockquote class="blockquote">
<p>A conversão para Forma Normal Conjuntiva (forma clausal) é amplamente utilizada em métodos de prova automática como resolução. A conversão para Forma Normal Disjuntiva é menos comum, mas pode ser aplicada em alguns contextos de análise lógica. <strong>OBSERVAÇÃO: a Skolemização (eliminação dos quantificadores existenciais) pode alterar a interpretação da fórmula em alguns modelos, mas preserva a satisfatibilidade, sendo apropriada para provas automáticas</strong>.</p>
</blockquote>
</section>
</section>
<section id="skolemização" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="skolemização"><span class="header-section-number">7.2.2</span> Skolemização</h3>
<p>A Skolemização é como um pescador veterano que transforma indicações vagas de cardumes em coordenadas precisas de pesca. Quando encontramos uma afirmação do tipo ‘há peixes por aqui’, a Skolemização nos permite dizer ’muito bem, vamos marcar este ponto específico no GPS”.</p>
<p>A criativa leitora pode se imaginar como um mestre de porto organizando o registro de embarcações: em vez de deixar referências vagas como ‘existe um navio cargueiro’, o mestre de porto cria um sistema de registro que permite localizar exatamente qual embarcação estamos procurando, baseados nas necessidades que definem nossos critérios de busca.</p>
<p>Considere a fórmula a seguir com um quantificador universal e um existencial:</p>
<p><span class="math display">\[\forall x \exists y P(x,y)\]</span></p>
<p>Ao aplicar a Skolemização, a variável existencial <span class="math inline">\(y\)</span> é substituída por uma Função de Skolem <span class="math inline">\(\mathbf{f}(x)\)</span>:</p>
<p><span class="math display">\[P(x,\mathbf{f}(x))\]</span></p>
<p>Para uma fórmula com dois quantificadores universais e dois existenciais:</p>
<p><span class="math display">\[\forall x \forall z \exists y \exists w R(x,y,z,w)\]</span></p>
<p>A Skolemização resultará em:</p>
<p><span class="math display">\[\forall x \forall z R(x,\mathbf{f}(x),z,\mathbf{g}(x,z))\]</span></p>
<p><span class="math inline">\(\mathbf{f}(x)\)</span> e $ (x,z)$ são Funções Skolem introduzidas para substituir as variáveis existenciais <span class="math inline">\(y\)</span> e $w $ respectivamente. A escolha entre Constante e Função Skolem é como decidir entre definir valores definitivos ou sua ação e aplicação:</p>
<ul>
<li><p>A <strong>Constante Skolem</strong> é como batizar um navio com nome fixo, “Santa Maria sempre será Santa Maria”, independente da rota ou tripulação.</p></li>
<li><p>A <strong>Função Skolem</strong> é como designar um papel dinâmico, “o navio de apoio da embarcação principal”, no qual a identidade específica muda dependendo de qual é a embarcação principal, mas a relação permanece consistente.</p></li>
</ul>
<p>Se nossa expedição marítima já tem os tripulantes estabelecidos, as variáveis universais, então nosso novo tripulante existencial precisa se adaptar a eles através de uma função. Isso pode ser feito com as fórmulas lógicas seguindo os seguintes passos:</p>
<p><strong>Passo 1: Identificar os Quantificadores Existenciais</strong>: comece identificando os quantificadores existenciais na fórmula.</p>
<p><strong>Passo 2: Determinar se a Variável Existencial Depende de Variáveis Universais</strong>: para cada variável ligada a um quantificador existencial, determinamos se ela depende ou não de alguma variável universal. Isso significa verificar se existem quantificadores universais que <em>dominam</em> a variável existencial. Se a variável existencial não depende de variáveis universais, usamos uma Constante de Skolem. Caso contrário, usamos uma Função de Skolem que leva como parâmetros as variáveis universais que a dominam.</p>
<p><strong>Passo 3: Substituir as Variáveis Existenciais</strong>: agora, substituímos todas as variáveis existenciais na fórmula original de acordo com as decisões tomadas no Passo 2. Se usarmos Constantes de Skolem, substituímos as variáveis existenciais diretamente pelas constantes. Se usarmos Funções de Skolem, substituímos as variáveis existenciais pelas funções de Skolem aplicadas às variáveis universais apropriadas.</p>
<p><strong>Exemplo 1</strong>: considere a <strong>Fórmula Bem Formada</strong> dada por: <span class="math inline">\(\forall x \exists y \, P(x,y)\)</span></p>
<ol type="1">
<li><p><strong>Identificação do quantificador existencial</strong>: identificamos o quantificador existencial <span class="math inline">\(\exists y\)</span> que introduz a variável <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Análise de dependência</strong>: a variável existencial <span class="math inline">\(y\)</span> <strong>depende</strong> da variável universal <span class="math inline">\(x\)</span>, pois o quantificador <span class="math inline">\(\forall x\)</span> aparece <strong>antes</strong> de <span class="math inline">\(\exists y\)</span> na fórmula. Isso significa que para cada valor específico de <span class="math inline">\(x\)</span>, existe um valor correspondente de <span class="math inline">\(y\)</span> que pode variar com <span class="math inline">\(x\)</span>.</p></li>
<li><p><strong>Escolha da substituição</strong>: como <span class="math inline">\(y\)</span> depende de <span class="math inline">\(x\)</span>, usamos uma <strong>Função de Skolem</strong> <span class="math inline">\(\mathbf{f}(x)\)</span> (não uma constante). A função <span class="math inline">\(\mathbf{f}\)</span> “escolhe” o valor apropriado de <span class="math inline">\(y\)</span> para cada <span class="math inline">\(x\)</span>.</p></li>
<li><p><strong>Substituição</strong>: substituímos <span class="math inline">\(y\)</span> por <span class="math inline">\(\mathbf{f}(x)\)</span> na fórmula: <span class="math display">\[\forall x \ P(x,\mathbf{f}(x))\]</span></p></li>
<li><p><strong>Remoção dos quantificadores universais</strong>: removemos o quantificador universal restante, obtendo a forma final: <span class="math display">\[P(x,\mathbf{f}(x))\]</span></p></li>
</ol>
<p><strong>Intuição</strong>: A função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span> representa uma “regra de escolha” que, dado qualquer valor de <span class="math inline">\(x\)</span>, seleciona o valor apropriado de <span class="math inline">\(y\)</span> que satisfaz <span class="math inline">\(P(x,y)\)</span>. Por exemplo, se <span class="math inline">\(P(x,y)\)</span> significa “<span class="math inline">\(y\)</span> é o dobro de <span class="math inline">\(x\)</span>”, então <span class="math inline">\(\mathbf{f}(x) = 2x\)</span>.</p>
<p><strong>Exemplo 2</strong>: considere a fórmula original: <span class="math inline">\(\forall x \forall z \exists y \ Q(x,y,z)\)</span></p>
<ol type="1">
<li><p>Identificamos o quantificador existencial que introduz a variável <span class="math inline">\(y\)</span>.</p></li>
<li><p>A variável <span class="math inline">\(y\)</span> depende de duas variáveis universais, <span class="math inline">\(x\)</span> e <span class="math inline">\(z\)</span>. Portanto, usamos uma Função de Skolem, digamos <span class="math inline">\(\mathbf{f}(x,z)\)</span>. A fórmula se torna:</p>
<p><span class="math display">\[\forall x \forall z \ Q(x,\mathbf{f}(x,z),z)\]</span></p></li>
</ol>
<p>Substituímos <span class="math inline">\(y\)</span> por <span class="math inline">\(\mathbf{f}(x,z)\)</span>, que é uma função que depende das variáveis universais <span class="math inline">\(x\)</span> e <span class="math inline">\(z\)</span>.</p>
<p>Em resumo, a Skolemização simplifica fórmulas quantificadas, eliminando quantificadores existenciais e substituindo variáveis por Constantes ou Funções de Skolem, dependendo de sua relação com quantificadores universais. Isso auxilia na conversão de fórmulas quantificadas para a Forma Normal Conjuntiva e na simplificação da lógica.</p>
<section id="exemplos-de-conversão-em-formas-normais-conjuntiva-e-disjuntiva" class="level4" data-number="7.2.2.1">
<h4 data-number="7.2.2.1" class="anchored" data-anchor-id="exemplos-de-conversão-em-formas-normais-conjuntiva-e-disjuntiva"><span class="header-section-number">7.2.2.1</span> Exemplos de conversão em formas normais, conjuntiva e disjuntiva</h4>
<ol type="a">
<li>Todos os alunos estudam ou alguns professores ensinam matemática</li>
</ol>
<p><strong>Lógica de Primeira Ordem</strong>:</p>
<p><span class="math display">\[
\forall x(\text{Aluno}(x) \rightarrow \text{Estuda}(x)) \vee \exists y(\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p>
<p><strong>Conversão para Forma Normal Conjuntiva </strong>:</p>
<ol type="1">
<li><p><strong>Eliminar implicações</strong>: converter <span class="math inline">\(A \rightarrow B\)</span> em <span class="math inline">\(\neg A \vee B\)</span>.</p>
<p><span class="math display">\[
\forall x(\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee \exists y(\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p></li>
<li><p><strong>Padronizar variáveis</strong>: as variáveis <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> já são distintas e não há conflito de escopo. Nenhuma alteração é necessária.</p></li>
<li><p><strong>Converter para Forma Normal Prenex</strong>: mover todos os quantificadores para a frente da fórmula.</p>
<p><span class="math display">\[
\forall x \exists y ((\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y)))
\]</span></p></li>
<li><p><strong>Skolemização</strong>: eliminar o quantificador existencial <span class="math inline">\(\exists y\)</span>. Como <span class="math inline">\(y\)</span> está no escopo de <span class="math inline">\(\forall x\)</span>, ele é substituído por uma função Skolem <span class="math inline">\(\mathbf{f}(x)\)</span>.</p>
<p><span class="math display">\[
\forall x ((\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(\mathbf{f}(x)) \wedge \text{EnsinaMatemática}(\mathbf{f}(x))))
\]</span></p></li>
<li><p><strong>Aplicar distributividade</strong>: distribuir <span class="math inline">\(\vee\)</span> sobre <span class="math inline">\(\wedge\)</span> usando a regra <span class="math inline">\((P \vee (Q \wedge R)) \equiv ((P \vee Q) \wedge (P \vee R))\)</span>.</p>
<p><span class="math display">\[
\forall x ((\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{Professor}(\mathbf{f}(x))) \wedge (\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{EnsinaMatemática}(\mathbf{f}(x))))
\]</span></p></li>
<li><p><strong>Remover quantificadores universais</strong>: na forma clausal, os quantificadores universais são implícitos.</p>
<p><span class="math display">\[
(\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{Professor}(\mathbf{f}(x))) \wedge (\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee \text{EnsinaMatemática}(\mathbf{f}(x)))
\]</span></p></li>
</ol>
<p><strong>Resultado final em Forma Normal Conjuntiva</strong>: A fórmula está na Forma Normal Conjuntiva, representada como uma conjunção de duas cláusulas.</p>
<p><strong>Conversão para Forma Normal Disjuntiva </strong>:</p>
<p>A conversão para Forma Normal Disjuntiva segue um caminho diferente e <strong>não utiliza Skolemização</strong>, pois este processo não preserva a equivalência lógica. O ponto de partida correto é a Forma Normal Prenex (passo 3 da conversão anterior).</p>
<ol type="1">
<li><p><strong>Ponto de Partida (Forma Normal Prenex)</strong>:</p>
<p><span class="math display">\[
\forall x \exists y ((\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y)))
\]</span></p></li>
<li><p><strong>Analisar a Matriz da Fórmula</strong>: A matriz é a parte da fórmula sem os quantificadores. Vamos analisá-la:</p>
<p><span class="math display">\[
(\neg \text{Aluno}(x) \vee \text{Estuda}(x)) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p>
<p>Uma fórmula está em Forma Normal Disjuntiva se for uma disjunção de conjunções de literais. Simplificando a expressão acima (removendo parênteses por associatividade), obtemos:</p>
<p><span class="math display">\[
\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))
\]</span></p>
<p>Esta estrutura já corresponde a uma Forma Normal Disjuntiva. Ela é uma disjunção (termos ligados por <span class="math inline">\(\vee\)</span>) de três termos: <span class="math inline">\(\neg \text{Aluno}(x)\)</span>, <span class="math inline">\(\text{Estuda}(x)\)</span> e a conjunção <span class="math inline">\((\text{Professor}(y) \wedge \text{EnsinaMatemática}(y))\)</span>. Nenhum passo de distribuição é necessário.</p></li>
</ol>
<p><strong>Resultado final em Forma Normal Disjuntiva</strong>: A Forma Normal Disjuntiva da fórmula, mantendo os quantificadores, é:</p>
<p><span class="math display">\[
\forall x \exists y (\neg \text{Aluno}(x) \vee \text{Estuda}(x) \vee (\text{Professor}(y) \wedge \text{EnsinaMatemática}(y)))
\]</span></p>
<p><strong>Observação</strong>: A estrutura da fórmula original, uma grande disjunção (<span class="math inline">\(P \vee Q\)</span>), faz com que ela seja naturalmente próxima da Forma Normal Disjuntiva, exigindo poucos ou nenhum passo de conversão. Em contraste, para chegar à Forma Normal Conjuntiva, foi necessário aplicar a lei da distributividade, resultando em uma expressão mais complexa.</p>
</section>
</section>
</section>
<section id="sec-predicativa-conexao-prolog" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="sec-predicativa-conexao-prolog"><span class="header-section-number">7.3</span> Exercícios de Conexão com Prolog</h2>
<p>A conversão de fórmulas para uma <strong>Forma Normal</strong> (seja Conjuntiva - <strong>Forma Normal Conjuntiva</strong>, ou Disjuntiva - <strong>Forma Normal Disjuntiva</strong>) é um processo algorítmico que permite a padronização e a manipulação de expressões lógicas por computadores. Este conjunto de questões foca nesta habilidade, que é a base para o funcionamento de provadores de teoremas e do mecanismo de resolução do Prolog.</p>
<p><strong>Questão 1: Conversão Básica</strong>: dada a seguinte fórmula lógica, que representa uma regra de negócio simples: “Se o pedido (<span class="math inline">\(P\)</span>) foi aprovado, então a nota fiscal (<span class="math inline">\(N\)</span>) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (<span class="math inline">\(E\)</span>).” Fórmula:</p>
<p><span class="math display">\[(P \to N) \wedge \neg (N \wedge \neg E)\]</span></p>
<p>Converta esta fórmula para:</p>
<ol type="1">
<li>A Forma Normal Conjuntiva.<br>
</li>
<li>A Forma Normal Disjuntiva.</li>
</ol>
<p><strong>Questão 2: Cenários de Ativação de Sistema</strong>: um sistema de irrigação automática (<span class="math inline">\(I\)</span>) é ativado se o sensor de umidade do solo indicar que está seco (<span class="math inline">\(S\)</span>) ou se não choveu nas últimas 24 horas (<span class="math inline">\(\neg C\)</span>) e a temperatura está alta (<span class="math inline">\(T\)</span>).</p>
<ol type="1">
<li>Modele a condição de ativação (<span class="math inline">\(I\)</span>) como uma fórmula lógica.<br>
</li>
<li>Converta a fórmula para a Forma Normal Disjuntiva. O que cada termo da Forma Normal Disjuntiva representa em termos de cenários práticos de ativação?</li>
</ol>
<p><strong>Questão 3: Verificação de Consistência de Regras</strong>: as regras de configuração de um firewall são:</p>
<ol type="1">
<li>Se uma conexão é da rede interna (<span class="math inline">\(I\)</span>), ela é permitida (<span class="math inline">\(P\)</span>).<br>
</li>
<li>Se uma conexão não é da rede interna, ela só é permitida se for uma conexão segura (<span class="math inline">\(S\)</span>).<br>
</li>
<li>Uma conexão segura nunca vem da rede interna.</li>
</ol>
<p>Modele as três regras como uma única fórmula. Converta-a para a Forma Normal Conjuntiva. A Forma Normal Conjuntiva resultante indica se as regras são consistentes? O que aconteceria se uma conexão fosse segura e viesse da rede interna?</p>
<p><strong>Questão 4: Equivalência de Políticas de Segurança</strong>: dois administradores de sistemas escreveram políticas de acesso a um servidor de desenvolvimento.</p>
<ul>
<li><p><strong>Política de Alice:</strong> “Um desenvolvedor (<span class="math inline">\(D\)</span>) pode acessar o servidor se tiver uma chave de acesso (<span class="math inline">\(C\)</span>), ou se não tiver uma chave de acesso mas estiver trabalhando em um projeto crítico (<span class="math inline">\(P\)</span>).”</p></li>
<li><p><strong>Política de Beto:</strong> “Um desenvolvedor (<span class="math inline">\(D\)</span>) pode acessar o servidor se estiver trabalhando em um projeto crítico (<span class="math inline">\(P\)</span>), ou se tiver uma chave de acesso (<span class="math inline">\(C\)</span>).”</p></li>
</ul>
<p>Modele as duas políticas como fórmulas lógicas e converta ambas para a Forma Normal Disjuntiva Mínima. Elas são logicamente equivalentes?</p>
<p><strong>Questão 5: Eliminando a Bicondicional</strong>: uma regra de um e-commerce afirma: “Um cliente recebe frete grátis (<span class="math inline">\(F\)</span>) se, e somente se, ele for um membro Prime (<span class="math inline">\(P\)</span>) ou o valor do seu pedido for superior a R$100 (<span class="math inline">\(V\)</span>).”</p>
<p>Fórmula:</p>
<p><span class="math display">\[F \leftrightarrow (P \vee V)\]</span></p>
<p>Converta esta fórmula para a Forma Normal Conjuntiva. Cada cláusula da Forma Normal Conjuntiva representa que tipo de restrição no sistema?</p>
<p><strong>Questão 6: Simplificação de Circuito Lógico</strong>: a saída de um circuito lógico com três entradas (<span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>) é descrita pela seguinte tabela verdade:</p>
<table class="table">
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B\)</span></th>
<th><span class="math inline">\(C\)</span></th>
<th>Saída</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>Escreva a Forma Normal Disjuntiva canônica a partir da tabela.</p></li>
<li><p>Use um Mapa de Karnaugh ou álgebra booleana para encontrar a Forma Normal Disjuntiva mínima.</p></li>
</ol>
<p><strong>Questão 7: Validando uma Inferência (Tautologia)</strong>: considere que “Todos os leões são mamíferos” e “Simba é um leão”, podemos concluir “Simba é um mamífero”. Prove que a estrutura lógica desta inferência é uma tautologia:</p>
<p><span class="math display">\[((\forall x(L(x) \to M(x))) \wedge L(S)) \to M(S)\]</span></p>
<p><strong>Questão 8: Problema de Satisfatibilidade (SAT)</strong>: três programadores (Ana, Beto, Carla) precisam ser alocados para um projeto. As restrições são:</p>
<ol type="1">
<li>Pelo menos um dos três deve ser alocado;<br>
</li>
<li>Ana e Beto não podem trabalhar juntos;</li>
<li>Se Carla for alocada, então Ana também deve ser.</li>
</ol>
<p>Sejam <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> as proposições “Ana foi alocada”, “Beto foi alocado” e “Carla foi alocada”. Modele as três restrições e converta-as para um conjunto de cláusulas em Forma Normal Conjuntiva. O conjunto de restrições é satisfatível? Se sim, apresente uma alocação válida.</p>
<p><strong>Questão 9: Forma Normal Prenex</strong>: a conversão para Forma Normal Clausal, que veremos no próximo capítulo, muitas vezes começa com a conversão para a Forma Normal Prenex, na qual todos os quantificadores são movidos para o início da fórmula.<br>
Converta a seguinte fórmula para a Forma Normal Prenex:</p>
<p><span class="math display">\[\forall x (P(x) \to (\exists y (Q(y) \wedge R(x,y)))) \vee \exists z S(z)\]</span></p>
<p><strong>Questão 10: O Princípio da Resolução</strong>: o Princípio da Resolução é um método de inferência que opera sobre cláusulas em Forma Normal Conjuntiva. Dadas duas cláusulas <span class="math inline">\((\neg P \vee Q)\)</span> e <span class="math inline">\((P \vee R)\)</span>, podemos inferir a cláusula resolvente <span class="math inline">\((Q \vee R)\)</span>.<br>
Use o Princípio da Resolução para provar que o seguinte conjunto de cláusulas é inconsistente (leva à cláusula vazia, <span class="math inline">\(\square\)</span>):</p>
<ol type="1">
<li><span class="math inline">\(\neg P \vee \neg Q \vee R\)</span>;<br>
</li>
<li><span class="math inline">\(P \vee R\)</span>;<br>
</li>
<li><span class="math inline">\(Q\)</span>;<br>
</li>
<li><span class="math inline">\(\neg R\)</span>.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./04-logica-predicativa-e-quantificadores.html" class="pagination-link" aria-label="Lógica de Primeira Ordem: Lógica Predicativa">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./06-construcao-de-mundos-logicos.html" class="pagination-link" aria-label="Mundos na **Lógica de Primeira Ordem**">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Mundos na <strong>Lógica de Primeira Ordem</strong></span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/05-formas-normais-e-skolemizacao.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>