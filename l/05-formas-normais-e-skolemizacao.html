<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 6&nbsp; Formas Normais</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06-construcao-de-mundos-logicos.html" rel="next">
<link href="./04-logica-predicativa-e-quantificadores.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Formas Normais</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title"><strong>Lógica de Primeira Ordem</strong></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Provas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Formas Normais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Mundos na <strong>Lógica de Primeira Ordem</strong></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Cláusulas de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Problemas Interessantes Resolvidos com Lógica Proposicional e Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#forma-normal-negativa-fnn" id="toc-forma-normal-negativa-fnn" class="nav-link active" data-scroll-target="#forma-normal-negativa-fnn"><span class="header-section-number">6.0.1</span> Forma Normal Negativa (FNN)</a></li>
  <li><a href="#forma-normal-disjuntiva-fnd" id="toc-forma-normal-disjuntiva-fnd" class="nav-link" data-scroll-target="#forma-normal-disjuntiva-fnd"><span class="header-section-number">6.0.2</span> Forma Normal Disjuntiva (FND)</a></li>
  <li><a href="#forma-normal-conjuntiva-fnc" id="toc-forma-normal-conjuntiva-fnc" class="nav-link" data-scroll-target="#forma-normal-conjuntiva-fnc"><span class="header-section-number">6.0.3</span> Forma Normal Conjuntiva (FNC)</a></li>
  <li><a href="#forma-normal-prenex" id="toc-forma-normal-prenex" class="nav-link" data-scroll-target="#forma-normal-prenex"><span class="header-section-number">6.0.4</span> Forma Normal Prenex</a></li>
  <li><a href="#usando-a-tabela-verdade-para-gerar-formas-normais" id="toc-usando-a-tabela-verdade-para-gerar-formas-normais" class="nav-link" data-scroll-target="#usando-a-tabela-verdade-para-gerar-formas-normais"><span class="header-section-number">6.0.5</span> Usando a Tabela-Verdade para Gerar Formas Normais</a></li>
  <li><a href="#skolemização" id="toc-skolemização" class="nav-link" data-scroll-target="#skolemização"><span class="header-section-number">6.1</span> Skolemização</a>
  <ul class="collapse">
  <li><a href="#exemplos-de-conversão-em-formas-normais-conjuntiva-e-disjuntiva" id="toc-exemplos-de-conversão-em-formas-normais-conjuntiva-e-disjuntiva" class="nav-link" data-scroll-target="#exemplos-de-conversão-em-formas-normais-conjuntiva-e-disjuntiva"><span class="header-section-number">6.1.1</span> Exemplos de conversão em formas normais, conjuntiva e disjuntiva</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/05-formas-normais-e-skolemizacao.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Formas Normais</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Formas Normais</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>As formas normais, em sua essência, são um meio de trazer ordem e consistência à forma como representamos proposições na Lógica Proposicional. Elas oferecem uma estrutura formalizada para expressar proposições, uma convenção que simplifica a comparação, análise, entendimento e simplificação de proposições lógicas.</p>
<p>Consideremos, por exemplo, a tarefa de comparar duas proposições para determinar se são equivalentes. Sem uma forma padronizada de representar proposições, essa tarefa pode se tornar complexa e demorada. No entanto, ao utilizar as formas normais, cada proposição é expressa de uma forma padrão, tornando a comparação direta e simples. Além disso, as formas normais também desempenham um papel importante na simplificação de proposições. Ao expressar uma proposição em sua forma normal, é mais fácil identificar oportunidades de simplificação, removendo redundâncias ou simplificando a estrutura lógica. As formas normais não são apenas uma ferramenta para lidar com a complexidade da Lógica Proposicional, mas também uma metodologia que facilita a compreensão e manipulação de proposições lógicas.</p>
<p>Existem várias formas normais na Lógica Proposicional, cada uma com suas próprias regras e aplicações. Aqui estão algumas das principais:</p>
<ol type="1">
<li><p><strong>Forma Normal Negativa (PNN)</strong>: Uma proposição está na Forma Normal Negativa se as operações de negação $$Aparecerem apenas imediatamente antes das variáveis. Isso é conseguido aplicando as leis de De Morgan e eliminando as duplas negações.</p>
<p><span class="math display">\[\neg (A \wedge B) \equiv (\neg A \vee \neg B)\]</span></p></li>
<li><p><strong>Forma Normal Conjuntiva (PNC)</strong>: Uma proposição está na Forma Normal Conjuntiva se for uma conjunção, operação <em>E</em>, $$, de uma ou mais cláusulas, onde cada cláusula é uma disjunção, operação <em>OU</em>, $$, de literais. Em outras palavras, é uma série de cláusulas conectadas por <em>Es</em>, onde cada cláusula é composta de variáveis conectadas por <em>OUs</em>.</p>
<p><span class="math display">\[(A \vee B) \wedge (C \vee D) \equiv (A \wedge C) \vee (A \wedge D) \vee (B \wedge C) \vee (B \wedge D)\]</span></p></li>
<li><p><strong>Forma Normal Disjuntiva (PND)</strong>: uma proposição está na Forma Normal Disjuntiva se for uma disjunção de uma ou mais cláusulas, onde cada cláusula é uma conjunção de literais. Ou seja, é uma série de cláusulas conectadas por <strong>ORs</strong>, onde cada cláusula é composta de variáveis conectadas por <strong>ANDs</strong>.</p>
<p><span class="math display">\[(A \wedge B) \vee (C \wedge D) \equiv (A \vee C) \wedge (A \vee D) \wedge (B \vee C) \wedge (B \vee D)\]</span></p></li>
<li><p><strong>Forma Normal Prenex (PNP)</strong>: uma proposição está na Forma Normal Prenex se todos os quantificadores, para a <strong>Lógica de Primeira Ordem</strong>, estiverem à esquerda, precedendo uma matriz quantificadora livre. Esta forma é útil na <strong>Lógica de Primeira Ordem</strong> e na teoria da prova.</p>
<p><span class="math display">\[\exists x \forall y (P(x,y) \wedge Q(y)) \equiv \forall y \exists x (P(x,y) \wedge Q(y))\]</span></p></li>
<li><p><strong>Forma Normal Skolem (PNS)</strong>: na <strong>Lógica de Primeira Ordem</strong>, uma fórmula está na Forma Normal de Skolem se estiver na Forma Normal Prenex e se todos os quantificadores existenciais forem eliminados. Isto é realizado através de um processo conhecido como Skolemização.</p>
<p><span class="math display">\[\forall x (P(x,y)) \equiv P(x, f(x))\]</span></p></li>
</ol>
<p>Nosso objetivo é rever a matemática que suporta a Programação Lógica, entre as principais formas normais, para este objetivo, precisamos destacar duas formas normais:</p>
<ol type="1">
<li><p><strong>Forma Normal Conjuntiva (FNC)</strong>: a Forma Normal Conjuntiva é importante na Programação Lógica porque muitos sistemas de inferência, como a resolução, funcionam em fórmulas que estão na FNC. Além disso, os programas em Prolog, A linguagem de Programação Lógica que escolhemos, são essencialmente cláusulas na FNC.</p></li>
<li><p><strong>Forma Normal de Skolem (FNS)</strong>: a Forma Normal de Skolem é útil na Programação Lógica porque a Skolemização, o processo de remover quantificadores existenciais transformando-os em funções de quantificadores universais, permite uma forma mais eficiente de representação e processamento de fórmulas lógicas. Essa forma normal é frequentemente usada em <strong>Lógica de Primeira Ordem</strong> e teoria da prova, ambas fundamentais para a Programação Lógica.</p></li>
</ol>
<p>Embora outras formas normais possam ter aplicações em áreas específicas da Programação Lógica, a FNC e a FNS são provavelmente as mais amplamente aplicáveis e úteis nesse Proposição. Começando com a Forma Normal Conjuntiva.</p>
<p>Se considerarmos as propriedades associativas apresentadas nas linhas 20 e 21 da Tabela 2, podemos escrever uma sequência de conjunções, ou disjunções, sem precisarmos de parênteses. Sendo assim, teremos:</p>
<p><span class="math display">\[((P \wedge (Q \wedge R)) \wedge S)\]</span></p>
<p>Pode ser escrita como:</p>
<p><span class="math display">\[P\wedge Q \wedge R \wedge s \]</span></p>
<section id="forma-normal-negativa-fnn" class="level3" data-number="6.0.1">
<h3 data-number="6.0.1" class="anchored" data-anchor-id="forma-normal-negativa-fnn"><span class="header-section-number">6.0.1</span> Forma Normal Negativa (FNN)</h3>
<p>A Forma Normal Negativa é uma representação canônica de fórmulas lógicas em que as negações são aplicadas apenas aos átomos da fórmula e não a expressões mais complexas. Em outras palavras, a negação está <em>empurrada para dentro</em> o máximo possível. A FNN é útil por sua simplicidade e é frequentemente um passo intermediário na conversão para outras formas normais.</p>
<p>Uma fórmula está na Forma Normal Negativa se:</p>
<ul>
<li>todos os operadores de negação $$ são aplicados diretamente aos átomos, variáveis ou constantes.</li>
<li>usaremos apenas a negação $$, a conjunção $$, e a disjunção $$.</li>
</ul>
<p>Converter uma fórmula para a FNN envolve os seguintes passos:</p>
<ol type="1">
<li><strong>Eliminar os Bicondicionais</strong>: substitua todas as ocorrências de <span class="math inline">\(A\leftrightarrow B\)</span> Por <span class="math inline">\(A\rightarrow B \wedge B\rightarrow A\)</span>.</li>
<li><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \lor B\)</span>.</li>
<li><strong>Aplicar as Leis de De Morgan</strong>: Use as leis de De Morgan para mover as negações para dentro, aplicando:
<ul>
<li><span class="math inline">\(\neg (A \land B) \rightarrow \neg A \lor \neg B\)</span></li>
<li><span class="math inline">\(\neg (A \lor B) \rightarrow \neg A \land \neg B\)</span></li>
</ul></li>
<li><strong>Eliminar Dupla Negação</strong>: Substitua qualquer dupla negação <span class="math inline">\(\neg \neg A\)</span> Por <span class="math inline">\(A\)</span>.</li>
</ol>
<section id="exemplo-1-converta-a-fórmula-neg-a-land-b-rightarrow-c-para-fnn" class="level4" data-number="6.0.1.1">
<h4 data-number="6.0.1.1" class="anchored" data-anchor-id="exemplo-1-converta-a-fórmula-neg-a-land-b-rightarrow-c-para-fnn"><span class="header-section-number">6.0.1.1</span> Exemplo 1: Converta a fórmula <span class="math inline">\(\neg (A \land (B \rightarrow C))\)</span> Para FNN</h4>
<ol type="1">
<li>Eliminar Implicações: <span class="math inline">\(\neg (A \land (\neg B \lor C))\)</span></li>
<li>Aplicar De Morgan: <span class="math inline">\(\neg A \lor (B \land \neg C)\)</span></li>
<li>Eliminar Dupla Negação: <span class="math inline">\(\neg A \lor (B \land \neg C)\)</span>(já está na FNN)</li>
</ol>
</section>
<section id="exemplo-2-converta-a-fórmula-a-rightarrow-b-land-neg-c-lor-d-para-fnn" class="level4" data-number="6.0.1.2">
<h4 data-number="6.0.1.2" class="anchored" data-anchor-id="exemplo-2-converta-a-fórmula-a-rightarrow-b-land-neg-c-lor-d-para-fnn"><span class="header-section-number">6.0.1.2</span> Exemplo 2: Converta a fórmula <span class="math inline">\((A \rightarrow B) \land \neg (C \lor D)\)</span> Para FNN</h4>
<ol type="1">
<li>Eliminar Implicações: <span class="math inline">\((\neg A \lor B) \land \neg (C \lor D)\)</span>;</li>
<li>Aplicar De Morgan: <span class="math inline">\((\neg A \lor B) \land (\neg C \land \neg D)\)</span>;</li>
<li>Eliminar Dupla Negação: <span class="math inline">\((\neg A \lor B) \land (\neg C \land \neg D)\)</span> (já está na FNN).</li>
</ol>
</section>
</section>
<section id="forma-normal-disjuntiva-fnd" class="level3" data-number="6.0.2">
<h3 data-number="6.0.2" class="anchored" data-anchor-id="forma-normal-disjuntiva-fnd"><span class="header-section-number">6.0.2</span> Forma Normal Disjuntiva (FND)</h3>
<p>A Forma Normal Disjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma disjunção de conjunções. Trata-se uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico.</p>
<p>Uma fórmula está na Forma Normal Disjuntiva se puder ser escrita como:</p>
<p><span class="math display">\[(C_1 \land C_2 \land \ldots) \lor (D_1 \land D_2 \land \ldots) \lor\]</span></p>
<p>Na qual, cada <span class="math inline">\(C_i\)</span> e <span class="math inline">\(D_i\)</span> é um literal. Ou seja, é uma variável ou sua negação. Com um pouco mais de formalidade matemática podemos afirmar que uma <strong>Fórmula Bem Formada</strong> está na Forma Normal Disjuntiva quando está na forma:</p>
<p><span class="math display">\[\bigvee_{i=1}^{m} \left( \bigwedge_{j=1}^{n} L_{ij} \right)\]</span></p>
<p>Converter uma fórmula para a FND geralmente envolve os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar os Bicondicionais</strong>: substitua todas as ocorrências de <span class="math inline">\(A\leftrightarrow B\)</span> Por <span class="math inline">\(A\rightarrow B \wedge B\rightarrow A\)</span>.</p></li>
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \lor B\)</span>.</p></li>
<li><p><strong>Aplicar as Leis de De Morgan</strong>: use as leis de De Morgan para mover as negações para dentro, aplicando:</p>
<ul>
<li><span class="math inline">\(\neg (A \land B) \rightarrow \neg A \lor \neg B\)</span></li>
<li><span class="math inline">\(\neg (A \lor B) \rightarrow \neg A \land \neg B\)</span></li>
</ul></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Substitua qualquer dupla negação <span class="math inline">\(\neg \neg A\)</span> Por <span class="math inline">\(A\)</span>.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong>: Use a lei distributiva para expandir a fórmula, transformando-a em uma disjunção de conjunções.</p></li>
</ol>
<section id="exemplo-1" class="level4" data-number="6.0.2.1">
<h4 data-number="6.0.2.1" class="anchored" data-anchor-id="exemplo-1"><span class="header-section-number">6.0.2.1</span> Exemplo 1</h4>
<p><span class="math display">\[(A \rightarrow B) \land (C \lor \neg (D \land E))\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações</p>
<p><span class="math display">\[(A \rightarrow B) \land (C \lor \neg (D \land E)) \rightarrow (\neg A \lor B) \land (C \lor \neg (D \land E))\]</span></p></li>
<li><p>Aplicar De Morgan</p>
<p><span class="math display">\[(\neg A \lor B) \land (C \lor \neg D \lor \neg E)\]</span></p></li>
<li><p>Distribuir a Disjunção</p>
<p><span class="math display">\[(\neg A \lor B) \land C \lor (\neg A \lor B) \land \neg D \lor (\neg A \lor B) \land \neg E\]</span></p></li>
</ol>
</section>
<section id="exemplo-2" class="level4" data-number="6.0.2.2">
<h4 data-number="6.0.2.2" class="anchored" data-anchor-id="exemplo-2"><span class="header-section-number">6.0.2.2</span> Exemplo 2</h4>
<p><span class="math display">\[(\neg A \land (B \rightarrow C)) \lor (D \land \neg (E \rightarrow F))\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações</p>
<p><span class="math display">\[(\neg A \land (\neg B \lor C)) \lor (D \land \neg (\neg E \lor F)) \rightarrow (\neg A \land (\neg B \lor C)) \lor (D \land (E \land \neg F))\]</span></p></li>
<li><p>Distribuir a Disjunção</p>
<p><span class="math display">\[(\neg A \land \neg B \lor \neg A \land C) \lor (D \land E \land \neg F)\]</span></p></li>
<li><p>Distribuir a Disjunção Novamente</p>
<p><span class="math display">\[\neg A \land \neg B \lor \neg A \land C \lor D \land E \land \neg F\]</span></p></li>
</ol>
</section>
<section id="exemplo-3" class="level4" data-number="6.0.2.3">
<h4 data-number="6.0.2.3" class="anchored" data-anchor-id="exemplo-3"><span class="header-section-number">6.0.2.3</span> Exemplo 3</h4>
<p><span class="math display">\[(p \rightarrow q) \rightarrow (r \vee s)\]</span></p>
<ol type="1">
<li><p>Remover as implicações (<span class="math inline">\(\rightarrow\)</span>):</p>
<p><span class="math display">\[p \rightarrow q \equiv \neg p \vee q\]</span></p></li>
<li><p>Substituir a expressão original com a equivalência encontrada no passo 1:</p>
<p><span class="math display">\[(\neg p \vee q) \rightarrow (r \vee s)\]</span></p></li>
<li><p>Aplicar novamente a equivalência para remover a implicação:</p>
<p><span class="math display">\[\neg (\neg p \vee q) \vee (r \vee s)\]</span></p></li>
<li><p>Aplicar a lei de De Morgan para expandir a negação:</p>
<p><span class="math display">\[(p \wedge \neg q) \vee (r \vee s)\]</span></p></li>
</ol>
</section>
<section id="exemplo-4" class="level4" data-number="6.0.2.4">
<h4 data-number="6.0.2.4" class="anchored" data-anchor-id="exemplo-4"><span class="header-section-number">6.0.2.4</span> Exemplo 4</h4>
<p><span class="math display">\[(p \rightarrow q) \rightarrow (\neg r \vee s)\]</span></p>
<ol type="1">
<li><p>Primeiro, vamos eliminar as implicações, usando a equivalência <span class="math inline">\(p \rightarrow q \equiv \neg p \vee q\)</span>:</p>
<p><span class="math display">\[(p \rightarrow q) \rightarrow (\neg r \vee s)\]</span></p>
<p>Substituindo a implicação interna, temos:</p>
<p><span class="math display">\[(\neg p \vee q) \rightarrow (\neg r \vee s)\]</span></p></li>
<li><p>Agora, vamos eliminar a implicação externa, usando a mesma equivalência:</p>
<p><span class="math display">\[\neg (\neg p \vee q) \vee (\neg r \vee s)\]</span></p></li>
<li><p>Em seguida, aplicamos a lei de De Morgan para expandir a negação:</p>
<p><span class="math display">\[(p \wedge \neg q) \vee (\neg r \vee s)\]</span></p></li>
</ol>
</section>
<section id="exemplo-5" class="level4" data-number="6.0.2.5">
<h4 data-number="6.0.2.5" class="anchored" data-anchor-id="exemplo-5"><span class="header-section-number">6.0.2.5</span> Exemplo 5</h4>
<p><span class="math display">\[\neg(p \land q) \rightarrow (r \leftrightarrow s)\]</span></p>
<p><span class="math display">\[\begin{align*}
\quad 1. &amp; \quad \neg(p \land q) \rightarrow (r \leftrightarrow s) \\
\quad 2. &amp; \quad \neg(p \land q) \rightarrow ((r \rightarrow s) \land (s \rightarrow r)) \, \text{ (Substituindo a equivalência por suas implicações)} \\
\quad 3. &amp; \quad \neg(p \land q) \rightarrow ((\neg r \lor s) \land (\neg s \lor r)) \, \text{ (Convertendo as implicações em disjunções)} \\
\quad 4. &amp; \quad (\neg (p \land q)) \lor ((\neg r \lor s) \land (\neg s \lor r)) \, \text{ (Aplicando a equivalência } p \rightarrow q \equiv \neg p \lor q \text{)} \\
\quad 5. &amp; \quad (\neg p \lor \neg q) \lor ((\neg r \lor s) \land (\neg s \lor r)) \, \text{ (Aplicando a De Morgan em } \neg(p \land q) \text{)} \\
\quad 6. &amp; \quad (\neg p \lor \neg q \lor \neg r \lor s) \land (\neg p \lor \neg q \lor \neg s \lor r) \, \text{ (Aplicando a distributividade para obter a FND)}
\end{align*}\]</span></p>
<p>A Forma Normal Disjuntiva é útil porque qualquer fórmula lógica pode ser representada desta forma, e a representação é única (à exceção da ordem dos literais e cláusulas).</p>
</section>
</section>
<section id="forma-normal-conjuntiva-fnc" class="level3" data-number="6.0.3">
<h3 data-number="6.0.3" class="anchored" data-anchor-id="forma-normal-conjuntiva-fnc"><span class="header-section-number">6.0.3</span> Forma Normal Conjuntiva (FNC)</h3>
<p>A Forma Normal Conjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma conjunção de disjunções. Em outras palavras, é uma expressão lógica na forma de uma <em>conjunção de disjunções</em>. É uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico e simplificação de fórmulas.</p>
<p>Uma fórmula está na Forma Normal Conjuntiva se puder ser expressa na forma:</p>
<p><span class="math display">\[(D_1 \lor D_2 \lor \ldots \lor D_n) \land (E_1 \lor E_2 \lor \ldots \lor E_m) \land \ldots\]</span></p>
<p>Na qual, <span class="math inline">\(D_1, \ldots , D_n\)</span> e $ e_1, ,E_n $ representam átomos. Podemos dizer que a Forma Normal Conjuntiva acontece quando a <strong>Fórmula Bem Formada</strong> está na forma:</p>
<p><span class="math display">\[\bigwedge_{i=1}^{m} \left( \bigvee_{j=1}^{n} L_{ij} \right)\]</span></p>
<p>Converter uma fórmula para a Forma Normal Conjuntiva, já incluindo os conceitos de Skolemização, envolve os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar os Bicondicionais</strong>: substitua todas as ocorrências de <span class="math inline">\(A\leftrightarrow B\)</span> Por <span class="math inline">\(A\rightarrow B \wedge B\rightarrow A\)</span>.</p></li>
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \lor B\)</span>.</p></li>
<li><p><strong>Colocar a Negação no Interior dos parênteses</strong>: Use as leis de De Morgan para mover as negações para dentro, aplicando:</p>
<ul>
<li><span class="math inline">\(\neg (\forall x A) \equiv \exists x \neg A\)</span>;</li>
<li><span class="math inline">\(\neg (\exists x A) \equiv \forall x \neg A\)</span>;</li>
<li><span class="math inline">\(\neg (A \land B) \rightarrow \neg A \lor \neg B\)</span>;</li>
<li><span class="math inline">\(\neg (A \lor B) \rightarrow \neg A \land \neg B\)</span>.</li>
</ul></li>
<li><p><strong>Eliminar Dupla Negação</strong>: Substitua qualquer dupla negação <span class="math inline">\(\neg \neg A\)</span> Por <span class="math inline">\(A\)</span>.</p></li>
<li><p><strong>Skolemização</strong>: todas as variáveis existenciais será substituída por uma Constante de Skolem, ou uma Função de Skolem das variáveis universais relacionadas.</p>
<ul>
<li><span class="math inline">\(\exists x Bonito(x)\)</span> será transformado em <span class="math inline">\(Bonito(g1)\)</span> onde <span class="math inline">\(g1\)</span> é uma Constante de Skolem;</li>
<li><span class="math inline">\(\forall x Pessoa(x) \rightarrow Coração(x) \wedge Feliz(x,y)\)</span> se torna <span class="math inline">\(\forall x Pessoa(x) \rightarrow Coração(H(x))\wedge Feliz(x,H(x))\)</span>, onde <span class="math inline">\(H\)</span> é uma função de Skolem.</li>
</ul></li>
<li><p>Remova todos os Quantificadores Universais. <span class="math inline">\(\forall x Pessoa(x)\)</span> se torna <span class="math inline">\(Pessoa(x)\)</span>.</p></li>
<li><p><strong>Aplicar a Lei Distributiva</strong>: Use a lei distributiva para expandir a fórmula, transformando-a em uma conjunção de disjunções. Substituindo <span class="math inline">\(\wedge\)</span> por <span class="math inline">\(\vee\)</span>.</p></li>
</ol>
<section id="exemplo-1-1" class="level4" data-number="6.0.3.1">
<h4 data-number="6.0.3.1" class="anchored" data-anchor-id="exemplo-1-1"><span class="header-section-number">6.0.3.1</span> Exemplo 1</h4>
<p><span class="math display">\[(A \land B) \rightarrow (C \lor D)\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações*:</p>
<p><span class="math display">\[\neg (A \land B) \lor (C \lor D) \rightarrow (\neg A \lor \neg B) \lor (C \lor D)\]</span></p></li>
<li><p>Distribuir a Disjunção:</p>
<p><span class="math display">\[(\neg A \lor \neg B \lor C \lor D)\]</span></p></li>
</ol>
</section>
<section id="exemplo-2-1" class="level4" data-number="6.0.3.2">
<h4 data-number="6.0.3.2" class="anchored" data-anchor-id="exemplo-2-1"><span class="header-section-number">6.0.3.2</span> Exemplo 2</h4>
<p><span class="math display">\[(A \land \neg B) \lor (\neg C \land D) \rightarrow (E \lor F)\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações:</p>
<p><span class="math display">\[\neg ((A \land \neg B) \lor (\neg C \land D)) \lor (E \lor F) \rightarrow \neg (A \land \neg B) \land \neg (\neg C \land D) \lor (E \lor F)\]</span></p></li>
<li><p>Aplicar De Morgan:</p>
<p><span class="math display">\[(\neg A \lor B) \land (C \lor \neg D) \lor (E \lor F)\]</span></p></li>
<li><p>Distribuir a Disjunção:</p>
<p><span class="math display">\[(\neg A \lor B \lor E \lor F) \land (C \lor \neg D \lor E \lor F)\]</span></p></li>
</ol>
</section>
<section id="exemplo-3-1" class="level4" data-number="6.0.3.3">
<h4 data-number="6.0.3.3" class="anchored" data-anchor-id="exemplo-3-1"><span class="header-section-number">6.0.3.3</span> Exemplo 3</h4>
<p><span class="math display">\[(p \wedge (q \vee r)) \vee (\neg p \wedge \neg q)\]</span></p>
<ol type="1">
<li><p>Aplicar a lei distributiva (<span class="math inline">\(\wedge\)</span> sobre <span class="math inline">\(\vee\)</span>) no primeiro termo para obter uma Forma Normal Disjuntiva (FND) da expressão:</p>
<p><span class="math display">\[(p \wedge q) \vee (p \wedge r) \vee (\neg p \wedge \neg q)\]</span></p></li>
<li><p>Aplicar a lei distributiva (<span class="math inline">\(\vee\)</span> sobre <span class="math inline">\(\wedge\)</span>) para transformar a FND em uma conjunção de disjunções.</p>
<p>A expressão <span class="math inline">\(( (p \wedge q) \vee (p \wedge r) ) \vee (\neg p \wedge \neg q)\)</span> pode ser reescrita como:</p>
<p><span class="math display">\[((p \wedge q) \vee (p \wedge r) \vee \neg p) \wedge ((p \wedge q) \vee (p \wedge r) \vee \neg q)\]</span></p>
<p>Simplificando cada um dos termos principais da conjunção:</p>
<ul>
<li><p>O primeiro termo, <span class="math inline">\(((p \wedge q) \vee (p \wedge r) \vee \neg p)\)</span>, simplifica para:</p>
<p><span class="math display">\[(\neg p \vee q \vee r)\]</span></p></li>
<li><p>O segundo termo, <span class="math inline">\(((p \wedge q) \vee (p \wedge r) \vee \neg q)\)</span>, simplifica para:</p>
<p><span class="math display">\[(p \vee \neg q)\]</span></p></li>
</ul></li>
<li><p>Finalmente a Forma Normal Conjuntiva (FNC):</p>
<p><span class="math display">\[(\neg p \vee q \vee r) \wedge (p \vee \neg q)\]</span></p></li>
</ol>
</section>
<section id="exemplo-4-1" class="level4" data-number="6.0.3.4">
<h4 data-number="6.0.3.4" class="anchored" data-anchor-id="exemplo-4-1"><span class="header-section-number">6.0.3.4</span> Exemplo 4</h4>
<p><span class="math display">\[ \neg ((p \wedge q) \vee \neg (r \wedge s))\]</span></p>
<ol type="1">
<li><p>Aplicando a Lei de De Morgan na expressão inteira:</p>
<p><span class="math display">\[
\begin{align*}
\neg ((p \wedge q) \vee \neg (r \wedge s)) &amp;\equiv \neg (p \wedge q) \wedge (r \wedge s) \quad \text{(Lei de De Morgan)}
\end{align*}
\]</span></p></li>
<li><p>aplicando a Lei de De Morgan nos termos internos:</p>
<p><span class="math display">\[
\begin{align*}
\neg (p \wedge q) \wedge (r \wedge s) &amp;\equiv (\neg p \vee \neg q) \wedge (r \wedge s) \quad \text{(Lei de De Morgan)}
\end{align*}
\]</span></p></li>
</ol>
</section>
<section id="exemplo-5-1" class="level4" data-number="6.0.3.5">
<h4 data-number="6.0.3.5" class="anchored" data-anchor-id="exemplo-5-1"><span class="header-section-number">6.0.3.5</span> Exemplo 5</h4>
<p><span class="math display">\[\neg (((p \rightarrow q) \rightarrow p) \rightarrow p)\]</span></p>
<ol type="1">
<li><p>Eliminar Implicações. Utilizando a equivalência $p q p q $:</p>
<p><span class="math display">\[\neg(\neg(\neg p \lor q)\lor p)\lor p\]</span></p></li>
<li><p>Aplicar Leis de De Morgan:</p>
<p><span class="math display">\[((p \land \neg q) \lor p) \land \neg p\]</span></p></li>
<li><p>Simplificamos a expressão usando propriedades como <span class="math inline">\(p \lor p \equiv p\)</span> e, em seguida, redistribuímos os termos para alcançar a Forma Normal Conjuntiva:</p>
<p><span class="math display">\[(p \land (\neg q \lor p)) \land \neg p\]</span></p></li>
<li><p>Aplicamos as propriedades comutativa e associativa para organizar os termos de uma forma mais apresentável:</p>
<p><span class="math display">\[(\neg q \lor p) \land (p \land \neg p)\]</span></p></li>
<li><p>Identificamos e simplificamos contradições na expressão usando <span class="math inline">\(p \land \neg p \equiv \bot\)</span>, levando a:</p>
<p><span class="math display">\[(\neg q \lor p) \land \bot\]</span></p></li>
<li><p>Por último, aplicamos a identidade com a contradição $<span class="math inline">\(\bot \land p \equiv \bot\)</span> para obter a expressão final:</p>
<p><span class="math display">\[\bot \text{False}\]</span></p></li>
</ol>
</section>
<section id="exemplo-6" class="level4" data-number="6.0.3.6">
<h4 data-number="6.0.3.6" class="anchored" data-anchor-id="exemplo-6"><span class="header-section-number">6.0.3.6</span> Exemplo 6</h4>
<p><span class="math display">\[(p \rightarrow q) \leftrightarrow (p \rightarrow r)\]</span></p>
<ol type="1">
<li><p>Começamos pela definição de equivalência e implicação:</p>
<p><span class="math display">\[(p \rightarrow q) \leftrightarrow (p \rightarrow r)\]</span></p></li>
<li><p>Aplicamos as definições de implicação:</p>
<p><span class="math display">\[(\neg p \lor q) \leftrightarrow (\neg p \lor r)\]</span></p></li>
<li><p>Agora, aplicamos a definição de equivalência, transformando-a em uma conjunção de duas implicações:</p>
<p><span class="math display">\[((\neg p \lor q) \rightarrow (\neg p \lor r)) \land ((\neg p \lor r) \rightarrow (\neg p \lor q))\]</span></p></li>
<li><p>Em seguida, aplicamos a definição de implicação novamente para cada uma das implicações internas:</p>
<p><span class="math display">\[(\neg (\neg p \lor q) \lor (\neg p \lor r)) \land (\neg (\neg p \lor r) \lor (\neg p \lor q))\]</span></p></li>
<li><p>Vamos aplicar a lei de De Morgan e a lei da dupla negação para simplificar a expressão:</p>
<p><span class="math display">\[((p \land \neg q) \lor (\neg p \lor r)) \land ((p \land \neg r) \lor (\neg p \lor q))\]</span></p></li>
<li><p>Aplicando a lei distributiva para desenvolver cada conjunção interna em disjunções:</p>
<p><span class="math display">\[((p \lor (\neg p \lor r)) \land (\neg q \lor (\neg p \lor r))) \land ((p \lor (\neg p \lor q)) \land (\neg r \lor (\neg p \lor q)))\]</span></p></li>
</ol>
<p>A aplicação das equivalências não é, nem de longe, a única forma de percorrer a rota da conversão de uma <strong>Fórmula Bem Formada</strong> em Forma Normal Conjuntiva.</p>
</section>
</section>
<section id="forma-normal-prenex" class="level3" data-number="6.0.4">
<h3 data-number="6.0.4" class="anchored" data-anchor-id="forma-normal-prenex"><span class="header-section-number">6.0.4</span> Forma Normal Prenex</h3>
<p>A Forma Normal Prenex é uma padronização para fórmulas da lógica de primeiro grau. Nela, todos os quantificadores são deslocados para a frente da fórmula, deixando a matriz da fórmula livre de quantificadores. A Forma Normal Prenex é vantajosa por três razões fundamentais:</p>
<ol type="1">
<li><p><strong>Facilitação da Manipulação Lógica</strong>: ao separar os quantificadores da matriz, a Forma Normal Prenex simplifica a análise e manipulação da estrutura lógica da fórmula;</p></li>
<li><p><strong>Preparação para Outras Formas Normais</strong>: Serve como uma etapa intermediária valiosa na conversão para outras formas normais, como as Forma Normal Conjuntiva e Forma Normal Disjuntiva;</p></li>
<li><p><strong>Uso em Provas Automáticas</strong>: é amplamente empregada em métodos de prova automática, tornando o raciocínio sobre quantificadores mais acessível.</p></li>
</ol>
<p>Considere o seguinte exemplo, partindo da fórmula original: <span class="math inline">\(\exists x \forall y (P(x,y) \wedge Q(y))\)</span></p>
<p>Na Forma Prenex, esta fórmula será representada:</p>
<p><span class="math display">\[\forall y \exists x (P(x,y) \wedge Q(y))\]</span></p>
<p>Uma fórmula na Forma Normal Prenex segue uma estrutura específica definida por:</p>
<p><span class="math display">\[Q_1 x_1 \, Q_2 x_2 \, \ldots \, Q_n x_n \, M(x_1, x_2, \ldots, x_n)\]</span></p>
<p>Nessa estrutura:</p>
<ul>
<li><span class="math inline">\(Q_i\)</span> são quantificadores, podendo ser universais <span class="math inline">\(\forall\)</span> ou existenciais <span class="math inline">\(\exists\)</span>;</li>
<li><span class="math inline">\(x_i\)</span> são as variáveis vinculadas pelos quantificadores;</li>
<li><span class="math inline">\(M(x_1, x_2, \ldots, x_n)\)</span> representa a matriz da fórmula, uma expressão lógica sem quantificadores.</li>
</ul>
<p>Converter uma fórmula para a Forma Normal Prenex envolve os seguintes passos:</p>
<ol type="1">
<li><p><strong>Eliminar Implicações</strong>: substitua todas as ocorrências de implicação por disjunções e negações;</p></li>
<li><p><strong>Mover Negações para Dentro</strong>: use as leis de De Morgan para mover as negações para dentro dos quantificadores e proposições;</p></li>
<li><p><strong>Padronizar Variáveis</strong>: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas;</p></li>
<li><p><strong>Eliminar Quantificadores Existenciais</strong>: substitua os quantificadores existenciais por constantes ou funções Skolem, dependendo do contexto;</p></li>
<li><p><strong>Mover Quantificadores para Fora</strong>: mova todos os quantificadores para a esquerda da expressão, mantendo a ordem relativa dos quantificadores universais e existenciais.</p></li>
</ol>
<p>A Forma Normal Prenex é uma representação canônica de fórmulas da lógica de primeiro grau que separa claramente os quantificadores da matriz da fórmula. Ela é uma ferramenta valiosa na lógica e na teoria da prova, e sua compreensão é fundamental para trabalhar com lógica de primeiro grau.</p>
<section id="regras-de-equivalência-prenex" class="level4" data-number="6.0.4.1">
<h4 data-number="6.0.4.1" class="anchored" data-anchor-id="regras-de-equivalência-prenex"><span class="header-section-number">6.0.4.1</span> Regras de Equivalência Prenex</h4>
<p>A Forma Prenex de uma fórmula lógica com quantificadores permite mover todos os quantificadores para o início da fórmula. Existem algumas regras de equivalência que preservam a Forma Prenex quando aplicadas a uma fórmula:</p>
<p><strong>1. Comutatividade de quantificadores do mesmo tipo</strong>: a ordem dos quantificadores do mesmo tipo pode ser trocada em uma fórmula na Forma Prenex. Por exemplo:</p>
<p><span class="math display">\[\forall x \forall y \ P(x,y) \Leftrightarrow \forall y \forall x \ P(x,y)\]</span></p>
<p>Isso ocorre porque a ordem dos quantificadores universais <span class="math inline">\(\forall x\)</span> e <span class="math inline">\(\forall y\)</span> não altera o significado lógico da fórmula. Essa propriedade é conhecida como comutatividade dos quantificadores.</p>
<p><strong>2. Associatividade de quantificadores do mesmo tipo</strong>: quantificadores do mesmo tipo podem ser agrupados de forma associativa em uma Forma Prenex. Por exemplo:</p>
<p><span class="math display">\[\forall x \forall y \forall z \ P(x,y,z) \Leftrightarrow \forall x (\forall y \forall z \ P(x,y,z))\]</span></p>
<p>Novamente, o agrupamento dos quantificadores universais não muda o significado da fórmula. Essa é a propriedade associativa.</p>
<p><strong>3. Distributividade de quantificadores sobre operadores lógicos</strong>: os quantificadores podem ser distribuídos sobre operadores lógicos como <span class="math inline">\(\wedge, \vee, \rightarrow\)</span>:</p>
<p><span class="math display">\[\forall x (P(x) \vee Q(x)) \Leftrightarrow (\forall x \ P(x)) \vee (\forall x \ Q(x))\]</span></p>
<p>Isso permite mover o quantificador para dentro do escopo do operador lógico. A equivalência se mantém pois a ordem de quantificação e operação não se altera.</p>
</section>
<section id="conversão-para-formas-normais-conjuntiva-fnc-e-disjuntiva-fnd" class="level4" data-number="6.0.4.2">
<h4 data-number="6.0.4.2" class="anchored" data-anchor-id="conversão-para-formas-normais-conjuntiva-fnc-e-disjuntiva-fnd"><span class="header-section-number">6.0.4.2</span> Conversão para Formas Normais Conjuntiva (FNC) e Disjuntiva (FND)</h4>
<p><strong>1. Eliminar Implicações</strong>: substitua todas as ocorrências de implicação da forma <span class="math inline">\(A \rightarrow B\)</span> Por <span class="math inline">\(\neg A \lor B\)</span>.</p>
<p><strong>2. Mover a Negação para Dentro</strong>: use as leis de De Morgan para mover a negação para dentro dos quantificadores e das proposições. Aplique as seguintes transformações:</p>
<ul>
<li><span class="math inline">\(\neg \forall x P(x) \rightarrow \exists x \neg P(x)\)</span></li>
<li><span class="math inline">\(\neg \exists x P(x) \rightarrow \forall x \neg P(x)\)</span></li>
</ul>
<p><strong>3. Padronizar Variáveis</strong>: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas, renomeando-as se necessário.</p>
<p><strong>4. Eliminar os Quantificadores Existenciais</strong>: substitua cada quantificador existencial <span class="math inline">\(\exists x\)</span> Por um novo termo constante ou Função Skolem, dependendo das variáveis livres em seu escopo. Para eliminar os quantificadores existenciais, é necessário introduzir novos termos: Constantes ou Funções Skolem.</p>
<ol type="1">
<li><p><strong>Se o quantificador existencial não tem quantificadores universais à sua esquerda</strong>: Substitua <span class="math inline">\(\exists x P(x)\)</span> Por <span class="math inline">\(P(c)\)</span>, sendo que <span class="math inline">\(c\)</span> é uma nova constante.</p></li>
<li><p><strong>Se o quantificador existencial tem quantificadores universais à sua esquerda</strong>: Substitua <span class="math inline">\(\exists x P(x)\)</span> Por <span class="math inline">\(P(f(y_1, y_2, \ldots, y_n))\)</span>, sendo que <span class="math inline">\(f\)</span> é uma nova função Skolem, e <span class="math inline">\(y_1, y_2, \ldots, y_n\)</span> são as variáveis universais à esquerda do quantificador existencial.</p></li>
</ol>
<p><strong>5. Mover os Quantificadores Universais para Fora</strong>: mova todos os quantificadores universais para fora, para a esquerda da expressão. Isso cria uma Forma Prenex da fórmula.</p>
<p><strong>6. Eliminar os Quantificadores Universais</strong>: remova os quantificadores universais, deixando apenas a matriz da fórmula. Isso resulta em uma fórmula livre de quantificadores. Após a eliminação dos quantificadores existenciais e a movimentação de todos os quantificadores universais para fora (Forma Prenex), a eliminação dos quantificadores universais é simples:</p>
<ol type="1">
<li><p><strong>Remova os quantificadores universais da fórmula</strong>: Se você tem uma fórmula da forma <span class="math inline">\(\forall x P(x)\)</span>, simplesmente remova o quantificador <span class="math inline">\(\forall x\)</span>, deixando apenas a matriz da fórmula <span class="math inline">\(P(x)\)</span>.</p></li>
<li><p><strong>Trate as variáveis como variáveis livres</strong>: As variáveis que eram ligadas pelo quantificador universal agora são tratadas como variáveis livres na matriz da fórmula.</p></li>
</ol>
<p><strong>7. Conversão para FNC</strong>:</p>
<ol type="1">
<li>Use as leis distributivas para mover as conjunções para dentro e as disjunções para fora.</li>
<li>Certifique-se de que a fórmula esteja na forma de uma conjunção de disjunções (cláusulas).</li>
</ol>
<p><strong>8. Conversão para FND</strong>:</p>
<ol type="1">
<li>Use as leis distributivas para mover as disjunções para dentro e as conjunções para fora.</li>
<li>Certifique-se de que a fórmula esteja na forma de uma disjunção de conjunções.</li>
</ol>
</section>
<section id="exemplo-1---duas-fórmulas-logicamente-equivalentes" class="level4" data-number="6.0.4.3">
<h4 data-number="6.0.4.3" class="anchored" data-anchor-id="exemplo-1---duas-fórmulas-logicamente-equivalentes"><span class="header-section-number">6.0.4.3</span> Exemplo 1 - Duas fórmulas logicamente equivalentes</h4>
<p>Vamos considerar duas fórmulas logicamente equivalentes, uma na Forma Prenex e outra não considere a fórmula original:</p>
<p><span class="math display">\[\forall x \exists y (P(x) \rightarrow Q(y))\]</span></p>
<p>Se convertida para a Forma Prenex teremos:</p>
<p><span class="math display">\[\exists y \forall x (P(x) \rightarrow Q(y))\]</span></p>
<p>Cuja a equivalência pode ser provada por meio do seguinte raciocínio: seja <span class="math inline">\(I\)</span> uma interpretação booleana das variáveis <span class="math inline">\(P\)</span> e <span class="math inline">\(Q\)</span>. Suponha <span class="math inline">\(I\)</span> satisfaz <span class="math inline">\(\forall x \exists y (P(x) \rightarrow Q(y))\)</span>. Logo, para todo <span class="math inline">\(x\)</span> no domínio, existe um <span class="math inline">\(y\)</span> tal que: se <span class="math inline">\(P(x)\)</span> é verdadeiro, então <span class="math inline">\(Q(y)\)</span> também é verdadeiro. Isso é equivalente a dizer: existe um <span class="math inline">\(y\)</span>, tal que para todo <span class="math inline">\(x\)</span>, se <span class="math inline">\(P(x)\)</span> é verdadeiro, <span class="math inline">\(Q(y)\)</span> também é verdadeiro. Ou seja, <span class="math inline">\(I\)</span> também satisfaz: <span class="math inline">\(\exists y \forall x (P(x) \rightarrow Q(y))\)</span>. Por um raciocínio simétrico, o oposto também é verdadeiro. Portanto, as fórmulas são logicamente equivalentes.</p>
</section>
<section id="exemplo-2---fórmula-sem-forma-prenex" class="level4" data-number="6.0.4.4">
<h4 data-number="6.0.4.4" class="anchored" data-anchor-id="exemplo-2---fórmula-sem-forma-prenex"><span class="header-section-number">6.0.4.4</span> Exemplo 2 - Fórmula sem Forma Prenex</h4>
<p><span class="math display">\[\forall x (P(x) \rightarrow \exists y Q(x,y))\]</span></p>
<p>Não pode ser convertida à Forma Prenex pois o quantificador <span class="math inline">\(\exists y\)</span> está dentro do escopo de de uma implicação (<span class="math inline">\(\rightarrow\)</span>).</p>
<blockquote class="blockquote">
<p>A conversão para Forma Normal Conjuntiva é útil para métodos de prova. A conversão para Forma Normal Disjuntiva é menos comum, mas pode ser útil em alguns contextos de análise lógica. <strong>CUIDADO: a eliminação dos quantificadores pode alterar a interpretação da fórmula em alguns modelos, mas é útil porque preserva a satisfatibilidade</strong>.</p>
</blockquote>
</section>
</section>
<section id="usando-a-tabela-verdade-para-gerar-formas-normais" class="level3" data-number="6.0.5">
<h3 data-number="6.0.5" class="anchored" data-anchor-id="usando-a-tabela-verdade-para-gerar-formas-normais"><span class="header-section-number">6.0.5</span> Usando a Tabela-Verdade para Gerar Formas Normais</h3>
<p>Em meio à precisão rígida da lógica proposicional, a tabela verdade surge como nossa bússola fiel. Com ela, discernimos, sem rodeios, os caminhos para as Formas Normais Conjuntiva e Disjuntiva. Cortamos através da névoa de possibilidades, fixando nosso olhar nas linhas nítidas em que a verdade ou a falsidade se manifestam. Encaramos, então, a fórmula que se descortina diante de nós.</p>
<p>Considere a <strong>Fórmula Bem Formada</strong> dada por: <span class="math inline">\((A \lor B) \rightarrow (C \land \neg A)\)</span>, se encontrarmos sua Tabela Verdade, podemos encontrar, tanto a Forma Normal Conjuntiva quanto a Forma Normal Disjuntiva. Bastando fixar nosso olhar na verdade, ou na falsidade.</p>
<section id="gerando-a-forma-normal-disjuntiva" class="level4" data-number="6.0.5.1">
<h4 data-number="6.0.5.1" class="anchored" data-anchor-id="gerando-a-forma-normal-disjuntiva"><span class="header-section-number">6.0.5.1</span> Gerando a Forma Normal Disjuntiva</h4>
<p>Para transformar <span class="math inline">\((A \lor B) \rightarrow (C \land \neg A)\)</span> na sua Forma Normal Conjuntiva, como um cozinheiro de bordo, devemos seguir rigidamente, os seguintes passos:</p>
<ol type="1">
<li><p>Criar a Tabela-Verdade</p>
<p><span class="math display">\[
\begin{array}{cccc|c|c|c}
A &amp; B &amp; C &amp; \neg A &amp; A \lor B &amp; C \land \neg A &amp; (A \lor B) \rightarrow (C \land \neg A) \\
\hline
T &amp; T &amp; T &amp; F &amp; T &amp; F &amp; F \\
T &amp; T &amp; F &amp; F &amp; T &amp; F &amp; F \\
T &amp; F &amp; T &amp; F &amp; T &amp; F &amp; F \\
T &amp; F &amp; F &amp; F &amp; T &amp; F &amp; F \\
F &amp; T &amp; T &amp; T &amp; T &amp; T &amp; T \\
F &amp; T &amp; F &amp; T &amp; T &amp; F &amp; F \\
F &amp; F &amp; T &amp; T &amp; F &amp; T &amp; T \\
F &amp; F &amp; F &amp; T &amp; F &amp; T &amp; T \\
\end{array}
\]</span></p></li>
<li><p>Identificar as Linhas com Resultado Verdadeiro</p>
<p>As linhas 5, 7 e 8 têm resultado verdadeiro.</p></li>
<li><p>Construir a FND usando as linhas com resultados verdadeiros:</p></li>
</ol>
<p>Neste passo, nosso objetivo é construir uma expressão que seja verdadeira nas linhas 5, 7 e 8 (as linhas nas quais o resultado é verdadeiro), e falsa em todos os outros casos. Para fazer isso, criamos uma disjunção (uma expressão <em>OR</em>) para cada linha verdadeira que reflete as condições das variáveis nesta linha, e então unimos essas disjunções com uma conjunção (uma operação <strong>AND</strong>) para criar a Forma Normal Disjuntiva desejada:</p>
<ol type="a">
<li><p><strong>Primeiro Termo Correspondente a Linha 5: <span class="math inline">\((\neg A \land B \land C)\)</span></strong> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é verdadeiro e <span class="math inline">\(C\)</span> é verdadeiro, o que corresponde à linha 5 da tabela.</p></li>
<li><p><strong>Segundo Termo Correspondente a Linha 7: <span class="math inline">\((\neg A \land \neg B \land C)\)</span></strong> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é falso e <span class="math inline">\(C\)</span> é verdadeiro, o que corresponde à linha 7 da tabela.</p></li>
<li><p><strong>Terceiro Correspondente a Linha 8: <span class="math inline">\((\neg A \land \neg B \land \neg C)\)</span></strong> Este termo é verdadeiro quando <span class="math inline">\(A\)</span> é falso, <span class="math inline">\(B\)</span> é falso e <span class="math inline">\(C\)</span> é falso, o que corresponde à linha 8 da tabela.</p></li>
</ol>
<p>Finalmente, unimos estes termos com operações OR (<span class="math inline">\(\lor\)</span>) para criar a expressão FND completa:</p>
<p><span class="math display">\[
(A \lor B) \rightarrow (C \land \neg A) = (\neg A \land B \land C) \lor (\neg A \land \neg B \land C) \lor (\neg A \land \neg B \land \neg C)
\]</span></p>
<p>A expressão acima será verdadeira se qualquer um dos termos (ou seja, qualquer uma das linhas 5, 7 ou 8 da tabela) for verdadeiro, garantindo que a expressão capture exatamente as condições em que <span class="math inline">\((A \lor B) \rightarrow (C \land \neg A)\)</span> é verdadeira de acordo com a tabela-verdade.</p>
</section>
<section id="gerando-a-forma-normal-conjuntiva" class="level4" data-number="6.0.5.2">
<h4 data-number="6.0.5.2" class="anchored" data-anchor-id="gerando-a-forma-normal-conjuntiva"><span class="header-section-number">6.0.5.2</span> Gerando a Forma Normal Conjuntiva</h4>
<p>Partindo da mesma tabela verdade da expressão <span class="math inline">\((A \lor B) \rightarrow (C \land \neg A)\)</span>, nossa bússola nesta fase da jornada, precisaremos voltar nosso olhar cuidadoso para as linhas com resultado falso e então teremos:</p>
<ol type="1">
<li><p>Identificar as Linhas com Resultado Falso</p>
<p>As linhas <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, <span class="math inline">\(3\)</span>, <span class="math inline">\(4\)</span> e <span class="math inline">\(6\)</span> têm resultado falso.</p></li>
<li><p>Construir a Forma Normal Conjuntiva: para cada linha falsa, criaremos uma disjunção que represente a negação da linha e as combinaremos com uma conjunção. Como um pescador que cria uma rede entrelaçando fios com nós. A construção dos termos disjuntivos considerará as variáveis que tornam a fórmula falsa na respectiva linha da Tabela verdade:</p>
<ul>
<li>Linha 1: <span class="math inline">\((\neg A \lor \neg B \lor \neg C \lor A)\)</span>;</li>
<li>Linha 2: <span class="math inline">\((\neg A \lor \neg B \lor C \lor A)\)</span>;</li>
<li>Linha 3: <span class="math inline">\((\neg A \lor B \lor \neg C \lor A)\)</span>;</li>
<li>Linha 4: <span class="math inline">\((\neg A \lor B \lor C \lor A)\)</span>;</li>
<li>Linha 6: <span class="math inline">\((A \lor \neg B \lor C \lor \neg A)\)</span>.</li>
</ul>
<p>Combinando-os com uma conjunção, temos a Forma Normal Conjuntiva:</p>
<p><span class="math display">\[
\begin{align*}
(A \lor B) \rightarrow (C \land \neg A) &amp;\equiv (\neg A \lor \neg B \lor \neg C \lor A) \\
&amp;\land (\neg A \lor \neg B \lor C \lor A) \\
&amp;\land (\neg A \lor B \lor \neg C \lor A) \\
&amp;\land (\neg A \lor B \lor C \lor A) \\
&amp;\land (A \lor \neg B \lor C \lor \neg A)
\end{align*}
\]</span></p></li>
</ol>
<p>Lamentavelmente, as tabelas verdade não têm utilidade na <strong>Lógica de Primeira Ordem</strong> quando usamos predicados e quantificadores. Skolemização e Forma Normal Prenex são as rotas que precisaremos dominar para desvendar esse enigma.</p>
</section>
</section>
<section id="skolemização" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="skolemização"><span class="header-section-number">6.1</span> Skolemização</h2>
<p>A Skolemização é uma técnica usada na <strong>Lógica de Primeira Ordem</strong> para eliminar quantificadores existenciais em fórmulas. Consiste em substituir as variáveis existenciais por Constantes ou Funções Skolem. Considere a fórmula a seguir com um quantificador universal e um existencial:</p>
<p><span class="math display">\[\forall x \exists y P(x,y)\]</span></p>
<p>Ao aplicar a Skolemização, a variável existencial <span class="math inline">\(y\)</span> é substituída por uma Função de Skolem <span class="math inline">\(f(x)\)</span>:</p>
<p><span class="math display">\[P(x,f(x))\]</span></p>
<p>Para uma fórmula com dois quantificadores universais e dois existenciais:</p>
<p><span class="math display">\[\forall x \forall z \exists y \exists w R(x,y,z,w)\]</span></p>
<p>A Skolemização resultará em:</p>
<p><span class="math display">\[\forall x \forall z R(x,f(x),z,g(x,z))\]</span></p>
<p><span class="math inline">\(f(x)\)</span> e $ g(x,z)$ são Funções Skolem introduzidas para substituir as variáveis existenciais <span class="math inline">\(y\)</span> e $w $ respectivamente. A escolha entre usar uma Constante Skolem ou uma Função Skolem durante a Skolemização depende do escopo dos quantificadores na fórmula original. Aqui estão as regras e passos para realizar a Skolemização de forma mais explicativa:</p>
<p><strong>Passo 1: Identificar os Quantificadores Existenciais</strong>: comece identificando os quantificadores existenciais na fórmula.</p>
<p><strong>Passo 2: Determinar se a Variável Existencial Depende de Variáveis Universais</strong>: para cada variável ligada a um quantificador existencial, determinamos se ela depende ou não de alguma variável universal. Isso significa verificar se existem quantificadores universais que <em>dominam</em> a variável existencial. Se a variável existencial não depende de variáveis universais, usamos uma Constante de Skolem. Caso contrário, usamos uma Função de Skolem que leva como parâmetros as variáveis universais que a dominam.</p>
<p><strong>Passo 3: Substituir as Variáveis Existenciais</strong>: agora, substituímos todas as variáveis existenciais na fórmula original de acordo com as decisões tomadas no Passo 2. Se usarmos Constantes de Skolem, substituímos as variáveis existenciais diretamente pelas constantes. Se usarmos Funções de Skolem, substituímos as variáveis existenciais pelas funções de Skolem aplicadas às variáveis universais apropriadas.</p>
<p><strong>Exemplo 1</strong>: considere a <strong>Fórmula Bem Formada</strong> dada por: <span class="math inline">\(\forall x \exists y \ P(x,y)\)</span></p>
<ol type="1">
<li><p>Identificamos o quantificador existencial que introduz a variável <span class="math inline">\(y\)</span>.</p></li>
<li><p>A variável <span class="math inline">\(y\)</span> não depende de nenhuma variável universal, então usamos uma Constante de Skolem, digamos <span class="math inline">\(a\)</span>. A fórmula se torna:</p>
<p><span class="math display">\[\forall x \ P(x,a)\]</span></p></li>
</ol>
<p><strong>Exemplo 2</strong>: considere a fórmula original: <span class="math inline">\(\forall x \forall z \exists y \ Q(x,y,z)\)</span></p>
<ol type="1">
<li><p>Identificamos o quantificador existencial que introduz a variável <span class="math inline">\(y\)</span>.</p></li>
<li><p>A variável <span class="math inline">\(y\)</span> depende de duas variáveis universais, <span class="math inline">\(x\)</span> e <span class="math inline">\(z\)</span>. Portanto, usamos uma Função de Skolem, digamos <span class="math inline">\(f(x,z)\)</span>. A fórmula se torna:</p>
<p><span class="math display">\[\forall x \forall z \ Q(x,f(x,z),z)\]</span></p></li>
</ol>
<p>Substituímos <span class="math inline">\(y\)</span> por <span class="math inline">\(f(x,z)\)</span>, que é uma função que depende das variáveis universais <span class="math inline">\(x\)</span> e <span class="math inline">\(z\)</span>.</p>
<p>Em resumo, a Skolemização simplifica fórmulas quantificadas, eliminando quantificadores existenciais e substituindo variáveis por Constantes ou Funções de Skolem, dependendo de sua relação com quantificadores universais. Isso auxilia na conversão de fórmulas quantificadas para a Forma Normal Conjuntiva e na simplificação da lógica.</p>
<section id="exemplos-de-conversão-em-formas-normais-conjuntiva-e-disjuntiva" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="exemplos-de-conversão-em-formas-normais-conjuntiva-e-disjuntiva"><span class="header-section-number">6.1.1</span> Exemplos de conversão em formas normais, conjuntiva e disjuntiva</h3>
<ol type="a">
<li>Todos os alunos estudam ou alguns professores ensinam matemática</li>
</ol>
<p><strong>Lógica de Primeiro Grau</strong>:</p>
<p><span class="math display">\[\forall x(\text{Aluno}(x) \rightarrow \text{Estuda}(x)) \lor \exists y(\text{Professor}(y) \land \text{EnsinaMatemática}(y))\]</span></p>
<p><strong>Forma Normal Conjuntiva (FNC)</strong>:</p>
<ol type="1">
<li><p>Convertendo a implicação:</p>
<p><span class="math display">\[\neg \text{Aluno}(x) \lor \text{Estuda}(x)\]</span></p></li>
<li><p>Adicionando a disjunção existencial:</p>
<p><span class="math display">\[(\neg \text{Aluno}(x) \lor \text{Estuda}(x)) \land (\text{Professor}(y) \land \text{EnsinaMatemática}(y))\]</span></p></li>
</ol>
<p><strong>Forma Normal Disjuntiva (FND)</strong>:</p>
<ol type="1">
<li><p>Negando o consequente do implicador:</p>
<p><span class="math display">\[\text{Aluno}(x) \land \neg \text{Estuda}(x)\]</span></p></li>
<li><p>Adicionando a conjunção existencial negada:</p>
<p><span class="math display">\[(\text{Aluno}(x) \land \neg \text{Estuda}(x)) \lor (\neg \text{Professor}(y) \lor \neg \text{EnsinaMatemática}(y))\]</span></p></li>
</ol>
<ol start="2" type="a">
<li>Algum aluno estuda e todo professor ensina</li>
</ol>
<p><strong>Lógica de Primeiro Grau</strong>:</p>
<p><span class="math display">\[\exists x(\text{Aluno}(x) \land \text{Estuda}(x)) \land \forall y(\text{Professor}(y) \rightarrow \text{Ensina}(y))\]</span></p>
<p><strong>Forma Normal Conjuntiva (FNC)</strong>:</p>
<ol type="1">
<li><p>Convertendo a implicação:</p>
<p><span class="math display">\[\neg \text{Professor}(y) \lor \text{Ensina}(y)\]</span></p></li>
<li><p>Adicionando a conjunção existencial:</p>
<p><span class="math display">\[(\text{Aluno}(x) \land \text{Estuda}(x)) \land (\neg \text{Professor}(y) \lor \text{Ensina}(y))\]</span></p></li>
</ol>
<p><strong>Forma Normal Disjuntiva (FND)</strong>:</p>
<ol type="1">
<li><p>Negando a conjunção existencial:</p>
<p><span class="math display">\[\neg \text{Aluno}(x) \lor \neg \text{Estuda}(x)\]</span></p></li>
<li><p>Adicionando a conjunção negada do consequente do implicador:</p>
<p><span class="math display">\[(\neg \text{Aluno}(x) \lor \neg \text{Estuda}(x)) \lor (\text{Professor}(y) \land \neg \text{Ensina}(y))\]</span></p></li>
</ol>
<ol start="3" type="a">
<li>Todo estudante é inteligente ou algum professor é sábio</li>
</ol>
<p><strong>Lógica de Primeiro Grau</strong>:</p>
<p><span class="math display">\[\forall x(\text{Estudante}(x) \rightarrow \text{Inteligente}(x)) \lor \exists y(\text{Professor}(y) \land \text{Sábio}(y))\]</span></p>
<p><strong>Forma Normal Conjuntiva (FNC)</strong>:</p>
<ol type="1">
<li><p>Convertendo a implicação:</p>
<p><span class="math display">\[\neg \text{Estudante}(x) \lor \text{Inteligente}(x)\]</span></p></li>
<li><p>Adicionando a disjunção existencial:</p>
<p><span class="math display">\[(\neg \text{Estudante}(x) \lor \text{Inteligente}(x)) \land (\text{Professor}(y) \land \text{Sábio}(y))\]</span></p></li>
</ol>
<p><strong>Forma Normal Disjuntiva (FND)</strong>:</p>
<ol type="1">
<li><p>Negando o consequente do implicador:</p>
<p><span class="math display">\[\text{Estudante}(x) \land \neg \text{Inteligente}(x)\]</span></p></li>
<li><p>Adicionando a conjunção existencial negada:</p>
<p><span class="math display">\[(\text{Estudante}(x) \land \neg \text{Inteligente}(x)) \lor (\neg \text{Professor}(y) \lor \neg \text{Sábio}(y))\]</span></p></li>
</ol>
<ol start="4" type="a">
<li>Todo animal corre ou algum pássaro voa</li>
</ol>
<p><strong>Lógica de Primeiro Grau</strong>:</p>
<p><span class="math display">\[\forall x(\text{Animal}(x) \rightarrow \text{Corre}(x)) \lor \exists y(\text{Pássaro}(y) \land \text{Voa}(y))\]</span></p>
<p><strong>Forma Normal Conjuntiva (FNC)</strong>:</p>
<ol type="1">
<li><p>Convertendo a implicação:</p>
<p><span class="math display">\[\neg \text{Animal}(x) \lor \text{Corre}(x)\]</span></p></li>
<li><p>Adicionando a disjunção existencial:</p>
<p><span class="math display">\[(\neg \text{Animal}(x) \lor \text{Corre}(x)) \land (\text{Pássaro}(y) \land \text{Voa}(y))\]</span></p></li>
</ol>
<p><strong>Forma Normal Disjuntiva (FND)</strong>:</p>
<ol type="1">
<li><p>Negando o consequente do implicador:</p>
<p><span class="math display">\[\text{Animal}(x) \land \neg \text{Corre}(x)\]</span></p></li>
<li><p>Adicionando a conjunção existencial negada:</p>
<p><span class="math display">\[(\text{Animal}(x) \land \neg \text{Corre}(x)) \lor (\neg \text{Pássaro}(y) \lor \neg \text{Voa}(y))\]</span></p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./04-logica-predicativa-e-quantificadores.html" class="pagination-link" aria-label="Lógica Predicativa">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Lógica Predicativa</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./06-construcao-de-mundos-logicos.html" class="pagination-link" aria-label="Mundos na **Lógica de Primeira Ordem**">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Mundos na <strong>Lógica de Primeira Ordem</strong></span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/05-formas-normais-e-skolemizacao.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>