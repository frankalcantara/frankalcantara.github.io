<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 11&nbsp; Desvendando o Processo de Inferência do Prolog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./08-verificacao-formal-de-programas.html" rel="next">
<link href="./07a-criando-mundos-praticas.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./07b-inferencia-prolog.html"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Desvendando o Processo de Inferência do Prolog</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução ao Paradigma da Programação Lógica</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-introducao-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introdução Prática ao Prolog com Swish</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Proposicional</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">A Arte da Prova e Análise de Argumentos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais: Estruturas de Solução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Formas Clausais e A Cláusula de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Raciocínio Algorítmico: Criando Mundos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07a-criando-mundos-praticas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Criando Mundos: Práticas 2025</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07b-inferencia-prolog.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Desvendando o Processo de Inferência do Prolog</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Desafios, Problemas e Mistérios</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Solução dos Exercícios</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-Sol-Proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Lógica Proposicional </span></span></a><a href="02-fundamentos-logica-proposicional.html" class="quarto-xref"><span>Chapter 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-Sol-Predicativa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Lógica Predicativa </span></span></a><a href="04-logica-predicativa-e-quantificadores.html" class="quarto-xref"><span>Chapter 6</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-Sol-Normais.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Formas Normais Proposicionais </span></span></a><a href="05-formas-normais-e-skolemizacao.html" class="quarto-xref"><span>Chapter 7</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#a-arquitetura-de-um-programa-prolog-a-base-de-conhecimento" id="toc-a-arquitetura-de-um-programa-prolog-a-base-de-conhecimento" class="nav-link active" data-scroll-target="#a-arquitetura-de-um-programa-prolog-a-base-de-conhecimento"><span class="header-section-number">11.1</span> A Arquitetura de um Programa Prolog: A Base de Conhecimento</a>
  <ul class="collapse">
  <li><a href="#termos-os-dados-do-prolog" id="toc-termos-os-dados-do-prolog" class="nav-link" data-scroll-target="#termos-os-dados-do-prolog"><span class="header-section-number">11.1.1</span> Termos: Os Dados do Prolog</a></li>
  <li><a href="#cláusulas-a-lógica-do-prolog" id="toc-cláusulas-a-lógica-do-prolog" class="nav-link" data-scroll-target="#cláusulas-a-lógica-do-prolog"><span class="header-section-number">11.1.2</span> Cláusulas: A Lógica do Prolog</a></li>
  <li><a href="#consultas-interrogando-a-base-de-conhecimento" id="toc-consultas-interrogando-a-base-de-conhecimento" class="nav-link" data-scroll-target="#consultas-interrogando-a-base-de-conhecimento"><span class="header-section-number">11.1.3</span> Consultas: Interrogando a Base de Conhecimento</a></li>
  <li><a href="#a-hipótese-do-mundo-fechado-o-que-não-pode-ser-provado-é-falso" id="toc-a-hipótese-do-mundo-fechado-o-que-não-pode-ser-provado-é-falso" class="nav-link" data-scroll-target="#a-hipótese-do-mundo-fechado-o-que-não-pode-ser-provado-é-falso"><span class="header-section-number">11.1.4</span> A Hipótese do Mundo Fechado: O que Não Pode Ser Provado é Falso</a></li>
  </ul></li>
  <li><a href="#o-coração-do-mecanismo-de-inferência-unificação" id="toc-o-coração-do-mecanismo-de-inferência-unificação" class="nav-link" data-scroll-target="#o-coração-do-mecanismo-de-inferência-unificação"><span class="header-section-number">11.2</span> O Coração do mecanismo de inferência: Unificação</a>
  <ul class="collapse">
  <li><a href="#o-algoritmo-de-unificação" id="toc-o-algoritmo-de-unificação" class="nav-link" data-scroll-target="#o-algoritmo-de-unificação"><span class="header-section-number">11.2.1</span> O Algoritmo de Unificação</a></li>
  <li><a href="#o-unificador-mais-geral-mgu" id="toc-o-unificador-mais-geral-mgu" class="nav-link" data-scroll-target="#o-unificador-mais-geral-mgu"><span class="header-section-number">11.2.2</span> O Unificador Mais Geral (MGU)</a></li>
  <li><a href="#o-occurs-check-uma-omissão-pragmática" id="toc-o-occurs-check-uma-omissão-pragmática" class="nav-link" data-scroll-target="#o-occurs-check-uma-omissão-pragmática"><span class="header-section-number">11.2.3</span> O <em>Occurs Check</em>: Uma Omissão Pragmática</a></li>
  </ul></li>
  <li><a href="#o-mecanismo-de-inferência-lógico-resolução-sld" id="toc-o-mecanismo-de-inferência-lógico-resolução-sld" class="nav-link" data-scroll-target="#o-mecanismo-de-inferência-lógico-resolução-sld"><span class="header-section-number">11.3</span> O mecanismo de inferência Lógico: Resolução SLD</a>
  <ul class="collapse">
  <li><a href="#navegando-no-espaço-de-soluções-busca-em-profundidade-e-backtracking" id="toc-navegando-no-espaço-de-soluções-busca-em-profundidade-e-backtracking" class="nav-link" data-scroll-target="#navegando-no-espaço-de-soluções-busca-em-profundidade-e-backtracking"><span class="header-section-number">11.3.1</span> Navegando no Espaço de Soluções: Busca em Profundidade e Backtracking</a></li>
  <li><a href="#exemplo-em-prolog" id="toc-exemplo-em-prolog" class="nav-link" data-scroll-target="#exemplo-em-prolog"><span class="header-section-number">11.3.2</span> Exemplo em Prolog</a></li>
  <li><a href="#a-estratégia-de-busca-do-prolog-transversalidade-em-profundidade" id="toc-a-estratégia-de-busca-do-prolog-transversalidade-em-profundidade" class="nav-link" data-scroll-target="#a-estratégia-de-busca-do-prolog-transversalidade-em-profundidade"><span class="header-section-number">11.3.3</span> A Estratégia de Busca do Prolog: transversalidade em Profundidade</a></li>
  </ul></li>
  <li><a href="#estruturas-de-dados-como-uma-lente-para-a-mecânica-do-prolog" id="toc-estruturas-de-dados-como-uma-lente-para-a-mecânica-do-prolog" class="nav-link" data-scroll-target="#estruturas-de-dados-como-uma-lente-para-a-mecânica-do-prolog"><span class="header-section-number">11.4</span> Estruturas de Dados como uma Lente para a Mecânica do Prolog</a>
  <ul class="collapse">
  <li><a href="#a-estrutura-de-dados-fundamental-listas-em-prolog" id="toc-a-estrutura-de-dados-fundamental-listas-em-prolog" class="nav-link" data-scroll-target="#a-estrutura-de-dados-fundamental-listas-em-prolog"><span class="header-section-number">11.4.1</span> A Estrutura de Dados Fundamental: Listas em Prolog</a></li>
  <li><a href="#a-pilha-um-ajuste-natural-para-as-listas-do-prolog" id="toc-a-pilha-um-ajuste-natural-para-as-listas-do-prolog" class="nav-link" data-scroll-target="#a-pilha-um-ajuste-natural-para-as-listas-do-prolog"><span class="header-section-number">11.4.2</span> A Pilha: Um Ajuste Natural para as Listas do Prolog</a></li>
  <li><a href="#a-fila-o-desafio-do-primeiro-a-entrar" id="toc-a-fila-o-desafio-do-primeiro-a-entrar" class="nav-link" data-scroll-target="#a-fila-o-desafio-do-primeiro-a-entrar"><span class="header-section-number">11.4.3</span> A Fila: O Desafio do “Primeiro a Entrar”</a></li>
  <li><a href="#árvores-de-busca-binária-unificação-em-estruturas-recursivas" id="toc-árvores-de-busca-binária-unificação-em-estruturas-recursivas" class="nav-link" data-scroll-target="#árvores-de-busca-binária-unificação-em-estruturas-recursivas"><span class="header-section-number">11.4.4</span> Árvores de Busca Binária: Unificação em Estruturas Recursivas</a></li>
  </ul></li>
  <li><a href="#controle-manual-da-busca-o-operador-de-corte" id="toc-controle-manual-da-busca-o-operador-de-corte" class="nav-link" data-scroll-target="#controle-manual-da-busca-o-operador-de-corte"><span class="header-section-number">11.5</span> Controle Manual da Busca: O Operador de Corte (<code>!</code>)</a>
  <ul class="collapse">
  <li><a href="#cortes-verdes-poda-para-eficiência" id="toc-cortes-verdes-poda-para-eficiência" class="nav-link" data-scroll-target="#cortes-verdes-poda-para-eficiência"><span class="header-section-number">11.5.1</span> Cortes Verdes: Poda para Eficiência</a></li>
  <li><a href="#cortes-vermelhos-alterando-a-lógica" id="toc-cortes-vermelhos-alterando-a-lógica" class="nav-link" data-scroll-target="#cortes-vermelhos-alterando-a-lógica"><span class="header-section-number">11.5.2</span> Cortes Vermelhos: Alterando a Lógica</a></li>
  <li><a href="#caso-de-uso-comum-negação-como-falha" id="toc-caso-de-uso-comum-negação-como-falha" class="nav-link" data-scroll-target="#caso-de-uso-comum-negação-como-falha"><span class="header-section-number">11.5.3</span> Caso de Uso Comum: Negação como Falha</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/07b-inferencia-prolog.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./07b-inferencia-prolog.html"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Desvendando o Processo de Inferência do Prolog</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Desvendando o Processo de Inferência do Prolog</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\07b-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>O Prolog, <em>Programming in Logic</em>, representa uma mudança de paradigma em relação às linguagens de programação imperativas. Em vez de fornecer ao computador uma sequência de instruções sobre <em>como</em> executar uma tarefa, um programa em Prolog consiste numa especificação declarativa do que <em>é verdade</em> sobre um determinado domínio. Um programa em Prolog é, em essência, uma especificação executável de um subconjunto da <strong>Lógica de Primeira Ordem</strong>, permitindo que os programadores se concentrem na descrição da lógica e das relações do problema, enquanto o <em>mecanismo de inferência</em> subjacente se encarrega da estratégia de execução.</p>
<p>A mágica por trás da surpresa que a atenta leitora teve ao perceber a capacidade do Prolog de responder a perguntas complexas e encontrar soluções para problemas lógicos não é arbitrária. Pelo contrário, esta estupefação é o resultado direto da observação da parte visível de uma interação sistemática e bem definida de três processos distintos que formam o seu mecanismo de inferência. O primeiro é um algoritmo de correspondência de padrões chamado <strong>Unificação</strong>, que serve como a operação computacional primária. O segundo é um procedimento de prova formal conhecido como <strong>Resolução SLD</strong>, que fornece a base lógica para a inferência. O terceiro é uma estratégia de busca determinística, a <strong>Busca em Profundidade (<em>Depth-First Search</em>)</strong>, implementada através de um mecanismo robusto de tentativa e erro chamado <strong><em>Backtracking</em></strong>.</p>
<section id="a-arquitetura-de-um-programa-prolog-a-base-de-conhecimento" class="level2" data-number="11.1">
<h2 data-number="11.1" class="anchored" data-anchor-id="a-arquitetura-de-um-programa-prolog-a-base-de-conhecimento"><span class="header-section-number">11.1</span> A Arquitetura de um Programa Prolog: A Base de Conhecimento</h2>
<p>Todos os programas Prolog são estruturados a partir da sua <strong>base de conhecimento</strong>, <em>knowledge base</em>, um repositório estruturado de asserções lógicas que descrevem um domínio específico. Esta arquitetura impõe uma separação rigorosa entre os dados (fatos), a lógica (regras) e o controle (o mecanismo de inferência), que é a pedra angular do paradigma declarativo que suporta o Prolog. O texto do programa não é uma sequência de instruções, mas sim uma declaração estática de verdades. <em>Executar</em> um programa é, na verdade, o ato de submeter uma consulta a base de conhecimento.</p>
<p>Tudo começa com fatos, o equivalente aos dados brutos.</p>
<section id="termos-os-dados-do-prolog" class="level3" data-number="11.1.1">
<h3 data-number="11.1.1" class="anchored" data-anchor-id="termos-os-dados-do-prolog"><span class="header-section-number">11.1.1</span> Termos: Os Dados do Prolog</h3>
<p>Em Prolog, toda a representação de dados é feita através de uma única estrutura: o <strong>termo</strong>. Não existem tipos de dados distintos no sentido convencional; tudo, desde um simples número a uma árvore complexa, é um termo. Assim, temos:</p>
<ul>
<li><strong>Átomos</strong>: são constantes que representam objetos, propriedades ou relações específicas. Sintaticamente, os átomos devem começar com uma letra minúscula, como <code>socrates</code>, <code>gosta</code> ou <code>vermelho</code>;</li>
<li><strong>Números</strong>: literais numéricos, como inteiros e números de ponto flutuante;</li>
<li><strong>Variáveis</strong>: representam espaços reservados para termos que ainda não são conhecidos. São sintaticamente distintas por começarem com uma letra maiúscula ou um sublinhado (_), como <code>X</code>, <code>Pessoa</code> ou <code>\_Nome</code>. A variável anônima, representada apenas por _, é um marcador especial que indica <em>não me importo com este valor</em>.</li>
<li><strong>Estruturas (Termos Compostos)</strong>: são o principal meio de criar dados complexos. Uma estrutura consiste em um <strong>functor</strong>, um átomo que nomeia a estrutura, e um número de <strong>argumentos</strong>, que são, por sua vez, outros termos. A notação é <code>functor(arg1, arg2,...)</code>. Por exemplo, <code>ponto(3, 4)</code> representa um ponto no plano cartesiano, e <code>pai(joao, maria)</code> representa uma relação de paternidade.</li>
</ul>
</section>
<section id="cláusulas-a-lógica-do-prolog" class="level3" data-number="11.1.2">
<h3 data-number="11.1.2" class="anchored" data-anchor-id="cláusulas-a-lógica-do-prolog"><span class="header-section-number">11.1.2</span> Cláusulas: A Lógica do Prolog</h3>
<p>As cláusulas constituem as unidades fundamentais de conhecimento em um programa Prolog. Elas são sentenças lógicas que codificam tanto conhecimento factual quanto inferencial sobre um domínio específico. Um conjunto de cláusulas com o mesmo functor e aridade (número de argumentos) define um <strong>predicado</strong>, que representa uma relação ou propriedade no domínio modelado.</p>
<section id="fatos-conhecimento-incondicional" class="level4" data-number="11.1.2.1">
<h4 data-number="11.1.2.1" class="anchored" data-anchor-id="fatos-conhecimento-incondicional"><span class="header-section-number">11.1.2.1</span> Fatos: Conhecimento Incondicional</h4>
<p><strong>Fatos</strong> são cláusulas unitárias que declaram verdades incondicionais, axiomas, sobre o domínio. Sintaticamente, um fato consiste em um predicado seguido de seus argumentos, terminado por um ponto final. Na terminologia da lógica de primeira ordem, os fatos correspondem a <strong>cláusulas de Horn unitárias</strong> da forma <span class="math inline">\(P(t_1, t_2, \cdots, t_n)\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Predicados unários - propriedades de objetos</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>mortal(socrates)<span class="kw">.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>mamifero(gato)<span class="kw">.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>ave(canario)<span class="kw">.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">% Predicados binários - relações entre objetos</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>pai(joao<span class="kw">,</span> pedro)<span class="kw">.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>maior_que(<span class="dv">5</span><span class="kw">,</span> <span class="dv">3</span>)<span class="kw">.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>capital(brasil<span class="kw">,</span> brasilia)<span class="kw">.</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">% Predicados n-ários - relações complexas</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>distancia(sao_paulo<span class="kw">,</span> rio_janeiro<span class="kw">,</span> <span class="dv">400</span>)<span class="kw">.</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>nasceu(socrates<span class="kw">,</span> atenas<span class="kw">,</span> <span class="dv">470</span>)<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Interpretação formal</strong>: Cada fato <code>P(a1, ..., an)</code> é interpretado como <em>é verdadeiro que <code>P(a1, ..., an)</code></em> no modelo mínimo de Herbrand que constitui a semântica do programa Prolog.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>O <strong>modelo mínimo de Herbrand</strong> é o alicerce matemático que fornece significado preciso aos programas Prolog. Para compreender esta construção formal, precisamos decompor três conceitos fundamentais que se entrelaçam para formar a semântica denotacional da linguagem.</p>
<ol type="1">
<li><p><strong>O Universo de Herbrand</strong>: o domínio sintático dos termos possíveis. O <strong>universo de Herbrand</strong> <span class="math inline">\(H_U\)</span> de um programa Prolog é o conjunto de todos os termos <em>ground</em> (sem variáveis) que podem ser construídos a partir dos símbolos presentes no programa. É o domínio sintático sobre o qual operamos.</p>
<p>Para um programa com átomos <code>socrates</code>, <code>atenas</code> e o functor <code>nasceu/3</code>, temos: <span class="math inline">\(H_U = \{socrates, atenas, nasceu(socrates, atenas, 470), nasceu(socrates, socrates, socrates), ...\}\)</span></p>
<p>Este universo é potencialmente infinito quando functors estão presentes, pois podemos construir termos arbitrariamente aninhados.</p></li>
<li><p><strong>A Base de Herbrand</strong>: todas as Afirmações Possíveis. A <strong>base de Herbrand</strong> <span class="math inline">\(H_B\)</span> consiste em todos os átomos <em>ground</em> possíveis que podem ser formados aplicando os predicados do programa aos elementos do universo de Herbrand.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Programa exemplo</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>mortal(socrates)<span class="kw">.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>grego(<span class="dt">X</span>) <span class="kw">:-</span> nasceu(<span class="dt">X</span><span class="kw">,</span> atenas<span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Para este programa, teremos: <span class="math inline">\(H_B = \{mortal(socrates), mortal(atenas), grego(socrates), grego(atenas), nasceu(socrates, atenas, 470), ...\}\)</span></p></li>
<li><p><strong>Interpretações e o Modelo Mínimo</strong>: uma <strong>interpretação de Herbrand</strong> é qualquer subconjunto da base de Herbrand. Ela especifica quais átomos <em>ground</em> são considerados verdadeiros, aqueles que estão presentes no subconjunto, e quais são falsos, os ausentes.</p>
<p>Um <strong>modelo de Herbrand</strong> é uma interpretação que satisfaz todas as cláusulas do programa. O <strong>modelo mínimo de Herbrand</strong> <span class="math inline">\(M_H\)</span> é o menor modelo possível, a interseção de todos os modelos de Herbrand do programa.</p></li>
</ol>
<p>O modelo mínimo pode ser construído através do <strong>operador de consequência imediata</strong> <span class="math inline">\(T_P\)</span>:</p>
<ol type="1">
<li><strong>Passo inicial</strong>: <span class="math inline">\(M_0 = \emptyset\)</span>;</li>
<li><strong>Aplicação iterativa</strong>: <span class="math inline">\(M_{i+1} = T_P(M_i)\)</span>, onde <span class="math inline">\(T_P\)</span> adiciona todos os átomos que podem ser derivados em um passo de inferência;</li>
<li><strong>Ponto fixo</strong>: <span class="math inline">\(M_H = M_n\)</span> quando <span class="math inline">\(M_{n+1} = M_n\)</span>.</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Base de conhecimento</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pai(joao<span class="kw">,</span> pedro)<span class="kw">.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>avo(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span> pai(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span> pai(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">% Construção do modelo mínimo:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">% M₀ = ∅</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">% M₁ = {pai(joao, pedro)}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">% M₂ = {pai(joao, pedro)}  % Ponto fixo alcançado</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">% MH = {pai(joao, pedro)}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Significado para o Prolog</strong>: quando dizemos que um fato <code>P(a₁, ..., aₙ)</code> é verdadeiro <em>no modelo mínimo de Herbrand</em>, estamos afirmando que:</p>
<ol type="1">
<li><strong>Semântica Declarativa</strong>: este átomo <em>ground</em> pertence ao menor conjunto de verdades que satisfaz logicamente o programa;</li>
<li><strong>Semântica Operacional</strong>: este fato pode ser derivado através da aplicação finita das regras do programa;</li>
<li><strong>Hipótese do Mundo Fechado</strong>: tudo que <strong>não</strong> está no modelo mínimo é considerado falso.</li>
</ol>
<p>Esta correspondência entre a semântica declarativa, modelo mínimo, e a semântica operacional, o que pode ser provado via <strong>Resolução SLD</strong>, é o que torna o Prolog uma implementação executável da lógica de primeira ordem restrita às cláusulas de Horn. O modelo mínimo de Herbrand é, portanto, a interpretação canônica que captura exatamente o conhecimento codificado no programa, nem mais, nem menos.</p>
</div>
</div>
</section>
<section id="regras-conhecimento-condicional" class="level4" data-number="11.1.2.2">
<h4 data-number="11.1.2.2" class="anchored" data-anchor-id="regras-conhecimento-condicional"><span class="header-section-number">11.1.2.2</span> Regras: Conhecimento Condicional</h4>
<p><strong>Regras</strong> são cláusulas que estabelecem verdades condicionais através de implicações lógicas. Uma regra consiste em uma <strong>cabeça</strong>, <em>head</em>, que representa a conclusão, e um <strong>corpo</strong>, <em>body</em>, que especifica as condições que devem ser satisfeitas. A cabeça e o corpo são conectados pelo operador <code>:-</code>, que se lê como <em>se</em> ou <em>é verdadeiro se</em>.</p>
<p>Na lógica de primeira ordem, as regras correspondem a <strong>cláusulas de Horn definidas</strong> da forma <span class="math inline">\(H \leftarrow B_1 \land B_2 \land ... \land B_n\)</span>, na qual <span class="math inline">\(H\)</span> é a cabeça e <span class="math inline">\(B_i\)</span> são os literais do corpo.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Regra simples: ∀X (mamifero(X) → animal(X))</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>animal(<span class="dt">X</span>) <span class="kw">:-</span> mamifero(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">% Regra com múltiplas condições</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>pode_voar(<span class="dt">X</span>) <span class="kw">:-</span> </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    ave(<span class="dt">X</span>)<span class="kw">,</span> </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">\+</span> pinguim(<span class="dt">X</span>)<span class="kw">,</span> </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">\+</span> avestruz(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">% Regra recursiva para definir ancestralidade</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>ancestral(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span> pai(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>ancestral(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span> pai(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span> ancestral(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Semântica operacional</strong>: para provar a cabeça <span class="math inline">\(H\)</span> de uma regra, o mecanismo de inferência deve provar todos os objetivos <span class="math inline">\(B_i\)</span> do corpo. A conjunção no corpo é representada por vírgulas, criando uma cadeia de condições que devem ser satisfeitas sequencialmente.</p>
</section>
<section id="estrutura-lógica-e-quantificação" class="level4" data-number="11.1.2.3">
<h4 data-number="11.1.2.3" class="anchored" data-anchor-id="estrutura-lógica-e-quantificação"><span class="header-section-number">11.1.2.3</span> Estrutura Lógica e Quantificação</h4>
<p>As variáveis em regras Prolog são <strong>universalmente quantificadas</strong> de forma implícita. A regra <code>animal(X) :- mamifero(X)</code> deve ser lida como <em>Para todo <code>X</code>, <code>X</code> é um animal se <code>X</code> é um mamífero</em>, ou formalmente: <span class="math inline">\(\forall X (mamifero(X) \rightarrow animal(X))\)</span>. O uso do quantificador universal é fundamental para compreender como as regras se aplicam a múltiplas instâncias durante o processo de inferência:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Base de conhecimento</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>mamifero(gato)<span class="kw">.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>mamifero(cachorro)<span class="kw">.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>mamifero(baleia)<span class="kw">.</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>animal(<span class="dt">X</span>) <span class="kw">:-</span> mamifero(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">% A regra se aplica a todas as instâncias</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> animal(gato)<span class="kw">.</span>    <span class="co">% true - pela regra e pelo fato mamifero(gato)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> animal(cachorro)<span class="kw">.</span> <span class="co">% true - pela regra e pelo fato mamifero(cachorro)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> animal(baleia)<span class="kw">.</span>  <span class="co">% true - pela regra e pelo fato mamifero(baleia)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="disjunção-através-de-múltiplas-cláusulas" class="level4" data-number="11.1.2.4">
<h4 data-number="11.1.2.4" class="anchored" data-anchor-id="disjunção-através-de-múltiplas-cláusulas"><span class="header-section-number">11.1.2.4</span> Disjunção através de Múltiplas Cláusulas</h4>
<p>O Prolog não possui um operador para criar disjunção entre cláusulas completas. Em vez disso, a disjunção no nível das cláusulas é expressa através de <strong>múltiplas cláusulas</strong> com a mesma cabeça:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Disjunção implícita: ∀X (voa(X) ← ave(X) ∨ inseto_voador(X))</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>voa(<span class="dt">X</span>) <span class="kw">:-</span> ave(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>voa(<span class="dt">X</span>) <span class="kw">:-</span> inseto_voador(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">% NOTA: O operador ; existe em Prolog, mas opera dentro do corpo:</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">% voa(X) :- (ave(X) ; inseto_voador(X)). % Disjunção no corpo</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">% Isso é diferente de ter múltiplas cláusulas, embora semanticamente similar</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Prestou a atenção? eu disse: semanticamente similar. Isto quer dizer que o sentido é o mesmo, mas a forma como o Prolog processa é diferente. A disjunção no corpo de uma única cláusula é tratada como uma escolha entre alternativas durante a prova do corpo, enquanto múltiplas cláusulas são tratadas como alternativas independentes para provar a cabeça. A abordagem de múltiplas cláusulas é preferível porque:</p>
<ol type="1">
<li>cada caminho alternativo é claramente separado e visível;</li>
<li>permite que o mecanismo de <em>backtracking</em> explore sistematicamente todas as alternativas;</li>
<li>facilita a compreensão do fluxo de controle do programa;</li>
<li>cada cláusula pode ter seu próprio corpo complexo sem necessidade de parênteses adicionais.</li>
</ol>
</section>
</section>
<section id="consultas-interrogando-a-base-de-conhecimento" class="level3" data-number="11.1.3">
<h3 data-number="11.1.3" class="anchored" data-anchor-id="consultas-interrogando-a-base-de-conhecimento"><span class="header-section-number">11.1.3</span> Consultas: Interrogando a Base de Conhecimento</h3>
<p>As <strong>consultas</strong>, <em>queries</em>, são o mecanismo através do qual fazemos perguntas à base de conhecimento Prolog. Representam objetivos, <em>goals</em>, que submetemos ao mecanismo de inferência para determinar se podem ser provados verdadeiros com base nos fatos e regras disponíveis.</p>
<section id="natureza-formal-das-consultas" class="level4" data-number="11.1.3.1">
<h4 data-number="11.1.3.1" class="anchored" data-anchor-id="natureza-formal-das-consultas"><span class="header-section-number">11.1.3.1</span> Natureza Formal das Consultas</h4>
<p>Na teoria lógica subjacente, as consultas correspondem a <strong>cláusulas de Horn negativas</strong> da forma <span class="math inline">\(\leftarrow B_1 \land B_2 \land ... \land B_n\)</span>. O mecanismo de inferência tenta encontrar uma <strong>refutação</strong> da negação da consulta, implementando uma estratégia de prova por contradição.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Consulta simples (objetivo atômico)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> mamifero(gato)<span class="kw">.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">% Consulta conjuntiva (múltiplos objetivos)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span> mae(<span class="dt">Z</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">% Consulta com estruturas complexas</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pessoa(nome(joao<span class="kw">,</span> silva)<span class="kw">,</span> idade(<span class="dv">25</span>))<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="quantificação-existencial-em-consultas" class="level4" data-number="11.1.3.2">
<h4 data-number="11.1.3.2" class="anchored" data-anchor-id="quantificação-existencial-em-consultas"><span class="header-section-number">11.1.3.2</span> Quantificação Existencial em Consultas</h4>
<p>Ao contrário das regras, nas quais as variáveis são universalmente quantificadas, nas consultas as variáveis livres são <strong>existencialmente quantificadas</strong>. A consulta <code>?- pai(joao, X).</code> deve ser interpretada como <em>Existe algum X tal que joao é pai de X?</em>, ou formalmente: <span class="math inline">\(\exists X \, pai(joao, X)\)</span>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Base de conhecimento</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>pai(joao<span class="kw">,</span> pedro)<span class="kw">.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>pai(joao<span class="kw">,</span> maria)<span class="kw">.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>pai(carlos<span class="kw">,</span> ana)<span class="kw">.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">% Consulta existencial</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(joao<span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">% Interpretação: ∃X pai(joao, X)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">% Respostas: X = pedro; X = maria</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="tipos-de-consultas-e-suas-interpretações" class="level4" data-number="11.1.3.3">
<h4 data-number="11.1.3.3" class="anchored" data-anchor-id="tipos-de-consultas-e-suas-interpretações"><span class="header-section-number">11.1.3.3</span> Tipos de Consultas e Suas Interpretações</h4>
<ol type="1">
<li><strong>Consultas <em>Ground</em> (Sem Variáveis)</strong>: perguntam sobre a veracidade de um fato específico.</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(joao<span class="kw">,</span> pedro)<span class="kw">.</span>   <span class="co">% true/false</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> mamifero(peixe)<span class="kw">.</span>    <span class="co">% false (pela Hipótese do Mundo Fechado)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><strong>Consultas com Variáveis Livres</strong>: solicitam instanciações que tornam a afirmação verdadeira.</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(<span class="dt">X</span><span class="kw">,</span> pedro)<span class="kw">.</span>      <span class="co">% Quem é pai de Pedro?</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">% X = joao</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(joao<span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span>       <span class="co">% De quem João é pai?</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">% Y = pedro; Y = maria</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li><strong>Consultas Conjuntivas</strong>: especificam múltiplas condições que devem ser satisfeitas simultaneamente.</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span> mae(<span class="dt">Z</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span> <span class="co">% Encontrar X, Y, Z onde X é pai de Y e Z é mãe de Y</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> mamifero(<span class="dt">X</span>)<span class="kw">,</span> voa(<span class="dt">X</span>)<span class="kw">.</span> <span class="co">% Encontrar mamíferos que voam</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="o-processo-de-resolução-de-consultas" class="level4" data-number="11.1.3.4">
<h4 data-number="11.1.3.4" class="anchored" data-anchor-id="o-processo-de-resolução-de-consultas"><span class="header-section-number">11.1.3.4</span> O Processo de Resolução de Consultas</h4>
<p>Quando uma consulta é submetida, o mecanismo de inferência inicia um processo sistemático:</p>
<ol type="1">
<li><p><strong>Decomposição</strong>: se a consulta contém múltiplos objetivos, eles são tratados como uma conjunção que deve ser satisfeita integralmente;</p></li>
<li><p><strong>Busca por Correspondência</strong>: para cada objetivo, o sistema busca cláusulas na base de conhecimento cuja cabeça possa unificar com o objetivo;</p></li>
<li><p><strong>Aplicação de Regras</strong>: se uma regra é encontrada, o objetivo original é substituído pelos objetivos do corpo da regra;</p></li>
<li><p><strong>Construção de Provas</strong>: o processo continua recursivamente até que todos os objetivos sejam resolvidos por fatos ou até que uma falha seja encontrada.</p></li>
</ol>
<div class="sourceCode" id="cb12"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Exemplo de rastreamento de consulta</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">% Base: animal(X) :- mamifero(X).</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">% mamifero(gato).</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">% Consulta: ?- animal(gato).</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">% Passo 1: Unifica animal(gato) com animal(X) :- mamifero(X)</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">% Passo 2: Novo objetivo: mamifero(gato)</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">% Passo 3: Unifica mamifero(gato) com fato mamifero(gato)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">% Resultado: true</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="respostas-e-substituições" class="level5" data-number="11.1.3.4.1">
<h5 data-number="11.1.3.4.1" class="anchored" data-anchor-id="respostas-e-substituições"><span class="header-section-number">11.1.3.4.1</span> Respostas e Substituições</h5>
<p>As respostas do Prolog a uma consulta não são simplesmente <em>verdadeiro</em> ou <em>falso</em>. Quando variáveis estão presentes, as respostas incluem as <strong>substituições</strong>, instanciações de variáveis, que tornam a consulta verdadeira. Estas substituições são, formalmente, os <strong>unificadores mais gerais</strong> encontrados durante o processo de prova.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pessoa(nome(<span class="dt">X</span><span class="kw">,</span> silva)<span class="kw">,</span> profissao(<span class="dt">Y</span>))<span class="kw">.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">% Se existir: pessoa(nome(joao, silva), profissao(engenheiro)).</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">% Resposta: X = joao, Y = engenheiro</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span> avo(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">% Encontra todas as combinações onde X é pai de Y e avô de Z</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">% Resposta múltipla com diferentes instanciações de X, Y, Z</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Este mecanismo de substituições é o que permite ao Prolog funcionar tanto como um sistema de prova de teoremas quanto como uma linguagem de programação, oferecendo respostas construtivas que não apenas confirmam a existência de soluções, mas também fornecem os valores específicos que as constituem.</p>
</section>
</section>
</section>
<section id="a-hipótese-do-mundo-fechado-o-que-não-pode-ser-provado-é-falso" class="level3" data-number="11.1.4">
<h3 data-number="11.1.4" class="anchored" data-anchor-id="a-hipótese-do-mundo-fechado-o-que-não-pode-ser-provado-é-falso"><span class="header-section-number">11.1.4</span> A Hipótese do Mundo Fechado: O que Não Pode Ser Provado é Falso</h3>
<p>Um dos princípios fundamentais que governa o comportamento do Prolog é a <strong>Hipótese do Mundo Fechado</strong>, em inglês: _<strong>C</strong>losed <strong>W</strong>orld <strong>A</strong>ssumption*, <strong>CWA</strong>, uma suposição central na teoria do conhecimento subjacente, que tem implicações profundas sobre como o sistema interpreta a ausência de informação</p>
<p><strong>Na lógica clássica, a ausência de uma afirmação sobre um fato não nos permite concluir nada sobre a sua veracidade</strong>. Se não sabemos que <em>Sócrates é mortal</em>, não podemos inferir nem que ele é mortal nem que não é mortal. Simplesmente não temos informação suficiente. Esta é a abordagem do <strong>mundo aberto</strong>, a ignorância não implica falsidade.</p>
<p>O Prolog, no entanto, adota a hipótese contrária: <strong>tudo o que não pode ser provado verdadeiro a partir da base de conhecimento é assumido como </strong>falso<strong>. Esta é a essência da Hipótese do Mundo Fechado</strong>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Base de conhecimento</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>ave(canario)<span class="kw">.</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>ave(papagaio)<span class="kw">.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>voa(canario)<span class="kw">.</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">% Consultas demonstrando a CWA</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> ave(canario)<span class="kw">.</span>   <span class="co">% true - pode ser provado</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> ave(cachorro)<span class="kw">.</span>  <span class="co">% false - não pode ser provado, logo é falso</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> voa(papagaio)<span class="kw">.</span>  <span class="co">% false - não pode ser provado, logo é falso</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="consequências-práticas-da-cwa" class="level4" data-number="11.1.4.1">
<h4 data-number="11.1.4.1" class="anchored" data-anchor-id="consequências-práticas-da-cwa"><span class="header-section-number">11.1.4.1</span> Consequências Práticas da CWA</h4>
<p>A aplicação da <strong>CWA</strong> permite que o Prolog tome decisões definitivas mesmo na ausência de informação explícita, tornando o sistema <strong>completo</strong> para o seu domínio de conhecimento. Isto tem várias implicações importantes:</p>
<ol type="1">
<li><p><strong>Comportamento Determinístico</strong>: O Prolog pode sempre responder <code>true</code> ou <code>false</code> para qualquer consulta, nunca <em>não sei</em> ou <em>informação insuficiente</em>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Definindo uma relação familiar</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>pai(joao<span class="kw">,</span> pedro)<span class="kw">.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>pai(pedro<span class="kw">,</span> ana)<span class="kw">.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">% A CWA permite conclusões definitivas</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(maria<span class="kw">,</span> pedro)<span class="kw">.</span>  <span class="co">% false - Maria não é pai de Pedro</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> pai(ana<span class="kw">,</span> carlos)<span class="kw">.</span>   <span class="co">% false - Ana não é pai de Carlos</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Na prática, algumas versões do Prolog, emitem mensagens de aviso quando uma consulta não pode ser provada, mas isto é uma convenção de implementação e não uma característica lógica inerente. A CWA permanece válida: a ausência de prova implica falsidade.</p>
</div>
</div>
<ol start="2" type="1">
<li><strong>Negação por Falha</strong>: A <strong>CWA</strong> é o que torna possível o operador de negação <code>\+</code> (lê-se <em>não provável</em>). Este operador não representa negação lógica clássica, mas sim <em>falha em provar</em>.</li>
</ol>
<div class="sourceCode" id="cb16"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>solteiro(<span class="dt">X</span>) <span class="kw">:-</span> pessoa(<span class="dt">X</span>)<span class="kw">,</span> <span class="kw">\+</span> casado(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">% Se casado(joao) não pode ser provado, então solteiro(joao) é verdadeiro</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>pessoa(joao)<span class="kw">.</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">% Sem fato casado(joao), a consulta ?- solteiro(joao). retorna true</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="limitações-da-cwa" class="level4" data-number="11.1.4.2">
<h4 data-number="11.1.4.2" class="anchored" data-anchor-id="limitações-da-cwa"><span class="header-section-number">11.1.4.2</span> Limitações da CWA</h4>
<p>Embora poderosa, a <strong>Hipótese do Mundo Fechado</strong> introduz limitações que o programador Prolog deve compreender:</p>
<ol type="1">
<li><strong>Monotonicidade Quebrada</strong>: Ao contrário da lógica clássica, adicionar novos fatos pode tornar afirmações previamente verdadeiras em falsas.</li>
</ol>
<div class="sourceCode" id="cb17"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Estado inicial da base de conhecimento</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>ave(canario)<span class="kw">.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>nao_voa(<span class="dt">X</span>) <span class="kw">:-</span> ave(<span class="dt">X</span>)<span class="kw">,</span> <span class="kw">\+</span> voa(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">% Consulta inicial</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> nao_voa(canario)<span class="kw">.</span>   <span class="co">% true - canário não voa (não está definido)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">% Adicionando novo fato</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>voa(canario)<span class="kw">.</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">% Mesma consulta agora</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> nao_voa(canario)<span class="kw">.</span>   <span class="co">% false - agora canário voa!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><strong>Diferença entre Falso e Desconhecido</strong>: A <strong>CWA</strong> colapsa a distinção entre <em>provadamente falso</em> e <em>desconhecido</em>, o que pode levar a conclusões incorretas em domínios nos quais esta distinção é importante.</li>
</ol>
<div class="sourceCode" id="cb18"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Problema: não sabemos se um animal específico voa ou não</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>animal(morcego)<span class="kw">.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">% Sem informação sobre voo</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> voa(morcego)<span class="kw">.</span>       <span class="co">% false - mas isto significa _não voa_ ou _não sabemos_?</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> <span class="kw">\+</span> voa(morcego)<span class="kw">.</span>    <span class="co">% true - assumimos que não voa por falta de evidência</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="abordagens-alternativas" class="level4" data-number="11.1.4.3">
<h4 data-number="11.1.4.3" class="anchored" data-anchor-id="abordagens-alternativas"><span class="header-section-number">11.1.4.3</span> Abordagens Alternativas</h4>
<p>Quando a <strong>CWA</strong> é inadequada para o domínio do problema, existem várias estratégias:</p>
<ol type="1">
<li><strong>Representação Explícita da Negação</strong>: definir explicitamente tanto casos positivos quanto negativos</li>
</ol>
<div class="sourceCode" id="cb19"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Definindo fatos positivos e negativos</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>voa(canario)<span class="kw">.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>voa(aguia)<span class="kw">.</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>nao_voa(pinguim)<span class="kw">.</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>nao_voa(avestruz)<span class="kw">.</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">% Predicado que distingue entre _não voa_ e _desconhecido_</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>pode_voar(<span class="dt">X</span>) <span class="kw">:-</span> voa(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>nao_pode_voar(<span class="dt">X</span>) <span class="kw">:-</span> nao_voa(<span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>status_voo_desconhecido(<span class="dt">X</span>) <span class="kw">:-</span> ave(<span class="dt">X</span>)<span class="kw">,</span> <span class="kw">\+</span> voa(<span class="dt">X</span>)<span class="kw">,</span> <span class="kw">\+</span> nao_voa(<span class="dt">X</span>)<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><strong>Uso de Valores de Verdade Ternários</strong>: representando verdadeiro, falso e desconhecido.</li>
</ol>
<div class="sourceCode" id="cb20"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Definindo o status de voo</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>voo_status(canario<span class="kw">,</span> verdadeiro)<span class="kw">.</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>voo_status(pinguim<span class="kw">,</span> falso)<span class="kw">.</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>voo_status(papagaio<span class="kw">,</span> desconhecido)<span class="kw">.</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>pode_voar(<span class="dt">X</span>) <span class="kw">:-</span> voo_status(<span class="dt">X</span><span class="kw">,</span> verdadeiro)<span class="kw">.</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>nao_pode_voar(<span class="dt">X</span>) <span class="kw">:-</span> voo_status(<span class="dt">X</span><span class="kw">,</span> falso)<span class="kw">.</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>incerto_se_voa(<span class="dt">X</span>) <span class="kw">:-</span> voo_status(<span class="dt">X</span><span class="kw">,</span> desconhecido)<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="impacto-da-cwa-no-comportamento-procedural-do-prolog" class="level4" data-number="11.1.4.4">
<h4 data-number="11.1.4.4" class="anchored" data-anchor-id="impacto-da-cwa-no-comportamento-procedural-do-prolog"><span class="header-section-number">11.1.4.4</span> Impacto da CWA no Comportamento Procedural do Prolog</h4>
<p>A <strong>Hipótese do Mundo Fechado</strong> é importante para compreender por que o Prolog se comporta de forma tão diferente das linguagens imperativas. Ela estabelece uma semântica clara para a ausência de informação, permitindo que o sistema de inferência tome decisões definitivas e siga adiante na computação. A atenta leitora não deve perder de vista que o Prolog não é simplesmente uma linguagem de consulta; é uma linguagem de programação completa, onde a lógica e o controle estão entrelaçados através da <strong>CWA</strong>.</p>
<p>Esta suposição está intrinsecamente ligada à estratégia de busca do Prolog: quando o mecanismo de inferência não consegue encontrar uma prova para um objetivo, ele <strong>não suspende</strong> a execução aguardando mais informação, assume imediatamente que o objetivo é falso e prossegue de acordo.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">% A CWA permite decisões rápidas em estruturas condicionais</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>processar_animal(<span class="dt">X</span>) <span class="kw">:-</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    (voa(<span class="dt">X</span>) <span class="kw">-&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        writeln(<span class="st">'</span><span class="er">Animal voador</span><span class="st">'</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">;</span>   writeln(<span class="st">'</span><span class="er">Animal que n</span><span class="st">ã</span><span class="er">o voa</span><span class="st">'</span>)  <span class="co">% Assume falso pela CWA</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    )<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A compreensão da <strong>Hipótese do Mundo Fechado</strong> é essencial para programar efetivamente em Prolog, pois ela permeia todo o comportamento do sistema, desde a avaliação de consultas simples até o funcionamento de construções complexas como a negação por falha e estruturas condicionais.</p>
</section>
</section>
</section>
<section id="o-coração-do-mecanismo-de-inferência-unificação" class="level2" data-number="11.2">
<h2 data-number="11.2" class="anchored" data-anchor-id="o-coração-do-mecanismo-de-inferência-unificação"><span class="header-section-number">11.2</span> O Coração do mecanismo de inferência: Unificação</h2>
<p><strong>A unificação é a operação fundamental que impulsiona toda a computação em Prolog</strong>. Esta operação é muito mais do que uma simples correspondência de padrões; é um algoritmo sofisticado para tornar dois termos sintaticamente idênticos, resolvendo equações simbólicas. Trata-se do mecanismo utilizado para corresponder um objetivo da consulta com a cabeça de uma cláusula na base de conhecimento.</p>
<p>Formalmente, dizemos que a unificação é o processo algorítmico para encontrar uma <strong>substituição</strong> de variáveis que tornam dois termos iguais. Ao contrário da atribuição em linguagens imperativas, que é unidirecional, a unificação é um processo <strong>bidirecional</strong>. Pode instanciar variáveis em qualquer um dos termos para alcançar uma correspondência. Por exemplo, ao unificar <code>ponto(X, 10)</code> com <code>ponto(b, Y)</code>, o processo tem sucesso ao ligar <code>X</code> ao átomo <code>b</code> e <code>Y</code> ao número <code>10</code>. Esta única operação realiza testes, passa argumentos e retorna valores simultaneamente, uma demonstração da sua eficiência e elegância conceptual.</p>
<section id="o-algoritmo-de-unificação" class="level3" data-number="11.2.1">
<h3 data-number="11.2.1" class="anchored" data-anchor-id="o-algoritmo-de-unificação"><span class="header-section-number">11.2.1</span> O Algoritmo de Unificação</h3>
<p>O processo de unificação é inerentemente recursivo e segue um conjunto de regras bem definidas:</p>
<ol type="1">
<li>Se os dois termos são constantes idênticas, átomos ou números, a unificação tem sucesso;<br>
</li>
<li>Se um dos termos é uma variável não instanciada, ela é ligada, instanciada, ao outro termo;<br>
</li>
<li>Se ambos os termos são variáveis não instanciadas, elas são co-referenciadas, tornando-se efetivamente aliases, pseudônimos, uma da outra;<br>
</li>
<li>Se ambos os termos são estruturas, a unificação só tem sucesso se ambos tiverem o mesmo functor e a mesma aridade, E se todos os seus argumentos correspondentes unificarem recursivamente;<br>
</li>
<li>Em todos os outros casos, por exemplo, functores diferentes, aridades diferentes ou uma constante e uma estrutura, a unificação falha.</li>
</ol>
<p>A tabela <a href="#tbl-algo1" class="quarto-xref">Table&nbsp;<span>11.1</span></a> ilustra o algoritmo em ação com vários exemplos.</p>
<div id="tbl-algo1" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-algo1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.1: Exemplos de Unificação.
</figcaption>
<div aria-describedby="tbl-algo1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Termo 1</th>
<th style="text-align: left;">Termo 2</th>
<th style="text-align: left;">Unifica?</th>
<th style="text-align: left;">Unificador Mais Geral (MGU)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">gato(tom)</td>
<td style="text-align: left;">gato(tom)</td>
<td style="text-align: left;">Sim</td>
<td style="text-align: left;">{} (substituição vazia)</td>
</tr>
<tr class="even">
<td style="text-align: left;">gato(X)</td>
<td style="text-align: left;">gato(tom)</td>
<td style="text-align: left;">Sim</td>
<td style="text-align: left;">X = tom</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pai(X, Y)</td>
<td style="text-align: left;">pai(joao, maria)</td>
<td style="text-align: left;">Sim</td>
<td style="text-align: left;">X = joao, Y = maria</td>
</tr>
<tr class="even">
<td style="text-align: left;">f(X, a)</td>
<td style="text-align: left;">f(b, Y)</td>
<td style="text-align: left;">Sim</td>
<td style="text-align: left;">X = b, Y = a</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f(X, X)</td>
<td style="text-align: left;">f(a, b)</td>
<td style="text-align: left;">Não</td>
<td style="text-align: left;">Falha (a = b)</td>
</tr>
<tr class="even">
<td style="text-align: left;">gato(tom)</td>
<td style="text-align: left;">cao(fido)</td>
<td style="text-align: left;">Não</td>
<td style="text-align: left;">Falha (functor diferente)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lista([a,b])</td>
<td style="text-align: left;">lista()</td>
<td style="text-align: left;">Sim</td>
<td style="text-align: left;">X = a, Y = [b]</td>
</tr>
<tr class="even">
<td style="text-align: left;">X</td>
<td style="text-align: left;">f(X)</td>
<td style="text-align: left;">Sim (sem <em>occurs check</em>)</td>
<td style="text-align: left;">X = f(f(f(…))) (termo infinito)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">unify_with_occurs_check(X, f(X))</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">Não</td>
<td style="text-align: left;">Falha (<em>occurs check</em>)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="o-unificador-mais-geral-mgu" class="level3" data-number="11.2.2">
<h3 data-number="11.2.2" class="anchored" data-anchor-id="o-unificador-mais-geral-mgu"><span class="header-section-number">11.2.2</span> O Unificador Mais Geral (MGU)</h3>
<p>Quando existem múltiplas substituições possíveis que podem unificar dois termos, o Prolog procura sempre o <strong>Unificador Mais Geral</strong>, em inglês: <em><strong>M</strong>ost <strong>G</strong>eneral <strong>U</strong>nifier</em>, <strong>MGU</strong>). O <strong>MGU</strong> é a substituição que faz o menor número de compromissos, deixando as variáveis tão livres quanto possível. Por exemplo, ao unificar <code>f(X, a)</code> com <code>f(Y, Z)</code>, um unificador possível seria <code>{X/b, Y/b, Z/a}</code>, mas o <strong>MGU</strong> é <code>{X/Y, Z/a}</code>. O <strong>MGU</strong> é preferido porque maximiza as opções para futuras unificações no processo de busca. As respostas que o Prolog fornece a uma consulta são, na verdade, os <strong>MGU</strong>s que tornam a consulta verdadeira.</p>
</section>
<section id="o-occurs-check-uma-omissão-pragmática" class="level3" data-number="11.2.3">
<h3 data-number="11.2.3" class="anchored" data-anchor-id="o-occurs-check-uma-omissão-pragmática"><span class="header-section-number">11.2.3</span> O <em>Occurs Check</em>: Uma Omissão Pragmática</h3>
<p>O algoritmo de unificação logicamente correto inclui um passo conhecido como <strong><em>occurs check</em></strong>, verificação de ocorrência. Este teste impede que uma variável seja unificada com um termo que a contenha, como em <code>X \= f(X)</code>. Tal unificação criaria um termo cíclico e infinito, o que é logicamente inconsistente. No entanto, a maioria das implementações de Prolog omite esta verificação por defeito, por razões de eficiência. O <em>occurs check</em> tem uma complexidade computacional linear em relação ao tamanho do termo, e a sua execução em cada passo da unificação tornaria os programas significativamente mais lentos. A justificativa para esta omissão é que tais situações raramente ocorrem em programas práticos. As consequências, no entanto, podem ser a geração de resultados incorretos ou a entrada em laços de recorrência infinitos.</p>
<p>Para os casos em que a correção lógica é primordial, a maioria dos sistemas Prolog fornece predicados incorporados. Tais como: <code>unify_with_occurs_check/2</code>, que realizam a unificação completa e segura.</p>
</section>
</section>
<section id="o-mecanismo-de-inferência-lógico-resolução-sld" class="level2" data-number="11.3">
<h2 data-number="11.3" class="anchored" data-anchor-id="o-mecanismo-de-inferência-lógico-resolução-sld"><span class="header-section-number">11.3</span> O mecanismo de inferência Lógico: Resolução SLD</h2>
<p>Se a unificação é a operação fundamental, a <strong>Resolução SLD</strong> é o procedimento de inferência formal que a orquestra. O mecanismo de inferência do Prolog não está simplesmente a <em>executar código</em>; está a construir uma prova formal para a consulta submetida.</p>
<p>A estratégia central do Prolog é a <strong>prova por refutação</strong>, do inglês <em>proof by refutation</em>. Para provar que uma consulta <span class="math inline">\(Q\)</span> é verdadeira, o mecanismo de inferência assume temporariamente que ela é falsa (<span class="math inline">\(\neg Q\)</span>) e tenta derivar uma contradição lógica, a cláusula vazia, que representa falso, a partir desta suposição, em conjunto com a base de conhecimento.8 Se uma contradição é encontrada, a suposição inicial (<span class="math inline">\(\neg Q\)</span>) deve ser falsa, o que, por sua vez, prova que a consulta original <span class="math inline">\(Q\)</span> deve ser verdadeira. Este é um princípio fundamental da prova automática de teoremas.</p>
<p>O acrônimo <strong>SLD</strong> tem origem no inglês e significa Resolução linear seletiva para cláusulas definidas. Cada termo tem um significado preciso:</p>
<ul>
<li><strong>D (Definidas)</strong>: o procedimento opera sobre Cláusulas de Horn definidas, que é a forma lógica das regras e fatos do Prolog;</li>
<li><strong>L (Linear)</strong>: a prova é construída como uma sequência linear de passos, nos quais cada novo conjunto de objetivos é derivado do conjunto anterior e de uma cláusula da base de conhecimento. Isto cria uma cadeia de raciocínio direta.</li>
<li><strong>S (Seletiva)</strong>: em cada passo do processo, uma regra de seleção escolhe um único objetivo da lista de objetivos atual para ser resolvido. Na implementação padrão do Prolog, esta regra é fixa e simples: <strong>selecionar sempre o objetivo mais à esquerda</strong>.</li>
</ul>
<p>O algoritmo de um único passo de resolução pode ser descrito da seguinte forma:</p>
<ol type="1">
<li>Dada uma lista de objetivos (inicialmente, a consulta), a regra de seleção escolhe o mais à esquerda;</li>
<li>O mecanismo de inferência pesquisa a base de conhecimento, de cima para baixo, por uma cláusula cuja cabeça unifique com o objetivo selecionado;</li>
<li>Se um <strong>fato</strong> unificador é encontrado, o objetivo é considerado provado. Ele é removido da lista de objetivos, e o <strong>MGU</strong> resultante da unificação é aplicado a todas as variáveis nos objetivos restantes;</li>
<li>Se uma <strong>regra</strong> unificadora (<span class="math inline">\(Head :- Body\)</span>) é encontrada, o objetivo selecionado é substituído na lista de objetivos pelos objetivos do corpo da regra. O <strong>MGU</strong> é então aplicado a esta nova lista de objetivos;</li>
<li>Se nenhuma cabeça de cláusula na base de conhecimento unificar com o objetivo selecionado, o objetivo falha;</li>
<li>O processo termina com sucesso quando a lista de objetivos se torna vazia. A derivação da cláusula vazia completa a prova por refutação.</li>
</ol>
<p>É importante que a atenta leitora consiga distinguir entre a <strong>Resolução SLD</strong> como regra de inferência lógica e a busca em profundidade como estratégia de busca. A <strong>Resolução SLD</strong> define <em>o que constitui um passo de prova válido</em>, enquanto a busca em profundidade dita <em>a ordem pela qual os possíveis passos de prova são explorados</em>. A teoria lógica da resolução não prescreve uma estratégia de busca, mas as escolhas pragmáticas dos criadores do Prolog, seleção do objetivo mais à esquerda, pesquisa de cláusulas de cima para baixo, dão à linguagem o seu comportamento procedural previsível e determinístico.</p>
<section id="navegando-no-espaço-de-soluções-busca-em-profundidade-e-backtracking" class="level3" data-number="11.3.1">
<h3 data-number="11.3.1" class="anchored" data-anchor-id="navegando-no-espaço-de-soluções-busca-em-profundidade-e-backtracking"><span class="header-section-number">11.3.1</span> Navegando no Espaço de Soluções: Busca em Profundidade e Backtracking</h3>
<p>A aplicação repetida da regra de <strong>Resolução SLD</strong> define um espaço de soluções potenciais. A forma como o mecanismo de inferência Prolog explora este espaço é o que determina o seu comportamento procedural e a sua eficiência.</p>
<p>O processo de resolução pode ser visualizado como a construção de uma <strong>árvore de busca SLD</strong>.</p>
<ul>
<li>A <strong>raiz</strong> da árvore é a consulta inicial;</li>
<li>Cada <strong>ramo</strong> que parte de um vértice representa a escolha de uma cláusula da base de conhecimento cuja cabeça unifica com o objetivo selecionado nesse vértice;</li>
<li>Os <strong>nós folha</strong> podem ser de dois tipos: <strong>nós de sucesso</strong>, nos quais a lista de objetivos está vazia, ou <strong>nós de falha</strong>, nos quais o objetivo selecionado não pode ser unificado com nenhuma cláusula.</li>
</ul>
<p>O objetivo do mecanismo de inferência Prolog é encontrar um caminho da raiz até um vértice de sucesso. As instanciações de variáveis acumuladas ao longo desse caminho constituem uma solução para a consulta.</p>
</section>
<section id="exemplo-em-prolog" class="level3" data-number="11.3.2">
<h3 data-number="11.3.2" class="anchored" data-anchor-id="exemplo-em-prolog"><span class="header-section-number">11.3.2</span> Exemplo em Prolog</h3>
<p>O código a seguir define uma pequena base de conhecimento sobre relações familiares e uma regra para inferir ancestralidade.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Base de conhecimento</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>pai(joao<span class="kw">,</span> maria)<span class="kw">.</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>pai(joao<span class="kw">,</span> pedro)<span class="kw">.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>pai(pedro<span class="kw">,</span> ana)<span class="kw">.</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>pai(pedro<span class="kw">,</span> carlos)<span class="kw">.</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>mae(rosa<span class="kw">,</span> maria)<span class="kw">.</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>mae(rosa<span class="kw">,</span> pedro)<span class="kw">.</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>mae(maria<span class="kw">,</span> ana)<span class="kw">.</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>mae(maria<span class="kw">,</span> carlos)<span class="kw">.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co">% Regra para definir progenitor</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>progenitor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span> pai(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>progenitor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span> mae(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="co">% Regra para definir ancestral</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>ancestral(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span> progenitor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>ancestral(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span> progenitor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">,</span> ancestral(<span class="dt">Z</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a><span class="co">% Consulta: ?- ancestral(joao, ana).</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Para a consulta <code>?- ancestral(joao, ana)</code>, o mecanismo de inferência Prolog constrói a seguinte árvore de busca, explorando um ramo de cada vez, busca em profundidade:</p>
<ol type="1">
<li><strong>vértice raiz</strong>: <code>ancestral(joao, ana)</code>
<ul>
<li>Tenta unificar com a primeira cláusula de <code>ancestral</code>: <code>ancestral(X, Y) :- progenitor(X, Y)</code>.</li>
<li>A unificação é bem-sucedida com <span class="math inline">\(X=joao\)</span> e <span class="math inline">\(Y=ana\)</span>.</li>
<li><strong>Novo objetivo</strong>: <code>progenitor(joao, ana)</code>.</li>
</ul></li>
<li><strong>Explorando</strong>: <code>progenitor(joao, ana)</code>
<ul>
<li>Tenta a primeira regra de <code>progenitor</code>: <code>progenitor(X, Y) :- pai(X, Y)</code>.</li>
<li>Busca por <code>pai(joao, ana)</code> na base de conhecimento.</li>
<li><strong>Falha</strong>: o fato não existe.</li>
</ul></li>
<li><strong>Backtracking (Retorno)</strong>:
<ul>
<li>A tentativa com <code>pai</code> falhou, então o Prolog retorna e tenta a próxima cláusula disponível para <code>progenitor</code>.</li>
<li>Tenta a segunda regra de <code>progenitor</code>: <code>progenitor(X, Y) :- mae(X, Y)</code>.</li>
<li>Busca por <code>mae(joao, ana)</code> na base de conhecimento.</li>
<li><strong>Falha</strong>: o fato não existe.</li>
</ul></li>
<li><strong>Backtracking (Retorno ao nível superior)</strong>:
<ul>
<li>Todas as cláusulas para <code>progenitor(joao, ana)</code> foram esgotadas sem sucesso. O Prolog retorna ao vértice <code>ancestral(joao, ana)</code> e tenta a próxima cláusula disponível para ele.</li>
<li>Tenta a segunda cláusula de <code>ancestral</code>: <code>ancestral(X, Y) :- progenitor(X, Z), ancestral(Z, Y)</code>.</li>
<li>A unificação é bem-sucedida com <span class="math inline">\(X=joao\)</span> e <span class="math inline">\(Y=ana\)</span>.</li>
<li><strong>Novos objetivos</strong>: <code>progenitor(joao, Z)</code>, <code>ancestral(Z, ana)</code>.</li>
</ul></li>
<li><strong>Resolvendo o primeiro novo objetivo</strong>: <code>progenitor(joao, Z)</code>
<ul>
<li>Tenta a primeira regra de <code>progenitor</code>: <code>progenitor(X, Y) :- pai(X, Y)</code>.</li>
<li>Busca por <code>pai(joao, Z)</code>.</li>
<li><strong>Sucesso</strong>: Unifica com o fato <code>pai(joao, maria)</code>, instanciando a variável <span class="math inline">\(Z=maria\)</span>.</li>
</ul></li>
<li><strong>Resolvendo o segundo objetivo com <span class="math inline">\(Z\)</span> instanciado</strong>: <code>ancestral(maria, ana)</code>
<ul>
<li>Começa a resolver este novo sub-problema do topo das regras de <code>ancestral</code>.</li>
<li>Tenta a primeira cláusula de <code>ancestral</code>: <code>ancestral(X, Y) :- progenitor(X, Y)</code>.</li>
<li>Unificação com <span class="math inline">\(X=maria\)</span> e <span class="math inline">\(Y=ana\)</span>.</li>
<li><strong>Novo objetivo</strong>: <code>progenitor(maria, ana)</code>.</li>
</ul></li>
<li><strong>Explorando <code>progenitor(maria, ana)</code></strong>:
<ul>
<li>Tenta a primeira regra de <code>progenitor</code>: <code>progenitor(X, Y) :- pai(X, Y)</code>.</li>
<li>Busca por <code>pai(maria, ana)</code>.</li>
<li><strong>Falha</strong>: o fato não existe.</li>
</ul></li>
<li><strong>Backtracking (Retorno)</strong>:
<ul>
<li>Retorna e tenta a próxima cláusula para <code>progenitor(maria, ana)</code>.</li>
<li>Tenta a segunda regra de <code>progenitor</code>: <code>progenitor(X, Y) :- mae(X, Y)</code>.</li>
<li>Busca por <code>mae(maria, ana)</code>.</li>
<li><strong>Sucesso</strong>: O fato <code>mae(maria, ana)</code> existe na base de conhecimento.</li>
</ul></li>
<li><strong>Solução Encontrada</strong>:
<ul>
<li>O objetivo <code>progenitor(maria, ana)</code> foi satisfeito.</li>
<li>O objetivo <code>ancestral(maria, ana)</code> foi satisfeito.</li>
<li>Como todos os objetivos da consulta original foram satisfeitos, a consulta <code>ancestral(joao, ana)</code> é bem-sucedida. O Prolog retorna <code>true</code>.</li>
</ul></li>
</ol>
<p>A árvore resultante da <strong>Resolução SLD</strong> para esta consulta está ilustrada na figura <a href="#fig-sld-tree" class="quarto-xref">Figure&nbsp;<span>11.1</span></a>.</p>
<div id="fig-sld-tree" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-sld-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/arvore-sld.webp" class="img-fluid figure-img"></p>
<figcaption>Árvore de Busca SLD para a Consulta <code>ancestral(joao, ana)</code></figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-sld-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.1
</figcaption>
</figure>
</div>
</section>
<section id="a-estratégia-de-busca-do-prolog-transversalidade-em-profundidade" class="level3" data-number="11.3.3">
<h3 data-number="11.3.3" class="anchored" data-anchor-id="a-estratégia-de-busca-do-prolog-transversalidade-em-profundidade"><span class="header-section-number">11.3.3</span> A Estratégia de Busca do Prolog: transversalidade em Profundidade</h3>
<p>O Prolog não explora a árvore <strong>SLD</strong> nível a nível, busca em largura. Em vez disso, ele emprega uma estratégia de <strong>busca em profundidade</strong>, no inglês: <em><strong>D</strong>epth-<strong>F</strong>irst <strong>S</strong>earch</em>, <strong>DFS</strong>. Esta estratégia é uma consequência direta das suas regras de seleção fixas: tentar sempre resolver o objetivo mais à esquerda e usar sempre a primeira cláusula correspondente, de cima para baixo, na base de conhecimento. Isto leva o mecanismo de inferência a seguir uma única linha de raciocínio o mais profundamente possível antes de considerar quaisquer alternativas. Esta escolha de design tem implicações importantes: por um lado, é extremamente eficiente em termos de uso de memória, pois só precisa de manter o estado do caminho atual; por outro, torna o Prolog <strong>incompleto</strong>, pois pode ficar preso num ramo infinito da árvore de busca, nunca encontrando uma solução que possa existir noutro ramo.</p>
<p>O <em>backtracking</em> é a implementação algorítmica da busca em profundidade. É o processo pelo qual o Prolog recua de um caminho de computação que falhou para explorar alternativas. O mecanismo funciona da seguinte forma:</p>
<ol type="1">
<li><strong>Criação de um Ponto de Escolha</strong>: quando um objetivo unifica com a cabeça de uma cláusula e existem outras cláusulas abaixo dela que também poderiam unificar, o mecanismo de inferência cria um <strong>ponto de escolha</strong>, <em>choice point</em>. Este ponto de escolha funciona como um marcador, guardando o estado atual da computação: a lista de objetivos restantes e um ponteiro para a próxima cláusula alternativa a ser tentada.</li>
<li><strong>Execução para a Frente</strong>: o mecanismo de inferência prossegue ao longo do caminho escolhido, tentando resolver os novos sub-objetivos, o que pode levar à criação de mais pontos de escolha.</li>
<li><strong>Ativação do Backtracking</strong>: O backtracking é ativado sempre que um objetivo <strong>falha</strong>, ou seja, não consegue unificar com nenhuma cabeça de cláusula na base de conhecimento.</li>
<li><strong>Retorno a um Ponto de Escolha</strong>: perante uma falha, o mecanismo de inferência abandona o caminho de computação atual e <em>salta</em> para trás, para o ponto de escolha mais recente que foi criado.</li>
<li><strong>Desfazer Ligações (Desinstanciação)</strong>: este é um passo crítico. Todas as ligações de variáveis que foram feitas <em>desde que esse ponto de escolha foi criado</em> são desfeitas. O estado do sistema é restaurado para o momento exato em que a escolha foi feita.</li>
<li><strong>Tentar a Próxima Alternativa</strong>: O mecanismo de inferência tenta então satisfazer o objetivo original usando a próxima cláusula alternativa registada no ponto de escolha. Se esta nova tentativa tiver sucesso, a execução para a frente é retomada a partir deste novo caminho. Se falhar novamente, o mecanismo de inferência faz backtracking outra vez, para o ponto de escolha anterior.</li>
<li><strong>Esgotar as Possibilidades</strong>: Se todas as alternativas num ponto de escolha forem tentadas e falharem, o ponto de escolha é removido, e o objetivo original que o criou falha, desencadeando mais backtracking. A consulta inteira falha se o mecanismo de inferência fizer backtracking para além do primeiro ponto de escolha.</li>
</ol>
<p>Vamos usar um algoritmo de procura de caminhos num grafo para traçar este processo em detalhe. Considere o fragmento de código a seguir:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>edge(a<span class="kw">,</span>b)<span class="kw">.</span> </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>edge(a<span class="kw">,</span>c)<span class="kw">.</span> </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>edge(b<span class="kw">,</span>d)<span class="kw">.</span> </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>edge(c<span class="kw">,</span>d)<span class="kw">.</span> </span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>edge(d<span class="kw">,</span>e)<span class="kw">.</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>path(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>) <span class="kw">:-</span> path(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span><span class="kw">,</span>[])<span class="kw">.</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">% Caso base: há um caminho se houver uma aresta direta. </span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>path(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span><span class="kw">,</span><span class="dt">_</span>) <span class="kw">:-</span> edge(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co">% Caso recursivo: há um caminho se houver uma aresta para Z  </span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co">% e um caminho de Z para Y, desde que X não tenha sido visitado. </span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>path(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span><span class="kw">,</span><span class="dt">V</span>) <span class="kw">:-</span>  </span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">\+</span> member(<span class="dt">X</span><span class="kw">,</span><span class="dt">V</span>)<span class="kw">,</span>  </span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    edge(<span class="dt">X</span><span class="kw">,</span><span class="dt">Z</span>)<span class="kw">,</span>  </span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    path(<span class="dt">Z</span><span class="kw">,</span><span class="dt">Y</span><span class="kw">,</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">V</span>])<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Agora podemos analisar o algoritmo, passo a passo para a solução da consulta <code>?- path(a, e).</code>:</p>
<ol type="1">
<li><strong>Chamada Inicial</strong>: o objetivo é <code>path(a, e)</code>. Unifica com a cabeça de <code>path/2</code>, que chama <code>path(a, e, [])</code>.</li>
<li><strong>Tentativa 1 (path/3)</strong>: o mecanismo de inferência tenta a primeira cláusula de <code>path/3</code>. O sub-objetivo <code>edge(a, e)</code> é tentado. <code>Falha</code>, pois não existe na base de conhecimento.</li>
<li><strong>Backtrack e Tentativa 2 (path/3)</strong>: o mecanismo de inferência faz <em>backtrack</em> e tenta a segunda cláusula de <code>path/3</code>.</li>
<li><strong>Sub-objetivo <code>\+ member(a, [])</code></strong>: este objetivo tem sucesso, pois a não está na lista vazia.</li>
<li><strong>Sub-objetivo <code>edge(a, Z)</code></strong>: o mecanismo de inferência procura uma correspondência. Encontra <code>edge(a, b)</code>. A variável <code>Z</code> é ligada a <code>b</code>. <strong>Um ponto de escolha é criado</strong> aqui, porque existe outra cláusula correspondente, <code>edge(a, c)</code>, que pode ser tentada mais tarde.</li>
<li><strong>Chamada Recursiva</strong>: o próximo sub-objetivo é <code>path(b, e, [a])</code>.</li>
<li><strong>Dentro da Recurssão</strong>: o mecanismo de inferência tenta resolver <code>path(b, e, [a])</code>.
<ul>
<li>Tenta <code>edge(b, e)</code>. <code>Falha</code>.</li>
<li>Tenta a segunda cláusula de <code>path/3</code>. <code>\+ member(b, [a])</code> tem sucesso.</li>
<li>O sub-objetivo <code>edge(b, Z1)</code> é tentado. Unifica com <code>edge(b, d)</code>, ligando <code>Z1</code> a <code>d</code>. Não há outras alternativas para <code>edge(b,...)</code>, por isso não é criado um novo ponto de escolha.</li>
<li>A chamada recursiva seguinte é <code>path(d, e, [b, a])</code>.</li>
</ul></li>
<li><strong>Sucesso</strong>: Para resolver <code>path(d, e, [b, a])</code>, o mecanismo de inferência tenta a primeira cláusula de <code>path/3</code>: <code>edge(d, e)</code>. Este objetivo <strong>tem sucesso</strong>, pois o facto <code>edge(d,e)</code> existe.</li>
<li><strong>Solução Encontrada</strong>: Como o último sub-objetivo teve sucesso, todas as chamadas recursivas anteriores também têm sucesso. A consulta original <code>path(a, e)</code> é provada como verdadeira. O Prolog responde <code>true</code>.</li>
<li><strong>Procurando Mais Soluções</strong>: Se o utilizador solicitar outra solução (premindo ;), o Prolog força uma falha no ponto de sucesso e inicia o <strong>backtracking</strong>.</li>
<li><strong>Retorno ao Ponto de Escolha</strong>: O mecanismo de inferência salta para trás, para o ponto de escolha mais recente: o objetivo <code>edge(a, Z)</code>. A ligação <code>Z=b</code> é <strong>desfeita</strong>.</li>
<li><strong>Nova Tentativa</strong>: O mecanismo de inferência tenta a alternativa seguinte, <code>edge(a, c)</code>. A variável <code>Z</code> é agora ligada a <code>c</code>.</li>
<li><strong>Novo Caminho</strong>: A execução prossegue para a frente a partir deste ponto, com a chamada <code>path(c, e, [a])</code>. Este novo caminho também levará ao sucesso, demonstrando como o backtracking explora sistematicamente todo o espaço de soluções.</li>
</ol>
<p>O processo inteiro pode ser visualizado na figura <a href="#fig-backtracking-tree" class="quarto-xref">Figure&nbsp;<span>11.2</span></a>, que ilustra a árvore de busca SLD para a consulta <code>path(a, e)</code>.</p>
<div id="fig-backtracking-tree" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-backtracking-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/backtracking.webp" class="img-fluid figure-img"></p>
<figcaption>Árvore de Busca SLD para a Consulta <code>path(a, e)</code> com Backtracking</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-backtracking-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.2
</figcaption>
</figure>
</div>
</section>
</section>
<section id="estruturas-de-dados-como-uma-lente-para-a-mecânica-do-prolog" class="level2" data-number="11.4">
<h2 data-number="11.4" class="anchored" data-anchor-id="estruturas-de-dados-como-uma-lente-para-a-mecânica-do-prolog"><span class="header-section-number">11.4</span> Estruturas de Dados como uma Lente para a Mecânica do Prolog</h2>
<p>A manipulação de estruturas de dados em Prolog serve como um exemplo prático da aplicação de seus mecanismos fundamentais: a unificação e a recursão. Diferente das linguagens imperativas, o Prolog não se destaca por comandos que modificam dados diretamente, como <em>obtenha o filho esquerdo de uma árvore</em>. Em vez disso, sua força está na capacidade de definir de forma declarativa as propriedades e relações que governam essas estruturas. O código Prolog não descreve <em>como</em> manipular a estrutura, mas sim <em>o que</em> a define. Por exemplo, em vez de um procedimento para navegar numa árvore, uma regra em Prolog especificaria: <em>esta relação é verdadeira para uma árvore se o seu valor satisfaz uma determinada condição</em>, deixando que o mecanismo de inferência encontre as soluções que correspondem a essa declaração.</p>
<p>Nós podemos tentar entender como o Prolog lida com estruturas de dados através de quatro exemplos clássicos de estruturas de dados: listas, pilhas, filas e árvores de busca binária.</p>
<section id="a-estrutura-de-dados-fundamental-listas-em-prolog" class="level3" data-number="11.4.1">
<h3 data-number="11.4.1" class="anchored" data-anchor-id="a-estrutura-de-dados-fundamental-listas-em-prolog"><span class="header-section-number">11.4.1</span> A Estrutura de Dados Fundamental: Listas em Prolog</h3>
<p>No coração do Prolog, a lista é a única estrutura de dados com sintaxe própria, tornando-a uma ferramenta central para quase todas as aplicações. Uma lista é uma sequência ordenada de elementos que pode conter qualquer tipo de termo Prolog (átomos, números, variáveis ou outras estruturas, incluindo outras listas). A sua elegância reside na sua definição recursiva, que se alinha perfeitamente com a natureza do Prolog.</p>
<p>Toda a lista é definida por duas construções:</p>
<ol type="1">
<li>O átomo <code>[]</code>, que representa a lista vazia;</li>
<li>A estrutura <code>[Head | Tail]</code>, onde <code>Head</code> é o primeiro elemento e <code>Tail</code> é uma lista contendo o resto dos elementos.</li>
</ol>
<p>Esta notação <code>[H|T]</code> é, na verdade, uma forma mais legível para o operador canônico do Prolog, o ponto (<code>.</code>). Assim, a lista <code>[a, b, c]</code> é internamente representada como <code>.(a, .(b, .(c, [])))</code>. Compreender isto é fundamental para ver por que a unificação com <code>[H|T]</code> é tão eficiente.</p>
<section id="unificação-e-recursão-as-ferramentas-de-manipulação-de-listas" class="level4" data-number="11.4.1.1">
<h4 data-number="11.4.1.1" class="anchored" data-anchor-id="unificação-e-recursão-as-ferramentas-de-manipulação-de-listas"><span class="header-section-number">11.4.1.1</span> Unificação e Recursão: As Ferramentas de Manipulação de Listas</h4>
<p>Como o Prolog não possui laços (<code>for</code>, <code>while</code>), a única forma de processar os elementos de uma lista é através da <strong>recursão</strong>. O padrão <code>[Head|Tail]</code> é a chave para este processo, permitindo decompor a lista a cada passo recursivo. O padrão geral para processar uma lista é:</p>
<ul>
<li><strong>Caso Base</strong>: define o que acontece quando a lista está vazia (<code>[]</code>). Este é o critério usado para parar a recursão;</li>
<li><strong>Caso Recursivo</strong>: processa a <code>Head</code> da lista e faz uma chamada recursiva para o predicado, passando o <code>Tail</code> como o novo argumento da lista.</li>
</ul>
<p>Vejamos o exemplo mais clássico, a implementação do predicado <code>member/2</code>, que verifica se um elemento pertence a uma lista.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">% member(Elemento, Lista)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">% Caso Base: O elemento é membro se for a cabeça da lista.</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>member(<span class="dt">X</span><span class="kw">,</span> [<span class="dt">X</span><span class="fu">|</span><span class="dt">_</span>])<span class="kw">.</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co">% Caso Recursivo: O elemento é membro se pertencer ao resto da lista.</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>member(<span class="dt">X</span><span class="kw">,</span> [<span class="dt">_</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> member(<span class="dt">X</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O funcionamento, impulsionado pela unificação, é o seguinte:</p>
<ol type="1">
<li><strong>Consulta:</strong> <code>?- member(b, [a, b, c]).</code></li>
<li><strong>Tentativa 1:</strong> O Prolog tenta unificar a consulta com a primeira cláusula: <code>member(b, [a, b, c])</code> com <code>member(X, [X|_])</code>.
<ul>
<li>Isto requer que <code>b</code> unifique com <code>X</code> e <code>[a, b, c]</code> unifique com <code>[X|_]</code>.</li>
<li>A segunda unificação implica que <code>X</code> deve ser <code>a</code>.</li>
<li>Como <code>b</code> não pode ser igual a <code>a</code>, a unificação falha.</li>
</ul></li>
<li><strong>Tentativa 2:</strong> O Prolog tenta a segunda cláusula: <code>member(b, [a, b, c])</code> com <code>member(X, [_|T])</code>.
<ul>
<li>Isto unifica com sucesso: <code>X</code> liga-se a <code>b</code>, a cabeça <code>a</code> é ignorada (<code>_</code>), e <code>T</code> liga-se a <code>[b, c]</code>.</li>
<li>O corpo da regra é executado: a chamada recursiva <code>member(b, [b, c])</code> torna-se o novo objetivo.</li>
</ul></li>
<li><strong>Recursão (Nível 1):</strong> O novo objetivo é <code>?- member(b, [b, c]).</code>
<ul>
<li>O Prolog tenta a primeira cláusula novamente: <code>member(b, [b, c])</code> com <code>member(X, [X|_])</code>.</li>
<li>Isto unifica com sucesso! <code>X</code> liga-se a <code>b</code> e <code>[b, c]</code> unifica com <code>[b|_]</code>.</li>
<li>Como a cabeça da regra foi unificada e não há corpo para executar, a regra tem sucesso.</li>
</ul></li>
<li><strong>Sucesso Final:</strong> Como a chamada recursiva teve sucesso, a consulta original também tem. O Prolog responde <code>true</code>.</li>
</ol>
<p>Este exemplo simples mostra a essência da manipulação de listas em Prolog: a decomposição via unificação com <code>[H|T]</code> e a transversalidade via recursão.</p>
</section>
</section>
<section id="a-pilha-um-ajuste-natural-para-as-listas-do-prolog" class="level3" data-number="11.4.2">
<h3 data-number="11.4.2" class="anchored" data-anchor-id="a-pilha-um-ajuste-natural-para-as-listas-do-prolog"><span class="header-section-number">11.4.2</span> A Pilha: Um Ajuste Natural para as Listas do Prolog</h3>
<p>Uma pilha (<em>stack</em>) é uma estrutura de dados <strong>LIFO</strong> (<em>Last-In, First-Out</em>), na qual o último elemento adicionado é o primeiro a ser removido. Esta estrutura é trivialmente implementada em Prolog, que trata a cabeça da lista (<code>Head</code>) como o topo da pilha e o resto da lista (<code>Tail</code>) como o corpo. A sintaxe <code>[Head|Tail]</code> permite a construção (adição) e a decomposição (remoção) de elementos com extrema eficiência.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">% is_empty(Pilha)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">% A pilha está vazia se for a lista vazia.</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>is_empty([])<span class="kw">.</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">% push(Elemento, Pilha_Antiga, Nova_Pilha)</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">% Adiciona um elemento ao topo da pilha.</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>push(<span class="dt">Elem</span><span class="kw">,</span> <span class="dt">Stack</span><span class="kw">,</span> [<span class="dt">Elem</span><span class="fu">|</span><span class="dt">Stack</span>])<span class="kw">.</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">% pop(Elemento, Pilha_Antiga, Nova_Pilha)</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co">% Remove o elemento do topo da pilha.</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>pop(<span class="dt">Elem</span><span class="kw">,</span> [<span class="dt">Elem</span><span class="fu">|</span><span class="dt">Stack</span>]<span class="kw">,</span> <span class="dt">Stack</span>)<span class="kw">.</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co">% peek(Elemento, Pilha)</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="co">% Vê o elemento no topo sem o remover.</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>peek(<span class="dt">Elem</span><span class="kw">,</span> [<span class="dt">Elem</span><span class="fu">|</span><span class="dt">_</span>])<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Este design elegante demonstra o poder da unificação para manipulação de dados:</p>
<ul>
<li><strong>Unificação para Decomposição (pop)</strong>: Uma consulta como <code>?- pop(X, [a, b, c], S).</code> tenta unificar a sua estrutura com a cabeça da regra <code>pop(Elem, [Elem|Stack], Stack)</code>. A unificação acontece da seguinte forma:
<ol type="1">
<li><code>[a, b, c]</code> unifica com <code>[Elem|Stack]</code>.</li>
<li>Isto liga <code>Elem</code> instantaneamente a <code>a</code> e <code>Stack</code> a <code>[b, c]</code>.</li>
<li>A variável <code>X</code> da consulta é ligada a <code>Elem</code> (que é <code>a</code>).</li>
<li>A variável <code>S</code> da consulta é ligada a <code>Stack</code> (que é <code>[b, c]</code>). O resultado é <code>X = a</code>, <code>S = [b, c]</code>. Não há comandos de “remover” ou “retornar”; a decomposição é uma consequência direta da correspondência de padrões.</li>
</ol></li>
<li><strong>Unificação para Construção (push)</strong>: Uma consulta como <code>?- push(x, [a, b], NovaPilha).</code> unifica <code>NovaPilha</code> com a estrutura <code>[Elem|Stack]</code>, substituindo as variáveis: <code>[x | [a, b]]</code>. O Prolog constrói a nova lista <code>[x, a, b]</code> como resultado direto da unificação.</li>
</ul>
<p>A ausência de estado mutável significa que operações como <code>push</code> e <code>pop</code> não modificam a pilha original; em vez disso, elas geram uma <em>nova versão</em> da estrutura de dados. Este é um princípio fundamental da programação funcional e lógica, que se baseia na transformação de dados em vez da sua mutação.</p>
</section>
<section id="a-fila-o-desafio-do-primeiro-a-entrar" class="level3" data-number="11.4.3">
<h3 data-number="11.4.3" class="anchored" data-anchor-id="a-fila-o-desafio-do-primeiro-a-entrar"><span class="header-section-number">11.4.3</span> A Fila: O Desafio do “Primeiro a Entrar”</h3>
<p>Uma fila (<em>queue</em>) é uma estrutura _<strong>F</strong>irst-<strong>I</strong>n, <strong>F</strong>irst-<strong>O</strong>ut*, <strong>FIFO</strong>, na qual o primeiro elemento a entrar é o primeiro a sair. Implementar uma fila de forma eficiente em Prolog é um pouco mais complexo. Adicionar um elemento no fim de uma lista é uma operação lenta (requer percorrer a lista inteira). A solução mais comum é usar duas listas para representar a fila: uma lista <em>frontal</em> para remoções rápidas e uma lista <em>traseira</em> para adições rápidas.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Estrutura: queue(Frente, Tras)</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">% enqueue(Elemento, Fila_Antiga, Nova_Fila)</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">% Adiciona um elemento ao fim da fila (na lista de trás).</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>enqueue(<span class="dt">Elem</span><span class="kw">,</span> queue(<span class="dt">F</span><span class="kw">,</span> <span class="dt">B</span>)<span class="kw">,</span> queue(<span class="dt">F</span><span class="kw">,</span> [<span class="dt">Elem</span><span class="fu">|</span><span class="dt">B</span>]))<span class="kw">.</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">% dequeue(Elemento, Fila_Antiga, Nova_Fila)</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="co">% Remove o elemento da frente da fila.</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co">% Caso 1: A lista da frente não está vazia.</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>dequeue(<span class="dt">Elem</span><span class="kw">,</span> queue([<span class="dt">Elem</span><span class="fu">|</span><span class="dt">F</span>]<span class="kw">,</span> <span class="dt">B</span>)<span class="kw">,</span> queue(<span class="dt">F</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">.</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="co">% Caso 2: A lista da frente está vazia. Inverte-se a de trás.</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>dequeue(<span class="dt">Elem</span><span class="kw">,</span> queue([]<span class="kw">,</span> <span class="dt">B</span>)<span class="kw">,</span> queue(<span class="dt">F</span><span class="kw">,</span> [])) <span class="kw">:-</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    reverse(<span class="dt">B</span><span class="kw">,</span> [<span class="dt">Elem</span><span class="fu">|</span><span class="dt">F</span>])<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O mecanismo inteligente acontece na segunda cláusula de <code>dequeue</code>:</p>
<ol type="1">
<li><strong>Chamada:</strong> <code>?- enqueue(c, queue([a], [b]), Q1), enqueue(d, Q1, Q2).</code>
<ul>
<li><code>Q1</code> torna-se <code>queue([a], [c,b])</code>;</li>
<li><code>Q2</code> torna-se <code>queue([a], [d,c,b])</code>. A lista traseira é construída ao contrário.</li>
</ul></li>
<li><strong>Remoção Simples:</strong> <code>?- dequeue(X, queue([a], [d,c,b]), Q3).</code>
<ul>
<li>A primeira cláusula de <code>dequeue</code> é usada;</li>
<li><code>X</code> unifica com <code>a</code>;</li>
<li><code>Q3</code> torna-se <code>queue([], [d,c,b])</code>.</li>
</ul></li>
<li><strong>Remoção com Inversão:</strong> <code>?- dequeue(Y, Q3, Q4).</code>
<ul>
<li>A primeira cláusula de <code>dequeue</code> falha, pois a lista frontal está vazia;</li>
<li>A segunda cláusula é ativada. O objetivo <code>reverse([d,c,b], NovaFrente)</code> é executado;</li>
<li><code>NovaFrente</code> torna-se <code>[b, c, d]</code>;</li>
<li>A estrutura <code>[Y|F]</code> é unificada com <code>[b, c, d]</code>, resultando em <code>Y = b</code> e <code>F = [c, d]</code>;</li>
<li>A nova fila <code>Q4</code> é construída como <code>queue([c, d], [])</code>.</li>
</ul></li>
</ol>
<p>Esta técnica, conhecida como <em>análise amortizada</em>, torna as operações de fila muito eficientes no geral.</p>
</section>
<section id="árvores-de-busca-binária-unificação-em-estruturas-recursivas" class="level3" data-number="11.4.4">
<h3 data-number="11.4.4" class="anchored" data-anchor-id="árvores-de-busca-binária-unificação-em-estruturas-recursivas"><span class="header-section-number">11.4.4</span> Árvores de Busca Binária: Unificação em Estruturas Recursivas</h3>
<p>Uma Árvore de Busca Binária é uma estrutura de dados recursiva ideal para o Prolog. Podemos representá-la com a estrutura <code>tree(Esquerda, Valor, Direita)</code> para um vértice e o átomo <code>nil</code> para uma árvore vazia. A implementação dos predicados de busca (<code>lookup</code>) e inserção (<code>insert</code>) demonstra como a unificação, guiada por comparações aritméticas, navega e constrói estas estruturas de forma declarativa.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">% lookup(Valor, Arvore)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">% Verifica se um valor existe na árvore.</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>lookup(<span class="dt">Value</span><span class="kw">,</span> tree(<span class="dt">_</span><span class="kw">,</span> <span class="dt">Value</span><span class="kw">,</span> <span class="dt">_</span>))<span class="kw">.</span> <span class="co">% Caso base: o valor está no vértice atual.</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>lookup(<span class="dt">Value</span><span class="kw">,</span> tree(<span class="dt">Left</span><span class="kw">,</span> <span class="dt">NodeVal</span><span class="kw">,</span> <span class="dt">_</span>)) <span class="kw">:-</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Value</span> <span class="dt">&lt;</span> <span class="dt">NodeVal</span><span class="kw">,</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    lookup(<span class="dt">Value</span><span class="kw">,</span> <span class="dt">Left</span>)<span class="kw">.</span>         <span class="co">% Recurso à esquerda.</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>lookup(<span class="dt">Value</span><span class="kw">,</span> tree(<span class="dt">_</span><span class="kw">,</span> <span class="dt">NodeVal</span><span class="kw">,</span> <span class="dt">Right</span>)) <span class="kw">:-</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Value</span> <span class="dt">&gt;</span> <span class="dt">NodeVal</span><span class="kw">,</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    lookup(<span class="dt">Value</span><span class="kw">,</span> <span class="dt">Right</span>)<span class="kw">.</span>        <span class="co">% Recurso à direita.</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">% insert(Valor, Arvore_Antiga, Nova_Arvore)</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="co">% Insere um valor na árvore, criando uma nova árvore.</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>insert(<span class="dt">Value</span><span class="kw">,</span> nil<span class="kw">,</span> tree(nil<span class="kw">,</span> <span class="dt">Value</span><span class="kw">,</span> nil))<span class="kw">.</span> <span class="co">% Caso base: insere numa árvore vazia.</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>insert(<span class="dt">Value</span><span class="kw">,</span> tree(<span class="dt">L</span><span class="kw">,</span> <span class="dt">V</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span> tree(<span class="dt">NL</span><span class="kw">,</span> <span class="dt">V</span><span class="kw">,</span> <span class="dt">R</span>)) <span class="kw">:-</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Value</span> <span class="dt">&lt;</span> <span class="dt">V</span><span class="kw">,</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    insert(<span class="dt">Value</span><span class="kw">,</span> <span class="dt">L</span><span class="kw">,</span> <span class="dt">NL</span>)<span class="kw">.</span>        <span class="co">% Constrói uma nova sub-árvore à esquerda.</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>insert(<span class="dt">Value</span><span class="kw">,</span> tree(<span class="dt">L</span><span class="kw">,</span> <span class="dt">V</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span> tree(<span class="dt">L</span><span class="kw">,</span> <span class="dt">V</span><span class="kw">,</span> <span class="dt">NR</span>)) <span class="kw">:-</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Value</span> <span class="dt">&gt;</span> <span class="dt">V</span><span class="kw">,</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    insert(<span class="dt">Value</span><span class="kw">,</span> <span class="dt">R</span><span class="kw">,</span> <span class="dt">NR</span>)<span class="kw">.</span>        <span class="co">% Constrói uma nova sub-árvore à direita.</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>insert(<span class="dt">Value</span><span class="kw">,</span> tree(<span class="dt">L</span><span class="kw">,</span> <span class="dt">Value</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span> tree(<span class="dt">L</span><span class="kw">,</span> <span class="dt">Value</span><span class="kw">,</span> <span class="dt">R</span>))<span class="kw">.</span> <span class="co">% Valor já existe, não faz nada.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>O processo de transversalidade é impulsionado pela busca do Prolog por uma cabeça de cláusula que possa unificar:</p>
<ul>
<li><strong>Busca (<code>lookup</code>)</strong>: Numa consulta <code>?- lookup(15, tree(nil, 20, nil)).</code>:
<ol type="1">
<li>A primeira cláusula, <code>lookup(15, tree(_, 15, _))</code>, falha porque <code>20</code> não unifica com <code>15</code>;</li>
<li>A terceira cláusula, que testa <code>15 &gt; 20</code>, falha;</li>
<li>A segunda cláusula é tentada. O teste <code>15 &lt; 20</code> tem sucesso. O Prolog avança para a chamada recursiva: <code>lookup(15, nil)</code>;</li>
<li>Nenhuma cláusula de <code>lookup</code> consegue unificar com <code>lookup(15, nil)</code>, portanto a consulta falha, corretamente indicando que o valor não existe.</li>
</ol></li>
<li><strong>Inserção (<code>insert</code>)</strong>: Numa consulta <code>?- insert(25, tree(nil, 20, nil), T).</code>:
<ol type="1">
<li>A primeira cláusula (inserir em <code>nil</code>) falha;</li>
<li>A segunda cláusula (<code>25 &lt; 20</code>) falha;</li>
<li>A terceira cláusula (<code>25 &gt; 20</code>) tem sucesso. A sua cabeça é <code>insert(Value, tree(L, V, R), tree(L, V, NR))</code>;
<ul>
<li><code>Value</code> é <code>25</code>, <code>L</code> é <code>nil</code>, <code>V</code> é <code>20</code>, <code>R</code> é <code>nil</code>;</li>
<li>A nova árvore a ser criada, <code>T</code>, é parcialmente unificada com <code>tree(nil, 20, NR)</code>, na qual <code>NR</code> (a nova sub-árvore direita) ainda é uma variável livre;</li>
<li>A chamada recursiva é <code>insert(25, nil, NR)</code>;</li>
</ul></li>
<li>Esta chamada recursiva unifica com a primeira cláusula de <code>insert</code>. <code>NR</code> é unificada com <code>tree(nil, 25, nil)</code>.</li>
<li>Como <code>NR</code> fazia parte da estrutura de <code>T</code>, a unificação propaga-se para cima. <code>T</code> fica finalmente instanciada como <code>tree(nil, 20, tree(nil, 25, nil))</code>. A nova árvore foi construída durante o retorno da recursão.</li>
</ol></li>
</ul>
</section>
</section>
<section id="controle-manual-da-busca-o-operador-de-corte" class="level2" data-number="11.5">
<h2 data-number="11.5" class="anchored" data-anchor-id="controle-manual-da-busca-o-operador-de-corte"><span class="header-section-number">11.5</span> Controle Manual da Busca: O Operador de Corte (<code>!</code>)</h2>
<p>O operador de corte, <code>!</code>, é o principal mecanismo de controle procedural em Prolog. Ele representa uma concessão do modelo puramente declarativo ao pragmatismo procedural, permitindo ao programador intervir diretamente no comportamento de busca do mecanismo de inferência e podar manualmente a árvore de busca <strong>SLD</strong>.</p>
<p>O corte é um objetivo, escrito como <code>!</code>, que tem sempre sucesso imediato quando é encontrado. O seu poder reside no seu efeito secundário: uma vez executado, o corte <strong>compromete</strong> o mecanismo de inferência com todas as escolhas feitas desde que o objetivo pai (a cabeça da cláusula que contém o corte) foi unificado. Este compromisso tem dois efeitos principais:</p>
<ol type="1">
<li>Descarta todas as outras cláusulas para o predicado atual que aparecem abaixo daquela que contém o corte.</li>
<li>Descarta todos os pontos de escolha criados pelos objetivos à <strong>esquerda</strong> do corte, dentro do corpo da cláusula atual.</li>
</ol>
<p>Uma metáfora útil é pensar no corte como uma barreira ou um portão de sentido único na árvore de busca. O <em>backtracking</em> pode ocorrer livremente entre os objetivos à direita do corte. No entanto, se a computação falhar à direita do corte e tentar fazer <em>backtrack</em> <em>através</em> dele, o objetivo pai falha imediatamente, e nenhuma outra alternativa é considerada.</p>
<section id="cortes-verdes-poda-para-eficiência" class="level3" data-number="11.5.1">
<h3 data-number="11.5.1" class="anchored" data-anchor-id="cortes-verdes-poda-para-eficiência"><span class="header-section-number">11.5.1</span> Cortes Verdes: Poda para Eficiência</h3>
<p>Um <strong>corte verde</strong>, do inglês <em>green cut</em>, é aquele cujo uso não altera o significado declarativo do programa, ou seja, não altera o conjunto de soluções encontradas. A sua única função é melhorar a eficiência, podando ramos da árvore de busca que se sabe serem redundantes ou que levarão a uma falha garantida. O exemplo clássico é o predicado <code>max/3</code> para encontrar o máximo de dois números:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>max(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> <span class="dt">X</span>) <span class="kw">:-</span> <span class="dt">X</span> \&gt;= <span class="dt">Y</span><span class="kw">,</span><span class="al">\</span><span class="kw">!.</span> </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>max(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span> <span class="dt">X</span> \&lt; <span class="dt">Y</span><span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Neste caso, as duas cláusulas são mutuamente exclusivas. Se a condição <code>X &gt;= Y</code> for verdadeira, sabemos que <code>X</code> é o máximo, e a segunda cláusula (<code>X &lt; Y</code>) será necessariamente falsa. O corte simplesmente informa o mecanismo de inferência: <em>Em contraste a única resposta correta para este caso. Não se preocupe em criar um ponto de escolha para tentar a outra cláusula, pois seria uma perda de tempo</em>. A remoção do corte não alteraria as respostas corretas, mas faria com que o mecanismo de inferência realizasse trabalho desnecessário.</p>
</section>
<section id="cortes-vermelhos-alterando-a-lógica" class="level3" data-number="11.5.2">
<h3 data-number="11.5.2" class="anchored" data-anchor-id="cortes-vermelhos-alterando-a-lógica"><span class="header-section-number">11.5.2</span> Cortes Vermelhos: Alterando a Lógica</h3>
<p>Um <strong>corte vermelho</strong>, do inglês <em>red cut</em>, é aquele que <em>altera</em> o significado declarativo do programa. A sua remoção levaria à produção de mais soluções ou de soluções diferentes e, muitas vezes, incorretas. Os cortes vermelhos tornam a correção do programa dependente da ordem específica das cláusulas e do fluxo procedural, comprometendo a sua pureza lógica. Um exemplo comum é a implementação de uma estrutura <em>if-then-else</em>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">% ifte(Condicao, Entao, Senao)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>ifte(<span class="dt">C</span><span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span> <span class="dt">_</span>) <span class="kw">:-</span> <span class="dt">C</span><span class="kw">,</span> <span class="kw">!,</span> <span class="dt">T</span><span class="kw">.</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>ifte(<span class="dt">_</span><span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dt">E</span>) <span class="kw">:-</span> <span class="dt">E</span><span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Aqui, se <code>C</code> tiver sucesso, o corte é executado, comprometendo o mecanismo de inferência com a primeira cláusula, e <code>T</code> é executado. Se <code>C</code> falhar, o mecanismo de inferência faz <em>backtrack</em>, pois o corte não foi alcançado, tenta a segunda cláusula e executa <code>E</code>. Este corte é <em>vermelho</em> porque a segunda cláusula, <code>ifte(_, _, E) :- E.</code>, não é logicamente correta por si só; ela só funciona como o ramo <em>else</em> porque está protegida pelo corte na primeira cláusula. Sem o corte, a consulta <code>ifte(true, success, fail)</code> produziria duas soluções, <code>success</code> e <code>fail</code>, o que é logicamente incorreto.</p>
</section>
<section id="caso-de-uso-comum-negação-como-falha" class="level3" data-number="11.5.3">
<h3 data-number="11.5.3" class="anchored" data-anchor-id="caso-de-uso-comum-negação-como-falha"><span class="header-section-number">11.5.3</span> Caso de Uso Comum: Negação como Falha</h3>
<p>A implementação do operador de negação do Prolog, <code>\+</code>, lê-se <em>não provável</em>, é o exemplo de um corte vermelho combinado com o predicado <code>fail</code>, que falha sempre.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode prolog code-with-copy"><code class="sourceCode prolog"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>not(<span class="dt">Goal</span>) <span class="kw">:-</span> <span class="kw">call</span>(<span class="dt">Goal</span>)<span class="kw">,</span> <span class="kw">!,</span> <span class="kw">fail.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>not(<span class="dt">_</span>)<span class="kw">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A lógica é a seguinte: para provar <code>not(Goal)</code>, o Prolog primeiro tenta provar <code>Goal</code> através de <code>call(Goal)</code>. Se <code>call(Goal)</code> tiver sucesso, o corte é executado, comprometendo a execução com esta cláusula, e de seguida <code>fail</code> é chamado, o que faz com que o predicado <code>not(Goal)</code> falhe. Se, no entanto, <code>call(Goal)</code> falhar inicialmente, o mecanismo de inferência faz <em>backtrack</em> para a segunda cláusula, <code>not(_)</code>, que tem sempre sucesso. Este mecanismo inverte efetivamente o sucesso/falha do objetivo original, implementando a <strong>negação como falha</strong>, do inglês, <em>negation as failure</em>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./07a-criando-mundos-praticas.html" class="pagination-link" aria-label="Criando Mundos: Práticas 2025">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Criando Mundos: Práticas 2025</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./08-verificacao-formal-de-programas.html" class="pagination-link" aria-label="Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural">
        <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/07b-inferencia-prolog.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>