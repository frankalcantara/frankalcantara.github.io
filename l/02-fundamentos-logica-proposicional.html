<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 3&nbsp; Lógica de Primeira Ordem</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./03-arte-da-prova-e-analise-de-argumentos.html" rel="next">
<link href="./01-jornada-programacao-logica.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-jornada-programacao-logica.html">Fundamentos da Lógica</a></li><li class="breadcrumb-item"><a href="./02-fundamentos-logica-proposicional.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title"><strong>Lógica de Primeira Ordem</strong></span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title"><strong>Lógica de Primeira Ordem</strong></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Provas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Formas Normais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Mundos na <strong>Lógica de Primeira Ordem</strong></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Cláusulas de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Problemas Interessantes Resolvidos com Lógica Proposicional e Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#lógica-proposicional" id="toc-lógica-proposicional" class="nav-link active" data-scroll-target="#lógica-proposicional"><span class="header-section-number">3.1</span> Lógica Proposicional</a>
  <ul class="collapse">
  <li><a href="#regras-de-inferência" id="toc-regras-de-inferência" class="nav-link" data-scroll-target="#regras-de-inferência"><span class="header-section-number">3.1.1</span> Regras de Inferência</a></li>
  <li><a href="#classificação-das-fórmulas-proposicionais" id="toc-classificação-das-fórmulas-proposicionais" class="nav-link" data-scroll-target="#classificação-das-fórmulas-proposicionais"><span class="header-section-number">3.1.2</span> Classificação das Fórmulas Proposicionais</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/02-fundamentos-logica-proposicional.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-jornada-programacao-logica.html">Fundamentos da Lógica</a></li><li class="breadcrumb-item"><a href="./02-fundamentos-logica-proposicional.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title"><strong>Lógica de Primeira Ordem</strong></span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title"><strong>Lógica de Primeira Ordem</strong></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>A <strong>Lógica de Primeira Ordem</strong> é uma estrutura básica da ciência da computação e da programação. Ela nos permite discursar e raciocinar com precisão sobre os elementos - podemos fazer afirmações sobre todo um grupo, ou sobre um único elemento em particular. No entanto, tem suas limitações. Na <strong>Lógica de Primeira Ordem</strong> clássica não podemos fazer afirmações diretas sobre predicados ou funções. Entretanto, algumas extensões, como a Lógica de Segunda Ordem, permitem fazer afirmações sobre predicados e funções.</p>
<p>Essa restrição não é um defeito, mas sim um equilíbrio cuidadoso entre poder expressivo e simplicidade computacional. Dá-nos uma forma de formular uma grande variedade de problemas, sem tornar o processo de resolução desses problemas excessivamente complexo.</p>
<p>A <strong>Lógica de Primeira Ordem</strong> é o nosso ponto de partida, nossa base, a pedra fundamental. Uma forma poderosa e útil de olhar para o universo, não tão complicada que seja hermética a olhos leigos, mas suficientemente complexa para permitir a descoberta de alguns dos mistérios da matemática e, no processo, resolver alguns problemas práticos.</p>
<p>A <strong>Lógica de Primeira Ordem</strong> consiste de uma linguagem, consequentemente criada a partir de um alfabeto <span class="math inline">\(\Sigma\)</span>, de um conjunto de axiomas e de um conjunto de regras de inferência. Esta linguagem consiste de todas as fórmulas bem formadas da teoria da Lógica Proposicional e predicativa. O conjunto de axiomas é um subconjunto do conjunto de fórmulas bem formadas acrescido e, finalmente, um conjunto de regras de inferência.</p>
<p>O alfabeto <span class="math inline">\(\Sigma\)</span> que estamos definindo poderá ser dividido em classes formadas por conjuntos de símbolos agrupados por semelhança. Assim:</p>
<ol type="1">
<li><p><strong>variáveis, constantes e símbolos de pontuação</strong>: vamos usar os símbolos do alfabeto latino em minúsculas e alguns símbolos de pontuação. Destaque-se os símbolos <span class="math inline">\((\)</span> e <span class="math inline">\()\)</span>, parênteses, usados para definir a prioridade de operações. Vamos usar os símbolos <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>, <span class="math inline">\(w\)</span>, <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> e <span class="math inline">\(z\)</span> para indicar variáveis e <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(d\)</span> e <span class="math inline">\(e\)</span> para indicar constantes.</p></li>
<li><p><strong>funções</strong>: usaremos os símbolos <span class="math inline">\(\mathbf{f}\)</span>, <span class="math inline">\(\mathbf{g}\)</span>, <span class="math inline">\(\mathbf{h}\)</span> e <span class="math inline">\(\mathbf{i}\)</span> Para indicar funções.</p></li>
<li><p><strong>predicados</strong>: usaremos letras do alfabeto latino, maiúsculas <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span> e <span class="math inline">\(S\)</span>, ou simplesmente <em>strings</em> como <span class="math inline">\(\text{MaiorQue}\)</span> ou <span class="math inline">\(\text{IgualA}\)</span> para indicar predicados. Sempre começando com letras maiúsculas.</p></li>
<li><p><strong>operadores</strong>: usaremos os símbolos tradicionais da Lógica Proposicional: <span class="math inline">\(\neg\)</span> (negação), $$ (conjunção, <strong>AND</strong>), $$ (disjunção, <em>or</em>), <span class="math inline">\(\rightarrow\)</span> (implicação) e <span class="math inline">\(\leftrightarrow\)</span> (equivalência).</p></li>
<li><p><strong>quantificadores</strong>: seguiremos, de perto, a tradição matemática usando $$ (quantificador existencial) e $$ (quantificador universal).</p></li>
<li><p><strong>Fórmulas Bem Formadas</strong>: usaremos para representar as Fórmulas Bem Formadas: <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span>, <span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span>.</p></li>
</ol>
<p>Na lógica matemática, uma <strong>Fórmula Bem Formada</strong>, ou Expressão Bem Formada, é uma sequência <strong>finita</strong> de símbolos formada de acordo com as regras gramaticais de uma linguagem formal especificamente desenvolvida para a redação das fórmulas da lógica.</p>
<p><em>Em <strong>Lógica de Primeira Ordem</strong>, uma <strong>Fórmula Bem Formada</strong> é uma expressão que <strong>só pode ser</strong> verdadeira ou falsa</em>. As Fórmulas Bem Formadas são compostas de símbolos que representam quantificadores, variáveis, constantes, predicados, e conectivos lógicos. Cuja distribuição e uso seguirão as regras sintáticas, gramaticais e semânticas da linguagem da lógica. Aprender lógica é aprender esta linguagem.</p>
<p>Em qualquer linguagem matemática, sem dúvida, a regra sintática mais importante é a precedência das operações, uma espécie de receita indexada. Que deve ser seguida à letra. Neste texto, vamos nos restringir a seguinte ordem de precedência:</p>
<p><span class="math display">\[\neg, \forall, \exists, \wedge, \vee, \rightarrow, \leftrightarrow\]</span></p>
<p>Dando maior precedência a <span class="math inline">\(\neg\)</span> (negação) e a menor a <span class="math inline">\(\leftrightarrow\)</span> (equivalência). Além disso, os parenteses <span class="math inline">\((\)</span> e <span class="math inline">\()\)</span> são usados para agrupar expressões e definir a ordem de precedência. O uso dos parênteses e da ordem de precedência requer cautela, muita cautela. Os parênteses permitem que possamos escrever <span class="math inline">\((\forall x(\exists y (\mathbf{p}(x,y)\rightarrow \mathbf{q}(x))))\)</span> ou <span class="math inline">\(\forall x \exists y (\mathbf{p}(x,y)\rightarrow \mathbf{q}(x))\,\)</span> duas expressões diferentes que são a mesma <strong>Fórmula Bem Formada</strong>. Escolha a opção que seja mais fácil de ler, entender e explicar.</p>
<p>Na linguagem da lógica cada sentença, ou proposição, deve ser verdadeira ou falsa, nunca pode ser verdadeira e falsa ao mesmo tempo, e não pode ser algo diferente de verdadeiro ou falso. Para que uma sentença, ou proposição, seja verdadeira ela precisa ser logicamente verdadeira. Uma sentença contraditória é aquela que é sempre falsa, independentemente da interpretação.</p>
<p>Da mesma forma que aprendemos nossa língua materna reconhecendo padrões, repetições e regularidades, também reconhecemos Fórmulas Bem Formadas por seus padrões característicos. os símbolos estarão dispostos de forma organizada em termos sobre os quais se aplicam operações, funções e quantificadores.</p>
<p>Termos são variáveis, constantes ou mesmo funções aplicadas a termos e seguem um pequeno conjunto de regras:</p>
<ol type="1">
<li>uma variável <span class="math inline">\(x\)</span> é um termo em si;</li>
<li>uma constante <span class="math inline">\(a\)</span> é um termo em si; uma proposição que a contenha será verdadeira <span class="math inline">\((T)\)</span> ou falsa <span class="math inline">\((F)\)</span>;</li>
<li>se <span class="math inline">\(\mathbf{f}\)</span> é uma função de termos <span class="math inline">\((t_1, ... t_n)\)</span> então <span class="math inline">\(\mathbf{f}(t_1, ... t_n)\)</span> é um termo.</li>
</ol>
<p><strong>Cada proposição, ou sentença, na Lógica Proposicional é um fato fundamental e indivisível</strong>. <em>A chuva cai</em>, <em>O sol brilha</em> - cada uma dessas proposições é verdadeira ou falsa por si só, como uma unidade, um átomo, elemento básico e fundamental de todas as expressões. Mais tarde, chamaremos de átomos a todo predicado aplicado aos termos de uma fórmula. Assim, precisamos definir os predicados.</p>
<ol type="1">
<li>se <span class="math inline">\(P\)</span> é um predicado de termos <span class="math inline">\((t_1, ... t_n)\)</span> então <span class="math inline">\(P(t_1, ... t_n)\)</span> é uma <strong>Fórmula Bem Formada</strong>, um átomo.</li>
<li>se <span class="math inline">\(P\)</span> e <span class="math inline">\(Q\)</span> são Fórmulas Bem Formadas então: <span class="math inline">\(\neg P\)</span>, <span class="math inline">\(P\wedge Q\)</span>, <span class="math inline">\(P \vee Q\)</span>, <span class="math inline">\(P \rightarrow Q\)</span> e <span class="math inline">\(P \leftrightarrow Q\)</span> são Fórmulas Bem Formadas.</li>
<li>se <span class="math inline">\(P\)</span> é uma <strong>Fórmula Bem Formada</strong> e <span class="math inline">\(x\)</span> uma variável então <span class="math inline">\(\exists x P(x)\)</span> e <span class="math inline">\(\forall x P(x)\)</span> são Fórmulas Bem Formadas.</li>
</ol>
<p>Podemos dizer que as Fórmulas Bem Formadas respeitam as regras de precedência entre conectivos, parênteses e quantificadores; não apresentam problemas como variáveis livres não quantificadas e, principalmente, são unívocas, sem ambiguidade na interpretação.</p>
<p>Finalmente podemos definir a linguagem da <strong>Lógica de Primeira Ordem</strong> como o conjunto de todas as Fórmulas Bem Formadas criadas a partir dos campos de estudo da Lógica Proposicional e da Lógica de Predicados. Termos e átomos interligados em uma teia, em que cada termo ou átomo é como uma ilha de verdade. <em>A chuva cai</em>, <em>O sol brilha</em>. Cada uma dessas proposições é verdadeira ou falsa, em si, uma unidade, como uma ilha. As operações lógicas são as pontes que conectam essas ilhas, permitindo-nos construir as estruturas mais complexas da razão.</p>
<section id="lógica-proposicional" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="lógica-proposicional"><span class="header-section-number">3.1</span> Lógica Proposicional</h2>
<p>Esse sistema, também chamado de álgebra booleana, fundamental para o desenvolvimento da computação, é uma verdadeira tapeçaria de possibilidades. <strong>Na Lógica Proposicional, declarações atômicas, que só podem ter valores verdadeiro, <span class="math inline">\(T\)</span>, ou falso <span class="math inline">\(F\)</span>, são entrelaçadas em declarações compostas cuja veracidade, segundo as regras desse cálculo, depende dos valores de verdade das declarações atômicas que as compõem quando sujeitas aos operadores, ou aos conectivos, que definimos anteriormente</strong>.</p>
<p>Vamos representar essas declarações atômicas por literais <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> etc., e suas negações por <span class="math inline">\(\neg A\)</span>, <span class="math inline">\(\neg B\)</span>, <span class="math inline">\(\neg X_1\)</span>, <span class="math inline">\(\neg X_2\)</span> etc. Todos os símbolos individuais e suas negações são conhecidos como literais.</p>
<p>Na Lógica Proposicional, as fórmulas são conhecidas como Fórmulas Bem Formadas. Elas podem ser atômicas ou compostas. Nas fórmulas compostas, um operador principal liga duas fórmulas atômicas ou duas compostas.</p>
<p>As declarações atômicas e compostas são costuradas por conectivos para produzir declarações compostas, cujo valor de verdade depende dos valores de verdade das declarações componentes. Os conectivos que consideramos inicialmente, e suas tabelas verdade serão:</p>
<table class="table">
<colgroup>
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(P\)</span></th>
<th><span class="math inline">\(Q\)</span></th>
<th><span class="math inline">\(P\vee Q\)</span></th>
<th><span class="math inline">\(P\wedge Q\)</span></th>
<th><span class="math inline">\(\neg P\)</span></th>
<th><span class="math inline">\(P\rightarrow Q\)</span></th>
<th><span class="math inline">\(P\leftrightarrow Q\)</span></th>
<th><span class="math inline">\(P\oplus Q\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>T</td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
</tr>
<tr class="even">
<td>T</td>
<td>F</td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
</tr>
<tr class="odd">
<td>F</td>
<td>T</td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(F\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(T\)</span></td>
<td><span class="math inline">\(F\)</span></td>
</tr>
</tbody>
</table>
<p><em>Tabela 1 - Tabela Verdade, operadores básicos.</em>{: class=“legend”}</p>
<p>Quando usamos a Tabela Verdade em uma declaração composta, podemos ver se ela é verdadeira ou falsa. Basta seguir as regras de precedência e aplicar a Tabela Verdade, simplificando a expressão. É uma alternativa mais direta do que o uso dos axiomas da Lógica Proposicional.</p>
<p>O operador <span class="math inline">\(\vee\)</span>, também chamado de ou inclusivo, é verdade quando pelo menos um dos termos é verdadeiro. Diferindo de um operador, que por não ser básico e fundamental, não consta da nossa lista, chamado de ou exclusivo, <span class="math inline">\(\oplus\)</span>, falso se ambos os termos forem iguais, ou verdadeiros ou falsos.</p>
<p>O condicional <span class="math inline">\(\rightarrow\)</span> não implica em causalidade. O condicional <span class="math inline">\(\rightarrow\)</span> é falso apenas quando o antecedente é verdadeiro e o consequente é falso.</p>
<p>O bicondicional <span class="math inline">\(\leftrightarrow\)</span> equivale a ambos os componentes terem o mesmo valor-verdade. Todos os operadores, ou conectivos, conectam duas declarações, exceto <span class="math inline">\(\neg\)</span> que se aplica a apenas um termo.</p>
<p>Cada operador com sua própria aridade:</p>
<table class="table">
<thead>
<tr class="header">
<th>No Argumentos</th>
<th>Aridade</th>
<th>Exemplos</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Nulo</td>
<td><span class="math inline">\(5\)</span>, <span class="math inline">\(False\)</span>, Constantes</td>
</tr>
<tr class="even">
<td>1</td>
<td>Unário</td>
<td><span class="math inline">\(P(x)\)</span>, <span class="math inline">\(7x\)</span></td>
</tr>
<tr class="odd">
<td>2</td>
<td>Binário</td>
<td><span class="math inline">\(x \vee y\)</span>, <span class="math inline">\(c \wedge y\)</span></td>
</tr>
</tbody>
</table>
<p><em>Tabela 2 - Aridade dos Operadores da Lógica Proposicional.</em>{: class=“legend”}</p>
<p>Ainda observando a Tabela 1, que contém a Tabela Verdade dos operadores da Lógica Proposicional, é fácil perceber que se tivermos quatro termos diferentes, em vez de dois, teremos <span class="math inline">\(2^4 = 16\)</span> linhas. Independentemente do número de termos, se para uma determinada <strong>Fórmula Bem Formada</strong> todos os resultados forem verdadeiros, <span class="math inline">\(T\)</span>, teremos uma <em>tautologia</em>, se todos forem falsos, <span class="math inline">\(F\)</span> uma <em>contradição</em>.</p>
<p><strong>Uma tautologia é uma fórmula que é sempre verdadeira, não importa os valores dados às variáveis</strong>. Na Programação Lógica, tautologias são verdades universais no domínio do problema. Uma contradição é uma fórmula que é sempre falsa, independentemente dos valores das variáveis. Em Programação Lógica, contradições mostram inconsistências ou impossibilidades lógicas no domínio.</p>
<p>Identificar tautologias permite simplificar expressões e fazer inferências válidas automaticamente. Reconhecer contradições evita o custo de tentar provar algo logicamente impossível.</p>
<p>Linguagens de programação que usam a Programação Lógica usam <strong>unificação</strong> e resolução para fazer deduções. Tautologias geram cláusulas vazias que simplificam esta resolução. Em problemas de <strong>satisfatibilidade</strong>, se obtivermos uma contradição, sabemos que as premissas são insatisfatíveis. Segure as lágrimas e o medo. Os termos <strong>unificação</strong> e <strong>satisfatibilidade</strong> serão explicados assim que sejam necessários. Antes disso, precisamos falar de <em>equivalências</em>. Para isso vamos incluir um metacaractere no alfabeto da nossa linguagem: o caractere <span class="math inline">\(\equiv\)</span> que permitirá o entendimento das principais equivalências da Lógica Proposicional explicitadas a seguir:</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Expressão Lógica Equivalente</th>
<th>Nome da Lei/Propriedade</th>
<th>Ref.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(P \land Q \equiv Q \land P\)</span></td>
<td>Comutatividade da Conjunção</td>
<td>(1)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P \lor Q \equiv Q \lor P\)</span></td>
<td>Comutatividade da Disjunção</td>
<td>(2)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \land (Q \lor R) \equiv (P \land Q) \lor (P \land R)\)</span></td>
<td>Distributividade da Conjunção sobre a Disjunção</td>
<td>(3)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P \lor (Q \land R) \equiv (P \lor Q) \land (P \lor R)\)</span></td>
<td>Distributividade da Disjunção sobre a Conjunção</td>
<td>(4)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\neg (P \land Q) \equiv \neg P \lor \neg Q\)</span></td>
<td>Lei de De Morgan</td>
<td>(5)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\neg (P \lor Q) \equiv \neg P \land \neg Q\)</span></td>
<td>Lei de De Morgan</td>
<td>(6)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \rightarrow Q \equiv \neg P \lor Q\)</span></td>
<td>Definição de Implicação</td>
<td>(7)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P \leftrightarrow Q \equiv (P \rightarrow Q) \land (Q \rightarrow P)\)</span></td>
<td>Definição de Equivalência</td>
<td>(8)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \rightarrow Q \equiv \neg Q \rightarrow \neg P\)</span></td>
<td>Lei da Contrapositiva</td>
<td>(9)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P \land \neg P \equiv F\)</span></td>
<td>Lei da Contradição</td>
<td>(10)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \lor \neg P \equiv T\)</span></td>
<td>Lei do Terceiro Excluído</td>
<td>(11)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\neg(\neg P) \equiv P\)</span></td>
<td>Lei da Dupla Negação</td>
<td>(12)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \equiv P\)</span></td>
<td>Lei da Identidade</td>
<td>(13)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P \land T \equiv P\)</span></td>
<td>Lei da Identidade para a Conjunção</td>
<td>(14)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \land F \equiv F\)</span></td>
<td>Lei do Domínio para a Conjunção</td>
<td>(15)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P \lor T \equiv T\)</span></td>
<td>Lei do Domínio para a Disjunção</td>
<td>(16)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \lor F \equiv P\)</span></td>
<td>Lei da Identidade para a Disjunção</td>
<td>(17)</td>
</tr>
<tr class="even">
<td><span class="math inline">\((P \land Q) \land R \equiv P \land (Q \land R)\)</span></td>
<td>Associatividade da Conjunção</td>
<td>(18)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\((P \lor Q) \lor R \equiv P \lor (Q \lor R)\)</span></td>
<td>Associatividade da Disjunção</td>
<td>(19)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P \land P \equiv P\)</span></td>
<td>Idempotência da Conjunção</td>
<td>(20)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P \lor P \equiv P\)</span></td>
<td>Idempotência da Disjunção</td>
<td>(21)</td>
</tr>
</tbody>
</table>
<p><em>Tabela 3 - Equivalências em Lógica Proposicional.</em>{: class=“legend”}</p>
<p>Como essas equivalências permitem validar Fórmulas Bem Formadas sem o uso de uma tabela verdade. Uma coisa interessante seria tentar provar cada uma delas. Mas, isso fica, por enquanto, a cargo da amável leitora.</p>
<p>AAs equivalências que mencionei surgiram quase naturalmente enquanto escrevia, mais por hábito e necessidade do que por um raciocínio organizado. Existem muitas equivalências, mas essas são as que uso com mais frequência. Talvez, alguns exemplos de validação de Fórmulas Bem Formadas, usando apenas as equivalências da Tabela 3, possam inflar as velas do conhecimento e nos guiar pelo caminho que devemos seguir:</p>
<p><strong>Exemplo 1</strong>: <span class="math inline">\(P \wedge (Q \vee (P \wedge R))\)</span></p>
<p><span class="math display">\[
\begin{align*}
P \wedge (Q \vee (P \wedge R)) &amp;\equiv (P \wedge Q) \vee (P \wedge (P \wedge R)) &amp;&amp; \text{Distributividade da Conjunção sobre a Disjunção (3)} \\
&amp;\equiv (P \wedge Q) \vee ((P \wedge P) \wedge R) &amp;&amp; \text{Associatividade da Conjunção (20)} \\
&amp;\equiv (P \wedge Q) \vee (P \wedge R) &amp;&amp; \text{Idempotência da Conjunção (P} \wedge \text{P} \equiv \text{P)}
\end{align*}
\]</span></p>
<p><strong>Nota</strong>: A lei da Idempotência (<span class="math inline">\(P \wedge P \equiv P\)</span>) não está na Tabela 3.</p>
<p><strong>Exemplo 2</strong>:<span class="math inline">\(P\rightarrow (Q \wedge (R \vee P))\)</span></p>
<p><span class="math display">\[
\begin{align*}
P \rightarrow (Q \wedge (R \vee P)) &amp;\equiv \neg P \vee (Q \wedge (R \vee P)) &amp;&amp; \text{(7)} \\
&amp;\equiv (\neg P \vee Q) \wedge (\neg P \vee (R \vee P)) &amp;&amp; \text{(4)} \\
&amp;\equiv (\neg P \vee Q) \wedge (R \vee \neg P \vee P) &amp;&amp; \text{(2)} \\
&amp;\equiv (\neg P \vee Q) \wedge T &amp;&amp; \text{(11)} \\
&amp;\equiv \neg P \vee Q &amp;&amp; \text{(14)}
\end{align*}
\]</span></p>
<p><strong>Exemplo 3</strong>: <span class="math inline">\(\neg (P \wedge (Q \rightarrow R))\)</span></p>
<p><span class="math display">\[
\begin{align*}
\neg (P \wedge (Q \rightarrow R)) &amp;\equiv \neg (P \wedge (\neg Q \vee R)) &amp;&amp; \text{(7)} \\
&amp;\equiv \neg P \vee \neg (\neg Q \vee R) &amp;&amp; \text{(5)} \\
&amp;\equiv \neg P \vee (Q \wedge \neg R) &amp;&amp; \text{(6)}
\end{align*}
\]</span></p>
<p><strong>Exemplo 4</strong>: <span class="math inline">\(\neg ((P \rightarrow Q) \wedge (R \rightarrow S))\)</span></p>
<p><span class="math display">\[
\begin{align*}
\neg ((P \rightarrow Q) \wedge (R \rightarrow S)) &amp;\equiv \neg ((\neg P \vee Q) \wedge (\neg R \vee S)) &amp;&amp; \text{(7)} \\
&amp;\equiv \neg (\neg P \vee Q) \vee \neg (\neg R \vee S) &amp;&amp; \text{(5)} \\
&amp;\equiv (P \wedge \neg Q) \vee (R \wedge \neg S) &amp;&amp; \text{(6)}
\end{align*}
\]</span></p>
<p><strong>Exemplo 5</strong>: <span class="math inline">\((P \rightarrow Q) \vee (R \rightarrow S) \vee (E \rightarrow P)\)</span></p>
<p><span class="math display">\[
\begin{align*}
(P \rightarrow Q) \vee (R \rightarrow S) \vee (E \rightarrow P) &amp;\equiv (\neg P \vee Q) \vee (\neg R \vee S) \vee (\neg E \vee P) &amp;&amp; \text{(7)} \\
&amp;\equiv \neg P \vee Q \vee \neg R \vee S \vee \neg E \vee P &amp;&amp; \text{(2)}\\
&amp;\equiv TRUE \vee Q \vee \neg R \vee S \vee \neg E &amp;&amp; \text{(11)}\\
&amp;\equiv TRUE \vee Q \vee \neg R \vee S \vee \neg E &amp;&amp; \text{(11)}\\
&amp;\equiv TRUE
\end{align*}
\]</span></p>
<p><strong>Exemplo 6</strong>: <span class="math inline">\(P\wedge (Q \vee (R \rightarrow S)) \vee (\neg E \leftrightarrow P)\)</span></p>
<p>Vamos simplificar a expressão passo a passo, indicando as leis da Tabela 3 utilizadas:</p>
<p><span class="math display">\[
\begin{align*}
&amp;P\wedge (Q \vee (R \rightarrow S)) \vee (\neg E \leftrightarrow P) \\
&amp;\equiv P\wedge (Q \vee (\neg R \vee S)) \vee ((\neg E \rightarrow P) \wedge (P \rightarrow \neg E)) &amp;&amp; \text{Definição de Implicação (7), Definição de Equivalência (8)} \\
&amp;\equiv P\wedge (Q \vee \neg R \vee S) \vee ((\neg (\neg E) \vee P) \wedge (\neg P \vee \neg E)) &amp;&amp; \text{Associatividade da Disjunção (21), Definição de Implicação (7)} \\
&amp;\equiv P\wedge (Q \vee \neg R \vee S) \vee ((E \vee P) \wedge (\neg P \vee \neg E)) &amp;&amp; \text{Lei da Dupla Negação (12)} \\
&amp;\equiv (P\wedge Q) \vee (P\wedge \neg R) \vee (P\wedge S) \vee ((E \vee P) \wedge (\neg P \vee \neg E)) &amp;&amp; \text{Distributividade da Conjunção sobre a Disjunção (3), aplicada repetidamente} \\
&amp;\equiv (P\wedge Q) \vee (P\wedge \neg R) \vee (P\wedge S) \vee (E \wedge (\neg P \vee \neg E)) \vee (P \wedge (\neg P \vee \neg E)) &amp;&amp; \text{Distributividade da Disjunção sobre a Conjunção (4)} \\
&amp;\equiv (P\wedge Q) \vee (P\wedge \neg R) \vee (P\wedge S) \vee (E \wedge \neg P) \vee (E \wedge \neg E) \vee (P \wedge \neg P) \vee (P \wedge \neg E) &amp;&amp; \text{Distributividade da Conjunção sobre a Disjunção (3)} \\
&amp;\equiv (P\wedge Q) \vee (P\wedge \neg R) \vee (P\wedge S) \vee (E \wedge \neg P) \vee F \vee F \vee (P \wedge \neg E) &amp;&amp; \text{Lei da Contradição (e.g., } E \wedge \neg E \equiv F \text{, similar à (10))} \\
&amp;\equiv (P\wedge Q) \vee (P\wedge \neg R) \vee (P\wedge S) \vee (E \wedge \neg P) \vee (P \wedge \neg E) &amp;&amp; \text{Lei da Identidade para a Disjunção (17)}
\end{align*}
\]</span></p>
<p>Este exemplo ilustra como múltiplas leis podem ser aplicadas. A cuidadosa leitora pode verificar cada passo com atenção. A simplificação completa pode ser extensa.</p>
<p><strong>Exemplo 7</strong>: determinar se a fórmula <span class="math inline">\(\neg(P \lor (Q \land \neg R)) \leftrightarrow ((S \lor E) \rightarrow (P \land Q))\)</span> é uma equivalência lógica.</p>
<p>Para analisar esta suposta equivalência, vamos simplificar ambos os lados separadamente:</p>
<p><strong>Lado Esquerdo</strong>:</p>
<p><span class="math display">\[\begin{align*}
\neg(P \lor (Q \land \neg R)) &amp;\equiv \neg P \land \neg(Q \land \neg R) &amp; \text{(Lei de De Morgan)} \\
&amp;\equiv \neg P \land (\neg Q \lor \neg\neg R) &amp; \text{(Lei de De Morgan)} \\
&amp;\equiv \neg P \land (\neg Q \lor R) &amp; \text{(Dupla Negação)}
\end{align*}\]</span></p>
<p><strong>Lado Direito</strong>:</p>
<p><span class="math display">\[\begin{align*}
((S \lor E) \rightarrow (P \land Q)) &amp;\equiv \neg(S \lor E) \lor (P \land Q) &amp; \text{(Eliminação da Implicação)} \\
&amp;\equiv (\neg S \land \neg E) \lor (P \land Q) &amp; \text{(Lei de De Morgan)}
\end{align*}\]</span></p>
<p>Como podemos ver, os resultados finais <span class="math inline">\(\neg P \land (\neg Q \lor R)\)</span> e <span class="math inline">\((\neg S \land \neg E) \lor (P \land Q)\)</span> têm formas diferentes e envolvem variáveis diferentes. Claramente, estas expressões não são logicamente equivalentes, a menos que existam restrições adicionais entre as variáveis <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span>, <span class="math inline">\(S\)</span> e <span class="math inline">\(E\)</span>, que não foram especificadas.</p>
<p><strong>Conclusão</strong>: As expressões não são logicamente equivalentes.</p>
<p><strong>Exemplo 8</strong>:</p>
<p><span class="math inline">\(\neg(P \leftrightarrow Q) \vee ((R \rightarrow S) \wedge (\neg E \vee \neg P))\)</span></p>
<p><span class="math display">\[
\begin{align*}
\neg(P \leftrightarrow Q) \vee ((R \rightarrow S) \wedge (\neg E \vee \neg P)) &amp;\equiv \neg((P \rightarrow Q) \wedge (Q \rightarrow P)) \vee ((\neg R \vee S) \wedge (\neg E \vee \neg P)) &amp;&amp; \text{(8)}\\
&amp;\equiv (\neg(P \rightarrow Q) \vee \neg(Q \rightarrow P)) \vee ((\neg R \vee S) \wedge (\neg E \vee \neg P)) &amp;&amp; \text{(5)}\\
&amp;\equiv ((P \wedge \neg Q) \vee (Q \wedge \neg P)) \vee ((\neg R \vee S) \wedge (\neg E \vee \neg P)) &amp;&amp; \text{(6)}
\end{align*}
\]</span></p>
<p><strong>Exemplo 9</strong>: <span class="math inline">\((P \wedge Q) \vee ((\neg R \leftrightarrow S) \rightarrow (\neg E \wedge P))\)</span></p>
<p>Vamos simplificar a expressão. Para clareza, podemos denotar <span class="math inline">\(A \equiv (\neg R \leftrightarrow S)\)</span>. <span class="math display">\[
\begin{align*}
&amp;(P \wedge Q) \vee ((\neg R \leftrightarrow S) \rightarrow (\neg E \wedge P)) \\
&amp;\equiv (P \wedge Q) \vee (\neg (\neg R \leftrightarrow S) \vee (\neg E \wedge P)) &amp;&amp; \text{Definição de Implicação (7)} \\
&amp;\equiv (P \wedge Q) \vee (\neg ((\neg R \rightarrow S) \wedge (S \rightarrow \neg R)) \vee (\neg E \wedge P)) &amp;&amp; \text{Definição de Equivalência (8)} \\
&amp;\equiv (P \wedge Q) \vee (\neg (\neg (\neg R) \vee S) \vee \neg ( \neg S \vee \neg R) \vee (\neg E \wedge P)) &amp;&amp; \text{Lei de De Morgan (5), Definição de Implicação (7) (aplicada duas vezes)} \\
&amp;\equiv (P \wedge Q) \vee (\neg (R \vee S) \vee \neg ( \neg S \vee \neg R) \vee (\neg E \wedge P)) &amp;&amp; \text{Lei da Dupla Negação (12)} \\
&amp;\equiv (P \wedge Q) \vee ((\neg R \wedge \neg S) \vee (S \wedge R) \vee (\neg E \wedge P)) &amp;&amp; \text{Lei de De Morgan (6) (aplicada duas vezes), Lei da Dupla Negação (12)}
\end{align*}
\]</span></p>
<p>A atenta leitora pode notar que a negação de uma equivalência <span class="math inline">\(\neg(X \leftrightarrow Y)\)</span> também pode ser expressa como <span class="math inline">\((X \wedge \neg Y) \vee (\neg X \wedge Y)\)</span>.</p>
<p><strong>Exemplo 10</strong>: <span class="math inline">\(\neg(P \wedge (Q \vee R)) \leftrightarrow (\neg(S \rightarrow E) \vee \neg(P \rightarrow Q))\)</span></p>
<p>Vamos simplificar ambos os lados da equivalência: Lado Esquerdo (LE): <span class="math inline">\(\neg(P \wedge (Q \vee R))\)</span></p>
<p><span class="math display">\[
\begin{align*}
\text{LE} &amp;\equiv \neg P \vee \neg(Q \vee R) &amp;&amp; \text{Lei de De Morgan (5)} \\
&amp;\equiv \neg P \vee (\neg Q \wedge \neg R) &amp;&amp; \text{Lei de De Morgan (6)}
\end{align*}
\]</span></p>
<p>Lado Direito (LD): <span class="math inline">\(\neg(S \rightarrow E) \vee \neg(P \rightarrow Q)\)</span></p>
<p><span class="math display">\[
\begin{align*}
\text{LD} &amp;\equiv \neg(\neg S \vee E) \vee \neg(\neg P \vee Q) &amp;&amp; \text{Definição de Implicação (7) (aplicada duas vezes)} \\
&amp;\equiv (S \wedge \neg E) \vee (P \wedge \neg Q) &amp;&amp; \text{Lei de De Morgan (6) (aplicada duas vezes), Lei da Dupla Negação (12)}
\end{align*}
\]</span></p>
<p>Portanto, a expressão original é equivalente a:</p>
<p><span class="math display">\[
(\neg P \vee (\neg Q \wedge \neg R)) \leftrightarrow ((S \wedge \neg E) \vee (P \wedge \neg Q))
\]</span></p>
<p>Não foram utilizadas substituições temporárias como <span class="math inline">\(F\)</span> ou <span class="math inline">\(G\)</span> para manter a clareza.</p>
<p>A lógica proposicional é essencial para entendermos o mundo. É a base de argumentos sólidos e da avaliação de proposições. Nasceu da necessidade humana de buscar a verdade e resolver conflitos com a lógica. Mas sua beleza vai além da filosofia, do discurso e da matemática. É a fundação da álgebra de <a href="https://en.wikipedia.org/wiki/George_Boole">George Boole</a>, que sustenta o design de circuitos eletrônicos e a construção dos computadores modernos.</p>
<p><em>Em sua dissertação de final de curso, <a href="https://en.wikipedia.org/wiki/Claude_Shannon">Claude Shannon</a> usou a álgebra booleana para simplificar circuitos de controle. Desde então, as operações básicas dessa álgebra — <strong>AND</strong>, <strong>OR</strong>, <strong>NOT</strong> — tornaram-se os blocos fundamentais dos sistemas digitais. Elas formam o núcleo dos computadores, dos celulares e, na verdade, de toda a nossa civilização digital. A lógica proposicional é a base de todo o raciocínio lógico. Como a tabela periódica para químicos ou as leis de Newton para físicos. Ela é simples, elegante e poderosa</em>.</p>
<p>Tão importante quanto o impacto da <strong>lógica proposicional</strong> na tecnologia digital é seu papel no pensamento racional, na tomada de decisões e na prova de teoremas. Neste caminho, nosso guia são as <strong>regras de inferência</strong>.</p>
<section id="regras-de-inferência" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="regras-de-inferência"><span class="header-section-number">3.1.1</span> Regras de Inferência</h3>
<p>Regras de inferência são esquemas que proporcionam a estrutura para derivações lógicas. Base da tomada de decisão computacional. Elas definem os passos legítimos que podem ser aplicados a uma ou mais proposições, sejam elas atômicas ou Fórmulas Bem Formadas, para produzir uma proposição nova. Em outras palavras, uma regra de inferência é uma transformação sintática de Formas Bem Formadas que preserva a verdade.</p>
<p>Aqui uma regra de inferência será representada por:</p>
<p><span class="math display">\[\frac{P_1, P_2, ..., P_n}{C},\]</span></p>
<p>ou, eventualmente por:</p>
<p><span class="math display">\[P_1, P_2, ..., P_n \vdash C.\]</span></p>
<p>O conjunto formado <span class="math inline">\(P_1, P_2, ..., P_n\)</span>, chamado de contexto, ou antecedente, <span class="math inline">\(\Gamma\)</span>, e <span class="math inline">\(C\)</span>, chamado de conclusão, ou consequente, são Fórmulas Bem Formadas. A regra significa que se as proposições que constituem a conjunção expressa no contexto são verdadeiras, então a conclusão <span class="math inline">\(C\)</span>, consequência, também será verdadeira.</p>
<p>Eu vou tentar usar contexto e conclusão. Mas a compassiva leitora deve me perdoar se eu escapar para antecedente e consequente. É apenas o hábito.</p>
<p>Quando estudamos lógica, chamamos de <strong>argumento</strong> uma lista de proposições, que aqui são as premissas. Elas vêm seguidas de uma palavra ou expressão (portanto, consequentemente, desta forma) e de outra proposição, que chamamos de conclusão. A forma que usamos para representar isso é chamada de sequência de dedução. É uma forma de mostrar que, se a proposição colocada acima da linha horizontal for verdadeira, então estamos afirmando que todas as proposições <span class="math inline">\(P_1, P_2, ..., P_n\)</span> acima da linha são verdadeiras. E, por isso, a proposição abaixo da linha, a conclusão, também será verdadeira.</p>
<p><strong>As regras de inferência são o alicerce da lógica dedutiva e das provas matemáticas. Elas permitem que raciocínios complexos sejam divididos em passos simples, com cada passo sendo justificado pela aplicação de uma regra de inferência</strong>. A seguir, estão algumas das regras de inferência mais usadas:</p>
<section id="modus-ponens" class="level4" data-number="3.1.1.1">
<h4 data-number="3.1.1.1" class="anchored" data-anchor-id="modus-ponens"><span class="header-section-number">3.1.1.1</span> Modus Ponens</h4>
<p>A regra do <strong>Modus Ponens</strong> permite inferir uma conclusão a partir de uma implicação e de sua premissa antecedente. Se temos uma implicação <span class="math inline">\(P\rightarrow Q\)</span>, e sabemos que <span class="math inline">\(P\)</span> é verdadeiro, então podemos concluir que <span class="math inline">\(Q\)</span> também é verdadeiro.</p>
<p><span class="math display">\[P \rightarrow Q\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;P\\
\hline
&amp;Q\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>se chover, <span class="math inline">\((P)\)</span>, então, <span class="math inline">\((\rightarrow)\)</span>, a rua ficará molhada, <span class="math inline">\((Q)\)</span></em>;</li>
<li>Proposição 2: <em>está chovendo, <span class="math inline">\((P)\)</span> é verdadeira</em>.</li>
<li>Conclusão: logo, <em>a rua ficará molhada, <span class="math inline">\((Q)\)</span></em>.</li>
</ul>
<p>Algumas aplicações do <em>Modus Ponens</em>:</p>
<ul>
<li><p>Derivar ações de regras e leis condicionais. Por exemplo:</p>
<ul>
<li>Proposição: <em>se a velocidade, <span class="math inline">\(V\)</span>, é maior que <span class="math inline">\(80 \text{km/h}\)</span>, então é uma infração de trânsito, <span class="math inline">\(IT\)</span></em>.</li>
<li>Proposição: <em>joão está dirigindo, $ d$, A <span class="math inline">\(90 \text{km/h}\)</span></em>.</li>
<li>Conclusão: logo, <em>João cometeu uma infração de trânsito</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[V &gt; 80 \rightarrow IT\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;D = 90\\
\hline
&amp;IT
\end{aligned}
\]</span></p>
<ul>
<li><p>Aplicar implicações teóricas e chegar a novas conclusões. Por exemplo:</p>
<ul>
<li>Proposição: <em>se um número é par, <span class="math inline">\(P\)</span>, então é divisível por 2, $ d2$</em>.</li>
<li>Proposição: <em>128 é par</em>.</li>
<li>Conclusão: logo, <em>128 é divisível por 2</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[ x \text{ é par} \rightarrow \text{divisível por dois}\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;128 \text{ é par}\\
\hline
&amp;128 \text{ é divisível por 2}
\end{aligned}
\]</span></p>
<ul>
<li><p>Fazer deduções lógicas em matemática e ciência. Por exemplo:</p>
<ul>
<li>Proposição: <em>se dois lados de um triângulo têm o mesmo comprimento, então o triângulo é isósceles</em>.</li>
<li>Proposição: <em>o triângulo <span class="math inline">\(ABC\)</span> tem os lados <span class="math inline">\(AB\)</span>, <span class="math inline">\(AC\)</span> e <span class="math inline">\(BC\)</span> do mesmo comprimento</em>.</li>
<li>Conclusão: logo, <em>o triângulo <span class="math inline">\(ABC\)</span> é isósceles</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;(AB = AC) \wedge (AB=CB) \text{ no triângulo} ABC\\
\hline
&amp;\text{o triângulo } ABC \text{ é isósceles}
\end{aligned}
\]</span></p>
<ul>
<li><p>Tirar conclusões com base no raciocínio condicional na vida cotidiana. Por exemplo:</p>
<ul>
<li>Proposição: <em>se hoje não chover, então irei à praia</em>.</li>
<li>Proposição: <em>Hoje não choveu</em>.</li>
<li>Conclusão: logo, <em>irei à praia</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\neg (\text{chover hoje}) \rightarrow \text{ir à praia}\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\neg (\text{choveu hoje})\\
\hline
&amp;(\text{ir à praia})
\end{aligned}
\]</span></p>
</section>
<section id="modus-tollens" class="level4" data-number="3.1.1.2">
<h4 data-number="3.1.1.2" class="anchored" data-anchor-id="modus-tollens"><span class="header-section-number">3.1.1.2</span> Modus Tollens</h4>
<p>A regra do Modus Tollens permite inferir a negação da premissa antecedente a partir de uma implicação e da negação de sua premissa consequente. Se temos uma implicação <span class="math inline">\(P\rightarrow Q\)</span>, e sabemos que <span class="math inline">\(Q\)</span> é falso (ou seja, <span class="math inline">\(\neg G\)</span>), então podemos concluir que <span class="math inline">\(P\)</span> também é falso.</p>
<p><span class="math display">\[P \rightarrow Q\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\neg Q\\
\hline
&amp;\neg P\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição 1: <em>se uma pessoa tem 18 anos ou mais</em>, <span class="math inline">\((P)\)</span>, <em>então</em>, <span class="math inline">\((\rightarrow)\)</span> <em>ela pode votar</em>, <span class="math inline">\((Q)\)</span>;</li>
<li>Proposição 2: <em>maria não pode votar</em><span class="math inline">\((\neg Q)\)</span>;</li>
<li>Conclusão: logo, <em>maria não tem 18 anos ou mais</em>, <span class="math inline">\((\neg P)\)</span>.</li>
</ul>
<p>Algumas aplicações do Modus Tollens:</p>
<ul>
<li><p>Refutar teorias mostrando que suas previsões são falsas. Por exemplo:</p>
<ul>
<li>Proposição: <em>se a teoria da geração espontânea, <span class="math inline">\(TG\)</span> é correta, insetos irão se formar em carne deixada exposta ao ar, <span class="math inline">\(I\)</span></em>.</li>
<li>Proposição: <em>insetos não se formam em carne deixada exposta ao ar</em>.</li>
<li>Conclusão: logo, <em>a teoria da geração espontânea</em> é falsa.</li>
</ul></li>
</ul>
<p><span class="math display">\[TG \rightarrow I\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\neg I\\
\hline
\neg TG
\end{aligned}
\]</span></p>
<ul>
<li><p>Identificar inconsistências ou contradições em raciocínios. Por exemplo:</p>
<ul>
<li>Proposição: <em>se João, <span class="math inline">\(J\)</span>, é mais alto, <span class="math inline">\(&gt;\)</span>, que Maria $m $, então Maria não é mais alta que João</em>.</li>
<li>Proposição: <em>Maria é mais alta que João</em>.</li>
<li>Conclusão: logo, <em>o raciocínio é inconsistente</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[(J&gt;M) \rightarrow \neg(M&gt;J)\]</span></p>
<p><span class="math display">\[
\begin{aligned}
(M&gt;J)\\
\hline
\neg(J&gt;M)
\end{aligned}
\]</span></p>
<ul>
<li><p>Fazer deduções lógicas baseadas na negação da conclusão. Por exemplo:</p>
<ul>
<li>Proposição: <em>se hoje, <span class="math inline">\(H\)</span>, é sexta-feira, <span class="math inline">\(se\)</span>, amanhã é sábado <span class="math inline">\(SA\)</span></em>.</li>
<li>Proposição: <em>amanhã não é sábado</em>.</li>
<li>Conclusão: logo, <em>hoje não é sexta-feira</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[(H=Se) \rightarrow (A=SA)\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\neg(A=(Sa)\\
\hline
\neg(H=Se)
\end{aligned}
\]</span></p>
<ul>
<li><p>Descobrir causas de eventos por eliminação de possibilidades. Por exemplo:</p>
<ul>
<li>Proposição: <em>se a tomada está com defeito, <span class="math inline">\(D\)</span>A lâmpada não acende <span class="math inline">\(L\)</span></em>.</li>
<li>Proposição: <em>a lâmpada não acendeu</em>.</li>
<li>Conclusão: logo, <em>a tomada deve estar com defeito</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[D \rightarrow \neg L\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\neg L\\
\hline
&amp;D
\end{aligned}
\]</span></p>
</section>
<section id="dupla-negação" class="level4" data-number="3.1.1.3">
<h4 data-number="3.1.1.3" class="anchored" data-anchor-id="dupla-negação"><span class="header-section-number">3.1.1.3</span> Dupla Negação</h4>
<p>A regra da Dupla Negação permite eliminar uma dupla negação, inferindo a afirmação original. A negação de uma negação é equivalente à afirmação original. Esta regra é importante para simplificar expressões lógicas.</p>
<p><span class="math display">\[\neg \neg F\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\neg \neg F\\
\hline
&amp;F\\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;F\\
\hline
&amp;\neg \neg F\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>não é verdade, <span class="math inline">\((\neg Q)\)</span>, que maria não, <span class="math inline">\((\neg Q)\)</span>, está feliz, <span class="math inline">\((P)\)</span></em>.</li>
<li>Conclusão: logo, <em>maria está feliz, <span class="math inline">\((P)\)</span></em>.</li>
</ul>
<p>A dupla negação pode parecer desnecessária, mas ela tem algumas aplicações na lógica:</p>
<ul>
<li>Simplifica expressões logicas: remover duplas negações ajuda a simplificar e a normalizar expressões complexas, tornando-as mais fáceis de analisar. Por exemplo, transformar <em>não é verdade que não está chovendo</em> em simplesmente <em>está chovendo</em>.</li>
</ul>
<p><span class="math display">\[\neg \neg \text{Está chovendo} \Leftrightarrow \text{Está chovendo}\]</span></p>
<ul>
<li><p>Preserva o valor de verdade: inserir ou remover duplas negações não altera o valor de verdade original de uma proposição. Isso permite transformar proposições em formas logicamente equivalentes.</p></li>
<li><p>Auxilia provas indiretas: em provas por contradição, ou contrapositiva, introduzir uma dupla negação permite assumir o oposto do que se quer provar e derivar uma contradição. Isso, indiretamente, prova a proposição original.</p></li>
<li><p>Conecta Lógica Proposicional e de predicados: em Lógica Predicativa, a negação de quantificadores universais e existenciais envolve dupla negação. Por exemplo, a negação de <em>todo <span class="math inline">\(x\)</span> é <span class="math inline">\(P\)</span></em> é <em>existe algum <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> não é verdadeiro</em>.</p></li>
</ul>
<p><span class="math display">\[\neg \forall x P(x) \Leftrightarrow \exists x \neg P(x)\]</span></p>
<ul>
<li>Permite provar equivalências: uma identidade ou lei importante na lógica é que a dupla negação de uma proposição é logicamente equivalente à proposição original. A regra da dupla negação permite formalmente provar essa equivalência.</li>
</ul>
<p><span class="math display">\[\neg \neg P \Leftrightarrow P\]</span></p>
</section>
<section id="adição" class="level4" data-number="3.1.1.4">
<h4 data-number="3.1.1.4" class="anchored" data-anchor-id="adição"><span class="header-section-number">3.1.1.4</span> Adição</h4>
<p>A regra da Adição permite adicionar uma disjunção a uma afirmação, resultando em uma nova disjunção verdadeira. Esta regra é útil para introduzir alternativas em nosso raciocínio dedutivo.</p>
<p><span class="math display">\[F\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;F\\
\hline
&amp;F \vee G\\
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;G\\
\hline
&amp;F \vee G\\
\end{aligned}\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>o céu está azul, <span class="math inline">\((P)\)</span></em>;</li>
<li>Conclusão: logo, <em>o céu está azul ou gatos podem voar, <span class="math inline">\((P \lor Q)\)</span></em>.</li>
</ul>
<p>A regra da Adição permite introduzir uma disjunção em uma prova ou argumento lógico. Especificamente, ela nos permite inferir uma disjunção <span class="math inline">\(P\vee Q\)</span>A partir de uma das afirmações disjuntivas (<span class="math inline">\(P\)</span> ou <span class="math inline">\(Q\)</span>) individualmente.</p>
<p>Alguns usos e aplicações importantes da regra da Adição:</p>
<ul>
<li><p>Introduzir alternativas ou possibilidades em um argumento: por exemplo, dado que <em>João está em casa</em>, podemos concluir que <em>João está em casa OR no trabalho</em>. E expandir este <em>OR</em> o quanto seja necessário para explicitar os lugares em que João está.</p></li>
<li><p>Combinar afirmações em novas disjunções: dadas duas afirmações quaisquer <span class="math inline">\(P\)</span> e <span class="math inline">\(Q\)</span>, podemos inferir que <span class="math inline">\(P\)</span> ou <span class="math inline">\(Q\)</span> é verdadeiro.</p></li>
<li><p>Criar casos ou opções exaustivas em uma prova: podemos derivar uma disjunção que cubra todas as possibilidades relevantes. Lembre-se do pobre <em>joão</em>.</p></li>
<li><p>Iniciar provas por casos: ao assumir cada disjuntiva separadamente, podemos provar teoremas por casos exaustivos.</p></li>
<li><p>Realizar provas indiretas: ao assumir a negação de uma disjunção, podemos chegar a uma contradição e provar a disjunção original.</p></li>
</ul>
<p>A regra da Adição amplia nossas capacidades de prova e abordagem de problemas.</p>
</section>
<section id="modus-tollendo-ponens" class="level4" data-number="3.1.1.5">
<h4 data-number="3.1.1.5" class="anchored" data-anchor-id="modus-tollendo-ponens"><span class="header-section-number">3.1.1.5</span> Modus Tollendo Ponens</h4>
<p>O Modus Tollendo Ponens permite inferir uma disjunção a partir da negação da outra disjunção.</p>
<p>Dada uma disjunção <span class="math inline">\(P\vee Q\)</span>:</p>
<ul>
<li>Se <span class="math inline">\(\neg P\)</span>, então <span class="math inline">\(Q\)</span></li>
<li>Se <span class="math inline">\(\neg Q\)</span>, então <span class="math inline">\(P\)</span></li>
</ul>
<p>Esta regra nos ajuda a chegar a conclusões a partir de disjunções, por exclusão de alternativas.</p>
<p><span class="math display">\[P \vee Q\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg P\\
\hline
&amp;Q\\
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg Q\\
\hline
&amp;P\\
\end{aligned}\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição 1: <em>ou o céu está azul ou a grama é roxa</em>;</li>
<li>Proposição 2: <em>a grama não é roxa</em>;</li>
<li>Conclusão: logo, <em>o céu está azul</em>.</li>
</ul>
<p>Algumas aplicações do Modus Tollendo Ponens:</p>
<ul>
<li><p>Derivar ações a partir de regras disjuntivas. Por exemplo:</p>
<ul>
<li>Proposição: <em>ou João vai à praia, <span class="math inline">\(P\)</span> ou João vai ao cinema, <span class="math inline">\(c\)</span></em>;</li>
<li>Proposição: <em>João não vai ao cinema</em>, <span class="math inline">\(\neg C\)</span>;</li>
<li>Conclusão: logo, <em>João vai à praia</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[P \vee C\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg C\\
\hline
&amp;P
\end{aligned}\]</span></p>
<ul>
<li><p>Simplificar casos em provas por exaustão. Por exemplo:</p>
<ul>
<li>Proposição: <em>o número é par, <span class="math inline">\(P\)</span>, ou ímpar, <span class="math inline">\(I\)</span></em>;</li>
<li>Proposição: <em>o número não é ímpar, <span class="math inline">\(\neg P\)</span></em>;</li>
<li>Conclusão: logo, <em>o número é par</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[P \vee I\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg I\\
\hline
&amp;P
\end{aligned}\]</span></p>
<ul>
<li><p>Eliminar opções em raciocínio dedutivo. Por exemplo:</p>
<ul>
<li>Proposição: <em>ou João estava em casa, <span class="math inline">\(c\)</span>, ou João estava no trabalho, <span class="math inline">\(t\)</span></em>;</li>
<li>Proposição: <em>João não estava em casa</em>;</li>
<li>Conclusão: logo, <em>João estava no trabalho</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[C \vee T\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg C\\
\hline
&amp;T
\end{aligned}\]</span></p>
<ul>
<li><p>Fazer prova indireta da disjunção. Por exemplo:</p>
<ul>
<li>Proposição: <em>1 é par, <span class="math inline">\(1P\)</span>, ou 1 é ímpar, <span class="math inline">\(1I\)</span></em>;</li>
<li>Proposição: <em>1 não é par</em>;</li>
<li>Conclusão: logo, <em>1 é ímpar</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[1P \vee 1I\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg 1P\\
\hline
&amp;1I
\end{aligned}\]</span></p>
</section>
<section id="adjunção" class="level4" data-number="3.1.1.6">
<h4 data-number="3.1.1.6" class="anchored" data-anchor-id="adjunção"><span class="header-section-number">3.1.1.6</span> Adjunção</h4>
<p>A regra da Adjunção permite combinar duas afirmações em uma conjunção. Esta regra é útil para juntar duas premissas em uma única afirmação conjuntiva.</p>
<p><span class="math display">\[F\]</span></p>
<p><span class="math display">\[G\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;F\\
&amp;G\\
\hline
&amp;F \land G\\
\end{aligned}\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>proposição 1: <em>o céu está azul</em>;</li>
<li>proposição 2: <em>os pássaros estão cantando</em>;</li>
<li>Conclusão: logo, <em>o céu está azul e os pássaros estão cantando</em>.</li>
</ul>
<p>Algumas aplicações da Adjunção:</p>
<ul>
<li><p>Combinar proposições relacionadas em argumentos. Por exemplo:</p>
<ul>
<li>Proposição: <em>o céu está nublado, <span class="math inline">\(n\)</span></em>;</li>
<li>Proposição: <em>está ventando, <span class="math inline">\(V\)</span></em>;</li>
<li>Conclusão: logo, <em>o céu está nublado e está ventando</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;N\\
&amp;V\\
\hline
&amp;N \land V
\end{aligned}\]</span></p>
<ul>
<li><p>Criar declarações conjuntivas complexas. Por exemplo:</p>
<ul>
<li>Proposição: <em>1 é número natural, <span class="math inline">\(n1\)</span></em>;</li>
<li>Proposição: <em>2 é número natural <span class="math inline">\(n2\)</span></em>;</li>
<li>Conclusão: logo, <em>1 é número natural <strong>e</strong> 2 é número natural</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;N1\\
&amp;N2\\
\hline
&amp;N1 \land N2
\end{aligned}\]</span></p>
<ul>
<li><p>Derivar novas informações da interseção de fatos conhecidos. Por exemplo:</p>
<ul>
<li>Proposição: <em>o gato está em cima do tapete, <span class="math inline">\(gT\)</span></em>;</li>
<li>Proposição: <em>o rato está em cima do tapete, <span class="math inline">\(rT\)</span></em>;</li>
<li>Conclusão: logo, <em>o gato <strong>e</strong> o rato estão em cima do tapete</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;GT\\
&amp;RT\\
\hline
&amp;G_T \land R_T
\end{aligned}\]</span></p>
<ul>
<li><p>Fazer deduções lógicas baseadas em múltiplas proposições. Por exemplo:</p>
<ul>
<li>Proposição: <em>2 + 2 = 4</em>;</li>
<li>Proposição: <em>4 x 4 = 16</em>;</li>
<li>Conclusão: logo, <em><span class="math inline">\((2 + 2 = 4) ∧ (4 × 4 = 16)\)</span></em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;(2 + 2 = 4)\\
&amp;(4 \times 4 = 16)\\
\hline
&amp;(2 + 2 = 4) \land (4 \times 4 = 16)
\end{aligned}\]</span></p>
</section>
<section id="simplificação" class="level4" data-number="3.1.1.7">
<h4 data-number="3.1.1.7" class="anchored" data-anchor-id="simplificação"><span class="header-section-number">3.1.1.7</span> Simplificação</h4>
<p>A regra da Simplificação permite inferir uma conjunção a partir de uma conjunção composta. Esta regra nos permite derivar ambos os elementos de uma conjunção, a partir da afirmação conjuntiva.</p>
<p><span class="math display">\[F \land G\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;F \land G\\
\hline
&amp;F\\
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;F \land G\\
\hline
&amp;G\\
\end{aligned}\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>proposição: <em>o céu está azul e os pássaros estão cantando</em>;</li>
<li>Conclusão: logo, <em>o céu está azul. E os pássaros estão cantando</em>.</li>
</ul>
<p>Algumas aplicações da Simplificação:</p>
<ul>
<li><p>Derivar elementos de conjunções complexas. Por exemplo:</p>
<ul>
<li>Proposição: <em>hoje está chovendo, <span class="math inline">\(c\)</span>, e fazendo frio, <span class="math inline">\(F\)</span></em>;</li>
<li>Conclusão: logo, <em>está chovendo</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;C \land F\\
\hline
&amp;C
\end{aligned}\]</span></p>
<ul>
<li><p>Simplificar provas baseadas em conjunções. Por exemplo:</p>
<ul>
<li>Proposição: <em>2 é par, <span class="math inline">\(2P\)</span>, e 3 é ímpar, <span class="math inline">\(3P\)</span></em>;</li>
<li>Conclusão: logo, <em>3 é ímpar, <span class="math inline">\(3I\)</span></em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;2P \land 3I\\
\hline
&amp;3I
\end{aligned}\]</span></p>
<ul>
<li><p>Inferir detalhes específicos de declarações complexas. Por exemplo:</p>
<ul>
<li>Proposição: <em>o gato está dormindo, <span class="math inline">\(d\)</span>, e ronronando, <span class="math inline">\(R\)</span></em>;</li>
<li>Conclusão: logo, <em>o gato está ronronando</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;D \land R\\
\hline
&amp;R
\end{aligned}\]</span></p>
<ul>
<li><p>Derivar informações de premissas conjuntivas. Por exemplo:</p>
<ul>
<li>Proposição: <em>está chovendo, <span class="math inline">\(J\)</span>, e o jogo foi cancelado, <span class="math inline">\(c\)</span></em>;</li>
<li>Conclusão: logo, <em>o jogo foi cancelado</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;C \land J\\
\hline
&amp;J
\end{aligned}\]</span></p>
</section>
<section id="bicondicionalidade" class="level4" data-number="3.1.1.8">
<h4 data-number="3.1.1.8" class="anchored" data-anchor-id="bicondicionalidade"><span class="header-section-number">3.1.1.8</span> Bicondicionalidade</h4>
<p>A regra da Bicondicionalidade permite inferir uma bicondicional a partir de duas condicionais. Esta regra nos permite combinar duas implicações para obter uma afirmação de equivalência lógica.</p>
<p><span class="math display">\[F \rightarrow G\]</span></p>
<p><span class="math display">\[G \rightarrow F\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;G \rightarrow F\\
\hline
&amp;F \leftrightarrow G\\
\end{aligned}\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>proposição <em>1: se está chovendo, então a rua está molhada</em>;</li>
<li>proposição <em>2: se a rua está molhada, então está chovendo</em>;</li>
<li>Conclusão: logo, <em>está chovendo se e somente se a rua está molhada</em>.</li>
</ul>
<p>Algumas aplicações da Bicondicionalidade:</p>
<ul>
<li><p>Inferir equivalências lógicas a partir de implicações bidirecionais. Por exemplo:</p>
<ul>
<li>Proposição: <em>se chove, <span class="math inline">\(c\)</span> então a rua fica molhada, <span class="math inline">\(m\)</span></em>;</li>
<li>Proposição: <em>se a rua fica molhada, então chove</em>;</li>
<li>Conclusão: logo, <em>chove se e somente se a rua fica molhada</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[C \rightarrow M\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;M \rightarrow C\\
\hline
&amp;C \leftrightarrow M
\end{aligned}\]</span></p>
<ul>
<li><p>Simplificar relações recíprocas. Por exemplo:</p>
<ul>
<li>Proposição: <em>se um número é múltiplo de 2, <span class="math inline">\(M2\)</span> então é par, <span class="math inline">\(P\)</span></em>;</li>
<li>Proposição: <em>se um número é par, então é múltiplo de 2</em>;</li>
<li>Conclusão: logo, <em>um número é par se e somente se é múltiplo de 2</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[P \rightarrow M2\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;M2 \rightarrow P\\
\hline
&amp;P \leftrightarrow M2
\end{aligned}\]</span></p>
<ul>
<li><p>Estabelecer equivalências matemáticas. Por exemplo:</p>
<ul>
<li>Proposição: <em>se <span class="math inline">\(x^2 = 25\)</span>, então <span class="math inline">\(x = 5\)</span></em>;</li>
<li>Proposição: <em>se <span class="math inline">\(x = 5\)</span>, então <span class="math inline">\(x^2 = 25\)</span></em>;</li>
<li>Conclusão: logo, <em><span class="math inline">\(x^2 = 25\)</span> se e somente se <span class="math inline">\(x = 5\)</span></em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[(x^2 = 25) \rightarrow (x = 5)\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;(x = 5) \rightarrow (x^2 = 25)\\
\hline
&amp;(x^2 = 25) \leftrightarrow (x = 5)
\end{aligned}\]</span></p>
<ul>
<li><p>Provar relações de definição mútua. Por exemplo:</p>
<ul>
<li>Proposição: <em>se figura é um quadrado, <span class="math inline">\(Q\)</span>, então tem 4 lados iguais, <span class="math inline">\(4L\)</span></em>;</li>
<li>Proposição: <em>se figura tem 4 lados iguais, é um quadrado</em>;</li>
<li>Conclusão: logo, <em>figura é quadrado se e somente se tem 4 lados iguais</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[Q \rightarrow 4L\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;4L \rightarrow Q\\
\hline
&amp;Q \leftrightarrow 4L
\end{aligned}\]</span></p>
</section>
<section id="equivalência" class="level4" data-number="3.1.1.9">
<h4 data-number="3.1.1.9" class="anchored" data-anchor-id="equivalência"><span class="header-section-number">3.1.1.9</span> Equivalência</h4>
<p>A regra da Equivalência permite inferir uma afirmação ou sua negação a partir de uma bicondicional. Esta regra nos permite aplicar bicondicionais para derivar novas afirmações baseadas nas equivalências lógicas.</p>
<p><span class="math display">\[F \leftrightarrow G\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;F\\
\hline
&amp;G\\
\end{aligned}\]</span></p>
<p><span class="math display">\[F \leftrightarrow G\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;G\\
\hline
&amp;F\\
\end{aligned}\]</span></p>
<p><span class="math display">\[F \leftrightarrow G\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg F\\
\hline
&amp;\neg G\\
\end{aligned}\]</span></p>
<p><span class="math display">\[F \leftrightarrow G\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg G\\
\hline
&amp;\neg F\\
\end{aligned}\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>proposição 1: <em>está chovendo se e somente se a rua está molhada</em>;</li>
<li>proposição 2: <em>está chovendo</em>;</li>
<li>Conclusão: logo, <em>a rua está molhada</em>.</li>
</ul>
<p>Algumas aplicações da Equivalência:</p>
<ol type="1">
<li><p>Inferir fatos de equivalências estabelecidas. Por exemplo:</p>
<ul>
<li>Proposição: <em>o número é par, <span class="math inline">\(P\)</span> se e somente se for divisível por 2, <span class="math inline">\(d2\)</span></em>;</li>
<li>Proposição: <em>156 é divisível por 2</em>;</li>
<li>Conclusão: logo, <em>156 é par</em>.</li>
</ul>
<p><span class="math display">\[P \leftrightarrow D2\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;D2(156)\\
\hline
&amp;P(156)
\end{aligned}\]</span></p></li>
<li><p>Derivar negações de equivalências. Por exemplo:</p>
<ul>
<li>Proposição: <em><span class="math inline">\(x\)</span> é negativo se e somente se <span class="math inline">\(x &lt; 0\)</span></em>;</li>
<li>Proposição: <em><span class="math inline">\(x\)</span> não é negativo</em>;</li>
<li>Conclusão: logo, <em><span class="math inline">\(x\)</span> não é menor que <span class="math inline">\(0\)</span></em>.</li>
</ul>
<p><span class="math display">\[ N \leftrightarrow (x &lt; 0)\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg N\\
\hline
&amp;\neg (x &lt; 0)
\end{aligned}\]</span></p></li>
<li><p>Fazer deduções baseadas em definições. Por exemplo:</p>
<ul>
<li>Proposição: <em>número ímpar é definido como não divisível, <span class="math inline">\(nD2\)</span>, por <span class="math inline">\(2\)</span></em>;</li>
<li>Proposição: <em><span class="math inline">\(9\)</span> não é divisível por <span class="math inline">\(2\)</span></em>;</li>
<li>Conclusão: logo, <em><span class="math inline">\(9\)</span> é ímpar</em>.</li>
</ul>
<p><span class="math display">\[I \leftrightarrow \neg ND2\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\neg D_2(9)\\
\hline
&amp;I(9)
\end{aligned}\]</span></p></li>
</ol>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Regra</th>
<th>Descrição</th>
<th>Fórmula</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Modus Ponens</td>
<td>Se <span class="math inline">\(P \rightarrow Q\)</span> e <span class="math inline">\(P\)</span> são verdadeiros, então <span class="math inline">\(Q\)</span> também é verdadeiro.</td>
<td><span class="math inline">\(\frac{P, P \rightarrow Q}{Q}\)</span></td>
</tr>
<tr class="even">
<td>Modus Tollens</td>
<td>Se <span class="math inline">\(P \rightarrow Q\)</span> e <span class="math inline">\(\neg Q\)</span> são verdadeiros, então <span class="math inline">\(\neg P\)</span> também é verdadeiro.</td>
<td><span class="math inline">\(\frac{\neg Q, P \rightarrow Q}{\neg P}\)</span></td>
</tr>
<tr class="odd">
<td>Dupla Negação</td>
<td>A negação de uma negação é equivalente à afirmação original.</td>
<td><span class="math inline">\(\frac{\neg \neg P}{P}\)</span></td>
</tr>
<tr class="even">
<td>Adição</td>
<td>Se <span class="math inline">\(P\)</span> é verdadeiro, então <span class="math inline">\(P \vee Q\)</span> também é verdadeiro.</td>
<td><span class="math inline">\(\frac{P}{P \vee Q}\)</span></td>
</tr>
<tr class="odd">
<td>Adjunção</td>
<td>Se <span class="math inline">\(P\)</span> e <span class="math inline">\(Q\)</span> são verdadeiros, então <span class="math inline">\(P \wedge Q\)</span> é verdadeiro.</td>
<td><span class="math inline">\(\frac{P, Q}{P \wedge Q}\)</span></td>
</tr>
<tr class="even">
<td>Simplificação</td>
<td>Se <span class="math inline">\(P \wedge Q\)</span> é verdadeiro, então <span class="math inline">\(P\)</span> (ou <span class="math inline">\(Q\)</span>) é verdadeiro.</td>
<td><span class="math inline">\(\frac{P \wedge Q}{P}\)</span></td>
</tr>
<tr class="odd">
<td>Bicondicionalidade</td>
<td>Se <span class="math inline">\(P \leftrightarrow Q\)</span>, então <span class="math inline">\(P \rightarrow Q\)</span> e <span class="math inline">\(Q \rightarrow P\)</span> são verdadeiros.</td>
<td><span class="math inline">\(\frac{P \leftrightarrow Q}{P \rightarrow Q, Q \rightarrow P}\)</span></td>
</tr>
</tbody>
</table>
<p><em>Tabela 4 - Resumo dos métodos de inferência.</em>{: class=“legend”}</p>
</section>
</section>
<section id="classificação-das-fórmulas-proposicionais" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="classificação-das-fórmulas-proposicionais"><span class="header-section-number">3.1.2</span> Classificação das Fórmulas Proposicionais</h3>
<p>Podemos classificar fórmulas proposicionais de acordo com suas propriedades semânticas, analisando suas tabelas-verdade. Seja <span class="math inline">\(R\)</span> uma fórmula proposicional:</p>
<ul>
<li><span class="math inline">\(R\)</span> é <strong>satisfatível</strong> se sua Tabela Verdade contém pelo menos uma linha verdadeira. Considere:<span class="math inline">\(P\wedge Q\)</span>.</li>
</ul>
<p><span class="math display">\[\begin{array}{|c|c|c|}
\hline
P &amp; Q &amp; P \land Q \\
\hline
F &amp; F &amp; F \\
\hline
F &amp; T &amp; F \\
\hline
T &amp; F &amp; F \\
\hline
T &amp; T &amp; T \\
\hline
\end{array}\]</span></p>
<ul>
<li><span class="math inline">\(R\)</span> é <strong>insatisfatível</strong> se sua Tabela Verdade contém apenas linhas falsas. Exemplo:<span class="math inline">\(P\wedge \neg P\)</span>.</li>
<li><span class="math inline">\(R\)</span> é <strong>falsificável</strong> se sua Tabela Verdade contém pelo menos uma linha falsa. Exemplo:<span class="math inline">\(P\wedge Q\)</span>.</li>
<li><span class="math inline">\(R\)</span> é <strong>válida</strong> se sua Tabela Verdade contém apenas linhas verdadeiras. Exemplo:<span class="math inline">\(P\vee \neg P\)</span>.</li>
</ul>
<p>Note que:</p>
<ul>
<li>Se <span class="math inline">\(A\)</span> é válida, então <span class="math inline">\(A\)</span> é satisfatível.</li>
<li>Se <span class="math inline">\(A\)</span> é insatisfatível, então <span class="math inline">\(A\)</span> é falsificável.</li>
</ul>
<p>Fórmulas válidas são importantes na lógica proposicional, representando argumentos sempre verdadeiros independentemente da valoração de suas variáveis proposicionais atômicas. Na verdade, esta classificação será importante para:</p>
<ol type="1">
<li><p><strong>Análise de Argumentos</strong>: Se uma argumentação lógica pode ser representada por uma fórmula que é insatisfatível, então sabemos que o argumento é inválido ou inconsistente. Isso é frequentemente usado em lógica e filosofia para analisar a validade dos argumentos.</p></li>
<li><p><strong>Prova de Teoremas</strong>: Na prova de teoremas, essas classificações são úteis. Quando estamos tentando provar que uma fórmula é uma tautologia, podemos usar essas classificações para simplificar a tarefa. Podemos mostrar que a negação da fórmula é insatisfatível, mostrando que a fórmula original é uma tautologia.</p></li>
<li><p><strong>Simplificação de Fórmulas</strong>: Na simplificação de fórmulas, essas classificações também são úteis. Se temos uma fórmula complexa e podemos mostrar que uma parte dela é uma tautologia, podemos simplificar a fórmula removendo essa parte. Similarmente, se uma parte da fórmula é uma contradição (ou seja, é insatisfatível), sabemos que a fórmula inteira é insatisfatível.</p></li>
<li><p><strong>Construção de Argumentos</strong>: Na construção de argumentos, estas classificações são úteis para garantir que os argumentos são válidos. Se estamos construindo um argumento e podemos mostrar que ele é representado por uma fórmula que é satisfatível (mas não uma tautologia), sabemos que existem algumas circunstâncias em que o argumento é válido e outras em que não é.</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./01-jornada-programacao-logica.html" class="pagination-link" aria-label="Introdução">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="pagination-link" aria-label="Provas">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Provas</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/02-fundamentos-logica-proposicional.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>