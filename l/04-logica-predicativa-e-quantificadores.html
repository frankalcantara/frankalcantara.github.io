<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 6&nbsp; Lógica de Primeira Ordem: Lógica Predicativa</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./05-formas-normais-e-skolemizacao.html" rel="next">
<link href="./03-arte-da-prova-e-analise-de-argumentos.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-jornada-programacao-logica.html">Fundamentos da Lógica</a></li><li class="breadcrumb-item"><a href="./04-logica-predicativa-e-quantificadores.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução ao Paradigma da Programação Lógica</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-introducao-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introdução Prática ao Prolog com Swish</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Proposicional</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">A Arte da Prova e Análise de Argumentos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Mundos na <strong>Lógica de Primeira Ordem</strong></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Cláusulas de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Problemas Interessantes Resolvidos com <strong>Lógica Proposicional</strong> e Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Solucao-Exercicios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Solução dos Exercícios</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#introdução-aos-predicados" id="toc-introdução-aos-predicados" class="nav-link active" data-scroll-target="#introdução-aos-predicados"><span class="header-section-number">6.1</span> Introdução aos Predicados</a></li>
  <li><a href="#universo-do-discurso" id="toc-universo-do-discurso" class="nav-link" data-scroll-target="#universo-do-discurso"><span class="header-section-number">6.2</span> Universo do Discurso</a></li>
  <li><a href="#entendendo-predicados" id="toc-entendendo-predicados" class="nav-link" data-scroll-target="#entendendo-predicados"><span class="header-section-number">6.3</span> Entendendo Predicados</a></li>
  <li><a href="#quantificadores" id="toc-quantificadores" class="nav-link" data-scroll-target="#quantificadores"><span class="header-section-number">6.4</span> Quantificadores</a>
  <ul class="collapse">
  <li><a href="#quantificador-universal" id="toc-quantificador-universal" class="nav-link" data-scroll-target="#quantificador-universal"><span class="header-section-number">6.4.1</span> Quantificador Universal</a></li>
  <li><a href="#quantificador-existencial" id="toc-quantificador-existencial" class="nav-link" data-scroll-target="#quantificador-existencial"><span class="header-section-number">6.4.2</span> Quantificador Existencial</a></li>
  <li><a href="#clarificação-sobre-o-uso-de-operadores-com-quantificadores" id="toc-clarificação-sobre-o-uso-de-operadores-com-quantificadores" class="nav-link" data-scroll-target="#clarificação-sobre-o-uso-de-operadores-com-quantificadores"><span class="header-section-number">6.4.3</span> Clarificação sobre o Uso de Operadores com Quantificadores</a></li>
  <li><a href="#equivalências-interessantes" id="toc-equivalências-interessantes" class="nav-link" data-scroll-target="#equivalências-interessantes"><span class="header-section-number">6.4.4</span> Equivalências Interessantes</a></li>
  </ul></li>
  <li><a href="#dos-predicados-à-linguagem-natural" id="toc-dos-predicados-à-linguagem-natural" class="nav-link" data-scroll-target="#dos-predicados-à-linguagem-natural"><span class="header-section-number">6.5</span> Dos Predicados à Linguagem Natural</a>
  <ul class="collapse">
  <li><a href="#exercícios-resolvidos-de-conversão-de-linguagem-natural-em-expressões-predicativas" id="toc-exercícios-resolvidos-de-conversão-de-linguagem-natural-em-expressões-predicativas" class="nav-link" data-scroll-target="#exercícios-resolvidos-de-conversão-de-linguagem-natural-em-expressões-predicativas"><span class="header-section-number">6.5.1</span> Exercícios Resolvidos de Conversão de Linguagem Natural em Expressões Predicativas</a></li>
  <li><a href="#exercícios-resolvidos-de-conversão-de-expressões-predicativas-em-linguagem-natural" id="toc-exercícios-resolvidos-de-conversão-de-expressões-predicativas-em-linguagem-natural" class="nav-link" data-scroll-target="#exercícios-resolvidos-de-conversão-de-expressões-predicativas-em-linguagem-natural"><span class="header-section-number">6.5.2</span> Exercícios Resolvidos de Conversão de Expressões Predicativas em Linguagem Natural</a></li>
  </ul></li>
  <li><a href="#ordem-de-aplicação-dos-quantificadores" id="toc-ordem-de-aplicação-dos-quantificadores" class="nav-link" data-scroll-target="#ordem-de-aplicação-dos-quantificadores"><span class="header-section-number">6.6</span> Ordem de Aplicação dos Quantificadores</a></li>
  <li><a href="#negação-dos-quantificadores" id="toc-negação-dos-quantificadores" class="nav-link" data-scroll-target="#negação-dos-quantificadores"><span class="header-section-number">6.7</span> Negação dos Quantificadores</a></li>
  <li><a href="#regras-de-inferência-usando-quantificadores" id="toc-regras-de-inferência-usando-quantificadores" class="nav-link" data-scroll-target="#regras-de-inferência-usando-quantificadores"><span class="header-section-number">6.8</span> Regras de Inferência usando Quantificadores</a>
  <ul class="collapse">
  <li><a href="#repetição" id="toc-repetição" class="nav-link" data-scroll-target="#repetição"><span class="header-section-number">6.8.1</span> Repetição</a></li>
  <li><a href="#instanciação-universal" id="toc-instanciação-universal" class="nav-link" data-scroll-target="#instanciação-universal"><span class="header-section-number">6.8.2</span> Instanciação Universal</a></li>
  <li><a href="#generalização-existencial" id="toc-generalização-existencial" class="nav-link" data-scroll-target="#generalização-existencial"><span class="header-section-number">6.8.3</span> Generalização Existencial</a></li>
  <li><a href="#instanciação-existencial" id="toc-instanciação-existencial" class="nav-link" data-scroll-target="#instanciação-existencial"><span class="header-section-number">6.8.4</span> Instanciação Existencial</a></li>
  </ul></li>
  <li><a href="#exercícios-de-conexão-com-o-prolog" id="toc-exercícios-de-conexão-com-o-prolog" class="nav-link" data-scroll-target="#exercícios-de-conexão-com-o-prolog"><span class="header-section-number">6.9</span> Exercícios de Conexão com o Prolog</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/04-logica-predicativa-e-quantificadores.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-jornada-programacao-logica.html">Fundamentos da Lógica</a></li><li class="breadcrumb-item"><a href="./04-logica-predicativa-e-quantificadores.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-logica-predicativa" class="quarto-section-identifier"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\04-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>A lógica é a técnica que usamos para adicionar convicção à verdade. Jean de la Bruyere{: class=“epigraph”}</p>
<p>A Lógica Predicativa, coração e espírito da <strong>Lógica de Primeira Ordem</strong>, nos leva um passo além da <strong>Lógica Proposicional</strong>. Em vez de se concentrar apenas em proposições completas que são verdadeiras ou falsas, a lógica predicativa nos permite expressar proposições sobre objetos e as relações entre eles. Ela nos permite falar de forma mais rica e sofisticada sobre o mundo.</p>
<p>Vamos lembrar que na <strong>Lógica Proposicional</strong>, cada proposição é um átomo indivisível. Por exemplo, ‘A chuva cai’ ou ‘O sol brilha’. Cada uma dessas proposições é verdadeira ou falsa como uma unidade. Na lógica predicativa, no entanto, podemos olhar para dentro dessas proposições. Podemos falar sobre o sujeito - a chuva, o sol - e o predicado - cai, brilha. Podemos quantificar sobre eles: para todos os dias, existe um momento em que o sol brilha.</p>
<p>Enquanto a <strong>Lógica Proposicional</strong> pode ser vista como a aritmética do verdadeiro e do falso, a lógica predicativa é a álgebra do raciocínio. Ela nos permite manipular proposições de forma muito mais rica e expressiva. Com ela, podemos começar a codificar partes substanciais da matemática e da ciência, levando-nos mais perto de nossa busca para decifrar o cosmos, um símbolo de lógica de cada vez.</p>
<section id="introdução-aos-predicados" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="introdução-aos-predicados"><span class="header-section-number">6.1</span> Introdução aos Predicados</h2>
<p>Um predicado é como uma luneta que nos permite observar as propriedades de uma entidade. Um conjunto de lentes por meio do qual podemos ver se uma entidade particular possui ou não uma característica específica. A palavra predicado foi importada do campo da linguística e tem o mesmo significado: qualidade; característica. Por exemplo, ao observar o universo das letras por meio do telescópio do predicado <em>ser uma vogal</em>, percebemos que algumas entidades deste conjunto, como <span class="math inline">\(a\)</span> e <span class="math inline">\(e\)</span>, possuem essa propriedade, enquanto outras, como <span class="math inline">\(b\)</span> e <span class="math inline">\(c\)</span>, não.</p>
<p>Um predicado não é uma afirmação absoluta de verdade ou falsidade. Divergindo das proposições, os predicados não são declarações completas. Pense neles como aquelas sentenças com espaços em branco, aguardando para serem preenchidos, que só têm sentido completo quando preenchidas:</p>
<ol type="1">
<li><p>O _______ está saboroso;</p></li>
<li><p>O _______ é vermelho;</p></li>
<li><p>_______ é alto.</p></li>
</ol>
<p>Preencha as lacunas, como quiser desde que faça sentido, e perceba que, em cada caso, ao preencher estamos atribuindo uma qualidade a um objeto. Esses são exemplos de predicados do nosso cotidiano, que sinteticamente o conceito que queremos abordar. Na lógica, os predicados são artefatos que possibilitam examinar o mundo ao nosso redor de forma organizada e exata.</p>
<p>Um predicado pode ser entendido como uma função que recebe um objeto (ou um conjunto de objetos) e retorna um valor de verdade, <span class="math inline">\(\{\text{TRUE, FALSE}\}\)</span>. Esta função descreve uma propriedade que o objeto pode possuir. Isto é, se <span class="math inline">\(P\)</span> é uma função <span class="math inline">\(P: u \rightarrow \{\text{TRUE, FALSE}\}\)</span> para um determinado conjunto $ u$ qualquer. Esse conjunto $ u$ é chamado de <em>universo ou domínio do discurso</em>, e dizemos que <span class="math inline">\(P\)</span> é um predicado sobre $ u$.</p>
</section>
<section id="universo-do-discurso" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="universo-do-discurso"><span class="header-section-number">6.2</span> Universo do Discurso</h2>
<p>O universo do discurso, <span class="math inline">\(u\)</span>, também chamado de <strong>universo</strong>, ou domínio, é o conjunto de objetos de interesse em um determinado cenário lógico para uma análise específica. O universo do discurso é importante porque as proposições na Lógica de Predicados serão declarações sobre objetos de um universo.</p>
<p>O universo, <span class="math inline">\(u\)</span>, é o domínio das variáveis das nossas Fórmulas Bem Formadas. O universo do discurso pode ser o conjunto dos números reais, <span class="math inline">\(\mathbb{R}\)</span>, o conjunto dos inteiros, <span class="math inline">\(\mathbb{Z}\)</span>, o conjunto de todos os alunos em uma sala de aula que usam camisa amarela, ou qualquer outro conjunto que definamos. Na prática, o universo costuma ser deixado implícito e deveria ser óbvio a partir do contexto. Se não for o caso, precisa ser explicitado.</p>
<p>Se estamos interessados em proposições sobre números naturais, <span class="math inline">\(\mathbb{N}\)</span>, o universo do discurso é o conjunto <span class="math inline">\(\mathbb{N} = \{0, 1, 2, 3,...\}\)</span>, um conjunto infinito. Já se estamos interessados em proposições sobre alunos de uma sala de aula, o universo do discurso poderia ser o conjunto $ u = {, , …}$, um conjunto finito.</p>
<p>Para que este conceito fique mais claro, suponha que temos um conjunto de números <span class="math inline">\(u = \{1, 2, 3, 4, 5\}\)</span> e um predicado <span class="math inline">\(P(x)\)</span>, que dizemos unário por ter um, e somente um, argumento, que afirma <em>x é par</em>. Ao aplicarmos este predicado a cada elemento do universo <span class="math inline">\(u\)</span>, obtemos um conjunto de valores verdade:</p>
<p><span class="math display">\[
\begin{align}
&amp;P(1) = \text{FALSE};\\
&amp;P(2) = \text{TRUE};\\
&amp;P(3) = \text{FALSE};\\
&amp;P(4) = \text{TRUE};\\
&amp;P(5) = \text{FALSE}.
\end{align}
\]</span></p>
<p>Vemos que o predicado <span class="math inline">\(P(u)\)</span> dado por <em>u é par</em> é uma propriedade que alguns números do conjunto $ u$ Possuem, e outros não. Vale notar que na Lógica Predicativa, a função que define um predicado pode ter múltiplos argumentos. Por exemplo, podemos ter um predicado <span class="math inline">\(Q(x, y)\)</span> que afirma <em>x é maior que y</em>. Neste caso, o predicado <span class="math inline">\(Q\)</span> é uma função de dois argumentos que retorna um valor de verdade. Dizemos que <span class="math inline">\(Q(x, y)\)</span> é um predicado binário. Exemplos nos conduzem ao caminho do entendimento:</p>
<ol type="1">
<li><p><strong>Exemplo 1</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(u = \text{conjunto de todas as pessoas}\)</span>.</li>
<li>Predicado: <span class="math inline">\(P(x) = \{ x : x \text{ é um matemático} \}\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(P(x)\)</span> é verdadeiro: Carl Gauss, Leonhard Euler, John Von Neumann.</li>
</ul></li>
<li><p><strong>Exemplo 2</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(u = \{x \in \mathbb{Z} : x \text{ é par}\}\)</span></li>
<li>Predicado: <span class="math inline">\(Q(x) = (x &gt; 5)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(Q(x)\)</span> é verdadeiro: $6 $, $8 $, <span class="math inline">\(10 ...\)</span>.</li>
</ul></li>
<li><p><strong>Exemplo 3</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(u = \{x \in \mathbb{R} : x &gt; 0 \text{ e } x &lt; 10\}\)</span></li>
<li>Predicado: <span class="math inline">\(R(x) = (x^2 - 4 = 0)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(R(x)\)</span> é verdadeiro: <span class="math inline">\(2\)</span> (note que <span class="math inline">\(-2\)</span> não pertence ao universo do discurso definido).</li>
</ul></li>
<li><p><strong>Exemplo 4</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(u = \{x \in \mathbb{N} : x \text{ é um múltiplo de } 3\}\)</span></li>
<li>Predicado: <span class="math inline">\(S(x) = (\text{mod}(x, 2) = 0)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(S(x)\)</span> é verdadeiro: <span class="math inline">\(6\)</span>, <span class="math inline">\(12\)</span>, $18 $.</li>
</ul></li>
<li><p><strong>Exemplo 5</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(u = \{(x, y) \in \mathbb{R}^2 : x \neq y\}\)</span></li>
<li>Predicado: <span class="math inline">\(P(x, y) = (x &lt; y)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(P(x, y)\)</span> é verdadeiro: <span class="math inline">\((1, 2)\)</span>, <span class="math inline">\((3, 4)\)</span>, <span class="math inline">\((5, 6)\)</span>.</li>
</ul></li>
</ol>
</section>
<section id="entendendo-predicados" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="entendendo-predicados"><span class="header-section-number">6.3</span> Entendendo Predicados</h2>
<p>A aridade do predicado, número de argumentos, é limitado pela análise lógica que estamos fazendo. Considere um predicado ternário, <span class="math inline">\(R\)</span>, dado por <em>x está entre y e z</em>. Quando substituímos <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> e <span class="math inline">\(z\)</span> por números específicos podemos validar a verdade do predicado <span class="math inline">\(R\)</span>. Vamos considerar alguns exemplos adicionais de predicados baseados na aritmética e defini-los com menos formalidade e mais legibilidade:</p>
<ol type="1">
<li><span class="math inline">\(Primo(x)\)</span>: o número inteiro positivo <span class="math inline">\(x\)</span> é um número primo.</li>
<li><span class="math inline">\(PotênciaDe(x, y)\)</span>: o número inteiro <span class="math inline">\(x\)</span> é uma potência exata de <span class="math inline">\(y : x = y^z\)</span> para algum <span class="math inline">\(z \in \mathbb{Z}, z \geq 0\)</span>.</li>
<li><span class="math inline">\(somaDeDoisPrimos(x)\)</span>: o número inteiro positivo <span class="math inline">\(x\)</span> é igual à soma de dois números primos.</li>
</ol>
<p>Em 1, 2 e 3 os predicados estão definidos com mnemônicos aumentando a legibilidade e melhorando nossa capacidade de manter o universo implícito. O uso de predicados, e da <strong>Lógica Proposicional</strong>, permite a escrita de sentenças menos ambíguas para a definição de conceitos lógicos em formato matemático. Por exemplo: se <span class="math inline">\(x\)</span> é um ancestral de <span class="math inline">\(y\)</span> e <span class="math inline">\(y\)</span> é um ancestral de <span class="math inline">\(z\)</span> então <span class="math inline">\(x\)</span> é um ancestral de <span class="math inline">\(z\)</span>; que, se consideramos o predicado <span class="math inline">\(ancestralDe\)</span> Pode ser escrito como <span class="math inline">\(ancestralDe (x,y) \wedge ancestralDe(y,z) \rightarrow ancestralDe(x,z)\)</span>. Ainda assim, falta alguma coisa. Algo que permita aplicar os predicados a um conjunto de elementos dentro do universo do discurso. É aqui que entram os quantificadores.</p>
</section>
<section id="quantificadores" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="quantificadores"><span class="header-section-number">6.4</span> Quantificadores</h2>
<p>Embora a <strong>Lógica Proposicional</strong> seja um bom ponto de partida, a maioria das afirmações interessantes em matemática contêm variáveis definidas em domínios maiores do que apenas <span class="math inline">\(\{\text{TRUE, FALSE}\}\)</span>. Por exemplo, a afirmação <em><span class="math inline">\(x \text{é uma potência de } 2\)</span></em> não é uma proposição. Não temos como definir a verdade dessa afirmação até conhecermos o valor de <span class="math inline">\(x\)</span>. Se <span class="math inline">\(P(x)\)</span> é definido como a afirmação <span class="math inline">\(x \text{é uma potência de } 2\)</span>, então <span class="math inline">\(P(8)\)</span> é verdadeiro e <span class="math inline">\(P(7)\)</span> é falso.</p>
<p>Para termos uma linguagem lógica que seja suficientemente flexível para representar os problemas que encontramos no Universo real, o Universo em que vivemos, precisaremos ser capazes de dizer quando o predicado <span class="math inline">\(P\)</span> ou <span class="math inline">\(Q\)</span> é verdadeiro para valores diferentes em seus argumentos. Para tanto, vincularemos as variáveis aos predicados usando operadores para indicar quantidade, chamados de quantificadores.</p>
<p>Os quantificadores indicam se a sentença que estamos criando se aplica a todos os valores possíveis do argumento, <em>quantificação universal</em>, ou se esta sentença se aplica a um valor específico, <em>quantificação existencial</em>. Usaremos esses quantificadores para fazer declarações sobre <strong>todos os elementos</strong> de um universo de discurso específico, ou para afirmar que existe <strong>pelo menos um elemento</strong> do universo do discurso que satisfaz uma determinada qualidade.</p>
<p>Vamos remover o véu da dúvida usando como recurso metafórico uma experiência humana, social, comum e popular: imaginemos estar em uma festa e o anfitrião lhe pede para verificar se todos os convidados têm algo para beber. Você, prestativo e simpático, começa a percorrer a sala, verificando cada pessoa. Se você encontrar pelo menos uma pessoa sem bebida, você pode imediatamente dizer <em>nem todos têm bebidas</em>. mas, se você verificar cada convidado e todos eles tiverem algo para beber, você pode dizer com confiança <em>todos têm bebidas</em>. Este é o conceito do quantificador universal, matematicamente representado por <span class="math inline">\(\forall\)</span>, que lemos como <em>para todo</em>.</p>
<p>A festa continua e o anfitrião quer saber se alguém na festa está bebendo champanhe. Desta vez, assim que você encontrar uma pessoa com champanhe, você pode responder imediatamente <em>sim, alguém está bebendo champanhe</em>. Você não precisa verificar todo mundo para ter a resposta correta. Este é o conceito do quantificador existencial, denotado por <span class="math inline">\(\exists\)</span>, que lemos <em>existe algum</em>.</p>
<p>Os quantificadores nos permitem fazer declarações gerais, ou específicas, sobre os membros de um universo de discurso, de uma forma que seria difícil, ou impossível, sem estes operadores especiais.</p>
<section id="quantificador-universal" class="level3" data-number="6.4.1">
<h3 data-number="6.4.1" class="anchored" data-anchor-id="quantificador-universal"><span class="header-section-number">6.4.1</span> Quantificador Universal</h3>
<p>O quantificador universal <span class="math inline">\(\forall\)</span>, lê-se <em>para todo</em>, indica que uma afirmação deve ser verdadeira para todos os valores de uma variável dentro de um universo de discurso definido para a criação de uma sentença contendo um predicado qualquer. Por exemplo, a proposição clássica <em>todos os humanos são mortais</em> pode ser escrita como <span class="math inline">\(\forall x Humano(x) \rightarrow Mortal(x)\)</span>. Ou recorrendo a um exemplo com mais de rigor matemático, teríamos o predicado se <em><span class="math inline">\(x\)</span> é positivo então <span class="math inline">\(x + 1\)</span> é positivo</em>, que pode ser escrito <span class="math inline">\(\forall x (x &gt; 0 \rightarrow x + 1 &gt; 0)\)</span>. Neste último exemplo temos Quantificadores, Lógica Predicativa, <strong>Lógica Proposicional</strong> e Teoria dos Conjuntos em uma sentença.</p>
<p>O quantificador universal pode ser representado usando apenas a <strong>Lógica Proposicional</strong>, com uma pequena trapaça. A afirmação <span class="math inline">\(\forall x P(x)\)</span> é, de certa forma, a operação <span class="math inline">\(\wedge\)</span>, <strong>AND</strong> aplicada a todos os elementos do universo do discurso. Ou seja, o predicado:</p>
<p><span class="math display">\[\forall x (x \in \mathbb{N} \rightarrow P(x))\]</span></p>
<p>Pode ser escrito como:</p>
<p><span class="math display">\[P(0) \wedge P(1) \wedge P(2) \wedge P(3) \wedge \ldots\]</span></p>
<p>Assim, <span class="math inline">\(P(0), P(1), P(2), P(3) \ldots\)</span> representam a aplicação do predicado <span class="math inline">\(P\)</span> a todos os elementos <span class="math inline">\(x\)</span> do conjunto <span class="math inline">\(\mathbb{N}\)</span>. A trapaça fica por conta de que, em <strong>Lógica Proposicional</strong>, não podemos escrever expressões com um número infinito de termos. Portanto, a expansão em conjunções de um predicado <span class="math inline">\(P\)</span> em um Universo de Discurso, <span class="math inline">\(u\)</span>, não é uma <strong>Fórmula Bem Formada</strong> se a cardinalidade de <span class="math inline">\(u\)</span> for infinita. De qualquer forma, podemos usar esta interpretação informal para entender o significado de <span class="math inline">\(\forall x P(x)\)</span>.</p>
<p>A representação do Quantificador Universal como uma conjunção <strong>não é uma </strong>Fórmula Bem Formada** a não ser que o Universo do Discurso seja não infinito. Neste caso, teremos uma conjunção que chamaremos de <strong>Conjunção Universal</strong>:</p>
<p><span class="math display">\[\forall x (P(x) \wedge Q(x))\]</span></p>
<p>Isso significa que para todo <span class="math inline">\(x\)</span> no domínio, as propriedades <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, e outras listadas são todas verdadeiras. É uma forma de expressar que todas as condições listadas são verdadeiras para cada elemento no domínio. Esta fórmula será usada para simplificar sentenças, ou para criar formas normais.</p>
<p>Vamos voltar um pouco. O quantificador universal <span class="math inline">\(\forall x P(x)\)</span> afirma que a proposição <span class="math inline">\(P(x)\)</span> é verdadeira para todo, e qualquer, valor possível de <span class="math inline">\(x\)</span> como elemento de um conjunto, <span class="math inline">\(u\)</span>. Uma forma de interpretar isso é pensar em <span class="math inline">\(x\)</span> como uma variável que pode ter qualquer valor dentro do universo do discurso.</p>
<p>Para validar <span class="math inline">\(\forall x P(x)\)</span> escolhemos o pior caso possível para <span class="math inline">\(x\)</span>, todos os valores que suspeitamos possa fazer <span class="math inline">\(P(x)\)</span> falso. Se conseguirmos provar que <span class="math inline">\(P(x)\)</span> é verdadeira nestes casos específicos, então <span class="math inline">\(\forall x P(x)\)</span> deve ser verdadeira. Novamente, vamos recorrer a exemplos na esperança de explicitar este conceito.</p>
<p><strong>Exemplo 1</strong>: todos os números reais são maiores que 0. (Universo do discurso: <span class="math inline">\(\{x \in \mathbb{R}\}\)</span>)</p>
<p><span class="math display">\[\forall x (x \in \mathbb{R} \rightarrow x &gt; 0)\]</span></p>
<blockquote class="blockquote">
<p>Observe que este predicado, apesar de estar corretamente representado, é <span class="math inline">\(Falso\)</span>.</p>
</blockquote>
<p><strong>Exemplo 2</strong>: todos os triângulos em um plano euclidiano têm a soma dos ângulos internos igual a 180 graus. (Universo do discurso: <span class="math inline">\(x\)</span> é um triângulo em um plano euclidiano)</p>
<p><span class="math display">\[\forall x (Triângulo(x) \rightarrow \Sigma_{i=1}^3 ÂnguloInterno_i(x) = 180^\circ)\]</span></p>
<p><strong>Exemplo 3</strong>: todas as pessoas com mais de 18 anos podem tirar carteira de motorista.” (Universo do discurso: <span class="math inline">\(x\)</span> é uma pessoa no Brasil)</p>
<p><span class="math display">\[\forall x (Pessoa(x) \wedge Idade (x) \geq 18 \rightarrow PodeTirarCarteira(x))\]</span></p>
<p><strong>Exemplo 4</strong>: todo número par maior que 2 pode ser escrito como a soma de dois números primos. (Universo do discurso: <span class="math inline">\(\{x \in \mathbb{Z}\}\)</span></p>
<p><span class="math display">\[\forall x\,(Par(x) \wedge x &gt; 2 \rightarrow \exists u\exists v\, (Primo(u) \wedge Primo(v) \wedge x = u + v))\]</span></p>
<p><strong>Exemplo 5</strong>: para todo número natural, se ele é múltiplo de 4 e múltiplo de 6, então ele também é múltiplo de 12. (Universo do discurso: <span class="math inline">\(\{x \in \mathbb{N}\}\)</span>)</p>
<p><span class="math display">\[\forall x\,((\exists u\in\Bbb N\,(x = 4u) \wedge \exists v\in\Bbb N\,(x = 6v)) \rightarrow \exists w\in\Bbb N\,(x = 12w))\]</span></p>
<p>O quantificador universal nos permite definir uma <strong>Fórmula Bem Formada</strong> representando todos os elementos de um conjunto, um universo do discurso, em relação a uma qualidade específica, um predicado. Esta é um artefato lógico interessante, mas não suficiente.</p>
<p>Usamos, preferencialmente, a implicação, <span class="math inline">\(\to\)</span>, com o quantificador universal, <span class="math inline">\(\forall\)</span>, para indicar que uma propriedade vale para todos os elementos de um domínio, Porque permite afirmar que para todo <span class="math inline">\(x\)</span>, se <span class="math inline">\(P(x)\)</span> for verdadeira, então <span class="math inline">\(Q(x)\)</span> também será verdadeira. Isso permite que <span class="math inline">\(P(x)\)</span> seja falsa para alguns <span class="math inline">\(x\)</span>, mas a implicação como um todo permanece verdadeira. Ou, em outras palavras, quando usamos uma implicação, como <span class="math inline">\(P(x) \rightarrow Q(x)\)</span>, estamos dizendo que se <span class="math inline">\(P(x)\)</span> for verdadeira, então <span class="math inline">\(Q(x)\)</span> também será verdadeira. A implicação é uma forma lógica que permite conectar duas proposições, em que a veracidade de <span class="math inline">\(Q(x)\)</span> depende da veracidade de <span class="math inline">\(P(x)\)</span>.</p>
<p>Importante: A implicação <span class="math inline">\(P(x) \rightarrow Q(x)\)</span> é considerada verdadeira em qualquer dos seguintes casos:</p>
<p><span class="math inline">\(P(x)\)</span> é verdadeira e <span class="math inline">\(Q(x)\)</span> é verdadeira. <span class="math inline">\(P(x)\)</span> é falsa, independentemente de <span class="math inline">\(Q(x)\)</span>. O ponto-chave é o segundo caso: se <span class="math inline">\(P(x)\)</span> for falsa, a implicação <span class="math inline">\(P(x) \rightarrow Q(x)\)</span> ainda é verdadeira, não importa o valor de <span class="math inline">\(Q(x)\)</span>.</p>
<p>Essa preferência não é arbitrária, mas baseada nas limitações que os outros conectivos apresentam quando combinados com o quantificador universal. Porém, uma análise de todos os operadores pode ser interessante para sedimentar os conceitos.</p>
<p>Comecemos com a conjunção. Quando usamos <span class="math inline">\(\forall x(P(x) ∧ Q(x))\)</span>, estamos afirmando que para todo <span class="math inline">\(x\)</span>, tanto <span class="math inline">\(P(x)\)</span> quanto <span class="math inline">\(Q(x)\)</span> são verdadeiros. Isso é extremamente restritivo e raramente reflete situações do mundo real. Por exemplo, se disséssemos <em>Todos os animais são mamíferos e podem voar</em>, estaríamos fazendo uma afirmação falsa, pois nem todos os animais são mamíferos e nem todos podem voar. Outro exemplo seria <em>Todos os números são pares e primos</em>, o que é claramente falso, pois nenhum número (exceto 2) satisfaz ambas as condições simultaneamente.</p>
<p>A disjunção, por outro lado, é muito fraca quando combinada com o quantificador universal. <span class="math inline">\(\forall x(P(x) ∨ Q(x))\)</span> afirma que para todo <span class="math inline">\(x\)</span>, ou <span class="math inline">\(P(x)\)</span> ou <span class="math inline">\(Q(x)\)</span> (ou ambos) são verdadeiros. Isso geralmente não captura relações condicionais úteis. Por exemplo, <em>Todo número é par ou ímpar</em> é uma afirmação verdadeira, mas não nos diz muito sobre a relação entre paridade e números. Da mesma forma, <em>Toda pessoa é alta ou baixa</em> é uma afirmação de tal amplitude que se torna quase sem sentido, pois não fornece informações úteis sobre a altura das pessoas.</p>
<p>A equivalência (<span class="math inline">\(\leftrightarrow\)</span>) com o quantificador universal também apresenta problemas. <span class="math inline">\(\forall x(P(x) \leftrightarrow Q(x))\)</span> afirma que para todo <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span> é verdadeiro se e somente se <span class="math inline">\(Q(x)\)</span> for verdadeiro. Isso é uma condição muito forte e raramente é satisfeita em situações reais. Por exemplo, <em>Um número é par se e somente se é divisível por 4</em> é falso, pois há números pares que não são divisíveis por <span class="math inline">\(4\)</span> (como <span class="math inline">\(2\)</span> e <span class="math inline">\(6\)</span>). Outro exemplo seria <em>Uma pessoa é feliz se e somente se é rica</em>, o que claramente não reflete a realidade complexa da felicidade e riqueza.</p>
<p>Por outro lado, a implicação (<span class="math inline">\(\to\)</span>) oferece várias vantagens quando usada com o quantificador universal. <span class="math inline">\(\forall x(P(x) \to Q(x))\)</span> nos permite expressar relações condicionais de forma mais flexível e precisa. Por exemplo, <em>Para todo número, se é par, então não é primo (exceto 2)</em> é uma afirmação verdadeira e informativa. Outro exemplo seria <em>Para toda pessoa, se é médico, então tem formação universitária</em>. Esta formulação permite exceções (pode haver pessoas com formação universitária que não são médicos) e captura uma regra geral de forma precisa.</p>
<p>A implicação também tem a vantagem de ser verdadeira quando o antecedente (<span class="math inline">\(P(x)\)</span>) é falso, o que é útil para expressar regras gerais. Por exemplo, em Para todo <span class="math inline">\(x\)</span>, se <span class="math inline">\(x\)</span> é um quadrado perfeito, então <span class="math inline">\(x\)</span> é positivo, a implicação é verdadeira mesmo para números negativos (que não são quadrados perfeitos), mantendo a regra geral válida.</p>
<p>Espero que tenha ficado claro. A implicação, quando combinada com o quantificador universal, oferece um equilíbrio entre flexibilidade e precisão que os outros conectivos lógicos não conseguem alcançar. Ela permite expressar relações condicionais, acomoda exceções e captura regras gerais de forma mais eficaz, tornando-a a escolha preferida em muitas situações da lógica formal e da matemática.</p>
</section>
<section id="quantificador-existencial" class="level3" data-number="6.4.2">
<h3 data-number="6.4.2" class="anchored" data-anchor-id="quantificador-existencial"><span class="header-section-number">6.4.2</span> Quantificador Existencial</h3>
<p>O quantificador existencial, <span class="math inline">\(\exists\)</span> nos permite fazer afirmações sobre a existência de objetos com certas propriedades, sem precisarmos especificar exatamente quais objetos são esses. Vamos tentar remover os véus da dúvida com um exemplo simples.</p>
<p>Consideremos a sentença: <em>existem humanos mortais</em>. Com um pouco mais de detalhe e matemática, podemos escrever isso como: existe pelo menos um <span class="math inline">\(x\)</span> tal que <span class="math inline">\(x\)</span> é humano e mortal. Para escrever a mesma sentença com precisão matemática teremos:</p>
<p><span class="math display">\[\exists x \text{Humano}(x) \wedge \text{Mortal}(x)\]</span></p>
<p>Lendo por partes: existe um <span class="math inline">\(x\)</span>, tal que <span class="math inline">\(x\)</span> é humano AND <span class="math inline">\(x\)</span> é mortal. Em outras palavras, existe pelo menos um humano que é mortal.</p>
<p>Note duas coisas importantes:</p>
<ol type="1">
<li><p>Nós não precisamos dizer exatamente quem é esse humano mortal. Só afirmamos que existe um. O operador <span class="math inline">\(\exists\)</span> captura essa ideia.</p></li>
<li><p>Usamos <strong>AND</strong> (<span class="math inline">\(\wedge\)</span>), não implicação (<span class="math inline">\(\rightarrow\)</span>). Se usássemos <span class="math inline">\(\rightarrow\)</span>, a afirmação ficaria muito mais fraca. Veja:</p></li>
</ol>
<p><span class="math display">\[\exists x \text{Humano}(x) \rightarrow \text{Mortal}(x)\]</span></p>
<p>Que pode ser lido como: <em>existe um <span class="math inline">\(x\)</span> tal que, SE <span class="math inline">\(x\)</span> é humano, ENTÃO <span class="math inline">\(x\)</span> é mortal</em>. Essa afirmação é verdadeira em qualquer universo que contenha um unicórnio de bolinhas roxas imortal. Porque o unicórnio não é humano. neste caso, o predicado <span class="math inline">\(\text{Humano}(\text{unicórnio})\)</span> é falso, e a implicação <span class="math inline">\(\text{Humano}(x) \rightarrow \text{Mortal}(x)\)</span> é verdadeira.</p>
<p>Portanto, é importante usar o operador <span class="math inline">\(\wedge\)</span>, e não <span class="math inline">\(\rightarrow\)</span> quando trabalhamos com quantificadores existenciais. O <span class="math inline">\(\wedge\)</span> garante que a propriedade se aplica ao objeto existente definido pelo <span class="math inline">\(\exists\)</span>. Contudo, podemos melhorar um pouco isso:</p>
<p>A conjunção, <span class="math inline">\(\wedge\)</span>, é frequentemente empregada com o quantificador existencial, <span class="math inline">\(\exists\)</span>, para expressar a presença de ao menos um elemento em determinado conjunto que possui múltiplas características simultaneamente. Isso nos possibilita declarar que <em>há no mínimo um <span class="math inline">\(x\)</span> para o qual tanto <span class="math inline">\(P(x)\)</span> quanto <span class="math inline">\(Q(x)\)</span> são válidas</em>. Tal afirmação confirma a existência de pelo menos um elemento que atende a ambos os critérios. Dito de outra forma, ao utilizarmos uma conjunção, como em <span class="math inline">\(P(x) \wedge Q(x)\)</span>, estamos afirmando que <em>existe ao menos um <span class="math inline">\(x\)</span> em que <span class="math inline">\(P(x)\)</span> é verdadeiro e, ao mesmo tempo, <span class="math inline">\(Q(x)\)</span> também o é</em>. A conjunção funciona como um operador lógico que une duas proposições, em que a validade da asserção existencial depende da ocorrência simultânea de <span class="math inline">\(P(x)\)</span> e <span class="math inline">\(Q(x)\)</span> para, no mínimo, um <span class="math inline">\(x\)</span>.</p>
<p>No contexto do quantificador existencial <span class="math inline">\(\exists x\)</span>, a conjunção <span class="math inline">\(P(x) \wedge Q(x)\)</span> é tida como verdadeira se, e apenas se houver ao menos um <span class="math inline">\(x\)</span> para o qual tanto <span class="math inline">\(P(x)\)</span> quanto <span class="math inline">\(Q(x)\)</span> são verdadeiras. Caso não exista tal <span class="math inline">\(x\)</span>, a afirmação existencial é considerada falsa.</p>
<p>Observe que basta a existência de um único elemento satisfazendo ambas as condições para validar a afirmação existencial.</p>
<p>Esta predileção não é fortuita, mas fundamentada na aptidão da conjunção em expressar com exatidão a existência de elementos dotados de múltiplos atributos concomitantes. No entanto, uma avaliação dos demais operadores pode ser proveitosa para consolidar esses conceitos.</p>
<p>Iniciemos com a implicação. Ao empregarmos <span class="math inline">\(\exists x(P(x) \to Q(x))\)</span>, declaramos a existência de ao menos um <span class="math inline">\(x\)</span> tal que, se <span class="math inline">\(P(x)\)</span> for verdadeiro, então <span class="math inline">\(Q(x)\)</span> também o será. Esta formulação é menos elucidativa que a conjunção no âmbito existencial, pois seria verdadeira mesmo se <span class="math inline">\(P(x)\)</span> fosse falso para todo <span class="math inline">\(x\)</span>. Ilustrando: <em>Há um número que, se for ímpar, é múltiplo de 2</em> é verdadeiro (pois é válido para números pares), mas não esclarece se realmente existe um número ímpar que é múltiplo de 2.</p>
<p>A disjunção aliada ao quantificador existencial, <span class="math inline">\(\exists x(P(x) \vee Q(x))\)</span>, assevera a existência de pelo menos um <span class="math inline">\(x\)</span> que satisfaz <span class="math inline">\(P(x)\)</span> ou <span class="math inline">\(Q(x)\)</span> (ou ambos). Embora útil em certos contextos, geralmente é menos robusta que a conjunção para afirmar a existência de elementos com múltiplas propriedades. Por exemplo: <em>Existe um número que é negativo ou racional</em> é verdadeiro, mas não nos informa se há um número que é ambos.</p>
<p>A equivalência (<span class="math inline">\(\leftrightarrow\)</span>) com o quantificador existencial também pode ser problemática. <span class="math inline">\(\exists x(P(x) \leftrightarrow Q(x))\)</span> afirma a existência de ao menos um <span class="math inline">\(x\)</span> para o qual <span class="math inline">\(P(x)\)</span> é verdadeiro se e somente se <span class="math inline">\(Q(x)\)</span> for verdadeiro. Isso pode ser útil em alguns casos, mas frequentemente é mais restritivo do que o necessário. Por exemplo: <em>Existe um número que é positivo se e somente se é inteiro</em> é verdadeiro (o número 1 satisfaz isso), mas não captura a existência de números que são apenas positivos ou apenas inteiros.</p>
<p>Em contrapartida, a conjunção (<span class="math inline">\(\wedge\)</span>) apresenta diversas vantagens quando utilizada com o quantificador existencial. <span class="math inline">\(\exists x(P(x) \wedge Q(x))\)</span> nos permite afirmar a existência de elementos que possuem múltiplas propriedades simultaneamente. Por exemplo: <em>Existe um número que é positivo e par</em> é uma afirmação verdadeira e informativa (o número 2 satisfaz ambas as condições). Outro exemplo seria <em>Existe uma substância que é líquida e condutora de eletricidade</em>. Esta formulação afirma claramente a existência de substâncias com ambas as características.</p>
<p>A conjunção também tem a vantagem de ser falsa quando não há elementos que satisfaçam ambas as condições, o que é útil para expressar a inexistência de certos tipos de elementos. Por exemplo: <em>Existe um número que é natural e negativo simultaneamente</em> é falso, indicando corretamente que não há tais números.</p>
<p>Em suma, a conjunção, quando associada ao quantificador existencial, proporciona um meio preciso e informativo de expressar a existência de elementos com múltiplos atributos. Ela permite afirmar a presença de elementos que atendem a condições simultâneas, tornando-se a opção preferencial em diversas situações da lógica formal e da matemática quando se trata de asserções existenciais.</p>
<p>Assim como o quantificador universal, <span class="math inline">\(\forall\)</span>, o quantificador existencial, <span class="math inline">\(\exists\)</span> , também pode ser restrito a um universo específico, usando a notação de pertencimento:</p>
<p><span class="math display">\[\exists x (x \in \mathbb{Z} \wedge x = x^2)\]</span></p>
<p>Esta sentença afirma a existência de pelo menos um inteiro <span class="math inline">\(x\)</span> tal que <span class="math inline">\(x\)</span> é igual ao seu quadrado. Novamente, não precisamos dizer qual é esse inteiro, apenas que ele existe dentro do conjunto dos inteiros. A resposta é sim: tanto <span class="math inline">\(x = 0\)</span> quanto <span class="math inline">\(x = 1\)</span> satisfazem a equação <span class="math inline">\(x = x^2\)</span>.</p>
<p>De forma geral, o quantificador existencial serve para fazer afirmações elegantes sobre a existência de objetos com certas qualidades, sem necessariamente conhecermos ou elencarmos todos esses objetos. Isso agrega mais qualidade a representação do mundo real que podemos fazer com a <strong>Lógica de Primeira Ordem</strong>.</p>
<p>Talvez, alguns exemplos possam ajudar no seu entendimento:</p>
<p><strong>Exemplo 1</strong>: existe um animal que é vertebrado e não é mamífero.</p>
<p><span class="math display">\[\exists x (Vertebrado(x) \wedge \neg Mamífero(x))\]</span></p>
<p><strong>Exemplo 2</strong>: existe uma equação do segundo grau com exatamente uma raiz real.</p>
<p><span class="math display">\[\exists x (\text{Eq2Grau}(x) \wedge |\text{RaízesReais}(x)| = 1)\]</span></p>
<p><strong>Exemplo 3</strong>: existe um número primo que é par.</p>
<p><span class="math display">\[\exists x (Primo(x) \wedge Par(x))\]</span></p>
<p><strong>Exemplo 4</strong>: existe um quadrado perfeito que pode ser escrito como o quadrado de um número racional.</p>
<p><span class="math display">\[\exists x (QuadPerfeito(x) \wedge \exists u \in \mathbb{Q} \ (x = u^2))\]</span></p>
<p><strong>Exemplo 5</strong>: existe um polígono convexo em que a soma dos ângulos internos não é igual a <span class="math inline">\((n-2) \cdot 180°\)</span>, de tal forma que <span class="math inline">\(n\)</span> é o número de lados desse polígono.</p>
<p>Para expressar isso corretamente em lógica de primeira ordem, precisamos relacionar o número de lados com o polígono específico:</p>
<p><span class="math display">\[\exists x (PolígonoConvexo(x) \land \exists n (NumLados(x, n) \land SomaÂngulosInternos(x) \neq (n-2) \cdot 180°))\]</span></p>
<p>Alternativamente, podemos usar uma notação mais explícita:</p>
<p><span class="math display">\[\exists x (PolígonoConvexo(x) \land \exists n (NumLados(x, n) \land \sum_{i=1}^{n} ÂnguloInterno_i(x) \neq (n-2) \cdot 180°))\]</span></p>
<p>A atenta leitora deve notar que este predicado é <strong>falso</strong>. Existe um teorema da geometria euclidiana que afirma que todos os polígonos convexos com <span class="math inline">\(n\)</span> lados têm a soma dos ângulos internos exatamente igual a <span class="math inline">\((n-2) \cdot 180°\)</span>.</p>
<p>A atenta leitora deve observar também que a variável <span class="math inline">\(n\)</span> está apropriadamente quantificada, com <span class="math inline">\(\exists n\)</span>, e explicitamente relacionada ao polígono <span class="math inline">\(x\)</span> por meio do predicado <span class="math inline">\(NumLados(x, n)\)</span>.</p>
<p><strong>Exemplo de instanciação</strong>:</p>
<ul>
<li>Para um triângulo (<span class="math inline">\(n = 3\)</span>): soma = <span class="math inline">\((3-2) \cdot 180° = 180°\)</span>;</li>
<li>Para um quadrilátero (<span class="math inline">\(n = 4\)</span>): soma = <span class="math inline">\((4-2) \cdot 180° = 360°\)</span>;</li>
<li>Para um pentágono (<span class="math inline">\(n = 5\)</span>): soma = <span class="math inline">\((5-2) \cdot 180° = 540°\)</span>.</li>
</ul>
<p>Em todos os casos, a fórmula da soma é satisfeita, tornando nossa afirmação existencial falsa.</p>
</section>
<section id="clarificação-sobre-o-uso-de-operadores-com-quantificadores" class="level3" data-number="6.4.3">
<h3 data-number="6.4.3" class="anchored" data-anchor-id="clarificação-sobre-o-uso-de-operadores-com-quantificadores"><span class="header-section-number">6.4.3</span> Clarificação sobre o Uso de Operadores com Quantificadores</h3>
<p>Embora seja verdade que <strong>frequentemente</strong> usamos implicação (<span class="math inline">\(\rightarrow\)</span>) com o quantificador universal (<span class="math inline">\(\forall\)</span>) e conjunção (<span class="math inline">\(\wedge\)</span>) com o quantificador existencial (<span class="math inline">\(\exists\)</span>), é importante esclarecer que estas são <strong>preferências contextuais</strong>, não regras absolutas. Há situações específicas nas quasi outras combinações são não apenas apropriadas, mas <strong>necessárias</strong> para expressar corretamente o significado desejado. A curiosa leitora deve considerar as seguintes situações:</p>
<section id="quantificador-universal-com-conjunção-forall-com-wedge" class="level4" data-number="6.4.3.1">
<h4 data-number="6.4.3.1" class="anchored" data-anchor-id="quantificador-universal-com-conjunção-forall-com-wedge"><span class="header-section-number">6.4.3.1</span> 1. Quantificador Universal com Conjunção (<span class="math inline">\(\forall\)</span> com <span class="math inline">\(\wedge\)</span>)</h4>
<p><strong>Uso apropriado</strong>: Quando queremos afirmar que <strong>todos</strong> os elementos de um conjunto possuem <strong>múltiplas propriedades simultaneamente</strong>.</p>
<p><strong>Exemplo</strong>: “Todos os números primos maiores que 2 são ímpares e indivisíveis por 4” <span class="math display">\[\forall x ((Primo(x) \wedge x &gt; 2) \rightarrow (Impar(x) \wedge \neg DivisívelPor4(x)))\]</span></p>
<p>Note que aqui usamos <span class="math inline">\(\wedge\)</span> tanto no antecedente quanto no consequente da implicação com <span class="math inline">\(\forall\)</span>.</p>
</section>
<section id="quantificador-existencial-com-implicação-exists-com-rightarrow" class="level4" data-number="6.4.3.2">
<h4 data-number="6.4.3.2" class="anchored" data-anchor-id="quantificador-existencial-com-implicação-exists-com-rightarrow"><span class="header-section-number">6.4.3.2</span> 2. Quantificador Existencial com Implicação (<span class="math inline">\(\exists\)</span> com <span class="math inline">\(\rightarrow\)</span>)</h4>
<p><strong>Uso apropriado</strong>: Quando queremos afirmar a existência de elementos que satisfazem uma relação condicional.</p>
<p><strong>Exemplo</strong>: “Existe um número tal que, se ele é par, então é maior que 10” <span class="math display">\[\exists x (Par(x) \rightarrow x &gt; 10)\]</span></p>
<p>Esta fórmula é verdadeira (por exemplo, <span class="math inline">\(x = 12\)</span> ou qualquer número ímpar satisfaz a condição).</p>
</section>
<section id="quantificador-universal-com-disjunção-forall-com-vee" class="level4" data-number="6.4.3.3">
<h4 data-number="6.4.3.3" class="anchored" data-anchor-id="quantificador-universal-com-disjunção-forall-com-vee"><span class="header-section-number">6.4.3.3</span> 3. Quantificador Universal com Disjunção (<span class="math inline">\(\forall\)</span> com <span class="math inline">\(\vee\)</span>)</h4>
<p><strong>Uso apropriado</strong>: Para expressar propriedades alternativas que todos os elementos devem satisfazer.</p>
<p><strong>Exemplo</strong>: “Todo número inteiro é positivo, negativo ou zero” <span class="math display">\[\forall x (x \in \mathbb{Z} \rightarrow (Positivo(x) \vee Negativo(x) \vee Zero(x)))\]</span></p>
</section>
<section id="quantificador-existencial-com-bicondicional-exists-com-leftrightarrow" class="level4" data-number="6.4.3.4">
<h4 data-number="6.4.3.4" class="anchored" data-anchor-id="quantificador-existencial-com-bicondicional-exists-com-leftrightarrow"><span class="header-section-number">6.4.3.4</span> 4. Quantificador Existencial com Bicondicional (<span class="math inline">\(\exists\)</span> com <span class="math inline">\(\leftrightarrow\)</span>)</h4>
<p><strong>Uso apropriado</strong>: Para afirmar a existência de elementos que satisfazem uma equivalência.</p>
<p><strong>Exemplo</strong>: “Existe um número que é primo se e somente se é ímpar” <span class="math display">\[\exists x (Primo(x) \leftrightarrow Impar(x))\]</span></p>
<p>(Verdadeiro para <span class="math inline">\(x = 3\)</span>, <span class="math inline">\(5\)</span>, <span class="math inline">\(7\)</span>, etc., mas falso para <span class="math inline">\(x = 2\)</span> ou <span class="math inline">\(x = 9\)</span>)</p>
</section>
<section id="diretrizes-práticas" class="level4" data-number="6.4.3.5">
<h4 data-number="6.4.3.5" class="anchored" data-anchor-id="diretrizes-práticas"><span class="header-section-number">6.4.3.5</span> Diretrizes Práticas</h4>
<p><strong>Regra geral para escolher o operador correto</strong>:</p>
<ol type="1">
<li><p><strong>Com <span class="math inline">\(\forall\)</span></strong>:</p>
<ul>
<li>Use <span class="math inline">\(\rightarrow\)</span> quando estiver <strong>restringindo</strong> o domínio (“para todos os <span class="math inline">\(X\)</span> que satisfazem <span class="math inline">\(P...\)</span>”);</li>
<li>Use <span class="math inline">\(\wedge\)</span> quando estiver afirmando <strong>múltiplas propriedades</strong> sobre todo o domínio;</li>
<li>Use <span class="math inline">\(\vee\)</span> quando todo elemento deve satisfazer <strong>pelo menos uma</strong> de várias condições.</li>
</ul></li>
<li><p><strong>Com <span class="math inline">\(\exists\)</span></strong>:</p>
<ul>
<li>Use <span class="math inline">\(\wedge\)</span> quando procurar elementos que satisfazem <strong>todas</strong> as propriedades listadas;</li>
<li>Use <span class="math inline">\(\vee\)</span> quando procurar elementos que satisfazem <strong>pelo menos uma</strong> propriedade;</li>
<li>Use <span class="math inline">\(\rightarrow\)</span> quando a existência envolver uma <strong>condição condicional</strong>.</li>
</ul></li>
</ol>
<section id="exemplo-comparativo" class="level5" data-number="6.4.3.5.1">
<h5 data-number="6.4.3.5.1" class="anchored" data-anchor-id="exemplo-comparativo"><span class="header-section-number">6.4.3.5.1</span> Exemplo Comparativo</h5>
<p>Considere a diferença entre estas duas afirmações sobre um sistema de banco de dados:</p>
<p><strong>Afirmação A</strong>: “Todos os usuários ativos têm senha” <span class="math display">\[\forall x (UsuarioAtivo(x) \rightarrow TemSenha(x))\]</span></p>
<p><strong>Afirmação B</strong>: “Todos os usuários são ativos e têm senha” <span class="math display">\[\forall x (Usuario(x) \rightarrow (UsuarioAtivo(x) \wedge TemSenha(x)))\]</span></p>
<p>A Afirmação A permite usuários inativos sem senha, enquanto a Afirmação B exige que <strong>todos</strong> os usuários sejam ativos <strong>e</strong> tenham senha - uma restrição muito mais forte.</p>
<p>A escolha do operador lógico deve ser guiada pelo <strong>significado preciso</strong> que queremos expressar, não por uma regra mecânica. As preferências mencionadas (implicação com <span class="math inline">\(\forall\)</span> e conjunção com <span class="math inline">\(\exists\)</span>) são <strong>padrões comuns</strong> que funcionam bem em muitos contextos, mas a lógica de primeira ordem é rica o suficiente para requerer todas as combinações possíveis em diferentes situações.</p>
<p>Existe uma regra de segurança que a esforçada leitora deve seguir: sempre traduza a fórmula de volta para linguagem natural para verificar se ela captura exatamente o significado pretendido. Se houver discrepância, reconsidere a escolha dos operadores.</p>
</section>
</section>
</section>
<section id="equivalências-interessantes" class="level3" data-number="6.4.4">
<h3 data-number="6.4.4" class="anchored" data-anchor-id="equivalências-interessantes"><span class="header-section-number">6.4.4</span> Equivalências Interessantes</h3>
<p>Estudando o quantificador universal encontramos duas equivalências interessantes:</p>
<p><span class="math display">\[\lnot \forall x P(x) \leftrightarrow \exists x \lnot P(x)\]</span></p>
<p><span class="math display">\[\lnot \exists x P(x) \leftrightarrow \forall x \lnot P(x)\]</span></p>
<p>Essas equivalências são essencialmente as versões quantificadas das <strong>Leis de De Morgan</strong>. A primeira diz que nem todos os humanos são mortais, isso é equivalente a encontrar algum humano que não é mortal. A segunda diz que para mostrar que nenhum humano é mortal, temos que mostrar que todos os humanos não são mortais.</p>
<p>Podemos representar uma declaração <span class="math inline">\(\exists x P(x)\)</span> como uma expressão <em>OU</em>. Por exemplo, <span class="math inline">\(\exists x (x \in \mathbb{N} \wedge P(x))\)</span> poderia ser reescrito como:</p>
<p><span class="math display">\[P(0) \vee P(1) \vee P(2) \vee P(3) \vee \ldots \]</span></p>
<p>Lembrando do problema que encontramos quando fizemos isso com o quantificador $$: não podemos representar fórmulas sem fim em <strong>Lógica de Primeira Ordem</strong>. mas, novamente esta notação, ainda que inválida, nos permite entender melhor o quantificador existencial. Caso o Universo do Discurso seja finito, limitado e contável, teremos a <strong>Disjunção Existencial</strong> uma expressão na <strong>Lógica de Primeira Ordem</strong> que afirma que existe pelo menos um elemento em um domínio que satisfaz uma ou mais propriedades. A forma geral de uma disjunção existencial é:</p>
<p><span class="math display">\[\exists x (P(x) \vee Q(x))\]</span></p>
<p>Isso significa que existe pelo menos um <span class="math inline">\(x\)</span> no domínio que satisfaz a propriedade <span class="math inline">\(P\)</span>, ou a propriedade <span class="math inline">\(Q\)</span>, ou ambas, ou outras propriedades listadas. É uma forma de expressar que pelo menos uma das condições listadas é verdadeira para algum elemento no domínio.</p>
<p>A expansão de $$ usando $$ destaca que a proposição <span class="math inline">\(P(x)\)</span> é verdadeira se pelo menos um valor de <span class="math inline">\(x\)</span> dentro do universo do discurso atender ao predicado <span class="math inline">\(P\)</span>. O que a expansão de exemplo está dizendo é que existe pelo menos um número natural <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> é verdadeiro. Não precisamos saber exatamente qual é esse <span class="math inline">\(x\)</span>. Apenas que existe um elemento dentro de <span class="math inline">\(\mathbb{N}\)</span> que atende o predicado.</p>
<p>O quantificador existencial não especifica o objeto dentro do universo determinado. Esse operador permite fazer afirmações elegantes sobre a existência de objetos com certas características, certas qualidades, ou ainda, certos predicados, sem necessariamente conhecermos exatamente quais são esses objetos.</p>
</section>
</section>
<section id="dos-predicados-à-linguagem-natural" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="dos-predicados-à-linguagem-natural"><span class="header-section-number">6.5</span> Dos Predicados à Linguagem Natural</h2>
<p>Ao ler uma <strong>Fórmula Bem Formada</strong> contendo quantificadores, a ordem da leitura é geralmente da esquerda para a direita. A interpretação precisa, no entanto, depende diretamente da ordem e do tipo dos quantificadores.</p>
<p>Por exemplo, <span class="math inline">\(\forall x\)</span> pode ser lido como “<em>para todo objeto <span class="math inline">\(x\)</span> no universo do discurso (em que este objeto está implícito), o seguinte se mantém</em>”. Já o quantificador <span class="math inline">\(\exists x\)</span> pode ser lido como “<em>existe um objeto <span class="math inline">\(x\)</span> no universo que satisfaz o seguinte</em>” ou “<em>para algum objeto <span class="math inline">\(x\)</span> no universo, o seguinte se mantém</em>”.</p>
<p>Converter uma <strong>Fórmula Bem Formada</strong> em uma sentença fluida em linguagem natural nem sempre é direto, mas é um passo valioso para a compreensão. Vamos considerar <span class="math inline">\(U\)</span> como o universo do discurso (o conjunto de todos os aviões já fabricados) e <span class="math inline">\(F(x,y)\)</span> como o predicado que denota “<span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>”. Analisemos algumas combinações de quantificadores:</p>
<ol type="1">
<li><p><strong><span class="math inline">\(\forall x \forall y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Para todo avião <span class="math inline">\(x\)</span>, e para todo avião <span class="math inline">\(y\)</span>, <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta afirmação é muito forte. Ela diz que cada avião no universo é mais rápido que todos os aviões no universo (incluindo ele mesmo, a menos que <span class="math inline">\(F(x,x)\)</span> seja definido como falso ou que se adicione <span class="math inline">\(x \neq y\)</span>). Se o universo tiver mais de um avião, esta afirmação provavelmente será falsa, pois implicaria, por exemplo, que <span class="math inline">\(A\)</span> é mais rápido que <span class="math inline">\(B\)</span> e <span class="math inline">\(B\)</span> é mais rápido que <span class="math inline">\(A\)</span> simultaneamente.</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(\exists x \forall y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Existe um avião <span class="math inline">\(x\)</span> tal que, para todo avião <span class="math inline">\(y\)</span>, <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta afirmação diz que existe pelo menos um avião que é mais rápido que todos os outros (e, novamente, dependendo da definição de <span class="math inline">\(F(x,x)\)</span>, mais rápido que ele mesmo). Em outras palavras, existe um “avião mais rápido absoluto”.</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(\forall x \exists y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Para todo avião <span class="math inline">\(x\)</span>, existe um avião <span class="math inline">\(y\)</span> tal que <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta afirmação diz que para qualquer avião que escolhermos, podemos encontrar algum avião <span class="math inline">\(y\)</span> que é mais lento que <span class="math inline">\(x\)</span>. Se <span class="math inline">\(y\)</span> pode ser igual a <span class="math inline">\(x\)</span>, a afirmação é trivialmente verdadeira se <span class="math inline">\(F(x,x)\)</span> for verdadeiro para algum <span class="math inline">\(x\)</span>. Se <span class="math inline">\(y\)</span> deve ser diferente de <span class="math inline">\(x\)</span>, isso significaria que não existe um “avião mais lento absoluto” (a menos que o universo seja finito e ordenado de forma cíclica, ou que <span class="math inline">\(F(x,y)\)</span> permita que <span class="math inline">\(x\)</span> seja mais rápido que “nada” se <span class="math inline">\(y\)</span> for o mais lento). Uma interpretação comum é que, para cada avião, há outro que ele supera em velocidade.</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(\exists x \exists y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Existe um avião <span class="math inline">\(x\)</span> e existe um avião <span class="math inline">\(y\)</span> tal que <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta é a afirmação mais fraca entre as quatro. Ela simplesmente diz que a relação “voa mais rápido que” não é vazia; ou seja, há pelo menos um par de aviões <span class="math inline">\((x,y)\)</span> em que <span class="math inline">\(x\)</span> é mais rápido que <span class="math inline">\(y\)</span>.</p></li>
</ul></li>
</ol>
<p>É fundamental perceber que <strong>estas quatro sentenças têm significados lógicos distintos e geralmente não expressam o mesmo contexto</strong>. A ordem dos quantificadores, especialmente quando misturamos <span class="math inline">\(\forall\)</span> e <span class="math inline">\(\exists\)</span>, altera drasticamente o significado da afirmação. Por exemplo, <span class="math inline">\(\exists x \forall y F(x,y)\)</span> (existe um avião mais rápido que todos) é uma afirmação muito mais forte e diferente de <span class="math inline">\(\forall x \exists y F(x,y)\)</span> (para cada avião, existe um mais lento).</p>
<p>Ao traduzir da lógica para a linguagem natural ou vice-versa, a precisão na interpretação da ordem e do tipo dos quantificadores é essencial. A prática leva a uma maior fluidez nesse processo de tradução e compreensão.</p>
<section id="exercícios-resolvidos-de-conversão-de-linguagem-natural-em-expressões-predicativas" class="level3" data-number="6.5.1">
<h3 data-number="6.5.1" class="anchored" data-anchor-id="exercícios-resolvidos-de-conversão-de-linguagem-natural-em-expressões-predicativas"><span class="header-section-number">6.5.1</span> Exercícios Resolvidos de Conversão de Linguagem Natural em Expressões Predicativas</h3>
<p><strong>Sentença 1</strong>: <em>Todo matemático que é professor tem alunos que são brilhantes e interessados.</em></p>
<p><span class="math display">\[
\forall x ((\text{Matemático}(x) \wedge \text{Professor}(x)) \rightarrow \exists y (\text{Aluno}(y) \wedge \text{Brilhante}(y) \wedge \text{Interessado}(y) \wedge \text{Ensina}(x, y)))
\]</span></p>
<p><span class="math display">\[
\forall x (\text{Matemático}(x) \rightarrow (\text{Professor}(x) \rightarrow \exists y (\text{Aluno}(y) \wedge \text{Brilhante}(y) \wedge \text{Interessado}(y) \wedge \text{Ensina}(x, y))))
\]</span></p>
<p><strong>Sentença 2</strong>: <em>Alguns engenheiros não são nem ricos nem felizes.</em></p>
<p><span class="math display">\[\exists x (\text{Engenheiro}(x) \wedge \neg (\text{Rico}(x) \vee \text{Feliz}(x)))\]</span></p>
<p><span class="math display">\[\exists x (\text{Engenheiro}(x) \wedge \neg\text{Rico}(x) \wedge \neg\text{Feliz}(x))\]</span></p>
<p><strong>Sentença 3</strong>: <em>Todos os planetas que têm água possuem vida ou têm potencial para vida.</em></p>
<p><span class="math display">\[
\forall x (\text{Planeta}(x) \wedge \text{TemÁgua}(x) \rightarrow (\text{TemVida}(x) \vee \text{TemPotencialParaVida}(x)))
\]</span></p>
<p><span class="math display">\[
\forall x (\text{Planeta}(x) \rightarrow (\text{TemÁgua}(x) \rightarrow (\text{TemVida}(x) \vee \text{TemPotencialParaVida}(x))))
\]</span></p>
<p><strong>Sentença 4</strong>: <em>Nenhum cientista que é cético acredita em todos os mitos.</em></p>
<p><span class="math display">\[
\neg \exists x (Cientista(x) \wedge Cético(x) \wedge \forall y (Mito(y) \rightarrow Acredita(x,y)))
\]</span></p>
<p><span class="math display">\[
\forall x ((\text{Cientista}(x) \wedge \text{Cético}(x)) \rightarrow \exists y (\text{Mito}(y) \wedge \neg \text{Acredita}(x, y)))
\]</span></p>
<p><span class="math display">\[
\forall x (\text{Cientista}(x) \rightarrow (\text{Cético}(x) \rightarrow \exists y (\text{Mito}(y) \wedge \neg \text{Acredita}(x, y))))
\]</span></p>
<p><strong>Sentença 5</strong>: <em>Alguns filósofos que escrevem sobre ética também leem ou estudam psicologia.</em></p>
<p><span class="math display">\[
\exists x (\text{Filósofo}(x) \wedge \text{EscreveSobreÉtica}(x) \wedge (\text{LêPsicologia}(x) \vee \text{EstudaPsicologia}(x)))
\]</span></p>
<p><strong>Sentença 6</strong>: <em>Para todo escritor, existe pelo menos um livro que ele escreveu e que é tanto criticado quanto admirado.</em></p>
<p><span class="math display">\[
\forall x (\text{Escritor}(x) \rightarrow \exists y (\text{Livro}(y) \wedge \text{Escreveu}(x, y) \wedge \text{Criticado}(y) \wedge \text{Admirado}(y)))
\]</span></p>
<p><strong>Sentença 7</strong>: <em>Todos os pássaros voam e todos os peixes nadam.</em></p>
<p><span class="math display">\[\forall x (Pássaro(x) \rightarrow Voa(x)) \wedge \forall y (Peixe(y) \rightarrow Nada(y))\]</span></p>
<p><strong>Sentença 8</strong>: <em>Todos os estudantes estudam ou todos os professores ensinam.</em></p>
<p><span class="math display">\[\forall x (Estudante(x) \rightarrow Estuda(x)) \vee \forall y (Professor(y) \rightarrow Ensina(y))\]</span></p>
<p><strong>Sentença 9</strong>: <em>Todos os cães latem e todos os gatos miam, mas nem todos os animais fazem barulho.</em></p>
<p><span class="math display">\[\forall x (Cão(x) \rightarrow Late(x)) \wedge \forall y (Gato(y) \rightarrow Mia(y)) \wedge \neg \forall z (Animal(z) \rightarrow FazBarulho(z))\]</span></p>
<p><strong>Sentença 10</strong>: <em>Se todos os carros são vermelhos, então todos os caminhões são azuis.</em></p>
<p><span class="math display">\[\forall x (Carro(x) \rightarrow Vermelho(x)) \rightarrow \forall y (Caminhão(y) \rightarrow Azul(y))\]</span></p>
<p><strong>Sentença 11</strong>: <em>Todos os planetas orbitam uma estrela e todos os asteroides orbitam o sol.</em></p>
<p><span class="math display">\[\forall x (Planeta(x) \rightarrow OrbitaEstrela(x)) \wedge \forall y (Asteroide(y) \rightarrow OrbitaSol(y))\]</span></p>
<p><strong>Sentença 12</strong>: <em>Alguns pássaros não voam.</em></p>
<p><span class="math display">\[\exists x (Pássaro(x) \wedge \neg Voa(x))\]</span></p>
<p><strong>Sentença 13</strong>: <em>Existe pelo menos um estudante que não estuda.</em></p>
<p><span class="math display">\[\exists x (Estudante(x) \wedge \neg Estuda(x))\]</span></p>
<p><span class="math display">\[\exists x (Estudante(x) \wedge \neg Estuda(x))\]</span></p>
<p><strong>Sentença 14</strong>: <em>Há algum animal que não faz barulho.</em></p>
<p><span class="math display">\[\exists x (Animal(x) \wedge \neg FazBarulho(x))\]</span></p>
<p><strong>Sentença 15</strong>: <em>Existe um carro que não é vermelho.</em></p>
<p><span class="math display">\[\exists x (Carro(x) \wedge \neg Vermelho(x))\]</span></p>
<p><span class="math display">\[\exists x (Carro(x) \wedge \neg Vermelho(x))\]</span></p>
<p><strong>Sentença 16</strong>: <em>Há um planeta que não orbita uma estrela</em>.</p>
<pre><code>$$\exists x (Planeta(x) \wedge \neg \exists y (Estrela(y) \wedge Orbita(x, y)))$$

Ou 

$$\exists x (Planeta(x) \wedge \forall y (Estrela(y) \rightarrow \neg Orbita(x, y)))$$ (Existe um planeta $x$ tal que, para toda estrela $y$, $x$ não a orbita).</code></pre>
<p><strong>Sentença 17</strong>: _Todos os pássaros voam, mas existe um animal que não voa.</p>
<pre><code>$$\forall x (Pássaro(x) \rightarrow Voa(x)) \wedge \exists y (Animal(y) \wedge \neg Voa(y))$$</code></pre>
<p><strong>Sentença 18</strong>: <em>Para cada estudante, existe um professor que o ensina.</em></p>
<pre><code>$$\forall x (Estudante(x) \rightarrow \exists y (Professor(y) \wedge Ensina(y, x)))$$</code></pre>
<p><strong>Sentença 19</strong>: <em>Existe um cão que late para todos os gatos.</em></p>
<pre><code>$$\exists x (Cão(x) \wedge \forall y (Gato(y) \rightarrow Late(x, y)))$$</code></pre>
<p><strong>Sentença 20</strong>: <em>Para cada carro vermelho, existe um caminhão azul.</em></p>
<pre><code>$$\forall x (Carro(x) \wedge Vermelho(x) \rightarrow \exists y (Caminhão(y) \wedge Azul(y)))$$</code></pre>
<p><strong>Sentença 21</strong>: <em>Todos os planetas orbitam uma estrela, e existe um asteroide que orbita o sol.</em></p>
<pre><code>$$(\forall x (Planeta(x) \rightarrow \exists y (Estrela(y) \wedge Orbita(x, y)))) \wedge (\exists z (Asteroide(z) \wedge Orbita(z, Sol)))$$</code></pre>
</section>
<section id="exercícios-resolvidos-de-conversão-de-expressões-predicativas-em-linguagem-natural" class="level3" data-number="6.5.2">
<h3 data-number="6.5.2" class="anchored" data-anchor-id="exercícios-resolvidos-de-conversão-de-expressões-predicativas-em-linguagem-natural"><span class="header-section-number">6.5.2</span> Exercícios Resolvidos de Conversão de Expressões Predicativas em Linguagem Natural</h3>
<p><strong>1. Fórmula Lógica</strong>: <span class="math inline">\(\forall x (\text{Humano}(x) \rightarrow (\text{Mortal}(x) \wedge \text{Racional}(x)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Humano(x)\)</span>: <em><span class="math inline">\(x\)</span> é um humano</em>.</li>
<li><span class="math inline">\(Mortal(x)\)</span>: <em><span class="math inline">\(x\)</span> é mortal</em>.</li>
<li><span class="math inline">\(Racional(x)\)</span>: <em><span class="math inline">\(x\)</span> é racional</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Todo humano é mortal e racional.</p></li>
</ul>
<p><strong>2. Fórmula Lógica</strong>:<span class="math inline">\(\exists y (\text{Livro}(y) \wedge (\text{Interessante}(y) \vee \text{Complicado}(y)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Livro(y)\)</span>: <em>y é um livro</em>.</li>
<li><span class="math inline">\(Interessante(y)\)</span>: <em>y é interessante</em>.</li>
<li><span class="math inline">\(Complicado(y)\)</span>: <em>y é complicado</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Existe pelo menos um livro que é interessante ou complicado.</p></li>
</ul>
<p><strong>3. Fórmula Lógica</strong>:<span class="math inline">\(\forall x \forall y (\text{Amigos}(x, y) \rightarrow (\text{Confiável}(x) \wedge \text{Honra}(x, y)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Amigos(x, y)\)</span>: <em>x é amigo de y</em>.</li>
<li><span class="math inline">\(Confiável(x)\)</span>: <em>x é confiável</em>.</li>
<li><span class="math inline">\(Honra(x, y)\)</span>: <em>x honra y</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Todo amigo de alguém é confiável e honra o amigo.</p></li>
</ul>
<p><strong>4. Fórmula Lógica</strong>:<span class="math inline">\(\exists x \exists y (\text{Animal}(x) \wedge \text{Planta}(y) \wedge \text{Convive}(x, y))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Animal(x)\)</span>: <em>x é um animal</em>.</li>
<li><span class="math inline">\(Planta(y)\)</span>: <em>y é uma planta</em>.</li>
<li><span class="math inline">\(Convive(x, y)\)</span>: <em>x e y convivem</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Existe pelo menos um animal e uma planta que convivem no mesmo ambiente.</p></li>
</ul>
<p><strong>5. Fórmula Lógica</strong>:<span class="math inline">\(\forall x \exists y (\text{Professor}(x) \rightarrow (\text{Disciplina}(y) \wedge \text{Leciona}(x, y)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Professor(x)\)</span>: <em>x é um professor</em>.</li>
<li><span class="math inline">\(Disciplina(y)\)</span>: <em>y é uma disciplina</em>.</li>
<li><span class="math inline">\(Leciona(x, y)\)</span>: <em>x leciona y</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Para todo professor, existe pelo menos uma disciplina que ele leciona.</p></li>
</ul>
<p><strong>6. Fórmula Lógica</strong>:$ x ((x) y ((y) (x, y))) $</p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Músico(x)\)</span>: <em>x é um músico</em>;</li>
<li><span class="math inline">\(Instrumento(y)\)</span>: <em>y é um instrumento</em>;</li>
<li><span class="math inline">\(Toca(x, y)\)</span>: <em>x toca y</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Existe pelo menos um músico que, se algo é um instrumento, então ele toca esse instrumento. Ou, Existe um músico que toca todos os instrumentos.</p></li>
</ul>
<p><strong>7. Fórmula Lógica</strong>: <span class="math inline">\(\forall x (Gato(x) \rightarrow (Peludo(x) \wedge Dorminhoco(x)))\)</span></p>
<p><span class="math display">\[\text{Todo gato é peludo e dorminhoco.}\]</span></p>
<p><strong>8. Fórmula Lógica</strong>:<span class="math inline">\(\forall y (Árvore(y) \rightarrow (Verde(y) \wedge Grande(y)))\)</span></p>
<p><span class="math display">\[\text{Toda árvore é verde e grande.}\]</span></p>
<p><strong>9. Fórmula Lógica</strong>: <span class="math inline">\((\forall x (Cidade(x) \rightarrow Populosa(x))) \rightarrow (\forall y (País(y) \rightarrow Populoso(y)))\)</span></p>
<p><span class="math display">\[\text{Se toda cidade é populosa, então todo país é populoso.}\]</span></p>
<p><strong>10. Fórmula Lógica</strong>: <span class="math inline">\(\forall x (Criança(x) \rightarrow (Inocente(x) \wedge Curiosa(x))) \wedge \neg \exists y (Adulto(y) \wedge (Inocente(y) \wedge Curioso(y)))\)</span></p>
<p><span class="math display">\[\text{Toda criança é inocente e curiosa, e não existe um adulto que seja inocente e curioso.}\]</span></p>
<p><strong>11. Fórmula Lógica</strong>: <span class="math inline">\(\forall x (Ave(x) \rightarrow Voa(x)) \wedge \forall y (Peixe(y) \rightarrow Nada(y))\)</span></p>
<p><span class="math display">\[\text{Toda ave voa e todo peixe nada.}\]</span></p>
<p><strong>12. Fórmula Lógica</strong>: <span class="math inline">\(\exists x (Pessoa(x) \wedge Feliz(x))\)</span></p>
<p><span class="math display">\[\text{Existe uma pessoa que é feliz.}\]</span></p>
<p><strong>13. Fórmula Lógica</strong>: <span class="math inline">\(\exists y (Livro(y) \wedge Interessante(y) \wedge \neg Longo(y))\)</span></p>
<p><span class="math display">\[\text{Há um livro que é interessante e não é longo.}\]</span></p>
<p><strong>14. Fórmula Lógica</strong>: <span class="math inline">\(\exists x (Estudante(x) \wedge (\forall y (Disciplina(y) \rightarrow Gosta(x, y))))\)</span></p>
<p><span class="math display">\[\text{Existe um estudante que gosta de todas as disciplinas.}\]</span></p>
<p><strong>15. Fórmula Lógica</strong>: <span class="math inline">\(\exists x (Carro(x) \wedge Rápido(x)) \wedge \exists y (Carro(y) \wedge \neg Rápido(y))\)</span></p>
<p><span class="math display">\[\text{Existe um carro que é rápido, e existe um carro que não é rápido.}\]</span></p>
<p><strong>16. Fórmula Lógica</strong>: <span class="math inline">\(\neg \exists x (Político(x) \wedge Honesto(x))\)</span></p>
<pre><code>$$\text{Não existe um político que seja honesto.}$$</code></pre>
<p><strong>17. Fórmula Lógica</strong>: <span class="math inline">\(\forall x (Cachorro(x) \rightarrow (\exists y (Pessoa(y) \wedge Dono(y, x))))\)</span></p>
<pre><code>$$\text{Todo cachorro tem uma pessoa que é seu dono.}$$</code></pre>
<p><strong>18. Fórmula Lógica</strong>: <span class="math inline">\(\exists x (Música(x) \wedge (\forall y (Pessoa(y) \rightarrow Gosta(y, x))))\)</span></p>
<pre><code>$$\text{Existe uma música que todas as pessoas gostam.}$$</code></pre>
<p><strong>19. Fórmula Lógica</strong>: <span class="math inline">\(\forall x (Estudante(x) \rightarrow (\exists y (Professor(y) \wedge Ensina(y, x))))\)</span></p>
<pre><code>$$\text{Para todo estudante, existe um professor que o ensina.}$$</code></pre>
<p><strong>20. Fórmula Lógica</strong>: <span class="math inline">\((\exists x (Médico(x) \wedge Competente(x))) \wedge (\forall y (Médico(y) \rightarrow Ocupado(y)))\)</span></p>
<pre><code>$$\text{Existe um médico que é competente, e todo médico é ocupado.}$$</code></pre>
<p><strong>21. Fórmula Lógica</strong>: <span class="math display">\[(\forall x (Artista(x) \rightarrow Criativo(x))) \rightarrow (\exists y (Pintor(y) \wedge Criativo(y)))\]</span></p>
<pre><code>$$\text{Se todo artista é criativo, então existe um pintor que é criativo.}$$</code></pre>
</section>
</section>
<section id="ordem-de-aplicação-dos-quantificadores" class="level2" data-number="6.6">
<h2 data-number="6.6" class="anchored" data-anchor-id="ordem-de-aplicação-dos-quantificadores"><span class="header-section-number">6.6</span> Ordem de Aplicação dos Quantificadores</h2>
<p>Quando mais de uma variável é quantificada em uma <strong>Fórmula Bem Formada</strong> como <span class="math inline">\(\forall y\forall x P(x,y)\)</span>, elas são aplicadas da esquerda para a direita. Assim, <span class="math inline">\(\forall y\forall x P(x,y)\)</span> se lê <em>para todo <span class="math inline">\(y\)</span>, para todo <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x,y)\)</span> se mantém</em>.</p>
<p>As posições dos mesmos tipos de quantificadores podem ser trocadas sem afetar o valor lógico, desde que não haja quantificadores do outro tipo entre os que serão trocados.</p>
<p>Por exemplo, <span class="math inline">\(\forall x\forall y\forall z P(x,y,z)\)</span> é equivalente a <span class="math inline">\(\forall y\forall x\forall z P(x,y,z)\)</span>, <span class="math inline">\(\forall z\forall y\forall x P(x,y,z)\)</span>. O mesmo vale para o quantificador existencial.</p>
<p>No entanto, as posições de quantificadores de tipos diferentes <strong>não</strong> podem ser trocadas. Por exemplo, <span class="math inline">\(\forall x\exists y P(x,y)\)</span> <strong>não</strong> é equivalente A<span class="math inline">\(\exists y\forall x P(x,y)\)</span>. Por exemplo, seja <span class="math inline">\(P(x,y)\)</span> representando <span class="math inline">\(x &lt; y\)</span> Para o conjunto dos números como universo. Então, <span class="math inline">\(\forall x\exists y P(x,y)\)</span> se lê <em>para todo número <span class="math inline">\(x\)</span>, existe um número <span class="math inline">\(y\)</span> que é maior que <span class="math inline">\(x\)</span></em>, o que é verdadeiro, enquanto <span class="math inline">\(\exists y\forall x P(x,y)\)</span> se lê <em>existe um número que é maior que todo (qualquer) número</em>, o que não é verdadeiro.</p>
</section>
<section id="negação-dos-quantificadores" class="level2" data-number="6.7">
<h2 data-number="6.7" class="anchored" data-anchor-id="negação-dos-quantificadores"><span class="header-section-number">6.7</span> Negação dos Quantificadores</h2>
<p>Existe uma equivalência entre as negações dos quantificadores. De tal forma que:</p>
<ol type="1">
<li><p><strong>Negação do Quantificador Universal ($$)</strong>: A negação de uma afirmação universal significa que existe pelo menos um caso no Universo do Discurso em que a afirmação não é verdadeira. Isso pode ser expresso pela seguinte equivalência:</p>
<p><span class="math display">\[\neg \forall x \, P(x) \equiv \exists x \, \neg P(x)\]</span></p>
<p>Em linguagem natural podemos entender como: negar que <em>para todos os <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span> é verdadeiro</em> é equivalente a afirmar que <em>existe algum <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> não é verdadeiro</em>.</p></li>
<li><p><strong>Negação do Quantificador Existencial ( $$ )</strong>: A negação de uma afirmação existencial significa que a afirmação não é verdadeira para nenhum caso no Universo do Discurso. Isso pode ser expresso pela seguinte equivalência:</p></li>
</ol>
<p><span class="math display">\[\neg \exists x \, P(x) \equiv \forall x \, \neg P(x)\]</span></p>
<p>Ou seja, negar que <em>existe algum <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> é verdadeiro</em> é equivalente a afirmar que <em>para todos os <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span> não é verdadeiro</em>.</p>
<p>Vamos tentar entender estas negações. Considere as expressões <span class="math inline">\(\neg (\forall x P(x))\)</span> e <span class="math inline">\(\exists x (\neg P(x))\)</span>. Essas fórmulas se aplicam a qualquer predicado <span class="math inline">\(P\)</span>, e possuem o mesmo valor de verdade para qualquer <span class="math inline">\(P\)</span>.</p>
<p>Na <strong>Lógica Proposicional</strong>, poderíamos simplesmente verificar isso com uma tabela verdade, mas aqui, não podemos. Não existem proposições, conectadas por $$, $$, para construir uma tabela e não é possível determinar o valor verdade de forma genérica para uma determinada variável.</p>
<p>Vamos tentar entender isso com linguagem natural: afirmar que <span class="math inline">\(\neg (\forall x P(x))\)</span> é verdadeiro significa que não é verdade que <span class="math inline">\(P(x)\)</span> se aplica a todas as possíveis entidades <span class="math inline">\(x\)</span>. Deve haver alguma entidade <span class="math inline">\(A\)</span> Para a qual<span class="math inline">\(P(a)\)</span> é falso. Como <span class="math inline">\(P(a)\)</span> é falso, <span class="math inline">\(\neg P(a)\)</span> é verdadeiro. Isso significa que <span class="math inline">\(\exists x (\neg P(x))\)</span> é verdadeiro. Portanto, a verdade de <span class="math inline">\(\neg (\forall x P(x))\)</span>implica a verdade de <span class="math inline">\(\exists x (\neg P(x))\)</span>.</p>
<p>Se <span class="math inline">\(\neg (\forall x P(x))\)</span> é falso, então <span class="math inline">\(\forall x P(x)\)</span> é verdadeiro. Como <span class="math inline">\(P(x)\)</span> é verdadeiro para todos os <span class="math inline">\(x\)</span>, <span class="math inline">\(\neg P(x)\)</span> é falso para todos os <span class="math inline">\(x\)</span>. Logo, <span class="math inline">\(\exists x (\neg P(x))\)</span> é falso.</p>
<p>Os valores de verdade de <span class="math inline">\(\neg (\forall x P(x))\)</span> e <span class="math inline">\(\exists x (\neg P(x))\)</span> são os mesmos. Como isso é verdadeiro para qualquer predicado <span class="math inline">\(P\)</span>, essas duas fórmulas são logicamente equivalentes, e podemos escrever <span class="math inline">\(\neg (\forall x P(x)) \equiv \exists x (\neg P(x))\)</span>.</p>
<p>Muita lógica? Que tal se tentarmos novamente, usando um pouco mais de linguagem natural. Considere as expressões lógicas <span class="math inline">\(\neg (\forall x P(x))\)</span> e <span class="math inline">\(\exists x (\neg P(x))\)</span>. Para ilustrar essas fórmulas, vamos usar um exemplo com um predicado <span class="math inline">\(P(x)\)</span> que se aplica a uma entidade <span class="math inline">\(x\)</span> se <em><span class="math inline">\(x\)</span> é feliz</em>.</p>
<p>A expressão <span class="math inline">\(\forall x P(x)\)</span> significa que todos são felizes. A negação dessa afirmação, <span class="math inline">\(\neg (\forall x P(x))\)</span>, equivale logicamente a <span class="math inline">\(\exists x (\neg P(x))\)</span>, ou seja, existe pelo menos um indivíduo que não é feliz.</p>
<p>A expressão <span class="math inline">\(\exists x (\neg P(x))\)</span> significa que <em>existe alguém que não está feliz</em>. Você pode ver que isso é apenas outra forma de expressar a ideia contida em <span class="math inline">\(\neg (\forall x P(x))\)</span>.</p>
<p>A afirmação de que <em>não é verdade que todos estão felizes</em> implica que deve haver alguém que não está feliz. Se a primeira afirmação é falsa (ou seja, todos estão felizes), então a segunda afirmação também deve ser falsa.</p>
<p>Portanto, as duas fórmulas têm o mesmo valor verdade. Elas são logicamente equivalentes e podem ser representadas como <span class="math inline">\(\neg (\forall x P(x)) \equiv \exists x (\neg P(x))\)</span>. Esta equivalência reflete uma relação profunda e intuitiva em nosso entendimento de declarações sobre entidades em nosso mundo.</p>
<table class="table">
<thead>
<tr class="header">
<th>Expressão</th>
<th>Equivalência</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\forall x P(x)\)</span></td>
<td><span class="math inline">\(\neg \exists x \neg P(x)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\exists x \, P(x)\)</span></td>
<td><span class="math inline">\(\neg \forall x \, \neg P(x)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\neg \forall x \, P(x)\)</span></td>
<td><span class="math inline">\(\exists x \, \neg P(x)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\neg \exists x \, P(x)\)</span></td>
<td><span class="math inline">\(\forall x \, \neg P(x)\)</span></td>
</tr>
</tbody>
</table>
<p><em>Tabela 5 - Equivalências entre Quantificadores.</em></p>
</section>
<section id="regras-de-inferência-usando-quantificadores" class="level2" data-number="6.8">
<h2 data-number="6.8" class="anchored" data-anchor-id="regras-de-inferência-usando-quantificadores"><span class="header-section-number">6.8</span> Regras de Inferência usando Quantificadores</h2>
<p>As regras de inferência com quantificadores lidam especificamente com as proposições que envolvem quantificadores. Estas regras nos permitem fazer generalizações ou especificações, transformando proposições universais em existenciais, e vice-versa. Compreender essas regras é essencial para aprofundar o entendimento da estrutura da lógica, o que nos permite analisar e construir argumentos mais complexos de forma precisa e coerente.</p>
<p>Nos próximos tópicos, exploraremos essas regras em detalhes, observando como elas interagem com os quantificadores universal e existencial.</p>
<section id="repetição" class="level3" data-number="6.8.1">
<h3 data-number="6.8.1" class="anchored" data-anchor-id="repetição"><span class="header-section-number">6.8.1</span> Repetição</h3>
<p>A regra de Repetição permite repetir uma afirmação. Esta regra é útil para propagar premissas em uma prova formal.</p>
<p><span class="math display">\[F\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;F\\
\hline
&amp;F\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>o céu está azul</em>.</li>
<li>Conclusão: logo, <em>o céu está azul</em>.</li>
</ul>
<p>Algumas aplicações da Repetição:</p>
<ul>
<li><p>Reafirmar premissas em provas longas. Por exemplo:</p>
<ul>
<li>Proposição: <em>todos os homens, <span class="math inline">\(H(x)\)</span>, são mortais, <span class="math inline">\(M(x)\)</span></em>.</li>
<li>Conclusão: logo, <em>todos os homens são mortais</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\forall x(H(x) \rightarrow M(x))\\
\hline
&amp;\forall x(H(x) \rightarrow M(x))
\end{aligned}
\]</span></p>
<ul>
<li><p>Introduzir suposições em provas indiretas. Por exemplo:</p>
<ul>
<li>Proposição: <em>suponha que <span class="math inline">\((2 + 2 = 5)\)</span></em>.</li>
<li>Conclusão: logo, <em>(2 + 2 = 5)$</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;2 + 2 = 5\\
\hline
&amp;2 + 2 = 5
\end{aligned}
\]</span></p>
<ul>
<li><p>Reafirmar fórmulas quantificadas. Por exemplo:</p>
<ul>
<li>Proposição: <em>para todo <span class="math inline">\(x\)</span>, <span class="math inline">\(x + 0 = x\)</span></em>.</li>
<li>Conclusão: logo, <em>para todo <span class="math inline">\(x\)</span>, <span class="math inline">\(x + 0 = x\)</span></em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\forall x(x + 0 = x)\\
\hline
&amp;\forall x(x + 0 = x)
\end{aligned}
\]</span></p>
</section>
<section id="instanciação-universal" class="level3" data-number="6.8.2">
<h3 data-number="6.8.2" class="anchored" data-anchor-id="instanciação-universal"><span class="header-section-number">6.8.2</span> Instanciação Universal</h3>
<p>A regra de Instanciação Universal permite substituir a variável em uma afirmação universalmente quantificada por um termo concreto. Esta regra nos permite derivar casos particulares a partir de afirmações gerais.</p>
<p><span class="math display">\[\forall x P(x)\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\forall x P(x)\\
\hline
&amp;P(a)\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>todos os humanos são mortais</em>.</li>
<li>Conclusão: logo, <em>Sócrates é mortal</em>. Assumindo que Sócrates é humano.</li>
</ul>
<p><strong>Exemplo completo de aplicação</strong>:</p>
<ul>
<li><strong>Premissa 1</strong>: todos os mamíferos respiram ar: <span class="math inline">\(\forall x(M(x) \rightarrow R(x))\)</span>;</li>
<li><strong>Premissa 2</strong>: a baleia é um mamífero: <span class="math inline">\(M(b)\)</span>;</li>
<li><strong>Aplicação da Instanciação Universal à Premissa 1</strong>: <span class="math inline">\(M(b) \rightarrow R(b)\)</span>;</li>
<li><strong>Aplicação de Modus Ponens</strong>:</li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;M(b) \rightarrow R(b)\\
&amp;M(b)\\
\hline
&amp;R(b)
\end{aligned}
\]</span></p>
<ul>
<li><strong>Conclusão</strong>: logo, a baleia respira ar: <span class="math inline">\(R(b)\)</span></li>
</ul>
<p>Algumas aplicações da Instanciação Universal:</p>
<ul>
<li><p>Aplicar regras e princípios gerais. Por exemplo:</p>
<ul>
<li>Proposição: <em>todos os triângulos têm 180 graus internos</em>: <span class="math inline">\(\forall t(T(t) \rightarrow 180^\circ(t))\)</span>;</li>
<li>Premissa adicional: <em>ABC é um triângulo</em>: <span class="math inline">\(T(\text{Triângulo }ABC)\)</span>;</li>
<li>Aplicação da Instanciação Universal: <span class="math inline">\(T(\text{Triângulo }ABC) \rightarrow 180^\circ(\text{Triângulo }ABC)\)</span>;</li>
<li>Aplicação de Modus Ponens:</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;T(\text{Triângulo }ABC) \rightarrow 180^\circ(\text{Triângulo }ABC)\\
&amp;T(\text{Triângulo }ABC)\\
\hline
&amp;180^\circ(\text{Triângulo }ABC)
\end{aligned}
\]</span></p>
<ul>
<li><p>Conclusão: logo, <em>o triângulo <span class="math inline">\(ABC\)</span> tem 180 graus</em>.</p></li>
<li><p>Testar propriedades em membros de conjuntos. Por exemplo:</p>
<ul>
<li>Proposição: <em>todo inteiro é maior que seu antecessor</em>: <span class="math inline">\(\forall x (\mathbb{Z}(x) \rightarrow (x &gt; x-1))\)</span>;</li>
<li>Premissa adicional: <em>5 é um inteiro</em>: <span class="math inline">\(\mathbb{Z}(5)\)</span>;</li>
<li>Aplicação da Instanciação Universal: <span class="math inline">\(\mathbb{Z}(5) \rightarrow (5 &gt; 5-1)\)</span>;</li>
<li>Aplicação de Modus Ponens:</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;\mathbb{Z}(5) \rightarrow (5 &gt; 5-1)\\
&amp;\mathbb{Z}(5)\\
\hline
&amp;5 &gt; 4
\end{aligned}
\]</span></p>
<ul>
<li>Conclusão: logo, <span class="math inline">\(5\)</span> é maior que <span class="math inline">\(4\)</span>.</li>
</ul>
</section>
<section id="generalização-existencial" class="level3" data-number="6.8.3">
<h3 data-number="6.8.3" class="anchored" data-anchor-id="generalização-existencial"><span class="header-section-number">6.8.3</span> Generalização Existencial</h3>
<p>A regra de Generalização Existencial permite inferir que algo existe a partir de uma afirmação concreta. Esta regra nos permite generalizar de exemplos específicos para a existência geral.</p>
<p><span class="math display">\[P(a)\]</span></p>
<p><span class="math display">\[
\begin{aligned}
P(a)\\
\hline
\exists x P(x)\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>Rex é um cachorro</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos um cachorro</em>.</li>
</ul>
<p>Algumas aplicações da Generalização Existencial:</p>
<ul>
<li><p>Inferir existência a partir de exemplos concretos. Por exemplo:</p>
<ul>
<li>Proposição: <em>o urânio-235 é radioativo</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos um elemento químico radioativo</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;R(u_{235})\\
\hline
&amp;\exists x R(x)
\end{aligned}
\]</span></p>
<ul>
<li><p>Concluir que uma propriedade não é vazia. Por exemplo:</p>
<ul>
<li>Proposição: <em>$7 $ é um número primo</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos um número primo</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;P(7)\\
\hline
&amp;\exists x P(x)
\end{aligned}
\]</span></p>
<ul>
<li><p>Inferir a existência de soluções para problemas. Por exemplo:</p>
<ul>
<li>Proposição: <em>$x = 2 $ satisfaz a equação $x + 3 = 5 $</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos uma solução para essa equação</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;S(2)\\
\hline
&amp;\exists x S(x)
\end{aligned}
\]</span></p>
</section>
<section id="instanciação-existencial" class="level3" data-number="6.8.4">
<h3 data-number="6.8.4" class="anchored" data-anchor-id="instanciação-existencial"><span class="header-section-number">6.8.4</span> Instanciação Existencial</h3>
<p>A regra de Instanciação Existencial permite introduzir um novo termo como instância de uma variável existencialmente quantificada. Esta regra nos permite derivar exemplos de afirmações existenciais.</p>
<p><span class="math display">\[\exists x P(x)\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x P(x)\\
\hline
&amp;P(b)\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>existe um cachorro com rabo curto</em>.</li>
<li>Conclusão: logo, <em>algum cachorro específico (que podemos chamar de <span class="math inline">\(c\)</span>) tem rabo curto</em>.</li>
</ul>
<p>Algumas aplicações da Instanciação Existencial:</p>
<ul>
<li><p>Derivar exemplos de existência previamente estabelecida. Por exemplo:</p>
<ul>
<li>Proposição: <em>existem estrelas, $ e $, maiores, $M $, que o Sol, $s $</em>.</li>
<li>Conclusão: logo, <em>existe uma estrela específica, <span class="math inline">\(c\)</span>, que é maior que o Sol</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x (e (x) \wedge M(x, s))\\
\hline
&amp;e(c) \wedge M(c, s)
\end{aligned}
\]</span></p>
<ul>
<li><p>Construir modelos satisfatíveis para predicados existenciais. Por exemplo:</p>
<ul>
<li>Proposição: <em>existem pessoas mais velhas que <span class="math inline">\(25\)</span> Anos</em>.</li>
<li>Conclusão: logo, <em>John tem 30 anos</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x (P(x) \wedge \text{Idade}(x) &gt; 25)\\
\hline
&amp;P(c) \wedge \text{Idade}(c) &gt; 25 \quad (\text{para uma nova constante } c)
\end{aligned}
\]</span></p>
<ul>
<li><p>Provar que conjuntos não estão vazios. Por exemplo:</p>
<ul>
<li>Proposição: <em>existem números reais maiores que <span class="math inline">\(2\)</span></em>.</li>
<li>Conclusão: logo, <em><span class="math inline">\(5\)</span> é um número real maior que <span class="math inline">\(2\)</span></em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x (R(x) \wedge x &gt; 2)\\
\hline
&amp;R(d) \wedge d &gt; 2 \quad (\text{para uma nova constante } d)
\end{aligned}
\]</span></p>
</section>
</section>
<section id="exercícios-de-conexão-com-o-prolog" class="level2" data-number="6.9">
<h2 data-number="6.9" class="anchored" data-anchor-id="exercícios-de-conexão-com-o-prolog"><span class="header-section-number">6.9</span> Exercícios de Conexão com o Prolog</h2>
<p>Estas questões de Lógica Predicativa estabelecem os fundamentos conceituais essenciais para Prolog:</p>
<ol type="1">
<li><strong>Predicados</strong> se tornam <strong>fatos</strong> e <strong>cabeças de regras</strong></li>
<li><strong>Quantificadores universais</strong> correspondem a <strong>variáveis em regras</strong><br>
</li>
<li><strong>Quantificadores existenciais</strong> correspondem a <strong>consultas</strong> e <strong>instanciações</strong></li>
<li><strong>Implicações</strong> se tornam <strong>regras</strong> (<code>:-</code>)</li>
<li><strong>Conjunções</strong> se tornam <strong>múltiplas condições</strong> nas regras</li>
<li><strong>Negação</strong> se torna <strong>negação por falha</strong> (<code>\+</code>)</li>
</ol>
<p>A modelagem em Lógica de Predicados fornece a base teórica que o Prolog implementa por meio de seu mecanismo de resolução e unificação.</p>
<p><strong>Questão 1: Relações em um Sistema Acadêmico</strong><br>
Considere um “mundo” acadêmico com alunos e cursos. Use os seguintes predicados:</p>
<ul>
<li><span class="math inline">\(A(x)\)</span>: “x é um aluno”</li>
<li><span class="math inline">\(C(x)\)</span>: “x é um curso”<br>
</li>
<li><span class="math inline">\(M(x,y)\)</span>: “o aluno x está matriculado no curso y”</li>
</ul>
<p>Traduza as seguintes sentenças para fórmulas da lógica de predicados:</p>
<ol type="1">
<li>Existe pelo menos um aluno</li>
<li>Nem todo aluno está matriculado em algum curso</li>
<li>Todo aluno está matriculado em pelo menos um curso</li>
<li>Existe um curso no qual nenhum aluno está matriculado</li>
<li>Existe um aluno que está matriculado em todos os cursos</li>
</ol>
<p><strong>Questão 2: O Escopo dos Quantificadores</strong><br>
A ordem dos quantificadores altera drasticamente o significado de uma sentença. Usando os predicados <span class="math inline">\(Pessoa(x)\)</span> e <span class="math inline">\(Ama(x,y)\)</span> (“x ama y”), traduza e explique a diferença semântica entre as duas sentenças abaixo:</p>
<ol type="1">
<li><span class="math inline">\(\forall x \exists y (Pessoa(x) \to (Pessoa(y) \wedge Ama(x,y)))\)</span></li>
<li><span class="math inline">\(\exists y \forall x (Pessoa(x) \to (Pessoa(y) \wedge Ama(x,y)))\)</span></li>
</ol>
<p>Qual das duas sentenças descreve melhor o conceito de “amor fraternal universal” e qual descreve a existência de uma “figura universalmente amada por todos”?</p>
<p><strong>Questão 3: O Paradoxo do Barbeiro</strong><br>
Em uma cidade, há um único barbeiro. A regra que define seu trabalho é: “O barbeiro barbeia todos os homens da cidade que não se barbeiam a si mesmos, e apenas esses”.</p>
<p>Use o predicado <span class="math inline">\(Barbeia(x,y)\)</span> para representar “x barbeia y”. Seja <span class="math inline">\(b\)</span> a constante que representa o barbeiro.</p>
<ol type="1">
<li>Traduza a regra para uma fórmula da lógica de predicados</li>
<li>Mostre, por meio de dedução lógica, que essa regra leva a uma contradição ao se perguntar: “Quem barbeia o barbeiro?” (ou seja, ao analisar a proposição <span class="math inline">\(Barbeia(b,b)\)</span>)</li>
</ol>
<p><strong>Questão 4: Especificação de um Sistema de Arquivos</strong><br>
Modele as permissões de um sistema de arquivos com os predicados:</p>
<ul>
<li><span class="math inline">\(Admin(x)\)</span>: “x é um administrador”</li>
<li><span class="math inline">\(Arquivo(y)\)</span>: “y é um arquivo”</li>
<li><span class="math inline">\(PodeAcessar(x,y)\)</span>: “x pode acessar y”</li>
</ul>
<p>A política de segurança do sistema é: “Qualquer administrador pode acessar todos os arquivos. Ninguém que não seja administrador pode acessar algum arquivo”.</p>
<ol type="1">
<li>Traduza a política para um conjunto de fórmulas lógicas</li>
<li>Suponha os seguintes fatos: <span class="math inline">\(Admin(ana)\)</span> e <span class="math inline">\(\neg Admin(beto)\)</span>. O que podemos concluir sobre <span class="math inline">\(PodeAcessar(ana, relatorio.doc)\)</span> e <span class="math inline">\(PodeAcessar(beto, relatorio.doc)\)</span>?</li>
</ol>
<p><strong>Questão 5: Negando Afirmações Universais</strong><br>
Negar sentenças com quantificadores é uma habilidade fundamental para entender a falha em Prolog (negação por falha). Forneça a negação formal das seguintes sentenças, movendo o símbolo de negação (<span class="math inline">\(\neg\)</span>) o mais para dentro possível da fórmula.</p>
<ol type="1">
<li>“Todos os programas de computador têm pelo menos um bug”
<ul>
<li>Use: <span class="math inline">\(Programa(x)\)</span>, <span class="math inline">\(Bug(y)\)</span>, <span class="math inline">\(Tem(x,y)\)</span></li>
</ul></li>
<li>“Existe um político que é honesto com todos os seus eleitores”
<ul>
<li>Use: <span class="math inline">\(Politico(x)\)</span>, <span class="math inline">\(Eleitor(y,x)\)</span> (“y é eleitor de x”), <span class="math inline">\(HonestoCom(x,y)\)</span></li>
</ul></li>
</ol>
<p><strong>Questão 6: Mundo dos Blocos (Planejamento em IA)</strong></p>
<p>Considere um cenário simples de IA com os predicados: * <span class="math inline">\(Bloco(x)\)</span>: “<span class="math inline">\(x\)</span> é um bloco” * <span class="math inline">\(EmCima(x,y)\)</span>: “o bloco <span class="math inline">\(x\)</span> está em cima do bloco <span class="math inline">\(y\)</span>” * <span class="math inline">\(Azul(x)\)</span>: “o bloco <span class="math inline">\(x\)</span> é azul” * <span class="math inline">\(Verde(x)\)</span>: “o bloco <span class="math inline">\(x\)</span> é verde” * <span class="math inline">\(NaMesa(x)\)</span>: “o bloco <span class="math inline">\(x\)</span> está diretamente sobre a mesa”</p>
<p>Dados os seguintes axiomas sobre o estado do mundo:</p>
<ol type="1">
<li><p><strong>Axioma 1</strong>: Existe um bloco verde em cima de um bloco azul <span class="math display">\[\exists x \exists y (Bloco(x) \wedge Bloco(y) \wedge Verde(x) \wedge Azul(y) \wedge EmCima(x,y))\]</span></p></li>
<li><p><strong>Axioma 2</strong>: Todo bloco que está diretamente sobre a mesa é azul <span class="math display">\[\forall x ((Bloco(x) \wedge NaMesa(x)) \rightarrow Azul(x))\]</span></p></li>
<li><p><strong>Axioma 3</strong>: Nenhum bloco pode estar simultaneamente em cima de outro bloco e sobre a mesa <span class="math display">\[\forall x (Bloco(x) \rightarrow \neg(\exists y (Bloco(y) \wedge EmCima(x,y)) \wedge NaMesa(x)))\]</span></p></li>
<li><p><strong>Axioma 4</strong>: Nenhum bloco pode ser verde e azul simultaneamente <span class="math display">\[\forall x (Bloco(x) \rightarrow \neg(Verde(x) \wedge Azul(x)))\]</span></p></li>
</ol>
<p><strong>Prove formalmente que</strong>: “Existe um bloco que não é verde” <span class="math display">\[\exists x (Bloco(x) \wedge \neg Verde(x))\]</span></p>
<p><strong>Dica para a prova</strong>: Use o Axioma 1 para estabelecer a existência de um bloco azul, depois aplique o Axioma 4 para mostrar que esse bloco não pode ser verde.</p>
<p><strong>Questão 7: Propriedades dos Números Inteiros</strong><br>
Seja o domínio de discurso o conjunto dos números inteiros (<span class="math inline">\(\mathbb{Z}\)</span>). Use os predicados <span class="math inline">\(Par(x)\)</span>, <span class="math inline">\(Impar(x)\)</span> e os símbolos usuais da matemática. Traduza as seguintes sentenças para a lógica de predicados:</p>
<ol type="1">
<li>Todo número par é maior que algum número ímpar</li>
<li>Não existe um número inteiro que seja o maior de todos<br>
</li>
<li>A soma de quaisquer dois números pares é par</li>
</ol>
<p><strong>Questão 8: Dedução Lógica com Instanciação</strong><br>
Considere as seguintes premissas:</p>
<ol type="1">
<li>Todos os leões são mamíferos: <span class="math inline">\(\forall x (Leao(x) \to Mamifero(x))\)</span></li>
<li>Alguns leões vivem na savana: <span class="math inline">\(\exists x (Leao(x) \wedge ViveNaSavana(x))\)</span></li>
</ol>
<p>Usando as regras de dedução da lógica de predicados (Instanciação Universal, Instanciação Existencial, Modus Ponens, etc.), prove formalmente que “Alguns mamíferos vivem na savana”: <span class="math inline">\(\exists x (Mamifero(x) \wedge ViveNaSavana(x))\)</span>.</p>
<p><strong>Questão 9: Consulta a uma Base de Dados Relacional</strong><br>
Imagine uma base de dados com as tabelas Funcionario(ID, Nome, DeptoID) e Departamento(ID, NomeDepto). Modele este esquema com os predicados:</p>
<ul>
<li><span class="math inline">\(Func(x,n,d)\)</span>: “o funcionário com ID x tem nome n e trabalha no departamento d”</li>
<li><span class="math inline">\(Depto(d,m)\)</span>: “o departamento com ID d tem nome m”</li>
</ul>
<p>Formule a seguinte consulta em lógica de predicados: “Encontre os nomes de todos os funcionários que trabalham no departamento de ‘Vendas’”.</p>
<p><strong>Questão 10: Hierarquia Organizacional</strong><br>
Modele a estrutura de uma empresa com os predicados:</p>
<ul>
<li><span class="math inline">\(Funcionario(x)\)</span>: “x é um funcionário”</li>
<li><span class="math inline">\(Gerente(x,y)\)</span>: “x é gerente de y”<br>
</li>
<li><span class="math inline">\(Salario(x,s)\)</span>: “o salário de x é s”</li>
</ul>
<p>Traduza as seguintes regras de negócio para a lógica de predicados:</p>
<ol type="1">
<li>Todo funcionário tem exatamente um gerente</li>
<li>Nenhum funcionário pode ser gerente de si mesmo</li>
<li>Todo gerente é também um funcionário</li>
<li>Existe um funcionário que não é gerente de ninguém</li>
</ol>
<p><strong>Questão 11: Sistema Bancário</strong>:</p>
<p><strong>Cenário</strong>: Banco com clientes e contas <strong>Entidades</strong>: Clientes, contas bancárias, transações <strong>Regras de Negócio</strong>:</p>
<ul>
<li>Todo cliente possui pelo menos uma conta;</li>
<li>Toda conta pertence a exatamente um cliente;</li>
<li>Contas podem ter saldo positivo ou negativo;</li>
<li>Existem clientes VIP que têm mais de uma conta;</li>
<li>Nem todas as contas têm saldo positivo.</li>
</ul>
<p><strong>Sua tarefa</strong>:</p>
<ol type="1">
<li>Defina os predicados necessários;</li>
<li>Formalize as regras usando quantificadores;</li>
<li>Crie 3 consultas úteis para o sistema.</li>
</ol>
<p><strong>Questão 12: Sistema de Saúde</strong>:</p>
<p><strong>Cenário</strong>: Hospital com médicos, pacientes e tratamentos. <strong>Entidades</strong>: Médicos, pacientes, tratamentos, especialidades. <strong>Regras de Negócio</strong>:</p>
<ul>
<li>Todo paciente é atendido por pelo menos um médico;</li>
<li>Todo médico tem uma especialidade;</li>
<li>Alguns tratamentos requerem médicos especialistas;</li>
<li>Existem pacientes internados e ambulatoriais;</li>
<li>Todo tratamento é prescrito por algum médico.</li>
</ul>
<p><strong>Sua tarefa</strong>:</p>
<ol type="1">
<li>Defina os predicados necessários;</li>
<li>Formalize as regras usando quantificadores;</li>
<li>Crie 3 consultas úteis para o sistema.</li>
</ol>
<p><strong>Questão 13: Rede Social</strong>:</p>
<p><strong>Cenário</strong>: Plataforma social como Facebook <strong>Entidades</strong>: Usuários, postagens, curtidas, amizades <strong>Regras de Negócio</strong>:</p>
<ul>
<li>Amizade é uma relação simétrica;</li>
<li>Todo usuário pode publicar postagens;</li>
<li>Usuários podem curtir postagens de amigos;</li>
<li>Existem usuários influenciadores;</li>
<li>Nem toda postagem recebe curtidas.</li>
</ul>
<p><strong>Sua tarefa</strong>:</p>
<ol type="1">
<li>Defina os predicados necessários;</li>
<li>Formalize as regras usando quantificadores;</li>
<li>Crie 3 consultas úteis para o sistema.</li>
</ol>
<p><strong>Questão 14: Sistema de Biblioteca</strong>:</p>
<p><strong>Cenário</strong>: Biblioteca universitária. <strong>Entidades</strong>: Livros, usuários, empréstimos, reservas. <strong>Regras de Negócio</strong>:</p>
<ul>
<li>Um usuário pode pegar vários livros;</li>
<li>Um livro só pode estar com um usuário por vez;</li>
<li>Nem todos os livros estão emprestados;</li>
<li>Existem livros que nunca foram emprestados;</li>
<li>Todo empréstimo tem data de devolução.</li>
</ul>
<p><strong>Sua tarefa</strong>:</p>
<ol type="1">
<li>Defina os predicados necessários;</li>
<li>Formalize as regras usando quantificadores;</li>
<li>Crie 3 consultas úteis para o sistema.</li>
</ol>
<p><strong>Questão 15: Sistema de E-commerce</strong>:</p>
<p><strong>Cenário</strong>: Loja online como Amazon. <strong>Entidades</strong>: Produtos, clientes, pedidos, categorias, avaliações. <strong>Regras de Negócio</strong>:</p>
<ul>
<li>Todo produto pertence a pelo menos uma categoria;</li>
<li>Todo pedido é feito por exatamente um cliente;</li>
<li>Nem todo produto tem avaliações;</li>
<li>Existem produtos em promoção;</li>
<li>Clientes podem fazer múltiplos pedidos.</li>
</ul>
<p><strong>Sua tarefa</strong>:</p>
<ol type="1">
<li>Defina os predicados necessários;</li>
<li>Formalize as regras usando quantificadores;</li>
<li>Crie 3 consultas úteis para o sistema.</li>
</ol>
<p><strong>Questão 16: Sistema de Transporte</strong>:</p>
<p><strong>Cenário</strong>: App de transporte como Uber. <strong>Entidades</strong>: Motoristas, passageiros, viagens, veículos, avaliações.</p>
<p><strong>Regras de Negócio</strong>:</p>
<ul>
<li>Todo motorista possui exatamente um veículo;</li>
<li>Toda viagem conecta um passageiro a um motorista;</li>
<li>Nem toda viagem recebe avaliação;</li>
<li>Existem motoristas premium (alta avaliação);</li>
<li>Passageiros podem avaliar motoristas.</li>
</ul>
<p><strong>Sua tarefa</strong>:</p>
<ol type="1">
<li>Defina os predicados necessários;</li>
<li>Formalize as regras usando quantificadores;</li>
<li>Crie 3 consultas úteis para o sistema.</li>
</ol>
<p><strong>Questão 17: Sistema Universitário</strong>:</p>
<p><strong>Cenário</strong>: Gestão acadêmica completa. <strong>Entidades</strong>: Estudantes, professores, disciplinas, cursos, notas.</p>
<p><strong>Regras de Negócio</strong>:</p>
<ul>
<li>Todo estudante está matriculado em um curso;</li>
<li>Toda disciplina é ministrada por pelo menos um professor;</li>
<li>Nem todo estudante tem nota em todas as disciplinas;</li>
<li>Existem disciplinas obrigatórias e optativas;</li>
<li>Todo professor ensina disciplinas da sua área.</li>
</ul>
<p><strong>Sua tarefa</strong>:</p>
<ol type="1">
<li>Defina os predicados necessários;</li>
<li>Formalize as regras usando quantificadores;</li>
<li>Crie 3 consultas úteis para o sistema.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="pagination-link" aria-label="A Arte da Prova e Análise de Argumentos">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">A Arte da Prova e Análise de Argumentos</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./05-formas-normais-e-skolemizacao.html" class="pagination-link" aria-label="Formas Normais Organizando o Pensamento Lógico">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais Organizando o Pensamento Lógico</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/04-logica-predicativa-e-quantificadores.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>