<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 5&nbsp; Lógica Predicativa</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./05-formas-normais-e-skolemizacao.html" rel="next">
<link href="./03-arte-da-prova-e-analise-de-argumentos.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-jornada-programacao-logica.html">Fundamentos da Lógica</a></li><li class="breadcrumb-item"><a href="./04-logica-predicativa-e-quantificadores.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Lógica Predicativa</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Provas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Formas Normais</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Mundos na Lógica de Primeira Ordem</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Cláusulas de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Problemas Interessantes Resolvidos com Lógica Proposicional e Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#introdução-aos-predicados" id="toc-introdução-aos-predicados" class="nav-link active" data-scroll-target="#introdução-aos-predicados"><span class="header-section-number">5.0.1</span> Introdução aos Predicados</a></li>
  <li><a href="#universo-do-discurso" id="toc-universo-do-discurso" class="nav-link" data-scroll-target="#universo-do-discurso"><span class="header-section-number">5.0.2</span> Universo do Discurso</a></li>
  <li><a href="#entendendo-predicados" id="toc-entendendo-predicados" class="nav-link" data-scroll-target="#entendendo-predicados"><span class="header-section-number">5.0.3</span> Entendendo Predicados</a></li>
  <li><a href="#quantificadores" id="toc-quantificadores" class="nav-link" data-scroll-target="#quantificadores"><span class="header-section-number">5.0.4</span> Quantificadores</a></li>
  <li><a href="#equivalências-interessantes" id="toc-equivalências-interessantes" class="nav-link" data-scroll-target="#equivalências-interessantes"><span class="header-section-number">5.0.5</span> Equivalências Interessantes</a></li>
  <li><a href="#dos-predicados-à-linguagem-natural" id="toc-dos-predicados-à-linguagem-natural" class="nav-link" data-scroll-target="#dos-predicados-à-linguagem-natural"><span class="header-section-number">5.0.6</span> Dos Predicados à Linguagem Natural</a></li>
  <li><a href="#exercícios-de-conversão-de-linguagem-natural-em-expressões-predicativas" id="toc-exercícios-de-conversão-de-linguagem-natural-em-expressões-predicativas" class="nav-link" data-scroll-target="#exercícios-de-conversão-de-linguagem-natural-em-expressões-predicativas"><span class="header-section-number">5.0.7</span> Exercícios de Conversão de Linguagem Natural em Expressões Predicativas</a></li>
  <li><a href="#exercícios-de-conversão-de-expressões-predicativas-em-linguagem-natural" id="toc-exercícios-de-conversão-de-expressões-predicativas-em-linguagem-natural" class="nav-link" data-scroll-target="#exercícios-de-conversão-de-expressões-predicativas-em-linguagem-natural"><span class="header-section-number">5.0.8</span> Exercícios de Conversão de Expressões Predicativas em Linguagem Natural</a></li>
  <li><a href="#exemplos-extras-de-conversão-de-sentenças-em-predicados" id="toc-exemplos-extras-de-conversão-de-sentenças-em-predicados" class="nav-link" data-scroll-target="#exemplos-extras-de-conversão-de-sentenças-em-predicados"><span class="header-section-number">5.0.9</span> Exemplos Extras de conversão de sentenças em predicados</a></li>
  <li><a href="#exemplos-extras-de-conversão-de-predicados-em-sentenças" id="toc-exemplos-extras-de-conversão-de-predicados-em-sentenças" class="nav-link" data-scroll-target="#exemplos-extras-de-conversão-de-predicados-em-sentenças"><span class="header-section-number">5.0.10</span> Exemplos Extras de Conversão de Predicados em Sentenças</a></li>
  <li><a href="#ordem-de-aplicação-dos-quantificadores" id="toc-ordem-de-aplicação-dos-quantificadores" class="nav-link" data-scroll-target="#ordem-de-aplicação-dos-quantificadores"><span class="header-section-number">5.0.11</span> Ordem de Aplicação dos Quantificadores</a></li>
  <li><a href="#regras-de-inferência-usando-quantificadores" id="toc-regras-de-inferência-usando-quantificadores" class="nav-link" data-scroll-target="#regras-de-inferência-usando-quantificadores"><span class="header-section-number">5.0.12</span> Regras de Inferência usando Quantificadores</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/04-logica-predicativa-e-quantificadores.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-jornada-programacao-logica.html">Fundamentos da Lógica</a></li><li class="breadcrumb-item"><a href="./04-logica-predicativa-e-quantificadores.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Lógica Predicativa</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Lógica Predicativa</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>A lógica é a técnica que usamos para adicionar convicção à verdade. Jean de la Bruyere{: class=“epigraph”}</p>
</blockquote>
<p>A Lógica Predicativa, coração e espírito da Lógica de Primeira Ordem, nos leva um passo além da Lógica Proposicional. Em vez de se concentrar apenas em proposições completas que são verdadeiras ou falsas, a lógica predicativa nos permite expressar proposições sobre objetos e as relações entre eles. Ela nos permite falar de forma mais rica e sofisticada sobre o mundo.</p>
<p>Vamos lembrar que na Lógica Proposicional, cada proposição é um átomo indivisível. Por exemplo, ‘A chuva cai’ ou ‘O sol brilha’. Cada uma dessas proposições é verdadeira ou falsa como uma unidade. Na lógica predicativa, no entanto, podemos olhar para dentro dessas proposições. Podemos falar sobre o sujeito - a chuva, o sol - e o predicado - cai, brilha. Podemos quantificar sobre eles: para todos os dias, existe um momento em que o sol brilha.</p>
<p>Enquanto a Lógica Proposicional pode ser vista como a aritmética do verdadeiro e do falso, a lógica predicativa é a álgebra do raciocínio. Ela nos permite manipular proposições de forma muito mais rica e expressiva. Com ela, podemos começar a codificar partes substanciais da matemática e da ciência, levando-nos mais perto de nossa busca para decifrar o cosmos, um símbolo de lógica de cada vez.</p>
<section id="introdução-aos-predicados" class="level3" data-number="5.0.1">
<h3 data-number="5.0.1" class="anchored" data-anchor-id="introdução-aos-predicados"><span class="header-section-number">5.0.1</span> Introdução aos Predicados</h3>
<p>Um predicado é como uma luneta que nos permite observar as propriedades de uma entidade. Um conjunto de lentes através do qual podemos ver se uma entidade particular possui ou não uma característica específica. A palavra predicado foi importada do campo da linguística e tem o mesmo significado: qualidade; característica. Por exemplo, ao observar o universo das letras através do telescópio do predicado <em>ser uma vogal</em>, percebemos que algumas entidades deste conjunto, como <span class="math inline">\(A\)</span> e $I $, possuem essa propriedade, enquanto outras, como $ g$ e <span class="math inline">\(H\)</span>, não.</p>
<p>Um predicado não é uma afirmação absoluta de verdade ou falsidade. Divergindo das proposições, os predicados não são declarações completas. Pense neles como aquelas sentenças com espaços em branco, aguardando para serem preenchidos, que só têm sentido completo quando preenchidas:</p>
<ol type="1">
<li><p>O _______ está saboroso;</p></li>
<li><p>O _______ é vermelho;</p></li>
<li><p>_______ é alto.</p></li>
</ol>
<p>Preencha as lacunas, como quiser desde que faça sentido, e perceba que, em cada caso, ao preencher estamos atribuindo uma qualidade a um objeto. Esses são exemplos de predicados do nosso cotidiano, que sinteticamente o conceito que queremos abordar. Na lógica, os predicados são artefatos que possibilitam examinar o mundo ao nosso redor de forma organizada e exata.</p>
<p>Um predicado pode ser entendido como uma função que recebe um objeto (ou um conjunto de objetos) e retorna um valor de verdade, <span class="math inline">\(\{\text{verdadeiro ou falso}\}\)</span>. Esta função descreve uma propriedade que o objeto pode possuir. Isto é, se <span class="math inline">\(P\)</span> é uma função <span class="math inline">\(P: U \rightarrow \\{\text{Verdadeiro, Falso}\\}\)</span> Para um determinado conjunto $ u$ qualquer. Esse conjunto $ u$ é chamado de <em>universo ou domínio do discurso</em>, e dizemos que <span class="math inline">\(P\)</span> é um predicado sobre $ u$.</p>
</section>
<section id="universo-do-discurso" class="level3" data-number="5.0.2">
<h3 data-number="5.0.2" class="anchored" data-anchor-id="universo-do-discurso"><span class="header-section-number">5.0.2</span> Universo do Discurso</h3>
<p>O universo do discurso, <span class="math inline">\(U\)</span>, também chamado de <strong>universo</strong>, ou domínio, é o conjunto de objetos de interesse em um determinado cenário lógico para uma análise específica. O universo do discurso é importante porque as proposições na Lógica de Predicados serão declarações sobre objetos de um universo.</p>
<p>O universo, <span class="math inline">\(U\)</span>, é o domínio das variáveis das nossas Fórmulas Bem Formadas. O universo do discurso pode ser o conjunto dos números reais, <span class="math inline">\(\mathbb{R}\)</span> o conjunto dos inteiros, <span class="math inline">\(\mathbb{z}\)</span>, o conjunto de todos os alunos em uma sala de aula que usam camisa amarela, ou qualquer outro conjunto que definamos. Na prática, o universo costuma ser deixado implícito e deveria ser óbvio a partir do contexto. Se não for o caso, precisa ser explicitado.</p>
<p>Se estamos interessados em proposições sobre números naturais, <span class="math inline">\(\mathbb{N}\)</span>, o universo do discurso é o conjunto <span class="math inline">\(\mathbb{N} = \{0, 1, 2, 3,...\}\)</span>, um conjunto infinito. Já se estamos interessados em proposições sobre alunos de uma sala de aula, o universo do discurso poderia ser o conjunto $ u = {, , …}$, um conjunto finito.</p>
<p>Para que este conceito fique mais claro, suponha que temos um conjunto de números <span class="math inline">\(U = \\{1, 2, 3, 4, 5\\}\)</span> e um predicado <span class="math inline">\(P(u)\)</span>, que dizemos unário por ter um, e somente um, argumento, que afirma <em>u é par</em>. Ao aplicarmos este predicado a cada elemento do universo <span class="math inline">\(U\)</span>, obtemos um conjunto de valores verdade:</p>
<p><span class="math display">\[
\begin{align}
&amp;P(1) = \text{falso};\\
&amp;P(2) = \text{verdadeiro};\\
&amp;P(3) = \text{falso};\\
&amp;P(4) = \text{verdadeiro};\\
&amp;P(5) = \text{falso}.
\end{align}
\]</span></p>
<p>Vemos que o predicado <span class="math inline">\(P(u)\)</span> dado por <em>u é par</em> é uma propriedade que alguns números do conjunto $ u$ Possuem, e outros não. Vale notar que na Lógica Predicativa, a função que define um predicado pode ter múltiplos argumentos. Por exemplo, podemos ter um predicado <span class="math inline">\(Q(x, y)\)</span> que afirma <em>x é maior que y</em>. Neste caso, o predicado <span class="math inline">\(Q\)</span> é uma função de dois argumentos que retorna um valor de verdade. Dizemos que <span class="math inline">\(Q(x, y)\)</span> é um predicado binário. Exemplos nos conduzem ao caminho do entendimento:</p>
<ol type="1">
<li><p><strong>Exemplo 1</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(U = \text{conjunto de todas as pessoas}\)</span>.</li>
<li>Predicado:<span class="math inline">\(P(x) = \\{ x : x \text{ é um matemático} \\}\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(P(x)\)</span> é verdadeiro: Carl Gauss, Leonhard Euler, John Von Neumann.</li>
</ul></li>
<li><p><strong>Exemplo 2</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(U = \{x \in \mathbb{Z} : x \text{ é par}\}\)</span></li>
<li>Predicado: <span class="math inline">\(Q(x) = (x &gt; 5)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(Q(x)\)</span> é verdadeiro: $6 $, $8 $, <span class="math inline">\(10 ...\)</span>.</li>
</ul></li>
<li><p><strong>Exemplo 3</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(U = \{x \in \mathbb{R} : x &gt; 0 \text{ e } x &lt; 10\}\)</span></li>
<li>Predicado: <span class="math inline">\(R(x) = (x^2 - 4 = 0)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(R(x)\)</span> é verdadeiro: <span class="math inline">\(2\)</span>, <span class="math inline">\(-2\)</span>.</li>
</ul></li>
<li><p><strong>Exemplo 4</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(U = \\{x \in \mathbb{N} : x \text{ é um múltiplo de } 3\\}\)</span></li>
<li>Predicado: <span class="math inline">\(S(x) = (\text{mod}(x, 2) = 0)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(S(x)\)</span> é verdadeiro: <span class="math inline">\(6\)</span>, <span class="math inline">\(12\)</span>, $18 $.</li>
</ul></li>
<li><p><strong>Exemplo 5</strong>:</p>
<ul>
<li>Universo do discurso: <span class="math inline">\(U = \{(x, y) \in \mathbb{R}^2 : x \neq y\}\)</span></li>
<li>Predicado: <span class="math inline">\(P(x, y) = (x &lt; y)\)</span>;</li>
<li>Itens para os quais <span class="math inline">\(P(x, y)\)</span> é verdadeiro: <span class="math inline">\((1, 2)\)</span>, <span class="math inline">\((3, 4)\)</span>, <span class="math inline">\((5, 6)\)</span>.</li>
</ul></li>
</ol>
</section>
<section id="entendendo-predicados" class="level3" data-number="5.0.3">
<h3 data-number="5.0.3" class="anchored" data-anchor-id="entendendo-predicados"><span class="header-section-number">5.0.3</span> Entendendo Predicados</h3>
<p>A aridade do predicado, número de argumentos, é limitado pela análise lógica que estamos fazendo. Considere um predicado ternário, <span class="math inline">\(R\)</span>, dado por <em>x está entre y e z</em>. Quando substituímos <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> e <span class="math inline">\(z\)</span> Por números específicos podemos validar a verdade do predicado <span class="math inline">\(R\)</span>. Vamos considerar alguns exemplos adicionais de predicados baseados na aritmética e defini-los com menos formalidade e mais legibilidade:</p>
<ol type="1">
<li>$ Primo(n)$: o número inteiro positivo $ n$ é um número primo.</li>
<li>$ PotênciaDe (n, k)$: o número inteiro $ n$ é uma potência exata de <span class="math inline">\(k : n = ki\)</span> Para algum <span class="math inline">\(i \in \mathbb{Z} ≥ 0\)</span>.</li>
<li>$ somaDeDoisPrimos(n)$: o número inteiro positivo $ n$ é igual à soma de dois números primos.</li>
</ol>
<p>Em 1, 2 e 3 os predicados estão definidos com mnemônicos aumentando a legibilidade e melhorando nossa capacidade de manter o universo implícito. O uso de predicados, e da Lógica Proposicional, permite a escrita de sentenças menos ambíguas para a definição de conceitos lógicos em formato matemático. Por exemplo: se <span class="math inline">\(x\)</span> é um ancestral de <span class="math inline">\(y\)</span> e <span class="math inline">\(y\)</span> é um ancestral de <span class="math inline">\(z\)</span> então <span class="math inline">\(x\)</span> é um ancestral de <span class="math inline">\(z\)</span>; que, se consideramos o predicado $AncestralDe $ Pode ser escrito como <span class="math inline">\(AncestralDe (x,y) \wedge ancestralDe (y,z) \rightarrow ancestralDe (x,z)\)</span>. Ainda assim, falta alguma coisa. Algo que permita aplicar os predicados a um conjunto de elementos dentro do universo do discurso. É aqui que entram os quantificadores.</p>
</section>
<section id="quantificadores" class="level3" data-number="5.0.4">
<h3 data-number="5.0.4" class="anchored" data-anchor-id="quantificadores"><span class="header-section-number">5.0.4</span> Quantificadores</h3>
<p>Embora a Lógica Proposicional seja um bom ponto de partida, a maioria das afirmações interessantes em matemática contêm variáveis definidas em domínios maiores do que apenas <span class="math inline">\(\\{\text{Verdadeiro}, \text{Falso}\\}\)</span>. Por exemplo, a afirmação <em><span class="math inline">\(x \text{é uma potência de } 2\)</span></em> não é uma proposição. Não temos como definir a verdade dessa afirmação até conhecermos o valor de <span class="math inline">\(x\)</span>. Se <span class="math inline">\(P(x)\)</span> é definido como a afirmação <em><span class="math inline">\(x \text{é uma potência de } 2\)</span></em>, então <span class="math inline">\(P(8)\)</span> é verdadeiro e <span class="math inline">\(P(7)\)</span> é falso.</p>
<p>Para termos uma linguagem lógica que seja suficientemente flexível para representar os problemas que encontramos no Universo real, o Universo em que vivemos, precisaremos ser capazes de dizer quando o predicado <span class="math inline">\(P\)</span> ou <span class="math inline">\(Q\)</span> é verdadeiro para valores diferentes em seus argumentos. Para tanto, vincularemos as variáveis aos predicados usando operadores para indicar quantidade, chamados de quantificadores.</p>
<p>Os quantificadores indicam se a sentença que estamos criando se aplica a todos os valores possíveis do argumento, <em>quantificação universal</em>, ou se esta sentença se aplica a um valor específico, <em>quantificação existencial</em>. Usaremos esses quantificadores para fazer declarações sobre <strong>todos os elementos</strong> de um universo de discurso específico, ou para afirmar que existe <strong>pelo menos um elemento</strong> do universo do discurso que satisfaz uma determinada qualidade.</p>
<p>Vamos remover o véu da dúvida usando como recurso metafórico uma experiência humana, social, comum e popular: imaginemos estar em uma festa e o anfitrião lhe pede para verificar se todos os convidados têm algo para beber. Você, prestativo e simpático, começa a percorrer a sala, verificando cada pessoa. Se você encontrar pelo menos uma pessoa sem bebida, você pode imediatamente dizer <em>nem todos têm bebidas</em>. mas, se você verificar cada convidado e todos eles tiverem algo para beber, você pode dizer com confiança <em>todos têm bebidas</em>. Este é o conceito do quantificador universal, matematicamente representado por <span class="math inline">\(\forall\)</span>, que lemos como <em>para todo</em>.</p>
<p>A festa continua e o anfitrião quer saber se alguém na festa está bebendo champanhe. Desta vez, assim que você encontrar uma pessoa com champanhe, você pode responder imediatamente <em>sim, alguém está bebendo champanhe</em>. Você não precisa verificar todo mundo para ter a resposta correta. Este é o conceito do quantificador existencial, denotado por $$, que lemos <em>existe algum</em>.</p>
<p>Os quantificadores nos permitem fazer declarações gerais, ou específicas, sobre os membros de um universo de discurso, de uma forma que seria difícil, ou impossível, sem estes operadores especiais.</p>
<section id="quantificador-universal" class="level4" data-number="5.0.4.1">
<h4 data-number="5.0.4.1" class="anchored" data-anchor-id="quantificador-universal"><span class="header-section-number">5.0.4.1</span> Quantificador Universal</h4>
<p>O quantificador universal <span class="math inline">\(\forall\)</span>, lê-se <em>para todo</em>, indica que uma afirmação deve ser verdadeira para todos os valores de uma variável dentro de um universo de discurso definido para a criação de uma sentença contendo um predicado qualquer. Por exemplo, a proposição clássica <em>todos os humanos são mortais</em> pode ser escrita como <span class="math inline">\(\forall x Humano(x) \rightarrow Mortal(x)\)</span>. Ou recorrendo a um exemplo com mais de rigor matemático, teríamos o predicado se <em><span class="math inline">\(x\)</span> é positivo então $x + 1 $ é positivo</em>, que pode ser escrito <span class="math inline">\(\forall x (x &gt; 0 \rightarrow x + 1 &gt; 0)\)</span>. Neste último exemplo temos Quantificadores, Lógica Predicativa, Lógica Proposicional e Teoria dos Conjuntos em uma sentença.</p>
<p>O quantificador universal pode ser representado usando apenas a Lógica Proposicional, com uma pequena trapaça. A afirmação <span class="math inline">\(\forall x P(x)\)</span> é, de certa forma, a operação $$, <strong>AND</strong> aplicada a todos os elementos do universo do discurso. Ou seja, o predicado:</p>
<p><span class="math display">\[\forall x \{x:\in \mathbb{N}\} : P(x)\]</span></p>
<p>Pode ser escrito como:</p>
<p><span class="math display">\[P(0) \land P(1) \land P(2) \land P(3) \land \ldots \]</span></p>
<p>Assim, $P(0), P(1), P(2), P(3) $ representam a aplicação do predicado <span class="math inline">\(P\)</span>A todos os elementos <span class="math inline">\(x\)</span> do conjunto <span class="math inline">\(\mathbb{N}\)</span>. A trapaça fica por conta de que, em Lógica Proposicional, não podemos escrever expressões com um número infinito de termos. Portanto, a expansão em conjunções de um predicado <span class="math inline">\(P\)</span> em um Universo de Discurso, $ u$, não é uma Fórmula Bem Formada se a cardinalidade de $ u$ for infinita. De qualquer forma, podemos usar esta interpretação informal para entender o significado de <span class="math inline">\(\forall x P(x)\)</span>.</p>
<p>A representação do Quantificador Universal como uma conjunção <strong>não é uma Fórmula Bem Formada</strong> a não ser que o Universo do Discurso seja não infinito. Neste caso, teremos uma conjunção que chamaremos de <strong>Conjunção Universal</strong>:</p>
<p><span class="math display">\[\forall x (P(x) \land Q(x))\]</span></p>
<p>Isso significa que para todo <span class="math inline">\(x\)</span> no domínio, as propriedades <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, e outras listadas são todas verdadeiras. É uma forma de expressar que todas as condições listadas são verdadeiras para cada elemento no domínio. Esta fórmula será usada para simplificar sentenças, ou para criar formas normais.</p>
<p>Vamos voltar um pouco. O quantificador universal <span class="math inline">\(\forall x P(x)\)</span>Afirma que a proposição <span class="math inline">\(P(x)\)</span> é verdadeira para todo, e qualquer, valor possível de <span class="math inline">\(x\)</span> como elemento de um conjunto, <span class="math inline">\(u\)</span>. Uma forma de interpretar isso é pensar em <span class="math inline">\(x\)</span> como uma variável que pode ter qualquer valor dentro do universo do discurso.</p>
<p>Para validar <span class="math inline">\(\forall x P(x)\)</span> escolhemos o pior caso possível para <span class="math inline">\(x\)</span>, todos os valores que suspeitamos possa fazer <span class="math inline">\(P(x)\)</span> falso. Se conseguirmos provar que <span class="math inline">\(P(x)\)</span> é verdadeira nestes casos específicos, então <span class="math inline">\(\forall x P(x)\)</span> deve ser verdadeira. Novamente, vamos recorrer a exemplos na esperança de explicitar este conceito.</p>
<p><strong>Exemplo 1</strong>: todos os números reais são maiores que 0. (Universo do discurso: <span class="math inline">\(\{x \in \mathbb{R}\}\)</span>)</p>
<p><span class="math display">\[\forall x (x \in \mathbb{R} \rightarrow x &gt; 0)\]</span></p>
<blockquote class="blockquote">
<p>Observe que este predicado, apesar de estar corretamente representado, é <span class="math inline">\(Falso\)</span>.</p>
</blockquote>
<p><strong>Exemplo 2</strong>: todos os triângulos em um plano euclidiano têm a soma dos ângulos internos igual a 180 graus. (Universo do discurso: <span class="math inline">\(x\)</span> é um triângulo em um plano euclidiano)</p>
<p><span class="math display">\[\forall x (Triângulo(x) \rightarrow \Sigma_{i=1}^3 ÂnguloInterno_i(x) = 180^\circ)\]</span></p>
<p><strong>Exemplo 3</strong>: todas as pessoas com mais de 18 anos podem tirar carteira de motorista.” (Universo do discurso: <span class="math inline">\(x\)</span> é uma pessoa no Brasil)</p>
<p><span class="math display">\[\forall x (Pessoa(x) \land Idade (x) \geq 18 \rightarrow PodeTirarCarteira(x))\]</span></p>
<p><strong>Exemplo 4</strong>: todo número par maior que 2 pode ser escrito como a soma de dois números primos. (Universo do discurso: <span class="math inline">\(\{x \in \mathbb{Z}\}\)</span></p>
<p><span class="math display">\[\forall x\,(Par(x) \land x &gt; 2 \rightarrow \exists a\exists b\, (Primo(a) \land Primo(b) \land x = a + b))\]</span></p>
<p><strong>Exemplo 5</strong>: para todo número natural, se ele é múltiplo de 4 e múltiplo de 6, então ele também é múltiplo de 12. (Universo do discurso: <span class="math inline">\(\{x \in \mathbb{N}\}\)</span>)</p>
<p><span class="math display">\[\forall x\,((\exists a\in\Bbb N\,(x = 4a) \land \exists b\in\Bbb N\,(x = 6b)) \rightarrow \exists c\in\Bbb N\,(x = 12c))\]</span></p>
<p>O quantificador universal nos permite definir uma Fórmula Bem Formada representando todos os elementos de um conjunto, um universo do discurso, em relação a uma qualidade específica, um predicado. Esta é um artefato lógico interessante, mas não suficiente.</p>
<p>Usamos, preferencialmente, a implicação, <span class="math inline">\(\to\)</span>, com o quantificador universal, <span class="math inline">\(\forall\)</span>, para indicar que uma propriedade vale para todos os elementos de um domínio, Porque permite afirmar que <em>para todo <span class="math inline">\(x\)</span>, se <span class="math inline">\(P(x)\)</span> for verdadeira, então <span class="math inline">\(Q(x)\)</span> também será verdadeira</em>. Isso permite que <span class="math inline">\(P(x)\)</span> seja falsa para alguns <span class="math inline">\(x\)</span>, mas a implicação como um todo permanece verdadeira. Ou, em outras palavras, quando usamos uma implicação, como <span class="math inline">\(P(x) \rightarrow Q(x)\)</span>, estamos dizendo que <em>se <span class="math inline">\(P(x)\)</span> for verdadeira, então <span class="math inline">\(Q(x)\)</span> também será verdadeira</em>. A implicação é uma forma lógica que permite conectar duas proposições, em que a veracidade de <span class="math inline">\(Q(x)\)</span> depende da veracidade de <span class="math inline">\(P(x)\)</span>.</p>
<blockquote class="blockquote">
<p>Importante: A implicação <span class="math inline">\(P(x) \rightarrow Q(x)\)</span> é considerada verdadeira em qualquer dos seguintes casos:</p>
<p><span class="math inline">\(P(x)\)</span> é verdadeira e <span class="math inline">\(Q(x)\)</span> é verdadeira. <span class="math inline">\(P(x)\)</span> é falsa, independentemente de <span class="math inline">\(Q(x)\)</span>. O ponto-chave é o segundo caso: se <span class="math inline">\(P(x)\)</span> for falsa, a implicação <span class="math inline">\(P(x) \rightarrow Q(x)\)</span> ainda é verdadeira, não importa o valor de <span class="math inline">\(Q(x)\)</span>.</p>
</blockquote>
<p>Essa preferência não é arbitrária, mas baseada nas limitações que os outros conectivos apresentam quando combinados com o quantificador universal. Porém, uma análise de todos os operadores pode ser interessante para sedimentar os conceitos.</p>
<p>Comecemos com a conjunção. Quando usamos <span class="math inline">\(∀x(P(x) ∧ Q(x))\)</span>, estamos afirmando que para todo <span class="math inline">\(x\)</span>, tanto <span class="math inline">\(P(x)\)</span> quanto <span class="math inline">\(Q(x)\)</span> são verdadeiros. Isso é extremamente restritivo e raramente reflete situações do mundo real. Por exemplo, se disséssemos <em>Todos os animais são mamíferos e podem voar</em>, estaríamos fazendo uma afirmação falsa, pois nem todos os animais são mamíferos e nem todos podem voar. Outro exemplo seria <em>Todos os números são pares e primos</em>, o que é claramente falso, pois nenhum número (exceto 2) satisfaz ambas as condições simultaneamente.</p>
<p>A disjunção, por outro lado, é muito fraca quando combinada com o quantificador universal. <span class="math inline">\(∀x(P(x) ∨ Q(x))\)</span> afirma que para todo <span class="math inline">\(x\)</span>, ou <span class="math inline">\(P(x)\)</span> ou <span class="math inline">\(Q(x)\)</span> (ou ambos) são verdadeiros. Isso geralmente não captura relações condicionais úteis. Por exemplo, <em>Todo número é par ou ímpar</em> é uma afirmação verdadeira, mas não nos diz muito sobre a relação entre paridade e números. Da mesma forma, <em>Toda pessoa é alta ou baixa</em> é uma afirmação de tal amplitude que se torna quase sem sentido, pois não fornece informações úteis sobre a altura das pessoas.</p>
<p>A equivalência (<span class="math inline">\(\leftrightarrow\)</span>) com o quantificador universal também apresenta problemas. <span class="math inline">\(∀x(P(x) \leftrightarrow Q(x))\)</span> afirma que para todo <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span> é verdadeiro se e somente se <span class="math inline">\(Q(x)\)</span> for verdadeiro. Isso é uma condição muito forte e raramente é satisfeita em situações reais. Por exemplo, <em>Um número é par se e somente se é divisível por 4</em> é falso, pois há números pares que não são divisíveis por <span class="math inline">\(4\)</span> (como <span class="math inline">\(2\)</span> e <span class="math inline">\(6\)</span>). Outro exemplo seria <em>Uma pessoa é feliz se e somente se é rica</em>, o que claramente não reflete a realidade complexa da felicidade e riqueza.</p>
<p>Por outro lado, a implicação (<span class="math inline">\(\to\)</span>) oferece várias vantagens quando usada com o quantificador universal. <span class="math inline">\(∀x(P(x) \to Q(x))\)</span> nos permite expressar relações condicionais de forma mais flexível e precisa. Por exemplo, <em>Para todo número, se é par, então não é primo (exceto 2)</em> é uma afirmação verdadeira e informativa. Outro exemplo seria <em>Para toda pessoa, se é médico, então tem formação universitária</em>. Esta formulação permite exceções (pode haver pessoas com formação universitária que não são médicos) e captura uma regra geral de forma precisa.</p>
<p>A implicação também tem a vantagem de ser verdadeira quando o antecedente (<span class="math inline">\(P(x)\)</span>) é falso, o que é útil para expressar regras gerais. Por exemplo, em <em>Para todo x, se x é um quadrado perfeito, então x é positivo</em>, a implicação é verdadeira mesmo para números negativos (que não são quadrados perfeitos), mantendo a regra geral válida.</p>
<p>Espero que tenha ficado claro. A implicação, quando combinada com o quantificador universal, oferece um equilíbrio entre flexibilidade e precisão que os outros conectivos lógicos não conseguem alcançar. Ela permite expressar relações condicionais, acomoda exceções e captura regras gerais de forma mais eficaz, tornando-a a escolha preferida em muitas situações da lógica formal e da matemática.</p>
</section>
<section id="quantificador-existencial" class="level4" data-number="5.0.4.2">
<h4 data-number="5.0.4.2" class="anchored" data-anchor-id="quantificador-existencial"><span class="header-section-number">5.0.4.2</span> Quantificador Existencial</h4>
<p>O quantificador existencial, $$ nos permite fazer afirmações sobre a existência de objetos com certas propriedades, sem precisarmos especificar exatamente quais objetos são esses. Vamos tentar remover os véus da dúvida com um exemplo simples.</p>
<p>Consideremos a sentença: <em>existem humanos mortais</em>. Com um pouco mais de detalhe e matemática, podemos escrever isso como: existe pelo menos um <span class="math inline">\(x\)</span> tal que <span class="math inline">\(x\)</span> é humano e mortal. Para escrever a mesma sentença com precisão matemática teremos:</p>
<p><span class="math display">\[\exists x \text{Humano}(x) \land \text{Mortal}(x)\]</span></p>
<p>Lendo por partes: <em>existe um <span class="math inline">\(x\)</span>, tal que <span class="math inline">\(x\)</span> é humano AND <span class="math inline">\(x\)</span> é mortal</em>. Em outras palavras, existe pelo menos um humano que é mortal.</p>
<p>Note duas coisas importantes:</p>
<ol type="1">
<li><p>Nós não precisamos dizer exatamente quem é esse humano mortal. Só afirmamos que existe um. O operador $$ captura essa ideia.</p></li>
<li><p>Usamos <strong>AND</strong> ($<span class="math inline">\(), não implicação (\)</span>$). Se usássemos $$, a afirmação ficaria muito mais fraca. Veja:</p></li>
</ol>
<p><span class="math display">\[\exists x \text{Humano}(x) \rightarrow \text{Mortal}(x)\]</span></p>
<p>Que pode ser lido como: <em>existe um <span class="math inline">\(x\)</span> tal que, SE <span class="math inline">\(x\)</span> é humano, ENTÃO <span class="math inline">\(x\)</span> é mortal</em>. Essa afirmação é verdadeira em qualquer universo que contenha um unicórnio de bolinhas roxas imortal. Porque o unicórnio não é humano, então <span class="math inline">\(\text{Humano}(\text{unicórnio})\)</span> é falsa, e a implicação <span class="math inline">\(\text{Humano}(x) \rightarrow \text{Mortal}(x)\)</span> é verdadeira. Não entendeu? Volte dois parágrafos e leia novamente. Repita!</p>
<p>Portanto, é importante usar o operador $$, e não $$ quando trabalhamos com quantificadores existenciais. O $$ garante que a propriedade se aplica ao objeto existente definido pelo $$. Contudo, podemos melhorar um pouco isso:</p>
<p>A conjunção, <span class="math inline">\(\land\)</span>, é frequentemente empregada com o quantificador existencial, <span class="math inline">\(\exists\)</span>, para expressar a presença de ao menos um elemento em determinado conjunto que possui múltiplas características simultaneamente. Isso nos possibilita declarar que <em>há no mínimo um <span class="math inline">\(x\)</span> para o qual tanto <span class="math inline">\(P(x)\)</span> quanto <span class="math inline">\(Q(x)\)</span> são válidas</em>. Tal afirmação confirma a existência de pelo menos um elemento que atende a ambos os critérios. Dito de outra forma, ao utilizarmos uma conjunção, como em <span class="math inline">\(P(x) \land Q(x)\)</span>, estamos afirmando que <em>existe ao menos um <span class="math inline">\(x\)</span> em que <span class="math inline">\(P(x)\)</span> é verdadeiro e, ao mesmo tempo, <span class="math inline">\(Q(x)\)</span> também o é</em>. A conjunção funciona como um operador lógico que une duas proposições, em que a validade da asserção existencial depende da ocorrência simultânea de <span class="math inline">\(P(x)\)</span> e <span class="math inline">\(Q(x)\)</span> para, no mínimo, um <span class="math inline">\(x\)</span>.</p>
<blockquote class="blockquote">
<p>No contexto do quantificador existencial <span class="math inline">\(\exists x\)</span>, a conjunção <span class="math inline">\(P(x) \land Q(x)\)</span> é tida como verdadeira se, e apenas se:</p>
<p>Houver ao menos um <span class="math inline">\(x\)</span> para o qual tanto <span class="math inline">\(P(x)\)</span> quanto <span class="math inline">\(Q(x)\)</span> são verdadeiras. Caso não exista tal <span class="math inline">\(x\)</span>, a afirmação existencial é considerada falsa. Observe que basta a existência de um único elemento satisfazendo ambas as condições para validar a afirmação existencial.</p>
</blockquote>
<p>Esta predileção não é fortuita, mas fundamentada na aptidão da conjunção em expressar com exatidão a existência de elementos dotados de múltiplos atributos concomitantes. No entanto, uma avaliação dos demais operadores pode ser proveitosa para consolidar esses conceitos.</p>
<p>Iniciemos com a implicação. Ao empregarmos <span class="math inline">\(\exists x(P(x) \to Q(x))\)</span>, declaramos a existência de ao menos um <span class="math inline">\(x\)</span> tal que, se <span class="math inline">\(P(x)\)</span> for verdadeiro, então <span class="math inline">\(Q(x)\)</span> também o será. Esta formulação é menos elucidativa que a conjunção no âmbito existencial, pois seria verdadeira mesmo se <span class="math inline">\(P(x)\)</span> fosse falso para todo <span class="math inline">\(x\)</span>. Ilustrando: <em>Há um número que, se for ímpar, é múltiplo de 2</em> é verdadeiro (pois é válido para números pares), mas não esclarece se realmente existe um número ímpar que é múltiplo de 2.</p>
<p>A disjunção aliada ao quantificador existencial, <span class="math inline">\(\exists x(P(x) \lor Q(x))\)</span>, assevera a existência de pelo menos um <span class="math inline">\(x\)</span> que satisfaz <span class="math inline">\(P(x)\)</span> ou <span class="math inline">\(Q(x)\)</span> (ou ambos). Embora útil em certos contextos, geralmente é menos robusta que a conjunção para afirmar a existência de elementos com múltiplas propriedades. Por exemplo: <em>Existe um número que é negativo ou racional</em> é verdadeiro, mas não nos informa se há um número que é ambos.</p>
<p>A equivalência (<span class="math inline">\(\leftrightarrow\)</span>) com o quantificador existencial também pode ser problemática. <span class="math inline">\(\exists x(P(x) \leftrightarrow Q(x))\)</span> afirma a existência de ao menos um <span class="math inline">\(x\)</span> para o qual <span class="math inline">\(P(x)\)</span> é verdadeiro se e somente se <span class="math inline">\(Q(x)\)</span> for verdadeiro. Isso pode ser útil em alguns casos, mas frequentemente é mais restritivo do que o necessário. Por exemplo: <em>Existe um número que é positivo se e somente se é inteiro</em> é verdadeiro (o número 1 satisfaz isso), mas não captura a existência de números que são apenas positivos ou apenas inteiros.</p>
<p>Em contrapartida, a conjunção (<span class="math inline">\(\land\)</span>) apresenta diversas vantagens quando utilizada com o quantificador existencial. <span class="math inline">\(\exists x(P(x) \land Q(x))\)</span> nos permite afirmar a existência de elementos que possuem múltiplas propriedades simultaneamente. Por exemplo: <em>Existe um número que é positivo e par</em> é uma afirmação verdadeira e informativa (o número 2 satisfaz ambas as condições). Outro exemplo seria <em>Existe uma substância que é líquida e condutora de eletricidade</em>. Esta formulação afirma claramente a existência de substâncias com ambas as características.</p>
<p>A conjunção também tem a vantagem de ser falsa quando não há elementos que satisfaçam ambas as condições, o que é útil para expressar a inexistência de certos tipos de elementos. Por exemplo: <em>Existe um número que é natural e negativo simultaneamente</em> é falso, indicando corretamente que não há tais números.</p>
<p>Em suma, a conjunção, quando associada ao quantificador existencial, proporciona um meio preciso e informativo de expressar a existência de elementos com múltiplos atributos. Ela permite afirmar a presença de elementos que atendem a condições simultâneas, tornando-se a opção preferencial em diversas situações da lógica formal e da matemática quando se trata de asserções existenciais.</p>
<p>Assim como o quantificador universal, <span class="math inline">\(\forall\)</span>, o quantificador existencial, <span class="math inline">\(\exists\)</span> , também pode ser restrito a um universo específico, usando a notação de pertencimento:</p>
<p><span class="math display">\[\exists x \in \mathbb{Z} : x = x^2\]</span></p>
<p>Esta sentença afirma a existência de pelo menos um inteiro <span class="math inline">\(x\)</span> tal que <span class="math inline">\(x\)</span> é igual ao seu quadrado. Novamente, não precisamos dizer qual é esse inteiro, apenas que ele existe dentro do conjunto dos inteiros. Existe?</p>
<p>De forma geral, o quantificador existencial serve para fazer afirmações elegantes sobre a existência de objetos com certas qualidades, sem necessariamente conhecermos ou elencarmos todos esses objetos. Isso agrega mais qualidade a representação do mundo real que podemos fazer com a Lógica de Primeira Ordem.</p>
<p>Talvez, alguns exemplos possam ajudar no seu entendimento:</p>
<p><strong>Exemplo 1</strong>: existe um mamífero que não respira ar.</p>
<p><span class="math display">\[\exists x (mamífero(x) \land \neg RespiraAr(x))\]</span></p>
<p><strong>Exemplo 2</strong>: existe uma equação do segundo grau com uma raiz real.</p>
<p><span class="math display">\[\exists x (\text{Eq2Grau}(x) \land |\text{RaízesReais}(x)| \leq 1)\]</span></p>
<p><strong>Exemplo 3</strong>: existe um número primo que é par.</p>
<p><span class="math display">\[\exists x (Primo(x) \land Par(x))\]</span></p>
<p><strong>Exemplo 4</strong>: existe um quadrado perfeito que pode ser escrito como o quadrado de um número racional.</p>
<p><span class="math display">\[\exists x (QuadPerfeito(x) \land \exists a \in \mathbb{Q} \ (x = a^2))\]</span></p>
<p><strong>Exemplo 5</strong>: existe um polígono convexo em que a soma dos ângulos internos não é igual A<span class="math inline">\((n-2)\cdot180^{\circ}\)</span>.</p>
<p><span class="math display">\[\exists x (\text{PolígonoConvexo}(x) \land \sum_{i=1}^{n} \text{ÂnguloInterno}_i(x) \neq (n-2)\cdot 180^{\circ})\]</span></p>
<blockquote class="blockquote">
<p>Novamente, observe que este predicado é <span class="math inline">\(falso\)</span>. Todos os polígonos convexos têm a soma dos ângulos internos igual a <span class="math inline">\((n−2)cdot 180\)</span>, onde <span class="math inline">\(𝑛\)</span> é o número de lados do polígono.</p>
</blockquote>
</section>
</section>
<section id="equivalências-interessantes" class="level3" data-number="5.0.5">
<h3 data-number="5.0.5" class="anchored" data-anchor-id="equivalências-interessantes"><span class="header-section-number">5.0.5</span> Equivalências Interessantes</h3>
<p>Estudando o quantificador universal encontramos duas equivalências interessantes:</p>
<p><span class="math display">\[\lnot \forall x P(x) \leftrightarrow \exists x \lnot P(x)\]</span></p>
<p><span class="math display">\[\lnot \exists x P(x) \leftrightarrow \forall x \lnot P(x)\]</span></p>
<p>Essas equivalências são essencialmente as versões quantificadas das <strong>Leis de De Morgan</strong>. A primeira diz que nem todos os humanos são mortais, isso é equivalente a encontrar algum humano que não é mortal. A segunda diz que para mostrar que nenhum humano é mortal, temos que mostrar que todos os humanos não são mortais.</p>
<p>Podemos representar uma declaração <span class="math inline">\(\exists x P(x)\)</span> como uma expressão <em>OU</em>. Por exemplo, <span class="math inline">\(\exists x \in \mathbb{N} : P(x)\)</span> Poderia ser reescrito como:</p>
<p><span class="math display">\[P(0) \lor P(1) \lor P(2) \lor P(3) \lor \ldots \]</span></p>
<p>Lembrado do problema que encontramos quando fizemos isso com o quantificador $$: não podemos representar fórmulas sem fim em Lógica de Primeira Ordem. mas, novamente esta notação, ainda que inválida, nos permite entender melhor o quantificador existencial. Caso o Universo do Discurso seja não infinito, limitado e contável, teremos a <strong>Disjunção Existencial</strong> uma expressão na lógica de primeiro grau que afirma que existe pelo menos um elemento em um domínio que satisfaz uma ou mais propriedades. A forma geral de uma disjunção existencial é:</p>
<p><span class="math display">\[\exists x (P(x) \lor Q(x))\]</span></p>
<p>Isso significa que existe pelo menos um <span class="math inline">\(x\)</span> no domínio que satisfaz a propriedade <span class="math inline">\(P\)</span>, ou a propriedade <span class="math inline">\(Q\)</span>, ou ambas, ou outras propriedades listadas. É uma forma de expressar que pelo menos uma das condições listadas é verdadeira para algum elemento no domínio.</p>
<p>A expansão de $$ usando $$ destaca que a proposição <span class="math inline">\(P(x)\)</span> é verdadeira se pelo menos um valor de <span class="math inline">\(x\)</span> dentro do universo do discurso atender ao predicado <span class="math inline">\(P\)</span>. O que a expansão de exemplo está dizendo é que existe pelo menos um número natural <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> é verdadeiro. Não precisamos saber exatamente qual é esse <span class="math inline">\(x\)</span>. Apenas que existe um elemento dentro de <span class="math inline">\(\mathbb{N}\)</span> que atende o predicado.</p>
<p>O quantificador existencial não especifica o objeto dentro do universo determinado. Esse operador permite fazer afirmações elegantes sobre a existência de objetos com certas características, certas qualidades, ou ainda, certos predicados, sem necessariamente conhecermos exatamente quais são esses objetos.</p>
</section>
<section id="dos-predicados-à-linguagem-natural" class="level3" data-number="5.0.6">
<h3 data-number="5.0.6" class="anchored" data-anchor-id="dos-predicados-à-linguagem-natural"><span class="header-section-number">5.0.6</span> Dos Predicados à Linguagem Natural</h3>
<p>Ao ler uma Fórmula Bem Formada contendo quantificadores, a ordem da leitura é geralmente da esquerda para a direita. A interpretação precisa, no entanto, depende diretamente da ordem e do tipo dos quantificadores.</p>
<p>Por exemplo, <span class="math inline">\(\forall x\)</span> pode ser lido como “<em>para todo objeto <span class="math inline">\(x\)</span> no universo do discurso (em que este objeto está implícito), o seguinte se mantém</em>”. Já o quantificador <span class="math inline">\(\exists x\)</span> pode ser lido como “<em>existe um objeto <span class="math inline">\(x\)</span> no universo que satisfaz o seguinte</em>” ou “<em>para algum objeto <span class="math inline">\(x\)</span> no universo, o seguinte se mantém</em>”.</p>
<p>Converter uma Fórmula Bem Formada em uma sentença fluida em linguagem natural nem sempre é direto, mas é um passo valioso para a compreensão. Vamos considerar <span class="math inline">\(U\)</span> como o universo do discurso (o conjunto de todos os aviões já fabricados) e <span class="math inline">\(F(x,y)\)</span> como o predicado que denota “<span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>”. Analisemos algumas combinações de quantificadores:</p>
<ol type="1">
<li><p><strong><span class="math inline">\(\forall x \forall y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Para todo avião <span class="math inline">\(x\)</span>, e para todo avião <span class="math inline">\(y\)</span>, <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta afirmação é muito forte. Ela diz que cada avião no universo é mais rápido que todos os aviões no universo (incluindo ele mesmo, a menos que <span class="math inline">\(F(x,x)\)</span> seja definido como falso ou que se adicione <span class="math inline">\(x \neq y\)</span>). Se o universo tiver mais de um avião, esta afirmação provavelmente será falsa, pois implicaria, por exemplo, que <span class="math inline">\(A\)</span> é mais rápido que <span class="math inline">\(B\)</span> e <span class="math inline">\(B\)</span> é mais rápido que <span class="math inline">\(A\)</span> simultaneamente.</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(\exists x \forall y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Existe um avião <span class="math inline">\(x\)</span> tal que, para todo avião <span class="math inline">\(y\)</span>, <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta afirmação diz que existe pelo menos um avião que é mais rápido que todos os outros (e, novamente, dependendo da definição de <span class="math inline">\(F(x,x)\)</span>, mais rápido que ele mesmo). Em outras palavras, existe um “avião mais rápido absoluto”.</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(\forall x \exists y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Para todo avião <span class="math inline">\(x\)</span>, existe um avião <span class="math inline">\(y\)</span> tal que <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta afirmação diz que para qualquer avião que escolhermos, podemos encontrar algum avião <span class="math inline">\(y\)</span> que é mais lento que <span class="math inline">\(x\)</span>. Se <span class="math inline">\(y\)</span> pode ser igual a <span class="math inline">\(x\)</span>, a afirmação é trivialmente verdadeira se <span class="math inline">\(F(x,x)\)</span> for verdadeiro para algum <span class="math inline">\(x\)</span>. Se <span class="math inline">\(y\)</span> deve ser diferente de <span class="math inline">\(x\)</span>, isso significaria que não existe um “avião mais lento absoluto” (a menos que o universo seja finito e ordenado de forma cíclica, ou que <span class="math inline">\(F(x,y)\)</span> permita que <span class="math inline">\(x\)</span> seja mais rápido que “nada” se <span class="math inline">\(y\)</span> for o mais lento). Uma interpretação comum é que, para cada avião, há outro que ele supera em velocidade.</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(\exists x \exists y F(x,y)\)</span></strong></p>
<ul>
<li><p><strong>Leitura literal</strong>: Existe um avião <span class="math inline">\(x\)</span> e existe um avião <span class="math inline">\(y\)</span> tal que <span class="math inline">\(x\)</span> voa mais rápido que <span class="math inline">\(y\)</span>.</p></li>
<li><p><strong>Significado</strong>: Esta é a afirmação mais fraca entre as quatro. Ela simplesmente diz que a relação “voa mais rápido que” não é vazia; ou seja, há pelo menos um par de aviões <span class="math inline">\((x,y)\)</span> em que <span class="math inline">\(x\)</span> é mais rápido que <span class="math inline">\(y\)</span>.</p></li>
</ul></li>
</ol>
<p>É fundamental perceber que <strong>estas quatro sentenças têm significados lógicos distintos e geralmente não expressam o mesmo contexto</strong>. A ordem dos quantificadores, especialmente quando misturamos <span class="math inline">\(\forall\)</span> e <span class="math inline">\(\exists\)</span>, altera drasticamente o significado da afirmação. Por exemplo, <span class="math inline">\(\exists x \forall y F(x,y)\)</span> (existe um avião mais rápido que todos) é uma afirmação muito mais forte e diferente de <span class="math inline">\(\forall x \exists y F(x,y)\)</span> (para cada avião, existe um mais lento).</p>
<p>Ao traduzir da lógica para a linguagem natural ou vice-versa, a precisão na interpretação da ordem e do tipo dos quantificadores é essencial. A prática leva a uma maior fluidez nesse processo de tradução e compreensão.</p>
</section>
<section id="exercícios-de-conversão-de-linguagem-natural-em-expressões-predicativas" class="level3" data-number="5.0.7">
<h3 data-number="5.0.7" class="anchored" data-anchor-id="exercícios-de-conversão-de-linguagem-natural-em-expressões-predicativas"><span class="header-section-number">5.0.7</span> Exercícios de Conversão de Linguagem Natural em Expressões Predicativas</h3>
<p><strong>Sentença 1</strong>: <em>Todo matemático que é professor tem alunos que são brilhantes e interessados.</em></p>
<p><span class="math display">\[
\forall x ((\text{Matemático}(x) \wedge \text{Professor}(x)) \rightarrow \exists y (\text{Aluno}(y) \wedge \text{Brilhante}(y) \wedge \text{Interessado}(y) \wedge \text{Ensina}(x, y)))
\]</span></p>
<p><span class="math display">\[
\forall x (\text{Matemático}(x) \rightarrow (\text{Professor}(x) \rightarrow \exists y (\text{Aluno}(y) \wedge \text{Brilhante}(y) \wedge \text{Interessado}(y) \wedge \text{Ensina}(x, y))))
\]</span></p>
<p><strong>Sentença 2</strong>: <em>Alguns engenheiros não são nem ricos nem felizes.</em></p>
<p><span class="math display">\[\exists x (\text{Engenheiro}(x) \wedge \neg (\text{Rico}(x) \vee \text{Feliz}(x)))\]</span></p>
<p><span class="math display">\[\exists x (\text{Engenheiro}(x) \wedge \neg\text{Rico}(x) \wedge \neg\text{Feliz}(x))\]</span></p>
<p><strong>Sentença 3</strong>: <em>Todos os planetas que têm água possuem vida ou têm potencial para vida.</em></p>
<p><span class="math display">\[
\forall x (\text{Planeta}(x) \wedge \text{TemÁgua}(x) \rightarrow (\text{TemVida}(x) \vee \text{TemPotencialParaVida}(x)))
\]</span></p>
<p><span class="math display">\[
\forall x (\text{Planeta}(x) \rightarrow (\text{TemÁgua}(x) \rightarrow (\text{TemVida}(x) \vee \text{TemPotencialParaVida}(x))))
\]</span></p>
<p><strong>Sentença 4</strong>: <em>Nenhum cientista que é cético acredita em todos os mitos.</em></p>
<p><span class="math display">\[
\neg \exists x (Cientista(x) \wedge Cético(x) \wedge \forall y (Mito(y) \rightarrow Acredita(x,y)))
\]</span></p>
<p><span class="math display">\[
\forall x ((\text{Cientista}(x) \wedge \text{Cético}(x)) \rightarrow \exists y (\text{Mito}(y) \wedge \neg \text{Acredita}(x, y)))
\]</span></p>
<p><span class="math display">\[
\forall x (\text{Cientista}(x) \rightarrow (\text{Cético}(x) \rightarrow \exists y (\text{Mito}(y) \wedge \neg \text{Acredita}(x, y))))
\]</span></p>
<p><strong>Sentença 5</strong>: <em>Alguns filósofos que escrevem sobre ética também leem ou estudam psicologia.</em></p>
<p><span class="math display">\[
\exists x (\text{Filósofo}(x) \wedge \text{EscreveSobreÉtica}(x) \wedge (\text{Lê}(x, \text{"Psicologia"}) \vee \text{Estuda}(x, \text{"Psicologia"})))
\]</span></p>
<p><span class="math display">\[
\exists x (\text{Filósofo}(x) \wedge \text{EscreveSobreÉtica}(x) \rightarrow (\text{Lê}(x, \text{"Psicologia"}) \vee \text{Estuda}(x, \text{"Psicologia"})))
\]</span></p>
<p><span class="math display">\[
\exists x (\text{Filósofo}(x) \land \text{EscreveSobreÉtica}(x) \land (\text{Lê}(x) \lor \text{"Psicologia"}(x)))
\]</span></p>
<p><strong>Sentença 6</strong>: <em>Para todo escritor, existe pelo menos um livro que ele escreveu e que é tanto criticado quanto admirado.</em></p>
<p><span class="math display">\[
\forall x (\text{Escritor}(x) \rightarrow \exists y (\text{Livro}(y) \wedge \text{Escreveu}(x, y) \wedge \text{Criticado}(y) \wedge \text{Admirado}(y)))
\]</span></p>
<p><span class="math display">\[
\exists x (\text{Escritor}(x) \wedge \exists y (\text{Livro}(y) \wedge \text{Escreveu}(x, y) \wedge (\text{Criticado}(y) \wedge \text{Admirado}(y))))
\]</span></p>
<p><span class="math display">\[
\forall x \exists y (\text{Escritor}(x) \land \text{Escreveu}(x, y) \rightarrow (\text{criticado}(y) \land \text{Admirado}(y)))
\]</span></p>
</section>
<section id="exercícios-de-conversão-de-expressões-predicativas-em-linguagem-natural" class="level3" data-number="5.0.8">
<h3 data-number="5.0.8" class="anchored" data-anchor-id="exercícios-de-conversão-de-expressões-predicativas-em-linguagem-natural"><span class="header-section-number">5.0.8</span> Exercícios de Conversão de Expressões Predicativas em Linguagem Natural</h3>
<p><strong>1. Fórmula Lógica</strong>: <span class="math inline">\(\forall x (\text{Humano}(x) \rightarrow (\text{Mortal}(x) \wedge \text{Racional}(x)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Humano(x)\)</span>: <em><span class="math inline">\(x\)</span> é um humano</em>.</li>
<li><span class="math inline">\(Mortal(x)\)</span>: <em><span class="math inline">\(x\)</span> é mortal</em>.</li>
<li><span class="math inline">\(Racional(x)\)</span>: <em><span class="math inline">\(x\)</span> é racional</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Todo humano é mortal e racional.</p></li>
</ul>
<p><strong>~2. Fórmula Lógica</strong>:<span class="math inline">\(\exists y (\text{Livro}(y) \wedge (\text{Interessante}(y) \vee \text{Complicado}(y)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Livro(y)\)</span>: <em>y é um livro</em>.</li>
<li><span class="math inline">\(Interessante(y)\)</span>: <em>y é interessante</em>.</li>
<li><span class="math inline">\(Complicado(y)\)</span>: <em>y é complicado</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Existe pelo menos um livro que é interessante ou complicado.</p></li>
</ul>
<p><strong>3. Fórmula Lógica</strong>:<span class="math inline">\(\forall x \forall y (\text{Amigos}(x, y) \rightarrow (\text{Confiável}(x) \wedge \text{Honra}(x)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Amigos(x, y)\)</span>: <em>x é amigo de y</em>.</li>
<li><span class="math inline">\(Confiável(x)\)</span>: <em>x é confiável</em>.</li>
<li><span class="math inline">\(Honra(x)\)</span>: <em>x honra y</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Todo amigo de alguém é confiável e honra o amigo.</p></li>
</ul>
<p><strong>4. Fórmula Lógica</strong>:<span class="math inline">\(\exists x \exists y (\text{Animal}(x) \wedge \text{Planta}(y) \wedge \text{Convive}(x, y))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Animal(x)\)</span>: <em>x é um animal</em>.</li>
<li><span class="math inline">\(Planta(y)\)</span>: <em>y é uma planta</em>.</li>
<li><span class="math inline">\(Convive(x, y)\)</span>: <em>x e y convivem</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Existe pelo menos um animal e uma planta que convivem no mesmo ambiente.</p></li>
</ul>
<p><strong>5. Fórmula Lógica</strong>:<span class="math inline">\(\forall x \exists y (\text{Professor}(x) \rightarrow (\text{Disciplina}(y) \wedge \text{Leciona}(x, y)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Professor(x)\)</span>: <em>x é um professor</em>.</li>
<li><span class="math inline">\(Disciplina(y)\)</span>: <em>y é uma disciplina</em>.</li>
<li><span class="math inline">\(Leciona(x, y)\)</span>: <em>x leciona y</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Para todo professor, existe pelo menos uma disciplina que ele leciona.</p></li>
</ul>
<p><strong>6. Fórmula Lógica</strong>:<span class="math inline">\(\exists x \forall y (\text{Músico}(x) \wedge (\text{Instrumento}(y) \rightarrow \text{Toca}(x, y)))\)</span></p>
<ul>
<li><p>Predicados:</p>
<ul>
<li><span class="math inline">\(Músico(x)\)</span>: <em>x é um músico</em>.</li>
<li><span class="math inline">\(Instrumento(y)\)</span>: <em>y é um instrumento</em>.</li>
<li><span class="math inline">\(Toca(x, y)\)</span>: <em>x toca y</em>.</li>
</ul></li>
<li><p><strong>Sentença em Português</strong>: Existe pelo menos um músico que, se algo é um instrumento, então ele toca esse instrumento.</p></li>
</ul>
</section>
<section id="exemplos-extras-de-conversão-de-sentenças-em-predicados" class="level3" data-number="5.0.9">
<h3 data-number="5.0.9" class="anchored" data-anchor-id="exemplos-extras-de-conversão-de-sentenças-em-predicados"><span class="header-section-number">5.0.9</span> Exemplos Extras de conversão de sentenças em predicados</h3>
<ol type="1">
<li><p><strong>Todos os pássaros voam e todos os peixes nadam.</strong></p>
<p><span class="math display">\[\forall x (Pássaro(x) \rightarrow Voa(x)) \land \forall y (Peixe(y) \rightarrow Nada(y))\]</span></p></li>
<li><p><strong>Todos os estudantes estudam ou todos os professores ensinam.</strong></p>
<p><span class="math display">\[\forall x (Estudante(x) \rightarrow Estuda(x)) \lor \forall y (Professor(y) \rightarrow Ensina(y))\]</span></p></li>
<li><p><strong>Todos os cães latem e todos os gatos miam, mas nem todos os animais fazem barulho.</strong></p>
<p><span class="math display">\[\forall x (Cão(x) \rightarrow Late(x)) \land \forall y (Gato(y) \rightarrow Mia(y)) \land \neg \forall z (Animal(z) \rightarrow FazBarulho(z))\]</span></p></li>
<li><p><strong>Se todos os carros são vermelhos, então todos os caminhões são azuis.</strong></p>
<p><span class="math display">\[\forall x (Carro(x) \rightarrow Vermelho(x)) \rightarrow \forall y (Caminhão(y) \rightarrow Azul(y))\]</span></p></li>
<li><p><strong>Todos os planetas orbitam uma estrela e todos os asteroides orbitam o sol.</strong></p>
<p><span class="math display">\[\forall x (Planeta(x) \rightarrow OrbitaEstrela(x)) \land \forall y (Asteroide(y) \rightarrow OrbitaSol(y))\]</span></p></li>
<li><p><strong>Alguns pássaros não voam.</strong></p>
<p><span class="math display">\[\exists x (Pássaro(x) \land \neg Voa(x))\]</span></p></li>
<li><p><strong>Existe pelo menos um estudante que não estuda</strong>.</p>
<p><span class="math display">\[\exists x (Estudante(x) \land \neg Estuda(x))\]</span></p></li>
<li><p><strong>Há algum animal que não faz barulho</strong>.</p>
<p><span class="math display">\[\exists x (Animal(x) \land \neg FazBarulho(x))\]</span></p></li>
<li><p><strong>Existe um carro que não é vermelho</strong>.</p>
<p><span class="math display">\[\exists x (Carro(x) \land \neg Vermelho(x))\]</span></p></li>
<li><p><strong>Há um planeta que não orbita uma estrela</strong>.</p>
<p><span class="math display">\[\exists x (Planeta(x) \land \neg \exists y (Estrela(y) \land Orbita(x, y)))\]</span></p></li>
<li><p>Todos os pássaros voam, mas existe um animal que não voa.</p>
<p><span class="math display">\[\forall x (Pássaro(x) \rightarrow Voa(x)) \land \exists y (Animal(y) \land \neg Voa(y))\]</span></p></li>
<li><p>Para cada estudante, existe um professor que o ensina.</p>
<p><span class="math display">\[\forall x (Estudante(x) \rightarrow \exists y (Professor(y) \land Ensina(y, x)))\]</span></p></li>
<li><p>Existe um cão que late para todos os gatos.</p>
<p><span class="math display">\[\exists x (Cão(x) \land \forall y (Gato(y) \rightarrow Late(x, y)))\]</span></p></li>
<li><p>Para cada carro vermelho, existe um caminhão azul.</p>
<p><span class="math display">\[\forall x (Carro(x) \land Vermelho(x) \rightarrow \exists y (Caminhão(y) \land Azul(y)))\]</span></p></li>
<li><p>Todos os planetas orbitam uma estrela, e existe um asteroide que orbita o sol.</p>
<p><span class="math display">\[(\forall x (Planeta(x) \rightarrow \exists y (Estrela(y) \land Orbita(x, y)))) \land (\exists z (Asteroide(z) \land Orbita(z, Sol)))\]</span></p></li>
</ol>
</section>
<section id="exemplos-extras-de-conversão-de-predicados-em-sentenças" class="level3" data-number="5.0.10">
<h3 data-number="5.0.10" class="anchored" data-anchor-id="exemplos-extras-de-conversão-de-predicados-em-sentenças"><span class="header-section-number">5.0.10</span> Exemplos Extras de Conversão de Predicados em Sentenças</h3>
<ol type="1">
<li><p><span class="math inline">\(\forall x (Gato(x) \rightarrow (Peludo(x) \land Dorminhoco(x)))\)</span></p>
<p><span class="math display">\[\text{Todo gato é peludo e dorminhoco.}\]</span></p></li>
<li><p><span class="math inline">\(\forall y (Árvore(y) \rightarrow (Verde(y) \land Grande(y)))\)</span></p>
<p><span class="math display">\[\text{Toda árvore é verde e grande.}\]</span></p></li>
<li><p><span class="math inline">\((\forall x (Cidade(x) \rightarrow Populosa(x))) \rightarrow (\forall y (País(y) \rightarrow Populoso(y)))\)</span></p>
<p><span class="math display">\[\text{Se toda cidade é populosa, então todo país é populoso.}\]</span></p></li>
<li><p><span class="math inline">\(\forall x (Criança(x) \rightarrow (Inocente(x) \land Curiosa(x))) \land \neg \exists y (Adulto(y) \land (Inocente(y) \land Curioso(y)))\)</span></p>
<p><span class="math display">\[\text{Toda criança é inocente e curiosa, e não existe um adulto que seja inocente e curioso.}\]</span></p></li>
<li><p><span class="math inline">\(\forall x (Ave(x) \rightarrow Voa(x)) \land \forall y (Peixe(y) \rightarrow Nada(y))\)</span></p>
<p><span class="math display">\[\text{Toda ave voa e todo peixe nada.}\]</span></p></li>
<li><p><span class="math inline">\(\exists x (Pessoa(x) \land Feliz(x))\)</span></p>
<p><span class="math display">\[\text{Existe uma pessoa que é feliz.}\]</span></p></li>
<li><p><span class="math inline">\(\exists y (Livro(y) \land Interessante(y) \land \neg Longo(y))\)</span></p>
<p><span class="math display">\[\text{Há um livro que é interessante e não é longo.}\]</span></p></li>
<li><p><span class="math inline">\(\exists x (Estudante(x) \land (\forall y (Disciplina(y) \rightarrow Gosta(x, y))))\)</span></p>
<p><span class="math display">\[\text{Existe um estudante que gosta de todas as disciplinas.}\]</span></p></li>
<li><p><span class="math inline">\(\exists x (Carro(x) \land Rápido(x)) \land \exists y (Carro(y) \land \neg Rápido(y))\)</span></p>
<p><span class="math display">\[\text{Existe um carro que é rápido, e existe um carro que não é rápido.}\]</span></p></li>
<li><p><span class="math inline">\(\neg \exists x (Político(x) \land Honesto(x))\)</span></p>
<p><span class="math display">\[\text{Não existe um político que seja honesto.}\]</span></p></li>
<li><p><span class="math display">\[\forall x (Cachorro(x) \rightarrow (\exists y (Pessoa(y) \land Dono(y, x))))\]</span></p>
<p><span class="math display">\[\text{Todo cachorro tem uma pessoa que é seu dono.}\]</span></p></li>
<li><p><span class="math display">\[\exists x (Música(x) \land (\forall y (Pessoa(y) \rightarrow Gosta(y, x))))\]</span></p>
<p><span class="math display">\[\text{Existe uma música que todas as pessoas gostam.}\]</span></p></li>
<li><p><span class="math display">\[\forall x (Estudante(x) \rightarrow (\exists y (Professor(y) \land Ensina(y, x))))\]</span></p>
<p><span class="math display">\[\text{Para todo estudante, existe um professor que o ensina.}\]</span></p></li>
<li><p><span class="math display">\[(\exists x (Médico(x) \land Competente(x))) \land (\forall y (Médico(y) \rightarrow Ocupado(y)))\]</span></p>
<p><span class="math display">\[\text{Existe um médico que é competente, e todo médico é ocupado.}\]</span></p></li>
<li><p><span class="math display">\[(\forall x (Artista(x) \rightarrow Criativo(x))) \rightarrow (\exists y (Pintor(y) \land Criativo(y)))\]</span></p>
<p><span class="math display">\[\text{Se todo artista é criativo, então existe um pintor que é criativo.}\]</span></p></li>
</ol>
</section>
<section id="ordem-de-aplicação-dos-quantificadores" class="level3" data-number="5.0.11">
<h3 data-number="5.0.11" class="anchored" data-anchor-id="ordem-de-aplicação-dos-quantificadores"><span class="header-section-number">5.0.11</span> Ordem de Aplicação dos Quantificadores</h3>
<p>Quando mais de uma variável é quantificada em uma Fórmula Bem Formada como <span class="math inline">\(\forall y\forall x P(x,y)\)</span>, elas são aplicadas de dentro para fora, ou seja, a mais próxima da fórmula atômica é aplicada primeiro. Assim, <span class="math inline">\(\forall y\forall x P(x,y)\)</span> se lê <em>existe um <span class="math inline">\(y\)</span> tal que para todo <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x,y)\)</span> se mantém</em> ou <em>para algum <span class="math inline">\(y\)</span>, <span class="math inline">\(P(x,y)\)</span> se mantém para todo <span class="math inline">\(x\)</span></em>.</p>
<p>As posições dos mesmos tipos de quantificadores podem ser trocadas sem afetar o valor lógico, desde que não haja quantificadores do outro tipo entre os que serão trocados.</p>
<p>Por exemplo, <span class="math inline">\(\forall x\forall y\forall z P(x,y,z)\)</span> é equivalente a <span class="math inline">\(\forall y\forall x\forall z P(x,y,z)\)</span>, <span class="math inline">\(\forall z\forall y\forall x P(x,y,z)\)</span>. O mesmo vale para o quantificador existencial.</p>
<p>No entanto, as posições de quantificadores de tipos diferentes <strong>não</strong> podem ser trocadas. Por exemplo, <span class="math inline">\(\forall x\exists y P(x,y)\)</span> <strong>não</strong> é equivalente A<span class="math inline">\(\exists y\forall x P(x,y)\)</span>. Por exemplo, seja <span class="math inline">\(P(x,y)\)</span> representando <span class="math inline">\(x &lt; y\)</span> Para o conjunto dos números como universo. Então, <span class="math inline">\(\forall x\exists y P(x,y)\)</span> se lê <em>para todo número <span class="math inline">\(x\)</span>, existe um número <span class="math inline">\(y\)</span> que é maior que <span class="math inline">\(x\)</span></em>, o que é verdadeiro, enquanto <span class="math inline">\(\exists y\forall x P(x,y)\)</span> se lê <em>existe um número que é maior que todo (qualquer) número</em>, o que não é verdadeiro.</p>
<section id="negação-dos-quantificadores" class="level4" data-number="5.0.11.1">
<h4 data-number="5.0.11.1" class="anchored" data-anchor-id="negação-dos-quantificadores"><span class="header-section-number">5.0.11.1</span> Negação dos Quantificadores</h4>
<p>Existe uma equivalência entre as negações dos quantificadores. De tal forma que:</p>
<ol type="1">
<li><p><strong>Negação do Quantificador Universal ($$)</strong>: A negação de uma afirmação universal significa que existe pelo menos um caso no Universo do Discurso em que a afirmação não é verdadeira. Isso pode ser expresso pela seguinte equivalência:</p>
<p><span class="math display">\[\neg \forall x \, P(x) \equiv \exists x \, \neg P(x)\]</span></p>
<p>Em linguagem natural podemos entender como: negar que <em>para todos os <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span> é verdadeiro</em> é equivalente a afirmar que <em>existe algum <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> não é verdadeiro</em>.</p></li>
<li><p><strong>Negação do Quantificador Existencial ( $$ )</strong>: A negação de uma afirmação existencial significa que a afirmação não é verdadeira para nenhum caso no Universo do Discurso. Isso pode ser expresso pela seguinte equivalência:</p></li>
</ol>
<p><span class="math display">\[\neg \exists x \, P(x) \equiv \forall x \, \neg P(x)\]</span></p>
<p>Ou seja, negar que <em>existe algum <span class="math inline">\(x\)</span> tal que <span class="math inline">\(P(x)\)</span> é verdadeiro</em> é equivalente a afirmar que <em>para todos os <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span> não é verdadeiro</em>.</p>
<p>Vamos tentar entender estas negações. Considere as expressões <span class="math inline">\(\neg (\forall x P(x))\)</span> e <span class="math inline">\(\exists x (\neg P(x))\)</span>. Essas fórmulas se aplicam a qualquer predicado <span class="math inline">\(P\)</span>, e possuem o mesmo valor de verdade para qualquer <span class="math inline">\(P\)</span>.</p>
<p>Na lógica proposicional, poderíamos simplesmente verificar isso com uma tabela verdade, mas aqui, não podemos. Não existem proposições, conectadas por $$, $$, para construir uma tabela e não é possível determinar o valor verdade de forma genérica para uma determinada variável.</p>
<p>Vamos tentar entender isso com linguagem natural: afirmar que <span class="math inline">\(\neg (\forall x P(x))\)</span> é verdadeiro significa que não é verdade que <span class="math inline">\(P(x)\)</span> se aplica a todas as possíveis entidades <span class="math inline">\(x\)</span>. Deve haver alguma entidade <span class="math inline">\(A\)</span> Para a qual<span class="math inline">\(P(a)\)</span> é falso. Como <span class="math inline">\(P(a)\)</span> é falso, <span class="math inline">\(\neg P(a)\)</span> é verdadeiro. Isso significa que <span class="math inline">\(\exists x (\neg P(x))\)</span> é verdadeiro. Portanto, a verdade de <span class="math inline">\(\neg (\forall x P(x))\)</span>implica a verdade de <span class="math inline">\(\exists x (\neg P(x))\)</span>.</p>
<p>Se <span class="math inline">\(\neg (\forall x P(x))\)</span> é falso, então <span class="math inline">\(\forall x P(x)\)</span> é verdadeiro. Como <span class="math inline">\(P(x)\)</span> é verdadeiro para todos os <span class="math inline">\(x\)</span>, <span class="math inline">\(\neg P(x)\)</span> é falso para todos os <span class="math inline">\(x\)</span>. Logo, <span class="math inline">\(\exists x (\neg P(x))\)</span> é falso.</p>
<p>Os valores de verdade de <span class="math inline">\(\neg (\forall x P(x))\)</span> e <span class="math inline">\(\exists x (\neg P(x))\)</span> são os mesmos. Como isso é verdadeiro para qualquer predicado <span class="math inline">\(P\)</span>, essas duas fórmulas são logicamente equivalentes, e podemos escrever <span class="math inline">\(\neg (\forall x P(x)) \equiv \exists x (\neg P(x))\)</span>.</p>
<p>Muita lógica? Que tal se tentarmos novamente, usando um pouco mais de linguagem natural. Considere as expressões lógicas <span class="math inline">\(\neg (\forall x P(x))\)</span> e <span class="math inline">\(\exists x (\neg P(x))\)</span>. Para ilustrar essas fórmulas, vamos usar um exemplo com um predicado <span class="math inline">\(P(x)\)</span> que se aplica a uma entidade <span class="math inline">\(x\)</span> se <em><span class="math inline">\(x\)</span> é feliz</em>.</p>
<p>A expressão <span class="math inline">\(\forall x P(x)\)</span> significa que todos são felizes. A negação dessa afirmação, <span class="math inline">\(\neg (\forall x P(x))\)</span>, equivale logicamente a <span class="math inline">\(\exists x (\neg P(x))\)</span>, ou seja, existe pelo menos um indivíduo que não é feliz.</p>
<p>A expressão <span class="math inline">\(\exists x (\neg P(x))\)</span> significa que <em>existe alguém que não está feliz</em>. Você pode ver que isso é apenas outra forma de expressar a ideia contida em <span class="math inline">\(\neg (\forall x P(x))\)</span>.</p>
<p>A afirmação de que <em>não é verdade que todos estão felizes</em> implica que deve haver alguém que não está feliz. Se a primeira afirmação é falsa (ou seja, todos estão felizes), então a segunda afirmação também deve ser falsa.</p>
<p>Portanto, as duas fórmulas têm o mesmo valor verdade. Elas são logicamente equivalentes e podem ser representadas como <span class="math inline">\(\neg (\forall x P(x)) \equiv \exists x (\neg P(x))\)</span>. Esta equivalência reflete uma relação profunda e intuitiva em nosso entendimento de declarações sobre entidades em nosso mundo.</p>
<table class="table">
<thead>
<tr class="header">
<th>Expressão</th>
<th>Equivalência</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\forall x P(x)\)</span></td>
<td><span class="math inline">\(\neg \exists x \neg P(x)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\exists x \, P(x)\)</span></td>
<td><span class="math inline">\(\neg \forall x \, \neg P(x)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\neg \forall x \, P(x)\)</span></td>
<td><span class="math inline">\(\exists x \, \neg P(x)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\neg \exists x \, P(x)\)</span></td>
<td><span class="math inline">\(\forall x \, \neg P(x)\)</span></td>
</tr>
</tbody>
</table>
<p><em>Tabela 5 - Equivalências entre Quantificadores.</em></p>
</section>
</section>
<section id="regras-de-inferência-usando-quantificadores" class="level3" data-number="5.0.12">
<h3 data-number="5.0.12" class="anchored" data-anchor-id="regras-de-inferência-usando-quantificadores"><span class="header-section-number">5.0.12</span> Regras de Inferência usando Quantificadores</h3>
<p>As regras de inferência com quantificadores lidam especificamente com as proposições que envolvem quantificadores. Estas regras nos permitem fazer generalizações ou especificações, transformando proposições universais em existenciais, e vice-versa. Compreender essas regras é essencial para aprofundar o entendimento da estrutura da lógica, o que nos permite analisar e construir argumentos mais complexos de forma precisa e coerente.</p>
<p>Nos próximos tópicos, exploraremos essas regras em detalhes, observando como elas interagem com os quantificadores universal e existencial.</p>
<section id="repetição" class="level4" data-number="5.0.12.1">
<h4 data-number="5.0.12.1" class="anchored" data-anchor-id="repetição"><span class="header-section-number">5.0.12.1</span> Repetição</h4>
<p>A regra de Repetição permite repetir uma afirmação. Esta regra é útil para propagar premissas em uma prova formal.</p>
<p><span class="math display">\[F\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;F\\
\hline
&amp;F\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>o céu está azul</em>.</li>
<li>Conclusão: logo, <em>o céu está azul</em>.</li>
</ul>
<p>Algumas aplicações da Repetição:</p>
<ul>
<li><p>Reafirmar premissas em provas longas. Por exemplo:</p>
<ul>
<li>Proposição: <em>todos os homens, <span class="math inline">\(H(x)\)</span>, são mortais, M(x)$</em>.</li>
<li>Conclusão: logo, <em>todos os homens são mortais</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\forall x(H(x) \rightarrow M(x))\\
\hline
&amp;\forall x(H(x) \rightarrow M(x))
\end{aligned}
\]</span></p>
<ul>
<li><p>Introduzir suposições em provas indiretas. Por exemplo:</p>
<ul>
<li>Proposição: <em>suponha que <span class="math inline">\((2 + 2 = 5)\)</span></em>.</li>
<li>Conclusão: logo, <em>(2 + 2 = 5)$</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;2 + 2 = 5\\
\hline
&amp;2 + 2 = 5
\end{aligned}
\]</span></p>
<ul>
<li><p>Derivar instâncias de generalizações. Por exemplo:</p>
<ul>
<li>Proposição: <em>para todo <span class="math inline">\(x\)</span>, <span class="math inline">\(x + 0 = x\)</span></em>.</li>
<li>Conclusão: logo, _<span class="math inline">\(2 + 0 = 2\)</span>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\forall x(x + 0 = x)\\
\hline
&amp;2 + 0 = 2
\end{aligned}
\]</span></p>
</section>
<section id="instanciação-universal" class="level4" data-number="5.0.12.2">
<h4 data-number="5.0.12.2" class="anchored" data-anchor-id="instanciação-universal"><span class="header-section-number">5.0.12.2</span> Instanciação Universal</h4>
<p>A regra de Instanciação Universal permite substituir a variável em uma afirmação universalmente quantificada por um termo concreto. Esta regra nos permite derivar casos particulares a partir de afirmações gerais.</p>
<p><span class="math display">\[\forall x P(x)\]</span></p>
<p><span class="math display">\[\begin{aligned}
&amp;\forall x P(x)\\
\hline
&amp;P(a)\\
\end{aligned}\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>todos os humanos são mortais</em>.</li>
<li>Conclusão: logo, <em>Sócrates é mortal</em>. Assumindo que Sócrates é humano.</li>
</ul>
<p><strong>Exemplo completo de aplicação</strong>:</p>
<ul>
<li><p><strong>Premissa 1</strong>: todos os mamíferos respiram ar: <span class="math inline">\(\forall x(M(x) \rightarrow R(x))\)</span>;</p></li>
<li><p><strong>Premissa 2</strong>: a baleia é um mamífero: <span class="math inline">\(M(b)\)</span>;</p></li>
<li><p><strong>Aplicação da Instanciação Universal à Premissa 1</strong>: <span class="math inline">\(M(b) \rightarrow R(b)\)</span>;</p></li>
<li><p><strong>Aplicação de Modus Ponens</strong>:</p>
<p><span class="math display">\[\begin{aligned}
&amp;M(b) \rightarrow R(b)\\
&amp;M(b)\\
\hline
&amp;R(b)
\end{aligned}\]</span></p></li>
<li><p><strong>Conclusão</strong>: logo, a baleia respira ar: <span class="math inline">\(R(b)\)</span></p></li>
</ul>
<p>Algumas aplicações da Instanciação Universal:</p>
<ul>
<li><p>Aplicar regras e princípios gerais. Por exemplo:</p>
<ul>
<li>Proposição: <em>todos os triângulos têm 180 graus internos</em>: <span class="math inline">\(\forall t(T(t) \rightarrow 180^\circ(t))\)</span>;</li>
<li>Premissa adicional: <em>ABC é um triângulo</em>: <span class="math inline">\(T(\text{Triângulo }ABC)\)</span>;</li>
<li>Aplicação da Instanciação Universal: <span class="math inline">\(T(\text{Triângulo }ABC) \rightarrow 180^\circ(\text{Triângulo }ABC)\)</span>;</li>
<li>Aplicação de Modus Ponens:</li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;T(\text{Triângulo }ABC) \rightarrow 180^\circ(\text{Triângulo }ABC)\\
&amp;T(\text{Triângulo }ABC)\\
\hline
&amp;180^\circ(\text{Triângulo }ABC)
\end{aligned}\]</span></p>
<ul>
<li>Conclusão: logo, <em>o triângulo <span class="math inline">\(ABC\)</span> tem 180 graus</em>.</li>
</ul></li>
<li><p>Testar propriedades em membros de conjuntos. Por exemplo:</p>
<ul>
<li>Proposição: <em>todo inteiro é maior que seu antecessor</em>: <span class="math inline">\(\forall n (\mathbb{Z}(n) \rightarrow (n &gt; n-1))\)</span>;</li>
<li>Premissa adicional: <em>5 é um inteiro</em>: <span class="math inline">\(\mathbb{Z}(5)\)</span>;</li>
<li>Aplicação da Instanciação Universal: <span class="math inline">\(\mathbb{Z}(5) \rightarrow (5 &gt; 5-1)\)</span>;</li>
<li>Aplicação de Modus Ponens:</li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;\mathbb{Z}(5) \rightarrow (5 &gt; 5-1)\\
&amp;\mathbb{Z}(5)\\
\hline
&amp;5 &gt; 4
\end{aligned}\]</span></p>
<ul>
<li>Conclusão: logo, <span class="math inline">\(5\)</span> é maior que <span class="math inline">\(4\)</span>.</li>
</ul></li>
</ul>
</section>
<section id="generalização-existencial" class="level4" data-number="5.0.12.3">
<h4 data-number="5.0.12.3" class="anchored" data-anchor-id="generalização-existencial"><span class="header-section-number">5.0.12.3</span> Generalização Existencial</h4>
<p>A regra de Generalização Existencial permite inferir que algo existe a partir de uma afirmação concreta. Esta regra nos permite generalizar de exemplos específicos para a existência geral.</p>
<p><span class="math display">\[P(a)\]</span></p>
<p><span class="math display">\[
\begin{aligned}
P(a)\\
\hline
\exists x P(x)\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>Rex é um cachorro</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos um cachorro</em>.</li>
</ul>
<p>Algumas aplicações da Generalização Existencial:</p>
<ul>
<li><p>Inferir existência a partir de exemplos concretos. Por exemplo:</p>
<ul>
<li>Proposição: <em>o urânio-235 é radioativo</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos um elemento químico radioativo</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;R(u_{235})\\
\hline
&amp;\exists x R(x)
\end{aligned}
\]</span></p>
<ul>
<li><p>Concluir que uma propriedade não é vazia. Por exemplo:</p>
<ul>
<li>Proposição: <em>$7 $ é um número primo</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos um número primo</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;P(7)\\
\hline
&amp;\exists x P(x)
\end{aligned}
\]</span></p>
<ul>
<li><p>Inferir a existência de soluções para problemas. Por exemplo:</p>
<ul>
<li>Proposição: <em>$x = 2 $ satisfaz a equação $x + 3 = 5 $</em>.</li>
<li>Conclusão: logo, <em>existe pelo menos uma solução para essa equação</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;S(2)\\
\hline
&amp;\exists x S(x)
\end{aligned}
\]</span></p>
</section>
<section id="instanciação-existencial" class="level4" data-number="5.0.12.4">
<h4 data-number="5.0.12.4" class="anchored" data-anchor-id="instanciação-existencial"><span class="header-section-number">5.0.12.4</span> Instanciação Existencial</h4>
<p>A regra de Instanciação Existencial permite introduzir um novo termo como instância de uma variável existencialmente quantificada. Esta regra nos permite derivar exemplos de afirmações existenciais.</p>
<p><span class="math display">\[\exists x P(x)\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x P(x)\\
\hline
&amp;P(b)\\
\end{aligned}
\]</span></p>
<p>Em linguagem natural:</p>
<ul>
<li>Proposição: <em>existe um cachorro com rabo curto</em>.</li>
<li>Conclusão: logo, <em>Rex tem rabo curto</em>.</li>
</ul>
<p>Algumas aplicações da Instanciação Existencial:</p>
<ul>
<li><p>Derivar exemplos de existência previamente estabelecida. Por exemplo:</p>
<ul>
<li>Proposição: <em>existem estrelas, $ e $, maiores, $M $, que o Sol, $s $</em>.</li>
<li>Conclusão: logo, <em>Alpha Centauri, <span class="math inline">\(A\)</span>, é maior que o Sol</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x (e (x) \land M(x, s))\\
\hline
&amp;M(a, s)
\end{aligned}
\]</span></p>
<ul>
<li><p>Construir modelos satisfatíveis para predicados existenciais. Por exemplo:</p>
<ul>
<li>Proposição: <em>existem pessoas mais velhas que <span class="math inline">\(25\)</span>Anos</em>.</li>
<li>Conclusão: logo, <em>John tem 30 anos</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x (P(x) \land V(x, 25))\\
\hline
&amp;P(j) \land V(j, 30)
\end{aligned}
\]</span></p>
<ul>
<li><p>Provar que conjuntos não estão vazios. Por exemplo:</p>
<ul>
<li>Proposição: <em>existem números reais maiores que <span class="math inline">\(2\)</span></em>.</li>
<li>Conclusão: logo, <em><span class="math inline">\(5\)</span> é um número real maior que <span class="math inline">\(2\)</span></em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\exists x (R(x) \land M(x, 2))\\
\hline
&amp;R(5) \land M(5, 2)
\end{aligned}
\]</span></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="pagination-link" aria-label="Provas">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Provas</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./05-formas-normais-e-skolemizacao.html" class="pagination-link" aria-label="Formas Normais">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Formas Normais</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/04-logica-predicativa-e-quantificadores.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>