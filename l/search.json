[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Programação Lógica",
    "section": "",
    "text": "1 Introdução\nA Programação Lógica representa um paradigma fundamental na ciência da computação que tem suas raízes profundamente entrelaçadas com os princípios da lógica matemática e filosófica. Como Marvin Minsky observou, “Logic programming is the future of artificial intelligence”, destacando a importância central deste campo para o desenvolvimento de sistemas inteligentes.\nEste livro convida você a uma jornada através dos fundamentos da lógica e sua aplicação computacional, explorando desde os conceitos básicos da lógica proposicional até as aplicações mais avançadas em verificação formal de programas e inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#estrutura-do-livro",
    "href": "index.html#estrutura-do-livro",
    "title": "Introdução à Programação Lógica",
    "section": "1.1 Estrutura do Livro",
    "text": "1.1 Estrutura do Livro\nA obra está organizada em duas partes principais:\nParte I - Fundamentos da Lógica: Apresenta os conceitos fundamentais necessários para compreender a programação lógica, incluindo lógica proposicional, técnicas de prova, lógica predicativa e quantificadores.\nParte II - Aplicações Avançadas: Explora as aplicações práticas dos conceitos fundamentais, incluindo formas normais, construção de mundos lógicos, cláusulas de Horn, Prolog, verificação formal e desafios lógicos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#público-alvo",
    "href": "index.html#público-alvo",
    "title": "Introdução à Programação Lógica",
    "section": "1.2 Público-Alvo",
    "text": "1.2 Público-Alvo\nEste material foi desenvolvido para estudantes de ciência da computação, engenharia de software, matemática aplicada e profissionais interessados em compreender os fundamentos teóricos que sustentam muitas das tecnologias modernas de inteligência artificial e sistemas de inferência.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#metodologia",
    "href": "index.html#metodologia",
    "title": "Introdução à Programação Lógica",
    "section": "1.3 Metodologia",
    "text": "1.3 Metodologia\nCada capítulo combina teoria rigorosa com exemplos práticos e exercícios, permitindo ao leitor não apenas compreender os conceitos, mas também aplicá-los na resolução de problemas reais. O texto progride de forma gradual, construindo conhecimento de maneira incremental e sempre conectando novos conceitos aos já estabelecidos.\nEsperamos que esta jornada pela programação lógica seja tanto educativa quanto inspiradora, fornecendo as bases sólidas necessárias para explorar as fronteiras da computação e da inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-jornada-programacao-logica.html",
    "href": "01-jornada-programacao-logica.html",
    "title": "2  Introdução",
    "section": "",
    "text": "ra &gt; “Logic programming is the future of artificial intelligence.” - Marvin Minsky{: class=“epigraph”}\nImagine, por um momento, que estamos explorando o universo dos computadores, mas em vez de sermos os comandantes, capazes de ditar todos os passos do caminho, nós fornecemos as diretrizes gerais e deixamos que o computador deduza o caminho. Pode parecer estranho para quem está envolvido com as linguagens do Paradigma Imperativo. Acredite ou não, isso é exatamente o que a Programação Lógica faz.\nEm vez de sermos forçados a ordenar cada detalhe do processo de solução de um problema, a Programação Lógica permite que declaremos o que queremos, e então deixemos o computador fazer o trabalho de encontrar os detalhes e processos necessários para resolver cada problema.\nNa Programação Imperativa partimos de uma determinada expressão e seguimos um conjunto de instruções até encontrar o resultado desejado. O programador fornece um conjunto de instruções que definem o fluxo de controle e modificam o estado da máquina a cada passo. O foco está em como o problema deve ser resolvido. Exemplos de linguagens imperativas incluem C++, Java e Python.\nNa Programação Descritiva, o programador fornece uma descrição lógica ou funcional, do que deve ser feito, sem especificar o fluxo de controle. O foco está no problema, não na solução. Exemplos incluem SQL, Prolog e Haskell. Na Programação Lógica, partimos de uma hipótese e, de acordo com um conjunto específico de regras, tentamos construir uma prova para esta hipótese.\nNa Programação Lógica, um dos paradigmas da Programação Descritiva usamos a dedução para resolver problemas.\nUma hipótese é uma suposição, expressa na forma de proposição, que é acreditada ser verdadeira, mas que ainda não foi provada. Uma sentença declarativa que precisa ser verificada em busca da sua validação. Na linguagem natural, conjecturas são frequentemente expressas como declarações. Na Lógica de Primeira Ordem, serão proposições e as proposições serão tratadas como sentenças que foram criadas para serem verificadas na busca da verdade. Para testar a verdade expressa nestas sentenças usaremos as ferramentas da própria Lógica de Primeira Ordem.\n\n\n\nDiagrama de Significado de Conjecturas\n\n\nEm resumo: programação imperativa focada no processo, no como chegar à solução; programação descritiva focada no problema em si, no o que precisa ser feito. Eu, sempre que posso escolho uma linguagem descritiva. Não há glória, nem honra nesta escolha apenas as lamúrias da opinião pessoal.\nSua escolha, pessoal e intransferível, entre estes paradigmas dependerá da aplicação que será construída, tanto quanto dependerá do estilo do programador. Contudo, o futuro parece cada vez mais orientado para linguagens descritivas, que permitam ao programador concentrar-se no problema, não nos detalhes da solução. Efeito que parece ser evidente se considerarmos os avanços da segunda década no século XXI no campo da Inteligência Artificial. Este documento contém a base matemática que suporta o entendimento da programação lógica e um pouco de Prolog, como linguagem de programação para solução de problemas. Será uma longa jornada.\nEm nossa jornada, percorreremos a Lógica de Primeira Ordem. Esta será a nossa primeira rota, que iremos subdividir em elementos interligados e interdependentes e, sem dúvida, de mesma importância e valor: a lógica Proposicional e a lógica Predicativa. Não deixe de notar que muitos dos nossos companheiros de viagem, aqueles restritos à academia, podem não entender as sutilezas desta divisão.\nPretensioso este timoneiro tenta não ser. Partiremos da Lógica Proposicional com esperança de encontrar bons ventos que nos levem até o Prolog.\nA Lógica Proposicional é um tipo de linguagem matemática, suficientemente rica para expressar os problemas que precisamos resolver e suficientemente simples para que computadores possam lidar com ela. Quando esta ferramenta estiver conhecida mergulharemos na alma da Lógica de Primeira Ordem, a Lógica Predicativa, ou Lógica de Predicados, e então poderemos fazer sentido do mundo real de forma clara e bela.\nVamos enfrentar a inferência e a dedução, duas ferramentas para extração de conhecimento de declarações lógicas. Voltando a metáfora do Detetive, podemos dizer que a inferência é quase como um detetive que tira conclusões a partir de pistas: teremos algumas verdades, nossas pistas, e precisaremos descobrir outras verdades, consequências diretas das primeiras verdades, para encontrar o que procuramos de forma incontestável. A verdade da lógica não abarca opiniões ou contestações. É linda e inquestionável.\nNossos mares não serão brandos, mas não nos furtaremos a enfrentar as especificidades da Cláusula de Horn, um conceito um pouco mais estranho. Uma regra que torna todos os problemas expressos em lógica mais fáceis de resolver. Como um mapa que, se seguido corretamente, torna o processo de descobrir a verdade mais simples. Muito mais simples, até mesmo passível de automatização.\nNo final do dia, cansados, porém felizes, vamos entender que, desde os tempos de Gödel, Turing e Church, tudo que queremos é que nossas máquinas sejam capazes de resolver problemas complexos com o mínimo de interferência nossa. Queremos que elas pensem, ou pelo menos, que simulem o pensamento. Aqui, neste objetivo, entre as pérolas mais reluzentes da evolução humana destaca-se a Programação Lógica.\nComo diria Newton chegamos até aqui porque nos apoiamos nos ombros de gigantes. O termo Programação Lógica aparece em meados dos anos 1970 como uma evolução dos esforços nas pesquisas sobre a prova computacional de teoremas matemáticos e Inteligência Artificial. O homem querendo fazer máquinas capazes de raciocinar como o homem. Deste esforço surgiu a esperança de que poderíamos usar a lógica como uma linguagem de programação, em inglês, programming logic, ou Prolog. Aqui está a base deste conhecimento.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html",
    "href": "02-fundamentos-logica-proposicional.html",
    "title": "3  Lógica de Primeira Ordem",
    "section": "",
    "text": "3.1 Lógica Proposicional\nEsse sistema, também chamado de álgebra booleana, fundamental para o desenvolvimento da computação, é uma verdadeira tapeçaria de possibilidades. Na Lógica Proposicional, declarações atômicas, que só podem ter valores verdadeiro, \\(T\\), ou falso \\(F\\), são entrelaçadas em declarações compostas cuja veracidade, segundo as regras desse cálculo, depende dos valores de verdade das declarações atômicas que as compõem quando sujeitas aos operadores, ou aos conectivos, que definimos anteriormente.\nVamos representar essas declarações atômicas por literais \\(A\\), \\(B\\), \\(X_1\\), \\(X_2\\) etc., e suas negações por \\(\\neg A\\), \\(\\neg B\\), \\(\\neg X_1\\), \\(\\neg X_2\\) etc. Todos os símbolos individuais e suas negações são conhecidos como literais.\nNa Lógica Proposicional, as fórmulas são conhecidas como Fórmulas Bem Formadas. Elas podem ser atômicas ou compostas. Nas fórmulas compostas, um operador principal liga duas fórmulas atômicas ou duas compostas.\nAs declarações atômicas e compostas são costuradas por conectivos para produzir declarações compostas, cujo valor de verdade depende dos valores de verdade das declarações componentes. Os conectivos que consideramos inicialmente, e suas tabelas verdade serão:\nTabela 1 - Tabela Verdade, operadores básicos.{: class=“legend”}\nQuando usamos a Tabela Verdade em uma declaração composta, podemos ver se ela é verdadeira ou falsa. Basta seguir as regras de precedência e aplicar a Tabela Verdade, simplificando a expressão. É uma alternativa mais direta do que o uso dos axiomas da Lógica Proposicional.\nO operador \\(\\vee\\), também chamado de ou inclusivo, é verdade quando pelo menos um dos termos é verdadeiro. Diferindo de um operador, que por não ser básico e fundamental, não consta da nossa lista, chamado de ou exclusivo, \\(\\oplus\\), falso se ambos os termos forem iguais, ou verdadeiros ou falsos.\nO condicional \\(\\rightarrow\\) não implica em causalidade. O condicional \\(\\rightarrow\\) é falso apenas quando o antecedente é verdadeiro e o consequente é falso.\nO bicondicional \\(\\leftrightarrow\\) equivale a ambos os componentes terem o mesmo valor-verdade. Todos os operadores, ou conectivos, conectam duas declarações, exceto \\(\\neg\\) que se aplica a apenas um termo.\nCada operador com sua própria aridade:\nTabela 2 - Aridade dos Operadores da Lógica Proposicional.{: class=“legend”}\nAinda observando a Tabela 1, que contém a Tabela Verdade dos operadores da Lógica Proposicional, é fácil perceber que se tivermos quatro termos diferentes, em vez de dois, teremos \\(2^4 = 16\\) linhas. Independentemente do número de termos, se para uma determinada Fórmula Bem Formada todos os resultados forem verdadeiros, \\(T\\), teremos uma tautologia, se todos forem falsos, \\(F\\) uma contradição.\nUma tautologia é uma fórmula que é sempre verdadeira, não importa os valores dados às variáveis. Na Programação Lógica, tautologias são verdades universais no domínio do problema. Uma contradição é uma fórmula que é sempre falsa, independentemente dos valores das variáveis. Em Programação Lógica, contradições mostram inconsistências ou impossibilidades lógicas no domínio.\nIdentificar tautologias permite simplificar expressões e fazer inferências válidas automaticamente. Reconhecer contradições evita o custo de tentar provar algo logicamente impossível.\nLinguagens de programação que usam a Programação Lógica usam unificação e resolução para fazer deduções. Tautologias geram cláusulas vazias que simplificam esta resolução. Em problemas de satisfatibilidade, se obtivermos uma contradição, sabemos que as premissas são insatisfatíveis. Segure as lágrimas e o medo. Os termos unificação e satisfatibilidade serão explicados assim que sejam necessários. Antes disso, precisamos falar de equivalências. Para isso vamos incluir um metacaractere no alfabeto da nossa linguagem: o caractere \\(\\equiv\\) que permitirá o entendimento das principais equivalências da Lógica Proposicional explicitadas a seguir:\nTabela 3 - Equivalências em Lógica Proposicional.{: class=“legend”}\nComo essas equivalências permitem validar Fórmulas Bem Formadas sem o uso de uma tabela verdade. Uma coisa interessante seria tentar provar cada uma delas. Mas, isso fica, por enquanto, a cargo da amável leitora.\nAAs equivalências que mencionei surgiram quase naturalmente enquanto escrevia, mais por hábito e necessidade do que por um raciocínio organizado. Existem muitas equivalências, mas essas são as que uso com mais frequência. Talvez, alguns exemplos de validação de Fórmulas Bem Formadas, usando apenas as equivalências da Tabela 3, possam inflar as velas do conhecimento e nos guiar pelo caminho que devemos seguir:\nExemplo 1: \\(P \\wedge (Q \\vee (P \\wedge R))\\)\n\\[\n\\begin{align*}\nP \\wedge (Q \\vee (P \\wedge R)) &\\equiv (P \\wedge Q) \\vee (P \\wedge (P \\wedge R)) && \\text{Distributividade da Conjunção sobre a Disjunção (3)} \\\\\n&\\equiv (P \\wedge Q) \\vee ((P \\wedge P) \\wedge R) && \\text{Associatividade da Conjunção (20)} \\\\\n&\\equiv (P \\wedge Q) \\vee (P \\wedge R) && \\text{Idempotência da Conjunção (P} \\wedge \\text{P} \\equiv \\text{P)}\n\\end{align*}\n\\]\nNota: A lei da Idempotência (\\(P \\wedge P \\equiv P\\)) não está na Tabela 3.\nExemplo 2:\\(P\\rightarrow (Q \\wedge (R \\vee P))\\)\n\\[\n\\begin{align*}\nP \\rightarrow (Q \\wedge (R \\vee P)) &\\equiv \\neg P \\vee (Q \\wedge (R \\vee P)) && \\text{(7)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (\\neg P \\vee (R \\vee P)) && \\text{(4)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (R \\vee \\neg P \\vee P) && \\text{(2)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge T && \\text{(11)} \\\\\n&\\equiv \\neg P \\vee Q && \\text{(14)}\n\\end{align*}\n\\]\nExemplo 3: \\(\\neg (P \\wedge (Q \\rightarrow R))\\)\n\\[\n\\begin{align*}\n\\neg (P \\wedge (Q \\rightarrow R)) &\\equiv \\neg (P \\wedge (\\neg Q \\vee R)) && \\text{(7)} \\\\\n&\\equiv \\neg P \\vee \\neg (\\neg Q \\vee R) && \\text{(5)} \\\\\n&\\equiv \\neg P \\vee (Q \\wedge \\neg R) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 4: \\(\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S))\\)\n\\[\n\\begin{align*}\n\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S)) &\\equiv \\neg ((\\neg P \\vee Q) \\wedge (\\neg R \\vee S)) && \\text{(7)} \\\\\n&\\equiv \\neg (\\neg P \\vee Q) \\vee \\neg (\\neg R \\vee S) && \\text{(5)} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (R \\wedge \\neg S) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 5: \\((P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P)\\)\n\\[\n\\begin{align*}\n(P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P) &\\equiv (\\neg P \\vee Q) \\vee (\\neg R \\vee S) \\vee (\\neg E \\vee P) && \\text{(7)} \\\\\n&\\equiv \\neg P \\vee Q \\vee \\neg R \\vee S \\vee \\neg E \\vee P && \\text{(2)}\\\\\n&\\equiv TRUE \\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{(11)}\\\\\n&\\equiv TRUE \\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{(11)}\\\\\n&\\equiv TRUE\n\\end{align*}\n\\]\nExemplo 6: \\(P\\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P)\\)\nVamos simplificar a expressão passo a passo, indicando as leis da Tabela 3 utilizadas:\n\\[\n\\begin{align*}\n&P\\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P) \\\\\n&\\equiv P\\wedge (Q \\vee (\\neg R \\vee S)) \\vee ((\\neg E \\rightarrow P) \\wedge (P \\rightarrow \\neg E)) && \\text{Definição de Implicação (7), Definição de Equivalência (8)} \\\\\n&\\equiv P\\wedge (Q \\vee \\neg R \\vee S) \\vee ((\\neg (\\neg E) \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Associatividade da Disjunção (21), Definição de Implicação (7)} \\\\\n&\\equiv P\\wedge (Q \\vee \\neg R \\vee S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Lei da Dupla Negação (12)} \\\\\n&\\equiv (P\\wedge Q) \\vee (P\\wedge \\neg R) \\vee (P\\wedge S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Distributividade da Conjunção sobre a Disjunção (3), aplicada repetidamente} \\\\\n&\\equiv (P\\wedge Q) \\vee (P\\wedge \\neg R) \\vee (P\\wedge S) \\vee (E \\wedge (\\neg P \\vee \\neg E)) \\vee (P \\wedge (\\neg P \\vee \\neg E)) && \\text{Distributividade da Disjunção sobre a Conjunção (4)} \\\\\n&\\equiv (P\\wedge Q) \\vee (P\\wedge \\neg R) \\vee (P\\wedge S) \\vee (E \\wedge \\neg P) \\vee (E \\wedge \\neg E) \\vee (P \\wedge \\neg P) \\vee (P \\wedge \\neg E) && \\text{Distributividade da Conjunção sobre a Disjunção (3)} \\\\\n&\\equiv (P\\wedge Q) \\vee (P\\wedge \\neg R) \\vee (P\\wedge S) \\vee (E \\wedge \\neg P) \\vee F \\vee F \\vee (P \\wedge \\neg E) && \\text{Lei da Contradição (e.g., } E \\wedge \\neg E \\equiv F \\text{, similar à (10))} \\\\\n&\\equiv (P\\wedge Q) \\vee (P\\wedge \\neg R) \\vee (P\\wedge S) \\vee (E \\wedge \\neg P) \\vee (P \\wedge \\neg E) && \\text{Lei da Identidade para a Disjunção (17)}\n\\end{align*}\n\\]\nEste exemplo ilustra como múltiplas leis podem ser aplicadas. A cuidadosa leitora pode verificar cada passo com atenção. A simplificação completa pode ser extensa.\nExemplo 7: determinar se a fórmula \\(\\neg(P \\lor (Q \\land \\neg R)) \\leftrightarrow ((S \\lor E) \\rightarrow (P \\land Q))\\) é uma equivalência lógica.\nPara analisar esta suposta equivalência, vamos simplificar ambos os lados separadamente:\nLado Esquerdo:\n\\[\\begin{align*}\n\\neg(P \\lor (Q \\land \\neg R)) &\\equiv \\neg P \\land \\neg(Q \\land \\neg R) & \\text{(Lei de De Morgan)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor \\neg\\neg R) & \\text{(Lei de De Morgan)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor R) & \\text{(Dupla Negação)}\n\\end{align*}\\]\nLado Direito:\n\\[\\begin{align*}\n((S \\lor E) \\rightarrow (P \\land Q)) &\\equiv \\neg(S \\lor E) \\lor (P \\land Q) & \\text{(Eliminação da Implicação)} \\\\\n&\\equiv (\\neg S \\land \\neg E) \\lor (P \\land Q) & \\text{(Lei de De Morgan)}\n\\end{align*}\\]\nComo podemos ver, os resultados finais \\(\\neg P \\land (\\neg Q \\lor R)\\) e \\((\\neg S \\land \\neg E) \\lor (P \\land Q)\\) têm formas diferentes e envolvem variáveis diferentes. Claramente, estas expressões não são logicamente equivalentes, a menos que existam restrições adicionais entre as variáveis \\(P\\), \\(Q\\), \\(R\\), \\(S\\) e \\(E\\), que não foram especificadas.\nConclusão: As expressões não são logicamente equivalentes.\nExemplo 8:\n\\(\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P))\\)\n\\[\n\\begin{align*}\n\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P)) &\\equiv \\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(8)}\\\\\n&\\equiv (\\neg(P \\rightarrow Q) \\vee \\neg(Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(5)}\\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 9: \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\)\nVamos simplificar a expressão. Para clareza, podemos denotar \\(A \\equiv (\\neg R \\leftrightarrow S)\\). \\[\n\\begin{align*}\n&(P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P)) \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg (\\neg R \\leftrightarrow S) \\vee (\\neg E \\wedge P)) && \\text{Definição de Implicação (7)} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg ((\\neg R \\rightarrow S) \\wedge (S \\rightarrow \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Definição de Equivalência (8)} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg (\\neg (\\neg R) \\vee S) \\vee \\neg ( \\neg S \\vee \\neg R) \\vee (\\neg E \\wedge P)) && \\text{Lei de De Morgan (5), Definição de Implicação (7) (aplicada duas vezes)} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg (R \\vee S) \\vee \\neg ( \\neg S \\vee \\neg R) \\vee (\\neg E \\wedge P)) && \\text{Lei da Dupla Negação (12)} \\\\\n&\\equiv (P \\wedge Q) \\vee ((\\neg R \\wedge \\neg S) \\vee (S \\wedge R) \\vee (\\neg E \\wedge P)) && \\text{Lei de De Morgan (6) (aplicada duas vezes), Lei da Dupla Negação (12)}\n\\end{align*}\n\\]\nA atenta leitora pode notar que a negação de uma equivalência \\(\\neg(X \\leftrightarrow Y)\\) também pode ser expressa como \\((X \\wedge \\neg Y) \\vee (\\neg X \\wedge Y)\\).\nExemplo 10: \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\)\nVamos simplificar ambos os lados da equivalência: Lado Esquerdo (LE): \\(\\neg(P \\wedge (Q \\vee R))\\)\n\\[\n\\begin{align*}\n\\text{LE} &\\equiv \\neg P \\vee \\neg(Q \\vee R) && \\text{Lei de De Morgan (5)} \\\\\n&\\equiv \\neg P \\vee (\\neg Q \\wedge \\neg R) && \\text{Lei de De Morgan (6)}\n\\end{align*}\n\\]\nLado Direito (LD): \\(\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q)\\)\n\\[\n\\begin{align*}\n\\text{LD} &\\equiv \\neg(\\neg S \\vee E) \\vee \\neg(\\neg P \\vee Q) && \\text{Definição de Implicação (7) (aplicada duas vezes)} \\\\\n&\\equiv (S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) && \\text{Lei de De Morgan (6) (aplicada duas vezes), Lei da Dupla Negação (12)}\n\\end{align*}\n\\]\nPortanto, a expressão original é equivalente a:\n\\[\n(\\neg P \\vee (\\neg Q \\wedge \\neg R)) \\leftrightarrow ((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q))\n\\]\nNão foram utilizadas substituições temporárias como \\(F\\) ou \\(G\\) para manter a clareza.\nA lógica proposicional é essencial para entendermos o mundo. É a base de argumentos sólidos e da avaliação de proposições. Nasceu da necessidade humana de buscar a verdade e resolver conflitos com a lógica. Mas sua beleza vai além da filosofia, do discurso e da matemática. É a fundação da álgebra de George Boole, que sustenta o design de circuitos eletrônicos e a construção dos computadores modernos.\nEm sua dissertação de final de curso, Claude Shannon usou a álgebra booleana para simplificar circuitos de controle. Desde então, as operações básicas dessa álgebra — AND, OR, NOT — tornaram-se os blocos fundamentais dos sistemas digitais. Elas formam o núcleo dos computadores, dos celulares e, na verdade, de toda a nossa civilização digital. A lógica proposicional é a base de todo o raciocínio lógico. Como a tabela periódica para químicos ou as leis de Newton para físicos. Ela é simples, elegante e poderosa.\nTão importante quanto o impacto da lógica proposicional na tecnologia digital é seu papel no pensamento racional, na tomada de decisões e na prova de teoremas. Neste caminho, nosso guia são as regras de inferência.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lógica de Primeira Ordem</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#lógica-proposicional",
    "href": "02-fundamentos-logica-proposicional.html#lógica-proposicional",
    "title": "3  Lógica de Primeira Ordem",
    "section": "",
    "text": "\\(P\\)\n\\(Q\\)\n\\(P\\vee Q\\)\n\\(P\\wedge Q\\)\n\\(\\neg P\\)\n\\(P\\rightarrow Q\\)\n\\(P\\leftrightarrow Q\\)\n\\(P\\oplus Q\\)\n\n\n\n\nT\nT\n\\(T\\)\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\\(T\\)\n\\(F\\)\n\n\nT\nF\n\\(T\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(T\\)\n\n\nF\nT\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\n\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(T\\)\n\\(T\\)\n\\(T\\)\n\\(F\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo Argumentos\nAridade\nExemplos\n\n\n\n\n0\nNulo\n\\(5\\), \\(False\\), Constantes\n\n\n1\nUnário\n\\(P(x)\\), \\(7x\\)\n\n\n2\nBinário\n\\(x \\vee y\\), \\(c \\wedge y\\)\n\n\n3\nTernário\nif \\(P\\) then \\(Q\\) else \\(R\\), \\((P \\rightarrow Q) \\wedge (\\neg P \\rightarrow R)\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpressão Lógica Equivalente\nNome da Lei/Propriedade\nRef.\n\n\n\n\n\\(P \\land Q \\equiv Q \\land P\\)\nComutatividade da Conjunção\n(1)\n\n\n\\(P \\lor Q \\equiv Q \\lor P\\)\nComutatividade da Disjunção\n(2)\n\n\n\\(P \\land (Q \\lor R) \\equiv (P \\land Q) \\lor (P \\land R)\\)\nDistributividade da Conjunção sobre a Disjunção\n(3)\n\n\n\\(P \\lor (Q \\land R) \\equiv (P \\lor Q) \\land (P \\lor R)\\)\nDistributividade da Disjunção sobre a Conjunção\n(4)\n\n\n\\(\\neg (P \\land Q) \\equiv \\neg P \\lor \\neg Q\\)\nLei de De Morgan\n(5)\n\n\n\\(\\neg (P \\lor Q) \\equiv \\neg P \\land \\neg Q\\)\nLei de De Morgan\n(6)\n\n\n\\(P \\rightarrow Q \\equiv \\neg P \\lor Q\\)\nDefinição de Implicação\n(7)\n\n\n\\(P \\leftrightarrow Q \\equiv (P \\rightarrow Q) \\land (Q \\rightarrow P)\\)\nDefinição de Equivalência\n(8)\n\n\n\\(P \\rightarrow Q \\equiv \\neg Q \\rightarrow \\neg P\\)\nLei da Contrapositiva\n(9)\n\n\n\\(P \\land \\neg P \\equiv F\\)\nLei da Contradição\n(10)\n\n\n\\(P \\lor \\neg P \\equiv T\\)\nLei do Terceiro Excluído\n(11)\n\n\n\\(\\neg(\\neg P) \\equiv P\\)\nLei da Dupla Negação\n(12)\n\n\n\\(P \\equiv P\\)\nLei da Identidade\n(13)\n\n\n\\(P \\land T \\equiv P\\)\nLei da Identidade para a Conjunção\n(14)\n\n\n\\(P \\land F \\equiv F\\)\nLei do Domínio para a Conjunção\n(15)\n\n\n\\(P \\lor T \\equiv T\\)\nLei do Domínio para a Disjunção\n(16)\n\n\n\\(P \\lor F \\equiv P\\)\nLei da Identidade para a Disjunção\n(17)\n\n\n\\((P \\land Q) \\land R \\equiv P \\land (Q \\land R)\\)\nAssociatividade da Conjunção\n(18)\n\n\n\\((P \\lor Q) \\lor R \\equiv P \\lor (Q \\lor R)\\)\nAssociatividade da Disjunção\n(19)\n\n\n\\(P \\land P \\equiv P\\)\nIdempotência da Conjunção\n(20)\n\n\n\\(P \\lor P \\equiv P\\)\nIdempotência da Disjunção\n(21)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.1.1 Regras de Inferência\nRegras de inferência são esquemas que proporcionam a estrutura para derivações lógicas. Base da tomada de decisão computacional. Elas definem os passos legítimos que podem ser aplicados a uma ou mais proposições, sejam elas atômicas ou Fórmulas Bem Formadas, para produzir uma proposição nova. Em outras palavras, uma regra de inferência é uma transformação sintática de Formas Bem Formadas que preserva a verdade.\nAqui uma regra de inferência será representada por:\n\\[\\frac{P_1, P_2, ..., P_n}{C},\\]\nou, eventualmente por:\n\\[P_1, P_2, ..., P_n \\vdash C.\\]\nO conjunto formado \\(P_1, P_2, ..., P_n\\), chamado de contexto, ou antecedente, \\(\\Gamma\\), e \\(C\\), chamado de conclusão, ou consequente, são Fórmulas Bem Formadas. A regra significa que se as proposições que constituem a conjunção expressa no contexto são verdadeiras, então a conclusão \\(C\\), consequência, também será verdadeira.\nEu vou tentar usar contexto e conclusão. Mas a compassiva leitora deve me perdoar se eu escapar para antecedente e consequente. É apenas o hábito.\nQuando estudamos lógica, chamamos de argumento uma lista de proposições, que aqui são as premissas. Elas vêm seguidas de uma palavra ou expressão (portanto, consequentemente, desta forma) e de outra proposição, que chamamos de conclusão. A forma que usamos para representar isso é chamada de sequência de dedução. É uma forma de mostrar que, se a proposição colocada acima da linha horizontal for verdadeira, então estamos afirmando que todas as proposições \\(P_1, P_2, ..., P_n\\) acima da linha são verdadeiras. E, por isso, a proposição abaixo da linha, a conclusão, também será verdadeira.\nAs regras de inferência são o alicerce da lógica dedutiva e das provas matemáticas. Elas permitem que raciocínios complexos sejam divididos em passos simples, com cada passo sendo justificado pela aplicação de uma regra de inferência. A seguir, estão algumas das regras de inferência mais usadas:\n\n3.1.1.1 Modus Ponens\nA regra do Modus Ponens permite inferir uma conclusão a partir de uma implicação e de sua premissa antecedente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(P\\) é verdadeiro, então podemos concluir que \\(Q\\) também é verdadeiro.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: se chover, \\((P)\\), então, \\((\\rightarrow)\\), a rua ficará molhada, \\((Q)\\);\nProposição 2: está chovendo, \\((P)\\) é verdadeira.\nConclusão: logo, a rua ficará molhada, \\((Q)\\).\n\nAlgumas aplicações do Modus Ponens:\n\nDerivar ações de regras e leis condicionais. Por exemplo:\n\nProposição: se a velocidade, \\(V\\), é maior que \\(80 \\text{km/h}\\), então é uma infração de trânsito, \\(IT\\).\nProposição: joão está dirigindo, $ d$, A \\(90 \\text{km/h}\\).\nConclusão: logo, João cometeu uma infração de trânsito.\n\n\n\\[V &gt; 80 \\rightarrow IT\\]\n\\[\n\\begin{aligned}\n&D = 90\\\\\n\\hline\n&IT\n\\end{aligned}\n\\]\n\nAplicar implicações teóricas e chegar a novas conclusões. Por exemplo:\n\nProposição: se um número é par, \\(P\\), então é divisível por 2, $ d2$.\nProposição: 128 é par.\nConclusão: logo, 128 é divisível por 2.\n\n\n\\[ x \\text{ é par} \\rightarrow \\text{divisível por dois}\\]\n\\[\n\\begin{aligned}\n&128 \\text{ é par}\\\\\n\\hline\n&128 \\text{ é divisível por 2}\n\\end{aligned}\n\\]\n\nFazer deduções lógicas em matemática e ciência. Por exemplo:\n\nProposição: se dois lados de um triângulo têm o mesmo comprimento, então o triângulo é isósceles.\nProposição: o triângulo \\(ABC\\) tem os lados \\(AB\\), \\(AC\\) e \\(BC\\) do mesmo comprimento.\nConclusão: logo, o triângulo \\(ABC\\) é isósceles.\n\n\n\\[\n\\begin{aligned}\n&(AB = AC) \\wedge (AB=CB) \\text{ no triângulo} ABC\\\\\n\\hline\n&\\text{o triângulo } ABC \\text{ é isósceles}\n\\end{aligned}\n\\]\n\nTirar conclusões com base no raciocínio condicional na vida cotidiana. Por exemplo:\n\nProposição: se hoje não chover, então irei à praia.\nProposição: Hoje não choveu.\nConclusão: logo, irei à praia.\n\n\n\\[\\neg (\\text{chover hoje}) \\rightarrow \\text{ir à praia}\\]\n\\[\n\\begin{aligned}\n&\\neg (\\text{choveu hoje})\\\\\n\\hline\n&(\\text{ir à praia})\n\\end{aligned}\n\\]\n\n\n3.1.1.2 Modus Tollens\nA regra do Modus Tollens permite inferir a negação da premissa antecedente a partir de uma implicação e da negação de sua premissa consequente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(Q\\) é falso (ou seja, \\(\\neg G\\)), então podemos concluir que \\(P\\) também é falso.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&\\neg P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição 1: se uma pessoa tem 18 anos ou mais, \\((P)\\), então, \\((\\rightarrow)\\) ela pode votar, \\((Q)\\);\nProposição 2: maria não pode votar\\((\\neg Q)\\);\nConclusão: logo, maria não tem 18 anos ou mais, \\((\\neg P)\\).\n\nAlgumas aplicações do Modus Tollens:\n\nRefutar teorias mostrando que suas previsões são falsas. Por exemplo:\n\nProposição: se a teoria da geração espontânea, \\(TG\\) é correta, insetos irão se formar em carne deixada exposta ao ar, \\(I\\).\nProposição: insetos não se formam em carne deixada exposta ao ar.\nConclusão: logo, a teoria da geração espontânea é falsa.\n\n\n\\[TG \\rightarrow I\\]\n\\[\n\\begin{aligned}\n\\neg I\\\\\n\\hline\n\\neg TG\n\\end{aligned}\n\\]\n\nIdentificar inconsistências ou contradições em raciocínios. Por exemplo:\n\nProposição: se João, \\(J\\), é mais alto, \\(&gt;\\), que Maria $m $, então Maria não é mais alta que João.\nProposição: Maria é mais alta que João.\nConclusão: logo, o raciocínio é inconsistente.\n\n\n\\[(J&gt;M) \\rightarrow \\neg(M&gt;J)\\]\n\\[\n\\begin{aligned}\n(M&gt;J)\\\\\n\\hline\n\\neg(J&gt;M)\n\\end{aligned}\n\\]\n\nFazer deduções lógicas baseadas na negação da conclusão. Por exemplo:\n\nProposição: se hoje, \\(H\\), é sexta-feira, \\(se\\), amanhã é sábado \\(SA\\).\nProposição: amanhã não é sábado.\nConclusão: logo, hoje não é sexta-feira.\n\n\n\\[(H=Se) \\rightarrow (A=SA)\\]\n\\[\n\\begin{aligned}\n\\neg(A=(Sa)\\\\\n\\hline\n\\neg(H=Se)\n\\end{aligned}\n\\]\n\nDescobrir causas de eventos por eliminação de possibilidades. Por exemplo:\n\nProposição: se a tomada está com defeito, \\(D\\)A lâmpada não acende \\(L\\).\nProposição: a lâmpada não acendeu.\nConclusão: logo, a tomada deve estar com defeito.\n\n\n\\[D \\rightarrow \\neg L\\]\n\\[\n\\begin{aligned}\n&\\neg L\\\\\n\\hline\n&D\n\\end{aligned}\n\\]\n\n\n3.1.1.3 Dupla Negação\nA regra da Dupla Negação permite eliminar uma dupla negação, inferindo a afirmação original. A negação de uma negação é equivalente à afirmação original. Esta regra é importante para simplificar expressões lógicas.\n\\[\\neg \\neg F\\]\n\\[\n\\begin{aligned}\n&\\neg \\neg F\\\\\n\\hline\n&F\\\\\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n&F\\\\\n\\hline\n&\\neg \\neg F\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: não é verdade, \\((\\neg Q)\\), que maria não, \\((\\neg Q)\\), está feliz, \\((P)\\).\nConclusão: logo, maria está feliz, \\((P)\\).\n\nA dupla negação pode parecer desnecessária, mas ela tem algumas aplicações na lógica:\n\nSimplifica expressões logicas: remover duplas negações ajuda a simplificar e a normalizar expressões complexas, tornando-as mais fáceis de analisar. Por exemplo, transformar não é verdade que não está chovendo em simplesmente está chovendo.\n\n\\[\\neg \\neg \\text{Está chovendo} \\Leftrightarrow \\text{Está chovendo}\\]\n\nPreserva o valor de verdade: inserir ou remover duplas negações não altera o valor de verdade original de uma proposição. Isso permite transformar proposições em formas logicamente equivalentes.\nAuxilia provas indiretas: em provas por contradição, ou contrapositiva, introduzir uma dupla negação permite assumir o oposto do que se quer provar e derivar uma contradição. Isso, indiretamente, prova a proposição original.\nConecta Lógica Proposicional e de predicados: em Lógica Predicativa, a negação de quantificadores universais e existenciais envolve dupla negação. Por exemplo, a negação de todo \\(x\\) é \\(P\\) é existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\n\n\\[\\neg \\forall x P(x) \\Leftrightarrow \\exists x \\neg P(x)\\]\n\nPermite provar equivalências: uma identidade ou lei importante na lógica é que a dupla negação de uma proposição é logicamente equivalente à proposição original. A regra da dupla negação permite formalmente provar essa equivalência.\n\n\\[\\neg \\neg P \\Leftrightarrow P\\]\n\n\n3.1.1.4 Adição\nA regra da Adição permite adicionar uma disjunção a uma afirmação, resultando em uma nova disjunção verdadeira. Esta regra é útil para introduzir alternativas em nosso raciocínio dedutivo.\n\\[F\\]\n\\[\\begin{aligned}\n&F\\\\\n\\hline\n&F \\vee G\\\\\n\\end{aligned}\\]\n\\[\\begin{aligned}\n&G\\\\\n\\hline\n&F \\vee G\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição: o céu está azul, \\((P)\\);\nConclusão: logo, o céu está azul ou gatos podem voar, \\((P \\lor Q)\\).\n\nA regra da Adição permite introduzir uma disjunção em uma prova ou argumento lógico. Especificamente, ela nos permite inferir uma disjunção \\(P\\vee Q\\)A partir de uma das afirmações disjuntivas (\\(P\\) ou \\(Q\\)) individualmente.\nAlguns usos e aplicações importantes da regra da Adição:\n\nIntroduzir alternativas ou possibilidades em um argumento: por exemplo, dado que João está em casa, podemos concluir que João está em casa OR no trabalho. E expandir este OR o quanto seja necessário para explicitar os lugares em que João está.\nCombinar afirmações em novas disjunções: dadas duas afirmações quaisquer \\(P\\) e \\(Q\\), podemos inferir que \\(P\\) ou \\(Q\\) é verdadeiro.\nCriar casos ou opções exaustivas em uma prova: podemos derivar uma disjunção que cubra todas as possibilidades relevantes. Lembre-se do pobre joão.\nIniciar provas por casos: ao assumir cada disjuntiva separadamente, podemos provar teoremas por casos exaustivos.\nRealizar provas indiretas: ao assumir a negação de uma disjunção, podemos chegar a uma contradição e provar a disjunção original.\n\nA regra da Adição amplia nossas capacidades de prova e abordagem de problemas.\n\n\n3.1.1.5 Modus Tollendo Ponens\nO Modus Tollendo Ponens permite inferir uma disjunção a partir da negação da outra disjunção.\nDada uma disjunção \\(P\\vee Q\\):\n\nSe \\(\\neg P\\), então \\(Q\\)\nSe \\(\\neg Q\\), então \\(P\\)\n\nEsta regra nos ajuda a chegar a conclusões a partir de disjunções, por exclusão de alternativas.\n\\[P \\vee Q\\]\n\\[\\begin{aligned}\n&\\neg P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\\]\n\\[\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: ou o céu está azul ou a grama é roxa;\nProposição 2: a grama não é roxa;\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações do Modus Tollendo Ponens:\n\nDerivar ações a partir de regras disjuntivas. Por exemplo:\n\nProposição: ou João vai à praia, \\(P\\) ou João vai ao cinema, \\(c\\);\nProposição: João não vai ao cinema, \\(\\neg C\\);\nConclusão: logo, João vai à praia.\n\n\n\\[P \\vee C\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&P\n\\end{aligned}\\]\n\nSimplificar casos em provas por exaustão. Por exemplo:\n\nProposição: o número é par, \\(P\\), ou ímpar, \\(I\\);\nProposição: o número não é ímpar, \\(\\neg P\\);\nConclusão: logo, o número é par.\n\n\n\\[P \\vee I\\]\n\\[\\begin{aligned}\n&\\neg I\\\\\n\\hline\n&P\n\\end{aligned}\\]\n\nEliminar opções em raciocínio dedutivo. Por exemplo:\n\nProposição: ou João estava em casa, \\(c\\), ou João estava no trabalho, \\(t\\);\nProposição: João não estava em casa;\nConclusão: logo, João estava no trabalho.\n\n\n\\[C \\vee T\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&T\n\\end{aligned}\\]\n\nFazer prova indireta da disjunção. Por exemplo:\n\nProposição: 1 é par, \\(1P\\), ou 1 é ímpar, \\(1I\\);\nProposição: 1 não é par;\nConclusão: logo, 1 é ímpar.\n\n\n\\[1P \\vee 1I\\]\n\\[\\begin{aligned}\n&\\neg 1P\\\\\n\\hline\n&1I\n\\end{aligned}\\]\n\n\n3.1.1.6 Adjunção\nA regra da Adjunção permite combinar duas afirmações em uma conjunção. Esta regra é útil para juntar duas premissas em uma única afirmação conjuntiva.\n\\[F\\]\n\\[G\\]\n\\[\\begin{aligned}\n&F\\\\\n&G\\\\\n\\hline\n&F \\land G\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nproposição 1: o céu está azul;\nproposição 2: os pássaros estão cantando;\nConclusão: logo, o céu está azul e os pássaros estão cantando.\n\nAlgumas aplicações da Adjunção:\n\nCombinar proposições relacionadas em argumentos. Por exemplo:\n\nProposição: o céu está nublado, \\(n\\);\nProposição: está ventando, \\(V\\);\nConclusão: logo, o céu está nublado e está ventando.\n\n\n\\[\\begin{aligned}\n&N\\\\\n&V\\\\\n\\hline\n&N \\land V\n\\end{aligned}\\]\n\nCriar declarações conjuntivas complexas. Por exemplo:\n\nProposição: 1 é número natural, \\(n1\\);\nProposição: 2 é número natural \\(n2\\);\nConclusão: logo, 1 é número natural e 2 é número natural.\n\n\n\\[\\begin{aligned}\n&N1\\\\\n&N2\\\\\n\\hline\n&N1 \\land N2\n\\end{aligned}\\]\n\nDerivar novas informações da interseção de fatos conhecidos. Por exemplo:\n\nProposição: o gato está em cima do tapete, \\(gT\\);\nProposição: o rato está em cima do tapete, \\(rT\\);\nConclusão: logo, o gato e o rato estão em cima do tapete.\n\n\n\\[\\begin{aligned}\n&GT\\\\\n&RT\\\\\n\\hline\n&G_T \\land R_T\n\\end{aligned}\\]\n\nFazer deduções lógicas baseadas em múltiplas proposições. Por exemplo:\n\nProposição: 2 + 2 = 4;\nProposição: 4 x 4 = 16;\nConclusão: logo, \\((2 + 2 = 4) ∧ (4 × 4 = 16)\\).\n\n\n\\[\\begin{aligned}\n&(2 + 2 = 4)\\\\\n&(4 \\times 4 = 16)\\\\\n\\hline\n&(2 + 2 = 4) \\land (4 \\times 4 = 16)\n\\end{aligned}\\]\n\n\n3.1.1.7 Simplificação\nA regra da Simplificação permite inferir uma conjunção a partir de uma conjunção composta. Esta regra nos permite derivar ambos os elementos de uma conjunção, a partir da afirmação conjuntiva.\n\\[F \\land G\\]\n\\[\\begin{aligned}\n&F \\land G\\\\\n\\hline\n&F\\\\\n\\end{aligned}\\]\n\\[\\begin{aligned}\n&F \\land G\\\\\n\\hline\n&G\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nproposição: o céu está azul e os pássaros estão cantando;\nConclusão: logo, o céu está azul. E os pássaros estão cantando.\n\nAlgumas aplicações da Simplificação:\n\nDerivar elementos de conjunções complexas. Por exemplo:\n\nProposição: hoje está chovendo, \\(c\\), e fazendo frio, \\(F\\);\nConclusão: logo, está chovendo.\n\n\n\\[\\begin{aligned}\n&C \\land F\\\\\n\\hline\n&C\n\\end{aligned}\\]\n\nSimplificar provas baseadas em conjunções. Por exemplo:\n\nProposição: 2 é par, \\(2P\\), e 3 é ímpar, \\(3P\\);\nConclusão: logo, 3 é ímpar, \\(3I\\).\n\n\n\\[\\begin{aligned}\n&2P \\land 3I\\\\\n\\hline\n&3I\n\\end{aligned}\\]\n\nInferir detalhes específicos de declarações complexas. Por exemplo:\n\nProposição: o gato está dormindo, \\(d\\), e ronronando, \\(R\\);\nConclusão: logo, o gato está ronronando.\n\n\n\\[\\begin{aligned}\n&D \\land R\\\\\n\\hline\n&R\n\\end{aligned}\\]\n\nDerivar informações de premissas conjuntivas. Por exemplo:\n\nProposição: está chovendo, \\(J\\), e o jogo foi cancelado, \\(c\\);\nConclusão: logo, o jogo foi cancelado.\n\n\n\\[\\begin{aligned}\n&C \\land J\\\\\n\\hline\n&J\n\\end{aligned}\\]\n\n\n3.1.1.8 Bicondicionalidade\nA regra da Bicondicionalidade permite inferir uma bicondicional a partir de duas condicionais. Esta regra nos permite combinar duas implicações para obter uma afirmação de equivalência lógica.\n\\[F \\rightarrow G\\]\n\\[G \\rightarrow F\\]\n\\[\\begin{aligned}\n&G \\rightarrow F\\\\\n\\hline\n&F \\leftrightarrow G\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nproposição 1: se está chovendo, então a rua está molhada;\nproposição 2: se a rua está molhada, então está chovendo;\nConclusão: logo, está chovendo se e somente se a rua está molhada.\n\nAlgumas aplicações da Bicondicionalidade:\n\nInferir equivalências lógicas a partir de implicações bidirecionais. Por exemplo:\n\nProposição: se chove, \\(c\\) então a rua fica molhada, \\(m\\);\nProposição: se a rua fica molhada, então chove;\nConclusão: logo, chove se e somente se a rua fica molhada.\n\n\n\\[C \\rightarrow M\\]\n\\[\\begin{aligned}\n&M \\rightarrow C\\\\\n\\hline\n&C \\leftrightarrow M\n\\end{aligned}\\]\n\nSimplificar relações recíprocas. Por exemplo:\n\nProposição: se um número é múltiplo de 2, \\(M2\\) então é par, \\(P\\);\nProposição: se um número é par, então é múltiplo de 2;\nConclusão: logo, um número é par se e somente se é múltiplo de 2.\n\n\n\\[P \\rightarrow M2\\]\n\\[\\begin{aligned}\n&M2 \\rightarrow P\\\\\n\\hline\n&P \\leftrightarrow M2\n\\end{aligned}\\]\n\nEstabelecer equivalências matemáticas. Por exemplo:\n\nProposição: se \\(x^2 = 25\\), então \\(x = 5\\);\nProposição: se \\(x = 5\\), então \\(x^2 = 25\\);\nConclusão: logo, \\(x^2 = 25\\) se e somente se \\(x = 5\\).\n\n\n\\[(x^2 = 25) \\rightarrow (x = 5)\\]\n\\[\\begin{aligned}\n&(x = 5) \\rightarrow (x^2 = 25)\\\\\n\\hline\n&(x^2 = 25) \\leftrightarrow (x = 5)\n\\end{aligned}\\]\n\nProvar relações de definição mútua. Por exemplo:\n\nProposição: se figura é um quadrado, \\(Q\\), então tem 4 lados iguais, \\(4L\\);\nProposição: se figura tem 4 lados iguais, é um quadrado;\nConclusão: logo, figura é quadrado se e somente se tem 4 lados iguais.\n\n\n\\[Q \\rightarrow 4L\\]\n\\[\\begin{aligned}\n&4L \\rightarrow Q\\\\\n\\hline\n&Q \\leftrightarrow 4L\n\\end{aligned}\\]\n\n\n3.1.1.9 Equivalência\nA regra da Equivalência permite inferir uma afirmação ou sua negação a partir de uma bicondicional. Esta regra nos permite aplicar bicondicionais para derivar novas afirmações baseadas nas equivalências lógicas.\n\\[F \\leftrightarrow G\\]\n\\[\\begin{aligned}\n&F\\\\\n\\hline\n&G\\\\\n\\end{aligned}\\]\n\\[F \\leftrightarrow G\\]\n\\[\\begin{aligned}\n&G\\\\\n\\hline\n&F\\\\\n\\end{aligned}\\]\n\\[F \\leftrightarrow G\\]\n\\[\\begin{aligned}\n&\\neg F\\\\\n\\hline\n&\\neg G\\\\\n\\end{aligned}\\]\n\\[F \\leftrightarrow G\\]\n\\[\\begin{aligned}\n&\\neg G\\\\\n\\hline\n&\\neg F\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nproposição 1: está chovendo se e somente se a rua está molhada;\nproposição 2: está chovendo;\nConclusão: logo, a rua está molhada.\n\nAlgumas aplicações da Equivalência:\n\nInferir fatos de equivalências estabelecidas. Por exemplo:\n\nProposição: o número é par, \\(P\\) se e somente se for divisível por 2, \\(d2\\);\nProposição: 156 é divisível por 2;\nConclusão: logo, 156 é par.\n\n\\[P \\leftrightarrow D2\\]\n\\[\\begin{aligned}\n&D2(156)\\\\\n\\hline\n&P(156)\n\\end{aligned}\\]\nDerivar negações de equivalências. Por exemplo:\n\nProposição: \\(x\\) é negativo se e somente se \\(x &lt; 0\\);\nProposição: \\(x\\) não é negativo;\nConclusão: logo, \\(x\\) não é menor que \\(0\\).\n\n\\[ N \\leftrightarrow (x &lt; 0)\\]\n\\[\\begin{aligned}\n&\\neg N\\\\\n\\hline\n&\\neg (x &lt; 0)\n\\end{aligned}\\]\nFazer deduções baseadas em definições. Por exemplo:\n\nProposição: número ímpar é definido como não divisível, \\(nD2\\), por \\(2\\);\nProposição: \\(9\\) não é divisível por \\(2\\);\nConclusão: logo, \\(9\\) é ímpar.\n\n\\[I \\leftrightarrow \\neg ND2\\]\n\\[\\begin{aligned}\n&\\neg D_2(9)\\\\\n\\hline\n&I(9)\n\\end{aligned}\\]\n\n\n\n\n\n\n\n\n\nRegra\nDescrição\nFórmula\n\n\n\n\nModus Ponens\nSe \\(P \\rightarrow Q\\) e \\(P\\) são verdadeiros, então \\(Q\\) também é verdadeiro.\n\\(\\frac{P, P \\rightarrow Q}{Q}\\)\n\n\nModus Tollens\nSe \\(P \\rightarrow Q\\) e \\(\\neg Q\\) são verdadeiros, então \\(\\neg P\\) também é verdadeiro.\n\\(\\frac{\\neg Q, P \\rightarrow Q}{\\neg P}\\)\n\n\nDupla Negação\nA negação de uma negação é equivalente à afirmação original.\n\\(\\frac{\\neg \\neg P}{P}\\)\n\n\nAdição\nSe \\(P\\) é verdadeiro, então \\(P \\vee Q\\) também é verdadeiro.\n\\(\\frac{P}{P \\vee Q}\\)\n\n\nAdjunção\nSe \\(P\\) e \\(Q\\) são verdadeiros, então \\(P \\wedge Q\\) é verdadeiro.\n\\(\\frac{P, Q}{P \\wedge Q}\\)\n\n\nSimplificação\nSe \\(P \\wedge Q\\) é verdadeiro, então \\(P\\) (ou \\(Q\\)) é verdadeiro.\n\\(\\frac{P \\wedge Q}{P}\\)\n\n\nBicondicionalidade\nSe \\(P \\leftrightarrow Q\\), então \\(P \\rightarrow Q\\) e \\(Q \\rightarrow P\\) são verdadeiros.\n\\(\\frac{P \\leftrightarrow Q}{P \\rightarrow Q, Q \\rightarrow P}\\)\n\n\n\nTabela 4 - Resumo dos métodos de inferência.{: class=“legend”}\n\n\n\n3.1.2 Classificação das Fórmulas Proposicionais\nPodemos classificar fórmulas proposicionais de acordo com suas propriedades semânticas, analisando suas tabelas-verdade. Seja \\(R\\) uma fórmula proposicional:\n\n\\(R\\) é satisfatível se sua Tabela Verdade contém pelo menos uma linha verdadeira. Considere:\\(P\\wedge Q\\).\n\n\\[\\begin{array}{|c|c|c|}\n\\hline\nP & Q & P \\land Q \\\\\n\\hline\nF & F & F \\\\\n\\hline\nF & T & F \\\\\n\\hline\nT & F & F \\\\\n\\hline\nT & T & T \\\\\n\\hline\n\\end{array}\\]\n\n\\(R\\) é insatisfatível se sua Tabela Verdade contém apenas linhas falsas. Exemplo:\\(P\\wedge \\neg P\\).\n\\(R\\) é falsificável se sua Tabela Verdade contém pelo menos uma linha falsa. Exemplo:\\(P\\wedge Q\\).\n\\(R\\) é válida se sua Tabela Verdade contém apenas linhas verdadeiras. Exemplo:\\(P\\vee \\neg P\\).\n\nNote que:\n\nSe \\(A\\) é válida, então \\(A\\) é satisfatível.\nSe \\(A\\) é insatisfatível, então \\(A\\) é falsificável.\n\nFórmulas válidas são importantes na lógica proposicional, representando argumentos sempre verdadeiros independentemente da valoração de suas variáveis proposicionais atômicas. Na verdade, esta classificação será importante para:\n\nAnálise de Argumentos: Se uma argumentação lógica pode ser representada por uma fórmula que é insatisfatível, então sabemos que o argumento é inválido ou inconsistente. Isso é frequentemente usado em lógica e filosofia para analisar a validade dos argumentos.\nProva de Teoremas: Na prova de teoremas, essas classificações são úteis. Quando estamos tentando provar que uma fórmula é uma tautologia, podemos usar essas classificações para simplificar a tarefa. Podemos mostrar que a negação da fórmula é insatisfatível, mostrando que a fórmula original é uma tautologia.\nSimplificação de Fórmulas: Na simplificação de fórmulas, essas classificações também são úteis. Se temos uma fórmula complexa e podemos mostrar que uma parte dela é uma tautologia, podemos simplificar a fórmula removendo essa parte. Similarmente, se uma parte da fórmula é uma contradição (ou seja, é insatisfatível), sabemos que a fórmula inteira é insatisfatível.\nConstrução de Argumentos: Na construção de argumentos, estas classificações são úteis para garantir que os argumentos são válidos. Se estamos construindo um argumento e podemos mostrar que ele é representado por uma fórmula que é satisfatível (mas não uma tautologia), sabemos que existem algumas circunstâncias em que o argumento é válido e outras em que não é.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lógica de Primeira Ordem</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html",
    "title": "4  Provas",
    "section": "",
    "text": "4.0.1 Contrapositivas e Recíprocas\nAs implicações são um problema, do ponto de vista da matemática. Sentenças do tipo se…então induzem uma conclusão. Provar estas sentenças é uma preocupação constante da matemática. Dada uma implicação, existem duas fórmulas relacionadas que ocorrem com tanta frequência que possuem nomes especiais: contrapositivas e recíprocas. Antes de mergulharmos em contrapositivas, precisamos visitar alguns portos.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Provas</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "title": "4  Provas",
    "section": "4.1 Análise de Argumentos Lógicos em Textos do Cotidiano",
    "text": "4.1 Análise de Argumentos Lógicos em Textos do Cotidiano\nUma das coisas mais importantes que a amável leitora irá aprender neste documento é que a lógica não é apenas uma disciplina acadêmica, mas uma ferramenta poderosa para analisar e compreender argumentos em textos do cotidiano. A lógica nos ajuda a identificar premissas e conclusões, avaliar a validade de argumentos e entender como as ideias estão interconectadas. A lógica é útil e pode ser a diferença entre um argumento persuasivo e um argumento falacioso. Além disso, o uso da lógica para entender textos do cotidiano criará as estruturas cognitivas necessários para a construção de soluções computacionais para os problemas mais complexos da atualidade.\nA análise de argumentos lógicos em textos do cotidiano envolve a identificação de premissas e conclusões, bem como a formalização dessas relações em lógica proposicional ou lógica de predicados.\nDeste ponto tem diante, caberá a esforçada leitora, aplicar os conceitos aprendidos neste documento para analisar textos de livros, notícias, especificações de sistemas e outros documentos. Comece vendo os textos de exemplo a seguir.\n\n4.1.1 Exemplo 1: Avanço Científico na Medicina (2022)\n“Em 2022, pesquisadores descobriram que a vacina contra a malária aprovada pela Organização Mundial da Saúde pode ajudar a salvar centenas de milhares de vidas por ano. É também a primeira vacina do mundo para uma infecção parasitária. A malária mata mais de 600.000 pessoas anualmente, a maioria crianças menores de cinco anos.”\n\n4.1.1.1 Premissas e Conclusão\nPremissas:\n\nA malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\nA vacina contra a malária foi aprovada pela Organização Mundial da Saúde;\nA vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária.\n\nConclusão:\n\nA vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\n\n\n4.1.1.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\n\\(Q\\): A vacina contra a malária foi aprovada pela OMS;\n\\(R\\): A vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária;\n\\(S\\): A vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\nEstrutura do argumento: \\((P \\land Q \\land R) \\rightarrow S\\)\nLógica de Predicados:\n\n\\(m\\): malária;\n\\(v\\): vacina contra a malária;\n\\(Mata(x, y)\\): x mata y pessoas anualmente;\n\\(MajoriaCriancas(x)\\): a maioria das vítimas de x são crianças menores de cinco anos;\n\\(Aprovada(x)\\): x foi aprovada pela OMS;\n\\(Primeira(x)\\): x é a primeira vacina para infecção parasitária;\n\\(PodeSalvar(x, y)\\): x pode salvar y vidas por ano.\n\nFormalização:\n\n\\(Mata(m, 600000) \\land MajoriaCriancas(m)\\);\n\\(Aprovada(v)\\);\n\\(Primeira(v)\\);\n\\([Mata(m, 600000) \\land MajoriaCriancas(m) \\land Aprovada(v) \\land Primeira(v)] \\rightarrow PodeSalvar(v, \\text{\"centenas de milhares\"})\\).\n\n\n\n4.1.1.3 Análise da Validade\nEste argumento não segue uma forma lógica estritamente válida. A relação entre as premissas e a conclusão depende de conhecimentos médicos implícitos.\nEstrutura implícita:\n\nSe uma doença mata muitas pessoas e existe uma vacina aprovada contra essa doença, então essa vacina pode salvar muitas vidas;\nA malária mata muitas pessoas;\nExiste uma vacina aprovada contra a malária;\nLogo, a vacina contra a malária pode salvar muitas vidas.\n\nEsta estrutura se aproxima de um modus ponens, mas depende de uma premissa implícita.\n\n\n4.1.1.4 Análise da Solidez\nAs premissas são verificáveis e consideradas verdadeiras:\n\nA mortalidade por malária é confirmada por dados epidemiológicos da OMS;\nA aprovação da vacina pela OMS é um fato verificável;\nSer a primeira vacina para infecção parasitária é historicamente verificável.\n\nA conclusão é razoável no contexto médico, mas sua solidez completa dependeria de dados específicos sobre a eficácia da vacina.\n\n\n\n4.1.2 Exemplo 2: Inovação Tecnológica Nuclear (2023)\n“O campo da fusão nuclear teve um grande avanço em 2023. A fusão nuclear é uma reação química que produz uma grande quantidade de calor que pode ser usada para gerar energia. É o mesmo processo que alimenta o sol. A reação química é produzida por dois núcleos atômicos leves que se combinam e formam um único núcleo atômico leve mais pesado. Isso produz uma grande quantidade de energia.”\n\n4.1.2.1 Premissas e Conclusão\nPremissas:\n\nA fusão nuclear é uma reação que ocorre quando dois núcleos atômicos leves se combinam formando um único núcleo mais pesado;\nEsta reação produz grande quantidade de calor;\nO calor pode ser usado para gerar energia;\nA fusão nuclear é o mesmo processo que alimenta o sol.\n\nConclusão:\n\nO campo da fusão nuclear teve um grande avanço em 2023.\n\n\n\n4.1.2.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A fusão nuclear é uma reação em que núcleos leves se combinam formando um núcleo mais pesado;\n\\(Q\\): A fusão nuclear produz grande quantidade de calor;\n\\(R\\): O calor pode ser usado para gerar energia;\n\\(S\\): A fusão nuclear é o mesmo processo que alimenta o sol;\n\\(T\\): O campo da fusão nuclear teve um grande avanço em 2023.\n\nEstrutura do argumento: \\((P \\land Q \\land R \\land S) \\rightarrow T\\)\nLógica de Predicados:\n\n\\(FusaoNuclear(x)\\): \\(x\\) é um processo de fusão nuclear;\n\\(Reacao(x, y, z)\\): \\(x\\) é uma reação em que \\(y\\) se combina formando \\(z\\);\n\\(Produz(x, y)\\): \\(x\\) produz \\(y\\);\n\\(PodeGerarEnergia(x)\\): \\(x\\) pode ser usado para gerar energia;\n\\(AlimentaSol(x)\\): \\(x\\) é o processo que alimenta o sol;\n\\(TeveAvanco(x, y, z)\\): o campo \\(x\\) teve um avanço de grau \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Reacao(x, \\text{\"núcleos leves\"}, \\text{\"núcleo mais pesado\"})]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Produz(x, \\text{\"grande quantidade de calor\"})]\\);\n\\(\\forall x [Produz(x, \\text{\"grande quantidade de calor\"}) \\rightarrow PodeGerarEnergia(x)]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow AlimentaSol(x)]\\);\n\\(TeveAvanco(\\text{\"campo da fusão nuclear\"}, \\text{\"grande\"}, 2023)\\).\n\n\n\n4.1.2.3 Análise da Validade\nEste argumento apresenta uma estrutura incomum, pois a conclusão não é derivada logicamente das premissas apresentadas. As premissas descrevem o que é a fusão nuclear e suas características, mas não estabelecem uma relação lógica com o avanço mencionado.\nSob análise de dedução natural, o argumento não é válido, pois a conclusão não é uma consequência lógica das premissas fornecidas.\n\n\n4.1.2.4 Análise da Solidez\nComo o argumento não é formalmente válido, não pode ser considerado sólido. Entretanto, suas premissas são majoritariamente verdadeiras:\n\nA definição de fusão nuclear como combinação de núcleos leves é cientificamente precisa;\nA produção de calor e seu potencial energético são verdadeiros;\nA fusão nuclear realmente alimenta o sol.\n\nHá um erro conceitual no texto: a fusão nuclear é descrita como “reação química”, quando na verdade é uma reação nuclear, comprometendo a precisão científica do texto.\n\n\n\n4.1.3 Exemplo 3: Economia Global (2023)\n“As economias avançadas devem desacelerar de 2,6% em 2022 para 1,5% em 2023 e 1,4% em 2024, à medida que o aperto da política começa a surtir efeito. A inflação global deverá diminuir constantemente, de 8,7% em 2022 para 6,9% em 2023 e 5,8% em 2024, devido a uma política monetária mais rígida auxiliada por preços mais baixos das commodities internacionais.”\n\n4.1.3.1 Premissas e Conclusão\nPremissas:\n\nO aperto da política (monetária) está começando a surtir efeito;\nEstá sendo implementada uma política monetária mais rígida;\nOs preços das commodities internacionais estão mais baixos.\n\nConclusões:\n\nAs economias avançadas devem desacelerar de \\(2,6\\%\\) em 2022 para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\nA inflação global deverá diminuir constantemente, de \\(8,7\\%\\) em 2022 para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\n\n\n4.1.3.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): O aperto da política monetária está surtindo efeito;\n\\(Q\\): Está sendo implementada uma política monetária mais rígida;\n\\(R\\): Os preços das commodities internacionais estão mais baixos;\n\\(S\\): As economias avançadas desacelerarão para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\n\\(T\\): A inflação global diminuirá para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\nEstrutura do argumento: \\((P \\land Q \\land R) \\rightarrow (S \\land T)\\)\nLógica de Predicados:\n\n\\(ApertoSurteEfeito(x)\\): o aperto da política monetária \\(x\\) está surtindo efeito;\n\\(PoliticaRigida(x)\\): \\(x\\) é uma política monetária rígida;\n\\(PrecosBaixos(x)\\): os preços de $\\(x\\) estão baixos;\n\\(Desacelerar(x, y, z)\\): a economia \\(x\\) desacelerará para taxa \\(y\\) no ano \\(z\\);\n\\(DiminuirInflacao(x, y, z)\\): a inflação \\(x\\) diminuirá para taxa \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(ApertoSurteEfeito(\\text{\"política monetária\"})\\);\n\\(PoliticaRigida(\\text{\"política monetária atual\"})\\);\n\\(PrecosBaixos(\\text{\"commodities internacionais\"})\\);\n\\([ApertoSurteEfeito(\\text{\"política monetária\"}) \\land PoliticaRigida(\\text{\"política monetária atual\"})] \\rightarrow Desacelerar(\\text{\"economias avançadas\"}, 1.5\\%, 2023) \\land Desacelerar(\\text{\"economias avançadas\"}, 1.4\\%, 2024)\\);\n\\([PoliticaRigida(\\text{\"política monetária atual\"}) \\land PrecosBaixos(\\text{\"commodities internacionais\"})] \\rightarrow DiminuirInflacao(\\text{\"global\"}, 6.9\\%, 2023) \\land DiminuirInflacao(\\text{\"global\"}, 5.8\\%, 2024)\\).\n\n\n\n4.1.3.3 Análise da Validade\nEste argumento segue uma estrutura causal que pode ser analisada pela forma lógica:\n\nSe \\(X\\) causa \\(Y\\), e \\(X\\) está ocorrendo, então \\(Y\\) ocorrerá;\n\\(X\\) está ocorrendo;\nPortanto, \\(Y\\) ocorrerá.\n\nEsta estrutura segue o padrão de modus ponens, que é uma forma de argumento válida.\n\n\n4.1.3.4 Análise da Solidez\nA validade lógica do argumento foi estabelecida, mas sua solidez depende da veracidade das premissas:\n\nA eficácia do aperto monetário é uma afirmação empírica que requer verificação com dados econômicos;\nA implementação de política monetária mais rígida era geralmente verdadeira no contexto de 2023;\nA afirmação sobre preços mais baixos de commodities depende do período específico e das commodities consideradas.\n\nAs conclusões são previsões específicas cuja solidez dependeria da veracidade das premissas, da robustez dos modelos econômicos e da ausência de fatores externos imprevistos.\nEm economia, relações causais são geralmente probabilísticas, tornando a solidez do argumento contingente a condições específicas.\n\n\n\n4.1.4 Exercício de Análise de Argumentos Lógicos\nObjetivo: aplicar técnicas de lógica proposicional e de predicados para analisar descrições e especificações de sistemas computacionais, traduzindo-as para a linguagem formal e avaliando sua consistência lógica como base para decisões de implementação.\nDescrição: na engenharia de software, especificações e requisitos de sistemas são frequentemente descritos em linguagem natural, o que pode levar a ambiguidades, inconsistências e interpretações equivocadas. A análise lógica formal dessas descrições pode ajudar a identificar tais problemas e proporcionar uma base sólida para o desenvolvimento de soluções computacionais. Nesta tarefa, você atuará como “Arquiteto Lógico de Sistemas” para traduzir especificações em linguagem natural para modelos lógicos formais.\n\n4.1.4.1 Exercício 1: Sistema de Autenticação Biométrica\nFragmento de Texto Original: O sistema de autenticação biométrica deve permitir o acesso a usuários autorizados por meio de reconhecimento facial ou impressão digital. Se um usuário não conseguir autenticar por nenhum dos métodos biométricos, o sistema deve oferecer como alternativa a autenticação por senha. Caso ocorram três tentativas falhas consecutivas por qualquer método, o acesso do usuário deve ser temporariamente bloqueado por 30 minutos por motivos de segurança.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em lógica proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nUsuários autorizados podem se autenticar por reconhecimento facial;\nUsuários autorizados podem se autenticar por impressão digital;\nSe a autenticação biométrica falhar, o usuário pode usar senha;\nTrês tentativas falhas consecutivas levam ao bloqueio temporário;\nO bloqueio temporário dura 30 minutos.\n\nConclusões:\n\nO sistema deve bloquear o acesso após três tentativas falhas consecutivas;\nO sistema deve permitir múltiplos métodos de autenticação.\n\nFormalização\nLógica Proposicional:\n\n\\(A\\): O usuário está autorizado;\n\\(F\\): O usuário autentica com reconhecimento facial;\n\\(D\\): O usuário autentica com impressão digital;\n\\(S\\): O usuário autentica com senha;\n\\(T\\): Ocorreram três tentativas falhas consecutivas;\n\\(B\\): O acesso do usuário está bloqueado temporariamente.\n\nEstrutura do argumento:\n\n\\(A \\rightarrow (F \\lor D \\lor S)\\);\n\\(\\neg(F \\lor D) \\rightarrow S\\);\n\\(T \\rightarrow B\\).\n\nLógica de Predicados:\n\n\\(Usuario(x)\\): \\(x\\) é um usuário;\n\\(Autorizado(x)\\): \\(x\\) é autorizado;\n\\(AutenticaFacial(x)\\): \\(x\\) autentica por reconhecimento facial;\n\\(AutenticaDigital(x)\\): \\(x\\) autentica por impressão digital;\n\\(AutenticaSenha(x)\\): \\(x\\) autentica por senha;\n\\(TentativasFalhas(x, n)\\): \\(x\\) teve \\(n\\) tentativas falhas consecutivas;\n\\(Bloqueado(x, t)\\): \\(x\\) está bloqueado por \\(t\\) minutos.\n\nFormalização:\n\n\\(\\forall x [Autorizado(x) \\rightarrow (AutenticaFacial(x) \\lor AutenticaDigital(x) \\lor AutenticaSenha(x))]\\);\n\\(\\forall x [(Usuario(x) \\land \\neg(AutenticaFacial(x) \\lor AutenticaDigital(x))) \\rightarrow AutenticaSenha(x)]\\);\n\\(\\forall x [TentativasFalhas(x, 3) \\rightarrow Bloqueado(x, 30)]\\).\n\nAnálise da Validade: o argumento é válido em termos de lógica proposicional e de predicados. A estrutura segue formas lógicas válidas:\n\nA primeira relação estabelece uma disjunção inclusiva (OR) de métodos de autenticação disponíveis para usuários autorizados;\nA segunda relação segue a forma \\((P \\land \\neg Q) \\rightarrow R\\), que é válida: se um usuário não consegue autenticar pelos métodos biométricos, então deve poder usar senha;\nA terceira relação segue a forma \\(P \\rightarrow Q\\), um modus ponens: se ocorrerem três tentativas falhas, então o bloqueio é implementado.\n\nAnálise da Solidez:\nAs premissas são razoáveis no contexto de sistemas de autenticação modernos:\n\nA disponibilidade de múltiplos métodos de autenticação aumenta a usabilidade;\nA provisão de métodos alternativos quando os biométricos falham é uma prática comum;\nO bloqueio após múltiplas tentativas falhas é um mecanismo de segurança padrão.\n\nAs conclusões derivadas são sólidas no contexto de sistemas de autenticação e seguem práticas recomendadas de segurança digital.\n\n\n4.1.4.2 Exercício 2: Processamento de Pagamentos Online\nFragmento de Texto Original: O sistema de pagamentos online deve processar transações com cartões de crédito, cartões de débito e carteiras digitais. Quando uma transação é iniciada, o sistema verifica primeiro se há fundos suficientes. Se houver fundos suficientes, o sistema realiza a verificação de segurança. Uma transação só é aprovada se ambas as verificações forem bem-sucedidas. Caso contrário, a transação é rejeitada e o cliente recebe uma notificação com o motivo da falha.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em lógica proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema processa transações com cartões de crédito, cartões de débito e carteiras digitais;\nQuando uma transação é iniciada, o sistema verifica a disponibilidade de fundos;\nSe há fundos suficientes, o sistema realiza verificação de segurança;\nUma transação é aprovada apenas se as verificações de fundos e segurança forem bem-sucedidas;\nTransações rejeitadas geram notificações com o motivo da falha.\n\nConclusão:\n\nSe uma verificação de fundos ou segurança falhar, a transação será rejeitada.\n\nFormalização\nLógica Proposicional:\n\n\\(C\\): A transação é com cartão de crédito;\n\\(D\\): A transação é com cartão de débito;\n\\(W\\): A transação é com carteira digital;\n\\(F\\): Há fundos suficientes;\n\\(S\\): A verificação de segurança é bem-sucedida;\n\\(A\\): A transação é aprovada;\n\\(R\\): A transação é rejeitada;\n\\(N\\): O cliente recebe notificação.\n\nEstrutura do argumento:\n\n\\((C \\lor D \\lor W)\\) (A transação é feita por um dos métodos aceitos);\n\\(F \\rightarrow S\\) (Se há fundos, realiza-se verificação de segurança);\n\\((F \\land S) \\rightarrow A\\) (Se há fundos e a verificação de segurança é bem-sucedida, a transação é aprovada);\n\\(\\neg(F \\land S) \\rightarrow (R \\land N)\\) (Se não há fundos ou a verificação falha, a transação é rejeitada e há notificação).\n\nLógica de Predicados:\n\n\\(Transacao(x)\\): \\(x\\) é uma transação;\n\\(Metodo(x, y)\\): a transação \\(x\\) utiliza o método de pagamento \\(y\\);\n\\(TemFundos(x)\\): a transação \\(x\\) tem fundos suficientes;\n\\(VerificacaoSeguranca(x)\\): a transação \\(x\\) passa na verificação de segurança;\n\\(Aprovada(x)\\): a transação \\(x\\) é aprovada;\n\\(Rejeitada(x)\\): a transação \\(x\\) é rejeitada;\n\\(Notifica(x, y)\\): o sistema notifica o cliente sobre \\(y\\) relacionado à transação \\(x\\).\n\nFormalização:\n\n\\(\\forall x [Transacao(x) \\rightarrow (Metodo(x, \\text{\"crédito\"}) \\lor Metodo(x, \\text{\"débito\"}) \\lor Metodo(x, \\text{\"carteira digital\"}))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (TemFundos(x) \\rightarrow VerificacaoSeguranca(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow ((TemFundos(x) \\land VerificacaoSeguranca(x)) \\rightarrow Aprovada(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (\\neg(TemFundos(x) \\land VerificacaoSeguranca(x)) \\rightarrow (Rejeitada(x) \\land \\exists y Notifica(x, y)))]\\).\n\nAnálise da Validade:\nO argumento é válido logicamente. As relações causais seguem formas lógicas consistentes:\n\nA primeira premissa estabelece os métodos de pagamento aceitos, formando uma disjunção inclusiva;\nA relação entre verificação de fundos e verificação de segurança segue um fluxo condicional válido;\nA aprovação da transação requer a conjunção (AND) de condições, seguindo o padrão \\((P \\land Q) \\rightarrow R\\);\nA rejeição da transação ocorre pela negação da conjunção, usando a lei de De Morgan: \\(\\neg(P \\land Q) \\equiv \\neg P \\lor \\neg Q\\);\n\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de processamento de pagamentos:\n\nOs métodos de pagamento mencionados são comuns em sistemas reais;\nA verificação de fundos antes de processamento é uma prática padrão;\nAs verificações de segurança são essenciais em transações financeiras;\nA notificação em caso de falha é uma boa prática para experiência do usuário.\n\nA conclusão derivada é sólida e consistente com o funcionamento esperado de um sistema de pagamentos seguro e funcional.\n\n\n4.1.4.3 Exercício 3: Sistema de Gerenciamento de Estoque\nFragmento de Texto Original: “O sistema de gerenciamento de estoque deve monitorar continuamente os níveis de produtos. Quando o estoque de um produto cai abaixo do limite mínimo configurado, o sistema deve gerar automaticamente uma ordem de reabastecimento. Se o produto estiver marcado como ‘crítico’, a ordem deve ser enviada com prioridade alta. Caso contrário, a ordem segue o fluxo padrão. Qualquer produto que não tenha movimento de venda por mais de 90 dias deve ser marcado para revisão de demanda.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em lógica proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema monitora continuamente os níveis de estoque dos produtos;\nExiste um limite mínimo configurado para cada produto;\nOrdens de reabastecimento são geradas quando o estoque cai abaixo do limite mínimo;\nProdutos podem ser marcados como ‘críticos’;\nProdutos críticos recebem prioridade alta no reabastecimento;\nProdutos sem movimento de venda por mais de 90 dias são marcados para revisão.\n\nConclusões:\n\nSe o estoque de um produto cai abaixo do limite e o produto é crítico, uma ordem de reabastecimento com prioridade alta é gerada;\nSe o estoque de um produto cai abaixo do limite e o produto não é crítico, uma ordem de reabastecimento padrão é gerada;\nSe um produto não tem vendas por mais de 90 dias, ele deve ser revisado.\n\nFormalização\nLógica Proposicional:\n\n\\(M\\): O sistema monitora os níveis de estoque;\n\\(B\\): O estoque está abaixo do limite mínimo;\n\\(O\\): Uma ordem de reabastecimento é gerada;\n\\(C\\): O produto é marcado como crítico;\n\\(P\\): A ordem é enviada com prioridade alta;\n\\(F\\): A ordem segue fluxo padrão;\n\\(N\\): O produto não tem movimento de venda por mais de 90 dias;\n\\(R\\): O produto é marcado para revisão de demanda.\n\nEstrutura do argumento:\n\n\\(M\\);\n\\(B \\rightarrow O\\);\n\\((B \\land C) \\rightarrow (O \\land P)\\);\n\\((B \\land \\neg C) \\rightarrow (O \\land F)\\);\n\\(N \\rightarrow R\\).\n\nLógica de Predicados:\n\n\\(Produto(x)\\): \\(x\\) é um produto;\n\\(Monitora(x)\\): o sistema monitora o estoque de \\(x\\);\n\\(AbaixoLimite(x)\\): o estoque de \\(x\\) está abaixo do limite mínimo;\n\\(Critico(x)\\): \\(x\\) é marcado como crítico;\n\\(GeraOrdem(x, y)\\): o sistema gera uma ordem de reabastecimento para \\(x\\) com prioridade \\(y\\);\n\\(SemVendas(x, d)\\): \\(x\\) não tem vendas por \\(d\\) dias;\n\\(MarcarRevisao(x)\\): \\(x\\) é marcado para revisão de demanda.\n\nFormalização:\n\n\\(\\forall x [Produto(x) \\rightarrow Monitora(x)]\\);\n\\(\\forall x [Produto(x) \\land AbaixoLimite(x) \\rightarrow \\exists y \\, GeraOrdem(x, y)]\\);\n\\(\\forall x [Produto(x) \\land AbaixoLimite(x) \\land Critico(x) \\rightarrow GeraOrdem(x, \\text{\"alta\"})]\\);\n\\(\\forall x [Produto(x) \\land AbaixoLimite(x) \\land \\neg Critico(x) \\rightarrow GeraOrdem(x, \\text{\"normal\"})]\\);\n\\(\\forall x [Produto(x) \\land SemVendas(x, 90) \\rightarrow MarcarRevisao(x)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura segue padrões lógicos consistentes:\n\nA relação entre níveis de estoque e geração de ordens segue um modus ponens;\nA distinção entre produtos críticos e não críticos usa corretamente a conjunção e a negação;\nA condição para revisão de demanda segue uma implicação simples.\n\nAs regras de negócio são representadas por condicionais bem formados, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de gerenciamento de estoque:\n\nO monitoramento contínuo de estoque é uma funcionalidade essencial desses sistemas;\nO conceito de limite mínimo para reabastecimento é uma prática comum;\nA priorização de produtos críticos é uma estratégia logística válida;\nA revisão de produtos sem movimentação é uma prática de otimização de estoque reconhecida.\n\nAs conclusões derivadas são sólidas e refletem procedimentos operacionais padrão em gerenciamento de estoque e logística.\n\n\n\n4.1.5 Sistema de Recomendação de Conteúdo\n“O sistema de recomendação deve analisar o histórico de visualizações, preferências explícitas e comportamento de navegação de cada usuário. Com base nesses dados, o sistema calcula um score de relevância para cada item de conteúdo disponível. Itens com score acima de 0,7 são recomendados ao usuário. No entanto, se o usuário já visualizou um item nos últimos 30 dias, este não deve ser recomendado novamente, independentemente do score. Adicionalmente, se o usuário deu um feedback negativo a um conteúdo similar, o score desse tipo de conteúdo deve ser reduzido em 0,3 pontos.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em lógica proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas: 1. O sistema analisa o histórico de visualizações, preferências explícitas e comportamento de navegação. 2. Um score de relevância é calculado para cada item de conteúdo. 3. Itens com score acima de 0,7 são recomendados. 4. Itens visualizados nos últimos 30 dias não são recomendados, independentemente do score. 5. Feedback negativo a conteúdo similar reduz o score em 0,3 pontos.\nConclusões: - Um item será recomendado se seu score for maior que 0,7 E não tiver sido visualizado nos últimos 30 dias. - O feedback negativo do usuário influencia o cálculo do score para itens similares.\n\n\n4.1.6 Formalização Lógica\nLógica Proposicional: - \\(A\\): O sistema analisa dados do usuário. - \\(C\\): O sistema calcula scores de relevância. - \\(S\\): O item tem score acima de 0,7. - \\(V\\): O item foi visualizado nos últimos 30 dias. - \\(R\\): O item é recomendado ao usuário. - \\(F\\): O usuário deu feedback negativo a conteúdo similar. - \\(D\\): O score é reduzido em 0,3 pontos.\nEstrutura do argumento: 1. \\(A \\rightarrow C\\) 2. \\((S \\land \\neg V) \\rightarrow R\\) 3. \\(V \\rightarrow \\neg R\\) 4. \\(F \\rightarrow D\\)\nLógica de Predicados: - \\(Usuario(u)\\): u é um usuário - \\(Item(i)\\): i é um item de conteúdo - \\(AnalisaDados(u)\\): o sistema analisa dados do usuário u - \\(Score(i, s)\\): o item i tem score s - \\(Visualizado(u, i, d)\\): o usuário u visualizou o item i nos últimos d dias - \\(Recomendado(u, i)\\): o item i é recomendado ao usuário u - \\(FeedbackNegativo(u, t)\\): o usuário u deu feedback negativo ao tipo de conteúdo t - \\(Similar(i, t)\\): o item i é similar ao tipo de conteúdo t - \\(ReducaoScore(i, v)\\): o score do item i é reduzido em v pontos\nFormalização:\n\n\\(\\forall u [Usuario(u) \\rightarrow AnalisaDados(u)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\land Item(i) \\land Score(i, s) \\land s &gt; 0.7 \\land \\neg Visualizado(u, i, 30) \\rightarrow Recomendado(u, i)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\land Item(i) \\land Visualizado(u, i, 30) \\rightarrow \\neg Recomendado(u, i)]\\);\n\\(\\forall u \\forall i \\forall t [Usuario(u) \\land Item(i) \\land Similar(i, t) \\land FeedbackNegativo(u, t) \\rightarrow ReducaoScore(i, 0.3)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. As regras de recomendação seguem formas lógicas bem definidas:\n\nA relação entre análise de dados e cálculo de scores é uma implicação simples;\nA condição para recomendação usa corretamente a conjunção entre score alto e não visualização recente;\nA exclusão de itens já visualizados é uma implicação direta;\nA redução de score baseada em feedback é uma relação causal válida.\n\nA estrutura lógica representa adequadamente as regras condicionais do sistema de recomendação.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de recomendação modernos:\n\nA utilização de histórico, preferências e comportamento de navegação é uma prática padrão;\nO uso de scores de relevância é uma abordagem quantitativa comum;\nA prevenção de recomendações repetitivas é uma boa prática de experiência do usuário;\nA consideração de feedback negativo reflete sistemas adaptativos reais.\n\nAs conclusões derivadas são sólidas e representam um sistema de recomendação funcional que equilibra relevância, novidade e preferências do usuário.\n\n4.1.6.1 Exercício 5: Sistema de Detecção de Fraudes\nFragmento Texto Original: “O sistema de detecção de fraudes deve analisar cada transação em tempo real. Uma transação é marcada como suspeita se atender a pelo menos um dos seguintes critérios: valor acima do padrão histórico do cliente, localização geográfica incomum, ou múltiplas tentativas em curto período de tempo. Se dois ou mais critérios forem atendidos simultaneamente, a transação é automaticamente bloqueada e enviada para revisão manual. Caso contrário, se apenas um critério for atendido, o cliente recebe uma notificação de confirmação. Se o cliente não confirmar em 5 minutos, a transação é bloqueada preventivamente.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em lógica proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema analisa cada transação em tempo real;\nCritérios de suspeita: valor acima do padrão, localização incomum, múltiplas tentativas;\nUma transação é suspeita se atende a pelo menos um dos critérios;\nUma transação é automaticamente bloqueada se atende a dois ou mais critérios;\nSe apenas um critério for atendido, o cliente recebe notificação para confirmação;\nSe não houver confirmação em 5 minutos, a transação é bloqueada.\n\nConclusões:\n\nSe múltiplos critérios de suspeita são atendidos, a transação é bloqueada sem intervenção do cliente;\nSe um único critério é atendido, a transação depende de confirmação do cliente;\nToda transação suspeita é ou bloqueada automaticamente ou requer confirmação.\n\nFormalização\nLógica Proposicional:\n\n\\(R\\): O sistema analisa transações em tempo real;\n\\(V\\): A transação tem valor acima do padrão histórico;\n\\(L\\): A transação ocorre em localização geográfica incomum;\n\\(M\\): Há múltiplas tentativas em curto período;\n\\(S\\): A transação é marcada como suspeita;\n\\(B\\): A transação é bloqueada automaticamente;\n\\(N\\): O cliente recebe notificação de confirmação;\n\\(C\\): O cliente confirma a transação em 5 minutos;\n\\(P\\): A transação é bloqueada preventivamente.\n\nEstrutura do argumento:\n\n\\((V \\lor L \\lor M) \\rightarrow S\\);\n\\([(V \\land L) \\lor (V \\land M) \\lor (L \\land M)] \\rightarrow B\\);\n\\([S \\land \\neg((V \\land L) \\lor (V \\land M) \\lor (L \\land M))] \\rightarrow N\\);\n\\((N \\land \\neg C) \\rightarrow P\\).\n\nLógica de Predicados:\n\n\\(Transacao(t)\\): \\(t\\) é uma transação;\n\\(AnalisaTempoReal(t)\\): a transação \\(t\\) é analisada em tempo real;\n\\(ValorAlto(t)\\): a transação \\(t\\) tem valor acima do padrão histórico;\n\\(LocalizacaoIncomum(t)\\): a transação \\(t\\) ocorre em localização incomum;\n\\(MultiplasTentativas(t)\\): há múltiplas tentativas para a transação \\(t\\);\n\\(Suspeita(t)\\): a transação \\(t\\) é marcada como suspeita;\n\\(Bloqueada(t)\\): a transação \\(t\\) é bloqueada automaticamente;\n\\(EnviaNotificacao(t)\\): uma notificação é enviada para confirmar \\(t\\);\n\\(Confirma(t, m)\\): a transação \\(t\\) é confirmada dentro de m minutos;\n\\(BloqueioPreventivo(t)\\): a transação \\(t\\) recebe bloqueio preventivo.\n\nFormalização:\n\n\\(\\forall t [Transacao(t) \\rightarrow AnalisaTempoReal(t)]\\);\n\\(\\forall t [Transacao(t) \\land (ValorAlto(t) \\lor LocalizacaoIncomum(t) \\lor MultiplasTentativas(t)) \\rightarrow Suspeita(t)]\\);\n\\(\\forall t [Transacao(t) \\land ((ValorAlto(t) \\land LocalizacaoIncomum(t)) \\lor (ValorAlto(t) \\land MultiplasTentativas(t)) \\lor (LocalizacaoIncomum(t) \\land MultiplasTentativas(t))) \\rightarrow Bloqueada(t)]\\);\n\\(\\forall t [Transacao(t) \\land Suspeita(t) \\land \\neg((ValorAlto(t) \\land LocalizacaoIncomum(t)) \\lor (ValorAlto(t) \\land MultiplasTentativas(t)) \\lor (LocalizacaoIncomum(t) \\land MultiplasTentativas(t))) \\rightarrow EnviaNotificacao(t)]\\);\n\\(\\forall t [Transacao(t) \\land EnviaNotificacao(t) \\land \\neg Confirma(t, 5) \\rightarrow BloqueioPreventivo(t)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura representa corretamente o processo de decisão do sistema:\n\nA definição de transação suspeita usa uma disjunção (\\(OR\\)) adequada;\nA condição para bloqueio automático usa corretamente conjunções (\\(AND\\)) para representar a combinação de critérios;\nA notificação em caso de suspeita única é representada por uma conjunção com uma negação de múltiplos critérios;\nO bloqueio preventivo após falta de confirmação segue uma implicação lógica válida.\n\nO sistema de regras é coerente, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de detecção de fraudes:\n\nA análise em tempo real é essencial para sistemas antifraude eficazes;\nOs critérios mencionados são indicadores comuns de atividades potencialmente fraudulentas;\nA escalação baseada na quantidade de indicadores segue práticas reais de segurança;\nO envolvimento do cliente para confirmação é uma prática que equilibra segurança e usabilidade;\nO tempo limite para confirmação é uma medida preventiva razoável.\n\nAs conclusões derivadas são sólidas e representam um sistema de detecção de fraudes que equilibra detecção automática, envolvimento do cliente e proteção preventiva.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Provas</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html",
    "href": "04-logica-predicativa-e-quantificadores.html",
    "title": "5  Lógica Predicativa",
    "section": "",
    "text": "A lógica é a técnica que usamos para adicionar convicção à verdade. Jean de la Bruyere{: class=“epigraph”}\n\nA Lógica Predicativa, coração e espírito da Lógica de Primeira Ordem, nos leva um passo além da Lógica Proposicional. Em vez de se concentrar apenas em proposições completas que são verdadeiras ou falsas, a lógica predicativa nos permite expressar proposições sobre objetos e as relações entre eles. Ela nos permite falar de forma mais rica e sofisticada sobre o mundo.\nVamos lembrar que na Lógica Proposicional, cada proposição é um átomo indivisível. Por exemplo, ‘A chuva cai’ ou ‘O sol brilha’. Cada uma dessas proposições é verdadeira ou falsa como uma unidade. Na lógica predicativa, no entanto, podemos olhar para dentro dessas proposições. Podemos falar sobre o sujeito - a chuva, o sol - e o predicado - cai, brilha. Podemos quantificar sobre eles: para todos os dias, existe um momento em que o sol brilha.\nEnquanto a Lógica Proposicional pode ser vista como a aritmética do verdadeiro e do falso, a lógica predicativa é a álgebra do raciocínio. Ela nos permite manipular proposições de forma muito mais rica e expressiva. Com ela, podemos começar a codificar partes substanciais da matemática e da ciência, levando-nos mais perto de nossa busca para decifrar o cosmos, um símbolo de lógica de cada vez.\n\n5.0.1 Introdução aos Predicados\nUm predicado é como uma luneta que nos permite observar as propriedades de uma entidade. Um conjunto de lentes através do qual podemos ver se uma entidade particular possui ou não uma característica específica. A palavra predicado foi importada do campo da linguística e tem o mesmo significado: qualidade; característica. Por exemplo, ao observar o universo das letras através do telescópio do predicado ser uma vogal, percebemos que algumas entidades deste conjunto, como \\(A\\) e $I $, possuem essa propriedade, enquanto outras, como $ g$ e \\(H\\), não.\nUm predicado não é uma afirmação absoluta de verdade ou falsidade. Divergindo das proposições, os predicados não são declarações completas. Pense neles como aquelas sentenças com espaços em branco, aguardando para serem preenchidos, que só têm sentido completo quando preenchidas:\n\nO _______ está saboroso;\nO _______ é vermelho;\n_______ é alto.\n\nPreencha as lacunas, como quiser desde que faça sentido, e perceba que, em cada caso, ao preencher estamos atribuindo uma qualidade a um objeto. Esses são exemplos de predicados do nosso cotidiano, que sinteticamente o conceito que queremos abordar. Na lógica, os predicados são artefatos que possibilitam examinar o mundo ao nosso redor de forma organizada e exata.\nUm predicado pode ser entendido como uma função que recebe um objeto (ou um conjunto de objetos) e retorna um valor de verdade, \\(\\{\\text{verdadeiro ou falso}\\}\\). Esta função descreve uma propriedade que o objeto pode possuir. Isto é, se \\(P\\) é uma função \\(P: U \\rightarrow \\\\{\\text{Verdadeiro, Falso}\\\\}\\) Para um determinado conjunto $ u$ qualquer. Esse conjunto $ u$ é chamado de universo ou domínio do discurso, e dizemos que \\(P\\) é um predicado sobre $ u$.\n\n\n5.0.2 Universo do Discurso\nO universo do discurso, \\(U\\), também chamado de universo, ou domínio, é o conjunto de objetos de interesse em um determinado cenário lógico para uma análise específica. O universo do discurso é importante porque as proposições na Lógica de Predicados serão declarações sobre objetos de um universo.\nO universo, \\(U\\), é o domínio das variáveis das nossas Fórmulas Bem Formadas. O universo do discurso pode ser o conjunto dos números reais, \\(\\mathbb{R}\\) o conjunto dos inteiros, \\(\\mathbb{z}\\), o conjunto de todos os alunos em uma sala de aula que usam camisa amarela, ou qualquer outro conjunto que definamos. Na prática, o universo costuma ser deixado implícito e deveria ser óbvio a partir do contexto. Se não for o caso, precisa ser explicitado.\nSe estamos interessados em proposições sobre números naturais, \\(\\mathbb{N}\\), o universo do discurso é o conjunto \\(\\mathbb{N} = \\{0, 1, 2, 3,...\\}\\), um conjunto infinito. Já se estamos interessados em proposições sobre alunos de uma sala de aula, o universo do discurso poderia ser o conjunto $ u = {, , …}$, um conjunto finito.\nPara que este conceito fique mais claro, suponha que temos um conjunto de números \\(U = \\\\{1, 2, 3, 4, 5\\\\}\\) e um predicado \\(P(u)\\), que dizemos unário por ter um, e somente um, argumento, que afirma u é par. Ao aplicarmos este predicado a cada elemento do universo \\(U\\), obtemos um conjunto de valores verdade:\n\\[\n\\begin{align}\n&P(1) = \\text{falso};\\\\\n&P(2) = \\text{verdadeiro};\\\\\n&P(3) = \\text{falso};\\\\\n&P(4) = \\text{verdadeiro};\\\\\n&P(5) = \\text{falso}.\n\\end{align}\n\\]\nVemos que o predicado \\(P(u)\\) dado por u é par é uma propriedade que alguns números do conjunto $ u$ Possuem, e outros não. Vale notar que na Lógica Predicativa, a função que define um predicado pode ter múltiplos argumentos. Por exemplo, podemos ter um predicado \\(Q(x, y)\\) que afirma x é maior que y. Neste caso, o predicado \\(Q\\) é uma função de dois argumentos que retorna um valor de verdade. Dizemos que \\(Q(x, y)\\) é um predicado binário. Exemplos nos conduzem ao caminho do entendimento:\n\nExemplo 1:\n\nUniverso do discurso: \\(U = \\text{conjunto de todas as pessoas}\\).\nPredicado:\\(P(x) = \\\\{ x : x \\text{ é um matemático} \\\\}\\);\nItens para os quais \\(P(x)\\) é verdadeiro: Carl Gauss, Leonhard Euler, John Von Neumann.\n\nExemplo 2:\n\nUniverso do discurso: \\(U = \\{x \\in \\mathbb{Z} : x \\text{ é par}\\}\\)\nPredicado: \\(Q(x) = (x &gt; 5)\\);\nItens para os quais \\(Q(x)\\) é verdadeiro: $6 $, $8 $, \\(10 ...\\).\n\nExemplo 3:\n\nUniverso do discurso: \\(U = \\{x \\in \\mathbb{R} : x &gt; 0 \\text{ e } x &lt; 10\\}\\)\nPredicado: \\(R(x) = (x^2 - 4 = 0)\\);\nItens para os quais \\(R(x)\\) é verdadeiro: \\(2\\), \\(-2\\).\n\nExemplo 4:\n\nUniverso do discurso: \\(U = \\\\{x \\in \\mathbb{N} : x \\text{ é um múltiplo de } 3\\\\}\\)\nPredicado: \\(S(x) = (\\text{mod}(x, 2) = 0)\\);\nItens para os quais \\(S(x)\\) é verdadeiro: \\(6\\), \\(12\\), $18 $.\n\nExemplo 5:\n\nUniverso do discurso: \\(U = \\{(x, y) \\in \\mathbb{R}^2 : x \\neq y\\}\\)\nPredicado: \\(P(x, y) = (x &lt; y)\\);\nItens para os quais \\(P(x, y)\\) é verdadeiro: \\((1, 2)\\), \\((3, 4)\\), \\((5, 6)\\).\n\n\n\n\n5.0.3 Entendendo Predicados\nA aridade do predicado, número de argumentos, é limitado pela análise lógica que estamos fazendo. Considere um predicado ternário, \\(R\\), dado por x está entre y e z. Quando substituímos \\(x\\), \\(y\\) e \\(z\\) Por números específicos podemos validar a verdade do predicado \\(R\\). Vamos considerar alguns exemplos adicionais de predicados baseados na aritmética e defini-los com menos formalidade e mais legibilidade:\n\n$ Primo(n)$: o número inteiro positivo $ n$ é um número primo.\n$ PotênciaDe (n, k)$: o número inteiro $ n$ é uma potência exata de \\(k : n = ki\\) Para algum \\(i \\in \\mathbb{Z} ≥ 0\\).\n$ somaDeDoisPrimos(n)$: o número inteiro positivo $ n$ é igual à soma de dois números primos.\n\nEm 1, 2 e 3 os predicados estão definidos com mnemônicos aumentando a legibilidade e melhorando nossa capacidade de manter o universo implícito. O uso de predicados, e da Lógica Proposicional, permite a escrita de sentenças menos ambíguas para a definição de conceitos lógicos em formato matemático. Por exemplo: se \\(x\\) é um ancestral de \\(y\\) e \\(y\\) é um ancestral de \\(z\\) então \\(x\\) é um ancestral de \\(z\\); que, se consideramos o predicado $AncestralDe $ Pode ser escrito como \\(AncestralDe (x,y) \\wedge ancestralDe (y,z) \\rightarrow ancestralDe (x,z)\\). Ainda assim, falta alguma coisa. Algo que permita aplicar os predicados a um conjunto de elementos dentro do universo do discurso. É aqui que entram os quantificadores.\n\n\n5.0.4 Quantificadores\nEmbora a Lógica Proposicional seja um bom ponto de partida, a maioria das afirmações interessantes em matemática contêm variáveis definidas em domínios maiores do que apenas \\(\\\\{\\text{Verdadeiro}, \\text{Falso}\\\\}\\). Por exemplo, a afirmação \\(x \\text{é uma potência de } 2\\) não é uma proposição. Não temos como definir a verdade dessa afirmação até conhecermos o valor de \\(x\\). Se \\(P(x)\\) é definido como a afirmação \\(x \\text{é uma potência de } 2\\), então \\(P(8)\\) é verdadeiro e \\(P(7)\\) é falso.\nPara termos uma linguagem lógica que seja suficientemente flexível para representar os problemas que encontramos no Universo real, o Universo em que vivemos, precisaremos ser capazes de dizer quando o predicado \\(P\\) ou \\(Q\\) é verdadeiro para valores diferentes em seus argumentos. Para tanto, vincularemos as variáveis aos predicados usando operadores para indicar quantidade, chamados de quantificadores.\nOs quantificadores indicam se a sentença que estamos criando se aplica a todos os valores possíveis do argumento, quantificação universal, ou se esta sentença se aplica a um valor específico, quantificação existencial. Usaremos esses quantificadores para fazer declarações sobre todos os elementos de um universo de discurso específico, ou para afirmar que existe pelo menos um elemento do universo do discurso que satisfaz uma determinada qualidade.\nVamos remover o véu da dúvida usando como recurso metafórico uma experiência humana, social, comum e popular: imaginemos estar em uma festa e o anfitrião lhe pede para verificar se todos os convidados têm algo para beber. Você, prestativo e simpático, começa a percorrer a sala, verificando cada pessoa. Se você encontrar pelo menos uma pessoa sem bebida, você pode imediatamente dizer nem todos têm bebidas. mas, se você verificar cada convidado e todos eles tiverem algo para beber, você pode dizer com confiança todos têm bebidas. Este é o conceito do quantificador universal, matematicamente representado por \\(\\forall\\), que lemos como para todo.\nA festa continua e o anfitrião quer saber se alguém na festa está bebendo champanhe. Desta vez, assim que você encontrar uma pessoa com champanhe, você pode responder imediatamente sim, alguém está bebendo champanhe. Você não precisa verificar todo mundo para ter a resposta correta. Este é o conceito do quantificador existencial, denotado por $$, que lemos existe algum.\nOs quantificadores nos permitem fazer declarações gerais, ou específicas, sobre os membros de um universo de discurso, de uma forma que seria difícil, ou impossível, sem estes operadores especiais.\n\n5.0.4.1 Quantificador Universal\nO quantificador universal \\(\\forall\\), lê-se para todo, indica que uma afirmação deve ser verdadeira para todos os valores de uma variável dentro de um universo de discurso definido para a criação de uma sentença contendo um predicado qualquer. Por exemplo, a proposição clássica todos os humanos são mortais pode ser escrita como \\(\\forall x Humano(x) \\rightarrow Mortal(x)\\). Ou recorrendo a um exemplo com mais de rigor matemático, teríamos o predicado se \\(x\\) é positivo então $x + 1 $ é positivo, que pode ser escrito \\(\\forall x (x &gt; 0 \\rightarrow x + 1 &gt; 0)\\). Neste último exemplo temos Quantificadores, Lógica Predicativa, Lógica Proposicional e Teoria dos Conjuntos em uma sentença.\nO quantificador universal pode ser representado usando apenas a Lógica Proposicional, com uma pequena trapaça. A afirmação \\(\\forall x P(x)\\) é, de certa forma, a operação $$, AND aplicada a todos os elementos do universo do discurso. Ou seja, o predicado:\n\\[\\forall x \\{x:\\in \\mathbb{N}\\} : P(x)\\]\nPode ser escrito como:\n\\[P(0) \\land P(1) \\land P(2) \\land P(3) \\land \\ldots \\]\nAssim, $P(0), P(1), P(2), P(3) $ representam a aplicação do predicado \\(P\\)A todos os elementos \\(x\\) do conjunto \\(\\mathbb{N}\\). A trapaça fica por conta de que, em Lógica Proposicional, não podemos escrever expressões com um número infinito de termos. Portanto, a expansão em conjunções de um predicado \\(P\\) em um Universo de Discurso, $ u$, não é uma Fórmula Bem Formada se a cardinalidade de $ u$ for infinita. De qualquer forma, podemos usar esta interpretação informal para entender o significado de \\(\\forall x P(x)\\).\nA representação do Quantificador Universal como uma conjunção não é uma Fórmula Bem Formada a não ser que o Universo do Discurso seja não infinito. Neste caso, teremos uma conjunção que chamaremos de Conjunção Universal:\n\\[\\forall x (P(x) \\land Q(x))\\]\nIsso significa que para todo \\(x\\) no domínio, as propriedades \\(P\\), \\(Q\\), e outras listadas são todas verdadeiras. É uma forma de expressar que todas as condições listadas são verdadeiras para cada elemento no domínio. Esta fórmula será usada para simplificar sentenças, ou para criar formas normais.\nVamos voltar um pouco. O quantificador universal \\(\\forall x P(x)\\)Afirma que a proposição \\(P(x)\\) é verdadeira para todo, e qualquer, valor possível de \\(x\\) como elemento de um conjunto, \\(u\\). Uma forma de interpretar isso é pensar em \\(x\\) como uma variável que pode ter qualquer valor dentro do universo do discurso.\nPara validar \\(\\forall x P(x)\\) escolhemos o pior caso possível para \\(x\\), todos os valores que suspeitamos possa fazer \\(P(x)\\) falso. Se conseguirmos provar que \\(P(x)\\) é verdadeira nestes casos específicos, então \\(\\forall x P(x)\\) deve ser verdadeira. Novamente, vamos recorrer a exemplos na esperança de explicitar este conceito.\nExemplo 1: todos os números reais são maiores que 0. (Universo do discurso: \\(\\{x \\in \\mathbb{R}\\}\\))\n\\[\\forall x (x \\in \\mathbb{R} \\rightarrow x &gt; 0)\\]\n\nObserve que este predicado, apesar de estar corretamente representado, é \\(Falso\\).\n\nExemplo 2: todos os triângulos em um plano euclidiano têm a soma dos ângulos internos igual a 180 graus. (Universo do discurso: \\(x\\) é um triângulo em um plano euclidiano)\n\\[\\forall x (Triângulo(x) \\rightarrow \\Sigma_{i=1}^3 ÂnguloInterno_i(x) = 180^\\circ)\\]\nExemplo 3: todas as pessoas com mais de 18 anos podem tirar carteira de motorista.” (Universo do discurso: \\(x\\) é uma pessoa no Brasil)\n\\[\\forall x (Pessoa(x) \\land Idade (x) \\geq 18 \\rightarrow PodeTirarCarteira(x))\\]\nExemplo 4: todo número par maior que 2 pode ser escrito como a soma de dois números primos. (Universo do discurso: \\(\\{x \\in \\mathbb{Z}\\}\\)\n\\[\\forall x\\,(Par(x) \\land x &gt; 2 \\rightarrow \\exists a\\exists b\\, (Primo(a) \\land Primo(b) \\land x = a + b))\\]\nExemplo 5: para todo número natural, se ele é múltiplo de 4 e múltiplo de 6, então ele também é múltiplo de 12. (Universo do discurso: \\(\\{x \\in \\mathbb{N}\\}\\))\n\\[\\forall x\\,((\\exists a\\in\\Bbb N\\,(x = 4a) \\land \\exists b\\in\\Bbb N\\,(x = 6b)) \\rightarrow \\exists c\\in\\Bbb N\\,(x = 12c))\\]\nO quantificador universal nos permite definir uma Fórmula Bem Formada representando todos os elementos de um conjunto, um universo do discurso, em relação a uma qualidade específica, um predicado. Esta é um artefato lógico interessante, mas não suficiente.\nUsamos, preferencialmente, a implicação, \\(\\to\\), com o quantificador universal, \\(\\forall\\), para indicar que uma propriedade vale para todos os elementos de um domínio, Porque permite afirmar que para todo \\(x\\), se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. Isso permite que \\(P(x)\\) seja falsa para alguns \\(x\\), mas a implicação como um todo permanece verdadeira. Ou, em outras palavras, quando usamos uma implicação, como \\(P(x) \\rightarrow Q(x)\\), estamos dizendo que se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. A implicação é uma forma lógica que permite conectar duas proposições, em que a veracidade de \\(Q(x)\\) depende da veracidade de \\(P(x)\\).\n\nImportante: A implicação \\(P(x) \\rightarrow Q(x)\\) é considerada verdadeira em qualquer dos seguintes casos:\n\\(P(x)\\) é verdadeira e \\(Q(x)\\) é verdadeira. \\(P(x)\\) é falsa, independentemente de \\(Q(x)\\). O ponto-chave é o segundo caso: se \\(P(x)\\) for falsa, a implicação \\(P(x) \\rightarrow Q(x)\\) ainda é verdadeira, não importa o valor de \\(Q(x)\\).\n\nEssa preferência não é arbitrária, mas baseada nas limitações que os outros conectivos apresentam quando combinados com o quantificador universal. Porém, uma análise de todos os operadores pode ser interessante para sedimentar os conceitos.\nComecemos com a conjunção. Quando usamos \\(∀x(P(x) ∧ Q(x))\\), estamos afirmando que para todo \\(x\\), tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiros. Isso é extremamente restritivo e raramente reflete situações do mundo real. Por exemplo, se disséssemos Todos os animais são mamíferos e podem voar, estaríamos fazendo uma afirmação falsa, pois nem todos os animais são mamíferos e nem todos podem voar. Outro exemplo seria Todos os números são pares e primos, o que é claramente falso, pois nenhum número (exceto 2) satisfaz ambas as condições simultaneamente.\nA disjunção, por outro lado, é muito fraca quando combinada com o quantificador universal. \\(∀x(P(x) ∨ Q(x))\\) afirma que para todo \\(x\\), ou \\(P(x)\\) ou \\(Q(x)\\) (ou ambos) são verdadeiros. Isso geralmente não captura relações condicionais úteis. Por exemplo, Todo número é par ou ímpar é uma afirmação verdadeira, mas não nos diz muito sobre a relação entre paridade e números. Da mesma forma, Toda pessoa é alta ou baixa é uma afirmação de tal amplitude que se torna quase sem sentido, pois não fornece informações úteis sobre a altura das pessoas.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador universal também apresenta problemas. \\(∀x(P(x) \\leftrightarrow Q(x))\\) afirma que para todo \\(x\\), \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso é uma condição muito forte e raramente é satisfeita em situações reais. Por exemplo, Um número é par se e somente se é divisível por 4 é falso, pois há números pares que não são divisíveis por \\(4\\) (como \\(2\\) e \\(6\\)). Outro exemplo seria Uma pessoa é feliz se e somente se é rica, o que claramente não reflete a realidade complexa da felicidade e riqueza.\nPor outro lado, a implicação (\\(\\to\\)) oferece várias vantagens quando usada com o quantificador universal. \\(∀x(P(x) \\to Q(x))\\) nos permite expressar relações condicionais de forma mais flexível e precisa. Por exemplo, Para todo número, se é par, então não é primo (exceto 2) é uma afirmação verdadeira e informativa. Outro exemplo seria Para toda pessoa, se é médico, então tem formação universitária. Esta formulação permite exceções (pode haver pessoas com formação universitária que não são médicos) e captura uma regra geral de forma precisa.\nA implicação também tem a vantagem de ser verdadeira quando o antecedente (\\(P(x)\\)) é falso, o que é útil para expressar regras gerais. Por exemplo, em Para todo x, se x é um quadrado perfeito, então x é positivo, a implicação é verdadeira mesmo para números negativos (que não são quadrados perfeitos), mantendo a regra geral válida.\nEspero que tenha ficado claro. A implicação, quando combinada com o quantificador universal, oferece um equilíbrio entre flexibilidade e precisão que os outros conectivos lógicos não conseguem alcançar. Ela permite expressar relações condicionais, acomoda exceções e captura regras gerais de forma mais eficaz, tornando-a a escolha preferida em muitas situações da lógica formal e da matemática.\n\n\n5.0.4.2 Quantificador Existencial\nO quantificador existencial, $$ nos permite fazer afirmações sobre a existência de objetos com certas propriedades, sem precisarmos especificar exatamente quais objetos são esses. Vamos tentar remover os véus da dúvida com um exemplo simples.\nConsideremos a sentença: existem humanos mortais. Com um pouco mais de detalhe e matemática, podemos escrever isso como: existe pelo menos um \\(x\\) tal que \\(x\\) é humano e mortal. Para escrever a mesma sentença com precisão matemática teremos:\n\\[\\exists x \\text{Humano}(x) \\land \\text{Mortal}(x)\\]\nLendo por partes: existe um \\(x\\), tal que \\(x\\) é humano AND \\(x\\) é mortal. Em outras palavras, existe pelo menos um humano que é mortal.\nNote duas coisas importantes:\n\nNós não precisamos dizer exatamente quem é esse humano mortal. Só afirmamos que existe um. O operador $$ captura essa ideia.\nUsamos AND ($\\(), não implicação (\\)$). Se usássemos $$, a afirmação ficaria muito mais fraca. Veja:\n\n\\[\\exists x \\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\]\nQue pode ser lido como: existe um \\(x\\) tal que, SE \\(x\\) é humano, ENTÃO \\(x\\) é mortal. Essa afirmação é verdadeira em qualquer universo que contenha um unicórnio de bolinhas roxas imortal. Porque o unicórnio não é humano, então \\(\\text{Humano}(\\text{unicórnio})\\) é falsa, e a implicação \\(\\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\) é verdadeira. Não entendeu? Volte dois parágrafos e leia novamente. Repita!\nPortanto, é importante usar o operador $$, e não $$ quando trabalhamos com quantificadores existenciais. O $$ garante que a propriedade se aplica ao objeto existente definido pelo $$. Contudo, podemos melhorar um pouco isso:\nA conjunção, \\(\\land\\), é frequentemente empregada com o quantificador existencial, \\(\\exists\\), para expressar a presença de ao menos um elemento em determinado conjunto que possui múltiplas características simultaneamente. Isso nos possibilita declarar que há no mínimo um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são válidas. Tal afirmação confirma a existência de pelo menos um elemento que atende a ambos os critérios. Dito de outra forma, ao utilizarmos uma conjunção, como em \\(P(x) \\land Q(x)\\), estamos afirmando que existe ao menos um \\(x\\) em que \\(P(x)\\) é verdadeiro e, ao mesmo tempo, \\(Q(x)\\) também o é. A conjunção funciona como um operador lógico que une duas proposições, em que a validade da asserção existencial depende da ocorrência simultânea de \\(P(x)\\) e \\(Q(x)\\) para, no mínimo, um \\(x\\).\n\nNo contexto do quantificador existencial \\(\\exists x\\), a conjunção \\(P(x) \\land Q(x)\\) é tida como verdadeira se, e apenas se:\nHouver ao menos um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiras. Caso não exista tal \\(x\\), a afirmação existencial é considerada falsa. Observe que basta a existência de um único elemento satisfazendo ambas as condições para validar a afirmação existencial.\n\nEsta predileção não é fortuita, mas fundamentada na aptidão da conjunção em expressar com exatidão a existência de elementos dotados de múltiplos atributos concomitantes. No entanto, uma avaliação dos demais operadores pode ser proveitosa para consolidar esses conceitos.\nIniciemos com a implicação. Ao empregarmos \\(\\exists x(P(x) \\to Q(x))\\), declaramos a existência de ao menos um \\(x\\) tal que, se \\(P(x)\\) for verdadeiro, então \\(Q(x)\\) também o será. Esta formulação é menos elucidativa que a conjunção no âmbito existencial, pois seria verdadeira mesmo se \\(P(x)\\) fosse falso para todo \\(x\\). Ilustrando: Há um número que, se for ímpar, é múltiplo de 2 é verdadeiro (pois é válido para números pares), mas não esclarece se realmente existe um número ímpar que é múltiplo de 2.\nA disjunção aliada ao quantificador existencial, \\(\\exists x(P(x) \\lor Q(x))\\), assevera a existência de pelo menos um \\(x\\) que satisfaz \\(P(x)\\) ou \\(Q(x)\\) (ou ambos). Embora útil em certos contextos, geralmente é menos robusta que a conjunção para afirmar a existência de elementos com múltiplas propriedades. Por exemplo: Existe um número que é negativo ou racional é verdadeiro, mas não nos informa se há um número que é ambos.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador existencial também pode ser problemática. \\(\\exists x(P(x) \\leftrightarrow Q(x))\\) afirma a existência de ao menos um \\(x\\) para o qual \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso pode ser útil em alguns casos, mas frequentemente é mais restritivo do que o necessário. Por exemplo: Existe um número que é positivo se e somente se é inteiro é verdadeiro (o número 1 satisfaz isso), mas não captura a existência de números que são apenas positivos ou apenas inteiros.\nEm contrapartida, a conjunção (\\(\\land\\)) apresenta diversas vantagens quando utilizada com o quantificador existencial. \\(\\exists x(P(x) \\land Q(x))\\) nos permite afirmar a existência de elementos que possuem múltiplas propriedades simultaneamente. Por exemplo: Existe um número que é positivo e par é uma afirmação verdadeira e informativa (o número 2 satisfaz ambas as condições). Outro exemplo seria Existe uma substância que é líquida e condutora de eletricidade. Esta formulação afirma claramente a existência de substâncias com ambas as características.\nA conjunção também tem a vantagem de ser falsa quando não há elementos que satisfaçam ambas as condições, o que é útil para expressar a inexistência de certos tipos de elementos. Por exemplo: Existe um número que é natural e negativo simultaneamente é falso, indicando corretamente que não há tais números.\nEm suma, a conjunção, quando associada ao quantificador existencial, proporciona um meio preciso e informativo de expressar a existência de elementos com múltiplos atributos. Ela permite afirmar a presença de elementos que atendem a condições simultâneas, tornando-se a opção preferencial em diversas situações da lógica formal e da matemática quando se trata de asserções existenciais.\nAssim como o quantificador universal, $$, o quantificador existencial, $$ , também pode ser restrito a um universo específico, usando a notação de pertencimento:\n\\[\\exists x \\in \\mathbb{Z} : x = x^2\\]\nEsta sentença afirma a existência de pelo menos um inteiro \\(x\\) tal que \\(x\\) é igual ao seu quadrado. Novamente, não precisamos dizer qual é esse inteiro, apenas que ele existe dentro do conjunto dos inteiros. Existe?\nDe forma geral, o quantificador existencial serve para fazer afirmações elegantes sobre a existência de objetos com certas qualidades, sem necessariamente conhecermos ou elencarmos todos esses objetos. Isso agrega mais qualidade a representação do mundo real que podemos fazer com a Lógica de Primeira Ordem.\nTalvez, alguns exemplos possam ajudar no seu entendimento:\nExemplo 1: existe um mamífero que não respira ar.\n\\[\\exists x (mamífero(x) \\land \\neg RespiraAr(x))\\]\nExemplo 2: existe uma equação do segundo grau com uma raiz real.\n\\[\\exists x (\\text{Eq2Grau}(x) \\land |\\text{RaízesReais}(x)| \\leq 1)\\]\nExemplo 3: existe um número primo que é par.\n\\[\\exists x (Primo(x) \\land Par(x))\\]\nExemplo 4: existe um quadrado perfeito que pode ser escrito como o quadrado de um número racional.\n\\[\\exists x (QuadPerfeito(x) \\land \\exists a \\in \\mathbb{Q} \\ (x = a^2))\\]\nExemplo 5: existe um polígono convexo em que a soma dos ângulos internos não é igual A\\((n-2)\\cdot180^{\\circ}\\).\n\\[\\exists x (\\text{PolígonoConvexo}(x) \\land \\sum_{i=1}^{n} \\text{ÂnguloInterno}_i(x) \\neq (n-2)\\cdot 180^{\\circ})\\]\n\nNovamente, observe que este predicado é \\(falso\\). Todos os polígonos convexos têm a soma dos ângulos internos igual a \\((n−2)cdot 180\\), onde \\(𝑛\\) é o número de lados do polígono.\n\n\n\n\n5.0.5 Equivalências Interessantes\nEstudando o quantificador universal encontramos duas equivalências interessantes:\n\\[\\lnot \\forall x P(x) \\leftrightarrow \\exists x \\lnot P(x)\\]\n\\[\\lnot \\exists x P(x) \\leftrightarrow \\forall x \\lnot P(x)\\]\nEssas equivalências são essencialmente as versões quantificadas das Leis de De Morgan. A primeira diz que nem todos os humanos são mortais, isso é equivalente a encontrar algum humano que não é mortal. A segunda diz que para mostrar que nenhum humano é mortal, temos que mostrar que todos os humanos não são mortais.\nPodemos representar uma declaração \\(\\exists x P(x)\\) como uma expressão OU. Por exemplo, \\(\\exists x \\in \\mathbb{N} : P(x)\\) Poderia ser reescrito como:\n\\[P(0) \\lor P(1) \\lor P(2) \\lor P(3) \\lor \\ldots \\]\nLembrado do problema que encontramos quando fizemos isso com o quantificador $$: não podemos representar fórmulas sem fim em Lógica de Primeira Ordem. mas, novamente esta notação, ainda que inválida, nos permite entender melhor o quantificador existencial. Caso o Universo do Discurso seja não infinito, limitado e contável, teremos a Disjunção Existencial uma expressão na lógica de primeiro grau que afirma que existe pelo menos um elemento em um domínio que satisfaz uma ou mais propriedades. A forma geral de uma disjunção existencial é:\n\\[\\exists x (P(x) \\lor Q(x))\\]\nIsso significa que existe pelo menos um \\(x\\) no domínio que satisfaz a propriedade \\(P\\), ou a propriedade \\(Q\\), ou ambas, ou outras propriedades listadas. É uma forma de expressar que pelo menos uma das condições listadas é verdadeira para algum elemento no domínio.\nA expansão de $$ usando $$ destaca que a proposição \\(P(x)\\) é verdadeira se pelo menos um valor de \\(x\\) dentro do universo do discurso atender ao predicado \\(P\\). O que a expansão de exemplo está dizendo é que existe pelo menos um número natural \\(x\\) tal que \\(P(x)\\) é verdadeiro. Não precisamos saber exatamente qual é esse \\(x\\). Apenas que existe um elemento dentro de \\(\\mathbb{N}\\) que atende o predicado.\nO quantificador existencial não especifica o objeto dentro do universo determinado. Esse operador permite fazer afirmações elegantes sobre a existência de objetos com certas características, certas qualidades, ou ainda, certos predicados, sem necessariamente conhecermos exatamente quais são esses objetos.\n\n\n5.0.6 Dos Predicados à Linguagem Natural\nAo ler uma Fórmula Bem Formada contendo quantificadores, a ordem da leitura é geralmente da esquerda para a direita. A interpretação precisa, no entanto, depende diretamente da ordem e do tipo dos quantificadores.\nPor exemplo, \\(\\forall x\\) pode ser lido como “para todo objeto \\(x\\) no universo do discurso (em que este objeto está implícito), o seguinte se mantém”. Já o quantificador \\(\\exists x\\) pode ser lido como “existe um objeto \\(x\\) no universo que satisfaz o seguinte” ou “para algum objeto \\(x\\) no universo, o seguinte se mantém”.\nConverter uma Fórmula Bem Formada em uma sentença fluida em linguagem natural nem sempre é direto, mas é um passo valioso para a compreensão. Vamos considerar \\(U\\) como o universo do discurso (o conjunto de todos os aviões já fabricados) e \\(F(x,y)\\) como o predicado que denota “\\(x\\) voa mais rápido que \\(y\\)”. Analisemos algumas combinações de quantificadores:\n\n\\(\\forall x \\forall y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), e para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação é muito forte. Ela diz que cada avião no universo é mais rápido que todos os aviões no universo (incluindo ele mesmo, a menos que \\(F(x,x)\\) seja definido como falso ou que se adicione \\(x \\neq y\\)). Se o universo tiver mais de um avião, esta afirmação provavelmente será falsa, pois implicaria, por exemplo, que \\(A\\) é mais rápido que \\(B\\) e \\(B\\) é mais rápido que \\(A\\) simultaneamente.\n\n\\(\\exists x \\forall y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) tal que, para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que existe pelo menos um avião que é mais rápido que todos os outros (e, novamente, dependendo da definição de \\(F(x,x)\\), mais rápido que ele mesmo). Em outras palavras, existe um “avião mais rápido absoluto”.\n\n\\(\\forall x \\exists y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que para qualquer avião que escolhermos, podemos encontrar algum avião \\(y\\) que é mais lento que \\(x\\). Se \\(y\\) pode ser igual a \\(x\\), a afirmação é trivialmente verdadeira se \\(F(x,x)\\) for verdadeiro para algum \\(x\\). Se \\(y\\) deve ser diferente de \\(x\\), isso significaria que não existe um “avião mais lento absoluto” (a menos que o universo seja finito e ordenado de forma cíclica, ou que \\(F(x,y)\\) permita que \\(x\\) seja mais rápido que “nada” se \\(y\\) for o mais lento). Uma interpretação comum é que, para cada avião, há outro que ele supera em velocidade.\n\n\\(\\exists x \\exists y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) e existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta é a afirmação mais fraca entre as quatro. Ela simplesmente diz que a relação “voa mais rápido que” não é vazia; ou seja, há pelo menos um par de aviões \\((x,y)\\) em que \\(x\\) é mais rápido que \\(y\\).\n\n\nÉ fundamental perceber que estas quatro sentenças têm significados lógicos distintos e geralmente não expressam o mesmo contexto. A ordem dos quantificadores, especialmente quando misturamos \\(\\forall\\) e \\(\\exists\\), altera drasticamente o significado da afirmação. Por exemplo, \\(\\exists x \\forall y F(x,y)\\) (existe um avião mais rápido que todos) é uma afirmação muito mais forte e diferente de \\(\\forall x \\exists y F(x,y)\\) (para cada avião, existe um mais lento).\nAo traduzir da lógica para a linguagem natural ou vice-versa, a precisão na interpretação da ordem e do tipo dos quantificadores é essencial. A prática leva a uma maior fluidez nesse processo de tradução e compreensão.\n\n\n5.0.7 Exercícios de Conversão de Linguagem Natural em Expressões Predicativas\nSentença 1: Todo matemático que é professor tem alunos que são brilhantes e interessados.\n\\[\n\\forall x ((\\text{Matemático}(x) \\wedge \\text{Professor}(x)) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Matemático}(x) \\rightarrow (\\text{Professor}(x) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y))))\n\\]\nSentença 2: Alguns engenheiros não são nem ricos nem felizes.\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg (\\text{Rico}(x) \\vee \\text{Feliz}(x)))\\]\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg\\text{Rico}(x) \\wedge \\neg\\text{Feliz}(x))\\]\nSentença 3: Todos os planetas que têm água possuem vida ou têm potencial para vida.\n\\[\n\\forall x (\\text{Planeta}(x) \\wedge \\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x)))\n\\]\n\\[\n\\forall x (\\text{Planeta}(x) \\rightarrow (\\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x))))\n\\]\nSentença 4: Nenhum cientista que é cético acredita em todos os mitos.\n\\[\n\\neg \\exists x (Cientista(x) \\wedge Cético(x) \\wedge \\forall y (Mito(y) \\rightarrow Acredita(x,y)))\n\\]\n\\[\n\\forall x ((\\text{Cientista}(x) \\wedge \\text{Cético}(x)) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Cientista}(x) \\rightarrow (\\text{Cético}(x) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y))))\n\\]\nSentença 5: Alguns filósofos que escrevem sobre ética também leem ou estudam psicologia.\n\\[\n\\exists x (\\text{Filósofo}(x) \\wedge \\text{EscreveSobreÉtica}(x) \\wedge (\\text{Lê}(x, \\text{\"Psicologia\"}) \\vee \\text{Estuda}(x, \\text{\"Psicologia\"})))\n\\]\n\\[\n\\exists x (\\text{Filósofo}(x) \\wedge \\text{EscreveSobreÉtica}(x) \\rightarrow (\\text{Lê}(x, \\text{\"Psicologia\"}) \\vee \\text{Estuda}(x, \\text{\"Psicologia\"})))\n\\]\n\\[\n\\exists x (\\text{Filósofo}(x) \\land \\text{EscreveSobreÉtica}(x) \\land (\\text{Lê}(x) \\lor \\text{\"Psicologia\"}(x)))\n\\]\nSentença 6: Para todo escritor, existe pelo menos um livro que ele escreveu e que é tanto criticado quanto admirado.\n\\[\n\\forall x (\\text{Escritor}(x) \\rightarrow \\exists y (\\text{Livro}(y) \\wedge \\text{Escreveu}(x, y) \\wedge \\text{Criticado}(y) \\wedge \\text{Admirado}(y)))\n\\]\n\\[\n\\exists x (\\text{Escritor}(x) \\wedge \\exists y (\\text{Livro}(y) \\wedge \\text{Escreveu}(x, y) \\wedge (\\text{Criticado}(y) \\wedge \\text{Admirado}(y))))\n\\]\n\\[\n\\forall x \\exists y (\\text{Escritor}(x) \\land \\text{Escreveu}(x, y) \\rightarrow (\\text{criticado}(y) \\land \\text{Admirado}(y)))\n\\]\n\n\n5.0.8 Exercícios de Conversão de Expressões Predicativas em Linguagem Natural\n1. Fórmula Lógica: \\(\\forall x (\\text{Humano}(x) \\rightarrow (\\text{Mortal}(x) \\wedge \\text{Racional}(x)))\\)\n\nPredicados:\n\n\\(Humano(x)\\): \\(x\\) é um humano.\n\\(Mortal(x)\\): \\(x\\) é mortal.\n\\(Racional(x)\\): \\(x\\) é racional.\n\nSentença em Português: Todo humano é mortal e racional.\n\n~2. Fórmula Lógica:\\(\\exists y (\\text{Livro}(y) \\wedge (\\text{Interessante}(y) \\vee \\text{Complicado}(y)))\\)\n\nPredicados:\n\n\\(Livro(y)\\): y é um livro.\n\\(Interessante(y)\\): y é interessante.\n\\(Complicado(y)\\): y é complicado.\n\nSentença em Português: Existe pelo menos um livro que é interessante ou complicado.\n\n3. Fórmula Lógica:\\(\\forall x \\forall y (\\text{Amigos}(x, y) \\rightarrow (\\text{Confiável}(x) \\wedge \\text{Honra}(x)))\\)\n\nPredicados:\n\n\\(Amigos(x, y)\\): x é amigo de y.\n\\(Confiável(x)\\): x é confiável.\n\\(Honra(x)\\): x honra y.\n\nSentença em Português: Todo amigo de alguém é confiável e honra o amigo.\n\n4. Fórmula Lógica:\\(\\exists x \\exists y (\\text{Animal}(x) \\wedge \\text{Planta}(y) \\wedge \\text{Convive}(x, y))\\)\n\nPredicados:\n\n\\(Animal(x)\\): x é um animal.\n\\(Planta(y)\\): y é uma planta.\n\\(Convive(x, y)\\): x e y convivem.\n\nSentença em Português: Existe pelo menos um animal e uma planta que convivem no mesmo ambiente.\n\n5. Fórmula Lógica:\\(\\forall x \\exists y (\\text{Professor}(x) \\rightarrow (\\text{Disciplina}(y) \\wedge \\text{Leciona}(x, y)))\\)\n\nPredicados:\n\n\\(Professor(x)\\): x é um professor.\n\\(Disciplina(y)\\): y é uma disciplina.\n\\(Leciona(x, y)\\): x leciona y.\n\nSentença em Português: Para todo professor, existe pelo menos uma disciplina que ele leciona.\n\n6. Fórmula Lógica:\\(\\exists x \\forall y (\\text{Músico}(x) \\wedge (\\text{Instrumento}(y) \\rightarrow \\text{Toca}(x, y)))\\)\n\nPredicados:\n\n\\(Músico(x)\\): x é um músico.\n\\(Instrumento(y)\\): y é um instrumento.\n\\(Toca(x, y)\\): x toca y.\n\nSentença em Português: Existe pelo menos um músico que, se algo é um instrumento, então ele toca esse instrumento.\n\n\n\n5.0.9 Exemplos Extras de conversão de sentenças em predicados\n\nTodos os pássaros voam e todos os peixes nadam.\n\\[\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\land \\forall y (Peixe(y) \\rightarrow Nada(y))\\]\nTodos os estudantes estudam ou todos os professores ensinam.\n\\[\\forall x (Estudante(x) \\rightarrow Estuda(x)) \\lor \\forall y (Professor(y) \\rightarrow Ensina(y))\\]\nTodos os cães latem e todos os gatos miam, mas nem todos os animais fazem barulho.\n\\[\\forall x (Cão(x) \\rightarrow Late(x)) \\land \\forall y (Gato(y) \\rightarrow Mia(y)) \\land \\neg \\forall z (Animal(z) \\rightarrow FazBarulho(z))\\]\nSe todos os carros são vermelhos, então todos os caminhões são azuis.\n\\[\\forall x (Carro(x) \\rightarrow Vermelho(x)) \\rightarrow \\forall y (Caminhão(y) \\rightarrow Azul(y))\\]\nTodos os planetas orbitam uma estrela e todos os asteroides orbitam o sol.\n\\[\\forall x (Planeta(x) \\rightarrow OrbitaEstrela(x)) \\land \\forall y (Asteroide(y) \\rightarrow OrbitaSol(y))\\]\nAlguns pássaros não voam.\n\\[\\exists x (Pássaro(x) \\land \\neg Voa(x))\\]\nExiste pelo menos um estudante que não estuda.\n\\[\\exists x (Estudante(x) \\land \\neg Estuda(x))\\]\nHá algum animal que não faz barulho.\n\\[\\exists x (Animal(x) \\land \\neg FazBarulho(x))\\]\nExiste um carro que não é vermelho.\n\\[\\exists x (Carro(x) \\land \\neg Vermelho(x))\\]\nHá um planeta que não orbita uma estrela.\n\\[\\exists x (Planeta(x) \\land \\neg \\exists y (Estrela(y) \\land Orbita(x, y)))\\]\nTodos os pássaros voam, mas existe um animal que não voa.\n\\[\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\land \\exists y (Animal(y) \\land \\neg Voa(y))\\]\nPara cada estudante, existe um professor que o ensina.\n\\[\\forall x (Estudante(x) \\rightarrow \\exists y (Professor(y) \\land Ensina(y, x)))\\]\nExiste um cão que late para todos os gatos.\n\\[\\exists x (Cão(x) \\land \\forall y (Gato(y) \\rightarrow Late(x, y)))\\]\nPara cada carro vermelho, existe um caminhão azul.\n\\[\\forall x (Carro(x) \\land Vermelho(x) \\rightarrow \\exists y (Caminhão(y) \\land Azul(y)))\\]\nTodos os planetas orbitam uma estrela, e existe um asteroide que orbita o sol.\n\\[(\\forall x (Planeta(x) \\rightarrow \\exists y (Estrela(y) \\land Orbita(x, y)))) \\land (\\exists z (Asteroide(z) \\land Orbita(z, Sol)))\\]\n\n\n\n5.0.10 Exemplos Extras de Conversão de Predicados em Sentenças\n\n\\(\\forall x (Gato(x) \\rightarrow (Peludo(x) \\land Dorminhoco(x)))\\)\n\\[\\text{Todo gato é peludo e dorminhoco.}\\]\n\\(\\forall y (Árvore(y) \\rightarrow (Verde(y) \\land Grande(y)))\\)\n\\[\\text{Toda árvore é verde e grande.}\\]\n\\((\\forall x (Cidade(x) \\rightarrow Populosa(x))) \\rightarrow (\\forall y (País(y) \\rightarrow Populoso(y)))\\)\n\\[\\text{Se toda cidade é populosa, então todo país é populoso.}\\]\n\\(\\forall x (Criança(x) \\rightarrow (Inocente(x) \\land Curiosa(x))) \\land \\neg \\exists y (Adulto(y) \\land (Inocente(y) \\land Curioso(y)))\\)\n\\[\\text{Toda criança é inocente e curiosa, e não existe um adulto que seja inocente e curioso.}\\]\n\\(\\forall x (Ave(x) \\rightarrow Voa(x)) \\land \\forall y (Peixe(y) \\rightarrow Nada(y))\\)\n\\[\\text{Toda ave voa e todo peixe nada.}\\]\n\\(\\exists x (Pessoa(x) \\land Feliz(x))\\)\n\\[\\text{Existe uma pessoa que é feliz.}\\]\n\\(\\exists y (Livro(y) \\land Interessante(y) \\land \\neg Longo(y))\\)\n\\[\\text{Há um livro que é interessante e não é longo.}\\]\n\\(\\exists x (Estudante(x) \\land (\\forall y (Disciplina(y) \\rightarrow Gosta(x, y))))\\)\n\\[\\text{Existe um estudante que gosta de todas as disciplinas.}\\]\n\\(\\exists x (Carro(x) \\land Rápido(x)) \\land \\exists y (Carro(y) \\land \\neg Rápido(y))\\)\n\\[\\text{Existe um carro que é rápido, e existe um carro que não é rápido.}\\]\n\\(\\neg \\exists x (Político(x) \\land Honesto(x))\\)\n\\[\\text{Não existe um político que seja honesto.}\\]\n\\[\\forall x (Cachorro(x) \\rightarrow (\\exists y (Pessoa(y) \\land Dono(y, x))))\\]\n\\[\\text{Todo cachorro tem uma pessoa que é seu dono.}\\]\n\\[\\exists x (Música(x) \\land (\\forall y (Pessoa(y) \\rightarrow Gosta(y, x))))\\]\n\\[\\text{Existe uma música que todas as pessoas gostam.}\\]\n\\[\\forall x (Estudante(x) \\rightarrow (\\exists y (Professor(y) \\land Ensina(y, x))))\\]\n\\[\\text{Para todo estudante, existe um professor que o ensina.}\\]\n\\[(\\exists x (Médico(x) \\land Competente(x))) \\land (\\forall y (Médico(y) \\rightarrow Ocupado(y)))\\]\n\\[\\text{Existe um médico que é competente, e todo médico é ocupado.}\\]\n\\[(\\forall x (Artista(x) \\rightarrow Criativo(x))) \\rightarrow (\\exists y (Pintor(y) \\land Criativo(y)))\\]\n\\[\\text{Se todo artista é criativo, então existe um pintor que é criativo.}\\]\n\n\n\n5.0.11 Ordem de Aplicação dos Quantificadores\nQuando mais de uma variável é quantificada em uma Fórmula Bem Formada como \\(\\forall y\\forall x P(x,y)\\), elas são aplicadas de dentro para fora, ou seja, a mais próxima da fórmula atômica é aplicada primeiro. Assim, \\(\\forall y\\forall x P(x,y)\\) se lê existe um \\(y\\) tal que para todo \\(x\\), \\(P(x,y)\\) se mantém ou para algum \\(y\\), \\(P(x,y)\\) se mantém para todo \\(x\\).\nAs posições dos mesmos tipos de quantificadores podem ser trocadas sem afetar o valor lógico, desde que não haja quantificadores do outro tipo entre os que serão trocados.\nPor exemplo, \\(\\forall x\\forall y\\forall z P(x,y,z)\\) é equivalente a \\(\\forall y\\forall x\\forall z P(x,y,z)\\), \\(\\forall z\\forall y\\forall x P(x,y,z)\\). O mesmo vale para o quantificador existencial.\nNo entanto, as posições de quantificadores de tipos diferentes não podem ser trocadas. Por exemplo, \\(\\forall x\\exists y P(x,y)\\) não é equivalente A\\(\\exists y\\forall x P(x,y)\\). Por exemplo, seja \\(P(x,y)\\) representando \\(x &lt; y\\) Para o conjunto dos números como universo. Então, \\(\\forall x\\exists y P(x,y)\\) se lê para todo número \\(x\\), existe um número \\(y\\) que é maior que \\(x\\), o que é verdadeiro, enquanto \\(\\exists y\\forall x P(x,y)\\) se lê existe um número que é maior que todo (qualquer) número, o que não é verdadeiro.\n\n5.0.11.1 Negação dos Quantificadores\nExiste uma equivalência entre as negações dos quantificadores. De tal forma que:\n\nNegação do Quantificador Universal ($$): A negação de uma afirmação universal significa que existe pelo menos um caso no Universo do Discurso em que a afirmação não é verdadeira. Isso pode ser expresso pela seguinte equivalência:\n\\[\\neg \\forall x \\, P(x) \\equiv \\exists x \\, \\neg P(x)\\]\nEm linguagem natural podemos entender como: negar que para todos os \\(x\\), \\(P(x)\\) é verdadeiro é equivalente a afirmar que existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\nNegação do Quantificador Existencial ( $$ ): A negação de uma afirmação existencial significa que a afirmação não é verdadeira para nenhum caso no Universo do Discurso. Isso pode ser expresso pela seguinte equivalência:\n\n\\[\\neg \\exists x \\, P(x) \\equiv \\forall x \\, \\neg P(x)\\]\nOu seja, negar que existe algum \\(x\\) tal que \\(P(x)\\) é verdadeiro é equivalente a afirmar que para todos os \\(x\\), \\(P(x)\\) não é verdadeiro.\nVamos tentar entender estas negações. Considere as expressões \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Essas fórmulas se aplicam a qualquer predicado \\(P\\), e possuem o mesmo valor de verdade para qualquer \\(P\\).\nNa lógica proposicional, poderíamos simplesmente verificar isso com uma tabela verdade, mas aqui, não podemos. Não existem proposições, conectadas por $$, $$, para construir uma tabela e não é possível determinar o valor verdade de forma genérica para uma determinada variável.\nVamos tentar entender isso com linguagem natural: afirmar que \\(\\neg (\\forall x P(x))\\) é verdadeiro significa que não é verdade que \\(P(x)\\) se aplica a todas as possíveis entidades \\(x\\). Deve haver alguma entidade \\(A\\) Para a qual\\(P(a)\\) é falso. Como \\(P(a)\\) é falso, \\(\\neg P(a)\\) é verdadeiro. Isso significa que \\(\\exists x (\\neg P(x))\\) é verdadeiro. Portanto, a verdade de \\(\\neg (\\forall x P(x))\\)implica a verdade de \\(\\exists x (\\neg P(x))\\).\nSe \\(\\neg (\\forall x P(x))\\) é falso, então \\(\\forall x P(x)\\) é verdadeiro. Como \\(P(x)\\) é verdadeiro para todos os \\(x\\), \\(\\neg P(x)\\) é falso para todos os \\(x\\). Logo, \\(\\exists x (\\neg P(x))\\) é falso.\nOs valores de verdade de \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\) são os mesmos. Como isso é verdadeiro para qualquer predicado \\(P\\), essas duas fórmulas são logicamente equivalentes, e podemos escrever \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\).\nMuita lógica? Que tal se tentarmos novamente, usando um pouco mais de linguagem natural. Considere as expressões lógicas \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Para ilustrar essas fórmulas, vamos usar um exemplo com um predicado \\(P(x)\\) que se aplica a uma entidade \\(x\\) se \\(x\\) é feliz.\nA expressão \\(\\forall x P(x)\\) significa que todos são felizes. A negação dessa afirmação, \\(\\neg (\\forall x P(x))\\), equivale logicamente a \\(\\exists x (\\neg P(x))\\), ou seja, existe pelo menos um indivíduo que não é feliz.\nA expressão \\(\\exists x (\\neg P(x))\\) significa que existe alguém que não está feliz. Você pode ver que isso é apenas outra forma de expressar a ideia contida em \\(\\neg (\\forall x P(x))\\).\nA afirmação de que não é verdade que todos estão felizes implica que deve haver alguém que não está feliz. Se a primeira afirmação é falsa (ou seja, todos estão felizes), então a segunda afirmação também deve ser falsa.\nPortanto, as duas fórmulas têm o mesmo valor verdade. Elas são logicamente equivalentes e podem ser representadas como \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\). Esta equivalência reflete uma relação profunda e intuitiva em nosso entendimento de declarações sobre entidades em nosso mundo.\n\n\n\nExpressão\nEquivalência\n\n\n\n\n\\(\\forall x P(x)\\)\n\\(\\neg \\exists x \\neg P(x)\\)\n\n\n\\(\\exists x \\, P(x)\\)\n\\(\\neg \\forall x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\forall x \\, P(x)\\)\n\\(\\exists x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\exists x \\, P(x)\\)\n\\(\\forall x \\, \\neg P(x)\\)\n\n\n\nTabela 5 - Equivalências entre Quantificadores.\n\n\n\n5.0.12 Regras de Inferência usando Quantificadores\nAs regras de inferência com quantificadores lidam especificamente com as proposições que envolvem quantificadores. Estas regras nos permitem fazer generalizações ou especificações, transformando proposições universais em existenciais, e vice-versa. Compreender essas regras é essencial para aprofundar o entendimento da estrutura da lógica, o que nos permite analisar e construir argumentos mais complexos de forma precisa e coerente.\nNos próximos tópicos, exploraremos essas regras em detalhes, observando como elas interagem com os quantificadores universal e existencial.\n\n5.0.12.1 Repetição\nA regra de Repetição permite repetir uma afirmação. Esta regra é útil para propagar premissas em uma prova formal.\n\\[F\\]\n\\[\n\\begin{aligned}\n&F\\\\\n\\hline\n&F\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: o céu está azul.\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações da Repetição:\n\nReafirmar premissas em provas longas. Por exemplo:\n\nProposição: todos os homens, \\(H(x)\\), são mortais, M(x)$.\nConclusão: logo, todos os homens são mortais.\n\n\n\\[\n\\begin{aligned}\n&\\forall x(H(x) \\rightarrow M(x))\\\\\n\\hline\n&\\forall x(H(x) \\rightarrow M(x))\n\\end{aligned}\n\\]\n\nIntroduzir suposições em provas indiretas. Por exemplo:\n\nProposição: suponha que \\((2 + 2 = 5)\\).\nConclusão: logo, (2 + 2 = 5)$.\n\n\n\\[\n\\begin{aligned}\n&2 + 2 = 5\\\\\n\\hline\n&2 + 2 = 5\n\\end{aligned}\n\\]\n\nDerivar instâncias de generalizações. Por exemplo:\n\nProposição: para todo \\(x\\), \\(x + 0 = x\\).\nConclusão: logo, _\\(2 + 0 = 2\\).\n\n\n\\[\n\\begin{aligned}\n&\\forall x(x + 0 = x)\\\\\n\\hline\n&2 + 0 = 2\n\\end{aligned}\n\\]\n\n\n5.0.12.2 Instanciação Universal\nA regra de Instanciação Universal permite substituir a variável em uma afirmação universalmente quantificada por um termo concreto. Esta regra nos permite derivar casos particulares a partir de afirmações gerais.\n\\[\\forall x P(x)\\]\n\\[\\begin{aligned}\n&\\forall x P(x)\\\\\n\\hline\n&P(a)\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição: todos os humanos são mortais.\nConclusão: logo, Sócrates é mortal. Assumindo que Sócrates é humano.\n\nExemplo completo de aplicação:\n\nPremissa 1: todos os mamíferos respiram ar: \\(\\forall x(M(x) \\rightarrow R(x))\\);\nPremissa 2: a baleia é um mamífero: \\(M(b)\\);\nAplicação da Instanciação Universal à Premissa 1: \\(M(b) \\rightarrow R(b)\\);\nAplicação de Modus Ponens:\n\\[\\begin{aligned}\n&M(b) \\rightarrow R(b)\\\\\n&M(b)\\\\\n\\hline\n&R(b)\n\\end{aligned}\\]\nConclusão: logo, a baleia respira ar: \\(R(b)\\)\n\nAlgumas aplicações da Instanciação Universal:\n\nAplicar regras e princípios gerais. Por exemplo:\n\nProposição: todos os triângulos têm 180 graus internos: \\(\\forall t(T(t) \\rightarrow 180^\\circ(t))\\);\nPremissa adicional: ABC é um triângulo: \\(T(\\text{Triângulo }ABC)\\);\nAplicação da Instanciação Universal: \\(T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\);\nAplicação de Modus Ponens:\n\n\\[\\begin{aligned}\n&T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\\\\n&T(\\text{Triângulo }ABC)\\\\\n\\hline\n&180^\\circ(\\text{Triângulo }ABC)\n\\end{aligned}\\]\n\nConclusão: logo, o triângulo \\(ABC\\) tem 180 graus.\n\nTestar propriedades em membros de conjuntos. Por exemplo:\n\nProposição: todo inteiro é maior que seu antecessor: \\(\\forall n (\\mathbb{Z}(n) \\rightarrow (n &gt; n-1))\\);\nPremissa adicional: 5 é um inteiro: \\(\\mathbb{Z}(5)\\);\nAplicação da Instanciação Universal: \\(\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\);\nAplicação de Modus Ponens:\n\n\\[\\begin{aligned}\n&\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\\\\n&\\mathbb{Z}(5)\\\\\n\\hline\n&5 &gt; 4\n\\end{aligned}\\]\n\nConclusão: logo, \\(5\\) é maior que \\(4\\).\n\n\n\n\n5.0.12.3 Generalização Existencial\nA regra de Generalização Existencial permite inferir que algo existe a partir de uma afirmação concreta. Esta regra nos permite generalizar de exemplos específicos para a existência geral.\n\\[P(a)\\]\n\\[\n\\begin{aligned}\nP(a)\\\\\n\\hline\n\\exists x P(x)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: Rex é um cachorro.\nConclusão: logo, existe pelo menos um cachorro.\n\nAlgumas aplicações da Generalização Existencial:\n\nInferir existência a partir de exemplos concretos. Por exemplo:\n\nProposição: o urânio-235 é radioativo.\nConclusão: logo, existe pelo menos um elemento químico radioativo.\n\n\n\\[\n\\begin{aligned}\n&R(u_{235})\\\\\n\\hline\n&\\exists x R(x)\n\\end{aligned}\n\\]\n\nConcluir que uma propriedade não é vazia. Por exemplo:\n\nProposição: $7 $ é um número primo.\nConclusão: logo, existe pelo menos um número primo.\n\n\n\\[\n\\begin{aligned}\n&P(7)\\\\\n\\hline\n&\\exists x P(x)\n\\end{aligned}\n\\]\n\nInferir a existência de soluções para problemas. Por exemplo:\n\nProposição: $x = 2 $ satisfaz a equação $x + 3 = 5 $.\nConclusão: logo, existe pelo menos uma solução para essa equação.\n\n\n\\[\n\\begin{aligned}\n&S(2)\\\\\n\\hline\n&\\exists x S(x)\n\\end{aligned}\n\\]\n\n\n5.0.12.4 Instanciação Existencial\nA regra de Instanciação Existencial permite introduzir um novo termo como instância de uma variável existencialmente quantificada. Esta regra nos permite derivar exemplos de afirmações existenciais.\n\\[\\exists x P(x)\\]\n\\[\n\\begin{aligned}\n&\\exists x P(x)\\\\\n\\hline\n&P(b)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: existe um cachorro com rabo curto.\nConclusão: logo, Rex tem rabo curto.\n\nAlgumas aplicações da Instanciação Existencial:\n\nDerivar exemplos de existência previamente estabelecida. Por exemplo:\n\nProposição: existem estrelas, $ e $, maiores, $M $, que o Sol, $s $.\nConclusão: logo, Alpha Centauri, \\(A\\), é maior que o Sol.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (e (x) \\land M(x, s))\\\\\n\\hline\n&M(a, s)\n\\end{aligned}\n\\]\n\nConstruir modelos satisfatíveis para predicados existenciais. Por exemplo:\n\nProposição: existem pessoas mais velhas que \\(25\\)Anos.\nConclusão: logo, John tem 30 anos.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (P(x) \\land V(x, 25))\\\\\n\\hline\n&P(j) \\land V(j, 30)\n\\end{aligned}\n\\]\n\nProvar que conjuntos não estão vazios. Por exemplo:\n\nProposição: existem números reais maiores que \\(2\\).\nConclusão: logo, \\(5\\) é um número real maior que \\(2\\).\n\n\n\\[\n\\begin{aligned}\n&\\exists x (R(x) \\land M(x, 2))\\\\\n\\hline\n&R(5) \\land M(5, 2)\n\\end{aligned}\n\\]",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html",
    "href": "05-formas-normais-e-skolemizacao.html",
    "title": "6  Formas Normais",
    "section": "",
    "text": "6.0.1 Forma Normal Negativa (FNN)\nA Forma Normal Negativa é uma representação canônica de fórmulas lógicas em que as negações são aplicadas apenas aos átomos da fórmula e não a expressões mais complexas. Em outras palavras, a negação está empurrada para dentro o máximo possível. A FNN é útil por sua simplicidade e é frequentemente um passo intermediário na conversão para outras formas normais.\nUma fórmula está na Forma Normal Negativa se:\nConverter uma fórmula para a FNN envolve os seguintes passos:",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Formas Normais</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#skolemização",
    "href": "05-formas-normais-e-skolemizacao.html#skolemização",
    "title": "6  Formas Normais",
    "section": "6.1 Skolemização",
    "text": "6.1 Skolemização\nA Skolemização é uma técnica usada na Lógica de Primeira Ordem para eliminar quantificadores existenciais em fórmulas. Consiste em substituir as variáveis existenciais por Constantes ou Funções Skolem. Considere a fórmula a seguir com um quantificador universal e um existencial:\n\\[\\forall x \\exists y P(x,y)\\]\nAo aplicar a Skolemização, a variável existencial \\(y\\) é substituída por uma Função de Skolem \\(f(x)\\):\n\\[P(x,f(x))\\]\nPara uma fórmula com dois quantificadores universais e dois existenciais:\n\\[\\forall x \\forall z \\exists y \\exists w R(x,y,z,w)\\]\nA Skolemização resultará em:\n\\[\\forall x \\forall z R(x,f(x),z,g(x,z))\\]\n\\(f(x)\\) e $ g(x,z)$ são Funções Skolem introduzidas para substituir as variáveis existenciais \\(y\\) e $w $ respectivamente. A escolha entre usar uma Constante Skolem ou uma Função Skolem durante a Skolemização depende do escopo dos quantificadores na fórmula original. Aqui estão as regras e passos para realizar a Skolemização de forma mais explicativa:\nPasso 1: Identificar os Quantificadores Existenciais: comece identificando os quantificadores existenciais na fórmula.\nPasso 2: Determinar se a Variável Existencial Depende de Variáveis Universais: para cada variável ligada a um quantificador existencial, determinamos se ela depende ou não de alguma variável universal. Isso significa verificar se existem quantificadores universais que dominam a variável existencial. Se a variável existencial não depende de variáveis universais, usamos uma Constante de Skolem. Caso contrário, usamos uma Função de Skolem que leva como parâmetros as variáveis universais que a dominam.\nPasso 3: Substituir as Variáveis Existenciais: agora, substituímos todas as variáveis existenciais na fórmula original de acordo com as decisões tomadas no Passo 2. Se usarmos Constantes de Skolem, substituímos as variáveis existenciais diretamente pelas constantes. Se usarmos Funções de Skolem, substituímos as variáveis existenciais pelas funções de Skolem aplicadas às variáveis universais apropriadas.\nExemplo 1: considere a Fórmula Bem Formada dada por: \\(\\forall x \\exists y \\ P(x,y)\\)\n\nIdentificamos o quantificador existencial que introduz a variável \\(y\\).\nA variável \\(y\\) não depende de nenhuma variável universal, então usamos uma Constante de Skolem, digamos \\(a\\). A fórmula se torna:\n\\[\\forall x \\ P(x,a)\\]\n\nExemplo 2: considere a fórmula original: \\(\\forall x \\forall z \\exists y \\ Q(x,y,z)\\)\n\nIdentificamos o quantificador existencial que introduz a variável \\(y\\).\nA variável \\(y\\) depende de duas variáveis universais, \\(x\\) e \\(z\\). Portanto, usamos uma Função de Skolem, digamos \\(f(x,z)\\). A fórmula se torna:\n\\[\\forall x \\forall z \\ Q(x,f(x,z),z)\\]\n\nSubstituímos \\(y\\) por \\(f(x,z)\\), que é uma função que depende das variáveis universais \\(x\\) e \\(z\\).\nEm resumo, a Skolemização simplifica fórmulas quantificadas, eliminando quantificadores existenciais e substituindo variáveis por Constantes ou Funções de Skolem, dependendo de sua relação com quantificadores universais. Isso auxilia na conversão de fórmulas quantificadas para a Forma Normal Conjuntiva e na simplificação da lógica.\n\n6.1.1 Exemplos de conversão em formas normais, conjuntiva e disjuntiva\n\nTodos os alunos estudam ou alguns professores ensinam matemática\n\nLógica de Primeiro Grau:\n\\[\\forall x(\\text{Aluno}(x) \\rightarrow \\text{Estuda}(x)) \\lor \\exists y(\\text{Professor}(y) \\land \\text{EnsinaMatemática}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Aluno}(x) \\lor \\text{Estuda}(x)\\]\nAdicionando a disjunção existencial:\n\\[(\\neg \\text{Aluno}(x) \\lor \\text{Estuda}(x)) \\land (\\text{Professor}(y) \\land \\text{EnsinaMatemática}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando o consequente do implicador:\n\\[\\text{Aluno}(x) \\land \\neg \\text{Estuda}(x)\\]\nAdicionando a conjunção existencial negada:\n\\[(\\text{Aluno}(x) \\land \\neg \\text{Estuda}(x)) \\lor (\\neg \\text{Professor}(y) \\lor \\neg \\text{EnsinaMatemática}(y))\\]\n\n\nAlgum aluno estuda e todo professor ensina\n\nLógica de Primeiro Grau:\n\\[\\exists x(\\text{Aluno}(x) \\land \\text{Estuda}(x)) \\land \\forall y(\\text{Professor}(y) \\rightarrow \\text{Ensina}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Professor}(y) \\lor \\text{Ensina}(y)\\]\nAdicionando a conjunção existencial:\n\\[(\\text{Aluno}(x) \\land \\text{Estuda}(x)) \\land (\\neg \\text{Professor}(y) \\lor \\text{Ensina}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando a conjunção existencial:\n\\[\\neg \\text{Aluno}(x) \\lor \\neg \\text{Estuda}(x)\\]\nAdicionando a conjunção negada do consequente do implicador:\n\\[(\\neg \\text{Aluno}(x) \\lor \\neg \\text{Estuda}(x)) \\lor (\\text{Professor}(y) \\land \\neg \\text{Ensina}(y))\\]\n\n\nTodo estudante é inteligente ou algum professor é sábio\n\nLógica de Primeiro Grau:\n\\[\\forall x(\\text{Estudante}(x) \\rightarrow \\text{Inteligente}(x)) \\lor \\exists y(\\text{Professor}(y) \\land \\text{Sábio}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Estudante}(x) \\lor \\text{Inteligente}(x)\\]\nAdicionando a disjunção existencial:\n\\[(\\neg \\text{Estudante}(x) \\lor \\text{Inteligente}(x)) \\land (\\text{Professor}(y) \\land \\text{Sábio}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando o consequente do implicador:\n\\[\\text{Estudante}(x) \\land \\neg \\text{Inteligente}(x)\\]\nAdicionando a conjunção existencial negada:\n\\[(\\text{Estudante}(x) \\land \\neg \\text{Inteligente}(x)) \\lor (\\neg \\text{Professor}(y) \\lor \\neg \\text{Sábio}(y))\\]\n\n\nTodo animal corre ou algum pássaro voa\n\nLógica de Primeiro Grau:\n\\[\\forall x(\\text{Animal}(x) \\rightarrow \\text{Corre}(x)) \\lor \\exists y(\\text{Pássaro}(y) \\land \\text{Voa}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Animal}(x) \\lor \\text{Corre}(x)\\]\nAdicionando a disjunção existencial:\n\\[(\\neg \\text{Animal}(x) \\lor \\text{Corre}(x)) \\land (\\text{Pássaro}(y) \\land \\text{Voa}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando o consequente do implicador:\n\\[\\text{Animal}(x) \\land \\neg \\text{Corre}(x)\\]\nAdicionando a conjunção existencial negada:\n\\[(\\text{Animal}(x) \\land \\neg \\text{Corre}(x)) \\lor (\\neg \\text{Pássaro}(y) \\lor \\neg \\text{Voa}(y))\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Formas Normais</span>"
    ]
  },
  {
    "objectID": "06-construcao-de-mundos-logicos.html",
    "href": "06-construcao-de-mundos-logicos.html",
    "title": "7  Mundos na Lógica de Primeira Ordem",
    "section": "",
    "text": "A lógica de primeira ordem, também conhecida como lógica de predicados de primeira ordem, emergiu no final do século XIX e início do século XX, principalmente através dos trabalhos de Gottlob Frege, Bertrand Russell e Alfred North Whitehead. Essa lógica foi desenvolvida como uma extensão da lógica proposicional, permitindo a representação de afirmações mais complexas sobre objetos e suas relações. A lógica de primeira ordem tornou-se uma ferramenta fundamental na matemática, filosofia e ciência da computação, especialmente na formalização de sistemas dedutivos e na fundamentação da matemática.\nA capacidade de definir “mundos” ou estruturas dentro da lógica de primeira ordem é que permite modelar e analisar sistemas complexos. Esses mundos representam interpretações ou modelos que atribuem significado às fórmulas lógicas, permitindo verificar a validade de argumentos, provar teoremas e desenvolver sistemas de inteligência artificial. Na ciência da computação, por exemplo, a lógica de primeira ordem é usada em linguagens de programação declarativas, sistemas de banco de dados e na verificação de software.\n\n7.0.1 Definição Formal de um Mundo\nNa lógica de primeira ordem, um mundo ou modelo é uma estrutura que consiste em:\n\nDomínio de Discurso (\\(D\\)): Um conjunto não vazio de objetos sobre os quais as variáveis quantificadas podem se referir. Exemplo: \\(D = \\{1, 2, 3, 4, 5\\}\\) (um domínio de números inteiros de 1 a 5)\nSímbolos de Constantes: Elementos específicos do domínio que são nomeados. Exemplo: \\(a = 1\\), \\(b = 3\\) (sendo que \\(a\\) e \\(b\\) são constantes que se referem a elementos específicos do domínio)\nSímbolos de Função: Mapeamentos de elementos do domínio para outros elementos dentro do domínio. Exemplo: \\(f(x) = x + 1\\) (uma função que mapeia cada elemento do domínio para seu sucessor)\nSímbolos de Predicado: Propriedades ou relações que podem ser atribuídas aos elementos do domínio. Exemplo: \\(P(x)\\): “x é par”, \\(R(x, y)\\): “x é menor que y”\nInterpretação: Uma função que atribui significado aos símbolos não lógicos (constantes, funções e predicados) em termos do domínio. Exemplo:\n\n\\(I(a) = 1\\)\n\\(I(f(2)) = 3\\)\n\\(I(P) = \\{2, 4\\}\\)\n\\(I(R) = \\{(1,2), (1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,4), (3,5), (4,5)\\}\\)\n\n\nUm modelo \\(M\\) para uma linguagem \\(L\\) é então definido como \\(M = (D, I)\\), sendo que \\(D\\) é o domínio e \\(I\\) é a interpretação.\nNeste exemplo, temos um modelo \\(M\\) no qual:\n\\[M = (\\{1, 2, 3, 4, 5\\}, I)\\]\ncom \\(I\\) definido como acima. Este modelo representa um “mundo” no qual podemos fazer afirmações sobre números inteiros de 1 a 5, suas relações de ordem e paridade.\n\n\n7.0.2 Construção de Mundos\nVamos ilustrar a definição acima com um exemplo concreto.\nDomínio de Objetos (\\(D\\)):\n\\[D = \\{ a, b, c \\}\\]\nOnde: \\(a\\), \\(b\\) e \\(c\\) são objetos distintos no domínio.\nSímbolos de Constante: \\(e\\): representa um elemento específico do domínio.\nSímbolos de Função: \\(f(x)\\): “o melhor amigo de x.”\nSímbolos de Predicado:\n\n\\(P(x)\\): “x é uma pessoa.”\n\\(Q(x)\\): “x é um animal.”\n\\(R(x, y)\\): “x gosta de y.”\n\nInterpretação no Mundo: atribuímos significado aos símbolos não lógicos:\n\n\\(I(e) = a\\) (a constante \\(e\\) refere-se ao objeto \\(a\\))\n\\(I(f)(a) = b\\) (o melhor amigo de \\(a\\) é \\(b\\))\n\\(I(f)(b) = c\\) (o melhor amigo de \\(b\\) é \\(c\\))\n\\(I(f)(c) = a\\) (o melhor amigo de \\(c\\) é \\(a\\))\n\\(P(a)\\) é verdadeiro (a é uma pessoa).\n\\(P(b)\\) é verdadeiro (b é uma pessoa).\n\\(P(c)\\) é falso (c não é uma pessoa).\n\\(Q(c)\\) é verdadeiro (c é um animal).\n\\(R(a, c)\\) é verdadeiro (a gosta de c).\n\\(R(b, c)\\) é verdadeiro (b gosta de c).\n\\(R(a, b)\\) é falso (a não gosta de b).\n\nRepresentação Formal do Mundo:\nAs informações acima podem ser formalizadas através das seguintes fórmulas:\n\n\\(P(a) \\land P(b) \\land \\neg P(c)\\): a e b são pessoas; c não é.\n\\(Q(c)\\): c é um animal.\n\\(R(a, c) \\land R(b, c) \\land \\neg R(a, b)\\): a e b gostam de c; a não gosta de b.\n\\(f(a) = b \\land f(b) = c \\land f(c) = a\\): representação da função “melhor amigo”.\n\\(e = a\\): a constante \\(e\\) refere-se ao objeto \\(a\\).\n\nEste mundo agora inclui não apenas predicados, mas também uma constante \\(e\\) e uma função \\(f\\), enriquecendo a estrutura e as relações entre os objetos do domínio.\nO mundo que definimos acima, embora simples, ilustra vários conceitos importantes da lógica de primeira ordem:\n\nDomínio Finito: Nosso domínio \\(D = \\{a, b, c\\}\\) é finito, o que facilita a compreensão, mas é importante notar que domínios em lógica de primeira ordem podem ser infinitos.\nRelações entre Objetos: Através dos predicados \\(P\\), \\(Q\\), e \\(R\\), estabelecemos propriedades e relações entre os objetos. Isso demonstra como a lógica de primeira ordem pode capturar informações estruturadas sobre um conjunto de entidades.\nFunções: A introdução da função \\(f\\) (melhor amigo) mostra como podemos mapear objetos do domínio para outros objetos do mesmo domínio, criando relações mais complexas.\nConstantes Nomeadas: A constante \\(e\\) ilustra como podemos nos referir diretamente a elementos específicos do domínio.\nExpressividade: Mesmo com apenas três objetos, três predicados, uma função e uma constante, somos capazes de expressar uma variedade de fatos e relações.\n\nLimitações do Exemplo:\n\nEscala: Em aplicações reais, os domínios e conjuntos de predicados e funções são geralmente muito maiores e mais complexos.\nTipos de Objetos: Nosso exemplo mistura pessoas e animais no mesmo domínio. Em modelos mais sofisticados, poderíamos usar tipos ou sortes para distinguir diferentes categorias de objetos.\nRelações Temporais: Este modelo é estático. Em muitas aplicações, precisaríamos representar como as relações mudam ao longo do tempo.\nIncerteza: A lógica de primeira ordem clássica lida com afirmações definitivamente verdadeiras ou falsas. Não há representação direta de probabilidades ou incertezas.\n\nExtensões Possíveis: para tornar este mundo mais rico e realista, poderíamos:\n\nAdicionar mais objetos ao domínio.\nIntroduzir predicados mais complexos, como \\(Irmão(x,y)\\) ou \\(MaisVelho(x,y)\\).\nDefinir funções adicionais, como \\(Idade(x)\\) ou \\(Pai(x)\\).\nIncorporar axiomas que expressem regras gerais sobre o mundo, como \\(\\forall x (P(x) \\rightarrow \\neg Q(x))\\) (nada pode ser simultaneamente uma pessoa e um animal).\n\nEste exemplo simplificado serve como um ponto de partida para entender como modelos mais complexos podem ser construídos na lógica de primeira ordem para representar conhecimento e raciocinar sobre domínios mais sofisticados.\n\n\n7.0.3 Aplicações e Importância\nA definição de mundos na lógica de primeira ordem tem aplicações fundamentais em diversas áreas, abrangendo desde a matemática pura até as ciências aplicadas e a engenharia, passando pela biologia e economia. Na matemática, essa abordagem suporta a prova de teoremas, onde modelos são utilizados para verificar a consistência de sistemas axiomáticos e construir contraexemplos. A teoria dos modelos, um ramo importante da lógica matemática, se dedica ao estudo das relações entre estruturas matemáticas e as linguagens formais que as descrevem. Além disso, nos fundamentos da matemática, a lógica de primeira ordem desempenha um papel central na formalização de conceitos matemáticos, como exemplificado pela Teoria dos Conjuntos de Zermelo-Fraenkel com o Axioma da Escolha (ZFC).\n\n\n7.0.4 A Teoria dos Modelos\nA teoria dos modelos estuda as relações entre estruturas matemáticas e as linguagens formais que as descrevem. Vamos considerar um exemplo simples, no qual analisamos a relação entre uma estrutura numérica e a linguagem formal que a descreve.\nSeja \\(M = (D, I)\\) um modelo em que:\n\\[D = \\{0, 1, 2, 3, 4, 5\\}\\]\nEste domínio representa um conjunto de números inteiros de \\(0\\) a \\(5\\). A interpretação \\(I\\) atribui significados aos símbolos não lógicos:\n\nFunção de Adição (\\(+\\)): mapeia pares de elementos do domínio para sua soma.\n\\[ I(+) : (x, y) \\mapsto (x + y \\mod 6)\\]$ (A adição é feita com módulo \\(6\\)).\nSímbolo de Constante: a constante \\(c = 3\\).\nPredicado de Paridade: \\(P(x)\\) significa “x é par”.\n\\[ I(P) = \\{0, 2, 4\\} \\]\n\nCom isso, podemos construir fórmulas na linguagem formal e verificar se são satisfeitas no modelo \\(M\\).\nRegras:\n\nA soma de dois números pares é sempre par:\n\\[ \\forall x \\forall y (P(x) \\land P(y) \\rightarrow P(x + y)) \\]\nEsta fórmula é verdadeira em \\(M\\).\nO número \\(3\\) não é par:\n\\[ \\neg P(3) \\]\nEsta fórmula também é verdadeira em \\(M\\), pois \\(3 \\notin \\{0, 2, 4\\}\\).\nA adição em \\(M\\) é comutativa:\n\\[ \\forall x \\forall y (x + y = y + x) \\]\nEsta fórmula é verdadeira, uma vez que a adição em \\(M\\) é comutativa no módulo \\(6\\).\n\nNeste exemplo, a estrutura matemática \\(M\\) é um conjunto de números inteiros de \\(0\\) a \\(5\\) com a operação de adição módulo \\(6\\). As fórmulas na linguagem formal são expressões que descrevem propriedades de números, como paridade e comutatividade da adição.\nA teoria dos modelos nos permite verificar se essas fórmulas são satisfeitas em \\(M\\). O estudo dessas relações entre fórmulas e estruturas é central na lógica matemática e fundamenta muitas áreas, como a álgebra e a aritmética, além de fornecer ferramentas para analisar a consistência de teorias matemáticas.\nAs ciências cognitivas constituem outro campo que faz uso extensivo do conceito de mundos. A modelagem cognitiva se baseia na representação formal de processos de raciocínio e tomada de decisão, enquanto a psicologia do raciocínio estuda como os seres humanos realizam inferências lógicas, muitas vezes comparando o raciocínio humano com os princípios formais da lógica. A engenharia de sistemas também faz uso do conceito de mundos. A especificação de requisitos e a modelagem de domínio se apoiam na capacidade de descrever formalmente sistemas complexos e suas interações, bem como representar conhecimento específico de domínio em diversos sistemas de engenharia. Entretanto, precisamos destacar duas áreas importantes para este trabalho: a ciência da computação e a linguística computacional.\n\n7.0.4.1 Aplicações na Ciência da Computação\nNa ciência da computação, as aplicações são vastas e variadas. No campo da inteligência artificial, a representação de conhecimento se beneficia enormemente da capacidade de modelar domínios complexos para sistemas especialistas e agentes inteligentes. O planejamento automatizado utiliza a descrição de estados do mundo e ações para resolver problemas, enquanto o processamento de linguagem natural depende da análise semântica de textos e da compreensão de contexto. Em bancos de dados, a modelagem conceitual e as consultas semânticas se apoiam fortemente em princípios lógicos para descrever formalmente esquemas e expressar consultas complexas. A verificação de software também se beneficia, com métodos formais sendo empregados para especificar e verificar propriedades de sistemas, e técnicas de model checking permitindo a verificação automática de propriedades em sistemas de estados finitos.\n\n7.0.4.1.1 Exemplo 1 - Diagnóstico Médico\nEm sistemas especialistas de diagnóstico médico, a capacidade de definir e manipular mundos lógicos permite:\n\nRaciocínio sobre cenários hipotéticos: um sistema especialista pode criar um mundo lógico \\(M = (D, I)\\) representando um paciente com sintomas específicos:\n\\[D = \\{p, f, t, d, c, g, a\\}\\]\nOnde \\(p\\) representa o paciente, \\(f\\) (febre), \\(t\\) (tosse), \\(d\\) (dor de cabeça), \\(c\\) (COVID-19), \\(g\\) (gripe), e \\(a\\) (alergia) são elementos do domínio.\nA interpretação \\(I\\) define predicados como:\n\n\\(S(x,y)\\): “x tem sintoma y”\n\\(D(x,z)\\): “x tem doença z”\n\\(T(x,w)\\): “x fez teste w”\n\nO sistema pode então raciocinar sobre um cenário hipotético onde:\n\\[S(p,f) \\land S(p,t) \\land \\neg S(p,d)\\]\nEste mundo representa um paciente com febre e tosse, mas sem dor de cabeça.\nPlanejamento de ações em ambientes complexos: baseado no mundo atual, o sistema pode planejar uma sequência de testes diagnósticos. Por exemplo, podemos definir uma função de ação \\(A(x,y)\\) que representa “realizar ação y no paciente x”.\nO sistema pode usar regras como:\n\\[\\forall x (S(x,f) \\land S(x,t) \\rightarrow A(x, \\text{\"testar_covid\"}))\\]\n\\[\\forall x (S(x,t) \\land \\neg S(x,f) \\rightarrow A(x, \\text{\"testar_alergia\"}))\\]\nAssim, no nosso cenário hipotético, o sistema recomendaria testar para COVID-19.\nInferência de novas informações a partir de dados existentes: o sistema pode usar regras de inferência para derivar novos fatos. Por exemplo:\n\\[\\forall x (S(x,f) \\land S(x,t) \\land T(x, \\text{\"covid_positivo\"}) \\rightarrow D(x,c))\\]\n\\[\\forall x (S(x,f) \\land S(x,t) \\land T(x, \\text{\"covid_negativo\"}) \\land T(x, \\text{\"gripe_positivo\"}) \\rightarrow D(x,g))\\]\nSe adicionarmos ao nosso mundo \\(T(p, \\text{\"covid_positivo\"})\\), o sistema pode inferir \\(D(p,c)\\), concluindo que o paciente tem COVID-19.\nValidação de consistência em bases de conhecimento: o sistema pode verificar se o diagnóstico proposto é consistente com o conhecimento existente. Por exemplo, podemos ter uma regra de consistência:\n\\[\\forall x \\neg(D(x,c) \\land D(x,g))\\]\nEsta regra afirma que um paciente não pode ter COVID-19 e gripe simultaneamente. Se o sistema tentar adicionar \\(D(p,g)\\) ao mundo no qual já existe \\(D(p,c)\\), ele detectará uma inconsistência.\nAlém disso, o sistema pode usar regras de integridade mais complexas, como:\n\\[\\forall x (D(x,c) \\rightarrow \\exists y (S(x,y) \\land (y = f \\lor y = t \\lor y = d)))\\]\nEsta regra afirma que se um paciente tem COVID-19, ele deve ter pelo menos um dos sintomas: febre, tosse ou dor de cabeça.\n\nNeste exemplo expandido, o mundo lógico permite ao sistema especialista:\n\nRepresentar e raciocinar sobre o estado de saúde do paciente;\nPlanejar testes diagnósticos baseados em regras predefinidas;\nFazer inferências sobre possíveis doenças usando regras lógicas;\nGarantir a consistência do diagnóstico através de verificações de integridade.\n\n\n\n7.0.4.1.2 Exemplo 2 - Robô de Limpeza\nEm sistemas de planejamento para robôs autônomos, a capacidade de definir e manipular mundos lógicos permite:\n\nRaciocínio sobre cenários hipotéticos: um sistema de IA para um robô de limpeza pode criar um mundo lógico \\(M = (D, I)\\) representando o estado de um ambiente:\n\\[D = \\{r, s1, s2, s3, s4, p1, p2, l, d\\}\\]\n\\(r\\) representa o robô, \\(s1\\) a \\(s4\\) são setores do ambiente, \\(p1\\) e \\(p2\\) são tipos de sujeira (por exemplo, poeira e líquido), \\(l\\) é o carregador, e \\(d\\) é a lixeira.\nA interpretação \\(I\\) define predicados como:\n\n\\(Em(x,y)\\): “x está em y”;\n\\(Sujo(x,y)\\): “x está sujo com y”;\n\\(Limpo(x)\\): “x está limpo”;\n\\(TemFerramenta(x,y)\\): “x tem a ferramenta para limpar y”.\n\nO sistema pode raciocinar sobre um cenário hipotético no qual:\n\\[Em(r,s1) \\land Sujo(s2,p1) \\land Sujo(s3,p2) \\land Limpo(s4) \\land TemFerramenta(r,p1)\\]\nEste mundo representa um robô no setor 1, com setores 2 e 3 sujos, setor 4 limpo, e o robô equipado para limpar poeira.\nPlanejamento de ações em ambientes complexos: baseado no mundo atual, o sistema pode planejar uma sequência de ações de limpeza. Definimos uma função de ação \\(A(x,y,z)\\) que representa “x realiza ação y no local z”.\nO sistema pode usar regras como:\n\\[\\forall x,y,z \\left( Em(x,y) \\land Sujo(z, p_1) \\land TemFerramenta(x, p_1) \\land y \\neq z \\rightarrow A(x, \\text{\"mover\"}, z) \\right)\\]\nAssumindo que p_1 é uma constante conhecida no universo do discurso, a fórmula está sintaticamente correta. Mas se p_1 for uma variável, ela deve ser quantificada. Como está, a fórmula é ambígua e potencialmente inválida.\n\\[\\forall x,y (Em(x,y) \\land Sujo(y,p1) \\land TemFerramenta(x,p1) \\rightarrow A(x, \\text{\"limpar\"}, y))\\]\nAssim, no nosso cenário, o sistema planejaria mover o robô para o setor 2 e então limpá-lo.\nInferência de novas informações a partir de dados existentes: o sistema pode usar regras de inferência para atualizar o estado do mundo após ações. Por exemplo:\n\\[\\forall x,y (A(x, \\text{\"limpar\"}, y) \\land Sujo(y,p1) \\land TemFerramenta(x,p1) \\rightarrow Limpo(y))\\]\n\\[\\forall x,y,z (A(x, \\text{\"mover\"}, z) \\land Em(x,y) \\rightarrow Em(x,z) \\land \\neg Em(x,y))\\]\nApós a ação de limpeza no setor 2, o sistema inferiria \\(Limpo(s2)\\), atualizando o estado do mundo.\nValidação de consistência em bases de conhecimento: o sistema pode verificar se o estado do mundo é consistente após cada ação. Por exemplo, podemos ter regras de consistência:\n\\[\\forall x \\neg(Limpo(x) \\land Sujo(x,p1))\\]\n\\[\\forall x,y,z (Em(x,y) \\land Em(x,z) \\rightarrow y = z)\\]\nA primeira regra afirma que um setor não pode estar limpo e sujo ao mesmo tempo. A segunda garante que o robô só pode estar em um lugar de cada vez.\nAlém disso, o sistema pode usar regras de integridade mais complexas, como:\n\\[\\forall x ((\\exists y Sujo(x,y)) \\rightarrow \\neg Limpo(x))\\]\nEsta regra afirma que se um setor está sujo com qualquer tipo de sujeira, ele não pode ser considerado limpo.\n\nNeste exemplo, o mundo lógico permite ao sistema de IA do robô de limpeza:\n\nRepresentar e raciocinar sobre o estado do ambiente e do próprio robô;\nPlanejar ações de limpeza baseadas em regras predefinidas e no estado atual;\nFazer inferências sobre os resultados das ações, atualizando o estado do mundo;\nGarantir a consistência do estado do mundo através de verificações de integridade.\n\nEste uso sofisticado da lógica de primeira ordem demonstra como sistemas de IA podem manipular informações complexas e realizar raciocínios avançados em domínios de planejamento e execução de tarefas autônomas.\n\n\n\n7.0.4.2 Aplicações na Linguística Computacional\nNa linguística computacional, a semântica formal emprega a lógica de primeira ordem para modelar o significado de sentenças e discursos em linguagens naturais. As gramáticas formais, por sua vez, se beneficiam dessa abordagem na descrição da estrutura sintática de linguagens, e a análise do discurso utiliza esses princípios para representar contexto e relações entre sentenças em textos.\n\n7.0.4.2.1 Exemplo 1 - Gramática Formal\nNa linguística, particularmente no estudo de gramáticas formais, a lógica de primeira ordem pode ser usada para definir e analisar estruturas sintáticas. Considere o seguinte exemplo de um mundo lógico representando uma gramática simplificada:\nSeja \\(M = (D, I)\\) um modelo em que:\n\\[\nD = \\{s, np, vp, n, v, det, \\text{\"o\"}, \\text{\"gato\"}, \\text{\"caça\"}, \\text{\"rato\"}\\}\n\\]\n\\(s\\) (sentença), \\(np\\) (sintagma nominal), \\(vp\\) (sintagma verbal), \\(n\\) (substantivo), \\(v\\) (verbo), \\(det\\) (determinante) são categorias sintáticas, e “o”, “gato”, “caça”, “rato” são palavras.\nA interpretação \\(I\\) define predicados e funções como:\n\n\\(Categoria(x, y)\\): “x é uma palavra da categoria sintática y”\n\\(Compõe(x, y, z)\\): “x é composto por y seguido de z”\n\\(Precede(x, y)\\): “x precede imediatamente y na sentença”\n\nPodemos definir regras gramaticais usando fórmulas lógicas:\n\nRegra para sintagma nominal:\n\\[\\forall x \\forall y (Categoria(x, det) \\land Categoria(y, n) \\land Precede(x, y) \\rightarrow \\exists z (Compõe(z, x, y) \\land Categoria(z, np)))\\]\nRegra para sintagma verbal:\n\\[\\forall x (Categoria(x, v) \\rightarrow \\exists y (Compõe(y, x, x) \\land Categoria(y, vp)))\\]\nRegra para sentença:\n\\[\\forall x \\forall y (Categoria(x, np) \\land Categoria(y, vp) \\land Precede(x, y) \\rightarrow \\exists z (Compõe(z, x, y) \\land Categoria(z, s)))\\]\nAtribuição de categorias às palavras:\n\\[Categoria(\\text{\"o\"}, det)\\]\n\\[Categoria(\\text{\"gato\"}, n)\\]\n\\[Categoria(\\text{\"caça\"}, v)\\]\n\\[Categoria(\\text{\"rato\"}, n)\\]\n\nAgora, podemos usar este mundo lógico para:\n\nAnalisar estruturas sintáticas: dada a sequência de palavras “o gato caça o rato”, podemos usar as regras para derivar sua estrutura sintática:\n\\[Precede(\\text{\"o\"}, \\text{\"gato\"}) \\land Precede(\\text{\"gato\"}, \\text{\"caça\"}) \\land Precede(\\text{\"caça\"}, \\text{\"o\"}) \\land Precede(\\text{\"o\"}, \\text{\"rato\"})\\]\nA partir disso e das regras, podemos inferir:\n\\[\\exists np_1 (Compõe(np_1, \\text{\"o\"}, \\text{\"gato\"}) \\land Categoria(np_1, np))\\]\n\\[\\exists vp (Compõe(vp, \\text{\"caça\"}, \\text{\"caça\"}) \\land Categoria(vp, vp))\\]\n\\[\\exists np_2 (Compõe(np_2, \\text{\"o\"}, \\text{\"rato\"}) \\land Categoria(np_2, np))\\]\n\\[\\exists s (Compõe(s, np_1, vp) \\land Categoria(s, s))\\]\nVerificar a gramaticalidade de sentenças: podemos verificar se uma sequência de palavras forma uma sentença válida ao tentar derivar um \\(s\\) usando as regras.\nGerar sentenças gramaticais: podemos usar as regras para gerar todas as sentenças possíveis de um certo comprimento.\nEstudar ambiguidades: poderíamos estender o modelo para lidar com ambiguidades estruturais, por exemplo, adicionando regras para sintagmas preposicionais.\n\nEste exemplo demonstra como a lógica de primeira ordem pode ser usada para formalizar e raciocinar sobre estruturas gramaticais, permitindo análises sintáticas rigorosas e geração de sentenças gramaticalmente corretas.\n\nUm sintagma é um grupo de palavras que, juntas, formam uma unidade dentro de uma frase e desempenham uma função sintática específica. Cada sintagma tem um núcleo (ou “cabeça”), que é o elemento mais importante dentro do grupo e define o tipo de sintagma. O sintagma pode ser constituído apenas pelo núcleo ou por outras palavras que o acompanham, chamadas modificadores ou complementos. Existem diferentes tipos de sintagmas, dependendo da classe gramatical do núcleo:\n\nSintagma Nominal (SN): Tem um substantivo como núcleo. Exemplo: o gato preto (o núcleo é gato, um substantivo).\nSintagma Verbal (SV): Tem um verbo como núcleo. Exemplo: corre rápido (o núcleo é corre, um verbo).\nSintagma Adjetival (SAdj): Tem um adjetivo como núcleo. Exemplo: muito feliz (o núcleo é feliz, um adjetivo).\nSintagma Adverbial (SAdv): Tem um advérbio como núcleo. Exemplo: muito rapidamente (o núcleo é rapidamente, um advérbio).\nSintagma Preposicional (SP): Tem uma preposição seguida de um complemento, que pode ser um sintagma nominal ou outro. Exemplo: com cuidado (o núcleo é com, uma preposição).\n\n\n\n\n\n7.0.4.3 Exemplos Aplicação da Lógica de Primeira Ordem em Biologia e Economia\nA lógica de primeira ordem é uma ferramenta fundamenta para modelar e raciocinar sobre sistemas complexos. A seguir, a atenta leitora poderá estudar dois exemplos práticos de como a lógica de primeira ordem pode ser aplicada em biologia e economia.\n\n7.0.4.3.1 Exemplo 1 - Sistemas Biológicos\nNa biologia, a lógica de primeira ordem pode ser usada para modelar sistemas biológicos e suas interações. Considere o seguinte exemplo de um mundo lógico representando uma cadeia alimentar simplificada.\nSeja \\(M = (D, I)\\) um modelo em que:\n\\[D = \\{c, h, a, p, f\\}\\]\n\\(c\\) (cobra), \\(h\\) (gavião), \\(a\\) (antílope), \\(p\\) (planta), \\(f\\) (fruto) são organismos.\nA interpretação \\(I\\) define predicados como:\n\n\\(Come(x, y)\\): “x come y”;\n\\(Herbívoro(x)\\): “x é herbívoro”;\n\\(Carnívoro(x)\\): “x é carnívoro”;\n\\(Produtor(x)\\): “x é produtor”;\n\nPodemos usar a lógica para descrever as interações alimentares:\n\nRegras de herbívoros:\n\\[ \\forall x (Herbívoro(x) \\rightarrow \\exists y (Come(x, y) \\land Produtor(y))) \\]\n(Um herbívoro come apenas produtores).\nRegras de carnívoros:\n\\[ \\forall x (Carnívoro(x) \\rightarrow \\exists y (Come(x, y) \\land Herbívoro(y))) \\]\n(Um carnívoro come apenas herbívoros).\n\nAtribuição de categorias aos organismos:\n\\[Herbívoro(a), Produtor(p), Produtor(f), Carnívoro(c), Carnívoro(h)\\]\nAgora, podemos usar este mundo lógico para:\n\nAnalisar interações tróficas: Por exemplo, \\(Come(c, a)\\) significa que a cobra come o antílope;\nVerificar coerência ecológica: As regras acima garantem que um herbívoro não comerá um carnívoro, e que um carnívoro não comerá plantas.\n\n\n\n7.0.4.3.2 Exemplo 2 - Modelagem Econômica\nNa economia, a lógica de primeira ordem pode ser aplicada para modelar mercados e interações econômicas. Considere o seguinte exemplo de um mundo lógico representando um mercado simples com consumidores e produtos.\nSeja \\(M = (D, I)\\) um modelo em que:\n\\[D = \\{c_1, c_2, p_1, p_2, m\\}\\]\n\\(c_1\\) e \\(c_2\\) são consumidores, \\(p_1\\) e \\(p_2\\) são produtos, e \\(m\\) é o mercado.\nA interpretação \\(I\\) define predicados como:\n\n\\(Compra(x, y)\\): “x compra o produto y”\n\\(Disponível(y, m)\\): “o produto y está disponível no mercado”\n\\(Dinheiro(x, z)\\): “o consumidor x tem dinheiro z”\n\nPodemos usar a lógica para descrever transações no mercado:\n\nRegra de compra:\n\\[ \\forall x \\forall y (Dinheiro(x, z) \\land Disponível(y, m) \\land z \\geq \\text{Preço}(y) \\rightarrow Compra(x, y)) \\]\n(Um consumidor compra um produto se tiver dinheiro suficiente e o produto estiver disponível).\n\nAtribuição de valores:\n\\[Dinheiro(c_1, 100), Dinheiro(c_2, 50), Disponível(p_1, m), Disponível(p_2, m)\\]\nAgora, podemos usar este mundo lógico para:\n\nAnalisar transações: Por exemplo, \\(Compra(c_1, p_1)\\) significa que o consumidor \\(c_1\\) comprou o produto \\(p_1\\);\nVerificar restrições econômicas: As regras garantem que um consumidor só pode comprar um produto se tiver dinheiro suficiente e se o produto estiver disponível no mercado.\n\nEssa ampla gama de aplicações demonstra a versatilidade e a importância fundamental da definição de mundos na lógica de primeira ordem, estabelecendo-a como uma ferramenta essencial para o avanço do conhecimento e da tecnologia em múltiplas disciplinas. A importância da definição de mundos na lógica de primeira ordem reside em sua capacidade de:\n\nFornecer um framework rigoroso para representar conhecimento estruturado;\nPermitir raciocínio automatizado sobre informações complexas;\nFacilitar a comunicação precisa de ideias abstratas entre diferentes disciplinas;\nServir como base para o desenvolvimento de sistemas inteligentes e adaptativos.\n\nÀ medida que os sistemas se tornam mais complexos e as demandas por inteligência artificial aumentam, a habilidade de definir e trabalhar com mundos lógicos torna-se cada vez mais importante para o avanço tecnológico e científico.\n\n\n\n7.0.4.4 Exercício de Aplicação da Lógica de Primeira Ordem\nA seguir, a esforçada leitora terá a oportunidade de ver dois exercícios práticos que envolvem a aplicação da lógica de primeira ordem. O primeiro exercício aborda a coloração de um grafo, enquanto o segundo envolve grafos parcialmente coloridos. Ambos os exercícios são projetados para serem resolvidos sem o uso de funções, utilizando apenas relações e variáveis.\n\n7.0.4.4.1 Exercício 1 - Coloração de um Grafo\nImagine que você está trabalhando como engenheiro de redes para uma grande empresa de tecnologia. Sua tarefa é planejar as conexões entre os servidores da empresa, garantindo que as comunicações entre eles não criem conflitos. O problema consiste em garantir que os servidores diretamente conectados não utilizem o mesmo canal de comunicação (representado por uma cor). Você tem, no máximo, \\(n\\) servidores e deseja utilizar menos de \\(k+1\\) canais de comunicação, respeitando que cada servidor pode se conectar diretamente a um número limitado de outros servidores, cujo limite é dado pelo grau de conexão \\(m\\).\nDescrição do Problema:\n\nServidor: Representado como um nó em um grafo;\nConexão direta: Representada como uma aresta entre dois nós;\nCor: Representa o canal de comunicação atribuído a um servidor. Dois servidores diretamente conectados não podem compartilhar o mesmo canal;\nGrau de um servidor: O número de conexões diretas que ele tem com outros servidores;\nGrau de conexão da rede: O maior grau entre os servidores da rede.\n\nO objetivo é determinar uma forma de atribuir um canal de comunicação a cada servidor de forma que não haja conflitos de comunicação entre servidores diretamente conectados, utilizando menos de \\(k+1\\) canais.\nSolução: vamos usar lógica de primeira ordem para modelar este problema sem utilizar funções, apenas relações e variáveis.\n\num predicado binário \\(Cor(x, c)\\), onde \\(x\\) é um servidor e \\(c\\) é uma cor/canal;\num predicado unário \\(Servidor(x)\\), que significa que \\(x\\) é um servidor;\num predicado binário \\(Conexao(x, y)\\), que significa que \\(x\\) está diretamente conectado a \\(y\\).\n\nRegras ou Axiomas:\n\nDois servidores diretamente conectados não podem usar o mesmo canal de comunicação:\n\\[ \\forall x \\forall y \\forall c: (Servidor(x) \\land Servidor(y) \\land Conexao(x, y) \\land Cor(x, c) \\rightarrow \\neg Cor(y, c)) \\]\nCada servidor deve receber exatamente uma cor:\n\\[ \\forall x: (Servidor(x) \\rightarrow \\exists c: Cor(x, c)) \\]\n\\[ \\forall x \\forall c1 \\forall c2: (Servidor(x) \\land Cor(x, c1) \\land Cor(x, c2) \\rightarrow c1 = c2) \\]\nRestrição de grau para um servidor (no máximo \\(m\\) conexões):\n\\[ \\forall x: (Servidor(x) \\rightarrow \\neg\\exists x_1,...,x_{m+1}: (\\bigwedge_{i=1}^{m+1} Conexao(x, x_i) \\land \\bigwedge_{i \\neq j} x_i \\neq x_j)) \\]\nNúmero máximo de cores utilizadas (menos de \\(k+1\\)):\n\\[ \\neg\\exists c_1,...,c_{k+1}: (\\bigwedge_{i=1}^{k+1} (\\exists x: Servidor(x) \\land Cor(x, c_i)) \\land \\bigwedge_{i \\neq j} c_i \\neq c_j) \\]\n\nConsultas Possíveis:\nCom esse modelo, você pode fazer as seguintes consultas:\n\nVerificar se dois servidores estão diretamente conectados:\n\nConsulta: \\(Conexao(a, b)\\);\nResposta: True se o servidor \\(a\\) estiver diretamente conectado ao servidor \\(b\\), False caso contrário.\n\nVerificar qual canal de comunicação (cor) foi atribuído a um servidor:\n\nConsulta: \\(Cor(a, c)\\);\nResposta: True se o servidor \\(a\\) usa o canal \\(c\\), False caso contrário.\n\nVerificar se dois servidores conectados têm cores diferentes:\n\nConsulta: \\(Conexao(a, b) \\land \\forall c: (Cor(a, c) \\rightarrow \\neg Cor(b, c))\\);\nResposta: True se os servidores \\(a\\) e \\(b\\) estiverem diretamente conectados e tiverem cores diferentes, False se eles compartilharem a mesma cor ou não estiverem conectados.\n\nVerificar se um servidor tem mais de \\(m\\) conexões diretas:\n\nConsulta: \\(\\exists x_1,...,x_{m+1}: (\\bigwedge_{i=1}^{m+1} Conexao(a, x_i) \\land \\bigwedge_{i \\neq j} x_i \\neq x_j)\\);\nResposta: True se o servidor \\(a\\) tiver mais de \\(m\\) servidores diretamente conectados, False caso contrário.\n\nVerificar se a coloração da rede é válida:\n\nConsulta: \\(\\forall x \\forall y \\forall c: (Servidor(x) \\land Servidor(y) \\land Conexao(x, y) \\land Cor(x, c) \\rightarrow \\neg Cor(y, c))\\);\nResposta: True se todos os servidores diretamente conectados tiverem cores diferentes, False se houver algum conflito de cores.\n\n\n\n\n7.0.4.4.2 Exercício 2 - Grafos Parcialmente Coloridos\nDado um conjunto não vazio e finito de cores \\(\\{c_1, \\dots, c_k\\}\\), um grafo direcionado parcialmente colorido é uma estrutura \\(\\langle N, R, C \\rangle\\) na qual:\n\n\\(N\\) é um conjunto não vazio de nós;\n\\(R\\) é uma relação binária sobre \\(N\\);\n\\(C\\) associa cores aos nós (nem todos os nós são necessariamente coloridos, e cada nó tem no máximo uma cor).\n\nForneça uma linguagem de Lógica de Primeira Ordem e um conjunto de axiomas que formalizem grafos parcialmente coloridos. Mostre que todo modelo dessa teoria corresponde a um grafo parcialmente colorido, e vice-versa. Para cada uma das seguintes propriedades, escreva uma fórmula que seja verdadeira apenas nos grafos que satisfazem a propriedade:\n\nNós conectados não têm a mesma cor;\nO grafo contém apenas dois nós amarelos;\nComeçando de um nó vermelho, pode-se alcançar um nó verde em no máximo 4 passos;\nPara cada cor, existe pelo menos um nó com essa cor;\nO grafo é composto por \\(|C|\\) subgrafos disjuntos e não vazios, um para cada cor.\n\nSolução:\n\nUm predicado binário \\(edge\\), onde \\(edge(n, m)\\) significa que o nó \\(n\\) está conectado ao nó \\(m\\);\nUm predicado binário \\(color\\), onde \\(color(n, x)\\) significa que o nó \\(n\\) tem a cor \\(x\\);\nAs constantes \\(yellow\\), \\(green\\), \\(red\\).\n\nAxiomas e Regras:\n\nCada nó tem no máximo uma cor:\n\\[ \\forall n \\forall x: (color(n, x) \\rightarrow \\neg \\exists y: (y \\neq x \\land color(n, y))) \\]\nNós conectados não têm a mesma cor:\n\\[ \\forall n \\forall m \\forall x: (edge(n, m) \\land color(n, x) \\rightarrow \\neg color(m, x)) \\]\nO grafo contém apenas dois nós amarelos:\n\\[ \\exists n \\exists n': (color(n, yellow) \\land color(n', yellow) \\land n \\neq n' \\land \\forall m: (m \\neq n \\land m \\neq n' \\rightarrow \\neg color(m, yellow))) \\]\nComeçando de um nó vermelho, pode-se alcançar um nó verde em no máximo 4 passos: Primeiro, definimos a relação de alcançabilidade em até k passos:\n\\[ reach_k(n, m, 0) \\leftrightarrow n = m \\]\n\\[ reach_k(n, m, k+1) \\leftrightarrow reach_k(n, m, k) \\lor \\exists x (edge(n, x) \\land reach_k(x, m, k)) \\]\nEntão, a propriedade 3 é expressa como:\n\\[ \\forall n (color(n, red) \\rightarrow \\exists m (reach_k(n, m, 4) \\land color(m, green))) \\]\nPara cada cor, existe pelo menos um nó com essa cor:\n\\[ \\forall x \\exists n: color(n, x) \\]\nO grafo é composto por \\(|C|\\) subgrafos disjuntos e não vazios, um para cada cor:\n\\[ \\forall x \\exists n: color(n, x) \\land \\]\n\\[ \\forall n \\exists x: color(n, x) \\land \\]\n\\[ \\forall n \\forall m \\forall x \\forall y ((color(n, x) \\land color(m, y) \\land x \\neq y) \\rightarrow \\neg reach_k(n, m, \\infty)) \\]\nOnde \\(\\infty\\) representa um número suficientemente grande para cobrir todo o grafo.\n\nConsultas possíveis:\n\nVerificar se dois nós estão conectados:\n\nConsulta: \\(edge(a, b)\\);\nResposta: True se o nó \\(a\\) está conectado ao nó \\(b\\), False caso contrário.\n\nVerificar a cor de um nó:\n\nConsulta: \\(color(a, x)\\);\nResposta: True se o nó \\(a\\) tem a cor \\(x\\), False caso contrário.\n\nVerificar se um nó é alcançável a partir de outro em até k passos:\n\nConsulta: \\(reach_k(a, b, k)\\);\nResposta: True se o nó \\(b\\) é alcançável a partir do nó \\(a\\) em até \\(k\\) passos, False caso contrário.\n\nContar o número de nós de uma determinada cor:\n\nConsulta: \\(\\exists n_1, ..., n_m: (\\bigwedge_{i=1}^m color(n_i, x) \\land \\bigwedge_{i \\neq j} n_i \\neq n_j \\land \\forall n: (color(n, x) \\rightarrow \\bigvee_{i=1}^m n = n_i))\\);\nResposta: O maior valor de \\(m\\) para o qual esta fórmula é verdadeira é o número de nós da cor \\(x\\).\n\nVerificar se o grafo é totalmente colorido:\n\nConsulta: \\(\\forall n \\exists x: color(n, x)\\);\nResposta: True se todos os nós têm uma cor atribuída, False caso contrário.\n\n\n\n\n7.0.4.4.3 Exercício 3 - Minesweeper [:2]\nO jogo Minesweeper foi inventado por Robert Donner em 1989. O objetivo do jogo é limpar um campo minado sem detonar uma mina. A tela do jogo consiste em um campo retangular de quadrados. Cada quadrado pode ser limpo, ou descoberto, clicando nele. Se um quadrado contendo uma mina for clicado, o jogo termina. Se o quadrado não contém uma mina, uma das duas coisas acontece: (1) Um número entre 1 e 8 aparece, indicando o número de quadrados adjacentes contendo minas, ou (2) nenhum número aparece; nesse caso, não há minas nas células adjacentes.\nForneça, em uma linguagem de Lógica de Primeira Ordem, um mundo que permita formalizar o conhecimento de um jogador em um estado do jogo. Nessa linguagem, você deve ser capaz de formalizar o seguinte conhecimento:\n\nExistem exatamente \\(n\\) minas no campo minado.\nSe uma célula contém o número 1, então há exatamente uma mina nas células adjacentes.\nMostre, por meio de dedução, que deve haver uma mina na posição (3,3) no estado do jogo da figura a seguir.\n\n{: class=“lazyimg”} Figura 1 - Um estado do jogo Minesweeper.{: class=“legend”}\nSolução:\n\nUm predicado unário \\(mine\\), onde \\(mine(x)\\) significa que a célula \\(x\\) contém uma mina;\nUm predicado binário \\(adj\\), onde \\(adj(x, y)\\) significa que a célula \\(x\\) é adjacente à célula \\(y\\);\nUm predicado binário \\(contains\\), onde \\(contains(x, n)\\) significa que a célula \\(x\\) contém o número \\(n\\).\n\nRegras e Axiomas:\n\nExistem exatamente \\(n\\) minas no jogo:\n\\[ \\exists x*1 \\dots \\exists x_n \\left( \\bigwedge*{i=1}^{n} mine(x*i) \\land \\forall y (mine(y) \\rightarrow \\bigvee*{i=1}^{n} y = x_i) \\right) \\]\nSe uma célula contém o número 1, então há exatamente uma mina nas células adjacentes:\n\\[ \\forall x: (contains(x, 1) \\rightarrow \\exists z: (adj(x, z) \\land mine(z) \\land \\forall y: (adj(x, y) \\land mine(y) \\rightarrow y = z))) \\]\nMostre por meio de dedução que deve haver uma mina na posição (3,3):\nDe acordo com a figura acima, temos:\n\n\\(contains((2, 2), 1)\\);\n\\(\\neg mine((1, 1)) \\land \\neg mine((1, 2)) \\land \\neg mine((1, 3))\\);\n\\(\\neg mine((2, 1)) \\land \\neg mine((2, 2)) \\land \\neg mine((2, 3))\\);\n\\(\\neg mine((3, 1)) \\land \\neg mine((3, 2))\\).\nPodemos deduzir:\n\\(\\exists z: (adj((2, 2), z) \\land mine(z) \\land \\forall y: (adj((2, 2), y) \\land mine(y) \\rightarrow y = z))\\) (de a e axioma 2)\n\\(mine((1, 1)) \\lor mine((1, 2)) \\lor mine((1, 3)) \\lor mine((2, 1)) \\lor mine((2, 2)) \\lor mine((2, 3)) \\lor mine((3, 1)) \\lor mine((3, 2)) \\lor mine((3, 3))\\) (de e)\n\\(mine((3, 3))\\) (de b, c, d e f)\n\n\n\n\n7.0.4.4.4 Exercício 4 - Conexões Aéreas\nImagine que você é responsável pela gestão de voos entre várias cidades brasileiras. A tarefa envolve criar uma representação formal das conexões aéreas entre essas cidades, considerando diferentes tipos de voos, como voos domésticos e internacionais, e as restrições específicas que regulam essas conexões. O objetivo é formalizar essas conexões de forma que se possa responder a perguntas sobre as rotas disponíveis e as restrições envolvidas.\nDescrição do Problema:\n\nCidades brasileiras: representadas como nós de um grafo;\nVoos diretos: representados como arestas que conectam duas cidades diretamente (sem escalas intermediárias);\nTipos de voos: diferentes categorias de voos, como domésticos (doméstico) e internacionais (internacional), com restrições sobre onde eles podem operar.\nCidades pequenas: algumas cidades são classificadas como pequenas, e certas restrições se aplicam a essas cidades.\n\nSolução:\n\nAs constantes \\(SP\\), \\(RJ\\), \\(BSB\\), \\(FLN\\), \\(MAO\\) são identificadores das cidades São Paulo, Rio de Janeiro, Brasília, Florianópolis, Manaus;\nAs constantes \\(Domestico\\), \\(Internacional\\) são os identificadores dos tipos de voo;\nO predicado unário \\(Aviao(x)\\) significa que \\(x\\) é um avião;\nO predicado unário \\(Cidade(x)\\) significa que \\(x\\) é uma cidade;\nO predicado unário \\(CidadePequena(x)\\) significa que \\(x\\) é uma cidade pequena;\nO predicado binário \\(TipoVoo(x, y)\\) significa que o voo \\(x\\) é do tipo \\(y\\);\nO predicado binário \\(PertenceEstado(x, y)\\) significa que a cidade \\(x\\) está no estado \\(y\\);\nO predicado ternário \\(ConexaoDireta(x, y, z)\\) significa que o voo \\(x\\) conecta diretamente as cidades \\(y\\) e \\(z\\) (sem escalas intermediárias).\n\nRegras e Axiomas:\n\nUm avião tem exatamente um tipo de voo:\n\\[ \\forall x (Aviao(x) \\rightarrow \\exists y (TipoVoo(x, y))) \\land \\forall x y z (TipoVoo(x, y) \\land TipoVoo(x, z) \\rightarrow y = z) \\]\nO tipo Internacional é diferente do tipo Doméstico:\n\\[ \\neg (Internacional = Domestico) \\]\nUma cidade está associada a exatamente um estado:\n\\[ \\forall x (Cidade(x) \\rightarrow \\exists y (PertenceEstado(x, y))) \\land \\forall x y z (PertenceEstado(x, y) \\land PertenceEstado(x, z) \\rightarrow y = z) \\]\nCidades pequenas são cidades:\n\\[ \\forall x (CidadePequena(x) \\rightarrow Cidade(x)) \\]\nSe uma cidade \\(a\\) está conectada a uma cidade \\(b\\), então \\(b\\) também está conectada a \\(a\\):\n\\[ \\forall x y (\\exists z ConexaoDireta(z, x, y) \\rightarrow \\exists z ConexaoDireta(z, y, x)) \\]\nDefinição das constantes de cidade:\n\\[ Cidade(SP) \\land Cidade(RJ) \\land Cidade(BSB) \\land Cidade(FLN) \\land Cidade(MAO) \\]\n\nAxiomas específicos:\n\nNão há conexão direta de São Paulo para Manaus:\n\\[ \\neg \\exists x ConexaoDireta(x, SP, MAO) \\]\nExiste um voo doméstico de São Paulo para Manaus que faz escalas em Brasília, Rio de Janeiro e Florianópolis:\n\\[ \\exists x (ConexaoDireta(x, SP, BSB) \\land ConexaoDireta(x, BSB, RJ) \\land ConexaoDireta(x, RJ, FLN) \\land ConexaoDireta(x, FLN, MAO) \\land TipoVoo(x, Domestico)) \\]\nVoos domésticos conectam cidades brasileiras:\n\\[ \\forall x y z (TipoVoo(x, Domestico) \\rightarrow (ConexaoDireta(x, y, z) \\rightarrow (Cidade(y) \\land Cidade(z)))) \\]\nVoos internacionais não fazem escalas em cidades pequenas:\n\\[ \\forall x y z (ConexaoDireta(x, y, z) \\land TipoVoo(x, Internacional) \\rightarrow \\neg CidadePequena(y) \\land \\neg CidadePequena(z)) \\]\n\nConsultas Possíveis:\n\nVerificar se há uma conexão direta entre duas cidades:\n\nConsulta: \\(ConexaoDireta(a, b, c)\\);\nResposta: True se o voo \\(a\\) conecta diretamente as cidades \\(b\\) e \\(c\\), False caso contrário.\n\nVerificar o tipo de voo de um avião:\n\nConsulta: \\(TipoVoo(a, x)\\);\nResposta: True se o avião \\(a\\) opera o tipo de voo \\(x\\), False caso contrário.\n\nVerificar se duas cidades estão no mesmo estado:\n\nConsulta: \\(PertenceEstado(a, b)\\);\nResposta: True se a cidade \\(a\\) está no estado \\(b\\), False caso contrário.\n\nVerificar se um voo faz escalas apenas em cidades grandes:\n\nConsulta: \\(\\forall y z (ConexaoDireta(a, y, z) \\rightarrow (\\neg CidadePequena(y) \\land \\neg CidadePequena(z)))\\);\nResposta: True se o voo \\(a\\) não faz escalas em cidades pequenas, False caso contrário.\n\nVerificar se uma cidade pequena está conectada por um voo:\n\nConsulta: \\(\\exists x (CidadePequena(y) \\land ConexaoDireta(x, y, z))\\);\nResposta: True se a cidade pequena \\(y\\) está conectada por um voo a alguma outra cidade, False caso contrário.\n\n\n\n\n7.0.4.4.5 Exercício 5 - Jogo de Damas Brasileiro\nO jogo de damas brasileiro é jogado em um tabuleiro de 64 casas (pretas e brancas), onde dois jogadores competem com 12 peças cada (denominadas comuns). Um jogador tem peças pretas e o outro, peças brancas. O objetivo do jogo é capturar todas as peças do adversário ou impossibilitar os movimentos do adversário.\nQuando o jogo começa, as peças de cada jogador são posicionadas nas 12 casas pretas mais próximas a eles, sendo que as casas brancas não são utilizadas durante o jogo. As peças se movem apenas diagonalmente, permanecendo nas casas pretas. O jogador com peças pretas sempre faz o primeiro movimento.\nMovimentos:\nExistem quatro tipos fundamentais de movimento: o movimento comum de uma peça, o movimento comum de uma dama, o movimento de captura de uma peça e o movimento de captura de uma dama.\n\nMovimento comum de uma peça: A peça é movida diagonalmente para frente, à esquerda ou à direita, para uma casa vazia adjacente;\nMovimento comum de uma dama: A dama (uma peça que alcançou a última fileira e foi promovida) pode se mover diagonalmente em qualquer direção (frente, trás, esquerda ou direita);\nCaptura: Quando uma peça (comum ou dama) tem uma peça adversária adjacente, e a casa imediatamente além está vazia, a peça adversária pode ser capturada ao “pular” sobre ela, removendo-a do tabuleiro. Se uma peça puder realizar capturas múltiplas consecutivas, ela deve fazê-lo.\n\nObjetivo:\nO jogador vence ao capturar todas as peças do adversário ou ao impossibilitar os movimentos de seu oponente.\nFormalização em Lógica de Primeira Ordem:\n\nO predicado unário \\(square(x)\\) significa que \\(x\\) é uma casa do tabuleiro;\nO predicado unário \\(piece(x)\\) significa que \\(x\\) é uma peça;\nO predicado unário \\(white(x)\\) significa que \\(x\\) é branca;\nO predicado unário \\(black(x)\\) significa que \\(x\\) é preta;\nO predicado unário \\(common(x)\\) significa que \\(x\\) é uma peça comum;\nO predicado unário \\(dama(x)\\) significa que \\(x\\) é uma dama;\nO predicado binário \\(empty(x, t)\\) significa que a casa \\(x\\) está vazia no tempo \\(t\\);\nO predicado binário \\(contain(x, y, t)\\) significa que a casa \\(x\\) contém a peça \\(y\\) no tempo \\(t\\);\nO predicado binário \\(capture(x, y, t)\\) significa que a peça \\(x\\) capturou a peça \\(y\\) no tempo \\(t\\);\nO predicado binário \\(adjacent(x, y)\\) significa que as casas \\(x\\) e \\(y\\) são adjacentes;\nO predicado unário \\(turn(x, t)\\) significa que é a vez do jogador \\(x\\) no tempo \\(t\\);\nO predicado binário \\(lastRow(x, y)\\) significa que a casa \\(x\\) está na última fileira para o jogador com cor \\(y\\).\n\nRegras e Axiomas:\n\nCada peça é branca ou preta:\n\\[ \\forall x: (piece(x) \\rightarrow (white(x) \\lor black(x))) \\]\nCada peça é uma peça comum ou uma dama:\n\\[ \\forall x: (piece(x) \\rightarrow (common(x) \\lor dama(x))) \\]\nAs casas brancas estão sempre vazias:\n\\[ \\forall x: (square(x) \\land white(x) \\rightarrow \\forall t: empty(x, t)) \\]\nEm cada instante do jogo, as casas pretas estão vazias ou contêm uma peça:\n\\[ \\forall x: (square(x) \\land black(x) \\rightarrow \\forall t: (empty(x, t) \\lor \\exists y: contain(x, y, t))) \\]\nNo início do jogo (instante zero), há exatamente 12 peças brancas e 12 peças pretas no tabuleiro:\n\\[ \\exists p*1, \\dots, p*{12}, q*1, \\dots, q*{12}: (\\bigwedge\\*{i=1}^{12} (piece(p_i) \\land white(p_i) \\land piece(q_i) \\land black(q_i)) \\land \\]\n\\[ \\forall x: (piece(x) \\land white(x) \\rightarrow \\bigvee*{i=1}^{12} x = p*i) \\land \\]\n\\[ \\forall x: (piece(x) \\land black(x) \\rightarrow \\bigvee\\*{i=1}^{12} x = q_i)) \\]\nMovimento de peça comum:\n\\[ \\forall x, y, p, t: (common(p) \\land contain(x, p, t) \\land empty(y, t) \\land adjacent(x, y) \\land turn(color(p), t) \\rightarrow contain(y, p, t+1) \\land empty(x, t+1)) \\]\nMovimento de dama:\n\\[ \\forall x, y, p, t: (dama(p) \\land contain(x, p, t) \\land empty(y, t) \\land turn(color(p), t) \\rightarrow contain(y, p, t+1) \\land empty(x, t+1)) \\]\nCaptura:\n\\[ \\forall x, y, z, p_1, p_2, t: (piece(p_1) \\land piece(p_2) \\land color(p_1) \\neq color(p_2) \\land contain(x, p_1, t) \\land contain(y, p_2, t) \\land empty(z, t) \\land adjacent(x, y) \\land adjacent(y, z) \\land turn(color(p_1), t) \\rightarrow capture(p_1, p_2, t) \\land contain(z, p_1, t+1) \\land empty(x, t+1) \\land empty(y, t+1)) \\]\nPromoção a dama:\n\\[ \\forall x, p, t: (common(p) \\land contain(x, p, t) \\land lastRow(x, color(p)) \\rightarrow dama(p)) \\]\nVitória:\n\n\\[ \\forall t: (\\neg \\exists x: (piece(x) \\land white(x) \\land contain(y, x, t)) \\lor \\neg \\exists x: (piece(x) \\land black(x) \\land contain(y, x, t)) \\lor \\]\n\\[ \\neg \\exists x, y: (piece(x) \\land contain(y, x, t) \\land turn(color(x), t) \\land ((\\exists z: (empty(z, t) \\land adjacent(y, z))) \\lor (\\exists w, z: (piece(w) \\land color(w) \\neq color(x) \\land contain(z, w, t) \\land adjacent(y, z) \\land \\exists v: (empty(v, t) \\land adjacent(z, v)))))) \\rightarrow gameOver(t)) \\]\nConsultas Possíveis:\n\nVerificar se uma casa está vazia no tempo \\(t\\):\n\nConsulta: \\(empty(a, t)\\);\nResposta: True se a casa \\(a\\) está vazia no tempo \\(t\\), False caso contrário.\n\nVerificar qual peça está em uma casa no tempo \\(t\\):\n\nConsulta: \\(contain(a, p, t)\\);\nResposta: True se a peça \\(p\\) está na casa \\(a\\) no tempo \\(t\\), False caso contrário.\n\nVerificar se uma peça capturou outra no tempo \\(t\\):\n\nConsulta: \\(capture(x, y, t)\\);\nResposta: True se a peça \\(x\\) capturou a peça \\(y\\) no tempo \\(t\\), False caso contrário.\n\nVerificar o número total de peças de uma cor no tabuleiro:\n\nConsulta: \\(\\exists p_1, \\dots, p_n: (\\bigwedge_{i=1}^n (piece(p_i) \\land color(p_i)) \\land \\forall x: (piece(x) \\land color(x) \\rightarrow \\bigvee_{i=1}^n x = p_i))\\);\nResposta: O valor \\(n\\) corresponde ao número total de peças da cor especificada no tabuleiro naquele momento.\n\nVerificar se o jogo terminou:\n\nConsulta: \\(gameOver(t)\\);\nResposta: True se o jogo terminou no tempo \\(t\\), False caso contrário.\n\nVerificar de quem é a vez de jogar:\n\nConsulta: \\(turn(x, t)\\);\nResposta: True se é a vez do jogador \\(x\\) no tempo \\(t\\), False caso contrário.\n\nVerificar se uma peça comum foi promovida a dama:\n\nConsulta: \\(\\exists t_1, t_2: (t_1 &lt; t_2 \\land common(p, t_1) \\land dama(p, t_2))\\);\nResposta: True se a peça \\(p\\) foi promovida de comum para dama em algum momento do jogo, False caso contrário.\n\n\n\n\n7.0.4.4.6 Exercício 6 - Sudoku\nO Sudoku é um jogo de lógica jogado em um tabuleiro de 9x9, que é dividido em 9 regiões menores de 3x3. O objetivo do jogo é preencher todas as 81 casas do tabuleiro com números de 1 a 9, respeitando as seguintes regras:\n\nCada número de 1 a 9 deve aparecer exatamente uma vez em cada linha;\nCada número de 1 a 9 deve aparecer exatamente uma vez em cada coluna;\nCada número de 1 a 9 deve aparecer exatamente uma vez em cada uma das 9 regiões 3x3.\n\nO jogo começa com algumas casas já preenchidas, e o jogador deve completar as casas restantes de forma a obedecer essas regras.\nSolução:\n\nO predicado unário \\(cell(x)\\) significa que \\(x\\) é uma célula do tabuleiro;\nO predicado binário \\(value(x, v)\\) significa que a célula \\(x\\) contém o valor \\(v\\), onde \\(v\\) é um número de \\(1\\) a \\(9\\);\nO predicado binário \\(inRow(x, r)\\) significa que a célula \\(x\\) está na linha \\(r\\), onde \\(r\\) é um número de \\(1\\) a \\(9\\);\nO predicado binário \\(inColumn(x, c)\\) significa que a célula \\(x\\) está na coluna \\(c\\), onde \\(c\\) é um número de \\(1\\) a \\(9\\);\nO predicado binário \\(inRegion(x, z)\\) significa que a célula \\(x\\) está na região \\(z\\), onde \\(z\\) é um número de \\(1\\) a \\(9\\) representando uma das \\(9\\) regiões \\(3\\times 3\\).\n\nRegras e Axiomas:\n\nCada célula tem exatamente um valor entre \\(1\\) e \\(9\\):\n\\[\\forall x: (cell(x) \\rightarrow \\exists! v: (1 \\leq v \\leq 9 \\land value(x, v)))\\]\nCada linha contém os números de \\(1\\) a \\(9\\) exatamente uma vez:\n\\[\\forall r \\forall v: (1 \\leq r \\leq 9 \\land 1 \\leq v \\leq 9 \\rightarrow \\exists! x: (inRow(x, r) \\land value(x, v)))\\]\nCada coluna contém os números de \\(1\\) a \\(9\\) exatamente uma vez:\n\\[\\forall c \\forall v: (1 \\leq c \\leq 9 \\land 1 \\leq v \\leq 9 \\rightarrow \\exists! x: (inColumn(x, c) \\land value(x, v)))\\]\nCada região 3x3 contém os números de \\(1\\) a \\(9\\) exatamente uma vez:\n\\[\\forall z \\forall v: (1 \\leq z \\leq 9 \\land 1 \\leq v \\leq 9 \\rightarrow \\exists! x: (inRegion(x, z) \\land value(x, v)))\\]\nCélulas na mesma linha não podem ter o mesmo valor:\n\\[\\forall x_1 \\forall x_2 \\forall v \\forall r: (x_1 \\neq x_2 \\land value(x_1, v) \\land value(x_2, v) \\land inRow(x_1, r) \\land inRow(x_2, r) \\rightarrow \\bot)\\]\nCélulas na mesma coluna não podem ter o mesmo valor:\n\\[\\forall x_1 \\forall x_2 \\forall v \\forall c: (x_1 \\neq x_2 \\land value(x_1, v) \\land value(x_2, v) \\land inColumn(x_1, c) \\land inColumn(x_2, c) \\rightarrow \\bot)\\]\nCélulas na mesma região não podem ter o mesmo valor:\n\\[\\forall x_1 \\forall x_2 \\forall v \\forall z: (x_1 \\neq x_2 \\land value(x_1, v) \\land value(x_2, v) \\land inRegion(x_1, z) \\land inRegion(x_2, z) \\rightarrow \\bot)\\]\nCada célula está em exatamente uma linha, uma coluna e uma região:\n\\[\\forall x: (cell(x) \\rightarrow \\exists! r \\exists! c \\exists! z: (inRow(x, r) \\land inColumn(x, c) \\land inRegion(x, z)))\\]\n\nConsultas Possíveis:\n\nVerificar se uma célula está preenchida com um determinado valor no tabuleiro:\n\nConsulta: \\(value(x, v)\\);\nResposta: True se a célula \\(x\\) contém o valor \\(v\\), False caso contrário.\n\nVerificar se uma linha contém todos os números de 1 a 9:\n\nConsulta: \\(\\forall v (1 \\leq v \\leq 9 \\rightarrow \\exists! x: (inRow(x, r) \\land value(x, v)))\\);\nResposta: True se a linha \\(r\\) contém todos os números de 1 a 9, False caso contrário.\n\nVerificar se uma coluna contém todos os números de 1 a 9:\n\nConsulta: \\(\\forall v (1 \\leq v \\leq 9 \\rightarrow \\exists! x: (inColumn(x, c) \\land value(x, v)))\\);\nResposta: True se a coluna \\(c\\) contém todos os números de 1 a 9, False caso contrário.\n\nVerificar se uma região 3x3 contém todos os números de 1 a 9:\n\nConsulta: \\(\\forall v (1 \\leq v \\leq 9 \\rightarrow \\exists! x: (inRegion(x, z) \\land value(x, v)))\\);\nResposta: True se a região \\(z\\) contém todos os números de 1 a 9, False caso contrário.\n\n\n\n\n7.0.4.4.7 Exercício 7 - Torre de Hanói\nNo jogo Torre de Hanói, três postes são dados, e discos de tamanhos diferentes são empilhados no primeiro poste em ordem crescente de tamanho (o menor no topo). O objetivo do jogo é mover todos os discos para o terceiro poste, usando o segundo poste como auxiliar, sob as seguintes condições [^2]:\n\nSomente um disco pode ser movido de cada vez;\nNenhum disco pode ser colocado sobre um disco menor.\n\nRegras e Axiomas:\n\nFormalize a regra de que apenas um disco pode ser movido de cada vez;\nFormalize a regra de que nenhum disco pode ser colocado sobre um disco menor;\nFormalize a condição de vitória, isto é, todos os discos estão no terceiro poste.\n\nSolução:\n\nO predicado unário \\(disk(x)\\) significa que \\(x\\) é um disco;\nO predicado unário \\(peg(x)\\) significa que \\(x\\) é um poste;\nO predicado ternário \\(on(x, y, t)\\) significa que, no tempo \\(t\\), o disco \\(x\\) está diretamente sobre o disco \\(y\\);\nO predicado ternário \\(at(x, p, t)\\) significa que, no tempo \\(t\\), o disco \\(x\\) está no poste \\(p\\);\nO predicado ternário \\(move(d, p, t)\\) significa que, no tempo \\(t\\), o disco \\(d\\) foi movido para o poste \\(p\\);\nO predicado unário \\(smallest(x)\\) significa que \\(x\\) é o disco de menor tamanho;\nO predicado binário \\(larger(x, y)\\) significa que o disco \\(x\\) é maior que o disco \\(y\\).\n\nAxiomas:\n\nApenas um disco pode ser movido de cada vez:\n\\[\\forall t \\exists! d \\exists p: move(d, p, t)\\]\nEste axioma afirma que, para cada tempo \\(t\\), existe exatamente um disco \\(d\\) e um poste \\(p\\) tal que \\(move(d, p, t)\\) é verdadeiro. Isso garante que apenas um disco é movido em cada instante.\nMovimento afeta o estado do jogo:\n\\[\\forall d \\forall p \\forall t: (move(d, p, t) \\rightarrow at(d, p, t+1))\\]\nSe um disco \\(d\\) é movido para o poste \\(p\\) no tempo \\(t\\), então no tempo \\(t+1\\), o disco \\(d\\) está no poste \\(p\\).\nEstado dos discos no tempo seguinte:\n\\[\\forall d \\forall p \\forall t: \\left[ at(d, p, t+1) \\leftrightarrow \\left( [at(d, p, t) \\land \\neg \\exists p': move(d, p', t)] \\lor move(d, p, t) \\right) \\right]\\]\nUm disco \\(d\\) está no poste \\(p\\) no tempo \\(t+1\\) se ele já estava no poste \\(p\\) no tempo \\(t\\) e não foi movido no tempo \\(t\\), ou se ele foi movido para o poste \\(p\\) no tempo \\(t\\).\nNenhum disco pode ser colocado sobre um disco menor:\n\\[\\forall d_1 \\forall d_2 \\forall t: (on(d_1, d_2, t) \\rightarrow larger(d_1, d_2))\\]\nEste axioma garante que, em qualquer momento \\(t\\), se o disco \\(d_1\\) está sobre o disco \\(d_2\\), então \\(d_1\\) é maior que \\(d_2\\).\nDefinição da relação de tamanho entre os discos:\n\nIrreflexividade:\n\n\\[\\forall x: \\neg larger(x, x)\\]\n\nTransitividade:\n\n\\[\\forall x \\forall y \\forall z: (larger(x, y) \\land larger(y, z) \\rightarrow larger(x, z))\\]\n\nAnti-simetria:\n\n\\[\\forall x \\forall y: (larger(x, y) \\rightarrow \\neg larger(y, x))\\]\nEstes axiomas definem \\(larger\\) como uma relação de ordem estrita entre os discos.\nCondição de vitória: todos os discos estão no terceiro poste:\n\\[\\exists t \\forall d: (disk(d) \\rightarrow at(d, peg_3, t))\\]\nEste axioma define a condição de vitória: existe um instante \\(t\\) em que todos os discos estão no terceiro poste (\\(peg_3\\)).\nNão há movimentos após a vitória:\n\\[\\forall t' &gt; t, \\forall d, \\forall p: \\neg move(d, p, t')\\]\nApós o tempo \\(t\\) em que a condição de vitória é alcançada, não ocorrem mais movimentos.\nCada disco está em exatamente um poste em cada momento:\n\\[\\forall d \\forall t: (disk(d) \\rightarrow \\exists! p: (peg(p) \\land at(d, p, t)))\\]\nEste axioma garante que cada disco está em exatamente um poste em cada momento do jogo.\nRelação entre \\(on\\) e \\(at\\):\n\\[\\forall d_1 \\forall d_2 \\forall p \\forall t: (on(d_1, d_2, t) \\rightarrow at(d_1, p, t) \\land at(d_2, p, t))\\]\nSe um disco \\(d_1\\) está sobre um disco \\(d_2\\), ambos estão no mesmo poste \\(p\\) no tempo \\(t\\).\nEstrutura de pilha sem ciclos:\n\nAciclicidade da relação \\(on\\):\n\n\\[\n\\forall d_1 \\forall d_2 \\forall t: (on(d_1, d_2, t) \\rightarrow \\neg on(d_2, d_1, t))\n\\]\nIsto garante que não existem ciclos na relação de “estar sobre”.\nCondições para \\(on\\) e a base do poste:\n\nUm disco pode estar diretamente no poste sem nenhum disco abaixo:\n\n\\[\n\\forall d \\forall p \\forall t: \\left( at(d, p, t) \\land \\neg \\exists d': on(d, d', t) \\right) \\rightarrow \\text{$d$ está na base ou é o único disco no poste $p$}\n\\]\nEste axioma assegura que, se não há nenhum disco abaixo de \\(d\\), então \\(d\\) está na base da pilha ou é o único disco no poste \\(p\\).\n\nConsultas Possíveis:\n\nVerificar se um disco está em um determinado poste no tempo \\(t\\):\n\nConsulta: \\(at(d, p, t)\\);\nResposta: Verdadeiro se o disco \\(d\\) está no poste \\(p\\) no tempo \\(t\\), Falso caso contrário.\n\nVerificar se um disco está sobre outro no tempo \\(t\\):\n\nConsulta: \\(on(d_1, d_2, t)\\);\nResposta: Verdadeiro se o disco \\(d_1\\) está sobre o disco \\(d_2\\) no tempo \\(t\\), Falso caso contrário.\n\nVerificar se o disco \\(d_1\\) é maior que o disco \\(d_2\\):\n\nConsulta: \\(larger(d_1, d_2)\\);\nResposta: Verdadeiro se o disco \\(d_1\\) é maior que o disco \\(d_2\\), Falso caso contrário.\n\nVerificar se o jogo foi vencido no tempo \\(t\\):\n\nConsulta: \\(\\forall d: (disk(d) \\rightarrow at(d, peg_3, t))\\);\nResposta: Verdadeiro se todos os discos estão no terceiro poste no tempo \\(t\\), Falso caso contrário.\n\nVerificar se um disco foi movido para um poste em um determinado instante:\n\nConsulta: \\(move(d, p, t)\\);\nResposta: Verdadeiro se o disco \\(d\\) foi movido para o poste \\(p\\) no tempo \\(t\\), Falso caso contrário.\n\n\n\n\n7.0.4.4.8 Exercício 8 - Modelo de Família com Meios-Irmãos\nVariáveis Proposicionais:\nPara pessoas:\n\n\\(P_i\\): Pessoa $\\(i\\) (na qual, \\(i\\) é um identificador único);\n\\(H_i\\): Pessoa \\(i\\) é homem;\n\\(M_i\\): Pessoa \\(i\\) é mulher.\n\nPara relações:\n\n\\(PaiDe(i,j)\\): Pessoa \\(i\\) é pai de pessoa \\(j\\);\n\\(MaeDe(i,j)\\): Pessoa \\(i\\) é mãe de pessoa \\(j\\);\n\\(FilhoDe(i,j)\\): Pessoa \\(i\\) é filho de pessoa \\(j\\);\n\\(FilhaDe(i,j)\\): Pessoa \\(i\\) é filha de pessoa \\(j\\);\n\\(IrmaoDe(i,j)\\): Pessoa \\(i\\) é irmão de pessoa \\(j\\);\n\\(IrmaDe(i,j)\\): Pessoa \\(i\\) é irmã de pessoa \\(j\\);\n\\(MeioIrmaoDe(i,j)\\): Pessoa \\(i\\) é meio-irmão de pessoa \\(j\\);\n\\(MeioIrmaDe(i,j)\\): Pessoa \\(i\\) é meia-irmã de pessoa \\(j\\).\n\nRegras do Modelo:\n\nCada pessoa é homem ou mulher, mas não ambos:\n\\[ \\forall i, P_i \\rightarrow (H_i \\oplus M_i) \\]\nRelações de paternidade e maternidade:\n\\[ \\forall i,j, PaiDe(i,j) \\rightarrow (H_i \\land (FilhoDe(j,i) \\lor FilhaDe(j,i))) \\]\n\\[ \\forall i,j, MaeDe(i,j) \\rightarrow (M_i \\land (FilhoDe(j,i) \\lor FilhaDe(j,i))) \\]\nRelações de filiação:\n\\[ \\forall i,j, FilhoDe(i,j) \\rightarrow (H_i \\land (PaiDe(j,i) \\lor MaeDe(j,i))) \\]\n\\[ \\forall i,j, FilhaDe(i,j) \\rightarrow (M_i \\land (PaiDe(j,i) \\lor MaeDe(j,i))) \\]\nRelações de irmandade:\n\\[ \\forall i,j, IrmaoDe(i,j) \\rightarrow (H_i \\land \\exists k, (PaiDe(k,i) \\land PaiDe(k,j)) \\land \\exists l, (MaeDe(l,i) \\land MaeDe(l,j)) \\land (i \\neq j)) \\]\n\\[ \\forall i,j, IrmaDe(i,j) \\rightarrow (M_i \\land \\exists k, (PaiDe(k,i) \\land PaiDe(k,j)) \\land \\exists l, (MaeDe(l,i) \\land MaeDe(l,j)) \\land (i \\neq j)) \\]\nRelações de meio-irmandade:\n\\[ \\forall i,j, MeioIrmaoDe(i,j) \\rightarrow (H_i \\land (((\\exists k, PaiDe(k,i) \\land PaiDe(k,j)) \\oplus (\\exists l, MaeDe(l,i) \\land MaeDe(l,j))) \\land (i \\neq j))) \\]\n\\[ \\forall i,j, MeioIrmaDe(i,j) \\rightarrow (M_i \\land (((\\exists k, PaiDe(k,i) \\land PaiDe(k,j)) \\oplus (\\exists l, MaeDe(l,i) \\land MaeDe(l,j))) \\land (i \\neq j))) \\]\nUma pessoa não pode ser seu próprio pai ou mãe:\n\\[ \\forall i, \\lnot PaiDe(i,i) \\land \\lnot MaeDe(i,i) \\]\nUma pessoa não pode ser irmão ou meio-irmão de si mesma:\n\\[ \\forall i, \\lnot IrmaoDe(i,i) \\land \\lnot IrmaDe(i,i) \\land \\lnot MeioIrmaoDe(i,i) \\land \\lnot MeioIrmaDe(i,i) \\]\nSimetria nas relações de irmandade:\n\\[ \\forall i,j, IrmaoDe(i,j) \\leftrightarrow IrmaoDe(j,i) \\]\n\\[ \\forall i,j, IrmaDe(i,j) \\leftrightarrow IrmaDe(j,i) \\]\n\\[ \\forall i,j, MeioIrmaoDe(i,j) \\leftrightarrow MeioIrmaoDe(j,i) \\]\n\\[ \\forall i,j, MeioIrmaDe(i,j) \\leftrightarrow MeioIrmaDe(j,i) \\]\nUma pessoa não pode ser simultaneamente irmão e meio-irmão de outra:\n\\[ \\forall i,j, \\lnot(IrmaoDe(i,j) \\land MeioIrmaoDe(i,j)) \\land \\lnot(IrmaDe(i,j) \\land MeioIrmaDe(i,j)) \\]\n\nNeste caso podemos definir um dos estados do mundo: para representar que \\(P1\\) é pai de \\(P2\\) e \\(P3\\), \\(P4\\) é mãe de \\(P2\\), \\(P5\\) é mãe de \\(P3\\), e \\(P2\\) e \\(P3\\) são meios-irmãos:\n\\[\n\\begin{align*}\nP1 \\land P2 \\land P3 \\land P4 \\land P5 \\land \\\\\nH_1 \\land H_2 \\land H_3 \\land M_4 \\land M_5 \\land \\\\\nPaiDe(1,2) \\land PaiDe(1,3) \\land \\\\\nMaeDe(4,2) \\land MaeDe(5,3) \\land \\\\\nFilhoDe(2,1) \\land FilhoDe(2,4) \\land \\\\\nFilhoDe(3,1) \\land FilhoDe(3,5) \\land \\\\\nMeioIrmaoDe(2,3) \\land MeioIrmaoDe(3,2)\n\\end{align*}\n\\]\nConsultas Possíveis::\n\nVerificar se uma pessoa existe no mundo:\n\nConsulta: \\(P_i\\);\nResposta: Verdadeiro se a pessoa i existe no mundo, Falso caso contrário.\n\nVerificar o sexo de uma pessoa:\n\nConsulta: \\(H_i\\) ou \\(M_i\\);\nResposta: Verdadeiro se a pessoa i é homem (H_i) ou mulher (M_i), Falso caso contrário.\n\nVerificar relação de paternidade:\n\nConsulta: \\(PaiDe(i,j)\\);\nResposta: Verdadeiro se a pessoa i é pai da pessoa j, Falso caso contrário.\n\nVerificar relação de maternidade:\n\nConsulta: \\(MaeDe(i,j)\\);\nResposta: Verdadeiro se a pessoa i é mãe da pessoa j, Falso caso contrário.\n\nVerificar se duas pessoas são irmãos:\n\nConsulta: \\(IrmaosDe(i,j)\\);\nResposta: Verdadeiro se as pessoas i e j são irmãos (mesmo pai e mesma mãe), Falso caso contrário.\n\nVerificar se duas pessoas são meios-irmãos:\n\nConsulta: \\(MeiosIrmaosDe(i,j)\\);\nResposta: Verdadeiro se as pessoas i e j são meios-irmãos (mesmo pai OU mesma mãe, mas não ambos), Falso caso contrário.\n\nEncontrar o pai de uma pessoa:\n\nConsulta: \\(\\exists x, PaiDe(x,i)\\);\nResposta: Verdadeiro se existe um pai para a pessoa i, Falso caso contrário;\nPara obter o pai específico: \\(x\\) tal que \\(PaiDe(x,i)\\) é verdadeiro.\n\nEncontrar a mãe de uma pessoa:\n\nConsulta: \\(\\exists x, MaeDe(x,i)\\);\nResposta: Verdadeiro se existe uma mãe para a pessoa i, Falso caso contrário;\nPara obter a mãe específica: \\(x\\) tal que \\(MaeDe(x,i)\\) é verdadeiro.\n\nVerificar se duas pessoas têm o mesmo pai:\n\nConsulta: \\(\\exists x, (PaiDe(x,i) \\land PaiDe(x,j))\\);\nResposta: Verdadeiro se as pessoas i e j têm o mesmo pai, Falso caso contrário.\n\nVerificar se duas pessoas têm a mesma mãe:\n\nConsulta: \\(\\exists x, (MaeDe(x,i) \\land MaeDe(x,j))\\);\nResposta: Verdadeiro se as pessoas i e j têm a mesma mãe, Falso caso contrário.\n\nContar o número de filhos de uma pessoa:\n\nConsulta: \\(\\text{Contagem}(\\{j : PaiDe(i,j) \\lor MaeDe(i,j)\\})\\);\nResposta: O número de filhos da pessoa \\(i\\).\n\nVerificar se uma pessoa é filho único:\n\nConsulta: \\(\\lnot \\exists j, (j \\neq i \\land (IrmaosDe(i,j) \\lor MeiosIrmaosDe(i,j)))\\);\nResposta: Verdadeiro se a pessoa i não tem irmãos nem meios-irmãos, Falso caso contrário.\n\n\n\n\n7.0.4.4.9 Exercício 9 - Jogo Pedra, Papel e Tesoura\nO jogo Pedra, Papel e Tesoura é um jogo simples entre dois jogadores, onde cada jogador escolhe uma das três opções: Pedra, Papel ou Tesoura. As regras são:\nVariáveis Proposicionais:\nPara jogadas:\n\n\\(P_i\\): Jogador i escolheu Pedra;\n\\(A_i\\): Jogador i escolheu Papel;\n\\(T_i\\): Jogador i escolheu Tesoura.\n\nPara resultados:\n\n\\(V_i\\): Jogador i venceu;\n\\(E\\): O jogo terminou em empate.\n\nRegras do Mundo:\n\nCada jogador faz exatamente uma jogada:\n\\[ \\forall i, ((P_i \\lor A_i \\lor T_i) \\land \\lnot(P_i \\land A_i) \\land \\lnot(P_i \\land T_i) \\land \\lnot(A_i \\land T_i)) \\]\nCondições de vitória para o Jogador \\(1\\):\n\\[ V_1 \\leftrightarrow ((P_1 \\land T_2) \\lor (T_1 \\land A_2) \\lor (A_1 \\land P_2)) \\]\nCondições de vitória para o Jogador \\(2\\):\n\\[ V_2 \\leftrightarrow ((P_2 \\land T_1) \\lor (T_2 \\land A_1) \\lor (A_2 \\land P_1)) \\]\nCondição de empate:\n\\[ E \\leftrightarrow ((P_1 \\land P_2) \\lor (A_1 \\land A_2) \\lor (T_1 \\land T_2)) \\]\nO jogo tem exatamente um resultado:\n\\[ (V_1 \\lor V_2 \\lor E) \\land \\lnot(V_1 \\land V_2) \\land \\lnot(V_1 \\land E) \\land \\lnot(V_2 \\land E) \\]\nNão é possível que ambos os jogadores vençam:\n\\[ \\lnot(V_1 \\land V_2) \\]\n\nConsultas Possíveis:\n\nVerificar a jogada de um jogador:\n\nConsulta: \\(P_i\\), \\(A_i\\), ou \\(T_i\\);\nResposta: Verdadeiro se o Jogador i escolheu a jogada correspondente, Falso caso contrário.\n\nVerificar o vencedor:\n\nConsulta: \\(V_1\\) ou \\(V_2\\);\nResposta: Verdadeiro se o Jogador correspondente venceu, Falso caso contrário.\n\nVerificar se houve empate:\n\nConsulta: \\(E\\);\nResposta: Verdadeiro se o jogo terminou em empate, Falso caso contrário.\n\nDeterminar o resultado do jogo:\n\nConsulta:\n\\[\nresultado = \\begin{cases}\n  1 & \\text{se } V_1 \\\\\n  2 & \\text{se } V_2 \\\\\n  0 & \\text{se } E\n\\end{cases}\n\\]\nResposta:\n\n\\(0\\) se o jogo terminou em empate;\n\\(1\\) se o Jogador 1 venceu;\n\\(2\\) se o Jogador 2 venceu.\n\n\nVerificar se um jogador escolheu uma jogada específica e venceu:\n\nConsulta: \\((P_i \\land V_i)\\), \\((A_i \\land V_i)\\), ou \\((T_i \\land V_i)\\).\nResposta: Verdadeiro se o Jogador i escolheu a jogada específica e venceu, Falso caso contrário.\n\nVerificar se o jogo foi válido:\n\nConsultas:\n\\[((P_1 \\lor A_1 \\lor T_1) \\land \\lnot(P_1 \\land A_1) \\land \\lnot(P_1 \\land T_1) \\land \\lnot(A_1 \\land T_1)) \\land\\]\n\\[((P_2 \\lor A_2 \\lor T_2) \\land \\lnot(P_2 \\land A_2) \\land \\lnot(P_2 \\land T_2) \\land \\lnot(A_2 \\land T_2)) \\land\\]\n\\[((V_1 \\lor V_2 \\lor E) \\land \\lnot(V_1 \\land V_2) \\land \\lnot(V_1 \\land E) \\land \\lnot(V_2 \\land E))\\]\nResposta: verdadeiro se o jogo seguiu todas as regras (uma jogada por jogador e um único resultado), Falso caso contrário.\n\n\nExemplo de um estado válido deste Mundo:\n\\[P_1 \\land T_2 \\land V_1 \\land \\lnot V_2 \\land \\lnot E \\land \\\\\n   \\lnot A_1 \\land \\lnot T_1 \\land \\lnot P_2 \\land \\lnot A_2\\]\nEste mundo representa um jogo onde:\n\nO Jogador \\(1\\) escolheu Pedra;\nO Jogador \\(2\\) escolheu Tesoura;\nO Jogador \\(1\\) venceu;\nNão houve empate.\n\n\n\n7.0.4.4.10 Exercício 10 - Mundo de Ginásio de Esportes\nElabore um mundo para um ginásio de esportes. O modelo deve incluir atletas, modalidades esportivas, treinadores, e competições. Considere que um atleta pode praticar múltiplas modalidades, um treinador pode especializar-se em uma ou mais modalidades, e uma competição envolve uma modalidade específica com vários atletas participantes. Crie consultas para responder se algum atleta pratica todas as modalidades, se algum treinador é especializado em todas as modalidades e mais duas a seu critério.\nFatos:\n\n\\(A(x)\\): \\(x\\) é um atleta;\n\\(M(x)\\): \\(x\\) é uma modalidade esportiva;\n\\(T(x)\\): \\(x\\) é um treinador;\n\\(C(x)\\): \\(x\\) é uma competição;\n\\(Pratica(x,y)\\): atleta \\(x\\) pratica a modalidade \\(y\\);\n\\(Especializa(x,y)\\): treinador \\(x\\) é especializado na modalidade \\(y\\);\n\\(Participa(x,y)\\): atleta \\(x\\) participa da competição \\(y\\);\n\\(EnvolveModalidade(x,y)\\): competição \\(x\\) envolve a modalidade \\(y\\).\n\nRegras:\n\nTodo atleta pratica pelo menos uma modalidade:\n\\[ \\forall x(A(x) \\rightarrow \\exists y(M(y) \\land Pratica(x,y))) \\]\nTodo treinador é especializado em pelo menos uma modalidade:\n\\[ \\forall x(T(x) \\rightarrow \\exists y(M(y) \\land Especializa(x,y))) \\]\nToda competição envolve exatamente uma modalidade:\n\\[ \\forall x(C(x) \\rightarrow \\exists! y(M(y) \\land EnvolveModalidade(x,y))) \\]\nUm atleta só pode participar de uma competição se praticar a modalidade envolvida:\n\\[ \\forall x \\forall y(Participa(x,y) \\rightarrow \\exists z(M(z) \\land Pratica(x,z) \\land EnvolveModalidade(y,z))) \\]\n\nConsultas:\n\nVerificar se um atleta pratica uma modalidade específica:\n\nConsulta: Pratica(atleta,modalidade);\nResposta: Verdadeiro se o atleta pratica a modalidade, Falso caso contrário.\n\nVerificar se um treinador é especializado em uma modalidade específica:\n\nConsulta: Especializa(treinador,modalidade);\nResposta: Verdadeiro se o treinador é especializado na modalidade, Falso caso contrário.\n\nVerificar se um atleta participa de uma competição específica:\n\nConsulta: Participa(atleta,competicao);\nResposta: Verdadeiro se o atleta participa da competição, Falso caso contrário.\n\nVerificar se uma competição envolve uma modalidade específica:\n\nConsulta: EnvolveModalidade(competicao,modalidade);\nResposta: Verdadeiro se a competição envolve a modalidade, Falso caso contrário.\n\nVerificar se existe um atleta que pratica todas as modalidades:\n\nConsulta: \\(\\exists x(A(x) \\land \\forall y(M(y) \\rightarrow Pratica(x,y)))\\);\nResposta: Verdadeiro se existe um atleta que pratica todas as modalidades, Falso caso contrário.\n\nVerificar se existe um treinador especializado em todas as modalidades:\n\nConsulta: \\(\\exists x(T(x) \\land \\forall y(M(y) \\rightarrow Especializa(x,y)))\\);\nResposta: Verdadeiro se existe um treinador especializado em todas as modalidades, Falso caso contrário.\n\nVerificar se existe uma modalidade praticada por todos os atletas:\n\nConsulta: \\(\\exists y(M(y) \\land \\forall x(A(x) \\rightarrow Pratica(x,y)))\\);\nResposta: Verdadeiro se existe uma modalidade praticada por todos os atletas, Falso caso contrário.\n\nVerificar se existe uma competição em que todos os atletas participam:\n\nConsulta: \\(\\exists y(C(y) \\land \\forall x(A(x) \\rightarrow Participa(x,y)))\\);\nResposta: Verdadeiro se existe uma competição com participação de todos os atletas, Falso caso contrário.\n\nVerificar se um atleta está qualificado para participar de uma competição específica:\n\nConsulta: \\(\\exists z(M(z) \\land Pratica(atleta,z) \\land EnvolveModalidade(competicao,z))\\);\nResposta: Verdadeiro se o atleta pratica a modalidade envolvida na competição, Falso caso contrário.\n\nVerificar se existe um treinador especializado na modalidade de uma competição específica:\n\nConsulta: \\(\\exists x \\exists y(T(x) \\land M(y) \\land Especializa(x,y) \\land EnvolveModalidade(competicao,y))\\);\nResposta: Verdadeiro se existe um treinador especializado na modalidade da competição, Falso caso contrário.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Mundos na Lógica de Primeira Ordem</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html",
    "href": "07-clausulas-de-horn-e-prolog.html",
    "title": "8  Cláusulas de Horn",
    "section": "",
    "text": "8.0.1 Definição da Cláusula de Horn\nA Cláusula de Horn é uma disjunção de literais que contém, no máximo, um literal positivo. Existem algumas formas equivalentes de representar Cláusulas de Horn:\nTipos de Cláusulas de Horn (baseado na forma disjuntiva \\(\\neg A_1 \\lor \\ldots \\lor \\neg A_k \\lor B\\)):\nPara entender melhor, imagine que estamos construindo um cenário mental fundamentado na lógica para construir o entendimento de um problema, uma espécie de paisagem mental onde as coisas fazem sentido. Nesse cenário, as Cláusulas de Horn serão os tijolos fundamentais que usaremos para construir estruturas lógicas.\n1. Fatos: os fatos são como pedras fundamentais desse cenário. Eles são afirmações simples e diretas que dizem como as coisas são. Considere, por exemplo: O céu é azul, \\(P\\) e A grama é verde\\(Q\\). Essas são verdades que não precisam de justificativa. Elas simplesmente são. os Fatos são axiomas.\n2. Regras: as regras são um pouco mais intrigantes. Elas são como as regras de um jogo que definem como as coisas se relacionam umas com as outras. Se não chover, a grama não ficará molhada. Essa é uma regra. Ela nos diz o que esperar se certas condições forem atendidas. As regras são como os conectores em nosso mundo lógico, ligando fatos e permitindo que façamos inferências. Elas são o motor que nos permite raciocinar e descobrir novas verdades a partir das que já conhecemos. Por exemplo:\n3. Metas ou Consultas: finalmente, temos as metas ou consultas. Essas são as perguntas que fazemos ao nosso mundo lógico. Está chovendo?, A grama está molhada? São os caminhos que usaremos para explorar o cenário criado, olhando ao redor e tentando entender o que está acontecendo. As consultas são a forma de interagir com nosso mundo lógico, usando os fatos e regras que estabelecemos para encontrar respostas e alcançar objetivos. Por exemplo:\nPodemos tentar avaliar alguns exemplos de uso de Fatos, Regras e Consultas:",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#exemplo-3---mundo-núcleo-familiar-lógica-de-primeira-ordem",
    "href": "07-clausulas-de-horn-e-prolog.html#exemplo-3---mundo-núcleo-familiar-lógica-de-primeira-ordem",
    "title": "8  Cláusulas de Horn",
    "section": "8.1 Exemplo 3 - Mundo Núcleo Familiar (Lógica de Primeira Ordem)",
    "text": "8.1 Exemplo 3 - Mundo Núcleo Familiar (Lógica de Primeira Ordem)\nO exemplo a seguir apresenta um mundo que representa uma família e suas relações, apresentado usando a sintaxe da lógica de primeira ordem (FOL).\nFatos: os fatos são representados como predicados aplicados a constantes em FOL.\n\n\\(Homem(joão)\\);\n\\(Homem(pedro)\\);\n\\(Mulher(maria)\\);\n\\(Mulher(ana)\\);\n\\(Progenitor(joão, pedro)\\);\n\\(Progenitor(maria, pedro)\\);\n\\(Progenitor(joão, ana)\\);\n\\(Progenitor(maria, ana)\\).\n\nRegras:\n1. Pai:\n\nForma Implicativa:\n\\[\\forall X \\forall Y (Homem(X) \\land Progenitor(X, Y) \\rightarrow Pai(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y (\\neg Homem(X) \\lor \\neg Progenitor(X, Y) \\lor Pai(X, Y))\\]\n\n2. Mãe:\n\nForma Implicativa:\n\\[\\forall X \\forall Y (Mulher(X) \\land Progenitor(X, Y) \\rightarrow Mae(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y (\\neg Mulher(X) \\lor \\neg Progenitor(X, Y) \\lor Mae(X, Y))\\]\n\n3. Meio-Irmão: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Homem(X) \\land Progenitor(Z, X) \\land Progenitor(Z, Y) \\land X \\neq Y \\rightarrow MeioIrmao(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\lor \\neg Progenitor(Z, X) \\lor \\neg Progenitor(Z, Y) \\lor X = Y \\lor MeioIrmao(X, Y))\\]\n\n4. Meio-Irmã: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Mulher(X) \\land Progenitor(Z, X) \\land Progenitor(Z, Y) \\land X \\neq Y \\rightarrow MeioIrma(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\lor \\neg Progenitor(Z, X) \\lor \\neg Progenitor(Z, Y) \\lor X = Y \\lor MeioIrma(X, Y))\\]\n\n5. Irmão: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall P \\forall M (Homem(X) \\land Pai(P,X) \\land Pai(P,Y) \\land Mae(M,X) \\land Mae(M,Y) \\land X \\neq Y \\rightarrow Irmao(X,Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall P \\forall M (\\neg Homem(X) \\lor \\neg Pai(P,X) \\lor \\neg Pai(P,Y) \\lor \\neg Mae(M,X) \\lor \\neg Mae(M,Y) \\lor X = Y \\lor Irmao(X,Y))\\]\n\n6. Irmã: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall P \\forall M (Mulher(X) \\land Pai(P,X) \\land Pai(P,Y) \\land Mae(M,X) \\land Mae(M,Y) \\land X \\neq Y \\rightarrow Irma(X,Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall P \\forall M (\\neg Mulher(X) \\lor \\neg Pai(P,X) \\lor \\neg Pai(P,Y) \\lor \\neg Mae(M,X) \\lor \\neg Mae(M,Y) \\lor X = Y \\lor Irma(X,Y))\\]\n\n7. Avô:\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Homem(X) \\land Progenitor(X, Z) \\land Progenitor(Z, Y) \\rightarrow Avo(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\lor \\neg Progenitor(X, Z) \\lor \\neg Progenitor(Z, Y) \\lor Avo(X, Y))\\]\n\n8. Avó:\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Mulher(X) \\land Progenitor(X, Z) \\land Progenitor(Z, Y) \\rightarrow Avo(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\lor \\neg Progenitor(X, Z) \\lor \\neg Progenitor(Z, Y) \\lor Avo(X, Y))\\]\n\nConsultas (Metas):\n\npai(joão, pedro)\nPara verificar se \\(Pai(joão, pedro)\\) é uma consequência lógica da base de conhecimento, tenta-se provar que a base de conhecimento junto com \\(\\neg Pai(joão, pedro)\\) leva a uma contradição (\\(\\bot\\)). A meta é, portanto: \\[\\neg Pai(joão, pedro)\\]\nirmão(pedro, ana)\nPara verificar se \\(Irmao(pedro, ana)\\) é verdadeiro: \\[\\neg Irmao(pedro, ana)\\]\navó(X, ana)\nPara perguntar se “Existe uma avó X para Ana?”, a consulta seria \\(\\exists X (Avo(X, ana) \\land Mulher(X))\\). A forma de meta para refutação seria tentar provar que a base de conhecimento junto com \\(\\forall X (\\neg Avo(X, ana) \\lor \\neg Mulher(X))\\) leva a uma contradição.\n\nEm um sistema de prova por refutação, adicionamos a negação da consulta à base de conhecimento e tentamos derivar uma contradição (\\(\\bot\\)). As representações das metas como negações em FOL estão corretas nesse contexto. #### Exemplo 4 - Torre de Hanói\nA Torre de Hanói é um quebra-cabeça matemático que consiste em três postes e um número de discos de diferentes tamanhos que podem deslizar sobre qualquer poste. O quebra-cabeça começa com os discos empilhados em ordem decrescente de tamanho no primeiro poste, o menor disco no topo. O objetivo é mover toda a pilha para o último poste, obedecendo às seguintes regras:\nPredicados:\n\n\\(Disco(x)\\): \\(x\\) é um disco;\n\\(Poste(x)\\): \\(x\\) é um poste;\n\\(Menor(x)\\): \\(x\\) é o disco menor;\n\\(Maior(x, y)\\): o disco \\(x\\) é maior que o disco \\(y\\);\n\\(Em(x, y)\\): o disco \\(x\\) está no poste \\(y\\);\n\\(Sobre(x, y)\\): o disco \\(x\\) está sobre o disco \\(y\\).\n\nFatos (Cláusulas de Horn Unitárias):\n\n\\(Disco(d_1)\\);\n\\(Disco(d_2)\\);\n\\(Disco(d_3)\\);\n\\(Poste(p_1)\\);\n\\(Poste(p_2)\\);\n\\(Poste(p_3)\\);\n\\(Menor(d_1)\\);\n\\(Maior(d_2, d_1)\\);\n\\(Maior(d_3, d_2)\\).\n\nRegras (Cláusulas de Horn Não-Unitárias):\n\nMovimento válido:\n\\[\\neg Disco(x) \\lor \\neg Poste(y) \\lor \\neg Poste(z) \\lor \\neg Em(x, y) \\lor \\neg DiscoNoTopo(x, y) \\lor \\neg DiscoNoTopo(u, z) \\lor \\neg Maior(x, u) \\lor MovimentoValido(x, y, z)\\]\nCondição de vitória:\n\\[\\neg Disco(x) \\lor \\neg Disco(y) \\lor \\neg Disco(z) \\lor \\neg Em(x, p_3) \\lor \\neg Em(y, p_3) \\lor \\neg Em(z, p_3) \\lor Vitoria()\\]\nDisco válido (nenhum disco maior sobre um menor):\n\\[\\neg Sobre(x, y) \\lor \\neg Maior(x, y) \\lor DiscoValido(x, y)\\]\nMovimento único:\n\\[\\neg Disco(x) \\lor \\neg Disco(y) \\lor \\neg Poste(z) \\lor \\neg Poste(w) \\lor \\neg MovimentoValido(y, z, w) \\lor x = y \\lor MovimentoUnico(x)\\]\nEstado inicial:\n\\[\\neg Em(d_1, p_1) \\lor \\neg Em(d_2, p_1) \\lor \\neg Em(d_3, p_1) \\lor \\neg Sobre(d_3, d_2) \\lor \\neg Sobre(d_2, d_1) \\lor EstadoInicial()\\]\nDisco no topo:\n\\[\\neg Disco(x) \\lor \\neg Poste(y) \\lor \\neg Em(x, y) \\lor \\neg Disco(z) \\lor \\neg Em(z, y) \\lor \\neg Sobre(z, x) \\lor DiscoNoTopo(x, y)\\]\n\nConsultas (Metas):\n\nVerificar se um movimento é válido:\n\\[\\neg MovimentoValido(x, y, z)\\]\nVerificar se o jogo foi vencido:\n\\[\\neg Vitoria()\\]\nVerificar se um disco pode estar sobre outro:\n\\[\\neg DiscoValido(x, y)\\]\nVerificar se apenas um disco está sendo movido:\n\\[\\neg MovimentoUnico(x)\\]\nVerificar o estado inicial:\n\\[\\neg EstadoInicial()\\]\nVerificar se um disco está no topo de um poste:\n\\[\\neg DiscoNoTopo(x, y)\\]\n\n\n8.1.1 Quantificadores em Cláusulas de Horn\nOs quantificadores podem ser incluídos nas Cláusulas de Horn. Contudo, é importante notar que a forma padrão de Cláusulas de Horn em programação lógica geralmente lida com quantificação de forma implícita. A quantificação universal é comum e é geralmente assumida em regras, enquanto a quantificação existencial é muitas vezes tratada através de fatos específicos ou construção de termos.\nPrecisamos tomar cuidado porque a inclusão explícita de quantificadores pode levar a uma Lógica de Primeira Ordem mais rica, permitindo expressões mais complexas e poderosas. No entanto, isso também pode aumentar a complexidade do raciocínio e da resolução.\nO quantificador universal (representado por $$) afirma que uma propriedade é verdadeira para todos os membros de um domínio. Em Cláusulas de Horn, isso é geralmente representado implicitamente através de regras gerais que se aplicam a todos os membros de um conjunto. Por exemplo, considere a regra: Todos os pássaros podem voar. Em uma Cláusula de Horn, isso pode ser representado como:\nEm programação lógica e Cláusulas de Horn, a quantificação é frequentemente tratada implicitamente.\nQuantificador Universal em Regras: considere a afirmação: “Para todo x, se x é um pássaro, então x pode voar.”\n\nFórmula em Lógica de Primeira Ordem (LPO): \\(\\forall x (\\text{Pássaro}(x) \\rightarrow \\text{Voa}(x))\\)\nForma clausal (Cláusula de Horn equivalente): \\(\\neg \\text{Pássaro}(x) \\lor \\text{Voa}(x)\\) (Aqui, \\(x\\) é implicitamente quantificado universalmente.)\nRepresentação em Prolog: voa(X) :- passaro(X). (A variável X é implicitamente quantificada universalmente.)\n\nQuantificador Existencial e Fatos: considere a afirmação: “Existe um pássaro que não pode voar.” * Fórmula em LPO: \\(\\exists x (\\text{Pássaro}(x) \\land \\neg \\text{Voa}(x))\\) * Tratamento em sistemas de Cláusulas de Horn: Afirmações existenciais puras como \\(\\exists x \\Phi(x)\\) não são diretamente representadas como regras de Cláusula de Horn. Para incorporar tal conhecimento, se o indivíduo específico for conhecido, ele é afirmado como um conjunto de fatos. Por exemplo, se sabemos que “Pengu” é um pássaro e não voa: * Fatos em Prolog: passaro(pengu). nao_voa(pengu). (ou voa(pengu) :- fail.)\n\nSe a existência é conhecida mas o indivíduo não é nomeado, em processos de prova teórica (como resolução), a Skolemização substituiria \\(x\\) por uma nova constante (constante de Skolem), resultando em: \\(\\text{Pássaro}(c) \\land \\neg \\text{Voa}(c)\\). Estes seriam então fatos no sistema: \\(\\text{Pássaro}(c).\\) e \\(\\neg \\text{Voa}(c).\\) (ou um predicado para a negação).\n\n\n\n8.1.2 Conversão de Fórmulas\nSeja uma fórmula bem formada arbitrária da Lógica Proposicional. Alguns passos podem ser aplicados para obter uma cláusula de Horn equivalente:\n\nConverter a fórmula para Forma Normal Conjuntiva (FNC), obtendo uma conjunção de disjunções\nAplicar as seguintes técnicas em cada disjunção:\n\nInverter a polaridade de literais positivos extras;\nAdicionar literais negativos que preservem a satisfatibilidade;\nDividir em cláusulas menores se necessário.\n\nSimplificar a fórmula final obtida.\n\n\n8.1.2.1 Exemplo 1: dada a fórmula\n\\[(P \\land Q) \\lor (P \\land R)\\]\nPassos:\n\nConverter para FNC: \\((P \\lor Q) \\land (P \\lor R)\\);\nInverter P em uma das disjunções: \\((P \\lor Q) \\land (\\neg P \\lor R)\\);\nAdicionar literal negativo: \\((P \\lor Q \\lor \\neg S) \\land (\\neg P \\lor R \\lor \\neg T)\\);\nSimplificar: $S P T r $.\n\nA sequência destes passos permite encontrar uma conjunção de cláusulas de Horn equivalente à fórmula original.\n\n\n8.1.2.2 Transformação de Forma Normal Conjuntiva (FNC) para Cláusulas de Horn\nA Forma Normal Conjuntiva é uma conjunção de disjunções de literais. Uma Cláusula de Horn é um tipo especial de cláusula que contém no máximo um literal positivo. Considere que o objetivo das Cláusulas de Horn é criar um conjunto de Fórmulas Bem Formadas, divididas em Fatos, Regras e Consultas para permitir a resolução de problemas então, a transformação de uma FNC para Cláusulas de Horn pode incorrer em alguns problemas:\n\nPerda de Informação: Nem todas as cláusulas em FNC podem ser transformadas em Cláusulas de Horn. Para minimizar este risco atente para as regras de equivalência que vimos anteriormente.\nComplexidade: A transformação pode ser complexa e requer uma análise cuidadosa da lógica e do contexto.\n\nEtapas de Transformação\n\nConverter para FNC: Se a fórmula ainda não estiver em Forma Normal Conjuntiva, converta-a para Forma Normal Conjuntiva usando as técnicas descritas anteriormente;\nIdentificar Cláusulas de Horn: Verifique cada cláusula na Forma Normal Conjuntiva. Se uma cláusula contém no máximo um literal positivo, ela já é uma Cláusula de Horn;\nTransformar Cláusulas Não-Horn: Se uma cláusula contém mais de um literal positivo, ela não pode ser diretamente transformada em uma Cláusula de Horn sem perder informações.\n\n\n8.1.2.2.1 Exemplo 1: vamos considerar a seguinte fórmula bem formada\n\\[(A \\rightarrow B) \\land (B \\lor C)\\]\n\nConverter para FNC:\n\nElimine a implicação: \\((\\neg A \\lor B) \\land (B \\lor C)\\);\nA fórmula já está em Forma Normal Conjuntiva.\n\nIdentificar Cláusulas de Horn:\n\nAmbas as cláusulas são Cláusulas de Horn, pois cada uma contém apenas um literal positivo.\n\nResultado:\n\nA fórmula em Cláusulas de Horn é: \\((\\neg A \\lor B) \\land (B \\lor C)\\)\n\n\n\n\n\n8.1.2.3 Problemas interessantes resolvidos com a Cláusula de Horn\nProblema 1 - O Mentiroso e o Verdadeiro:: Você encontra dois habitantes: \\(A\\) e \\(B\\). Você sabe que um sempre diz a verdade e o outro sempre mente, mas você não sabe quem é quem. Você consulta a \\(A\\), Você é o verdadeiro? A responde, mas você não consegue ouvir a resposta dele. \\(B\\) então te diz, A disse que ele é o mentiroso.\nFatos:\n\\(mentiroso(A)\\) \\(verdadeiro(B)\\)\nRegra:\n\\[\n\\forall x \\forall y (mentiroso(x) \\wedge consulta(y, \\text{Você é o verdadeiro?}) → Responde (x, \\text{Sou o mentiroso}))\n\\]\nConsulta:\n\\[ responde (A, \\text{Sou o mentiroso})?\\]\nProblema 2 - As Três Lâmpadas: existem três lâmpadas incandescentes em uma sala, e existem três interruptores fora da sala. Você pode manipular os interruptores o quanto quiser, mas só pode entrar na sala uma vez. Como você pode determinar qual interruptor opera qual lâmpada?\nFatos:\n\\(Interruptor(s_1)\\) \\(Interruptor(s_2)\\) \\(Interruptor(s_3)\\)\n\\(Lâmpada(b_1)\\) \\(Lâmpada(b_2)\\) \\(Lâmpada(b_3)\\)\nRegras:\n\\[\\forall x \\forall y (Interruptor(x) \\wedge Ligado(x) \\wedge Lâmpada(y) \\rightarrow Acende (y))\\]\n\\[\\forall x (Lâmpada(x) \\wedge FoiLigada(x) \\wedge AgoraDesligada(x) \\rightarrow EstáQuente (x))\\]\nConsulta:\n\\[Acende (b_2, s_2)?\\]\n\\[ estáQuente (b_1)?\\]\nProblema 3 - O Agricultor, a Raposa, o Ganso e o Grão: um agricultor quer atravessar um rio e levar consigo uma raposa, um ganso e um saco de grãos. O barco do agricultor só lhe permite levar um item além dele mesmo. Se a raposa e o ganso estiverem sozinhos, a raposa comerá o ganso. Se o ganso e o grão estiverem sozinhos, o ganso comerá o grão. Como o agricultor pode levar todas as suas posses para o outro lado do rio?\nFatos:\n\n\\(Raposa(r)\\);\n\\(Ganso(g)\\);\n\\(Grao(gr)\\).\n\nNestes fatos a atenta leitora deve observar que ‘\\(r\\)’ é uma raposa, ‘\\(g\\)’ é um ganso, e ‘\\(gr\\)’ é um saco de grãos.\nRegras:\n\nSe \\(x\\) é uma Raposa e \\(y\\) é um Ganso, e \\(x\\) e \\(y\\) estão sozinhos, então \\(x\\) come \\(y\\):\n\n\\[\\forall x \\forall y (Raposa(x) \\land Ganso(y) \\land Sozinhos(x, y) \\rightarrow Come(x, y))\\]\n\nSe \\(x\\) é um Ganso e \\(y\\) é Grão, e \\(x\\) e \\(y\\) estão sozinhos, então \\(x\\) come \\(y\\):\n\n\\[\\forall x \\forall y (Ganso(x) \\land Grao(y) \\land Sozinhos(x, y) \\rightarrow Come(x, y))\\]\nO predicado \\(Sozinhos(Item1, Item2)\\) significaria que \\(Item1\\) e \\(Item2\\) estão em uma margem do rio sem o agricultor. O predicado \\(Come(Predador, Presa)\\) significa que o predador come a presa.\nConsulta:\nAs consultas visam verificar se, em um determinado estado da travessia, certas condições de não comer são satisfeitas. Para um sistema de prova, estas seriam as metas a serem mantidas verdadeiras, ou suas negações a serem evitadas.\n\nA raposa \\(r\\) não come o ganso \\(g\\) (ou seja, é falso que \\(r\\) come \\(g\\))?\n\n\\[\\neg Come(r, g)\\]\n\nO ganso \\(g\\) não come o grão \\(gr\\) (ou seja, é falso que \\(g\\) come \\(gr\\))?\n\n\\[\\neg Come(g, gr)\\]\nEstas consultas, no contexto da resolução do problema, representam estados seguros que devem ser mantidos durante toda a travessia. A solução do problema envolve encontrar uma sequência de movimentos que leve todos ao outro lado do rio sem nunca satisfazer as condições de \\(Come(r,g)\\) ou \\(Come(g,gr)\\) quando o agricultor não está presente para supervisionar.\nProblema 4 - A Ponte e a Tocha: quatro pessoas chegam a um rio à noite. Há uma ponte estreita, mas ela só pode conter duas pessoas de cada vez. Eles têm uma tocha e, por ser noite, a tocha tem que ser usada ao atravessar a ponte. A pessoa A pode atravessar a ponte em um minuto, B em dois minutos, C em cinco minutos e D em oito minutos. Quando duas pessoas atravessam a ponte juntas, elas devem se mover no ritmo da pessoa mais lenta. Qual é a forma mais rápida para todos eles atravessarem a ponte?\nFatos (tempos):\n\n\\(tempo(a, 1)\\);\n\\(tempo(b, 2)\\);\n\\(tempo(c, 5)\\);\n\\(tempo(d, 8)\\).\n\nRegras:\n\nRegra para determinar qual pessoa é mais lenta:\n\\[\\neg tempo(X, TX) \\lor \\neg tempo(Y, TY) \\lor \\neg maior(TX, TY) \\lor mais\\_lento(X, Y, X)\\]\n\\[\\neg tempo(X, TX) \\lor \\neg tempo(Y, TY) \\lor \\neg maior(TY, TX) \\lor mais\\_lento(X, Y, Y)\\]\nRegra para calcular o tempo quando duas pessoas atravessam juntas:\n\\[\\neg mais\\_lento(X, Y, Z) \\lor \\neg tempo(Z, T) \\lor tempo\\_travessia(X, Y, T)\\]\nRelações “maior que” definidas como fatos:\n\n\\(maior(2, 1)\\);\n\\(maior(5, 1)\\);\n\\(maior(5, 2)\\);\n\\(maior(8, 1)\\);\n\\(maior(8, 2)\\);\n\\(maior(8, 5)\\).\n\nRegras para representar o plano de travessia:\n\\[\\neg atravessa\\_ida(X, Y, T1) \\lor \\neg volta(Z, T2) \\lor \\neg atravessa\\_ida(W, V, T3) \\lor \\neg volta(U, T4) \\lor \\neg atravessa\\_ida(S, R, T5) \\lor travessia\\_completa(T1+T2+T3+T4+T5)\\]\nOnde as variáveis representam as pessoas que atravessam em cada fase da solução.\n\nConsulta:\n\\[travessia\\_completa(15)?\\]\nEsta consulta verifica se existe um plano de travessia que soma exatamente 15 minutos, representando a solução ótima para o problema.\nProblema 5 - O Problema de Monty Hall: em um programa de game show, os concorrentes tentam adivinhar qual das três portas contém um prêmio valioso. Depois que um concorrente escolhe uma porta, o apresentador, que sabe o que está por trás de cada porta, abre uma das portas não escolhidas para revelar uma cabra (representando nenhum prêmio). O apresentador então pergunta ao concorrente se ele quer mudar sua escolha para a outra porta não aberta ou ficar com sua escolha inicial. O que o concorrente deve fazer para maximizar suas chances de ganhar o prêmio?\nFatos:\n\n\\(Porta(d_1)\\);\n\\(Porta(d_2)\\);\n\\(Porta(d_3)\\).\n\nRegras:\n\\[\\forall x Prêmio(x) \\rightarrow Porta(x)\\]\n\\[\\forall x \\forall y (Porta(x) \\wedge Porta(y) \\wedge x \\neq y \\rightarrow \\neg Prêmio(x) \\vee \\neg Prêmio(y))\\]\nConsulta:\n\\[\\exists x (Porta(x) \\wedge \\neg Revelada(x) \\wedge x \\neq PortaEscolhida \\rightarrow Prêmio(x))?\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "href": "07-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "title": "8  Cláusulas de Horn",
    "section": "8.2 O Prolog Entra em Cena",
    "text": "8.2 O Prolog Entra em Cena\nO Prolog é uma linguagem de programação lógica que utiliza Cláusulas de Horn para representar e manipular conhecimento. A sintaxe e a semântica do Prolog são diretamente mapeadas para Cláusulas de Horn:\n\nFatos: Em Prolog, fatos são representados como cláusulas sem antecedentes. Por exemplo, o fato John é humano pode ser representado como humano(john).\nRegras: As regras em Prolog são representadas como implicações, onde os antecedentes são literais negativos e o consequente é o literal positivo. Por exemplo, a regra Se X é humano, então X é mortal pode ser representada como mortal(X) :- humano(X).\nConsultas: As consultas em Prolog são feitas ao sistema para inferir informações com base nos fatos e regras definidos. Por exemplo, a consulta “Quem é mortal?” pode ser representada como ?- mortal(X).\n\nO Prolog utiliza um mecanismo de resolução baseado em Cláusulas de Horn para responder a consultas. Ele aplica uma técnica de busca em profundidade para encontrar uma substituição de variáveis que satisfaça a consulta.\n\n8.2.0.1 Exemplo 1: O mais simples possível\nFatos:\nhomem(joão).\nmulher(maria).\nOs fatos indicam que “João é homem” e “maria é mulher”.\nRegra:\nmortal(X) :- homem(X).\nA regra estabelece que “Se \\(X\\) é homem, então \\(X\\) é mortal”. O símbolo \\(:-\\) representa implicação.\nConsulta:\nmortal(joão).\nA consulta verifica se “João é mortal”, aplicando a regra definida anteriormente. O Prolog responderá True (verdadeiro ou \\(\\top\\)) pois a regra se aplica dado o fato de que João é homem.\n\n\n8.2.0.2 Exemplo 2: Sistema de Recomendação de Roupas em Prolog\nImagine que estamos construindo um sistema lógico simples em Prolog para recomendar o tipo de roupa que uma pessoa deve vestir com base no clima. Vamos usar Cláusulas de Horn para representar o conhecimento e a lógica do sistema.\nFatos: primeiro, estabelecemos os fatos, que são as verdades básicas sobre o mundo. Neste caso, os fatos podem ser informações sobre o clima atual.\n\nFato 1: está ensolarado.\n\n ensolarado.\n\nFato 2: a temperatura está acima de 20°C.\n\n temperatura_acima_de_20.\nRegras: em seguida, definimos as regras que descrevem como as coisas se relacionam. Essas regras nos dizem o tipo de roupa apropriada com base no clima.\n\nRegra 1: se está ensolarado e a temperatura está acima de 20°C, use óculos de sol.\n\n óculos_de_sol :- ensolarado, temperatura_acima_de_20.\n\nRegra 2: se está ensolarado, use chapéu.\n\n chapéu :- ensolarado.\n\nRegra 3: se a temperatura está acima de 20°C, use camiseta.\n\n camiseta :- temperatura_acima_de_20.\nAgora, podemos fazer consultas ao nosso sistema para obter recomendações de roupas.\n\nConsulta 1: está ensolarado e a temperatura está acima de 20°C. O que devo vestir?\n\n ?- óculos_de_sol, chapéu, camiseta.\n\n\n8.2.0.3 Exemplo 3: Torre de Hanói\n% Fatos\ndisco(d1).\ndisco(d2).\ndisco(d3).\nposte(p1).\nposte(p2).\nposte(p3).\nmenor(d1).\nmaior(d2, d1).\nmaior(d3, d2).\n\n% Regras (Cláusulas de Horn)\n\n% Um disco está em um poste\nem(D, P) :- disco(D), poste(P).\n\n% Um disco está sobre outro\nsobre(D1, D2) :- disco(D1), disco(D2), maior(D1, D2).\n\n% Movimento válido\nmovimento_valido(D, P1, P2) :-\n    em(D, P1),\n    poste(P2),\n    P1 \\= P2,\n    \\+ (em(D2, P2), menor(D2, D)).\n\n% Condição de vitória\nvitoria :-\n    disco(D1),\n    disco(D2),\n    disco(D3),\n    em(D1, p3),\n    em(D2, p3),\n    em(D3, p3).\n\n% Regra de que nenhum disco pode estar sobre um disco menor\ndisco_valido(D1, D2) :-\n    disco(D1),\n    disco(D2),\n    maior(D1, D2).\n\n% Apenas um disco pode ser movido de cada vez\nmovimento_unico(D) :-\n    disco(D),\n    \\+ (disco(D2), D \\= D2, movimento_valido(D2, _, _)).\n\n% Estado inicial\nestado_inicial :-\n    em(d1, p1),\n    em(d2, p1),\n    em(d3, p1),\n    sobre(d3, d2),\n    sobre(d2, d1).\n\n% Consultas possíveis\n% ?- movimento_valido(D, P1, P2).\n% ?- vitoria.\n% ?- disco_valido(D1, D2).\n% ?- movimento_unico(D).\n% ?- estado_inicial.\n\n8.2.0.3.1 Exemplo 4: O Narrador é seu próprio avô\nO problema do narrador que é seu próprio avô é um exemplo clássico de raciocínio lógico e relações familiares. O problema envolve a construção de uma base de conhecimento que representa as relações familiares e a aplicação de regras lógicas para determinar se o narrador realmente é seu próprio avô. Este exemplo foi publicado por Niklaus Wirth em seu livro Algorithms + Data Structures = Programs [^1] fazendo referência a um problema que havia sido publicado em um jornal de Zürich em 1922, que cito em tradução livre a seguir:\nCasei com uma viúva (vamos chamá-la de W) que tem uma filha adulta (chame-a de D). Meu pai (F), que nos visitava com bastante frequência, apaixonou-se pela minha enteada e casou-se com ela. Por isso, meu pai se tornou meu genro e minha enteada se tornou minha madrasta. Alguns meses depois, minha esposa deu à luz um filho (S1), que se tornou cunhado do meu pai, e meu tio. A esposa do meu pai, ou seja, minha enteada, também teve um filho (S2). Em outras palavras, para todos os efeitos, eu sou meu próprio avo.\nUsando este relato como base podemos criar uma base de conhecimento em Prolog, incluir algumas regras, e finalmente verificar se é verdade que o narrador é o seu próprio avô.\n % predicados\nhomem(narrador).\nhomem(f).\nhomem(s1).\nhomem(s2).\n\n% Predicados para relações baseadas em casamentos\nparentesco_legal(narrador,w).\nparentesco_legal(narrador,f).\n\n% relações de parentesco, filhos, netos de sangue\nparentesco(w,d).\nparentesco(f,narrador).\nparentesco(narrador,s1).\nparentesco(f,s2).\n\n% Regras para definir, pai, padrasto e avo\npai(X,Y) :- homem(X), parentesco(X,Y).\npadrasto(X,Y) :-  homem(X), parentesco_legal(X,Y).\navo(X,Z) :- (pai(X,Y); padrasto(X,Y)), (pai(Y,Z) ; padrasto(Y,Z)).\n\n%pergunte se o narrador é avo dele mesmo avo(narrador,narrador)",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html",
    "href": "08-verificacao-formal-de-programas.html",
    "title": "9  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "",
    "text": "9.0.1 Princípios fundamentais e triplas de Hoare\nA lógica de Hoare, desenvolvida por Tony Hoare em 1969, revolucionou a verificação formal ao estabelecer uma base axiomática para provar a correção de programas. O conceito central reside nas triplas de Hoare, que têm a forma {P} C {Q}, em que P representa a pré-condição (propriedade verdadeira antes da execução), C o comando ou programa, e Q a pós-condição (propriedade verdadeira após a execução).\nEsta notação expressa uma relação fundamental: “se P é verdadeiro antes da execução de C, e se C termina, então Q será verdadeiro após a execução de C”. Esta interpretação estabelece a base para correção parcial, distinguindo-se da correção total que também garante terminação.\nOs axiomas fundamentais da lógica de Hoare incluem o axioma da atribuição {Q[E/V]} V := E {Q}, que estabelece que para provar Q após a atribuição V := E, devemos provar Q com E substituído por V antes da atribuição. A regra de sequência {P} C1 {R}, {R} C2 {Q} / {P} C1; C2 {Q} permite compor provas de comandos sequenciais através de condições intermediárias.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "href": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "title": "9  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "9.1 Indução Estrutural: Verificação de Programas Recursivos",
    "text": "9.1 Indução Estrutural: Verificação de Programas Recursivos\n\n9.1.1 Princípios fundamentais e diferenças com indução matemática\nA indução estrutural estende a indução matemática tradicional para estruturas de dados definidas recursivamente. Enquanto a indução matemática opera sobre números naturais com estrutura linear, a indução estrutural aplica-se a estruturas como listas, árvores, e fórmulas lógicas que possuem múltiplas formas de construção.\nA indução matemática tradicional prova propriedades P(n) para números naturais através de um caso base P(0) e um caso indutivo P(k) → P(k+1). A indução estrutural generaliza este princípio para estruturas recursivamente definidas, em que múltiplos construtores podem criar novas instâncias a partir de instâncias existentes.\nPara estruturas de dados indutivos, a indução estrutural baseia-se em uma ordenação bem-fundada. Por exemplo, para listas, a relação “ser sublista de” é bem-fundada, e para árvores, “ser subárvore de” estabelece a ordem necessária. Esta fundamentação garante que toda sequência decrescente é finita, permitindo provas por indução.\n\n\n9.1.2 Aplicação para verificação de programas recursivos\nA indução estrutural é especialmente poderosa na verificação de programas funcionais que operam sobre tipos de dados algébricos. Considere a verificação da propriedade de associatividade para concatenação de listas:\nTeorema: ∀xs ys zs. xs @ (ys @ zs) = (xs @ ys) @ zs\n\nProva por indução estrutural em xs:\nCaso base: xs = []\n  [] @ (ys @ zs) = ys @ zs = ([] @ ys) @ zs\n\nCaso indutivo: xs = h::t\n  Hipótese indutiva: t @ (ys @ zs) = (t @ ys) @ zs\n  (h::t) @ (ys @ zs) = h :: (t @ (ys @ zs))\n                      = h :: ((t @ ys) @ zs)  [por H.I.]\n                      = (h :: (t @ ys)) @ zs\n                      = ((h::t) @ ys) @ zs\nEsta prova demonstra como a estrutura recursiva dos dados guia naturalmente a estrutura da prova, com cada constructor da estrutura correspondendo a um caso na indução.\n\n\n9.1.3 Provas de correção de algoritmos funcionais\nA indução estrutural permite provar correção de algoritmos complexos sobre estruturas recursivas. Para funções sobre árvores, consideremos a verificação de que a reflexão é uma involução:\nTeorema: ∀t. reflect(reflect(t)) = t\n\nProva por indução estrutural:\nCaso base: t = Leaf\n  reflect(reflect(Leaf)) = reflect(Leaf) = Leaf\n\nCaso indutivo: t = Node(l, v, r)\n  H.I.: reflect(reflect(l)) = l ∧ reflect(reflect(r)) = r\n  reflect(reflect(Node(l, v, r))) = reflect(Node(reflect(r), v, reflect(l)))\n                                   = Node(reflect(reflect(l)), v, reflect(reflect(r)))\n                                   = Node(l, v, r)  [por H.I.]\nEsta prova ilustra como hipóteses indutivas múltiplas (para subárvores esquerda e direita) são necessárias para construtores com múltiplos argumentos recursivos.\n\n\n9.1.4 Exemplos práticos com funções recursivas\nA verificação de algoritmos de ordenação por inserção demonstra a aplicação prática da indução estrutural:\nTeorema: ∀lst. sorted(insertion_sort(lst)) ∧ \n                same_elements(lst, insertion_sort(lst))\n\nProva por indução estrutural em lst:\nCaso base: lst = []\n  insertion_sort([]) = []\n  sorted([]) = true\n  same_elements([], []) = true\n\nCaso indutivo: lst = h::t\n  H.I.: sorted(insertion_sort(t)) ∧ same_elements(t, insertion_sort(t))\n  insertion_sort(h::t) = insert(h, insertion_sort(t))\n  \n  Lema: insert preserva ordenação e elementos\n  Logo: sorted(insert(h, insertion_sort(t))) ∧ \n        same_elements(h::t, insert(h, insertion_sort(t)))\nO uso de lemmas auxiliares é frequentemente necessário para provas complexas, permitindo decomposição modular das verificações.\n\n\n9.1.5 Relação com tipos de dados indutivos e coinductivos\nA indução estrutural aplica-se naturalmente a tipos de dados indutivos, que são construídos através de construtores finitos. Tipos indutivos como listas e árvores são definidos através de casos base (lista vazia, folha) e casos recursivos (cons, nó interno).\nPor contraste, tipos coinductivos são definidos através de destrutores/observadores e podem representar estruturas potencialmente infinitas como streams. A coindução é o dual matemático da indução, apropriada para provar propriedades sobre estruturas infinitas através de consistência de observações.\nEm assistentes de prova como Coq, esta dualidade é expressa através da distinção entre tipos Inductive e CoInductive:\n(* Tipo indutivo - lista *)\nInductive list (A : Type) : Type :=\n| nil : list A\n| cons : A -&gt; list A -&gt; list A.\n\n(* Tipo coinductivo - stream *)\nCoInductive stream (A : Type) : Type :=\n| Cons : A -&gt; stream A -&gt; stream A.\nEsta distinção fundamental orienta a escolha entre técnicas de prova indutivas e coindutivas, dependendo da natureza finita ou infinita das estruturas sendo verificadas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "href": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "title": "9  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "9.2 Integração com Lógica de Primeira Ordem",
    "text": "9.2 Integração com Lógica de Primeira Ordem\n\n9.2.1 Especificação de propriedades de programas com FOL\nA lógica de primeira ordem (FOL) fornece a base teórica fundamental para especificação de propriedades de programas. FOL permite expressar propriedades complexas através de quantificadores (∀ - para todo, ∃ - existe) e predicados, oferecendo expressividade suficiente para a maioria das especificações práticas.\nA especificação de contratos de programas utiliza FOL para definir pré-condições, pós-condições e invariantes. Por exemplo, uma função de ordenação pode ter especificação:\n∀array: int[], sorted(array) ↔ \n  ∀i,j: 0 ≤ i &lt; j &lt; array.length → array[i] ≤ array[j]\nEsta especificação captura precisamente o conceito de array ordenado usando quantificadores universais sobre índices e uma implicação que define a relação de ordem.\nPara estruturas de dados mais complexas, FOL permite especificar invariantes estruturais:\n∀tree: BinaryTree, balanced(tree) ↔ \n  ∀node ∈ tree, |height(left(node)) - height(right(node))| ≤ 1\n\n\n9.2.2 Relação entre lógica e correção de programas\nA relação entre FOL e correção de programas manifesta-se através da interpretação semântica das especificações. A lógica de Hoare utiliza FOL como metalinguagem para expressar a semântica de correção parcial e total, sendo que triplas de Hoare são interpretadas como fórmulas FOL.\nA verificação de correção transforma programas anotados em condições de verificação (VCs) expressas em FOL. Estas VCs são então enviadas para provadores automáticos de teoremas (SAT/SMT solvers) que determinam sua validade. Este processo automatiza significativamente a verificação, reduzindo o esforço manual necessário para provas de correção.\nA correção parcial especifica que se a pré-condição é verdadeira e o programa termina, então a pós-condição é verdadeira. A correção total adiciona a garantia de terminação, frequentemente expressa através de variantes que diminuem em relações bem-fundamentadas.\n\n\n9.2.3 Métodos formais em engenharia de software\nA integração de FOL com engenharia de software ocorre através de diversos métodos formais. Model checking explora exaustivamente o espaço de estados de sistemas finitos, verificando propriedades temporais expressas em lógicas como LTL (Linear Temporal Logic) e CTL (Computation Tree Logic).\nTheorem proving oferece verificação interativa ou semi-automática baseada em FOL e lógicas de ordem superior. Ferramentas como Coq, Isabelle/HOL e Lean permitem construção incremental de provas complexas, com verificação automática de correção.\nA abstract interpretation utiliza FOL para especificar domínios abstratos que aproximam o comportamento de programas, permitindo análise estática eficiente para detecção de erros como buffer overflows, null pointer dereferences, e violações de invariantes.\n\n\n9.2.4 Ferramentas modernas e aplicações práticas\nAs ferramentas modernas de verificação formal implementam integração sofisticada entre FOL e verificação de programas. Dafny utiliza Church’s Simple Type Theory, uma extensão de FOL, para especificação e verificação automática através do provador Z3.\nSPARK, baseado em Ada, expressa contratos como predicados FOL e utiliza múltiplos provadores SMT para verificação automática. Esta abordagem demonstra aplicabilidade industrial da verificação formal, com uso em sistemas críticos da aviação e automotivos.\nCoq/Rocq oferece ambiente de prova interativa onde FOL pode ser codificada dentro do sistema de tipos, permitindo formalização matemática rigorosa e extração automática de programas certificados. Projetos como CompCert (compilador C formalmente verificado) demonstram a viabilidade da verificação formal em larga escala.\n\n\n9.2.5 Aplicações em sistemas críticos\nA verificação formal com FOL encontra aplicações cruciais em sistemas críticos. Na aviação, padrões como DO-178C/ED-12C reconhecem métodos formais como meio aceitável para certificação de software aviônico. Projetos como o Airbus A380 utilizaram verificação formal para componentes críticos de controle.\nSistemas automotivos seguem a ISO 26262 para segurança funcional, onde verificação formal contribui para atendimento aos níveis mais altos de integridade de segurança (ASIL D). A verificação de ECUs (Electronic Control Units) utiliza especificações FOL para garantir ausência de erros críticos.\nNa segurança cibernética, a verificação formal de protocolos criptográficos utiliza FOL para especificar propriedades de segurança como confidencialidade, integridade e autenticidade. Projetos como a verificação do microkernel seL4 demonstram correção funcional completa usando Isabelle/HOL.\n\n\n9.2.6 Desafios e direções futuras\nA integração entre FOL e verificação formal enfrenta desafios significativos. A complexidade computacional da verificação cresce exponencialmente com o tamanho dos programas, exigindo técnicas de abstração e decomposição para escalabilidade.\nA usabilidade permanece um obstáculo para adoção ampla, requerendo conhecimento matemático especializado e ferramentas com interfaces ainda em evolução. Desenvolvimentos em automação inteligente, incluindo uso de aprendizado de máquina para geração de especificações e invariantes, prometem reduzir esta barreira.\nTendências emergentes incluem verificação contínua integrada a pipelines DevOps, synthesis automática de código a partir de especificações FOL, e aplicação a novos domínios como blockchain e sistemas de inteligência artificial.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html",
    "href": "09-desafios-logicos-enigmas-e-misterios.html",
    "title": "10  Problemas Interessantes Resolvidos com Lógica Proposicional e Predicativa",
    "section": "",
    "text": "Aqui estão cinco quebra-cabeças clássicos juntamente com suas soluções usando Lógica de Primeira Ordem\n\nQuebra-cabeça: O Mentiroso e o Verdadeiro Você encontra dois habitantes: \\(A\\) e \\(B\\). Você sabe que um sempre diz a verdade e o outro sempre mente, mas você não sabe quem é quem. Você pergunta a \\(A\\), Você é o verdadeiro? A responde, mas você não consegue ouvir a resposta dele. \\(B\\) então te diz, A disse que ele é o mentiroso.\nSolução: \\(A\\) deve ser o verdadeiro e \\(B\\) deve ser o mentiroso. Se \\(B\\) fosse o verdadeiro, ele nunca diria que é o mentiroso. Portanto, \\(B\\) deve ser o mentiroso e \\(A\\) deve ser o verdadeiro, independentemente do que \\(B\\) disse.\nUsando apenas lógica proposicional teremos:\nDefinições: VA: A é o verdadeiro MA: A é o mentiroso VB: B é o verdadeiro MB: B é o mentiroso RA: A respondeu “Sim” à pergunta “Você é o verdadeiro?”\nAxiomas:\n\n\\(VA \\lor MA\\) (A é verdadeiro ou mentiroso);\n\\(\\neg(VA \\land MA)\\) (A não é ambos verdadeiro e mentiroso);\n\\(VB \\lor MB\\) (B é verdadeiro ou mentiroso);\n\\(\\neg(VB \\land MB)\\) (B não é ambos verdadeiro e mentiroso);\n\\(VA \\to \\neg VB\\) (Se A é verdadeiro, B não é verdadeiro);\n\\(VA \\to RA\\) (Se A é verdadeiro, ele respondeu “Sim”);\n\\(MA \\to \\neg RA\\) (Se A é mentiroso, ele respondeu “Não”);\n\\(VB \\to (B \\text{ diz } \\neg RA)\\) (Se B é verdadeiro, ele diz a verdade sobre a resposta de A);\n\\(MB \\to (B \\text{ diz } RA)\\) (Se B é mentiroso, ele mente sobre a resposta de A).\n\nFato observado:\n\\[B \\text{ diz } \\neg RA\\]\nProva:\n\n\\(B \\text{ diz } \\neg RA\\) (Fato observado)\n\\((VB \\land \\neg RA) \\lor (MB \\land RA)\\) (Por 8, 9 e 1)\nSuponha \\(MA\\): 3.1. \\(\\neg RA\\) (Por 7) 3.2. \\(VB\\) (Por 3, 4 e 5) 3.3. Mas isto contradiz 2, pois teríamos \\((VB \\land RA)\\)\nPortanto, \\(\\neg MA\\) (Por reductio ad absurdum)\n\\(VA\\) (Por 1 e 4)\n\nConclusão:\n\\[VA \\land \\neg MA\\]\n\\(A\\) é o verdadeiro e não é o mentiroso.\nUsando lógica de primeiro grau teremos:\nDefinições:\n\n\\(V(x)\\): \\(x\\) é o verdadeiro;\n\\(M(x)\\): \\(x\\) é o mentiroso;\n\\(R(x)\\): \\(x\\) respondeu “Sim” à pergunta “Você é o verdadeiro?”;\n\\(D(x, p)\\): \\(x\\) diz que p é verdadeiro.\n\nAxiomas:\n\n\\(\\forall x (V(x) \\lor M(x))\\) (Todo x é verdadeiro ou mentiroso);\n\\(\\forall x (V(x) \\to \\neg M(x))\\) (Ninguém é ambos verdadeiro e mentiroso);\n\\(\\forall x (V(x) \\to R(x))\\) (Se x é verdadeiro, x responde “Sim”);\n\\(\\forall x (M(x) \\to \\neg R(x))\\) (Se x é mentiroso, x responde “Não”);\n\\(\\forall x \\forall y \\forall p (V(x) \\to (D(x, p) \\leftrightarrow p))\\) (Se x é verdadeiro, x diz p se e somente se p é verdadeiro);\n\\(\\forall x \\forall y \\forall p (M(x) \\to (D(x, p) \\leftrightarrow \\neg p))\\) (Se x é mentiroso, x diz p se e somente se p é falso).\n\nFatos observados:\n\\[D(B, \\neg R(A))\\]\nProva:\n\n\\(D(B, \\neg R(A))\\) (Fato observado);\n\\(V(A) \\lor M(A)\\) (Por 1);\nSuponha \\(M(A)\\): 3.1. \\(\\neg R(A)\\) (Por 4); 3.2. \\(V(B)\\) (Pois apenas um é mentiroso, por 1 e 2); 3.3. \\(D(B, \\neg R(A)) \\leftrightarrow \\neg R(A)\\) (Por 5); 3.4. \\(\\neg R(A)\\) (Por 1 e 3.3); 3.5. Mas isto contradiz 3.1 e 3.4.\nPortanto, \\(\\neg M(A)\\) (Por reductio ad absurdum)\n\\(V(A)\\) (Por 2 e 4)\n\nConclusão: \\[V(A) \\land \\neg M(A)\\]\n\\(A\\) é o verdadeiro e não é o mentiroso.\nQuebra-cabeça: As Três Lâmpadas Existem três lâmpadas incandescentes em uma sala, e existem três interruptores fora da sala. Você pode manipular os interruptores o quanto quiser, mas só pode entrar na sala uma vez. Como você pode determinar qual interruptor opera qual lâmpada?\nSolução: ligue um interruptor e espere um pouco. Então desligue esse interruptor e ligue um segundo interruptor. Entre na sala. A lâmpada que está acesa corresponde ao segundo interruptor. A lâmpada que está desligada e quente corresponde ao primeiro interruptor. A lâmpada que está desligada e fria corresponde ao terceiro interruptor.\nUsando Lógica de Primeira Ordem: Vamos denotar os interruptores como \\(s1, s2, s3\\) e as lâmpadas como \\(b1, b2, b3\\). Podemos definir predicados \\(On(b, s)\\) e \\(Hot(b)\\).\n\\[On(b1, s2) \\land Hot(b2) \\land \\neg (On(b3) \\lor Hot(b3))\\]\nQuebra-cabeça: O Agricultor, a Raposa, o Ganso e o Grão Um agricultor quer atravessar um rio e levar consigo uma raposa, um ganso e um saco de grãos. O barco do agricultor só lhe permite levar um item além dele mesmo. Se a raposa e o ganso estiverem sozinhos, a raposa comerá o ganso. Se o ganso e o grão estiverem sozinhos, o ganso comerá o grão. Como o agricultor pode levar todas as suas posses para o outro lado do rio?\nSolução: o agricultor leva o ganso através do rio primeiro, deixando a raposa e o grão no lado original. Ele deixa o ganso no outro lado e volta para pegar a raposa. Ele deixa a raposa no outro lado, mas leva o ganso de volta ao lado original para pegar o grão. Ele deixa o grão com a raposa no outro lado. Finalmente, ele retorna ao lado original mais uma vez para pegar o ganso.\nUsando Lógica de Primeira Ordem: Podemos definir predicados \\(mesmoLado(x, y)\\) e \\(come (x, y)\\). A solução envolve a sequência de ações que mantêm as seguintes condições:\n\\[\\neg (mesmoLado(Raposa, Ganso) \\land \\neg mesmoLado(Raposa, Fazendeiro))\\]\n\\[\\neg (mesmoLado(Ganso, Grãos) \\land \\neg mesmoLado(Ganso, Fazendeiro))\\]\nQuebra-cabeça: O Problema da Ponte e da Tocha Quatro pessoas chegam a um rio à noite. Há uma ponte estreita, mas ela só pode conter duas pessoas de cada vez. Eles têm uma tocha e, por ser noite, a tocha tem que ser usada ao atravessar a ponte. A pessoa \\(A\\) pode atravessar a ponte em um minuto, \\(B\\) em dois minutos, \\(C\\) em cinco minutos e \\(D\\) em oito minutos. Quando duas pessoas atravessam a ponte juntas, elas devem se mover no ritmo da pessoa mais lenta. Qual é a forma mais rápida para todos eles atravessarem a ponte?\nSolução: primeiro, \\(A\\) e \\(B\\) atravessam a ponte, o que leva 2 minutos. \\(A\\) então pega a tocha e volta para o lado original, levando 1 minuto. \\(A\\) fica no lado original enquanto \\(C\\) e \\(D\\) atravessam a ponte, levando 8 minutos. \\(B\\) então pega a tocha e volta para o lado original, levando 2 minutos. Finalmente, \\(A\\) e \\(B\\) atravessam a ponte novamente, levando 2 minutos. No total, teremos \\(2+1+8+2+2=15\\) minutos.\nUsando Lógica de Primeira Ordem: Vamos denotar o tempo que cada pessoa leva para atravessar a ponte como \\(t_A, t_B, t_C, t_D\\) e o tempo total como \\(T\\). O problema pode ser representado da seguinte forma:\n\\[(t_A + t_B + t_A + t_C + t_D + t_B + t_A) \\leq T\\]\nSubstituindo os valores dos tempos resulta em \\(15 \\leq T\\).\nQuebra-cabeça: O Problema de Monty Hall Em um programa de game show, os concorrentes tentam adivinhar qual das três portas contém um prêmio valioso. Depois que um concorrente escolhe uma porta, o apresentador, que sabe o que está por trás de cada porta, abre uma das portas não escolhidas para revelar uma cabra, representando nenhum prêmio. O apresentador então pergunta ao concorrente se ele quer mudar sua escolha para a outra porta não aberta ou ficar com sua escolha inicial. O que o concorrente deve fazer para maximizar suas chances de ganhar o prêmio?\nSolução: o concorrente deve sempre mudar sua escolha. Inicialmente, a chance do prêmio estar atrás da porta escolhida é \\(1/3\\) e a chance de estar atrás de uma das outras portas é \\(2/3\\). Depois que o apresentador abre uma porta para revelar uma cabra, a chance do prêmio estar atrás da porta não escolhida e não aberta ainda é \\(2/3\\).\nUsando Lógica de Primeira Ordem: Vamos denotar as portas como \\(d1, d2, d3\\) e o prêmio como \\(P\\). Podemos definir um predicado \\(contémPrêmio(d)\\). A solução pode ser representada pela seguinte condição:\n\\[(contémPrêmio(d1) \\land \\neg contémPrêmio(d2) \\land \\neg contémPrêmio(d3)) \\\\ \\lor (contémPrêmio(d2)  \\land \\neg contémPrêmio(d1) \\land \\neg contémPrêmio(d3)) \\\\ \\lor (contémPrêmio(d3) \\land \\neg contémPrêmio(d1) \\land \\neg contémPrêmio(d2))\\]\nEsta condição afirma que o prêmio está exatamente atrás de uma das portas, e o concorrente deve mudar sua escolha depois que uma das portas é aberta para revelar nenhum prêmio.\n\n\n10.0.1 O Mistério da Mansão Hollow – Um Desafio para Detetives Lógicos\n\nObjetivo: Aplicar os princípios da lógica proposicional e de predicados para analisar um conjunto complexo de informações, identificar contradições, realizar deduções formais e solucionar um enigma.\nDescrição: A esforçada leitora foi convidada a investigar um intrigante mistério ocorrido na antiga Mansão Hollow. O renomado inventor, Sir Arthur Blackwood, desapareceu em circunstâncias suspeitas, deixando para trás uma série de pistas, depoimentos de funcionários e familiares, e alguns bilhetes enigmáticos. A polícia local está confusa com a quantidade de informações, algumas aparentemente contraditórias. Você deve montar uma equipe de detetives e superar o famoso detetive Hercule Poirot. Para isso deverá:\n\nAnalisar cuidadosamente todo o material fornecido (descrições de personagens, mapa da mansão, horários, depoimentos, bilhetes).\nFormalizar as informações relevantes utilizando sentenças da lógica proposicional e, quando aplicável, da lógica de predicados.\nConstruir tabelas-verdade e/ou aplicar regras de inferência para verificar a consistência das informações e deduzir novos fatos.\nIdentificar o(s) responsável(is) pelo desaparecimento do Sr. Blackwood (ou determinar o que de fato aconteceu), justificando cada passo da sua conclusão com base nas deduções lógicas realizadas.\n\nA seguir a descrição do caso, o mapa da mansão e os depoimentos dos envolvidos.\n\n10.0.1.1 O Mistério da Mansão Hollow: O Desaparecimento de Sir Arthur Blackwood\nData do Incidente: Segunda-feira, 12 de Maio de 2025 Local: Mansão Hollow, uma propriedade rural isolada. Vítima (Desaparecido): Sir Arthur Blackwood, renomado inventor, 58 anos.\n1. Descrições dos Personagens:\n\nSir Arthur Blackwood: O inventor desaparecido. Gênio excêntrico e recluso, conhecido por sua mente brilhante e comportamento imprevisível. Estava trabalhando febrilmente em um novo projeto secreto chamado “Quimera”.\nSra. Eleanor Blackwood (50 anos): Esposa de Arthur. Uma mulher elegante e ambiciosa, visivelmente preocupada com a reputação e fortuna da família. Ela teme que o comportamento errático de Arthur possa arruiná-los.\nDr. Alistair Finch (45 anos): Um cientista brilhante, antigo protegido de Arthur, mas que se tornou seu principal rival acadêmico e comercial. Chegou à mansão no dia do desaparecimento, alegando buscar uma reconciliação e possível colaboração.\nMiss Clara Evans (28 anos): A jovem e inteligente assistente pessoal de Arthur. Dedicada e leal, trabalhava em estreita colaboração com ele no projeto “Quimera” e conhecia muitos de seus segredos.\nSr. Reginald “Reggie” Croft (65 anos): O mordomo, trabalha para a família Blackwood há mais de trinta anos. É um homem discreto, observador e extremamente leal à memória do falecido pai de Arthur, mas demonstra certa reserva em relação ao próprio Arthur.\nSra. Beatrice Croft (62 anos): Esposa de Reggie, a cozinheira da mansão. Conhece todos os cantos da casa e os hábitos de seus ocupantes. É prática e não se deixa levar por fantasias.\n\nNossos personagens podem ser vistos na imagem abaixo:\n{:class=“lazyload”}\n2. Mapa da Mansão Hollow (Descrição Textual): A Mansão Hollow é uma construção vitoriana de dois andares, com um vasto terreno.\n\nTérreo:\n\nHall de Entrada: Amplo, com piso de mármore, uma imponente escadaria de carvalho que leva ao andar superior. Portas levam à biblioteca (esquerda), sala de estar (direita) e, ao fundo, um corredor para a sala de jantar e a ala de serviço/cozinha.\nBiblioteca: Paredes forradas de estantes com livros antigos e científicos. Uma grande escrivaninha de mogno, poltronas de couro e uma lareira. Duas janelas altas com vista para o jardim da frente.\nSala de Estar: Mobiliário luxuoso, mas um pouco antiquado. Um piano de cauda, lareira e janelas com vista para o jardim lateral e o gazebo.\nSala de Jantar: Uma longa mesa de jantar polida, prataria reluzente. Acesso direto à cozinha.\nCozinha: Grande e funcional, com uma mesa rústica ao centro. Portas para a despensa, os aposentos dos Croft e uma saída para o jardim dos fundos/horta.\nLaboratório do Sr. Blackwood: Localizado no final de um corredor isolado, partindo do hall, perto da escada de serviço. A porta possui uma fechadura especial de alta segurança projetada pelo próprio Arthur. O interior é um caos organizado de equipamentos eletrônicos, protótipos mecânicos, quadros com equações e ferramentas. Possui uma única janela reforçada que dá para o jardim dos fundos. Este é o local principal da investigação inicial.\nEscritório do Sr. Blackwood: Uma sala menor, anexa ao laboratório, acessível apenas por uma porta dentro do laboratório. Mais organizada, com arquivos, patentes, um cofre e um computador.\n\nAndar Superior:\n\nQuarto Principal (Sr. e Sra. Blackwood): Espaçoso, com uma grande cama de dossel, penteadeira, armários embutidos e um banheiro privativo. Uma varanda com vista para o jardim da frente.\nQuarto de Hóspedes: Onde Dr. Finch deixou seus pertences (embora não tenha passado a noite). Confortável, com uma cama de solteiro, escrivaninha e janela para o jardim lateral.\nQuarto de Clara Evans: Menor e mais simples, localizado perto da escada de serviço, com vista para os fundos.\nAposentos do Mordomo e da Cozinheira (Sr. e Sra. Croft): Localizados na ala de serviço, acima da cozinha.\n\nExterior:\n\nJardim da Frente: Um gramado bem cuidado com um caminho circular de cascalho que leva à porta principal. Ladeado por sebes altas.\nJardim Lateral: Menos formal, com um gazebo antigo coberto de hera e canteiros de rosas.\nJardim dos Fundos: Uma área mais extensa e um pouco mais selvagem, com árvores antigas, uma pequena horta cultivada pela Sra. Croft e, nos limites da propriedade, uma velha estufa de vidro abandonada e parcialmente coberta por vegetação.\n\n\nAlguns ambientes da Mansão Hollow podem ser vistos na imagem abaixo:\n\n3. Linha do Tempo (Segunda-feira, 18 de Maio de 1915):\n\n08:00: Café da manhã servido na sala de jantar. Sra. Blackwood preside. Sr. Blackwood não comparece, o que, segundo Sra. Blackwood, era comum quando ele estava imerso em trabalho.\n09:00: Clara Evans leva uma bandeja com café e torradas para o laboratório do Sr. Blackwood.\n10:00: Dr. Alistair Finch chega pontualmente à Mansão Hollow. É recebido pelo mordomo, Sr. Croft, e anunciado à Sra. Blackwood.\n10:15 - 11:00 (aprox.): Dr. Finch e Sra. Blackwood conversam na sala de estar.\n11:00: Sra. Blackwood acompanha Dr. Finch até a porta do laboratório do Sr. Blackwood. Ela bate. Uma voz abafada, identificada por ela como sendo de Arthur, diz: “Estou no meio de algo crítico! Não me perturbem agora!”. Dr. Finch parece contrariado.\n11:05 - 13:00: Período decisivo com movimentações diversas e álibis a serem verificados.\n13:00: O almoço é servido. Sr. Blackwood novamente não aparece.\n14:00: Sra. Blackwood, demonstrando crescente preocupação, pede a Sr. Croft que vá verificar pessoalmente o Sr. Blackwood em seu laboratório.\n14:05: Sr. Croft dirige-se ao laboratório. Encontra a porta especial entreaberta. A fechadura de alta segurança parece ter sido arranhada (marcas de tentativa de arrombamento), mas está destrancada (possivelmente aberta corretamente após a tentativa de arrombamento). O interior do laboratório está em grande desordem: papéis e diagramas espalhados pelo chão, algumas ferramentas fora do lugar, uma cadeira virada. Sr. Blackwood não está em lugar nenhum. A janela dos fundos do laboratório está destrancada e aberta. Não há sinais óbvios de luta violenta (ex: sangue).\n14:15: Sra. Blackwood, após ser informada por Sr. Croft, instrui-o a chamar a polícia local.\n17:00: A notícia do desaparecimento e a natureza peculiar do caso chegam aos ouvidos de Hercule Poirot, que está concluindo um caso em uma cidade vizinha. Ele informa que só poderá dedicar-se ao mistério da Mansão Hollow na manhã seguinte. (Vocês têm até lá para resolver!)\n\n4. Depoimentos Iniciais (Coletados apressadamente pelo Sargento Davis, da polícia local):\n\nSra. Eleanor Clithering:\n\n“Arthur estava impossível nas últimas semanas, totalmente absorvido pelo tal projeto ‘Quimera’. Falava coisas sem sentido sobre revolucionar o mundo, mas também sobre pessoas que queriam roubá-lo. Ele sempre foi um pouco… dramático.”\n“Quando bati à porta do laboratório às 11:00, ouvi claramente Arthur dizer para não ser perturbado. Sim, a voz parecia um pouco abafada, mas era ele. Dr. Finch estava ao meu lado.”\n“Depois disso, subi para meus aposentos para descansar e escrever algumas cartas. Não vi mais o Dr. Finch até a hora do almoço.”\n“A fechadura do laboratório é uma invenção do próprio Arthur. Apenas ele possuía a chave mestra. Ouvi dizer que Clara talvez soubesse algum truque para abri-la, mas forçá-la… faria um barulho terrível, não acha?”\n“Desaparecer assim… não é do feitio de Arthur, a menos que seja parte de algum plano mirabolante dele. Ou então algo terrível aconteceu.”\n\nDr. Alistair Finch:\n\n“Eu vim em uma missão de paz, acreditem. Nossas divergências passadas foram puramente intelectuais. Eu esperava que pudéssemos colaborar. A ideia de roubar o trabalho de Arthur é um insulto.”\n“Sim, a Sra. Blackwood me acompanhou até a porta do laboratório. Ouvi uma voz masculina dizer para não sermos inoportunos. Não posso jurar que era Arthur, a voz estava abafada, como disse a Sra. Blackwood.”\n“Após a recusa, senti-me um pouco desconfortável. Decidi caminhar pelos jardins para espairecer, entre aproximadamente 11:05 e 12:45. Andei pela frente da casa e também pelo jardim lateral, perto do gazebo. O tempo estava agradável.”\n“Não vi ninguém suspeito. Vi o mordomo, Sr. Croft, por um instante, perto da entrada lateral da casa, por volta das 11:20. Ele parecia estar carregando uma caixa ou algo similar em direção à parte de trás da casa ou à adega.”\n“Eu nunca tocaria na fechadura do laboratório de Arthur sem permissão. Seria uma violação imperdoável da ética científica.”\n\nMiss Clara Evans:\n\n“Sr. Blackwood estava muito pressionado, mas também excitado com o ‘Quimera’. Ele dizia que mudaria tudo. Ele confiava em mim implicitamente.”\n“Sim, ele temia que o Dr. Finch, ou outros, pudessem tentar se apropriar de suas descobertas. Ele tomava muitas precauções.”\n“Quando levei seu café às 09:00, ele estava um pouco agitado, mas lúcido. Disse-me: ‘Clara, hoje é um dia de grandes decisões. Lembre-se dos nossos protocolos.’”\n“Entre 11:00 e 13:00, estive principalmente no escritório anexo ao laboratório, compilando dados. A porta entre o escritório e o laboratório estava fechada na maior parte do tempo para que ele tivesse silêncio. Saí brevemente, por volta das 11:30, para ir à biblioteca buscar o ‘Compêndio de Ligas Metálicas Raras’. Fiquei lá uns 15, talvez 20 minutos. Não cruzei com ninguém no corredor ou na biblioteca.”\n“O laboratório tem um bom isolamento acústico, especialmente com a porta do escritório fechada. Não ouvi nenhum barulho de arrombamento. A fechadura especial é complexa; apenas Sr. Blackwood tinha a chave. Eu conheço o procedimento de abertura manual de emergência, mas é uma sequência demorada e específica.”\n\nSr. Reginald “Reggie” Croft (Mordomo):\n\n“Dr. Finch chegou às 10:00. Parecia um pouco nervoso, na minha opinião. Ele e a patroa conversaram na sala de estar por um bom tempo.”\n“Por volta das 11:00, eu estava no hall polindo a prata, e ouvi as vozes da Sra. Blackwood e do Dr. Finch perto do corredor do laboratório. Não prestei muita atenção ao que foi dito. Logo depois, vi a Sra. Blackwood subir a escadaria principal.”\n“De fato, por volta das 11:15, eu estava transportando uma caixa de garrafas de vinho da entrada de serviço lateral para a adega no porão. Nesse momento, vi o Dr. Finch caminhando pelo jardim da frente, perto do portão principal. Ele olhava muito para o relógio.”\n“Quando fui chamado pela Sra. Blackwood às 14:00, encontrei a porta do laboratório como descrito: entreaberta, com arranhões na fechadura, mas destrancada. O Sr. Blackwood era metódico. Se ele não queria ser perturbado, ele trancava a porta de uma forma que ninguém entraria.”\n\nSra. Beatrice Croft (Cozinheira):\n\n“Da cozinha, não se ouve muito do resto da casa, a menos que seja uma gritaria. Estive ocupada com o almoço toda a manhã.”\n“Sr. Blackwood não aparecer para as refeições não era novidade quando estava às voltas com suas invenções malucas.”\n“Uma coisa estranha: Miss Evans passou rapidamente pela cozinha por volta das 12:50. Parecia muito pálida e apressada. Perguntei se estava tudo bem, e ela murmurou algo sobre ir verificar se o Sr. Blackwood queria que o almoço fosse servido no laboratório. Ela voltou alguns minutos depois, ainda mais pálida, e disse que ele não tinha respondido aos chamados dela na porta do laboratório e que era melhor não insistir. Achei estranho ela não ter comentado isso com a Sra. Blackwood imediatamente, antes do alarme oficial.”\n“A janela do laboratório? Sim, dá para uma parte mais isolada d-o jardim dos fundos, perto da minha horta. Se alguém pulou por ali, e se esgueirou pelas árvores, poderia sumir sem ser visto da casa principal.”\n\n\n5. Pistas e Bilhetes Enigmáticos:\n\nPista 1: Papel Amassado na Lixeira do Laboratório: Um pequeno pedaço de papel de anotações, claramente arrancado de um bloco maior, contém a seguinte mensagem escrita à mão por Sr. Blackwood (caligrafia confirmada):\n\n“Se A implica B, e o Corvo visita o Ninho, então a Hipótese se confirma. A negação do consequente é o único caminho seguro. Sigma Ativado.”\n\nPista 2: Objeto Encontrado no Chão do Laboratório, Perto da Mesa Principal: Um pequeno e incomum botão de metal fosco, com um desenho de uma engrenagem estilizada. Não parece pertencer a nenhuma roupa do Sr. Blackwood, nem faz parte do vestuário usual dos funcionários.\nPista 3: Anotação na Margem de um Livro na Biblioteca: No livro “Compêndio de Ligas Metálicas Raras” (o mesmo que Clara Evans mencionou ter pego), na página sobre o Bismuto, há uma pequena anotação a lápis, quase imperceptível:\n\n“Onde o passado encontra o futuro, a reflexão é a chave. \\((\\neg P \\lor Q)\\) é equivalente a ?” A caligrafia parece ser de Sr. Blackwood.\n\nPista 4: Marca Estranha no Batente da Janela Aberta do Laboratório: Do lado de fora do batente da janela do laboratório, há uma leve marca de fuligem ou graxa escura, como se algo metálico e sujo tivesse sido apoiado ali brevemente.\nPista 5: Na Estufa Abandonada (Jardim dos Fundos): Dentro da estufa, sobre uma bancada empoeirada, alguém desenhou com o dedo na poeira um símbolo: um triângulo equilátero com um pequeno círculo no centro. Ao lado do desenho, um único fósforo queimado. Não há outras pegadas recentes visíveis devido ao solo irregular e coberto de folhas secas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Problemas Interessantes Resolvidos com Lógica Proposicional e Predicativa</span>"
    ]
  },
  {
    "objectID": "apendice-a-glossario.html",
    "href": "apendice-a-glossario.html",
    "title": "11  Glossário",
    "section": "",
    "text": "Álgebra de Boole: Sistema algébrico usado na lógica matemática, baseado nos valores verdadeiro (1) e falso (0).\nAntecedente: Em uma implicação \\(P \\rightarrow Q\\), \\(P\\) é o antecedente.\nAridade: Número de argumentos que uma função ou predicado aceita.\nArgumento: Lista de proposições (premissas) seguidas de uma conclusão.\nAssociatividade: Propriedade onde \\((a * b) * c = a * (b * c)\\) para um operador \\(*\\).\nÁtomo: Proposição indivisível ou predicado aplicado a termos em uma fórmula.\nAxioma: Fórmula ou proposição aceita como verdadeira sem necessidade de demonstração.\nBicondicional (\\(\\leftrightarrow\\)): Operador lógico que indica equivalência entre duas proposições.\nCardinalidade: Número de elementos em um conjunto.\nCláusula: Disjunção de literais, como \\(P \\vee Q \\vee \\neg R\\).\nCláusula de Horn: Disjunção de literais com no máximo um literal positivo.\nComutatividade: Propriedade onde \\(a * b = b * a\\) para um operador \\(*\\).\nConclusão: Em um argumento, a proposição final que se deriva das premissas.\nConjunção (\\(\\wedge\\)): Operador lógico “E”.\nConsequente: Em uma implicação \\(P \\rightarrow Q\\), \\(Q\\) é o consequente.\nConstante: Símbolo que representa um objeto específico no domínio do discurso.\nConstante de Skolem: Termo introduzido para eliminar quantificadores existenciais.\nContradição: Fórmula que é sempre falsa, independentemente dos valores de suas variáveis.\nContrapositiva: Para uma implicação \\(P \\rightarrow Q\\), sua contrapositiva é \\(\\neg Q \\rightarrow \\neg P\\).\nDedução: Processo de derivar conclusões lógicas a partir de premissas.\nDisjunção (\\(\\vee\\)): Operador lógico “OU”.\nDistributividade: Propriedade onde \\(a * (b + c) = (a * b) + (a * c)\\) para operadores \\(*\\) e \\(+\\).\nDomínio do Discurso: Conjunto de objetos sobre os quais as variáveis quantificadas podem se referir.\nDupla Negação: Princípio onde \\(\\neg \\neg P \\equiv P\\).\nEquivalência Lógica (\\(\\equiv\\)): Relação entre duas fórmulas que têm o mesmo valor verdade para todas as interpretações.\nEscopo: Parte de uma fórmula à qual um quantificador ou operador se aplica.\nFato: Na programação lógica, afirmação considerada verdadeira sem condições.\nFalseabilidade: Propriedade de uma hipótese que pode ser provada falsa.\nForma Normal Conjuntiva (FNC): Fórmula que é uma conjunção de cláusulas, onde cada cláusula é uma disjunção de literais.\nForma Normal Disjuntiva (FND): Fórmula que é uma disjunção de conjunções de literais.\nForma Normal Negativa (FNN): Fórmula onde as negações aparecem apenas imediatamente antes das variáveis proposicionais.\nForma Normal Prenex: Fórmula onde todos os quantificadores estão no início, seguidos por uma matriz sem quantificadores.\nForma Normal Skolem: Forma Normal Prenex onde todos os quantificadores existenciais foram eliminados.\nFórmula Atômica: Fórmula que consiste em um predicado aplicado a termos.\nFórmula Bem Formada: Sequência de símbolos que segue as regras de formação da linguagem lógica.\nFunção: Mapeamento de um conjunto de argumentos para um valor único.\nFunção de Skolem: Função introduzida para eliminar quantificadores existenciais que dependem de variáveis universalmente quantificadas.\nIdempotência: Propriedade onde \\(a * a = a\\) para um operador \\(*\\).\nImplicação (\\(\\rightarrow\\)): Operador lógico “SE…ENTÃO”.\nIndução Matemática: Método de prova que envolve um caso base e um passo indutivo.\nInferência: Processo de derivar novas informações a partir de informações existentes.\nInstanciação: Substituição de uma variável por um termo específico.\nInterpretação: Atribuição de significado aos símbolos de uma linguagem formal.\nLeis de De Morgan: \\(\\neg(P \\wedge Q) \\equiv (\\neg P \\vee \\neg Q)\\) e \\(\\neg(P \\vee Q) \\equiv (\\neg P \\wedge \\neg Q)\\).\nLema: Proposição auxiliar demonstrável utilizada como passo intermediário na prova de um teorema.\nLiteral: Variável proposicional ou sua negação.\nLógica de Primeira Ordem: Sistema formal para representar e raciocinar sobre propriedades de objetos e relações entre eles.\nLógica Proposicional: Sistema lógico que lida com proposições e suas inter-relações.\nMeta-linguagem: Linguagem usada para descrever outra linguagem.\nModelo: Interpretação que satisfaz um conjunto de fórmulas.\nModus Ponens: Regra de inferência: \\(P, P \\rightarrow Q \\vdash Q\\).\nModus Tollens: Regra de inferência: \\(\\neg Q, P \\rightarrow Q \\vdash \\neg P\\).\nNegação (\\(\\neg\\)): Operador lógico que inverte o valor de verdade de uma proposição.\nPredicado: Função que mapeia objetos a valores de verdade.\nPremissa: Proposição a partir da qual se deriva uma conclusão em um argumento.\nProlog: Linguagem de programação baseada na Lógica de Primeira Ordem e Cláusulas de Horn.\nProva: Sequência de passos lógicos que demonstra a verdade de uma proposição.\nQuantificador Existencial (\\(\\exists\\)): Símbolo lógico que significa “existe pelo menos um”.\nQuantificador Universal (\\(\\forall\\)): Símbolo lógico que significa “para todo”.\nRecíproca: Para uma implicação \\(P \\rightarrow Q\\), sua recíproca é \\(Q \\rightarrow P\\).\nRedução ao Absurdo: Método de prova que assume a negação da conclusão e deriva uma contradição.\nRefutação: Prova da falsidade de uma proposição.\nRegra: Na programação lógica, implicação que define como derivar novos fatos.\nResolução: Regra de inferência usada em provas automatizadas.\nSatisfatibilidade: Propriedade de uma fórmula que é verdadeira para pelo menos uma interpretação.\nSemântica: Estudo do significado em linguagens formais e naturais.\nSilogismo: Forma de raciocínio dedutivo com duas premissas e uma conclusão.\nSintaxe: Conjunto de regras que definem as sequências bem formadas em uma linguagem.\nSkolemização: Processo de eliminação de quantificadores existenciais em uma fórmula lógica.\nTabela Verdade: Tabela que mostra os valores de verdade de uma fórmula para todas as combinações possíveis de seus componentes.\nTautologia: Fórmula que é sempre verdadeira, independentemente dos valores de suas variáveis.\nTeoria: Conjunto de fórmulas em um sistema lógico.\nTeorema: Afirmação que pode ser provada como verdadeira dentro de um sistema lógico.\nTermo: Constante, variável ou função aplicada a outros termos.\nUnificação: Processo de encontrar substituições que tornam dois termos idênticos.\nUniverso de Herbrand: Conjunto de todos os termos básicos que podem ser construídos a partir das constantes e funções de uma linguagem de primeira ordem.\nUniverso do Discurso: Conjunto de todas as entidades sobre as quais as variáveis em uma fórmula lógica podem assumir valores.\nValidade: Propriedade de um argumento onde a conclusão é verdadeira sempre que todas as premissas são verdadeiras.\nVariável: Símbolo que representa um objeto não especificado no domínio do discurso.\nVariável Livre: Variável em uma fórmula que não está ligada a nenhum quantificador.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Glossário</span>"
    ]
  },
  {
    "objectID": "apendice-b-referencias.html",
    "href": "apendice-b-referencias.html",
    "title": "12  Referências",
    "section": "",
    "text": "BOOLOS, G.; BURGESS, J.; JEFFREY, R. Computability and Logic. 5. ed. Cambridge: Cambridge University Press, 2007.\nCHANG, C.C.; KEISLER, H.J. Model Theory. Amsterdam: North-Holland, 1990.\nEBBINGHAUS, H.D.; FLUM, J. Finite Model Theory. 2. ed. Berlin: Springer, 2006.\nGALLIER, J.H. Logic for Computer Science: Foundations of Automatic Theorem Proving. 2. ed. Mineola: Dover Publications, 2015.\nGENESERETH, M.; NILSSON, N. Logical Foundations of Artificial Intelligence. San Francisco: Morgan Kaufmann, 1987.\nINTERNATIONAL MONETARY FUND. World Economic Outlook, October 2023: Navigating Global Divergences. IMF, out. 2023. Disponível em: https://www.imf.org/en/Publications/WEO/Issues/2023/10/10/world-economic-outlook-october-2023. Acesso em: 17 mai. 2025.\nKRIPKE, S. Naming and Necessity. Cambridge: Harvard University Press, 1980.\nMANNA, Z. Verification of Computer Programs. Cambridge: MIT Press, 1974.\nMDPI BLOG. Five Breakthrough Moments in Science and Technology in 2022. MDPI Blog, 23 jan. 2023. Disponível em: https://blog.mdpi.com/2023/01/23/breakthroughs-in-2022/. Acesso em: 17 mai. 2025.\nMIT TECHNOLOGY REVIEW. 10 Breakthrough Technologies 2022. MIT Technology Review, 23 fev. 2022. Disponível em: https://www.technologyreview.com/2022/02/23/1045416/10-breakthrough-technologies-2022/. Acesso em: 17 mai. 2025.\nQUINE, W.V.O. Word and Object. Cambridge: MIT Press, 1960.\nRUSSELL, S.; NORVIG, P. Artificial Intelligence: A Modern Approach. 4. ed. Upper Saddle River: Pearson, 2020.\nVAN HARMELEN, F.; LIFSCHITZ, V.; PORTER, B. (Ed.). Handbook of Knowledge Representation. Amsterdam: Elsevier, 2008.\nWIRTH, N. Algorithms + Data Structures = Programs. 3. ed. Englewood Cliffs: Prentice-Hall, 1976.\n\nAPT, Krzysztof R. Ten years of Hoare’s logic: a survey. ACM Transactions on Programming Languages and Systems, New York, v. 3, n. 4, p. 431-483, Oct. 1981.\nBERTOT, Yves; CASTÉRAN, Pierre. Interactive Theorem Proving and Program Development: Coq’Art: The Calculus of Inductive Constructions. Berlin: Springer, 2004. 469 p.\nBURSTALL, Rod M. Proving properties of programs by structural induction. The Computer Journal, Oxford, v. 12, n. 1, p. 41-48, Feb. 1969.\nDIJKSTRA, Edsger W. A discipline of programming. Englewood Cliffs: Prentice-Hall, 1976.\nFLOYD, Robert W. Assigning meaning to programs. In: SCHWARTZ, J. T. (Ed.). Mathematical Aspects of Computer Science. Providence: American Mathematical Society, 1967. p. 19-32.\nHOARE, Charles Antony Richard. An axiomatic basis for computer programming. Communications of the ACM, New York, v. 12, n. 10, p. 576-580, Oct. 1969.\nLEINO, K. Rustan M. Efficient weakest preconditions. Information Processing Letters, Amsterdam, v. 93, n. 6, p. 281-288, Mar. 2005.\nNIPKOW, Tobias; KLEIN, Gerwin. Concrete Semantics: With Isabelle/HOL. Cham: Springer, 2014. 298 p.\nPIERCE, Benjamin C. et al. Software Foundations. University of Pennsylvania, 2018. Disponível em: https://softwarefoundations.cis.upenn.edu/. Acesso em: 14 jul. 2025.\nREYNOLDS, John C. Theories of Programming Languages. Cambridge: Cambridge University Press, 1998. 513 p.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Referências</span>"
    ]
  }
]