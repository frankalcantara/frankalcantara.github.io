[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Programação Lógica",
    "section": "",
    "text": "1 Apresentação\nA Programação Lógica representa um paradigma fundamental na ciência da computação que tem suas raízes profundamente entrelaçadas com os princípios da lógica matemática e filosófica. Como Marvin Minsky observou, “Logic programming is the future of artificial intelligence”, destacando a importância central deste campo para o desenvolvimento de sistemas inteligentes.\nEste livro convida você a uma jornada através dos fundamentos da lógica e sua aplicação computacional, explorando desde os conceitos básicos da Lógica Proposicional até as aplicações mais avançadas em verificação formal de programas e inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#estrutura-do-livro",
    "href": "index.html#estrutura-do-livro",
    "title": "Introdução à Programação Lógica",
    "section": "1.1 Estrutura do Livro",
    "text": "1.1 Estrutura do Livro\nA obra está organizada em duas partes principais:\nParte I - Fundamentos da Lógica: Apresenta os conceitos fundamentais necessários para compreender a programação lógica, incluindo Lógica Proposicional, técnicas de prova, lógica predicativa e quantificadores.\nParte II - Aplicações Avançadas: Explora as aplicações práticas dos conceitos fundamentais, incluindo formas normais, construção de mundos lógicos, cláusulas de Horn, Prolog, verificação formal e desafios lógicos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#público-alvo",
    "href": "index.html#público-alvo",
    "title": "Introdução à Programação Lógica",
    "section": "1.2 Público-Alvo",
    "text": "1.2 Público-Alvo\nEste material foi desenvolvido para estudantes de ciência da computação, engenharia de software, matemática aplicada e profissionais interessados em compreender os fundamentos teóricos que sustentam muitas das tecnologias modernas de inteligência artificial e sistemas de inferência.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#metodologia",
    "href": "index.html#metodologia",
    "title": "Introdução à Programação Lógica",
    "section": "1.3 Metodologia",
    "text": "1.3 Metodologia\nCada capítulo combina teoria rigorosa com exemplos práticos e exercícios, permitindo ao leitor não apenas compreender os conceitos, mas também aplicá-los na resolução de problemas reais. O texto progride de forma gradual, construindo conhecimento de maneira incremental e sempre conectando novos conceitos aos já estabelecidos.\nEsperamos que esta jornada pela programação lógica seja tanto educativa quanto inspiradora, fornecendo as bases sólidas necessárias para explorar as fronteiras da computação e da inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "01-jornada-programacao-logica.html",
    "href": "01-jornada-programacao-logica.html",
    "title": "2  Introdução ao Paradigma da Programação Lógica",
    "section": "",
    "text": "Tip\n\n\n\nEstá sem tempo? Leia o Expresso.\n\n\nImagine, por um momento, que estamos explorando o universo dos computadores, mas em vez de sermos os comandantes, capazes de ditar todos os passos do caminho, nós fornecemos as diretrizes gerais e deixamos que o computador deduza o caminho. Pode parecer estranho para quem está envolvido com as linguagens do Paradigma Imperativo. Acredite ou não, isso é exatamente o que a Programação Lógica faz.\nEm vez de sermos forçados a ordenar cada detalhe do processo de solução de um problema, a Programação Lógica permite que declaremos o que queremos, e então deixemos o computador fazer o trabalho de encontrar os detalhes e processos necessários para resolver cada problema.\nNa Programação Imperativa partimos de uma determinada expressão e seguimos um conjunto de instruções até encontrar o resultado desejado. O programador fornece um conjunto de instruções que definem o fluxo de controle e modificam o estado da máquina a cada passo. O foco está em como o problema deve ser resolvido. Exemplos de linguagens imperativas incluem C++, Java e Python. Todas hoje são amplamente utilizadas e multiparadigmas, mas não são as únicas disponíveis. A Programação Imperativa é como um chef que segue uma receita passo a passo, onde cada etapa é crucial para o resultado final.\nNa Programação Declarativa, o programador fornece uma descrição lógica ou funcional, do que deve ser feito, sem especificar o fluxo de controle. O foco está no problema, não na solução. Exemplos incluem SQL, Prolog e Haskell. Na Programação Lógica, partimos de um objetivo (goal), quase como se fosse a prova de uma hipótese e, de acordo com um conjunto específico de regras, tentamos construir uma prova para esta hipótese.\nNa Programação Lógica, um dos paradigmas da Programação Declarativa, usamos a dedução para resolver problemas. Começamos com hipóteses e conjecturas.\nUma hipótese é uma suposição, expressa na forma de proposição, que é acreditada ser verdadeira, mas que ainda não foi provada. Uma conjectura, por sua vez, é uma proposição ou sentença declarativa assumida como verdadeira, mas que ainda não foi formalmente provada ou refutada. Com um pouco mais de formalidade, já que a formalidade é o combustível da lógica, podemos dizer:\nConjectura é uma proposição provisoriamente aceita como verdadeira com base em evidências incompletas ou raciocínio plausível, mas que ainda não foi provada ou refutada. É essencialmente uma suposição educada que serve como ponto de partida para investigação posterior. Conjecturas são frequentemente formuladas quando há padrões observáveis ou intuições teóricas, mas falta rigor demonstrativo. A conjetura de Goldbach, que afirma que todo número par maior que \\(2\\) pode ser expresso como a soma de dois números primos, é um exemplo clássico de conjectura. Embora muitos números pares tenham sido verificados e a conjectura pareça verdadeira, ainda não foi provada para todos os números pares.\nHipótese é uma proposição formulada de maneira mais sistemática e específica, que pode ser testada através de métodos empíricos ou dedutivos. Uma hipótese deve ser formulada de modo que seja possível, em princípio, confirmá-la ou refutá-la através de evidências ou procedimentos lógicos específicos. Por exemplo, a hipótese de que “a temperatura afeta a taxa de crescimento das plantas” pode ser testada através de experimentos controlados. Se os resultados do experimento confirmarem a relação entre temperatura e crescimento, a hipótese é apoiada; caso contrário, ela pode ser refutada ou modificada.\nNa Lógica de Primeira Ordem, conjecturas são expressas como fórmulas lógicas que precisam ser verificadas por meio de demonstrações ou contraexemplos. Por exemplo, considere a conjectura: “Todos os números primos são ímpares.” Em Lógica de Primeira Ordem, isso pode ser expresso como:\n\\[\n\\forall x (\\text{Primo}(x) \\rightarrow \\text{Ímpar}(x))\n\\]\nEssa conjectura pode ser refutada pelo contraexemplo do número 2, que é primo, mas não ímpar. Outro exemplo seria: “Todo ser humano é mortal,” expresso como:\n\\[\n\\forall x (\\text{Humano}(x) \\rightarrow \\text{Mortal}(x))\n\\]\nEssa conjectura pode ser considerada verdadeira em muitos contextos, mas requer verificação formal para ser aceita como teorema. Para testar a verdade expressa nessas sentenças, usaremos as ferramentas da Lógica de Primeira Ordem.\n Em resumo: programação imperativa focada no processo, no como chegar à solução; Programação Declarativa focada no problema em si, no o que precisa ser feito. Eu, sempre que posso, escolho uma linguagem descritiva. Não há glória, nem honra nesta escolha: apenas as lamúrias da opinião pessoal.\nSua escolha, pessoal e intransferível, entre estes paradigmas dependerá da aplicação que será construída, tanto quanto dependerá do estilo do programador. Contudo, o futuro parece cada vez mais orientado para linguagens declarativas, que permitam ao programador concentrar-se no problema, não nos detalhes da solução. Efeito que parece ser evidente se considerarmos os avanços da segunda década no século XXI no campo da Inteligência Artificial. Este documento contém a base matemática que suporta o entendimento da programação lógica e um pouco de Prolog, como linguagem de programação para solução de problemas. Será uma longa jornada.\nEm nossa jornada, percorreremos a Lógica de Primeira Ordem. Esta será a nossa primeira rota, que iremos subdividir em elementos interligados e interdependentes e, sem dúvida, de mesma importância e valor: a Lógica Proposicional e a lógica Predicativa. Não deixe de notar que muitos dos nossos companheiros de viagem, aqueles restritos à formalidade acadêmica, podem não entender as sutilezas desta divisão.\nEste timoneiro tenta não ser pretensioso. Partiremos da Lógica Proposicional com esperança de encontrar bons ventos que nos levem até o Prolog.\nA Lógica Proposicional é um tipo de linguagem matemática, suficientemente rica para expressar os problemas que precisamos resolver e suficientemente simples para que computadores possam lidar com ela. Quando esta ferramenta estiver conhecida mergulharemos na alma da Lógica de Primeira Ordem, a Lógica Predicativa, ou Lógica de Predicados, e então poderemos fazer sentido do mundo real de forma clara e bela.\nVamos enfrentar a inferência e a dedução, duas ferramentas fundamentais para extrair conhecimento de declarações lógicas. Imagine um detetive investigando um caso: ele coleta pistas, como pegadas no local do crime, uma testemunha que viu um suspeito de capa preta e a informação de que o crime ocorreu à noite. A inferência é como o processo que o detetive usa para conectar essas pistas. Para chegar a uma conclusão lógica. Por exemplo, se ele sabe que “toda pessoa de capa preta estava no evento à noite” e que “o crime aconteceu no evento à noite”, ele pode inferir que “o suspeito de capa preta é uma pessoa que pode ter cometido o crime”.\nNa Lógica de Primeira Ordem, esse processo é formalizado. Considere as seguintes declarações lógicas como nossas “pistas”:\n\nPremissa 1: Todo ser humano é mortal ((x ((x) (x)))).\nPremissa 2: Sócrates é humano ((())).\n\nUsando a inferência lógica, podemos deduzir que Sócrates é mortal ((())). Aqui, as premissas são as “pistas”, e a inferência é o raciocínio que nos leva à conclusão. Esse processo é incontestável na lógica: se as premissas são verdadeiras, a conclusão também será. Assim, a inferência nos permite extrair verdades novas a partir de verdades conhecidas, de forma clara e estruturada, como um detetive que resolve o caso sem deixar margem para dúvidas.\nNossos mares não serão brandos, mas não nos furtaremos a enfrentar os desafios da Cláusula de Horn, um conceito um pouco mais estranho. Uma restrição sintática sobre as cláusulas de uma fórmula lógica que torna o problema de satisfatibilidade mais fácil de resolver. Como um mapa que, se seguido corretamente, reduz a complexidade computacional de exponencial para polinomial. Muito mais simples, até mesmo passível de automatização eficiente através de algoritmos como unit propagation.\nAs águas se agitarão um pouco mais quando cruzarmos o território da satisfatibilidade, o problema central que governa toda a Lógica Proposicional. A questão fundamental de determinar se existe uma atribuição de valores de verdade que torna uma fórmula lógica verdadeira. Como um detetive que busca descobrir se uma combinação específica de pistas pode resolver completamente um mistério. Este problema, aparentemente simples em sua formulação, revela-se NP-completo, uma classe de problemas para os quais não se conhece algoritmo de tempo polinomial. Desafiando os limites da computação eficiente e impulsionando o desenvolvimento de algoritmos sofisticados como DPLL e CDCL.\n\n\n\n\n\n\nNote\n\n\n\nDPLL (Davis-Putnam-Logemann-Loveland) é um algoritmo clássico para resolver o problema SAT (satisfatibilidade) que utiliza backtracking sistemático. O algoritmo funciona atribuindo valores às variáveis de forma incremental e, quando encontra uma contradição, retrocede para explorar outras possibilidades. Incorpora otimizações como unit propagation (propagação de literais unitários) e pure literal elimination (eliminação de literais puros).\nCDCL (Conflict-Driven Clause Learning) representa a evolução moderna do DPLL. Quando o algoritmo encontra um conflito durante a busca, ao invés de simplesmente retroceder, ele analisa as causas do conflito e aprende uma nova cláusula que previne a repetição do mesmo erro. Essa capacidade de aprendizado, combinada com heurísticas sofisticadas para escolha de variáveis e níveis de backtrack não cronológico, torna o CDCL significativamente mais eficiente que o DPLL tradicional em instâncias práticas complexas.\n\n\nNo final do dia, cansados, porém felizes, vamos entender que, desde os tempos de Gödel, Turing e Church, tudo que queremos é que nossas máquinas sejam capazes de resolver problemas complexos com o mínimo de interferência nossa. Queremos que elas pensem, ou pelo menos, que simulem o pensamento. Aqui, neste objetivo, entre as pérolas mais reluzentes da evolução humana destaca-se a Programação Lógica.\nComo diria Newton podemos olhar tão longe porque nos apoiamos nos ombros de gigantes. Assim, precisamos visitar a história para entender como chegamos até aqui.\nO termo Programação Lógica aparece em meados dos anos 1970 como uma evolução dos esforços nas pesquisas sobre a prova computacional de teoremas matemáticos e Inteligência Artificial. O homem querendo fazer máquinas capazes de raciocinar como o homem. Deste esforço surgiu a esperança de que poderíamos usar a lógica como uma linguagem de programação, em inglês, programming in logic, ou Prolog. Aqui está a base deste conhecimento.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao Paradigma da Programação Lógica</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html",
    "href": "01a-introducao-prolog.html",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "",
    "text": "3.1 O que é Prolog?\nO Prolog (Programming in Logic) é uma linguagem de programação declarativa baseada na lógica de primeira ordem e no princípio de resolução SLD (Selective Linear Definite clause resolution). Desenvolvida por Alain Colmerauer e Philippe Roussel na Universidade de Marselha em 1972, representa um paradigma fundamentalmente diferente das linguagens imperativas tradicionais.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#o-que-é-prolog",
    "href": "01a-introducao-prolog.html#o-que-é-prolog",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "",
    "text": "3.1.1 Paradigma Declarativo vs. Imperativo\nEm linguagens imperativas (C, Java, Python), o programador especifica como resolver um problema através de uma sequência de comandos que modificam o estado do programa. Em Prolog, o programador especifica o que constitui uma solução através de:\n\nFatos: Afirmações básicas sobre o domínio do problema\nRegras: Relações lógicas entre fatos\nConsultas: Perguntas sobre o que pode ser deduzido\n\nO interpretador Prolog utiliza um mecanismo de inferência baseado em resolução e backtracking para encontrar provas construtivas, isto é, não apenas determina se uma afirmação é verdadeira, mas também fornece os valores das variáveis que a tornam verdadeira.\n\n\n3.1.2 Fundamentos Teóricos\nO Prolog baseia-se na correspondência entre:\n\nLógica de primeira ordem → Expressividade para representar conhecimento\nCláusulas de Horn → Subconjunto decidível da lógica proposicional\nPrincípio de resolução → Método de prova por refutação\nMundo fechado (Closed World Assumption) → O que não pode ser provado é falso\n\nPara nossos propósitos práticos, utilizaremos o SWISH, uma interface web que implementa o interpretador SWI-Prolog.\nO SWISH (SWI-Prolog for Philippe Rousselaring) é uma plataforma online que permite executar código Prolog diretamente no navegador, sem necessidade de instalação. Existem vários servidores gratuitos na internet com recursos disponíveis, como compartilhamento de código, colaboração em tempo real e uma interface amigável para iniciantes. Eu uso o SWI. Este servidor é mantido pela comunidade SWI-Prolog, é gratuito e quase sempre está disponível.\n\n\n3.1.3 Como Acessar o SWISH.SWI-Prolog\n\nVá para: https://swish.swi-prolog.org/\nClique em “Create a program” para criar um novo programa\nVocê verá uma interface dividida em duas partes:\n\nLado esquerdo: Editor de código no qual você escreve fatos e regras;\nLado direito: Console de consultas no qual você faz perguntas (consultas) ao Prolog.\n\n\nEste ambiente pode ser visto na Figure 3.1.\n\n\n\n\n\n\nScreenshot do SWISH\n\n\n\n\nFigure 3.1: Página padrão do Swish-swi-prolog.org com o editor de código à esquerda e o console de consultas à direita.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#estrutura-básica-do-prolog-cláusulas-de-horn",
    "href": "01a-introducao-prolog.html#estrutura-básica-do-prolog-cláusulas-de-horn",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.2 Estrutura Básica do Prolog: Cláusulas de Horn",
    "text": "3.2 Estrutura Básica do Prolog: Cláusulas de Horn\nO Prolog trabalha exclusivamente com cláusulas de Horn, uma forma restrita de fórmulas lógicas que possuem no máximo um literal positivo. Esta restrição garante a decidibilidade e eficiência do processo de inferência.\n\n3.2.1 Fatos (Cláusulas Unitárias)\nFatos são cláusulas de Horn unitárias da forma \\(P(t_1, t_2, ..., t_n)\\), onde \\(P\\) é um predicado e \\(t_i\\) são termos. Representam conhecimento básico incondicional sobre o domínio:\n% Predicados unários\nmamifero(gato).\nmamifero(cachorro).\n\n% Predicados binários (relações)\nmaior_que(5, 3).\npai(joao, pedro).\n\n% Predicados n-ários\ndistancia(sao_paulo, rio_janeiro, 400).\nInterpretação formal: Cada fato \\(P(a_1, ..., a_n)\\) é interpretado como “é verdade que \\(P(a_1, ..., a_n)\\)” no modelo mínimo de Herbrand.\n\n\n3.2.2 Regras (Cláusulas Definidas)\nRegras são cláusulas de Horn definidas da forma \\(H \\leftarrow B_1 \\land B_2 \\land ... \\land B_n\\), representadas como H :- B1, B2, ..., Bn. onde:\n\n\\(H\\) (cabeça): Consequente da implicação;\n\\(B_i\\) (corpo): Antecedentes que devem ser satisfeitos;\n\\(\\leftarrow\\): Implicação reversa (“se”);\n\\(\\land\\): Conjunção lógica (vírgula em Prolog).\n\n% Regra simples: ∀X (mamifero(X) → animal(X))\nanimal(X) :- mamifero(X).\n\n% Regra composta: ∀X (voa(X) ↔ ave(X) ∧ ¬pinguim(X))\nvoa(X) :- ave(X), \\+ pinguim(X).\n\n% Regra recursiva: ancestral\nancestral(X, Y) :- pai(X, Y).\nancestral(X, Z) :- pai(X, Y), ancestral(Y, Z).\nSemântica operacional: Para provar \\(H\\), o interpretador deve provar todos os \\(B_i\\) do corpo.\n\n\n3.2.3 Consultas (Goals)\nConsultas são cláusulas de Horn negativas da forma \\(\\leftarrow B_1 \\land B_2 \\land ... \\land B_n\\), representadas como ?- B1, B2, ..., Bn. O interpretador tenta encontrar uma refutação da negação da consulta.\n% Consulta ground (sem variáveis)\n?- mamifero(gato).\n% Resposta: true/false\n\n% Consulta com variáveis livres\n?- animal(X).\n% Resposta: substituições que tornam a consulta verdadeira\n\n% Consulta conjuntiva\n?- pai(X, Y), mae(Z, Y).\n% Encontra todos os X, Y, Z que satisfazem ambas as condições\nProcesso de resolução: O Prolog utiliza o algoritmo SLD-resolution para encontrar uma derivação vazia, provando a consulta por contradição.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#sintaxe-e-semântica-formal",
    "href": "01a-introducao-prolog.html#sintaxe-e-semântica-formal",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.3 Sintaxe e Semântica Formal",
    "text": "3.3 Sintaxe e Semântica Formal\n\n3.3.1 Termos e Estruturas de Dados\nO Prolog trabalha com uma hierarquia bem definida de termos:\n\n3.3.1.1 Termos Simples\n\nÁtomos: constantes simbólicas → joao, nil, [];\nNúmeros: inteiros e reais → 42, 3.14159, -273;\nVariáveis: começam com maiúscula → X, Lista, _Temp;\n\n_ = variável anônima (singleton).\n\n\n\n\n3.3.1.2 Termos Compostos\n\nEstruturas: functor(arg1, arg2, ..., argN);\nListas: [H|T] onde H é cabeça e T é cauda;\nStrings: \"texto\" (lista de códigos ASCII).\n\n% Estruturas complexas\npessoa(nome(joao, silva), idade(25), endereco(rua(x), numero(123))).\n\n% Listas\nlista_vazia([]).\nlista_numeros([1, 2, 3, 4]).\nlista_aninhada([[a, b], [c, d], [e]]).\n\n\n\n3.3.2 Operadores e Conectivos Lógicos\n\n3.3.2.1 Conectivos Básicos\n% Conjunção (∧): vírgula\nregra(X) :- condicao1(X), condicao2(X).\n\n% Disjunção (∨): múltiplas cláusulas\nopcao(X) :- caminho1(X).\nopcao(X) :- caminho2(X).\n% Equivale a: opcao(X) ← caminho1(X) ∨ caminho2(X)\n\n\n3.3.2.2 Negação por Falha (\\+)\n% NAF (Negation as Failure) - não é negação clássica!\nvoa(X) :- ave(X), \\+ pinguim(X).\n% Lê-se: \"X voa se X é ave E não pode ser provado que X é pinguim\"\n\n% CUIDADO: \\+ é não-monotônica\n% Se pinguim(tweety) for adicionado depois, voa(tweety) muda de true para false\n\n\n3.3.2.3 Operadores de Comparação\n% Unificação\nX = Y          % X unifica com Y\nX \\= Y         % X não unifica com Y\n\n% Comparação aritmética (após avaliação)\nX =:= Y        % X é aritmeticamente igual a Y\nX =\\= Y        % X é aritmeticamente diferente de Y\nX &lt; Y, X &gt; Y   % Comparações numéricas\nX =&lt; Y, X &gt;= Y\n\n% Comparação de termos (ordem lexicográfica)\nX == Y         % X é idêntico a Y\nX \\== Y        % X não é idêntico a Y\nX @&lt; Y, X @&gt; Y % Comparação de termos\n\n\n\n3.3.3 Comentários\n% Comentário de linha única\n\n/* Comentário\n   de múltiplas\n   linhas */",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#unificação-o-coração-do-prolog",
    "href": "01a-introducao-prolog.html#unificação-o-coração-do-prolog",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.4 Unificação: O Coração do Prolog",
    "text": "3.4 Unificação: O Coração do Prolog\nUnificação é o processo de encontrar substituições que tornam dois termos sintaticamente idênticos. É o mecanismo fundamental para:\n\nPassagem de parâmetros;\nPattern matching;\nResolução de consultas.\n\n\n3.4.1 Algoritmo de Unificação (Robinson, 1965)\nDados termos \\(s\\) e \\(t\\), a unificação encontra o unificador mais geral (MGU) \\(\\theta\\) tal que \\(s\\theta = t\\theta\\).\n% Casos básicos\n?- X = joao.           % X ← joao\n?- f(X, Y) = f(a, b).  % X ← a, Y ← b\n?- [H|T] = [1,2,3].    % H ← 1, T ← [2,3]\n\n% Unificação recursiva\n?- pessoa(nome(X), idade(Y)) = pessoa(nome(joao), idade(25)).\n% X ← joao, Y ← 25\n\n% Falha de unificação\n?- f(a) = g(a).        % false (functors diferentes)\n?- f(a, b) = f(a).     % false (aridades diferentes)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#backtracking-e-espaço-de-busca",
    "href": "01a-introducao-prolog.html#backtracking-e-espaço-de-busca",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.5 Backtracking e Espaço de Busca",
    "text": "3.5 Backtracking e Espaço de Busca\nBacktracking é a estratégia de busca sistemática que o Prolog usa para explorar todas as possíveis derivações. Implementa uma busca em profundidade com retrocesso.\n\n3.5.1 Mecanismo de Escolha e Retrocesso\n% Base de dados\ngosta(maria, comida, pizza).\ngosta(maria, comida, sushi).\ngosta(joao, comida, pizza).\ngosta(joao, bebida, cerveja).\n\nsaida(X, Y) :- gosta(X, comida, Y).\nsaida(X, Y) :- gosta(X, bebida, Y).\nTrace da consulta ?- saida(maria, X).:\n\nPonto de escolha: primeira cláusula de saida/2;\nUnificação: saida(maria, X) com saida(X, Y) :- gosta(X, comida, Y)\n\nX ← maria, Y ← X (variável da consulta);\n\nNova meta: gosta(maria, comida, X);\nPrimeira solução: X ← pizza;\nBacktrack (se solicitado): tenta próxima solução;\nSegunda solução: X ← sushi;\nBacktrack: tenta segunda cláusula de saida/2;\nNova meta: gosta(maria, bebida, X) → falha.\n\n\n\n3.5.2 Cut (!) - Controle de Backtracking\n% Sem cut - busca exaustiva\nmax_sem_cut(X, Y, X) :- X &gt;= Y.\nmax_sem_cut(X, Y, Y) :- Y &gt; X.\n\n% Com cut - determinístico\nmax_com_cut(X, Y, X) :- X &gt;= Y, !.\nmax_com_cut(X, Y, Y).\n\n% Green cut vs Red cut\ndeterministico(X) :- condicao(X), !.  % Green cut (não muda semântica)\ndeterministico(X) :- alternativa(X).\n\nperigoso(X) :- condicao1(X), !, acao_perigosa(X).  % Red cut (muda semântica)\nperigoso(X) :- condicao2(X).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#resolução-sld-e-árvores-de-prova",
    "href": "01a-introducao-prolog.html#resolução-sld-e-árvores-de-prova",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.6 Resolução SLD e Árvores de Prova",
    "text": "3.6 Resolução SLD e Árvores de Prova\n\n3.6.1 Processo de Resolução\nO Prolog implementa SLD-resolution (Selective Linear Definite clause resolution):\n\nSelecionar literal do goal atual\nUnificar com cabeça de uma cláusula\nResolver substituindo o literal pelo corpo da cláusula\nRepetir até goal vazio (sucesso) ou falha\n\n\n\n3.6.2 Árvore de Derivação SLD\nPara a consulta ?- ancestral(joao, X). com programa:\nancestral(X, Y) :- pai(X, Y).\nancestral(X, Z) :- pai(X, Y), ancestral(Y, Z).\npai(joao, pedro).\npai(pedro, ana).\n?- ancestral(joao, X)\n├─ (regra 1) pai(joao, X) ──→ X=pedro \n└─ (regra 2) pai(joao, Y), ancestral(Y, X)\n   └─ Y=pedro, ancestral(pedro, X)\n      ├─ (regra 1) pai(pedro, X) ──→ X=ana \n      └─ (regra 2) pai(pedro, Z), ancestral(Z, X) ──→ falha\n\n\n3.6.3 Complexidade e Limitações\n\nDecidibilidade: Programas Prolog podem não terminar;\nCompletude: SLD-resolution é completa para cláusulas de Horn;\nComplexidade: Exponencial no pior caso (backtracking);\nOrdem das cláusulas: Afeta eficiência e terminação.\n\n% Programa que não termina\nloop(X) :- loop(X).\n\n% Solução: reordenar para casos base primeiro\nfatorial(0, 1) :- !.\nfatorial(N, F) :- N &gt; 0, N1 is N-1, fatorial(N1, F1), F is N * F1.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#executando-código-no-swish",
    "href": "01a-introducao-prolog.html#executando-código-no-swish",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.7 Executando Código no SWISH",
    "text": "3.7 Executando Código no SWISH\n\n3.7.1 Passo 1: Escrever o Programa\nEm um arquivo novo, no editor (lado esquerdo), digite fatos e regras:\n% Base de conhecimento sobre família\npai(joao, pedro).\npai(pedro, ana).\nmae(maria, pedro).\nmae(ana, carlos).\n\n% Regra para definir genitor\ngenitor(X, Y) :- pai(X, Y).\ngenitor(X, Y) :- mae(X, Y).\n\n% Regra para definir avô\navo(X, Z) :- genitor(X, Y), genitor(Y, Z).\n\n\n3.7.2 Passo 2: Salvar e Carregar\n\nPara salvar um programa, você precisa estar logado no SWISH. Pode logar com o sua conta do Google ou com o StackOverflow.\nClique no menu File/Save para salvar o programa\nUma vez salvo, o programa é automaticamente carregado na memória do Prolog\n\n\n\n3.7.3 Passo 3: Fazer Consultas\nNo console (lado direito), digite consultas:\n?- pai(joao, pedro).\nResposta esperada: true.\n?- genitor(X, pedro).\nResposta esperada: X = joao ; X = maria.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#interpretando-respostas",
    "href": "01a-introducao-prolog.html#interpretando-respostas",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.8 Interpretando Respostas",
    "text": "3.8 Interpretando Respostas\n\n3.8.1 Respostas Simples\n\ntrue. → A consulta é verdadeira;\nfalse. → A consulta é falsa/não pode ser provada.\n\n\n\n3.8.2 Respostas com Variáveis\n?- pai(X, pedro).\nX = joao.\nO Prolog encontrou que X = joao satisfaz a consulta.\n\n\n3.8.3 Múltiplas Soluções\n?- genitor(X, Y).\nX = joao, Y = pedro ;\nX = pedro, Y = ana ;\nX = maria, Y = pedro ;\nX = ana, Y = carlos.\n\nUse ; (ponto e vírgula) ou barra de espaço para ver a próxima solução;\nO Prolog mostra todas as combinações possíveis.\n\n\n\n3.8.4 Forçando Múltiplas Respostas\nApós uma resposta, você pode:\n\nPressionar ; para ver mais soluções;\nPressionar . (ponto) para parar.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#aplicações-em-ciência-da-computação",
    "href": "01a-introducao-prolog.html#aplicações-em-ciência-da-computação",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.9 Aplicações em Ciência da Computação",
    "text": "3.9 Aplicações em Ciência da Computação\n\n3.9.1 1. Sistemas Especialistas e Representação de Conhecimento\n% Sistema de diagnóstico médico\nsintoma(joao, febre).\nsintoma(joao, tosse).\nsintoma(maria, febre).\nsintoma(maria, dor_cabeca).\n\n% Regras de diagnóstico\ndiagnostico(Paciente, gripe) :-\n    sintoma(Paciente, febre),\n    sintoma(Paciente, tosse),\n    \\+ sintoma(Paciente, erupcao).\n\ndiagnostico(Paciente, enxaqueca) :-\n    sintoma(Paciente, dor_cabeca),\n    sintoma(Paciente, nausea).\n\n% Incerteza bayesiana (extensão)\ndiagnostico_probabilistico(Paciente, Doenca, Prob) :-\n    findall(S, sintoma(Paciente, S), Sintomas),\n    calcular_probabilidade(Sintomas, Doenca, Prob).\n\n\n3.9.2 2. Processamento de Linguagem Natural\n% Gramática de cláusulas definidas (DCG)\nsentenca --&gt; sintagma_nominal, sintagma_verbal.\nsintagma_nominal --&gt; determinante, substantivo.\nsintagma_verbal --&gt; verbo, sintagma_nominal.\n\ndeterminante --&gt; [o].\ndeterminante --&gt; [a].\nsubstantivo --&gt; [gato].\nsubstantivo --&gt; [rato].\nverbo --&gt; [persegue].\n\n% Parsing\n?- sentenca([o, gato, persegue, o, rato], []).\n% true - sentença válida\n\n% Geração\n?- sentenca(S, []).\n% S = [o, gato, persegue, o, rato]\n% S = [o, gato, persegue, a, rato]\n% ... (todas as combinações válidas)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#limitações-e-considerações-de-performance",
    "href": "01a-introducao-prolog.html#limitações-e-considerações-de-performance",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.10 Limitações e Considerações de Performance",
    "text": "3.10 Limitações e Considerações de Performance\n\n3.10.1 Complexidade Computacional\n\nConsultas ground: Tempo linear no tamanho do programa;\nConsultas com variáveis: Potencialmente exponencial;\nProgramas recursivos: Podem não terminar;\nEspaço: Pilha de escolhas pode crescer exponencialmente.\n\n\n\n3.10.2 Otimizações Modernas\n% Tabling (memoização) - SWI-Prolog\n:- table fibonacci/2.\n\nfibonacci(0, 1) :- !.\nfibonacci(1, 1) :- !.\nfibonacci(N, F) :-\n    N &gt; 1,\n    N1 is N-1, N2 is N-2,\n    fibonacci(N1, F1),\n    fibonacci(N2, F2),\n    F is F1 + F2.\n\n% Constraint Logic Programming (CLP)\n:- use_module(library(clpfd)).\n\nsudoku(Vars) :-\n    Vars = [X11,X12,X13,X21,X22,X23,X31,X32,X33],\n    Vars ins 1..3,\n    all_different([X11,X12,X13]),\n    all_different([X21,X22,X23]),\n    all_different([X31,X32,X33]),\n    all_different([X11,X21,X31]),\n    all_different([X12,X22,X32]),\n    all_different([X13,X23,X33]).\n\n\n3.10.3 Boas Práticas para Eficiência\n\nOrdenação de cláusulas: Casos base primeiro;\nUso criterioso do cut: Evitar backtracking desnecessário;\nTail recursion: Para evitar estouro de pilha;\nIndexação: SWI-Prolog indexa primeiro argumento automaticamente;\nAvoid ground/1 quando possível: Use type checking específico.\n\nNós vamos voltar a esses tópicos ao longo do livro, mas é importante ter uma visão geral desde o início. Principalmente porque a partir deste ponto, podemos incluir testes com o Prolog para validar a lógica que suporta o funcionamento do próprio Prolog. Mais um círculo virtuoso de aprendizado e desenvolvimento tecnológico.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html",
    "href": "02-fundamentos-logica-proposicional.html",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "",
    "text": "4.0.1 Alfabeto e Sintaxe da Lógica de Primeira Ordem\nA Lógica de Primeira Ordem é uma linguagem e, consequentemente, foi criada a partir de um alfabeto, \\(\\Sigma\\), de um conjunto de axiomas e de um conjunto de regras de inferência. Esta linguagem consiste de todas as Fórmulas Bem Formadas da teoria das lógicas proposicional e predicativa. Neste ponto, a atenta leitora deve perceber que o conjunto de axiomas é um subconjunto do conjunto de Fórmulas Bem Formadas.\nO alfabeto \\(\\Sigma\\) que estamos definindo poderá ser dividido em classes formadas por conjuntos de símbolos agrupados por semelhança. Assim:\nNa lógica matemática, uma Fórmula Bem Formada, ou Expressão Bem Formada, é uma sequência finita de símbolos formada de acordo com as regras gramaticais de uma linguagem formal especificamente desenvolvida para a redação das fórmulas da lógica.\nEm Lógica de Primeira Ordem, uma Fórmula Bem Formada é uma expressão que só pode ser verdadeira ou falsa. As Fórmulas Bem Formadas são compostas de símbolos que representam quantificadores, variáveis, constantes, predicados, e conectivos lógicos. Cuja distribuição e uso seguirão as regras sintáticas, gramaticais e semânticas da linguagem da lógica. Aprender lógica é aprender esta linguagem.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#fundamentos-da-lógica-proposicional",
    "href": "02-fundamentos-logica-proposicional.html#fundamentos-da-lógica-proposicional",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.1 Fundamentos da Lógica Proposicional",
    "text": "4.1 Fundamentos da Lógica Proposicional\nEsse sistema, também chamado de álgebra booleana, fundamental para o desenvolvimento da computação, é uma verdadeira tapeçaria de possibilidades. Na Lógica Proposicional, declarações atômicas, que só podem ter valores verdadeiro, \\(TRUE\\), ou falso \\(FALSE\\), são entrelaçadas em declarações compostas cuja veracidade, segundo as regras desse cálculo, depende dos valores de verdade das declarações atômicas que as compõem quando sujeitas aos operadores, ou aos conectivos, que definimos anteriormente.\nNa Lógica Proposicional, representamos proposições atômicas por letras como \\(P\\), \\(Q\\), \\(R\\), \\(S\\), ou usando índices como em \\(X_1\\), \\(X_2\\), etc. Um literal será definido como uma variável literal, ou uma proposição atômica, (por exemplo, \\(P\\) ou \\(Q\\)) ou sua negação (por exemplo, \\(\\neg P\\) ou \\(\\neg Q\\)). Os literais são as unidades básicas da Lógica Proposicional, assumindo valores de verdade verdadeiro (\\(TRUE\\)) ou falso (\\(FALSE\\)), e são combinados por conectivos lógicos (\\(\\neg, \\wedge, \\vee, \\rightarrow, \\leftrightarrow\\)) para formar fórmulas mais complexas.\nNa Lógica Proposicional, as fórmulas são conhecidas como Fórmulas Bem Formadas. Elas podem ser atômicas ou compostas. Nas fórmulas compostas, um operador principal, um conectivo, liga duas fórmulas atômicas, ou duas fórmulas compostas. Ou seja, as declarações atômicas e compostas são costuradas por conectivos para produzir declarações compostas, cujo valor de verdade depende dos valores de verdade das declarações componentes. Os conectivos que consideramos inicialmente, e suas tabelas-verdade podem ser vistos na #tbl-verdade1:\n\n\n\nTable 4.1: Tabela Verdade, operadores básicos.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P\\vee Q\\)\n\\(P\\wedge Q\\)\n\\(\\neg P\\)\n\\(P\\rightarrow Q\\)\n\\(P\\leftrightarrow Q\\)\n\n\n\n\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\n\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\n\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\n\n\n\n\n4.1.0.1 Análise dos Conectivos Lógicos\nQuando usamos a Tabela Verdade em uma declaração composta, podemos verificar a fórmula como verdadeira ou falsa. Para tanto, basta seguir as regras de precedência e aplicar os valores representados na Tabela Verdade de cada conectivo, simplificando a expressão. O uso da Tabela Verdade é uma alternativa mais direta do que o uso dos axiomas da Lógica Proposicional.\nNa tabela Table 4.1, listamos os conectivos, ou operadores, da Lógica Proposicional.\nO operador \\(\\vee\\), também chamado de ou inclusivo, é verdadeiro quando pelo menos um dos termos é verdadeiro. A atenta leitora deve observar que o \\(\\vee\\) difere do operador \\(\\oplus\\), ou exclusivo, que será falso se ambos os termos forem iguais, sejam eles verdadeiros ou falsos.\nO operador \\(\\wedge\\), também chamado de conjunção, é verdadeiro apenas quando ambos os termos são verdadeiros. Em linguagem natural, corresponde ao “e” lógico, como em “o céu está azul e a grama é verde”.\nO condicional \\(\\rightarrow\\) não implica em causalidade. O condicional \\(\\rightarrow\\) é falso apenas quando o antecedente é verdadeiro e o consequente é falso.\nO bicondicional \\(\\leftrightarrow\\) equivale a ambos os componentes terem o mesmo valor-verdade. Em linguagem natural, corresponde à expressão “se e somente se”, indicando que as duas proposições são verdadeiras ou falsas simultaneamente.\nTodos os operadores, ou conectivos, conectam duas declarações, exceto \\(\\neg\\) que se aplica a apenas um termo. O operador \\(\\neg\\), chamado de negação, inverte o valor-verdade de uma proposição, sendo verdadeiro quando a proposição é falsa e vice-versa.\nCada operador com sua própria aridade como pode ser visto na Table 4.2:\n\n\n\nTable 4.2: Aridade dos Operadores da Lógica Proposicional.\n\n\n\n\n\nNo Argumentos\nAridade\nExemplos\n\n\n\n\n1\nUnário\n\\(P(x)\\), \\(7x\\)\n\n\n2\nBinário\n\\(x \\vee y\\), \\(c \\wedge y\\)\n\n\n\n\n\n\nAinda observando a Table 4.1, que contém a Tabela Verdade dos operadores da Lógica Proposicional, é possível perceber que se tivermos quatro termos diferentes, em vez de dois, teremos \\(2^4 = 16\\) linhas. Independentemente do número de termos, se para uma determinada Fórmula Bem Formada todos os resultados forem verdadeiros, \\(TRUE\\), teremos uma tautologia, se todos forem falsos, \\(FALSE\\) uma contradição.\n\n\n4.1.1 Exercícios: Tabelas-Verdade e Conectivos Lógicos\nInstrução: Para cada uma das fórmulas a seguir, construa a tabela-verdade completa.\n\n\\(P \\rightarrow \\neg Q\\)\n\\((P \\lor Q) \\land R\\)\n\\(P \\leftrightarrow (P \\land Q)\\)\n\\((P \\land (P \\rightarrow Q)) \\rightarrow Q\\)\n\\((P \\rightarrow Q) \\land (P \\land \\neg Q)\\)\n\\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\)\n\\((A \\rightarrow B) \\lor (B \\rightarrow C)\\)\n\\(\\neg(P \\land Q) \\leftrightarrow (\\neg P \\lor \\neg Q)\\)\nAnalise a validade do seguinte argumento construindo uma tabela-verdade para a fórmula correspondente: “Se o programa é eficiente (\\(P\\)), o custo é baixo (\\(Q\\)). O programa é eficiente. Portanto, o custo é baixo.”\nConstrua a tabela-verdade para a fórmula \\((P \\lor Q) \\rightarrow (P \\land Q)\\).\n\n\n\n4.1.2 Equivalências Lógicas\n\n4.1.2.1 Principais Leis da Lógica Proposicional\nUma tautologia é uma fórmula que é sempre verdadeira, não importa os valores dados às variáveis. Na Programação Lógica, tautologias são verdades universais no domínio do problema. Uma contradição é uma fórmula que é sempre falsa, independentemente dos valores das variáveis. Em Programação Lógica, contradições mostram inconsistências ou impossibilidades lógicas no domínio.\nIdentificar tautologias permite simplificar expressões e fazer inferências válidas automaticamente. Reconhecer contradições evita o custo de tentar provar algo logicamente impossível.\nLinguagens de programação que usam a Programação Lógica usam unificação e resolução para fazer deduções. Tautologias geram cláusulas vazias que simplificam esta resolução. Em problemas de satisfatibilidade, se obtivermos uma contradição, sabemos que as premissas são insatisfatíveis. Segure as lágrimas e o medo. Os termos unificação e satisfatibilidade serão explicados assim que sejam necessários. Antes disso, precisamos falar de equivalências. Para isso vamos incluir um metacaractere no alfabeto da nossa linguagem: o caractere \\(\\equiv\\) que permitirá o entendimento das principais equivalências da Lógica Proposicional explicitadas a seguir:\nAs equivalências lógicas permitem validar Fórmulas Bem Formadas sem recorrer a tabelas-verdade, simplificando expressões e facilitando provas lógicas. A tabela Table 4.3 que usa um metasímbolo para definir equivalência \\(\\equiv\\), que não faz parte da linguagem que definimos para a lógica de primeira ordem mas será usado aqui em prol da didática, apresenta as principais equivalências da Lógica Proposicional, usadas nos exemplos deste documento:\n\n\n\nTable 4.3: Tabela 3 - Equivalências em Lógica Proposicional.\n\n\n\n\n\n\n\n\n\n\nExpressão Lógica Equivalente\nNome da Lei/Propriedade\nRef.\n\n\n\n\n( P Q Q P )\nComutatividade da Conjunção\n(1)\n\n\n( P Q Q P )\nComutatividade da Disjunção\n(2)\n\n\n( P (Q R) (P Q) (P R) )\nDistributividade da Conjunção sobre a Disjunção\n(3)\n\n\n( P (Q R) (P Q) (P R) )\nDistributividade da Disjunção sobre a Conjunção\n(4)\n\n\n( (P Q) P Q )\nLei de De Morgan\n(5)\n\n\n( (P Q) P Q )\nLei de De Morgan\n(6)\n\n\n( P Q P Q )\nDefinição de Implicação\n(7)\n\n\n( P Q (P Q) (Q P) )\nDefinição de Equivalência\n(8)\n\n\n( P Q Q P )\nLei da Contrapositiva\n(9)\n\n\n( P P \\(FALSE\\) )\nLei da Contradição\n(10)\n\n\n( P P \\(TRUE\\) )\nLei do Terceiro Excluído\n(11)\n\n\n( (P) P )\nLei da Dupla Negação\n(12)\n\n\n( P P )\nLei da Identidade\n(13)\n\n\n( P \\(TRUE\\) P )\nLei da Identidade para a Conjunção\n(14)\n\n\n( P \\(FALSE\\) \\(FALSE\\) )\nLei do Domínio para a Conjunção\n(15)\n\n\n( P \\(TRUE\\) \\(TRUE\\) )\nLei do Domínio para a Disjunção\n(16)\n\n\n( P \\(FALSE\\) P )\nLei da Identidade para a Disjunção\n(17)\n\n\n( (P Q) R P (Q R) )\nAssociatividade da Conjunção\n(18)\n\n\n( (P Q) R P (Q R) )\nAssociatividade da Disjunção\n(19)\n\n\n( P P P )\nIdempotência da Conjunção\n(20)\n\n\n( P P P )\nIdempotência da Disjunção\n(21)\n\n\n\n\n\n\nComo as equivalências apresentadas na Tabela Table 4.3 permitem validar Fórmulas Bem Formadas, sem o uso de uma tabela verdade, a corajosa leitora poderia tentar provar cada uma delas.\n\n\n4.1.2.2 Aplicação das Equivalências Lógicas\nAs equivalências que mencionei surgiram quase naturalmente enquanto escrevia, mais por hábito e necessidade do que por um raciocínio organizado. Existem muitas equivalências, mas essas são as que uso com mais frequência. Talvez, alguns exemplos de validação de Fórmulas Bem Formadas, usando apenas as equivalências da Tabela 3, possam inflar as velas do conhecimento e nos guiar pelo caminho que devemos seguir:\n\n4.1.2.2.1 Exemplos de Simplificação - Nível Básico\nExemplo 1: Vamos simplificar a fórmula \\(P \\wedge (Q \\vee (P \\wedge R))\\) e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\nP \\wedge (Q \\vee (P \\wedge R)) &\\equiv (P \\wedge Q) \\vee (P \\wedge (P \\wedge R)) && \\text{Distributividade da Conjunção sobre a Disjunção} \\\\\n&\\equiv (P \\wedge Q) \\vee ((P \\wedge P) \\wedge R) && \\text{Associatividade da Conjunção} \\\\\n&\\equiv (P \\wedge Q) \\vee (P \\wedge R) && \\text{Idempotência da Conjunção}\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (P \\wedge R)\\). Para determinar se a fórmula é uma tautologia, satisfatível ou falsificável, construímos a tabela-verdade completa para as variáveis \\(P\\), \\(Q\\), \\(R\\):\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(P \\wedge Q\\)\n\\(P \\wedge R\\)\n\\((P \\wedge Q) \\vee (P \\wedge R)\\)\n\n\n\n\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nFALSE\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\n\n\nFALSE\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\nFALSE\n\n\n\nAnalisando a tabela completa: - A fórmula é verdadeira em 3 das 8 linhas (linhas 1, 2 e 3), portanto é satisfatível. - A fórmula é falsa em 5 das 8 linhas, portanto não é uma tautologia. - A presença de linhas falsas confirma que a fórmula é falsificável.\nConclusão: A fórmula \\(P \\wedge (Q \\vee (P \\wedge R))\\) simplifica para \\((P \\wedge Q) \\vee (P \\wedge R)\\), que é satisfatível e falsificável, mas não é uma tautologia. Exemplo 2: \\(P\\rightarrow (Q \\wedge (R \\vee P))\\)\n\\[\n\\begin{align*}\nP \\rightarrow (Q \\wedge (R \\vee P)) &\\equiv \\neg P \\vee (Q \\wedge (R \\vee P)) && \\text{(7)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (\\neg P \\vee (R \\vee P)) && \\text{(4)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (R \\vee \\neg P \\vee P) && \\text{(2)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge $TRUE$ && \\text{(11)} \\\\\n&\\equiv \\neg P \\vee Q && \\text{(14)}\n\\end{align*}\n\\]\nExemplo 3: \\(\\neg (P \\wedge (Q \\rightarrow R))\\)\n\\[\n\\begin{align*}\n\\neg (P \\wedge (Q \\rightarrow R)) &\\equiv \\neg (P \\wedge (\\neg Q \\vee R)) && \\text{(7)} \\\\\n&\\equiv \\neg P \\vee \\neg (\\neg Q \\vee R) && \\text{(5)} \\\\\n&\\equiv \\neg P \\vee (Q \\wedge \\neg R) && \\text{(6)}\n\\end{align*}\n\\]\n\n\n4.1.2.2.2 Exemplos de Simplificação - Nível Intermediário\nExemplo 4: \\(\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S))\\)\n\\[\n\\begin{align*}\n\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S)) &\\equiv \\neg ((\\neg P \\vee Q) \\wedge (\\neg R \\vee S)) && \\text{(7)} \\\\\n&\\equiv \\neg (\\neg P \\vee Q) \\vee \\neg (\\neg R \\vee S) && \\text{(5)} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (R \\wedge \\neg S) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 5: Vamos simplificar a fórmula \\((P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P)\\) e determinar suas propriedades lógicas.\n\\[\n\\begin{align*}\n(P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P) &\\equiv (\\neg P \\vee Q) \\vee (\\neg R \\vee S) \\vee (\\neg E \\vee P) && \\text{Definição de Implicação} \\\\\n&\\equiv \\neg P \\vee Q \\vee \\neg R \\vee S \\vee \\neg E \\vee P && \\text{Associatividade da Disjunção} \\\\\n&\\equiv (\\neg P \\vee P) \\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{Comutatividade da Disjunção} \\\\\n&\\equiv$TRUE$\\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv$TRUE$&& \\text{Lei da Dominação da Disjunção}\n\\end{align*}\n\\]\nA expressão se simplifica para\\(TRUE\\)pela lei da dominação, que estabelece que \\(TRUE \\vee X \\equiv TRUE\\) para qualquer proposição \\(X\\).\nComo a fórmula se reduz a\\(TRUE\\), ela é uma tautologia - sempre verdadeira independentemente das valorações das variáveis proposicionais.\nVerificação: Em qualquer linha de uma tabela-verdade para as cinco variáveis \\((P, Q, R, S, E)\\), a presença de \\(\\neg P \\vee P\\) (que é sempre \\(TRUE\\)) garante que toda a disjunção seja verdadeira.\nConclusão: A fórmula \\((P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P)\\) é uma tautologia, pois se simplifica para\\(TRUE\\)através da presença de \\(\\neg P \\vee P\\) na disjunção expandida.\nExemplo 6: Vamos simplificar a fórmula \\(P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P)\\) passo a passo e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\n& P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P) \\\\\n&\\equiv P \\wedge (Q \\vee (\\neg R \\vee S)) \\vee ((\\neg E \\rightarrow P) \\wedge (P \\rightarrow \\neg E)) && \\text{Definição de Implicação, Definição de Equivalência} \\\\\n&\\equiv P \\wedge (Q \\vee \\neg R \\vee S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Definição de Implicação} \\\\\n&\\equiv (P \\wedge (Q \\vee \\neg R \\vee S)) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Reorganização para clareza}\n\\end{align*}\n\\]\nAplicando a distributividade da conjunção sobre a disjunção no primeiro termo:\n\\[\n\\begin{align*}\n&\\equiv (P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Distributividade}\n\\end{align*}\n\\]\nPara o segundo termo, aplicamos a distributividade corretamente. Seja \\((A \\vee B) \\wedge (C \\vee D) \\equiv (A \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge C) \\vee (B \\wedge D)\\):\n\\[\n\\begin{align*}\n(E \\vee P) \\wedge (\\neg P \\vee \\neg E) &\\equiv (E \\wedge \\neg P) \\vee (E \\wedge \\neg E) \\vee (P \\wedge \\neg P) \\vee (P \\wedge \\neg E) \\\\\n&\\equiv (E \\wedge \\neg P) \\vee FALSE \\vee FALSE \\vee (P \\wedge \\neg E) && \\text{Lei da Contradição} \\\\\n&\\equiv (E \\wedge \\neg P) \\vee (P \\wedge \\neg E) && \\text{Lei da Identidade para a Disjunção}\n\\end{align*}\n\\]\nSubstituindo de volta na expressão principal:\n\\[\n\\begin{align*}\n&\\equiv (P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee (E \\wedge \\neg P) \\vee (P \\wedge \\neg E)\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee (E \\wedge \\neg P) \\vee (P \\wedge \\neg E)\\).\nPara cinco variáveis proposicionais, uma tabela-verdade completa teria \\(2^5 = 32\\) linhas. Em vez de apresentar toda a tabela, analisemos casos estratégicos para determinar as propriedades da fórmula:\nCasos em que a fórmula é \\(FALSE\\):\n\n\\(P = FALSE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\):\n\n\\((P \\wedge Q) = FALSE\\)\n\\((P \\wedge \\neg R) = FALSE\\)\n\\((P \\wedge S) = FALSE\\)\n\\((E \\wedge \\neg P) = FALSE \\wedge TRUE = FALSE\\)\n\\((P \\wedge \\neg E) = FALSE\\)\nResultado: todos os cinco termos da disjunção são falsos\n\n\nCasos em que a fórmula é \\(TRUE\\):\n\n\\(P = TRUE, Q = TRUE, R = TRUE, S = TRUE, E = FALSE\\): \\((P \\wedge Q) = TRUE\\)\n\\(P = TRUE, Q = FALSE, R = FALSE, S = FALSE, E = FALSE\\): \\((P \\wedge \\neg R) = TRUE\\)\n\\(P = FALSE, Q = FALSE, R = FALSE, S = FALSE, E = TRUE\\): \\((E \\wedge \\neg P) = TRUE\\)\n\nA análise destes casos representativos mostra que: - A fórmula não é uma tautologia, pois existem valorações que a tornam falsa - A fórmula é satisfatível, pois existem valorações que a tornam verdadeira\n- A fórmula é falsificável, pois existem valorações que a tornam falsa\nConclusão: A fórmula \\(P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P)\\) é satisfatível e falsificável, mas não é uma tautologia.\n\n\n4.1.2.2.3 Exemplos de Simplificação - Nível Avançado\nOs exemplos a seguir envolvem fórmulas com múltiplas variáveis proposicionais e conectivos complexos. Estes casos demonstram a aplicação sistemática das equivalências lógicas em situações mais desafiadoras, nas quais a análise de propriedades semânticas requer maior cuidado.\nExemplo 7: Determinar se a fórmula $ (P (Q R)) ((S E) (P Q)) $ é uma equivalência lógica.\nVamos simplificar ambos os lados separadamente:\nLado Esquerdo ($ (P (Q R)) $):\n\\[\n\\begin{align*}\n\\neg(P \\lor (Q \\land \\neg R)) &\\equiv \\neg P \\land \\neg(Q \\land \\neg R) && \\text{Lei de De Morgan (5)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor \\neg\\neg R) && \\text{Lei de De Morgan (6)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor R) && \\text{Lei da Dupla Negação (12)}\n\\end{align*}\n\\]\nLado Direito ($ (S E) (P Q) $):\n\\[\n\\begin{align*}\n(S \\lor E) \\rightarrow (P \\land Q) &\\equiv \\neg(S \\lor E) \\lor (P \\land Q) && \\text{Definição de Implicação (7)} \\\\\n&\\equiv (\\neg S \\land \\neg E) \\lor (P \\land Q) && \\text{Lei de De Morgan (6)}\n\\end{align*}\n\\]\nA fórmula completa é $ (P (Q R)) ((S E) (P Q)) $. Para verificar se é uma equivalência, testemos uma valoração específica, como $ P = \\(TRUE\\), Q = \\(FALSE\\), R = \\(TRUE\\), S = \\(FALSE\\), E = \\(FALSE\\) $:\n\nLado Esquerdo: $ P = \\(FALSE\\) $, $ Q = \\(TRUE\\) $, $ R = \\(TRUE\\) $, então $ Q R = \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $, e $ P (Q R) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\) $.\nLado Direito: $ S = \\(TRUE\\) $, $ E = \\(TRUE\\) $, então $ S E = \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $; $ P Q = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\) $, então $ (S E) (P Q) = \\(TRUE\\) \\(FALSE\\) = \\(TRUE\\) $.\nComo $ \\(FALSE\\) \\(TRUE\\) $, os lados não são iguais nesta valoração, indicando que a fórmula não é uma equivalência lógica.\n\nPara analisar as propriedades lógicas, consideremos a satisfatibilidade da expressão completa com uma tabela-verdade parcial:\n\n\n\n\n\n\n\n\n\n\n\n\n\n$ P $\n$ Q $\n$ R $\n$ S $\n$ E $\n$ P (Q R) $\n$ (S E) (P Q) $\n$ $\n\n\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\n\nNa primeira linha, a expressão é falsa ($ \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\) $), indicando que não é uma tautologia.\nNa segunda linha, a expressão é verdadeira ($ \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $), mostrando que é satisfatível.\n\nConclusão: A fórmula \\(\\neg(P \\vee (Q \\wedge \\neg R)) \\leftrightarrow ((S \\vee E) \\rightarrow (P \\wedge Q))\\) não é uma equivalência lógica, pois os lados diferem em algumas valorações (por exemplo, \\(P = TRUE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\)). Ela é satisfatível, pois há valorações em que é verdadeira (por exemplo, \\(P = FALSE, Q = TRUE, R = TRUE, S = TRUE, E = TRUE\\)), mas não é uma tautologia, pois também é falsificável, como mostrado pela tabela-verdade parcial.\nExemplo 8:\n\\(\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P))\\)\n\\[\n\\begin{align*}\n\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P)) &\\equiv \\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(8)}\\\\\n&\\equiv (\\neg(P \\rightarrow Q) \\vee \\neg(Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(5)}\\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 9: Simplificação e Análise da Fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\)\nVamos simplificar a fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\) passo a passo e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\n& (P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P)) \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg (\\neg R \\leftrightarrow S) \\vee (\\neg E \\wedge P)) && \\text{Lei 7: Definição de Implicação} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg ((\\neg R \\rightarrow S) \\wedge (S \\rightarrow \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 8: Definição de Equivalência} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg ((R \\vee S) \\wedge (\\neg S \\vee \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 7: Definição de Implicação, Lei 12: Dupla Negação} \\\\\n&\\equiv (P \\wedge Q) \\vee ((\\neg (R \\vee S) \\vee \\neg (\\neg S \\vee \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 5: Lei de De Morgan} \\\\\n&\\equiv (P \\wedge Q) \\vee ((\\neg R \\wedge \\neg S) \\vee (S \\wedge R) \\vee (\\neg E \\wedge P)) && \\text{Lei 6: Lei de De Morgan, Lei 12: Dupla Negação} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P) && \\text{Lei 19: Associatividade da Disjunção}\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\).\nPara analisar as propriedades lógicas, consideremos uma tabela-verdade parcial para as variáveis \\(P\\), \\(Q\\), \\(R\\), \\(S\\), \\(E\\). Uma tabela completa teria \\(2^5 = 32\\) linhas, mas casos representativos são suficientes para determinar se a fórmula é uma tautologia, satisfatível ou falsificável:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(S\\)\n\\(E\\)\n\\(P \\wedge Q\\)\n\\(\\neg R \\wedge \\neg S\\)\n\\(R \\wedge S\\)\n\\(\\neg E \\wedge P\\)\n\\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\)\n\n\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\n\n\nAnálise dos Casos:\n\nCasos em que a fórmula é TRUE: Nas primeiras cinco linhas, pelo menos um dos termos da disjunção é verdadeiro:\n\nLinha 1: \\((R \\wedge S) = TRUE\\)\nLinha 2: \\((R \\wedge S) = TRUE\\)\nLinha 3: \\((\\neg R \\wedge \\neg S) = TRUE\\)\nLinha 4: \\((\\neg R \\wedge \\neg S) = TRUE\\), \\((\\neg E \\wedge P) = TRUE\\)\nLinha 5: \\((R \\wedge S) = TRUE\\), \\((\\neg E \\wedge P) = TRUE\\)\n\nEsses casos mostram que a fórmula é satisfatível, pois há valorações em que ela é verdadeira.\nCasos em que a fórmula é FALSE: Na última linha ($P = \\(FALSE\\), Q = \\(TRUE\\), R = \\(FALSE\\), S = \\(TRUE\\), E = \\(TRUE\\)$):\n\n$(P Q) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\)$\n$(R S) = \\(FALSE\\) \\(TRUE\\) = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\)$\n$(R S) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\)$\n$(E P) = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\) \\(FALSE\\) = \\(FALSE\\)$\nResultado: \\[FALSE$ \\vee $FALSE$ \\vee $FALSE$ \\vee $FALSE$ = $FALSE\\]\n\nEsse caso mostra que a fórmula é falsificável, pois há uma valoração em que ela é falsa.\n\nConclusão: A fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\) simplifica para \\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\). Ela é satisfatível, pois há valorações em que é verdadeira, mas também é falsificável, pois existe pelo menos uma valoração ($P = \\(FALSE\\), Q = \\(TRUE\\), R = \\(FALSE\\), S = \\(TRUE\\), E = \\(TRUE\\)$) em que é falsa. Portanto, a fórmula não é uma tautologia. A tabela-verdade parcial apresentada é suficiente para confirmar essas propriedades, evitando a necessidade de uma tabela completa com 32 linhas.\nExemplo 10: Simplificação e Análise da Fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\)\nVamos simplificar a fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\) passo a passo e analisar suas propriedades lógicas.\nSimplifiquemos ambos os lados da equivalência separadamente:\nLado Esquerdo: \\(\\neg(P \\wedge (Q \\vee R))\\)\n\\[\n\\begin{align*}\n\\neg(P \\wedge (Q \\vee R)) &\\equiv \\neg P \\vee \\neg(Q \\vee R) && \\text{Lei 5: Lei de De Morgan} \\\\\n&\\equiv \\neg P \\vee (\\neg Q \\wedge \\neg R) && \\text{Lei 6: Lei de De Morgan}\n\\end{align*}\n\\]\nLado Direito: \\(\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q)\\)\n\\[\n\\begin{align*}\n\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q) &\\equiv \\neg(\\neg S \\vee E) \\vee \\neg(\\neg P \\vee Q) && \\text{Lei 7: Definição de Implicação} \\\\\n&\\equiv (S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) && \\text{Lei 6: Lei de De Morgan, Lei 12: Dupla Negação}\n\\end{align*}\n\\]\nA fórmula completa é: \\((\\neg P \\vee (\\neg Q \\wedge \\neg R)) \\leftrightarrow ((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q))\\)\nPara analisar as propriedades lógicas, consideremos uma tabela-verdade parcial para as variáveis \\(P\\), \\(Q\\), \\(R\\), \\(S\\), \\(E\\). Uma tabela completa teria \\(2^5 = 32\\) linhas, mas casos representativos são suficientes para determinar se a fórmula é uma tautologia, satisfatível ou falsificável:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(S\\)\n\\(E\\)\n\\(\\neg P \\vee (\\neg Q \\wedge \\neg R)\\)\n\\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q)\\)\n\\(\\leftrightarrow\\)\n\n\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\nFALSE\nFALSE\n\n\nTRUE\nTRUE\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\nTRUE\n\n\n\nAnálise dos Casos:\n\nLinha 1: (\\(P = TRUE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\))\n\nLado Esquerdo: \\(\\neg P = FALSE\\), \\(\\neg Q \\wedge \\neg R = \\neg FALSE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = FALSE \\vee FALSE = FALSE\\).\nLado Direito: \\(S \\wedge \\neg E = FALSE \\wedge \\neg FALSE = FALSE \\wedge TRUE = FALSE\\), \\(P \\wedge \\neg Q = TRUE \\wedge \\neg FALSE = TRUE \\wedge TRUE = TRUE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee TRUE = TRUE\\).\nResultado: \\(FALSE \\leftrightarrow TRUE = FALSE\\). A fórmula é falsa nesta valoração.\n\nLinha 2: (\\(P = FALSE, Q = TRUE, R = TRUE, S = TRUE, E = TRUE\\))\n\nLado Esquerdo: \\(\\neg P = TRUE\\), \\(\\neg Q \\wedge \\neg R = \\neg TRUE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = TRUE \\vee FALSE = TRUE\\).\nLado Direito: \\(S \\wedge \\neg E = TRUE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), \\(P \\wedge \\neg Q = FALSE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee FALSE = FALSE\\).\nResultado: \\(TRUE \\leftrightarrow FALSE = FALSE\\). A fórmula é falsa nesta valoração.\n\nLinha 3: (\\(P = TRUE, Q = TRUE, R = FALSE, S = FALSE, E = TRUE\\))\n\nLado Esquerdo: \\(\\neg P = FALSE\\), \\(\\neg Q \\wedge \\neg R = \\neg TRUE \\wedge \\neg FALSE = FALSE \\wedge TRUE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = FALSE \\vee FALSE = FALSE\\).\nLado Direito: \\(S \\wedge \\neg E = FALSE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), \\(P \\wedge \\neg Q = TRUE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee FALSE = FALSE\\).\nResultado: \\(FALSE \\leftrightarrow FALSE = TRUE\\). A fórmula é verdadeira nesta valoração.\n\n\nPropriedades Lógicas:\n\nNão é uma tautologia: As linhas 1 e 2 mostram que a fórmula pode ser falsa, pois o bicondicional \\(\\leftrightarrow\\) resulta em FALSE quando os lados têm valores diferentes.\nSatisfatível: A linha 3 mostra que há uma valoração em que a fórmula é verdadeira (\\(FALSE \\leftrightarrow FALSE = TRUE\\)).\nFalsificável: As linhas 1 e 2 confirmam que há valorações em que a fórmula é falsa.\nNão é uma equivalência lógica: Como os lados esquerdo e direito diferem em algumas valorações (por exemplo, linha 1), a fórmula não é uma equivalência lógica.\n\nConclusão: A fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\) simplifica para \\((\\neg P \\vee (\\neg Q \\wedge \\neg R)) \\leftrightarrow ((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q))\\). Ela é satisfatível, pois há valorações em que é verdadeira, mas também é falsificável, pois há valorações em que é falsa. Portanto, não é uma tautologia nem uma equivalência lógica. A tabela-verdade parcial apresentada é suficiente para confirmar essas propriedades. A Lógica Proposicional é essencial para entendermos o mundo. É a base de argumentos sólidos e da avaliação de proposições. Nasceu da necessidade humana de buscar a verdade e resolver conflitos com a lógica. Mas sua beleza vai além da filosofia, do discurso e da matemática. É a fundação da álgebra de George Boole, que sustenta o design de circuitos eletrônicos e a construção dos computadores modernos.\n\n\n\n\n4.1.3 Importância Histórica e Aplicações\nEm sua dissertação de final de curso, Claude Shannon usou a álgebra booleana para simplificar circuitos de controle. Desde então, as operações básicas dessa álgebra — AND, OR, NOT — tornaram-se os blocos fundamentais dos sistemas digitais. Elas formam o núcleo dos computadores, dos celulares e, na verdade, de toda a nossa civilização digital. A Lógica Proposicional é a base de todo o raciocínio lógico. Como a tabela periódica para químicos ou as leis de Newton para físicos. Ela é simples, elegante e poderosa.\nTão importante quanto o impacto da Lógica Proposicional na tecnologia digital é seu papel no pensamento racional, na tomada de decisões e na prova de teoremas. Neste caminho, nosso guia são as regras de inferência.\n\n\n4.1.4 Exercícios: Simplificação com Equivalências Lógicas\nInstrução: Use as leis de equivalência lógica (como as da Tabela 3) para simplificar as fórmulas a seguir até a forma mais simples possível. Justifique cada passo com o nome da lei ou propriedade utilizada.\n\nSimplifique: $ (P Q) $\nSimplifique: $ P (P Q) $\nSimplifique: $ (P Q) $\nSimplifique: $ (P Q) (P Q) $\nProve que a seguinte fórmula é uma tautologia: $ (P Q) (Q P) $\nSimplifique: $ (P Q) $\nSimplifique: $ (P Q) (P Q) $\nSimplifique: $ (P Q) (P Q) $\nSimplifique: $ (A B) (A B) $\nProve que a lei da Transitividade (ou Silogismo Hipotético) é uma tautologia: $ ((P Q) (Q R)) (P R) $",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#sistema-dedutivo-da-lógica-proposicional",
    "href": "02-fundamentos-logica-proposicional.html#sistema-dedutivo-da-lógica-proposicional",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.2 Sistema Dedutivo da Lógica Proposicional",
    "text": "4.2 Sistema Dedutivo da Lógica Proposicional\nO sistema dedutivo da Lógica Proposicional é um conjunto de regras e princípios que nos permite derivar conclusões a partir de premissas. Ele é fundamental para a construção de argumentos lógicos válidos e para a prova de teoremas. A seguir, apresentamos os principais componentes desse sistema:\n\n4.2.1 Regras de Inferência\nRegras de inferência são esquemas que proporcionam a estrutura para derivações lógicas. Estas regras formam a base dos sistemas de tomada de decisão computacional. Elas definem os passos legítimos que podem ser aplicados a uma ou mais proposições, sejam elas atômicas ou Fórmulas Bem Formadas, para produzir uma proposição nova. Em outras palavras, uma regra de inferência é uma transformação sintática de Formas Bem Formadas que preserva a verdade.\nAqui uma regra de inferência será representada por:\n\\[\\frac{P_1, P_2, ..., P_n}{C},\\]\nou, eventualmente por:\n\\[P_1, P_2, ..., P_n \\vdash C.\\]\nO conjunto formado \\(P_1, P_2, ..., P_n\\), chamado de contexto, ou antecedente, \\(\\Gamma\\), e \\(C\\), chamado de conclusão, ou consequente, são Fórmulas Bem Formadas. A regra significa que se as proposições que constituem a conjunção expressa no contexto são verdadeiras, então a conclusão \\(C\\), consequência, também será verdadeira. Em resumo, o contexto \\(\\Gamma\\) é o conjunto de premissas assumidas verdadeiras em uma dedução, e a conclusão \\(C\\) é derivada aplicando regras de inferência às premissas em \\(\\Gamma\\).\nEu vou tentar usar contexto e conclusão. Mas a compassiva leitora deve me perdoar se eu escapar para antecedente e consequente. É apenas o hábito.\nQuando estudamos lógica, chamamos de argumento uma lista de proposições, que aqui são as premissas. Elas vêm seguidas de uma palavra ou expressão (portanto, consequentemente, desta forma) e de outra proposição, que chamamos de conclusão. A forma que usamos para representar isso é chamada de sequência de dedução. É uma forma de mostrar que, se a proposição colocada acima da linha horizontal for verdadeira, então estamos afirmando que todas as proposições \\(P_1, P_2, ..., P_n\\) acima da linha são verdadeiras. E, por isso, a proposição abaixo da linha, a conclusão, também será verdadeira.\nAs regras de inferência são o alicerce da lógica dedutiva e das provas matemáticas. Elas permitem que raciocínios complexos sejam divididos em passos simples, com cada passo sendo justificado pela aplicação de uma regra de inferência. A seguir, estão algumas das regras de inferência mais usadas:\n\n4.2.1.1 Regras Básicas de Inferência\nAs regras básicas de inferência formam o núcleo fundamental do sistema dedutivo da lógica proposicional. Estas regras permitem derivar conclusões válidas a partir de premissas conhecidas e são amplamente utilizadas em demonstrações matemáticas e raciocínio lógico.\nA tabela Table 4.4 apresenta um resumo das regras de inferência mais comuns, suas descrições e as fórmulas associadas.\n\n\n\nTable 4.4: Resumo dos métodos de inferência.\n\n\n\n\n\n\n\n\n\n\nRegra\nDescrição\nFórmula\n\n\n\n\nModus Ponens\nSe \\(P \\rightarrow Q\\) e \\(P\\) são verdadeiros, então \\(Q\\) também é verdadeiro.\n\\(\\frac{P, P \\rightarrow Q}{Q}\\)\n\n\nModus Tollens\nSe \\(P \\rightarrow Q\\) e \\(\\neg Q\\) são verdadeiros, então \\(\\neg P\\) também é verdadeiro.\n\\(\\frac{\\neg Q, P \\rightarrow Q}{\\neg P}\\)\n\n\nDupla Negação\nA negação de uma negação é equivalente à afirmação original.\n\\(\\frac{\\neg \\neg P}{P}\\)\n\n\nAdição\nSe \\(P\\) é verdadeiro, então \\(P \\vee Q\\) também é verdadeiro.\n\\(\\frac{P}{P \\vee Q}\\)\n\n\nAdjunção\nSe \\(P\\) e \\(Q\\) são verdadeiros, então \\(P \\wedge Q\\) é verdadeiro.\n\\(\\frac{P, Q}{P \\wedge Q}\\)\n\n\nSimplificação\nSe \\(P \\wedge Q\\) é verdadeiro, então \\(P\\) (ou \\(Q\\)) é verdadeiro.\n\\(\\frac{P \\wedge Q}{P}\\)\n\n\nBicondicionalidade\nSe \\(P \\leftrightarrow Q\\), então \\(P \\rightarrow Q\\) e \\(Q \\rightarrow P\\) são verdadeiros.\n\\(\\frac{P \\leftrightarrow Q}{P \\rightarrow Q, Q \\rightarrow P}\\)\n\n\n\n\n\n\n\n4.2.1.1.1 Modus Ponens\nA regra do Modus Ponens permite inferir uma conclusão a partir de uma implicação e de sua premissa antecedente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(P\\) é verdadeiro, então podemos concluir que \\(Q\\) também é verdadeiro.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: se chover, \\((P)\\), então, \\((\\rightarrow)\\), a rua ficará molhada, \\((Q)\\);\nProposição 2: está chovendo, \\((P)\\) é verdadeira.\nConclusão: logo, a rua ficará molhada, \\((Q)\\).\n\nAlgumas aplicações do Modus Ponens:\n\nDerivar ações de regras e leis condicionais. Por exemplo:\n\nProposição: se a velocidade, \\(V\\), é maior que \\(80 \\text{km/h}\\), então é uma infração de trânsito, \\(IT\\).\nProposição: João está dirigindo, \\(d\\), à \\(90 \\text{km/h}\\).\nConclusão: logo, João cometeu uma infração de trânsito.\n\n\n\\[V &gt; 80 \\rightarrow IT\\]\n\\[\n\\begin{aligned}\n&D = 90\\\\\n\\hline\n&IT\n\\end{aligned}\n\\]\n\nAplicar implicações teóricas e chegar a novas conclusões. Por exemplo:\n\nProposição: se um número é par, \\(P\\), então é divisível por 2, $ d2$.\nProposição: 128 é par.\nConclusão: logo, 128 é divisível por 2.\n\n\n\\[x \\text{ é par} \\rightarrow \\text{divisível por dois}\\]\n\\[\n\\begin{aligned}\n&128 \\text{ é par}\\\\\n\\hline\n&128 \\text{ é divisível por 2}\n\\end{aligned}\n\\]\n\nFazer deduções lógicas em matemática e ciência. Por exemplo:\n\nProposição: se dois lados de um triângulo têm o mesmo comprimento, então o triângulo é isósceles.\nProposição: o triângulo \\(ABC\\) tem os lados \\(AB\\), \\(AC\\) e \\(BC\\) do mesmo comprimento.\nConclusão: logo, o triângulo \\(ABC\\) é isósceles.\n\n\n\\[\n\\begin{aligned}\n&(AB = AC) \\wedge (AB=CB) \\text{ no triângulo} ABC\\\\\n\\hline\n&\\text{o triângulo } ABC \\text{ é isósceles}\n\\end{aligned}\n\\]\n\nTirar conclusões com base no raciocínio condicional na vida cotidiana. Por exemplo:\n\nProposição: se hoje não chover, então irei à praia.\nProposição: Hoje não choveu.\nConclusão: logo, irei à praia.\n\n\n\\[\\neg (\\text{chover hoje}) \\rightarrow \\text{ir à praia}\\]\n\\[\n\\begin{aligned}\n&\\neg (\\text{choveu hoje})\\\\\n\\hline\n&(\\text{ir à praia})\n\\end{aligned}\n\\]\n\n\n4.2.1.1.2 Modus Tollens\nA regra do Modus Tollens permite inferir a negação da premissa antecedente a partir de uma implicação e da negação de sua premissa consequente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(Q\\) é falso (ou seja, \\(\\neg Q\\)), então podemos concluir que \\(P\\) também é falso.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&\\neg P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição 1: se uma pessoa tem 18 anos ou mais, \\((P)\\), então, \\((\\rightarrow)\\) ela pode votar, \\((Q)\\);\nProposição 2: Maria não pode votar, \\((\\neg Q)\\);\nConclusão: logo, Maria não tem 18 anos ou mais, \\((\\neg P)\\).\n\nAlgumas aplicações do Modus Tollens:\n\nRefutar teorias mostrando que suas previsões são falsas. Por exemplo:\n\nProposição: se a teoria da geração espontânea, \\(TG\\), é correta, então insetos irão se formar em carne deixada exposta ao ar, \\(I\\).\nProposição: insetos não se formam em carne deixada exposta ao ar, \\(\\neg I\\).\nConclusão: logo, a teoria da geração espontânea é falsa, \\(\\neg TG\\).\n\n\n\\[TG \\rightarrow I\\]\n\\[\n\\begin{aligned}\n&\\neg I\\\\\n\\hline\n&\\neg TG\n\\end{aligned}\n\\]\n\nIdentificar inconsistências ou contradições em raciocínios. Por exemplo:\n\nProposição: se João, \\(J\\), é mais alto que Maria, \\(M\\), então Maria não é mais alta que João.\nProposição: Maria é mais alta que João, \\((M &gt; J)\\).\nConclusão: logo, João não é mais alto que Maria, \\(\\neg(J &gt; M)\\). O raciocínio mostra que não podemos ter simultaneamente \\(J &gt; M\\) e \\(M &gt; J\\), pois a relação “maior que” é assimétrica.\n\n\n\\[(J &gt; M) \\rightarrow \\neg(M &gt; J)\\]\n\\[\n\\begin{aligned}\n&(M &gt; J)\\\\\n\\hline\n&\\neg(J &gt; M)\n\\end{aligned}\n\\]\n\nFazer deduções lógicas baseadas na negação da conclusão. Por exemplo:\n\nProposição: se hoje, \\(H\\), é sexta-feira, então amanhã é sábado, \\(A_{sab}\\).\nProposição: amanhã não é sábado, \\(\\neg A_{sab}\\).\nConclusão: logo, hoje não é sexta-feira, \\(\\neg H_{sex}\\).\n\n\n\\[H_{sex} \\rightarrow A_{sab}\\]\n\\[\n\\begin{aligned}\n&\\neg A_{sab}\\\\\n\\hline\n&\\neg H_{sex}\n\\end{aligned}\n\\]\n\nDescobrir causas de eventos por eliminação de possibilidades. Por exemplo:\n\nProposição: se a tomada está com defeito, \\(D\\), então a lâmpada não acende, \\(\\neg L\\).\nProposição: a lâmpada acendeu, \\(L\\).\nConclusão: logo, a tomada não está com defeito, \\(\\neg D\\).\n\n\n\\[D \\rightarrow \\neg L\\]\n\\[\n\\begin{aligned}\n&L\\\\\n\\hline\n&\\neg D\n\\end{aligned}\n\\]\nExplicação: Como a lâmpada acendeu (\\(L\\)), isso contradiz a consequência da implicação (\\(\\neg L\\)). Pelo Modus Tollens, se o consequente é falso, então o antecedente também deve ser falso. Portanto, a tomada não está com defeito (\\(\\neg D\\)).\n\n\n\n4.2.1.2 **Regras de Manipulação Lógica\nEstas regras permitem transformar e simplificar expressões lógicas, facilitando a análise e manipulação de fórmulas complexas. São fundamentais para a normalização de expressões e para preparar fórmulas para aplicação de outras regras de inferência.\n\n4.2.1.2.1 Dupla Negação\nA regra da Dupla Negação permite eliminar uma dupla negação, inferindo a afirmação original. A negação de uma negação é equivalente à afirmação original. Esta regra é importante para simplificar expressões lógicas.\n\\[\\neg \\neg P\\]\n\\[\n\\begin{aligned}\n&\\neg \\neg P\\\\\n\\hline\n&P\\\\\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n&P\\\\\n\\hline\n&\\neg \\neg P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: não é verdade que Maria não está feliz;\nConclusão: logo, Maria está feliz.\n\nA dupla negação pode parecer desnecessária, mas ela tem algumas aplicações na lógica:\n\nSimplifica expressões lógicas: remover duplas negações ajuda a simplificar e a normalizar expressões complexas, tornando-as mais fáceis de analisar. Por exemplo, transformar não é verdade que não está chovendo em simplesmente está chovendo.\n\n\\[\\neg \\neg \\text{Está chovendo} \\equiv \\text{Está chovendo}\\]\n\nPreserva o valor de verdade: inserir ou remover duplas negações não altera o valor de verdade original de uma proposição. Isso permite transformar proposições em formas logicamente equivalentes.\nAuxilia provas indiretas: em provas por contradição, ou contrapositiva, introduzir uma dupla negação permite assumir o oposto do que se quer provar e derivar uma contradição. Isso, indiretamente, prova a proposição original.\nConecta Lógica Proposicional e de predicados: em Lógica Predicativa, a negação de quantificadores universais e existenciais envolve dupla negação. Por exemplo, a negação de todo \\(x\\) é \\(P\\) é existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\n\n\\[\\neg \\forall x P(x) \\equiv \\exists x \\neg P(x)\\]\n\nPermite provar equivalências: uma identidade ou lei importante na lógica é que a dupla negação de uma proposição é logicamente equivalente à proposição original. A regra da dupla negação permite formalmente provar essa equivalência.\n\n\\[\\neg \\neg P \\equiv P\\]\n\n\n4.2.1.2.2 Adição\nA regra da Adição permite adicionar uma disjunção a uma afirmação, resultando em uma nova disjunção verdadeira. Esta regra é útil para introduzir alternativas em nosso raciocínio dedutivo.\n\\[P\\]\n\\[\\begin{aligned}\n&P\\\\\n\\hline\n&P \\vee Q\\\\\n\\end{aligned}\n\\]\n\\[\\begin{aligned}\n&Q\\\\\n\\hline\n&P \\vee Q\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: o céu está azul;\nConclusão: logo, o céu está azul ou gatos podem voar.\n\nA regra da Adição permite introduzir uma disjunção em uma prova ou argumento lógico. Especificamente, ela nos permite inferir uma disjunção \\(P\\vee Q\\) a partir de uma das afirmações disjuntivas (\\(P\\) ou \\(Q\\)) individualmente.\nAlguns usos e aplicações importantes da regra da Adição:\n\nIntroduzir alternativas ou possibilidades em um argumento: por exemplo, dado que João está em casa, podemos concluir que João está em casa ou no trabalho. E expandir este ou o quanto seja necessário para explicitar os lugares em que João pode estar.\nCombinar afirmações em novas disjunções: dadas duas afirmações quaisquer \\(P\\) e \\(Q\\), podemos inferir que \\(P\\) ou \\(Q\\) é verdadeiro.\nCriar casos ou opções exaustivas em uma prova: podemos derivar uma disjunção que cubra todas as possibilidades relevantes.\nIniciar provas por casos: ao assumir cada disjuntiva separadamente, podemos provar teoremas por casos exaustivos.\nRealizar provas indiretas: ao assumir a negação de uma disjunção, podemos chegar a uma contradição e provar a disjunção original.\n\nA regra da Adição amplia nossas capacidades de prova e abordagem de problemas.\n\n\n4.2.1.2.3 Modus Tollendo Ponens\nO Modus Tollendo Ponens permite inferir uma disjunção a partir da negação da outra disjunção.\nDada uma disjunção \\(P\\vee Q\\):\n\nSe \\(\\neg P\\), então \\(Q\\)\nSe \\(\\neg Q\\), então \\(P\\)\n\nEsta regra nos ajuda a chegar a conclusões a partir de disjunções, por exclusão de alternativas.\n\\[P \\vee Q\\]\n\\[\\begin{aligned}\n&\\neg P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\n\\]\n\\[\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição 1: ou o céu está azul ou a grama é roxa;\nProposição 2: a grama não é roxa;\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações do Modus Tollendo Ponens:\n\nDerivar ações a partir de regras disjuntivas. Por exemplo:\n\nProposição: ou João vai à praia, \\(P\\) ou João vai ao cinema, \\(c\\);\nProposição: João não vai ao cinema, \\(\\neg C\\);\nConclusão: logo, João vai à praia.\n\n\n\\[P \\vee C\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&P\n\\end{aligned}\n\\]\n\nSimplificar casos em provas por exaustão. Por exemplo:\n\nProposição: o número é par, \\(P\\), ou ímpar, \\(I\\);\nProposição: o número não é ímpar, \\(\\neg I\\);\nConclusão: logo, o número é par, \\(P\\).\n\n\n\\[P \\vee I\\]\n\\[\\begin{aligned}\n&\\neg I\\\\\n\\hline\n&P\n\\end{aligned}\n\\]\n\nEliminar opções em raciocínio dedutivo. Por exemplo:\n\nProposição: ou João estava em casa, \\(c\\), ou João estava no trabalho, \\(t\\);\nProposição: João não estava em casa;\nConclusão: logo, João estava no trabalho.\n\n\n\\[C \\vee TRUE\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&TRUE\n\\end{aligned}\n\\]\n\nFazer prova indireta da disjunção. Por exemplo:\n\nProposição: 1 é par, \\(1P\\), ou 1 é ímpar, \\(1I\\);\nProposição: 1 não é par;\nConclusão: logo, 1 é ímpar.\n\n\n\\[1P \\vee 1I\\]\n\\[\\begin{aligned}\n&\\neg 1P\\\\\n\\hline\n&1I\n\\end{aligned}\n\\]\n\n\n4.2.1.2.4 Adjunção\nA regra da Adjunção permite combinar duas afirmações em uma conjunção. Esta regra é útil para juntar duas premissas em uma única afirmação conjuntiva.\n\\[P\\]\n\\[Q\\]\n\\[\\begin{aligned}\n&P\\\\\n&Q\\\\\n\\hline\n&P \\land Q\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: o céu está azul;\nProposição 2: os pássaros estão cantando;\nConclusão: logo, o céu está azul e os pássaros estão cantando.\n\nAlgumas aplicações da Adjunção:\n\nCombinar proposições relacionadas em argumentos. Por exemplo:\n\nProposição: o céu está nublado, \\(N\\);\nProposição: está ventando, \\(V\\);\nConclusão: logo, o céu está nublado e está ventando.\n\n\n\\[\\begin{aligned}\n&N\\\\\n&V\\\\\n\\hline\n&N \\land V\n\\end{aligned}\\]\n\nCriar declarações conjuntivas complexas. Por exemplo:\n\nProposição: 1 é número natural, \\(N1\\);\nProposição: 2 é número natural, \\(N2\\);\nConclusão: logo, 1 é número natural e 2 é número natural.\n\n\n\\[\\begin{aligned}\n&N1\\\\\n&N2\\\\\n\\hline\n&N1 \\land N2\n\\end{aligned}\\]\n\nDerivar novas informações da interseção de fatos conhecidos. Por exemplo:\n\nProposição: o gato está em cima do tapete, \\(GT\\);\nProposição: o rato está em cima do tapete, \\(RT\\);\nConclusão: logo, o gato e o rato estão em cima do tapete.\n\n\n\\[\\begin{aligned}\n&GT\\\\\n&RT\\\\\n\\hline\n&GT \\land RT\n\\end{aligned}\\]\n\nFazer deduções lógicas baseadas em múltiplas proposições. Por exemplo:\n\nProposição: 2 + 2 = 4;\nProposição: 4 = 16;\nConclusão: logo, \\((2 + 2 = 4) \\land (4 \\times 4 = 16)\\).\n\n\n\\[\\begin{aligned}\n&(2 + 2 = 4)\\\\\n&(4 \\times 4 = 16)\\\\\n\\hline\n&(2 + 2 = 4) \\land (4 \\times 4 = 16)\n\\end{aligned}\\]\n\n\n4.2.1.2.5 Simplificação\nA regra da Simplificação permite inferir um componente individual a partir de uma conjunção composta. Esta regra nos permite derivar qualquer um dos elementos de uma conjunção, a partir da afirmação conjuntiva.\n\\[P \\land Q\\]\n\\[\\begin{aligned}\n&P \\land Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\\]\n\\[\\begin{aligned}\n&P \\land Q\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição: o céu está azul e os pássaros estão cantando;\nConclusão: logo, o céu está azul. Ou alternativamente, os pássaros estão cantando.\n\nAlgumas aplicações da Simplificação:\n\nDerivar elementos de conjunções complexas. Por exemplo:\n\nProposição: hoje está chovendo, \\(C\\), e fazendo frio, \\(F\\);\nConclusão: logo, está chovendo.\n\n\n\\[\\begin{aligned}\n&C \\land F\\\\\n\\hline\n&C\n\\end{aligned}\\]\n\nSimplificar provas baseadas em conjunções. Por exemplo:\n\nProposição: 2 é par, \\(2P\\), e 3 é ímpar, \\(3I\\);\nConclusão: logo, 3 é ímpar.\n\n\n\\[\\begin{aligned}\n&2P \\land 3I\\\\\n\\hline\n&3I\n\\end{aligned}\\]\n\nInferir detalhes específicos de declarações complexas. Por exemplo:\n\nProposição: o gato está dormindo, \\(D\\), e ronronando, \\(R\\);\nConclusão: logo, o gato está ronronando.\n\n\n\\[\\begin{aligned}\n&D \\land R\\\\\n\\hline\n&R\n\\end{aligned}\\]\n\nDerivar informações de premissas conjuntivas. Por exemplo:\n\nProposição: está chovendo, \\(C\\), e o jogo foi cancelado, \\(J\\);\nConclusão: logo, o jogo foi cancelado.\n\n\n\\[\\begin{aligned}\n&C \\land J\\\\\n\\hline\n&J\n\\end{aligned}\\]\n\n\n\n4.2.1.3 Regras de Equivalência e Bicondicionalidade\nAs regras de equivalência e bicondicionalidade são fundamentais para a lógica proposicional, pois permitem estabelecer relações de equivalência entre proposições e inferir conclusões a partir dessas relações. Elas são essenciais para simplificar expressões lógicas, provar teoremas e estabelecer definições matemáticas precisas. Estas regras trabalham com o conceito de equivalência lógica, no qual duas proposições têm o mesmo valor de verdade em todas as interpretações possíveis.\n\n4.2.1.3.1 Bicondicionalidade\nA regra da Bicondicionalidade permite inferir uma bicondicional a partir de duas condicionais. Esta regra nos permite combinar duas implicações para obter uma afirmação de equivalência lógica.\n\\[P \\rightarrow Q\\]\n\\[Q \\rightarrow P\\]\n\\[\\begin{aligned}\n&P \\rightarrow Q \\\\\n&Q \\rightarrow P \\\\\n\\hline\n&P \\leftrightarrow Q\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: se está chovendo, então a rua está molhada;\nProposição 2: se a rua está molhada, então está chovendo;\nConclusão: logo, está chovendo se e somente se a rua está molhada.\n\nAlgumas aplicações da Bicondicionalidade:\n\nInferir equivalências lógicas a partir de implicações bidirecionais. Por exemplo:\n\nProposição: se chove, \\(C\\), então a rua fica molhada, \\(M\\);\nProposição: se a rua fica molhada, então chove;\nConclusão: logo, chove se e somente se a rua fica molhada.\n\n\n\\[C \\rightarrow M\\]\n\\[\\begin{aligned}\n&M \\rightarrow C\\\\\n\\hline\n&C \\leftrightarrow M\n\\end{aligned}\\]\n\nEstabelecer definições matemáticas precisas. Por exemplo:\n\nProposição: se um número é múltiplo de 2, \\(M2\\), então é par, \\(P\\);\nProposição: se um número é par, então é múltiplo de 2;\nConclusão: logo, um número é par se e somente se é múltiplo de 2.\n\n\n\\[M2 \\rightarrow P\\]\n\\[\\begin{aligned}\n&P \\rightarrow M2\\\\\n\\hline\n&P \\leftrightarrow M2\n\\end{aligned}\\]\n\nEstabelecer equivalências algébricas. Por exemplo:\n\nProposição: se \\(x = 5\\), então \\(x^2 = 25\\);\nProposição: se \\(x^2 = 25\\) e \\(x &gt; 0\\), então \\(x = 5\\);\nConclusão: logo, para números positivos, \\(x = 5\\) se e somente se \\(x^2 = 25\\).\n\n\n\\[(x = 5) \\rightarrow (x^2 = 25)\\]\n\\[\\begin{aligned}\n&(x^2 = 25 \\land x &gt; 0) \\rightarrow (x = 5)\\\\\n\\hline\n&(x = 5) \\leftrightarrow (x^2 = 25 \\land x &gt; 0)\n\\end{aligned}\\]\n\nDefinir conceitos através de propriedades equivalentes. Por exemplo:\n\nProposição: se um triângulo é equilátero, \\(E\\), então todos os seus ângulos são iguais, \\(A\\);\nProposição: se um triângulo tem todos os ângulos iguais, então é equilátero;\nConclusão: logo, um triângulo é equilátero se e somente se todos os seus ângulos são iguais.\n\n\n\\[E \\rightarrow A\\]\n\\[\\begin{aligned}\n&A \\rightarrow E\\\\\n\\hline\n&E \\leftrightarrow A\n\\end{aligned}\\]\n\n\n4.2.1.3.2 Equivalência\nA regra da Equivalência permite inferir uma afirmação ou sua negação a partir de uma bicondicional. Esta regra nos permite aplicar bicondicionais para derivar novas afirmações baseadas nas equivalências lógicas.\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&\\neg P\\\\\n\\hline\n&\\neg Q\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&\\neg P\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: está chovendo se e somente se a rua está molhada;\nProposição 2: está chovendo;\nConclusão: logo, a rua está molhada.\n\nAlgumas aplicações da Equivalência:\n\nInferir fatos de equivalências estabelecidas. Por exemplo:\n\nProposição: o número é par, \\(P\\), se e somente se for divisível por 2, \\(D2\\);\nProposição: 156 é divisível por 2;\nConclusão: logo, 156 é par.\n\n\\[P \\leftrightarrow D2\\]\n\\[\\begin{aligned}\n&D2(156)\\\\\n\\hline\n&P(156)\n\\end{aligned}\\]\nDerivar negações de equivalências. Por exemplo:\n\nProposição: \\(x\\) é negativo, \\(N\\), se e somente se \\(x &lt; 0\\);\nProposição: \\(x\\) não é negativo;\nConclusão: logo, \\(x\\) não é menor que \\(0\\).\n\n\\[N \\leftrightarrow (x &lt; 0)\\]\n\\[\\begin{aligned}\n&\\neg N\\\\\n\\hline\n&\\neg (x &lt; 0)\n\\end{aligned}\\]\nFazer deduções baseadas em definições. Por exemplo:\n\nProposição: número ímpar, \\(I\\), é definido como não divisível por \\(2\\), \\(\\neg D2\\);\nProposição: \\(9\\) não é divisível por \\(2\\);\nConclusão: logo, \\(9\\) é ímpar.\n\n\\[I \\leftrightarrow \\neg D2\\]\n\\[\\begin{aligned}\n&\\neg D2(9)\\\\\n\\hline\n&I(9)\n\\end{aligned}\\]\n\n\n\n\n\n4.2.2 Exercícios: Provas com Regras de Inferência\nInstrução: Para cada um dos seguintes conjuntos de premissas, derive a conclusão indicada. Apresente a prova como uma sequência de passos numerados, onde cada passo é justificado pela regra de inferência aplicada e pelos números dos passos anteriores ou premissas utilizadas.\n\nPremissas:\n\n\\(P \\rightarrow Q\\)\n\\(P\\) Conclusão: \\(Q\\)\n\nPremissas:\n\n\\(A \\rightarrow B\\)\n\\(\\neg B\\) Conclusão: \\(\\neg A\\)\n\nPremissas:\n\n\\(P \\land Q\\)\n\\(P \\rightarrow R\\) Conclusão: \\(R\\)\n\nPremissas:\n\n\\(S \\rightarrow \\neg T\\)\n\\(T\\)\n\\(S \\lor U\\) Conclusão: \\(U\\)\n\nPremissas:\n\n\\(A\\)\n\\(B\\)\n\\((A \\land B) \\rightarrow C\\) Conclusão: \\(C\\)\n\nPremissas:\n\n\\(P \\rightarrow Q\\)\n\\(Q \\rightarrow R\\) Conclusão: \\(P \\rightarrow R\\) (Esta regra é conhecida como Silogismo Hipotético)\n\nPremissas:\n\n\\(A \\rightarrow B\\)\n\\(C \\rightarrow D\\)\n\\(A \\lor C\\) Conclusão: \\(B \\lor D\\) (Esta regra é conhecida como Dilema Construtivo)\n\nPremissas:\n\n\\(\\neg A \\lor B\\)\n\\(C \\rightarrow A\\)\n\\(C\\) Conclusão: \\(B\\)\n\nArgumento: “Se o servidor está online (\\(S\\)), então os dados foram processados (\\(D\\)). Se os dados foram processados, o relatório foi gerado (\\(R\\)). O servidor está online. Portanto, o relatório foi gerado.” Instrução: Formalize as premissas e a conclusão, e então derive a conclusão.\nPremissas:\n\n\\((P \\land Q) \\rightarrow R\\)\n\\(\\neg R \\lor S\\)\n\\(P\\)\n\\(Q \\land T\\) Conclusão: \\(S\\)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#análise-semântica-de-fórmulas",
    "href": "02-fundamentos-logica-proposicional.html#análise-semântica-de-fórmulas",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.3 Análise Semântica de Fórmulas",
    "text": "4.3 Análise Semântica de Fórmulas\nA análise semântica de fórmulas proposicionais estuda o significado e as propriedades de verdade das expressões lógicas. Enquanto a sintaxe se preocupa com a estrutura formal das fórmulas, a semântica examina quando e por que essas fórmulas são verdadeiras ou falsas. Esta análise permite uma compreensão mais profunda da lógica, ajudando a identificar inconsistências e a validar argumentos.\n\n4.3.1 Classificação das Fórmulas Proposicionais\nPodemos classificar fórmulas proposicionais de acordo com suas propriedades semânticas, analisando suas tabelas-verdade. Seja \\(R\\) uma fórmula proposicional:\n\n\\(R\\) é satisfatível se sua Tabela Verdade contém pelo menos uma linha verdadeira. Considere:\\(P\\wedge Q\\).\n\n\\[\\begin{array}{|c|c|c|}\n\\hline\nP & Q & P \\land Q \\\\\n\\hline\n$FALSE$ & $FALSE$ & $FALSE$ \\\\\n\\hline\n$FALSE$ & $TRUE$ & $FALSE$ \\\\\n\\hline\n$TRUE$ & $FALSE$ & $FALSE$ \\\\\n\\hline\n$TRUE$ & $TRUE$ & $TRUE$ \\\\\n\\hline\n\\end{array}\\]\n\n\\(R\\) é insatisfatível se sua Tabela Verdade contém apenas linhas falsas. Exemplo:\\(P\\wedge \\neg P\\).\n\\(R\\) é falsificável se sua Tabela Verdade contém pelo menos uma linha falsa. Exemplo:\\(P\\wedge Q\\).\n\\(R\\) é válida se sua Tabela Verdade contém apenas linhas verdadeiras. Exemplo:\\(P\\vee \\neg P\\).\n\nNote que:\n\nSe \\(A\\) é válida, então \\(A\\) é satisfatível.\nSe \\(A\\) é insatisfatível, então \\(A\\) é falsificável.\n\nUma fórmula válida (tautologia) é satisfatível porque tem pelo menos uma linha verdadeira (na verdade, todas são verdadeiras). Uma fórmula insatisfatível (contradição) é falsificável porque tem pelo menos uma linha falsa (na verdade, todas são falsas)\nFórmulas válidas são importantes na Lógica Proposicional, representando argumentos sempre verdadeiros independentemente da valoração de suas variáveis proposicionais atômicas. Na verdade, esta classificação será importante para:\n\nAnálise de Argumentos: Se uma argumentação lógica pode ser representada por uma fórmula que é insatisfatível, então sabemos que o argumento é inválido ou inconsistente. Isso é frequentemente usado em lógica e filosofia para analisar a validade dos argumentos.\nProva de Teoremas: Na prova de teoremas, essas classificações são úteis. Quando estamos tentando provar que uma fórmula é uma tautologia, podemos usar essas classificações para simplificar a tarefa. Podemos mostrar que a negação da fórmula é insatisfatível, mostrando que a fórmula original é uma tautologia.\nSimplificação de Fórmulas: Na simplificação de fórmulas, essas classificações também são úteis. Se temos uma fórmula complexa e podemos mostrar que uma parte dela é uma tautologia, podemos simplificar a fórmula removendo essa parte. Similarmente, se uma parte da fórmula é uma contradição (ou seja, é insatisfatível), sabemos que a fórmula inteira é insatisfatível.\nConstrução de Argumentos: Na construção de argumentos, estas classificações são úteis para garantir que os argumentos são válidos. Se estamos construindo um argumento e podemos mostrar que ele é representado por uma fórmula que é satisfatível (mas não uma tautologia), sabemos que existem algumas circunstâncias em que o argumento é válido e outras em que não é.\n\n\n\n4.3.2 Exercícios: Análise Semântica de Fórmulas\nInstrução: Para cada uma das fórmulas abaixo, determine se ela é uma Tautologia, uma Contradição ou uma Contingência (satisfatível, mas também falsificável). Use o método que preferir (tabela-verdade ou simplificação por equivalências lógicas) para justificar sua resposta.\n\nClassifique a fórmula: \\(P \\rightarrow (P \\land Q)\\)\nClassifique a fórmula: \\((P \\lor Q) \\lor (\\neg P \\land \\neg Q)\\)\nClassifique a fórmula: \\((P \\leftrightarrow Q) \\land (P \\land \\neg Q)\\)\nEncontre uma valoração (uma atribuição de Verdadeiro ou Falso para A, B e C) que torne a seguinte fórmula verdadeira: \\((\\neg A \\lor B) \\rightarrow (C \\rightarrow A)\\)\nEncontre uma valoração que torne a fórmula do exercício 4 falsa.\nClassifique a fórmula (Axioma de Frege): \\((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\\)\nClassifique a fórmula: \\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\land Q))\\)\nClassifique a fórmula: \\(\\neg(((P \\lor Q) \\rightarrow P) \\lor Q)\\)\nAnalise o argumento: “Uma pessoa pode dirigir (\\(D\\)) se, e somente se, ela tem uma carteira de motorista (\\(C\\)) e não está embriagada (\\(\\neg E\\)). É logicamente consistente (satisfatível) afirmar que uma pessoa está dirigindo sem ter carteira de motorista?”. Justifique sua resposta.\nClassifique a fórmula: \\((A \\leftrightarrow B) \\lor (B \\leftrightarrow C)\\)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#exercícios-de-conexão-com-o-prolog",
    "href": "02-fundamentos-logica-proposicional.html#exercícios-de-conexão-com-o-prolog",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.4 Exercícios de Conexão com o Prolog",
    "text": "4.4 Exercícios de Conexão com o Prolog\nEstas questões demonstram conceitos fundamentais que se traduzem diretamente para Prolog:\n\nFatos: Proposições básicas verdadeiras (como “U” na questão 4)\nRegras: Implicações lógicas (como “C → U” traduzido para pode_compilar(core) :- pode_compilar(utils).)\nConsultas: Questões que queremos responder usando a base de conhecimento\nConsistência: Importância de evitar contradições na base de conhecimento\nDedução: Como o motor de inferência do Prolog resolve consultas usando fatos e regras\n\nEste conjunto de questões foi elaborado para solidificar os fundamentos da Lógica Proposicional, servindo como base para a modelagem de sistemas e a programação em lógica. Cada problema apresenta um “mundo” a ser modelado com proposições e operadores lógicos, preparando para a construção de bases de conhecimento com fatos, regras e consultas.\n\n4.4.1 Questão 1: Diagnóstico de Sistema\nUm sistema de monitoramento de um servidor reporta os seguintes fatos:\n\nSe o servidor está sobrecarregado (S), então a latência da rede aumenta (L).\n\nSe a latência da rede aumenta (L), o sistema de alerta envia uma notificação (N).\n\nO sistema de alerta não enviou uma notificação.\n\nModele essas afirmações usando lógica proposicional e prove que o servidor não está sobrecarregado.\n\n\n4.4.2 Questão 2: Validação de Circuito Lógico (Half-Adder)\nUm circuito somador de meio bit (Half-Adder) recebe duas entradas, A e B, e produz duas saídas: a Soma (S) e o “Vai-um” (C, de Carry). A lógica é:\n\nA saída S é verdadeira se, e somente se, exatamente uma das entradas (A ou B) for verdadeira.\n\nA saída C é verdadeira se, e somente se, ambas as entradas (A e B) forem verdadeiras.\n\nTraduza as condições para as saídas S e C em fórmulas proposicionais. Em seguida, usando uma tabela verdade, demonstre que a fórmula \\((A \\lor B) \\land \\neg(A \\land B)\\) é logicamente equivalente à fórmula para a saída S.\n\n\n4.4.3 Questão 3: Análise de Contrato de Serviço (Corrigida)\nAs cláusulas de um contrato de nível de serviço (SLA) para uma plataforma de nuvem estipulam:\n\nSe o uptime do serviço for menor que 99% (U), o cliente receberá um crédito na fatura (C).\n\nPara receber o crédito (C), o cliente deve abrir um ticket de suporte (T).\n\nO cliente pode optar por um desconto de 10% no próximo mês (D) em vez de receber o crédito (C), mas não pode ter ambos.\n\nNeste mês, o uptime foi de 98% e o cliente não abriu um ticket de suporte.\n\nAnalise a consistência lógica das regras do contrato. O que acontece quando o uptime é baixo mas o cliente não abre um ticket?\n\n\n4.4.4 Questão 4: Dependências de Compilação (Corrigida)\nPara compilar um software, as seguintes dependências devem ser satisfeitas:\n\nA biblioteca utils (U) deve estar compilada para que o módulo core (C) possa ser compilado.\n\nO módulo core (C) deve estar compilado para que o módulo api (A) possa ser compilado.\n\nPara compilar a interface gráfica gui (G), tanto o módulo api (A) quanto a biblioteca assets (L) devem estar compilados.\n\nA biblioteca utils (U) já foi compilada.\n\nModele as dependências como regras lógicas. Construa uma fórmula que represente todas as condições necessárias para compilar a gui. É possível compilar a gui com as informações disponíveis?\n\n\n4.4.5 Questão 5: Regras de um Jogo\nEm um jogo de tabuleiro, um jogador vence (V) se chegar à casa final (F) e possuir o amuleto mágico (A). As regras para obter o amuleto são:\n\nO jogador obtém o amuleto (A) se derrotar o dragão (D) ou se resolver o enigma da esfinge (E).\n\nPara enfrentar o dragão (D), o jogador precisa da espada de prata (S).\n\nO jogador encontrou a espada de prata, mas não conseguiu resolver o enigma da esfinge.\n\nModele o cenário. Supondo que o jogador chegue à casa final, ele vencerá o jogo se e somente se qual condição for satisfeita? Use equivalência lógica para simplificar a condição de vitória.\n\n\n4.4.6 Questão 6: Decisão de um Robô Autônomo\nUm robô de limpeza opera com as seguintes regras de decisão:\n\nSe o sensor de proximidade frontal detectar um obstáculo (O), o robô deve parar (P) e girar para a direita (G).\n\nSe a bateria estiver baixa (B), o robô deve parar (P) e retornar à base de carregamento (R).\n\nO robô não pode girar para a direita (G) e retornar à base (R) ao mesmo tempo.\n\nNeste momento, o sensor de proximidade detectou um obstáculo e a bateria está baixa.\n\nMostre que as regras atuais levam a uma contradição lógica, o que “travaria” o robô. Sugira uma modificação em uma das regras para resolver o conflito.\n\n\n4.4.7 Questão 7: Simplificação de Query de Banco de Dados (Corrigida)\nUm analista de dados precisa selecionar usuários de uma base de dados que satisfaçam uma condição complexa: “Selecionar usuários que são ‘ativos’ E (moram em ‘São Paulo’ OU têm mais de 50 compras) OU selecionar usuários que NÃO são ‘ativos’ E (moram em ‘São Paulo’ E têm mais de 50 compras)”.\nSeja: * A: O usuário é ‘ativo’.\n* S: O usuário mora em ‘São Paulo’.\n* C: O usuário tem mais de 50 compras.\nA condição pode ser escrita como: \\((A \\land (S \\lor C)) \\lor (\\neg A \\land (S \\land C))\\).\nUse uma tabela verdade para encontrar a forma normal disjuntiva mínima desta expressão. Qual das formas seria mais eficiente para o banco de dados processar?\n\n\n4.4.8 Questão 8: O Paradoxo do Mentiroso (Versão Proposicional)\nConsidere a seguinte afirmação: “Esta frase é falsa”. Seja P a proposição que representa “Esta frase é verdadeira”. A afirmação pode ser escrita como \\(P \\leftrightarrow \\neg P\\).\nUsando uma tabela verdade, mostre que esta fórmula é uma contradição. Explique por que isso representa um paradoxo e como a lógica proposicional clássica lida com sentenças autorreferentes.\n\n\n4.4.9 Questão 9: Política de Firewall\nUma política de segurança de rede é definida por duas regras:\n\nRegra 1: Se uma requisição vem de uma rede interna (I) E se destina à porta 443 (P), então a requisição é permitida (A).\n\nRegra 2: Se uma requisição vem de uma rede externa (ou seja, \\(\\neg I\\)) OU se destina a um serviço de monitoramento (ou seja, \\(\\neg P\\)), então a requisição é permitida (A).\n\nUm pacote chega de uma rede interna (I) e não se destina à porta 443 (\\(\\neg P\\)). A requisição será permitida? Use dedução lógica para chegar à conclusão. A política é redundante ou conflitante em algum aspecto?\n\n\n4.4.10 Questão 10: Tautologia, Contradição ou Contingência?\nUma empresa define uma nova política de bônus: “Um funcionário recebe um bônus (B) se ele atingiu a meta de vendas (V) ou se participou do novo treinamento (T). No entanto, se o funcionário participou do novo treinamento (T) mas não atingiu a meta de vendas (V), ele não recebe o bônus (B)”.\nA fórmula que descreve a política é: \\(((V \\lor T) \\to B) \\land ((T \\land \\neg V) \\to \\neg B)\\).\nAnalise esta fórmula. Ela é uma tautologia, uma contradição ou uma contingência? O que sua conclusão significa para a aplicabilidade da política da empresa?",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html",
    "title": "5  Provas",
    "section": "",
    "text": "5.0.1 Contrapositivas e Recíprocas\nAs implicações são um problema, do ponto de vista da matemática. Sentenças do tipo se…então induzem uma conclusão. Provar estas sentenças é uma preocupação constante da matemática. Dada uma implicação, existem duas fórmulas relacionadas que ocorrem com tanta frequência que possuem nomes especiais: contrapositivas e recíprocas. Antes de mergulharmos em contrapositivas, precisamos visitar alguns portos.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Provas</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "title": "5  Provas",
    "section": "5.1 Análise de Argumentos Lógicos em Textos do Cotidiano",
    "text": "5.1 Análise de Argumentos Lógicos em Textos do Cotidiano\nUma das coisas mais importantes que a amável leitora irá aprender neste documento é que a lógica não é apenas uma disciplina acadêmica, mas uma ferramenta poderosa para analisar e compreender argumentos em textos do cotidiano. A lógica nos ajuda a identificar premissas e conclusões, avaliar a validade de argumentos e entender como as ideias estão interconectadas. A lógica é útil e pode ser a diferença entre um argumento persuasivo e um argumento falacioso. Além disso, o uso da lógica para entender textos do cotidiano criará as estruturas cognitivas necessários para a construção de soluções computacionais para os problemas mais complexos da atualidade.\nA análise de argumentos lógicos em textos do cotidiano envolve a identificação de premissas e conclusões, bem como a formalização dessas relações em Lógica Proposicional ou lógica de predicados.\nDeste ponto tem diante, caberá a esforçada leitora, aplicar os conceitos aprendidos neste documento para analisar textos de livros, notícias, especificações de sistemas e outros documentos. Comece vendo os textos de exemplo a seguir.\n\n5.1.1 Exemplo 1: Avanço Científico na Medicina (2022)\n“Em 2022, pesquisadores descobriram que a vacina contra a malária aprovada pela Organização Mundial da Saúde pode ajudar a salvar centenas de milhares de vidas por ano. É também a primeira vacina do mundo para uma infecção parasitária. A malária mata mais de 600.000 pessoas anualmente, a maioria crianças menores de cinco anos.”\n\n5.1.1.1 Premissas e Conclusão\nPremissas:\n\nA malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\nA vacina contra a malária foi aprovada pela Organização Mundial da Saúde;\nA vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária.\n\nConclusão:\n\nA vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\n\n\n5.1.1.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\n\\(Q\\): A vacina contra a malária foi aprovada pela OMS;\n\\(R\\): A vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária;\n\\(S\\): A vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\nEstrutura do argumento: \\((P \\land Q \\land R) \\rightarrow S\\)\nLógica de Predicados:\n\n\\(m\\): malária;\n\\(v\\): vacina contra a malária;\n\\(Mata(x, y)\\): x mata y pessoas anualmente;\n\\(MajoriaCriancas(x)\\): a maioria das vítimas de x são crianças menores de cinco anos;\n\\(Aprovada(x)\\): x foi aprovada pela OMS;\n\\(Primeira(x)\\): x é a primeira vacina para infecção parasitária;\n\\(PodeSalvar(x, y)\\): x pode salvar y vidas por ano.\n\nFormalização:\n\n\\(Mata(m, 600000) \\land MajoriaCriancas(m)\\);\n\\(Aprovada(v)\\);\n\\(Primeira(v)\\);\n\\([Mata(m, 600000) \\land MajoriaCriancas(m) \\land Aprovada(v) \\land Primeira(v)] \\rightarrow PodeSalvar(v, \\text{\"centenas de milhares\"})\\).\n\n\n\n5.1.1.3 Análise da Validade\nEste argumento não segue uma forma lógica estritamente válida. A relação entre as premissas e a conclusão depende de conhecimentos médicos implícitos.\nEstrutura implícita:\n\nSe uma doença mata muitas pessoas e existe uma vacina aprovada contra essa doença, então essa vacina pode salvar muitas vidas;\nA malária mata muitas pessoas;\nExiste uma vacina aprovada contra a malária;\nLogo, a vacina contra a malária pode salvar muitas vidas.\n\nEsta estrutura se aproxima de um modus ponens, mas depende de uma premissa implícita.\n\n\n5.1.1.4 Análise da Solidez\nAs premissas são verificáveis e consideradas verdadeiras:\n\nA mortalidade por malária é confirmada por dados epidemiológicos da OMS;\nA aprovação da vacina pela OMS é um fato verificável;\nSer a primeira vacina para infecção parasitária é historicamente verificável.\n\nA conclusão é razoável no contexto médico, mas sua solidez completa dependeria de dados específicos sobre a eficácia da vacina.\n\n\n\n5.1.2 Exemplo 2: Inovação Tecnológica Nuclear (2023)\n“O campo da fusão nuclear teve um grande avanço em 2023. A fusão nuclear é uma reação química que produz uma grande quantidade de calor que pode ser usada para gerar energia. É o mesmo processo que alimenta o sol. A reação química é produzida por dois núcleos atômicos leves que se combinam e formam um único núcleo atômico leve mais pesado. Isso produz uma grande quantidade de energia.”\n\n5.1.2.1 Premissas e Conclusão\nPremissas:\n\nA fusão nuclear é uma reação que ocorre quando dois núcleos atômicos leves se combinam formando um único núcleo mais pesado;\nEsta reação produz grande quantidade de calor;\nO calor pode ser usado para gerar energia;\nA fusão nuclear é o mesmo processo que alimenta o sol.\n\nConclusão:\n\nO campo da fusão nuclear teve um grande avanço em 2023.\n\n\n\n5.1.2.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A fusão nuclear é uma reação em que núcleos leves se combinam formando um núcleo mais pesado;\n\\(Q\\): A fusão nuclear produz grande quantidade de calor;\n\\(R\\): O calor pode ser usado para gerar energia;\n\\(S\\): A fusão nuclear é o mesmo processo que alimenta o sol;\n\\(T\\): O campo da fusão nuclear teve um grande avanço em 2023.\n\nEstrutura do argumento: \\((P \\land Q \\land R \\land S) \\rightarrow T\\)\nLógica de Predicados:\n\n\\(FusaoNuclear(x)\\): \\(x\\) é um processo de fusão nuclear;\n\\(Reacao(x, y, z)\\): \\(x\\) é uma reação em que \\(y\\) se combina formando \\(z\\);\n\\(Produz(x, y)\\): \\(x\\) produz \\(y\\);\n\\(PodeGerarEnergia(x)\\): \\(x\\) pode ser usado para gerar energia;\n\\(AlimentaSol(x)\\): \\(x\\) é o processo que alimenta o sol;\n\\(TeveAvanco(x, y, z)\\): o campo \\(x\\) teve um avanço de grau \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Reacao(x, \\text{\"núcleos leves\"}, \\text{\"núcleo mais pesado\"})]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Produz(x, \\text{\"grande quantidade de calor\"})]\\);\n\\(\\forall x [Produz(x, \\text{\"grande quantidade de calor\"}) \\rightarrow PodeGerarEnergia(x)]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow AlimentaSol(x)]\\);\n\\(TeveAvanco(\\text{\"campo da fusão nuclear\"}, \\text{\"grande\"}, 2023)\\).\n\n\n\n5.1.2.3 Análise da Validade\nEste argumento apresenta uma estrutura incomum, pois a conclusão não é derivada logicamente das premissas apresentadas. As premissas descrevem o que é a fusão nuclear e suas características, mas não estabelecem uma relação lógica com o avanço mencionado.\nSob análise de dedução natural, o argumento não é válido, pois a conclusão não é uma consequência lógica das premissas fornecidas.\n\n\n5.1.2.4 Análise da Solidez\nComo o argumento não é formalmente válido, não pode ser considerado sólido. Entretanto, suas premissas são majoritariamente verdadeiras:\n\nA definição de fusão nuclear como combinação de núcleos leves é cientificamente precisa;\nA produção de calor e seu potencial energético são verdadeiros;\nA fusão nuclear realmente alimenta o sol.\n\nHá um erro conceitual no texto: a fusão nuclear é descrita como “reação química”, quando na verdade é uma reação nuclear, comprometendo a precisão científica do texto.\n\n\n\n5.1.3 Exemplo 3: Economia Global (2023)\n“As economias avançadas devem desacelerar de 2,6% em 2022 para 1,5% em 2023 e 1,4% em 2024, à medida que o aperto da política começa a surtir efeito. A inflação global deverá diminuir constantemente, de 8,7% em 2022 para 6,9% em 2023 e 5,8% em 2024, devido a uma política monetária mais rígida auxiliada por preços mais baixos das commodities internacionais.”\n\n5.1.3.1 Premissas e Conclusão\nPremissas:\n\nO aperto da política (monetária) está começando a surtir efeito;\nEstá sendo implementada uma política monetária mais rígida;\nOs preços das commodities internacionais estão mais baixos.\n\nConclusões:\n\nAs economias avançadas devem desacelerar de \\(2,6\\%\\) em 2022 para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\nA inflação global deverá diminuir constantemente, de \\(8,7\\%\\) em 2022 para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\n\n\n5.1.3.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): O aperto da política monetária está surtindo efeito;\n\\(Q\\): Está sendo implementada uma política monetária mais rígida;\n\\(R\\): Os preços das commodities internacionais estão mais baixos;\n\\(S\\): As economias avançadas desacelerarão para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\n\\(T\\): A inflação global diminuirá para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\nEstrutura do argumento: \\((P \\land Q \\land R) \\rightarrow (S \\land T)\\)\nLógica de Predicados:\n\n\\(ApertoSurteEfeito(x)\\): o aperto da política monetária \\(x\\) está surtindo efeito;\n\\(PoliticaRigida(x)\\): \\(x\\) é uma política monetária rígida;\n\\(PrecosBaixos(x)\\): os preços de $\\(x\\) estão baixos;\n\\(Desacelerar(x, y, z)\\): a economia \\(x\\) desacelerará para taxa \\(y\\) no ano \\(z\\);\n\\(DiminuirInflacao(x, y, z)\\): a inflação \\(x\\) diminuirá para taxa \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(ApertoSurteEfeito(\\text{\"política monetária\"})\\);\n\\(PoliticaRigida(\\text{\"política monetária atual\"})\\);\n\\(PrecosBaixos(\\text{\"commodities internacionais\"})\\);\n\\([ApertoSurteEfeito(\\text{\"política monetária\"}) \\land PoliticaRigida(\\text{\"política monetária atual\"})] \\rightarrow Desacelerar(\\text{\"economias avançadas\"}, 1.5\\%, 2023) \\land Desacelerar(\\text{\"economias avançadas\"}, 1.4\\%, 2024)\\);\n\\([PoliticaRigida(\\text{\"política monetária atual\"}) \\land PrecosBaixos(\\text{\"commodities internacionais\"})] \\rightarrow DiminuirInflacao(\\text{\"global\"}, 6.9\\%, 2023) \\land DiminuirInflacao(\\text{\"global\"}, 5.8\\%, 2024)\\).\n\n\n\n5.1.3.3 Análise da Validade\nEste argumento segue uma estrutura causal que pode ser analisada pela forma lógica:\n\nSe \\(X\\) causa \\(Y\\), e \\(X\\) está ocorrendo, então \\(Y\\) ocorrerá;\n\\(X\\) está ocorrendo;\nPortanto, \\(Y\\) ocorrerá.\n\nEsta estrutura segue o padrão de modus ponens, que é uma forma de argumento válida.\n\n\n5.1.3.4 Análise da Solidez\nA validade lógica do argumento foi estabelecida, mas sua solidez depende da veracidade das premissas:\n\nA eficácia do aperto monetário é uma afirmação empírica que requer verificação com dados econômicos;\nA implementação de política monetária mais rígida era geralmente verdadeira no contexto de 2023;\nA afirmação sobre preços mais baixos de commodities depende do período específico e das commodities consideradas.\n\nAs conclusões são previsões específicas cuja solidez dependeria da veracidade das premissas, da robustez dos modelos econômicos e da ausência de fatores externos imprevistos.\nEm economia, relações causais são geralmente probabilísticas, tornando a solidez do argumento contingente a condições específicas.\n\n\n\n5.1.4 Exercício de Análise de Argumentos Lógicos\nObjetivo: aplicar técnicas de Lógica Proposicional e de predicados para analisar descrições e especificações de sistemas computacionais, traduzindo-as para a linguagem formal e avaliando sua consistência lógica como base para decisões de implementação.\nDescrição: na engenharia de software, especificações e requisitos de sistemas são frequentemente descritos em linguagem natural, o que pode levar a ambiguidades, inconsistências e interpretações equivocadas. A análise lógica formal dessas descrições pode ajudar a identificar tais problemas e proporcionar uma base sólida para o desenvolvimento de soluções computacionais. Nesta tarefa, você atuará como “Arquiteto Lógico de Sistemas” para traduzir especificações em linguagem natural para modelos lógicos formais.\n\n5.1.4.1 Exercício 1: Sistema de Autenticação Biométrica\nFragmento de Texto Original: O sistema de autenticação biométrica deve permitir o acesso a usuários autorizados por meio de reconhecimento facial ou impressão digital. Se um usuário não conseguir autenticar por nenhum dos métodos biométricos, o sistema deve oferecer como alternativa a autenticação por senha. Caso ocorram três tentativas falhas consecutivas por qualquer método, o acesso do usuário deve ser temporariamente bloqueado por 30 minutos por motivos de segurança.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nUsuários autorizados podem se autenticar por reconhecimento facial;\nUsuários autorizados podem se autenticar por impressão digital;\nSe a autenticação biométrica falhar, o usuário pode usar senha;\nTrês tentativas falhas consecutivas levam ao bloqueio temporário;\nO bloqueio temporário dura 30 minutos.\n\nConclusões:\n\nO sistema deve bloquear o acesso após três tentativas falhas consecutivas;\nO sistema deve permitir múltiplos métodos de autenticação.\n\nFormalização\nLógica Proposicional:\n\n\\(A\\): O usuário está autorizado;\n\\(F\\): O usuário autentica com reconhecimento facial;\n\\(D\\): O usuário autentica com impressão digital;\n\\(S\\): O usuário autentica com senha;\n\\(T\\): Ocorreram três tentativas falhas consecutivas;\n\\(B\\): O acesso do usuário está bloqueado temporariamente.\n\nEstrutura do argumento:\n\n\\(A \\rightarrow (F \\lor D \\lor S)\\);\n\\(\\neg(F \\lor D) \\rightarrow S\\);\n\\(T \\rightarrow B\\).\n\nLógica de Predicados:\n\n\\(Usuario(x)\\): \\(x\\) é um usuário;\n\\(Autorizado(x)\\): \\(x\\) é autorizado;\n\\(AutenticaFacial(x)\\): \\(x\\) autentica por reconhecimento facial;\n\\(AutenticaDigital(x)\\): \\(x\\) autentica por impressão digital;\n\\(AutenticaSenha(x)\\): \\(x\\) autentica por senha;\n\\(TentativasFalhas(x, n)\\): \\(x\\) teve \\(n\\) tentativas falhas consecutivas;\n\\(Bloqueado(x, t)\\): \\(x\\) está bloqueado por \\(t\\) minutos.\n\nFormalização:\n\n\\(\\forall x [Autorizado(x) \\rightarrow (AutenticaFacial(x) \\lor AutenticaDigital(x) \\lor AutenticaSenha(x))]\\);\n\\(\\forall x [(Usuario(x) \\land \\neg(AutenticaFacial(x) \\lor AutenticaDigital(x))) \\rightarrow AutenticaSenha(x)]\\);\n\\(\\forall x [TentativasFalhas(x, 3) \\rightarrow Bloqueado(x, 30)]\\).\n\nAnálise da Validade: o argumento é válido em termos de Lógica Proposicional e de predicados. A estrutura segue formas lógicas válidas:\n\nA primeira relação estabelece uma disjunção inclusiva (OR) de métodos de autenticação disponíveis para usuários autorizados;\nA segunda relação segue a forma \\((P \\land \\neg Q) \\rightarrow R\\), que é válida: se um usuário não consegue autenticar pelos métodos biométricos, então deve poder usar senha;\nA terceira relação segue a forma \\(P \\rightarrow Q\\), um modus ponens: se ocorrerem três tentativas falhas, então o bloqueio é implementado.\n\nAnálise da Solidez:\nAs premissas são razoáveis no contexto de sistemas de autenticação modernos:\n\nA disponibilidade de múltiplos métodos de autenticação aumenta a usabilidade;\nA provisão de métodos alternativos quando os biométricos falham é uma prática comum;\nO bloqueio após múltiplas tentativas falhas é um mecanismo de segurança padrão.\n\nAs conclusões derivadas são sólidas no contexto de sistemas de autenticação e seguem práticas recomendadas de segurança digital.\n\n\n5.1.4.2 Exercício 2: Processamento de Pagamentos Online\nFragmento de Texto Original: O sistema de pagamentos online deve processar transações com cartões de crédito, cartões de débito e carteiras digitais. Quando uma transação é iniciada, o sistema verifica primeiro se há fundos suficientes. Se houver fundos suficientes, o sistema realiza a verificação de segurança. Uma transação só é aprovada se ambas as verificações forem bem-sucedidas. Caso contrário, a transação é rejeitada e o cliente recebe uma notificação com o motivo da falha.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema processa transações com cartões de crédito, cartões de débito e carteiras digitais;\nQuando uma transação é iniciada, o sistema verifica a disponibilidade de fundos;\nSe há fundos suficientes, o sistema realiza verificação de segurança;\nUma transação é aprovada apenas se as verificações de fundos e segurança forem bem-sucedidas;\nTransações rejeitadas geram notificações com o motivo da falha.\n\nConclusão:\n\nSe uma verificação de fundos ou segurança falhar, a transação será rejeitada.\n\nFormalização\nLógica Proposicional:\n\n\\(C\\): A transação é com cartão de crédito;\n\\(D\\): A transação é com cartão de débito;\n\\(W\\): A transação é com carteira digital;\n\\(F\\): Há fundos suficientes;\n\\(S\\): A verificação de segurança é bem-sucedida;\n\\(A\\): A transação é aprovada;\n\\(R\\): A transação é rejeitada;\n\\(N\\): O cliente recebe notificação.\n\nEstrutura do argumento:\n\n\\((C \\lor D \\lor W)\\) (A transação é feita por um dos métodos aceitos);\n\\(F \\rightarrow S\\) (Se há fundos, realiza-se verificação de segurança);\n\\((F \\land S) \\rightarrow A\\) (Se há fundos e a verificação de segurança é bem-sucedida, a transação é aprovada);\n\\(\\neg(F \\land S) \\rightarrow (R \\land N)\\) (Se não há fundos ou a verificação falha, a transação é rejeitada e há notificação).\n\nLógica de Predicados:\n\n\\(Transacao(x)\\): \\(x\\) é uma transação;\n\\(Metodo(x, y)\\): a transação \\(x\\) utiliza o método de pagamento \\(y\\);\n\\(TemFundos(x)\\): a transação \\(x\\) tem fundos suficientes;\n\\(VerificacaoSeguranca(x)\\): a transação \\(x\\) passa na verificação de segurança;\n\\(Aprovada(x)\\): a transação \\(x\\) é aprovada;\n\\(Rejeitada(x)\\): a transação \\(x\\) é rejeitada;\n\\(Notifica(x, y)\\): o sistema notifica o cliente sobre \\(y\\) relacionado à transação \\(x\\).\n\nFormalização:\n\n\\(\\forall x [Transacao(x) \\rightarrow (Metodo(x, \\text{\"crédito\"}) \\lor Metodo(x, \\text{\"débito\"}) \\lor Metodo(x, \\text{\"carteira digital\"}))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (TemFundos(x) \\rightarrow VerificacaoSeguranca(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow ((TemFundos(x) \\land VerificacaoSeguranca(x)) \\rightarrow Aprovada(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (\\neg(TemFundos(x) \\land VerificacaoSeguranca(x)) \\rightarrow (Rejeitada(x) \\land \\exists y Notifica(x, y)))]\\).\n\nAnálise da Validade:\nO argumento é válido logicamente. As relações causais seguem formas lógicas consistentes:\n\nA primeira premissa estabelece os métodos de pagamento aceitos, formando uma disjunção inclusiva;\nA relação entre verificação de fundos e verificação de segurança segue um fluxo condicional válido;\nA aprovação da transação requer a conjunção (AND) de condições, seguindo o padrão \\((P \\land Q) \\rightarrow R\\);\nA rejeição da transação ocorre pela negação da conjunção, usando a lei de De Morgan: \\(\\neg(P \\land Q) \\equiv \\neg P \\lor \\neg Q\\);\n\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de processamento de pagamentos:\n\nOs métodos de pagamento mencionados são comuns em sistemas reais;\nA verificação de fundos antes de processamento é uma prática padrão;\nAs verificações de segurança são essenciais em transações financeiras;\nA notificação em caso de falha é uma boa prática para experiência do usuário.\n\nA conclusão derivada é sólida e consistente com o funcionamento esperado de um sistema de pagamentos seguro e funcional.\n\n\n5.1.4.3 Exercício 3: Sistema de Gerenciamento de Estoque\nFragmento de Texto Original: “O sistema de gerenciamento de estoque deve monitorar continuamente os níveis de produtos. Quando o estoque de um produto cai abaixo do limite mínimo configurado, o sistema deve gerar automaticamente uma ordem de reabastecimento. Se o produto estiver marcado como ‘crítico’, a ordem deve ser enviada com prioridade alta. Caso contrário, a ordem segue o fluxo padrão. Qualquer produto que não tenha movimento de venda por mais de 90 dias deve ser marcado para revisão de demanda.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema monitora continuamente os níveis de estoque dos produtos;\nExiste um limite mínimo configurado para cada produto;\nOrdens de reabastecimento são geradas quando o estoque cai abaixo do limite mínimo;\nProdutos podem ser marcados como ‘críticos’;\nProdutos críticos recebem prioridade alta no reabastecimento;\nProdutos sem movimento de venda por mais de 90 dias são marcados para revisão.\n\nConclusões:\n\nSe o estoque de um produto cai abaixo do limite e o produto é crítico, uma ordem de reabastecimento com prioridade alta é gerada;\nSe o estoque de um produto cai abaixo do limite e o produto não é crítico, uma ordem de reabastecimento padrão é gerada;\nSe um produto não tem vendas por mais de 90 dias, ele deve ser revisado.\n\nFormalização\nLógica Proposicional:\n\n\\(M\\): O sistema monitora os níveis de estoque;\n\\(B\\): O estoque está abaixo do limite mínimo;\n\\(O\\): Uma ordem de reabastecimento é gerada;\n\\(C\\): O produto é marcado como crítico;\n\\(P\\): A ordem é enviada com prioridade alta;\n\\(F\\): A ordem segue fluxo padrão;\n\\(N\\): O produto não tem movimento de venda por mais de 90 dias;\n\\(R\\): O produto é marcado para revisão de demanda.\n\nEstrutura do argumento:\n\n\\(M\\);\n\\(B \\rightarrow O\\);\n\\((B \\land C) \\rightarrow (O \\land P)\\);\n\\((B \\land \\neg C) \\rightarrow (O \\land F)\\);\n\\(N \\rightarrow R\\).\n\nLógica de Predicados:\n\n\\(Produto(x)\\): \\(x\\) é um produto;\n\\(Monitora(x)\\): o sistema monitora o estoque de \\(x\\);\n\\(AbaixoLimite(x)\\): o estoque de \\(x\\) está abaixo do limite mínimo;\n\\(Critico(x)\\): \\(x\\) é marcado como crítico;\n\\(GeraOrdem(x, y)\\): o sistema gera uma ordem de reabastecimento para \\(x\\) com prioridade \\(y\\);\n\\(SemVendas(x, d)\\): \\(x\\) não tem vendas por \\(d\\) dias;\n\\(MarcarRevisao(x)\\): \\(x\\) é marcado para revisão de demanda.\n\nFormalização:\n\n\\(\\forall x [Produto(x) \\rightarrow Monitora(x)]\\);\n\\(\\forall x [Produto(x) \\land AbaixoLimite(x) \\rightarrow \\exists y \\, GeraOrdem(x, y)]\\);\n\\(\\forall x [Produto(x) \\land AbaixoLimite(x) \\land Critico(x) \\rightarrow GeraOrdem(x, \\text{\"alta\"})]\\);\n\\(\\forall x [Produto(x) \\land AbaixoLimite(x) \\land \\neg Critico(x) \\rightarrow GeraOrdem(x, \\text{\"normal\"})]\\);\n\\(\\forall x [Produto(x) \\land SemVendas(x, 90) \\rightarrow MarcarRevisao(x)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura segue padrões lógicos consistentes:\n\nA relação entre níveis de estoque e geração de ordens segue um modus ponens;\nA distinção entre produtos críticos e não críticos usa corretamente a conjunção e a negação;\nA condição para revisão de demanda segue uma implicação simples.\n\nAs regras de negócio são representadas por condicionais bem formados, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de gerenciamento de estoque:\n\nO monitoramento contínuo de estoque é uma funcionalidade essencial desses sistemas;\nO conceito de limite mínimo para reabastecimento é uma prática comum;\nA priorização de produtos críticos é uma estratégia logística válida;\nA revisão de produtos sem movimentação é uma prática de otimização de estoque reconhecida.\n\nAs conclusões derivadas são sólidas e refletem procedimentos operacionais padrão em gerenciamento de estoque e logística.\n\n\n\n5.1.5 Sistema de Recomendação de Conteúdo\n“O sistema de recomendação deve analisar o histórico de visualizações, preferências explícitas e comportamento de navegação de cada usuário. Com base nesses dados, o sistema calcula um score de relevância para cada item de conteúdo disponível. Itens com score acima de 0,7 são recomendados ao usuário. No entanto, se o usuário já visualizou um item nos últimos 30 dias, este não deve ser recomendado novamente, independentemente do score. Adicionalmente, se o usuário deu um feedback negativo a um conteúdo similar, o score desse tipo de conteúdo deve ser reduzido em 0,3 pontos.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas: 1. O sistema analisa o histórico de visualizações, preferências explícitas e comportamento de navegação. 2. Um score de relevância é calculado para cada item de conteúdo. 3. Itens com score acima de 0,7 são recomendados. 4. Itens visualizados nos últimos 30 dias não são recomendados, independentemente do score. 5. Feedback negativo a conteúdo similar reduz o score em 0,3 pontos.\nConclusões: - Um item será recomendado se seu score for maior que 0,7 E não tiver sido visualizado nos últimos 30 dias. - O feedback negativo do usuário influencia o cálculo do score para itens similares.\n\n\n5.1.6 Formalização Lógica\nLógica Proposicional: - \\(A\\): O sistema analisa dados do usuário. - \\(C\\): O sistema calcula scores de relevância. - \\(S\\): O item tem score acima de 0,7. - \\(V\\): O item foi visualizado nos últimos 30 dias. - \\(R\\): O item é recomendado ao usuário. - \\(F\\): O usuário deu feedback negativo a conteúdo similar. - \\(D\\): O score é reduzido em 0,3 pontos.\nEstrutura do argumento: 1. \\(A \\rightarrow C\\) 2. \\((S \\land \\neg V) \\rightarrow R\\) 3. \\(V \\rightarrow \\neg R\\) 4. \\(F \\rightarrow D\\)\nLógica de Predicados: - \\(Usuario(u)\\): u é um usuário - \\(Item(i)\\): i é um item de conteúdo - \\(AnalisaDados(u)\\): o sistema analisa dados do usuário u - \\(Score(i, s)\\): o item i tem score s - \\(Visualizado(u, i, d)\\): o usuário u visualizou o item i nos últimos d dias - \\(Recomendado(u, i)\\): o item i é recomendado ao usuário u - \\(FeedbackNegativo(u, t)\\): o usuário u deu feedback negativo ao tipo de conteúdo t - \\(Similar(i, t)\\): o item i é similar ao tipo de conteúdo t - \\(ReducaoScore(i, v)\\): o score do item i é reduzido em v pontos\nFormalização:\n\n\\(\\forall u [Usuario(u) \\rightarrow AnalisaDados(u)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\land Item(i) \\land Score(i, s) \\land s &gt; 0.7 \\land \\neg Visualizado(u, i, 30) \\rightarrow Recomendado(u, i)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\land Item(i) \\land Visualizado(u, i, 30) \\rightarrow \\neg Recomendado(u, i)]\\);\n\\(\\forall u \\forall i \\forall t [Usuario(u) \\land Item(i) \\land Similar(i, t) \\land FeedbackNegativo(u, t) \\rightarrow ReducaoScore(i, 0.3)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. As regras de recomendação seguem formas lógicas bem definidas:\n\nA relação entre análise de dados e cálculo de scores é uma implicação simples;\nA condição para recomendação usa corretamente a conjunção entre score alto e não visualização recente;\nA exclusão de itens já visualizados é uma implicação direta;\nA redução de score baseada em feedback é uma relação causal válida.\n\nA estrutura lógica representa adequadamente as regras condicionais do sistema de recomendação.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de recomendação modernos:\n\nA utilização de histórico, preferências e comportamento de navegação é uma prática padrão;\nO uso de scores de relevância é uma abordagem quantitativa comum;\nA prevenção de recomendações repetitivas é uma boa prática de experiência do usuário;\nA consideração de feedback negativo reflete sistemas adaptativos reais.\n\nAs conclusões derivadas são sólidas e representam um sistema de recomendação funcional que equilibra relevância, novidade e preferências do usuário.\n\n5.1.6.1 Exercício 5: Sistema de Detecção de Fraudes\nFragmento Texto Original: “O sistema de detecção de fraudes deve analisar cada transação em tempo real. Uma transação é marcada como suspeita se atender a pelo menos um dos seguintes critérios: valor acima do padrão histórico do cliente, localização geográfica incomum, ou múltiplas tentativas em curto período de tempo. Se dois ou mais critérios forem atendidos simultaneamente, a transação é automaticamente bloqueada e enviada para revisão manual. Caso contrário, se apenas um critério for atendido, o cliente recebe uma notificação de confirmação. Se o cliente não confirmar em 5 minutos, a transação é bloqueada preventivamente.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema analisa cada transação em tempo real;\nCritérios de suspeita: valor acima do padrão, localização incomum, múltiplas tentativas;\nUma transação é suspeita se atende a pelo menos um dos critérios;\nUma transação é automaticamente bloqueada se atende a dois ou mais critérios;\nSe apenas um critério for atendido, o cliente recebe notificação para confirmação;\nSe não houver confirmação em 5 minutos, a transação é bloqueada.\n\nConclusões:\n\nSe múltiplos critérios de suspeita são atendidos, a transação é bloqueada sem intervenção do cliente;\nSe um único critério é atendido, a transação depende de confirmação do cliente;\nToda transação suspeita é ou bloqueada automaticamente ou requer confirmação.\n\nFormalização\nLógica Proposicional:\n\n\\(R\\): O sistema analisa transações em tempo real;\n\\(V\\): A transação tem valor acima do padrão histórico;\n\\(L\\): A transação ocorre em localização geográfica incomum;\n\\(M\\): Há múltiplas tentativas em curto período;\n\\(S\\): A transação é marcada como suspeita;\n\\(B\\): A transação é bloqueada automaticamente;\n\\(N\\): O cliente recebe notificação de confirmação;\n\\(C\\): O cliente confirma a transação em 5 minutos;\n\\(P\\): A transação é bloqueada preventivamente.\n\nEstrutura do argumento:\n\n\\((V \\lor L \\lor M) \\rightarrow S\\);\n\\([(V \\land L) \\lor (V \\land M) \\lor (L \\land M)] \\rightarrow B\\);\n\\([S \\land \\neg((V \\land L) \\lor (V \\land M) \\lor (L \\land M))] \\rightarrow N\\);\n\\((N \\land \\neg C) \\rightarrow P\\).\n\nLógica de Predicados:\n\n\\(Transacao(t)\\): \\(t\\) é uma transação;\n\\(AnalisaTempoReal(t)\\): a transação \\(t\\) é analisada em tempo real;\n\\(ValorAlto(t)\\): a transação \\(t\\) tem valor acima do padrão histórico;\n\\(LocalizacaoIncomum(t)\\): a transação \\(t\\) ocorre em localização incomum;\n\\(MultiplasTentativas(t)\\): há múltiplas tentativas para a transação \\(t\\);\n\\(Suspeita(t)\\): a transação \\(t\\) é marcada como suspeita;\n\\(Bloqueada(t)\\): a transação \\(t\\) é bloqueada automaticamente;\n\\(EnviaNotificacao(t)\\): uma notificação é enviada para confirmar \\(t\\);\n\\(Confirma(t, m)\\): a transação \\(t\\) é confirmada dentro de m minutos;\n\\(BloqueioPreventivo(t)\\): a transação \\(t\\) recebe bloqueio preventivo.\n\nFormalização:\n\n\\(\\forall t [Transacao(t) \\rightarrow AnalisaTempoReal(t)]\\);\n\\(\\forall t [Transacao(t) \\land (ValorAlto(t) \\lor LocalizacaoIncomum(t) \\lor MultiplasTentativas(t)) \\rightarrow Suspeita(t)]\\);\n\\(\\forall t [Transacao(t) \\land ((ValorAlto(t) \\land LocalizacaoIncomum(t)) \\lor (ValorAlto(t) \\land MultiplasTentativas(t)) \\lor (LocalizacaoIncomum(t) \\land MultiplasTentativas(t))) \\rightarrow Bloqueada(t)]\\);\n\\(\\forall t [Transacao(t) \\land Suspeita(t) \\land \\neg((ValorAlto(t) \\land LocalizacaoIncomum(t)) \\lor (ValorAlto(t) \\land MultiplasTentativas(t)) \\lor (LocalizacaoIncomum(t) \\land MultiplasTentativas(t))) \\rightarrow EnviaNotificacao(t)]\\);\n\\(\\forall t [Transacao(t) \\land EnviaNotificacao(t) \\land \\neg Confirma(t, 5) \\rightarrow BloqueioPreventivo(t)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura representa corretamente o processo de decisão do sistema:\n\nA definição de transação suspeita usa uma disjunção (\\(OR\\)) adequada;\nA condição para bloqueio automático usa corretamente conjunções (\\(AND\\)) para representar a combinação de critérios;\nA notificação em caso de suspeita única é representada por uma conjunção com uma negação de múltiplos critérios;\nO bloqueio preventivo após falta de confirmação segue uma implicação lógica válida.\n\nO sistema de regras é coerente, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de detecção de fraudes:\n\nA análise em tempo real é essencial para sistemas antifraude eficazes;\nOs critérios mencionados são indicadores comuns de atividades potencialmente fraudulentas;\nA escalação baseada na quantidade de indicadores segue práticas reais de segurança;\nO envolvimento do cliente para confirmação é uma prática que equilibra segurança e usabilidade;\nO tempo limite para confirmação é uma medida preventiva razoável.\n\nAs conclusões derivadas são sólidas e representam um sistema de detecção de fraudes que equilibra detecção automática, envolvimento do cliente e proteção preventiva.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Provas</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html",
    "href": "04-logica-predicativa-e-quantificadores.html",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "",
    "text": "6.1 Introdução aos Predicados\nUm predicado é como uma luneta que nos permite observar as propriedades de uma entidade. Um conjunto de lentes através do qual podemos ver se uma entidade particular possui ou não uma característica específica. A palavra predicado foi importada do campo da linguística e tem o mesmo significado: qualidade; característica. Por exemplo, ao observar o universo das letras através do telescópio do predicado ser uma vogal, percebemos que algumas entidades deste conjunto, como \\(a\\) e \\(e\\), possuem essa propriedade, enquanto outras, como \\(b\\) e \\(c\\), não.\nUm predicado não é uma afirmação absoluta de verdade ou falsidade. Divergindo das proposições, os predicados não são declarações completas. Pense neles como aquelas sentenças com espaços em branco, aguardando para serem preenchidos, que só têm sentido completo quando preenchidas:\nPreencha as lacunas, como quiser desde que faça sentido, e perceba que, em cada caso, ao preencher estamos atribuindo uma qualidade a um objeto. Esses são exemplos de predicados do nosso cotidiano, que sinteticamente o conceito que queremos abordar. Na lógica, os predicados são artefatos que possibilitam examinar o mundo ao nosso redor de forma organizada e exata.\nUm predicado pode ser entendido como uma função que recebe um objeto (ou um conjunto de objetos) e retorna um valor de verdade, \\(\\{\\text{TRUE, FALSE}\\}\\). Esta função descreve uma propriedade que o objeto pode possuir. Isto é, se \\(P\\) é uma função \\(P: u \\rightarrow \\{\\text{TRUE, FALSE}\\}\\) para um determinado conjunto $ u$ qualquer. Esse conjunto $ u$ é chamado de universo ou domínio do discurso, e dizemos que \\(P\\) é um predicado sobre $ u$.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#introdução-aos-predicados",
    "href": "04-logica-predicativa-e-quantificadores.html#introdução-aos-predicados",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "",
    "text": "O _______ está saboroso;\nO _______ é vermelho;\n_______ é alto.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#universo-do-discurso",
    "href": "04-logica-predicativa-e-quantificadores.html#universo-do-discurso",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.2 Universo do Discurso",
    "text": "6.2 Universo do Discurso\nO universo do discurso, \\(u\\), também chamado de universo, ou domínio, é o conjunto de objetos de interesse em um determinado cenário lógico para uma análise específica. O universo do discurso é importante porque as proposições na Lógica de Predicados serão declarações sobre objetos de um universo.\nO universo, \\(u\\), é o domínio das variáveis das nossas Fórmulas Bem Formadas. O universo do discurso pode ser o conjunto dos números reais, \\(\\mathbb{R}\\), o conjunto dos inteiros, \\(\\mathbb{Z}\\), o conjunto de todos os alunos em uma sala de aula que usam camisa amarela, ou qualquer outro conjunto que definamos. Na prática, o universo costuma ser deixado implícito e deveria ser óbvio a partir do contexto. Se não for o caso, precisa ser explicitado.\nSe estamos interessados em proposições sobre números naturais, \\(\\mathbb{N}\\), o universo do discurso é o conjunto \\(\\mathbb{N} = \\{0, 1, 2, 3,...\\}\\), um conjunto infinito. Já se estamos interessados em proposições sobre alunos de uma sala de aula, o universo do discurso poderia ser o conjunto $ u = {, , …}$, um conjunto finito.\nPara que este conceito fique mais claro, suponha que temos um conjunto de números \\(u = \\{1, 2, 3, 4, 5\\}\\) e um predicado \\(P(x)\\), que dizemos unário por ter um, e somente um, argumento, que afirma x é par. Ao aplicarmos este predicado a cada elemento do universo \\(u\\), obtemos um conjunto de valores verdade:\n\\[\n\\begin{align}\n&P(1) = \\text{FALSE};\\\\\n&P(2) = \\text{TRUE};\\\\\n&P(3) = \\text{FALSE};\\\\\n&P(4) = \\text{TRUE};\\\\\n&P(5) = \\text{FALSE}.\n\\end{align}\n\\]\nVemos que o predicado \\(P(u)\\) dado por u é par é uma propriedade que alguns números do conjunto $ u$ Possuem, e outros não. Vale notar que na Lógica Predicativa, a função que define um predicado pode ter múltiplos argumentos. Por exemplo, podemos ter um predicado \\(Q(x, y)\\) que afirma x é maior que y. Neste caso, o predicado \\(Q\\) é uma função de dois argumentos que retorna um valor de verdade. Dizemos que \\(Q(x, y)\\) é um predicado binário. Exemplos nos conduzem ao caminho do entendimento:\n\nExemplo 1:\n\nUniverso do discurso: \\(u = \\text{conjunto de todas as pessoas}\\).\nPredicado: \\(P(x) = \\{ x : x \\text{ é um matemático} \\}\\);\nItens para os quais \\(P(x)\\) é verdadeiro: Carl Gauss, Leonhard Euler, John Von Neumann.\n\nExemplo 2:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{Z} : x \\text{ é par}\\}\\)\nPredicado: \\(Q(x) = (x &gt; 5)\\);\nItens para os quais \\(Q(x)\\) é verdadeiro: $6 $, $8 $, \\(10 ...\\).\n\nExemplo 3:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{R} : x &gt; 0 \\text{ e } x &lt; 10\\}\\)\nPredicado: \\(R(x) = (x^2 - 4 = 0)\\);\nItens para os quais \\(R(x)\\) é verdadeiro: \\(2\\) (note que \\(-2\\) não pertence ao universo do discurso definido).\n\nExemplo 4:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{N} : x \\text{ é um múltiplo de } 3\\}\\)\nPredicado: \\(S(x) = (\\text{mod}(x, 2) = 0)\\);\nItens para os quais \\(S(x)\\) é verdadeiro: \\(6\\), \\(12\\), $18 $.\n\nExemplo 5:\n\nUniverso do discurso: \\(u = \\{(x, y) \\in \\mathbb{R}^2 : x \\neq y\\}\\)\nPredicado: \\(P(x, y) = (x &lt; y)\\);\nItens para os quais \\(P(x, y)\\) é verdadeiro: \\((1, 2)\\), \\((3, 4)\\), \\((5, 6)\\).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#entendendo-predicados",
    "href": "04-logica-predicativa-e-quantificadores.html#entendendo-predicados",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.3 Entendendo Predicados",
    "text": "6.3 Entendendo Predicados\nA aridade do predicado, número de argumentos, é limitado pela análise lógica que estamos fazendo. Considere um predicado ternário, \\(R\\), dado por x está entre y e z. Quando substituímos \\(x\\), \\(y\\) e \\(z\\) por números específicos podemos validar a verdade do predicado \\(R\\). Vamos considerar alguns exemplos adicionais de predicados baseados na aritmética e defini-los com menos formalidade e mais legibilidade:\n\n$ Primo(x)$: o número inteiro positivo $ x$ é um número primo.\n$ PotênciaDe (x, y)$: o número inteiro $ x$ é uma potência exata de \\(y : x = y^z\\) para algum \\(z \\in \\mathbb{Z}, z \\geq 0\\).\n$ somaDeDoisPrimos(x)$: o número inteiro positivo $ x$ é igual à soma de dois números primos.\n\nEm 1, 2 e 3 os predicados estão definidos com mnemônicos aumentando a legibilidade e melhorando nossa capacidade de manter o universo implícito. O uso de predicados, e da Lógica Proposicional, permite a escrita de sentenças menos ambíguas para a definição de conceitos lógicos em formato matemático. Por exemplo: se \\(x\\) é um ancestral de \\(y\\) e \\(y\\) é um ancestral de \\(z\\) então \\(x\\) é um ancestral de \\(z\\); que, se consideramos o predicado $AncestralDe $ Pode ser escrito como \\(AncestralDe (x,y) \\wedge ancestralDe (y,z) \\rightarrow ancestralDe (x,z)\\). Ainda assim, falta alguma coisa. Algo que permita aplicar os predicados a um conjunto de elementos dentro do universo do discurso. É aqui que entram os quantificadores.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.4 Quantificadores",
    "text": "6.4 Quantificadores\nEmbora a Lógica Proposicional seja um bom ponto de partida, a maioria das afirmações interessantes em matemática contêm variáveis definidas em domínios maiores do que apenas \\(\\{\\text{TRUE, FALSE}\\}\\). Por exemplo, a afirmação \\(x \\text{é uma potência de } 2\\) não é uma proposição. Não temos como definir a verdade dessa afirmação até conhecermos o valor de \\(x\\). Se \\(P(x)\\) é definido como a afirmação \\(x \\text{é uma potência de } 2\\), então \\(P(8)\\) é verdadeiro e \\(P(7)\\) é falso.\nPara termos uma linguagem lógica que seja suficientemente flexível para representar os problemas que encontramos no Universo real, o Universo em que vivemos, precisaremos ser capazes de dizer quando o predicado \\(P\\) ou \\(Q\\) é verdadeiro para valores diferentes em seus argumentos. Para tanto, vincularemos as variáveis aos predicados usando operadores para indicar quantidade, chamados de quantificadores.\nOs quantificadores indicam se a sentença que estamos criando se aplica a todos os valores possíveis do argumento, quantificação universal, ou se esta sentença se aplica a um valor específico, quantificação existencial. Usaremos esses quantificadores para fazer declarações sobre todos os elementos de um universo de discurso específico, ou para afirmar que existe pelo menos um elemento do universo do discurso que satisfaz uma determinada qualidade.\nVamos remover o véu da dúvida usando como recurso metafórico uma experiência humana, social, comum e popular: imaginemos estar em uma festa e o anfitrião lhe pede para verificar se todos os convidados têm algo para beber. Você, prestativo e simpático, começa a percorrer a sala, verificando cada pessoa. Se você encontrar pelo menos uma pessoa sem bebida, você pode imediatamente dizer nem todos têm bebidas. mas, se você verificar cada convidado e todos eles tiverem algo para beber, você pode dizer com confiança todos têm bebidas. Este é o conceito do quantificador universal, matematicamente representado por \\(\\forall\\), que lemos como para todo.\nA festa continua e o anfitrião quer saber se alguém na festa está bebendo champanhe. Desta vez, assim que você encontrar uma pessoa com champanhe, você pode responder imediatamente sim, alguém está bebendo champanhe. Você não precisa verificar todo mundo para ter a resposta correta. Este é o conceito do quantificador existencial, denotado por $$, que lemos existe algum.\nOs quantificadores nos permitem fazer declarações gerais, ou específicas, sobre os membros de um universo de discurso, de uma forma que seria difícil, ou impossível, sem estes operadores especiais.\n\n6.4.1 Quantificador Universal\nO quantificador universal \\(\\forall\\), lê-se para todo, indica que uma afirmação deve ser verdadeira para todos os valores de uma variável dentro de um universo de discurso definido para a criação de uma sentença contendo um predicado qualquer. Por exemplo, a proposição clássica todos os humanos são mortais pode ser escrita como \\(\\forall x Humano(x) \\rightarrow Mortal(x)\\). Ou recorrendo a um exemplo com mais de rigor matemático, teríamos o predicado se \\(x\\) é positivo então $x + 1 $ é positivo, que pode ser escrito \\(\\forall x (x &gt; 0 \\rightarrow x + 1 &gt; 0)\\). Neste último exemplo temos Quantificadores, Lógica Predicativa, Lógica Proposicional e Teoria dos Conjuntos em uma sentença.\nO quantificador universal pode ser representado usando apenas a Lógica Proposicional, com uma pequena trapaça. A afirmação \\(\\forall x P(x)\\) é, de certa forma, a operação $$, AND aplicada a todos os elementos do universo do discurso. Ou seja, o predicado:\n\\[\\forall x (x \\in \\mathbb{N} \\rightarrow P(x))\\]\nPode ser escrito como:\n\\[P(0) \\land P(1) \\land P(2) \\land P(3) \\land \\ldots \\]\nAssim, $P(0), P(1), P(2), P(3) $ representam a aplicação do predicado \\(P\\) a todos os elementos \\(x\\) do conjunto \\(\\mathbb{N}\\). A trapaça fica por conta de que, em Lógica Proposicional, não podemos escrever expressões com um número infinito de termos. Portanto, a expansão em conjunções de um predicado \\(P\\) em um Universo de Discurso, $ u$, não é uma Fórmula Bem Formada se a cardinalidade de $ u$ for infinita. De qualquer forma, podemos usar esta interpretação informal para entender o significado de \\(\\forall x P(x)\\).\nA representação do Quantificador Universal como uma conjunção não é uma Fórmula Bem Formada** a não ser que o Universo do Discurso seja não infinito. Neste caso, teremos uma conjunção que chamaremos de Conjunção Universal:\n\\[\\forall x (P(x) \\land Q(x))\\]\nIsso significa que para todo \\(x\\) no domínio, as propriedades \\(P\\), \\(Q\\), e outras listadas são todas verdadeiras. É uma forma de expressar que todas as condições listadas são verdadeiras para cada elemento no domínio. Esta fórmula será usada para simplificar sentenças, ou para criar formas normais.\nVamos voltar um pouco. O quantificador universal \\(\\forall x P(x)\\)Afirma que a proposição \\(P(x)\\) é verdadeira para todo, e qualquer, valor possível de \\(x\\) como elemento de um conjunto, \\(u\\). Uma forma de interpretar isso é pensar em \\(x\\) como uma variável que pode ter qualquer valor dentro do universo do discurso.\nPara validar \\(\\forall x P(x)\\) escolhemos o pior caso possível para \\(x\\), todos os valores que suspeitamos possa fazer \\(P(x)\\) falso. Se conseguirmos provar que \\(P(x)\\) é verdadeira nestes casos específicos, então \\(\\forall x P(x)\\) deve ser verdadeira. Novamente, vamos recorrer a exemplos na esperança de explicitar este conceito.\nExemplo 1: todos os números reais são maiores que 0. (Universo do discurso: \\(\\{x \\in \\mathbb{R}\\}\\))\n\\[\\forall x (x \\in \\mathbb{R} \\rightarrow x &gt; 0)\\]\n\nObserve que este predicado, apesar de estar corretamente representado, é \\(Falso\\).\n\nExemplo 2: todos os triângulos em um plano euclidiano têm a soma dos ângulos internos igual a 180 graus. (Universo do discurso: \\(x\\) é um triângulo em um plano euclidiano)\n\\[\\forall x (Triângulo(x) \\rightarrow \\Sigma_{i=1}^3 ÂnguloInterno_i(x) = 180^\\circ)\\]\nExemplo 3: todas as pessoas com mais de 18 anos podem tirar carteira de motorista.” (Universo do discurso: \\(x\\) é uma pessoa no Brasil)\n\\[\\forall x (Pessoa(x) \\land Idade (x) \\geq 18 \\rightarrow PodeTirarCarteira(x))\\]\nExemplo 4: todo número par maior que 2 pode ser escrito como a soma de dois números primos. (Universo do discurso: \\(\\{x \\in \\mathbb{Z}\\}\\)\n\\[\\forall x\\,(Par(x) \\land x &gt; 2 \\rightarrow \\exists u\\exists v\\, (Primo(u) \\land Primo(v) \\land x = u + v))\\]\nExemplo 5: para todo número natural, se ele é múltiplo de 4 e múltiplo de 6, então ele também é múltiplo de 12. (Universo do discurso: \\(\\{x \\in \\mathbb{N}\\}\\))\n\\[\\forall x\\,((\\exists u\\in\\Bbb N\\,(x = 4u) \\land \\exists v\\in\\Bbb N\\,(x = 6v)) \\rightarrow \\exists w\\in\\Bbb N\\,(x = 12w))\\]\nO quantificador universal nos permite definir uma Fórmula Bem Formada representando todos os elementos de um conjunto, um universo do discurso, em relação a uma qualidade específica, um predicado. Esta é um artefato lógico interessante, mas não suficiente.\nUsamos, preferencialmente, a implicação, \\(\\to\\), com o quantificador universal, \\(\\forall\\), para indicar que uma propriedade vale para todos os elementos de um domínio, Porque permite afirmar que para todo \\(x\\), se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. Isso permite que \\(P(x)\\) seja falsa para alguns \\(x\\), mas a implicação como um todo permanece verdadeira. Ou, em outras palavras, quando usamos uma implicação, como \\(P(x) \\rightarrow Q(x)\\), estamos dizendo que se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. A implicação é uma forma lógica que permite conectar duas proposições, em que a veracidade de \\(Q(x)\\) depende da veracidade de \\(P(x)\\).\n\nImportante: A implicação \\(P(x) \\rightarrow Q(x)\\) é considerada verdadeira em qualquer dos seguintes casos:\n\\(P(x)\\) é verdadeira e \\(Q(x)\\) é verdadeira. \\(P(x)\\) é falsa, independentemente de \\(Q(x)\\). O ponto-chave é o segundo caso: se \\(P(x)\\) for falsa, a implicação \\(P(x) \\rightarrow Q(x)\\) ainda é verdadeira, não importa o valor de \\(Q(x)\\).\n\nEssa preferência não é arbitrária, mas baseada nas limitações que os outros conectivos apresentam quando combinados com o quantificador universal. Porém, uma análise de todos os operadores pode ser interessante para sedimentar os conceitos.\nComecemos com a conjunção. Quando usamos \\(∀x(P(x) ∧ Q(x))\\), estamos afirmando que para todo \\(x\\), tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiros. Isso é extremamente restritivo e raramente reflete situações do mundo real. Por exemplo, se disséssemos Todos os animais são mamíferos e podem voar, estaríamos fazendo uma afirmação falsa, pois nem todos os animais são mamíferos e nem todos podem voar. Outro exemplo seria Todos os números são pares e primos, o que é claramente falso, pois nenhum número (exceto 2) satisfaz ambas as condições simultaneamente.\nA disjunção, por outro lado, é muito fraca quando combinada com o quantificador universal. \\(∀x(P(x) ∨ Q(x))\\) afirma que para todo \\(x\\), ou \\(P(x)\\) ou \\(Q(x)\\) (ou ambos) são verdadeiros. Isso geralmente não captura relações condicionais úteis. Por exemplo, Todo número é par ou ímpar é uma afirmação verdadeira, mas não nos diz muito sobre a relação entre paridade e números. Da mesma forma, Toda pessoa é alta ou baixa é uma afirmação de tal amplitude que se torna quase sem sentido, pois não fornece informações úteis sobre a altura das pessoas.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador universal também apresenta problemas. \\(∀x(P(x) \\leftrightarrow Q(x))\\) afirma que para todo \\(x\\), \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso é uma condição muito forte e raramente é satisfeita em situações reais. Por exemplo, Um número é par se e somente se é divisível por 4 é falso, pois há números pares que não são divisíveis por \\(4\\) (como \\(2\\) e \\(6\\)). Outro exemplo seria Uma pessoa é feliz se e somente se é rica, o que claramente não reflete a realidade complexa da felicidade e riqueza.\nPor outro lado, a implicação (\\(\\to\\)) oferece várias vantagens quando usada com o quantificador universal. \\(∀x(P(x) \\to Q(x))\\) nos permite expressar relações condicionais de forma mais flexível e precisa. Por exemplo, Para todo número, se é par, então não é primo (exceto 2) é uma afirmação verdadeira e informativa. Outro exemplo seria Para toda pessoa, se é médico, então tem formação universitária. Esta formulação permite exceções (pode haver pessoas com formação universitária que não são médicos) e captura uma regra geral de forma precisa.\nA implicação também tem a vantagem de ser verdadeira quando o antecedente (\\(P(x)\\)) é falso, o que é útil para expressar regras gerais. Por exemplo, em Para todo x, se x é um quadrado perfeito, então x é positivo, a implicação é verdadeira mesmo para números negativos (que não são quadrados perfeitos), mantendo a regra geral válida.\nEspero que tenha ficado claro. A implicação, quando combinada com o quantificador universal, oferece um equilíbrio entre flexibilidade e precisão que os outros conectivos lógicos não conseguem alcançar. Ela permite expressar relações condicionais, acomoda exceções e captura regras gerais de forma mais eficaz, tornando-a a escolha preferida em muitas situações da lógica formal e da matemática.\n\n\n6.4.2 Quantificador Existencial\nO quantificador existencial, $$ nos permite fazer afirmações sobre a existência de objetos com certas propriedades, sem precisarmos especificar exatamente quais objetos são esses. Vamos tentar remover os véus da dúvida com um exemplo simples.\nConsideremos a sentença: existem humanos mortais. Com um pouco mais de detalhe e matemática, podemos escrever isso como: existe pelo menos um \\(x\\) tal que \\(x\\) é humano e mortal. Para escrever a mesma sentença com precisão matemática teremos:\n\\[\\exists x \\text{Humano}(x) \\land \\text{Mortal}(x)\\]\nLendo por partes: existe um \\(x\\), tal que \\(x\\) é humano AND \\(x\\) é mortal. Em outras palavras, existe pelo menos um humano que é mortal.\nNote duas coisas importantes:\n\nNós não precisamos dizer exatamente quem é esse humano mortal. Só afirmamos que existe um. O operador $$ captura essa ideia.\nUsamos AND ($\\(), não implicação (\\)$). Se usássemos $$, a afirmação ficaria muito mais fraca. Veja:\n\n\\[\\exists x \\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\]\nQue pode ser lido como: existe um \\(x\\) tal que, SE \\(x\\) é humano, ENTÃO \\(x\\) é mortal. Essa afirmação é verdadeira em qualquer universo que contenha um unicórnio de bolinhas roxas imortal. Porque o unicórnio não é humano, então \\(\\text{Humano}(\\text{unicórnio})\\) é falsa, e a implicação \\(\\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\) é verdadeira. Não entendeu? Volte dois parágrafos e leia novamente. Repita!\nPortanto, é importante usar o operador $$, e não $$ quando trabalhamos com quantificadores existenciais. O $$ garante que a propriedade se aplica ao objeto existente definido pelo $$. Contudo, podemos melhorar um pouco isso:\nA conjunção, \\(\\land\\), é frequentemente empregada com o quantificador existencial, \\(\\exists\\), para expressar a presença de ao menos um elemento em determinado conjunto que possui múltiplas características simultaneamente. Isso nos possibilita declarar que há no mínimo um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são válidas. Tal afirmação confirma a existência de pelo menos um elemento que atende a ambos os critérios. Dito de outra forma, ao utilizarmos uma conjunção, como em \\(P(x) \\land Q(x)\\), estamos afirmando que existe ao menos um \\(x\\) em que \\(P(x)\\) é verdadeiro e, ao mesmo tempo, \\(Q(x)\\) também o é. A conjunção funciona como um operador lógico que une duas proposições, em que a validade da asserção existencial depende da ocorrência simultânea de \\(P(x)\\) e \\(Q(x)\\) para, no mínimo, um \\(x\\).\n\nNo contexto do quantificador existencial \\(\\exists x\\), a conjunção \\(P(x) \\land Q(x)\\) é tida como verdadeira se, e apenas se:\nHouver ao menos um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiras. Caso não exista tal \\(x\\), a afirmação existencial é considerada falsa. Observe que basta a existência de um único elemento satisfazendo ambas as condições para validar a afirmação existencial.\n\nEsta predileção não é fortuita, mas fundamentada na aptidão da conjunção em expressar com exatidão a existência de elementos dotados de múltiplos atributos concomitantes. No entanto, uma avaliação dos demais operadores pode ser proveitosa para consolidar esses conceitos.\nIniciemos com a implicação. Ao empregarmos \\(\\exists x(P(x) \\to Q(x))\\), declaramos a existência de ao menos um \\(x\\) tal que, se \\(P(x)\\) for verdadeiro, então \\(Q(x)\\) também o será. Esta formulação é menos elucidativa que a conjunção no âmbito existencial, pois seria verdadeira mesmo se \\(P(x)\\) fosse falso para todo \\(x\\). Ilustrando: Há um número que, se for ímpar, é múltiplo de 2 é verdadeiro (pois é válido para números pares), mas não esclarece se realmente existe um número ímpar que é múltiplo de 2.\nA disjunção aliada ao quantificador existencial, \\(\\exists x(P(x) \\lor Q(x))\\), assevera a existência de pelo menos um \\(x\\) que satisfaz \\(P(x)\\) ou \\(Q(x)\\) (ou ambos). Embora útil em certos contextos, geralmente é menos robusta que a conjunção para afirmar a existência de elementos com múltiplas propriedades. Por exemplo: Existe um número que é negativo ou racional é verdadeiro, mas não nos informa se há um número que é ambos.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador existencial também pode ser problemática. \\(\\exists x(P(x) \\leftrightarrow Q(x))\\) afirma a existência de ao menos um \\(x\\) para o qual \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso pode ser útil em alguns casos, mas frequentemente é mais restritivo do que o necessário. Por exemplo: Existe um número que é positivo se e somente se é inteiro é verdadeiro (o número 1 satisfaz isso), mas não captura a existência de números que são apenas positivos ou apenas inteiros.\nEm contrapartida, a conjunção (\\(\\land\\)) apresenta diversas vantagens quando utilizada com o quantificador existencial. \\(\\exists x(P(x) \\land Q(x))\\) nos permite afirmar a existência de elementos que possuem múltiplas propriedades simultaneamente. Por exemplo: Existe um número que é positivo e par é uma afirmação verdadeira e informativa (o número 2 satisfaz ambas as condições). Outro exemplo seria Existe uma substância que é líquida e condutora de eletricidade. Esta formulação afirma claramente a existência de substâncias com ambas as características.\nA conjunção também tem a vantagem de ser falsa quando não há elementos que satisfaçam ambas as condições, o que é útil para expressar a inexistência de certos tipos de elementos. Por exemplo: Existe um número que é natural e negativo simultaneamente é falso, indicando corretamente que não há tais números.\nEm suma, a conjunção, quando associada ao quantificador existencial, proporciona um meio preciso e informativo de expressar a existência de elementos com múltiplos atributos. Ela permite afirmar a presença de elementos que atendem a condições simultâneas, tornando-se a opção preferencial em diversas situações da lógica formal e da matemática quando se trata de asserções existenciais.\nAssim como o quantificador universal, \\(\\forall\\), o quantificador existencial, \\(\\exists\\) , também pode ser restrito a um universo específico, usando a notação de pertencimento:\n\\[\\exists x (x \\in \\mathbb{Z} \\land x = x^2)\\]\nEsta sentença afirma a existência de pelo menos um inteiro \\(x\\) tal que \\(x\\) é igual ao seu quadrado. Novamente, não precisamos dizer qual é esse inteiro, apenas que ele existe dentro do conjunto dos inteiros. A resposta é sim: tanto \\(x = 0\\) quanto \\(x = 1\\) satisfazem a equação \\(x = x^2\\).\nDe forma geral, o quantificador existencial serve para fazer afirmações elegantes sobre a existência de objetos com certas qualidades, sem necessariamente conhecermos ou elencarmos todos esses objetos. Isso agrega mais qualidade a representação do mundo real que podemos fazer com a Lógica de Primeira Ordem.\nTalvez, alguns exemplos possam ajudar no seu entendimento:\nExemplo 1: existe um animal que é vertebrado e não é mamífero.\n\\[\\exists x (Vertebrado(x) \\land \\neg Mamífero(x))\\]\nExemplo 2: existe uma equação do segundo grau com exatamente uma raiz real.\n\\[\\exists x (\\text{Eq2Grau}(x) \\land |\\text{RaízesReais}(x)| = 1)\\]\nExemplo 3: existe um número primo que é par.\n\\[\\exists x (Primo(x) \\land Par(x))\\]\nExemplo 4: existe um quadrado perfeito que pode ser escrito como o quadrado de um número racional.\n\\[\\exists x (QuadPerfeito(x) \\land \\exists u \\in \\mathbb{Q} \\ (x = u^2))\\]\nExemplo 5: existe um polígono convexo em que a soma dos ângulos internos não é igual a \\((y-2)\\cdot180^{\\circ}\\).\n\\[\\exists x (\\text{PolígonoConvexo}(x) \\land \\sum_{z=1}^{y} \\text{ÂnguloInterno}_z(x) \\neq (y-2)\\cdot 180^{\\circ})\\]\n\nNovamente, observe que este predicado é \\(falso\\). Todos os polígonos convexos têm a soma dos ângulos internos igual a \\((y-2) \\cdot 180°\\), onde \\(y\\) é o número de lados do polígono.\n\n\n\n6.4.3 Equivalências Interessantes\nEstudando o quantificador universal encontramos duas equivalências interessantes:\n\\[\\lnot \\forall x P(x) \\leftrightarrow \\exists x \\lnot P(x)\\]\n\\[\\lnot \\exists x P(x) \\leftrightarrow \\forall x \\lnot P(x)\\]\nEssas equivalências são essencialmente as versões quantificadas das Leis de De Morgan. A primeira diz que nem todos os humanos são mortais, isso é equivalente a encontrar algum humano que não é mortal. A segunda diz que para mostrar que nenhum humano é mortal, temos que mostrar que todos os humanos não são mortais.\nPodemos representar uma declaração \\(\\exists x P(x)\\) como uma expressão OU. Por exemplo, \\(\\exists x (x \\in \\mathbb{N} \\land P(x))\\) poderia ser reescrito como:\n\\[P(0) \\lor P(1) \\lor P(2) \\lor P(3) \\lor \\ldots \\]\nLembrando do problema que encontramos quando fizemos isso com o quantificador $$: não podemos representar fórmulas sem fim em Lógica de Primeira Ordem. mas, novamente esta notação, ainda que inválida, nos permite entender melhor o quantificador existencial. Caso o Universo do Discurso seja não infinito, limitado e contável, teremos a Disjunção Existencial uma expressão na lógica de primeiro grau que afirma que existe pelo menos um elemento em um domínio que satisfaz uma ou mais propriedades. A forma geral de uma disjunção existencial é:\n\\[\\exists x (P(x) \\lor Q(x))\\]\nIsso significa que existe pelo menos um \\(x\\) no domínio que satisfaz a propriedade \\(P\\), ou a propriedade \\(Q\\), ou ambas, ou outras propriedades listadas. É uma forma de expressar que pelo menos uma das condições listadas é verdadeira para algum elemento no domínio.\nA expansão de $$ usando $$ destaca que a proposição \\(P(x)\\) é verdadeira se pelo menos um valor de \\(x\\) dentro do universo do discurso atender ao predicado \\(P\\). O que a expansão de exemplo está dizendo é que existe pelo menos um número natural \\(x\\) tal que \\(P(x)\\) é verdadeiro. Não precisamos saber exatamente qual é esse \\(x\\). Apenas que existe um elemento dentro de \\(\\mathbb{N}\\) que atende o predicado.\nO quantificador existencial não especifica o objeto dentro do universo determinado. Esse operador permite fazer afirmações elegantes sobre a existência de objetos com certas características, certas qualidades, ou ainda, certos predicados, sem necessariamente conhecermos exatamente quais são esses objetos.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#dos-predicados-à-linguagem-natural",
    "href": "04-logica-predicativa-e-quantificadores.html#dos-predicados-à-linguagem-natural",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.5 Dos Predicados à Linguagem Natural",
    "text": "6.5 Dos Predicados à Linguagem Natural\nAo ler uma Fórmula Bem Formada contendo quantificadores, a ordem da leitura é geralmente da esquerda para a direita. A interpretação precisa, no entanto, depende diretamente da ordem e do tipo dos quantificadores.\nPor exemplo, \\(\\forall x\\) pode ser lido como “para todo objeto \\(x\\) no universo do discurso (em que este objeto está implícito), o seguinte se mantém”. Já o quantificador \\(\\exists x\\) pode ser lido como “existe um objeto \\(x\\) no universo que satisfaz o seguinte” ou “para algum objeto \\(x\\) no universo, o seguinte se mantém”.\nConverter uma Fórmula Bem Formada em uma sentença fluida em linguagem natural nem sempre é direto, mas é um passo valioso para a compreensão. Vamos considerar \\(U\\) como o universo do discurso (o conjunto de todos os aviões já fabricados) e \\(F(x,y)\\) como o predicado que denota “\\(x\\) voa mais rápido que \\(y\\)”. Analisemos algumas combinações de quantificadores:\n\n\\(\\forall x \\forall y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), e para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação é muito forte. Ela diz que cada avião no universo é mais rápido que todos os aviões no universo (incluindo ele mesmo, a menos que \\(F(x,x)\\) seja definido como falso ou que se adicione \\(x \\neq y\\)). Se o universo tiver mais de um avião, esta afirmação provavelmente será falsa, pois implicaria, por exemplo, que \\(A\\) é mais rápido que \\(B\\) e \\(B\\) é mais rápido que \\(A\\) simultaneamente.\n\n\\(\\exists x \\forall y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) tal que, para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que existe pelo menos um avião que é mais rápido que todos os outros (e, novamente, dependendo da definição de \\(F(x,x)\\), mais rápido que ele mesmo). Em outras palavras, existe um “avião mais rápido absoluto”.\n\n\\(\\forall x \\exists y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que para qualquer avião que escolhermos, podemos encontrar algum avião \\(y\\) que é mais lento que \\(x\\). Se \\(y\\) pode ser igual a \\(x\\), a afirmação é trivialmente verdadeira se \\(F(x,x)\\) for verdadeiro para algum \\(x\\). Se \\(y\\) deve ser diferente de \\(x\\), isso significaria que não existe um “avião mais lento absoluto” (a menos que o universo seja finito e ordenado de forma cíclica, ou que \\(F(x,y)\\) permita que \\(x\\) seja mais rápido que “nada” se \\(y\\) for o mais lento). Uma interpretação comum é que, para cada avião, há outro que ele supera em velocidade.\n\n\\(\\exists x \\exists y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) e existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta é a afirmação mais fraca entre as quatro. Ela simplesmente diz que a relação “voa mais rápido que” não é vazia; ou seja, há pelo menos um par de aviões \\((x,y)\\) em que \\(x\\) é mais rápido que \\(y\\).\n\n\nÉ fundamental perceber que estas quatro sentenças têm significados lógicos distintos e geralmente não expressam o mesmo contexto. A ordem dos quantificadores, especialmente quando misturamos \\(\\forall\\) e \\(\\exists\\), altera drasticamente o significado da afirmação. Por exemplo, \\(\\exists x \\forall y F(x,y)\\) (existe um avião mais rápido que todos) é uma afirmação muito mais forte e diferente de \\(\\forall x \\exists y F(x,y)\\) (para cada avião, existe um mais lento).\nAo traduzir da lógica para a linguagem natural ou vice-versa, a precisão na interpretação da ordem e do tipo dos quantificadores é essencial. A prática leva a uma maior fluidez nesse processo de tradução e compreensão.\n\n6.5.1 Exercícios Resolvidos de Conversão de Linguagem Natural em Expressões Predicativas\nSentença 1: Todo matemático que é professor tem alunos que são brilhantes e interessados.\n\\[\n\\forall x ((\\text{Matemático}(x) \\wedge \\text{Professor}(x)) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Matemático}(x) \\rightarrow (\\text{Professor}(x) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y))))\n\\]\nSentença 2: Alguns engenheiros não são nem ricos nem felizes.\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg (\\text{Rico}(x) \\vee \\text{Feliz}(x)))\\]\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg\\text{Rico}(x) \\wedge \\neg\\text{Feliz}(x))\\]\nSentença 3: Todos os planetas que têm água possuem vida ou têm potencial para vida.\n\\[\n\\forall x (\\text{Planeta}(x) \\wedge \\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x)))\n\\]\n\\[\n\\forall x (\\text{Planeta}(x) \\rightarrow (\\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x))))\n\\]\nSentença 4: Nenhum cientista que é cético acredita em todos os mitos.\n\\[\n\\neg \\exists x (Cientista(x) \\wedge Cético(x) \\wedge \\forall y (Mito(y) \\rightarrow Acredita(x,y)))\n\\]\n\\[\n\\forall x ((\\text{Cientista}(x) \\wedge \\text{Cético}(x)) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Cientista}(x) \\rightarrow (\\text{Cético}(x) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y))))\n\\]\nSentença 5: Alguns filósofos que escrevem sobre ética também leem ou estudam psicologia.\n\\[\n\\exists x (\\text{Filósofo}(x) \\wedge \\text{EscreveSobreÉtica}(x) \\wedge (\\text{LêPsicologia}(x) \\vee \\text{EstudaPsicologia}(x)))\n\\]\nSentença 6: Para todo escritor, existe pelo menos um livro que ele escreveu e que é tanto criticado quanto admirado.\n\\[\n\\forall x (\\text{Escritor}(x) \\rightarrow \\exists y (\\text{Livro}(y) \\wedge \\text{Escreveu}(x, y) \\wedge \\text{Criticado}(y) \\wedge \\text{Admirado}(y)))\n\\]\nSentença 7: Todos os pássaros voam e todos os peixes nadam.\n\\[\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\land \\forall y (Peixe(y) \\rightarrow Nada(y))\\]\nSentença 8: Todos os estudantes estudam ou todos os professores ensinam.\n\\[\\forall x (Estudante(x) \\rightarrow Estuda(x)) \\lor \\forall y (Professor(y) \\rightarrow Ensina(y))\\]\nSentença 9: Todos os cães latem e todos os gatos miam, mas nem todos os animais fazem barulho.\n\\[\\forall x (Cão(x) \\rightarrow Late(x)) \\land \\forall y (Gato(y) \\rightarrow Mia(y)) \\land \\neg \\forall z (Animal(z) \\rightarrow FazBarulho(z))\\]\nSentença 10: Se todos os carros são vermelhos, então todos os caminhões são azuis.\n\\[\\forall x (Carro(x) \\rightarrow Vermelho(x)) \\rightarrow \\forall y (Caminhão(y) \\rightarrow Azul(y))\\]\nSentença 11: Todos os planetas orbitam uma estrela e todos os asteroides orbitam o sol.\n\\[\\forall x (Planeta(x) \\rightarrow OrbitaEstrela(x)) \\land \\forall y (Asteroide(y) \\rightarrow OrbitaSol(y))\\]\nSentença 12: Alguns pássaros não voam.\n\\[\\exists x (Pássaro(x) \\land \\neg Voa(x))\\]\nSentença 13: Existe pelo menos um estudante que não estuda.\n\\[\\exists x (Estudante(x) \\land \\neg Estuda(x))\\]\n\\[\\exists x (Estudante(x) \\land \\neg Estuda(x))\\]\nSentença 14: Há algum animal que não faz barulho.\n\\[\\exists x (Animal(x) \\land \\neg FazBarulho(x))\\]\nSentença 15: Existe um carro que não é vermelho.\n\\[\\exists x (Carro(x) \\land \\neg Vermelho(x))\\]\n\\[\\exists x (Carro(x) \\land \\neg Vermelho(x))\\]\nSentença 16: Há um planeta que não orbita uma estrela.\n$$\\exists x (Planeta(x) \\land \\neg \\exists y (Estrela(y) \\land Orbita(x, y)))$$\n\nOu \n\n$$\\exists x (Planeta(x) \\land \\forall y (Estrela(y) \\rightarrow \\neg Orbita(x, y)))$$ (Existe um planeta $x$ tal que, para toda estrela $y$, $x$ não a orbita).\nSentença 17: _Todos os pássaros voam, mas existe um animal que não voa.\n$$\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\land \\exists y (Animal(y) \\land \\neg Voa(y))$$\nSentença 18: Para cada estudante, existe um professor que o ensina.\n$$\\forall x (Estudante(x) \\rightarrow \\exists y (Professor(y) \\land Ensina(y, x)))$$\nSentença 19: Existe um cão que late para todos os gatos.\n$$\\exists x (Cão(x) \\land \\forall y (Gato(y) \\rightarrow Late(x, y)))$$\nSentença 20: Para cada carro vermelho, existe um caminhão azul.\n$$\\forall x (Carro(x) \\land Vermelho(x) \\rightarrow \\exists y (Caminhão(y) \\land Azul(y)))$$\n\n$$\\forall x (Carro(x) \\land Vermelho(x) \\rightarrow \\exists y (Caminhão(y) \\land Azul(y)))$$\nSentença 21: Todos os planetas orbitam uma estrela, e existe um asteroide que orbita o sol.\n$$(\\forall x (Planeta(x) \\rightarrow \\exists y (Estrela(y) \\land Orbita(x, y)))) \\land (\\exists z (Asteroide(z) \\land Orbita(z, Sol)))$$\n\n\n6.5.2 Exercícios Resolvidos de Conversão de Expressões Predicativas em Linguagem Natural\n1. Fórmula Lógica: \\(\\forall x (\\text{Humano}(x) \\rightarrow (\\text{Mortal}(x) \\wedge \\text{Racional}(x)))\\)\n\nPredicados:\n\n\\(Humano(x)\\): \\(x\\) é um humano.\n\\(Mortal(x)\\): \\(x\\) é mortal.\n\\(Racional(x)\\): \\(x\\) é racional.\n\nSentença em Português: Todo humano é mortal e racional.\n\n2. Fórmula Lógica:\\(\\exists y (\\text{Livro}(y) \\wedge (\\text{Interessante}(y) \\vee \\text{Complicado}(y)))\\)\n\nPredicados:\n\n\\(Livro(y)\\): y é um livro.\n\\(Interessante(y)\\): y é interessante.\n\\(Complicado(y)\\): y é complicado.\n\nSentença em Português: Existe pelo menos um livro que é interessante ou complicado.\n\n3. Fórmula Lógica:\\(\\forall x \\forall y (\\text{Amigos}(x, y) \\rightarrow (\\text{Confiável}(x) \\wedge \\text{Honra}(x)))\\)\n\nPredicados:\n\n\\(Amigos(x, y)\\): x é amigo de y.\n\\(Confiável(x)\\): x é confiável.\n\\(Honra(x, y)\\): x honra y.\n\nSentença em Português: Todo amigo de alguém é confiável e honra o amigo.\n\n4. Fórmula Lógica:\\(\\exists x \\exists y (\\text{Animal}(x) \\wedge \\text{Planta}(y) \\wedge \\text{Convive}(x, y))\\)\n\nPredicados:\n\n\\(Animal(x)\\): x é um animal.\n\\(Planta(y)\\): y é uma planta.\n\\(Convive(x, y)\\): x e y convivem.\n\nSentença em Português: Existe pelo menos um animal e uma planta que convivem no mesmo ambiente.\n\n5. Fórmula Lógica:\\(\\forall x \\exists y (\\text{Professor}(x) \\rightarrow (\\text{Disciplina}(y) \\wedge \\text{Leciona}(x, y)))\\)\n\nPredicados:\n\n\\(Professor(x)\\): x é um professor.\n\\(Disciplina(y)\\): y é uma disciplina.\n\\(Leciona(x, y)\\): x leciona y.\n\nSentença em Português: Para todo professor, existe pelo menos uma disciplina que ele leciona.\n\n6. Fórmula Lógica:\\(\\exists x \\forall y (\\text{Músico}(x) \\wedge (\\text{Instrumento}(y) \\rightarrow \\text{Toca}(x, y)))\\)\n\nPredicados:\n\n\\(Músico(x)\\): x é um músico.\n\\(Instrumento(y)\\): y é um instrumento.\n\\(Toca(x, y)\\): x toca y.\n\nSentença em Português: Existe pelo menos um músico que, se algo é um instrumento, então ele toca esse instrumento.\n\n7. Fórmula Lógica: \\(\\forall x (Gato(x) \\rightarrow (Peludo(x) \\land Dorminhoco(x)))\\)\n\\[\\text{Todo gato é peludo e dorminhoco.}\\]\n8. Fórmula Lógica:\\(\\forall y (Árvore(y) \\rightarrow (Verde(y) \\land Grande(y)))\\)\n\\[\\text{Toda árvore é verde e grande.}\\]\n9. Fórmula Lógica: \\((\\forall x (Cidade(x) \\rightarrow Populosa(x))) \\rightarrow (\\forall y (País(y) \\rightarrow Populoso(y)))\\)\n\\[\\text{Se toda cidade é populosa, então todo país é populoso.}\\]\n10. Fórmula Lógica: \\(\\forall x (Criança(x) \\rightarrow (Inocente(x) \\land Curiosa(x))) \\land \\neg \\exists y (Adulto(y) \\land (Inocente(y) \\land Curioso(y)))\\)\n\\[\\text{Toda criança é inocente e curiosa, e não existe um adulto que seja inocente e curioso.}\\]\n11. Fórmula Lógica: \\(\\forall x (Ave(x) \\rightarrow Voa(x)) \\land \\forall y (Peixe(y) \\rightarrow Nada(y))\\)\n\\[\\text{Toda ave voa e todo peixe nada.}\\]\n12. Fórmula Lógica: \\(\\exists x (Pessoa(x) \\land Feliz(x))\\)\n\\[\\text{Existe uma pessoa que é feliz.}\\]\n13. Fórmula Lógica: \\(\\exists y (Livro(y) \\land Interessante(y) \\land \\neg Longo(y))\\)\n\\[\\text{Há um livro que é interessante e não é longo.}\\]\n14. Fórmula Lógica: \\(\\exists x (Estudante(x) \\land (\\forall y (Disciplina(y) \\rightarrow Gosta(x, y))))\\)\n\\[\\text{Existe um estudante que gosta de todas as disciplinas.}\\]\n15. Fórmula Lógica: \\(\\exists x (Carro(x) \\land Rápido(x)) \\land \\exists y (Carro(y) \\land \\neg Rápido(y))\\)\n\\[\\text{Existe um carro que é rápido, e existe um carro que não é rápido.}\\]\n16. Fórmula Lógica: \\(\\neg \\exists x (Político(x) \\land Honesto(x))\\)\n$$\\text{Não existe um político que seja honesto.}$$\n17. Fórmula Lógica: \\(\\forall x (Cachorro(x) \\rightarrow (\\exists y (Pessoa(y) \\land Dono(y, x))))\\)\n$$\\text{Todo cachorro tem uma pessoa que é seu dono.}$$\n18. Fórmula Lógica: \\(\\exists x (Música(x) \\land (\\forall y (Pessoa(y) \\rightarrow Gosta(y, x))))\\)\n$$\\text{Existe uma música que todas as pessoas gostam.}$$\n19. Fórmula Lógica: \\(\\forall x (Estudante(x) \\rightarrow (\\exists y (Professor(y) \\land Ensina(y, x))))\\)\n$$\\text{Para todo estudante, existe um professor que o ensina.}$$\n20. Fórmula Lógica: \\((\\exists x (Médico(x) \\land Competente(x))) \\land (\\forall y (Médico(y) \\rightarrow Ocupado(y)))\\)\n$$\\text{Existe um médico que é competente, e todo médico é ocupado.}$$\n21. Fórmula Lógica: \\[(\\forall x (Artista(x) \\rightarrow Criativo(x))) \\rightarrow (\\exists y (Pintor(y) \\land Criativo(y)))\\]\n$$\\text{Se todo artista é criativo, então existe um pintor que é criativo.}$$",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#ordem-de-aplicação-dos-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#ordem-de-aplicação-dos-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.6 Ordem de Aplicação dos Quantificadores",
    "text": "6.6 Ordem de Aplicação dos Quantificadores\nQuando mais de uma variável é quantificada em uma Fórmula Bem Formada como \\(\\forall y\\forall x P(x,y)\\), elas são aplicadas da esquerda para a direita. Assim, \\(\\forall y\\forall x P(x,y)\\) se lê para todo \\(y\\), para todo \\(x\\), \\(P(x,y)\\) se mantém.\nAs posições dos mesmos tipos de quantificadores podem ser trocadas sem afetar o valor lógico, desde que não haja quantificadores do outro tipo entre os que serão trocados.\nPor exemplo, \\(\\forall x\\forall y\\forall z P(x,y,z)\\) é equivalente a \\(\\forall y\\forall x\\forall z P(x,y,z)\\), \\(\\forall z\\forall y\\forall x P(x,y,z)\\). O mesmo vale para o quantificador existencial.\nNo entanto, as posições de quantificadores de tipos diferentes não podem ser trocadas. Por exemplo, \\(\\forall x\\exists y P(x,y)\\) não é equivalente A\\(\\exists y\\forall x P(x,y)\\). Por exemplo, seja \\(P(x,y)\\) representando \\(x &lt; y\\) Para o conjunto dos números como universo. Então, \\(\\forall x\\exists y P(x,y)\\) se lê para todo número \\(x\\), existe um número \\(y\\) que é maior que \\(x\\), o que é verdadeiro, enquanto \\(\\exists y\\forall x P(x,y)\\) se lê existe um número que é maior que todo (qualquer) número, o que não é verdadeiro.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#negação-dos-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#negação-dos-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.7 Negação dos Quantificadores",
    "text": "6.7 Negação dos Quantificadores\nExiste uma equivalência entre as negações dos quantificadores. De tal forma que:\n\nNegação do Quantificador Universal ($$): A negação de uma afirmação universal significa que existe pelo menos um caso no Universo do Discurso em que a afirmação não é verdadeira. Isso pode ser expresso pela seguinte equivalência:\n\\[\\neg \\forall x \\, P(x) \\equiv \\exists x \\, \\neg P(x)\\]\nEm linguagem natural podemos entender como: negar que para todos os \\(x\\), \\(P(x)\\) é verdadeiro é equivalente a afirmar que existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\nNegação do Quantificador Existencial ( $$ ): A negação de uma afirmação existencial significa que a afirmação não é verdadeira para nenhum caso no Universo do Discurso. Isso pode ser expresso pela seguinte equivalência:\n\n\\[\\neg \\exists x \\, P(x) \\equiv \\forall x \\, \\neg P(x)\\]\nOu seja, negar que existe algum \\(x\\) tal que \\(P(x)\\) é verdadeiro é equivalente a afirmar que para todos os \\(x\\), \\(P(x)\\) não é verdadeiro.\nVamos tentar entender estas negações. Considere as expressões \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Essas fórmulas se aplicam a qualquer predicado \\(P\\), e possuem o mesmo valor de verdade para qualquer \\(P\\).\nNa Lógica Proposicional, poderíamos simplesmente verificar isso com uma tabela verdade, mas aqui, não podemos. Não existem proposições, conectadas por $$, $$, para construir uma tabela e não é possível determinar o valor verdade de forma genérica para uma determinada variável.\nVamos tentar entender isso com linguagem natural: afirmar que \\(\\neg (\\forall x P(x))\\) é verdadeiro significa que não é verdade que \\(P(x)\\) se aplica a todas as possíveis entidades \\(x\\). Deve haver alguma entidade \\(A\\) Para a qual\\(P(a)\\) é falso. Como \\(P(a)\\) é falso, \\(\\neg P(a)\\) é verdadeiro. Isso significa que \\(\\exists x (\\neg P(x))\\) é verdadeiro. Portanto, a verdade de \\(\\neg (\\forall x P(x))\\)implica a verdade de \\(\\exists x (\\neg P(x))\\).\nSe \\(\\neg (\\forall x P(x))\\) é falso, então \\(\\forall x P(x)\\) é verdadeiro. Como \\(P(x)\\) é verdadeiro para todos os \\(x\\), \\(\\neg P(x)\\) é falso para todos os \\(x\\). Logo, \\(\\exists x (\\neg P(x))\\) é falso.\nOs valores de verdade de \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\) são os mesmos. Como isso é verdadeiro para qualquer predicado \\(P\\), essas duas fórmulas são logicamente equivalentes, e podemos escrever \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\).\nMuita lógica? Que tal se tentarmos novamente, usando um pouco mais de linguagem natural. Considere as expressões lógicas \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Para ilustrar essas fórmulas, vamos usar um exemplo com um predicado \\(P(x)\\) que se aplica a uma entidade \\(x\\) se \\(x\\) é feliz.\nA expressão \\(\\forall x P(x)\\) significa que todos são felizes. A negação dessa afirmação, \\(\\neg (\\forall x P(x))\\), equivale logicamente a \\(\\exists x (\\neg P(x))\\), ou seja, existe pelo menos um indivíduo que não é feliz.\nA expressão \\(\\exists x (\\neg P(x))\\) significa que existe alguém que não está feliz. Você pode ver que isso é apenas outra forma de expressar a ideia contida em \\(\\neg (\\forall x P(x))\\).\nA afirmação de que não é verdade que todos estão felizes implica que deve haver alguém que não está feliz. Se a primeira afirmação é falsa (ou seja, todos estão felizes), então a segunda afirmação também deve ser falsa.\nPortanto, as duas fórmulas têm o mesmo valor verdade. Elas são logicamente equivalentes e podem ser representadas como \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\). Esta equivalência reflete uma relação profunda e intuitiva em nosso entendimento de declarações sobre entidades em nosso mundo.\n\n\n\nExpressão\nEquivalência\n\n\n\n\n\\(\\forall x P(x)\\)\n\\(\\neg \\exists x \\neg P(x)\\)\n\n\n\\(\\exists x \\, P(x)\\)\n\\(\\neg \\forall x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\forall x \\, P(x)\\)\n\\(\\exists x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\exists x \\, P(x)\\)\n\\(\\forall x \\, \\neg P(x)\\)\n\n\n\nTabela 5 - Equivalências entre Quantificadores.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#regras-de-inferência-usando-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#regras-de-inferência-usando-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.8 Regras de Inferência usando Quantificadores",
    "text": "6.8 Regras de Inferência usando Quantificadores\nAs regras de inferência com quantificadores lidam especificamente com as proposições que envolvem quantificadores. Estas regras nos permitem fazer generalizações ou especificações, transformando proposições universais em existenciais, e vice-versa. Compreender essas regras é essencial para aprofundar o entendimento da estrutura da lógica, o que nos permite analisar e construir argumentos mais complexos de forma precisa e coerente.\nNos próximos tópicos, exploraremos essas regras em detalhes, observando como elas interagem com os quantificadores universal e existencial.\n\n6.8.1 Repetição\nA regra de Repetição permite repetir uma afirmação. Esta regra é útil para propagar premissas em uma prova formal.\n\\[F\\]\n\\[\n\\begin{aligned}\n&F\\\\\n\\hline\n&F\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: o céu está azul.\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações da Repetição:\n\nReafirmar premissas em provas longas. Por exemplo:\n\nProposição: todos os homens, \\(H(x)\\), são mortais, \\(M(x)\\).\nConclusão: logo, todos os homens são mortais.\n\n\n\\[\n\\begin{aligned}\n&\\forall x(H(x) \\rightarrow M(x))\\\\\n\\hline\n&\\forall x(H(x) \\rightarrow M(x))\n\\end{aligned}\n\\]\n\nIntroduzir suposições em provas indiretas. Por exemplo:\n\nProposição: suponha que \\((2 + 2 = 5)\\).\nConclusão: logo, (2 + 2 = 5)$.\n\n\n\\[\n\\begin{aligned}\n&2 + 2 = 5\\\\\n\\hline\n&2 + 2 = 5\n\\end{aligned}\n\\]\n\nReafirmar fórmulas quantificadas. Por exemplo:\n\nProposição: para todo \\(x\\), \\(x + 0 = x\\).\nConclusão: logo, para todo \\(x\\), \\(x + 0 = x\\).\n\n\n\\[\n\\begin{aligned}\n&\\forall x(x + 0 = x)\\\\\n\\hline\n&\\forall x(x + 0 = x)\n\\end{aligned}\n\\]\n\n\n6.8.2 Instanciação Universal\nA regra de Instanciação Universal permite substituir a variável em uma afirmação universalmente quantificada por um termo concreto. Esta regra nos permite derivar casos particulares a partir de afirmações gerais.\n\\[\\forall x P(x)\\]\n\\[\\begin{aligned}\n&\\forall x P(x)\\\\\n\\hline\n&P(a)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: todos os humanos são mortais.\nConclusão: logo, Sócrates é mortal. Assumindo que Sócrates é humano.\n\nExemplo completo de aplicação:\n\nPremissa 1: todos os mamíferos respiram ar: \\(\\forall x(M(x) \\rightarrow R(x))\\);\nPremissa 2: a baleia é um mamífero: \\(M(b)\\);\nAplicação da Instanciação Universal à Premissa 1: \\(M(b) \\rightarrow R(b)\\);\nAplicação de Modus Ponens:\n\n\\[\\begin{aligned}\n&M(b) \\rightarrow R(b)\\\\\n&M(b)\\\\\n\\hline\n&R(b)\n\\end{aligned}\n\\]\n\nConclusão: logo, a baleia respira ar: \\(R(b)\\)\n\nAlgumas aplicações da Instanciação Universal:\n\nAplicar regras e princípios gerais. Por exemplo:\n\nProposição: todos os triângulos têm 180 graus internos: \\(\\forall t(T(t) \\rightarrow 180^\\circ(t))\\);\nPremissa adicional: ABC é um triângulo: \\(T(\\text{Triângulo }ABC)\\);\nAplicação da Instanciação Universal: \\(T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\);\nAplicação de Modus Ponens:\n\n\n\\[\\begin{aligned}\n&T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\\\\n&T(\\text{Triângulo }ABC)\\\\\n\\hline\n&180^\\circ(\\text{Triângulo }ABC)\n\\end{aligned}\n\\]\n\nConclusão: logo, o triângulo \\(ABC\\) tem 180 graus.\nTestar propriedades em membros de conjuntos. Por exemplo:\n\nProposição: todo inteiro é maior que seu antecessor: \\(\\forall x (\\mathbb{Z}(x) \\rightarrow (x &gt; x-1))\\);\nPremissa adicional: 5 é um inteiro: \\(\\mathbb{Z}(5)\\);\nAplicação da Instanciação Universal: \\(\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\);\nAplicação de Modus Ponens:\n\n\n\\[\\begin{aligned}\n&\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\\\\n&\\mathbb{Z}(5)\\\\\n\\hline\n&5 &gt; 4\n\\end{aligned}\n\\]\n\nConclusão: logo, \\(5\\) é maior que \\(4\\).\n\n\n\n6.8.3 Generalização Existencial\nA regra de Generalização Existencial permite inferir que algo existe a partir de uma afirmação concreta. Esta regra nos permite generalizar de exemplos específicos para a existência geral.\n\\[P(a)\\]\n\\[\n\\begin{aligned}\nP(a)\\\\\n\\hline\n\\exists x P(x)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: Rex é um cachorro.\nConclusão: logo, existe pelo menos um cachorro.\n\nAlgumas aplicações da Generalização Existencial:\n\nInferir existência a partir de exemplos concretos. Por exemplo:\n\nProposição: o urânio-235 é radioativo.\nConclusão: logo, existe pelo menos um elemento químico radioativo.\n\n\n\\[\n\\begin{aligned}\n&R(u_{235})\\\\\n\\hline\n&\\exists x R(x)\n\\end{aligned}\n\\]\n\nConcluir que uma propriedade não é vazia. Por exemplo:\n\nProposição: $7 $ é um número primo.\nConclusão: logo, existe pelo menos um número primo.\n\n\n\\[\n\\begin{aligned}\n&P(7)\\\\\n\\hline\n&\\exists x P(x)\n\\end{aligned}\n\\]\n\nInferir a existência de soluções para problemas. Por exemplo:\n\nProposição: $x = 2 $ satisfaz a equação $x + 3 = 5 $.\nConclusão: logo, existe pelo menos uma solução para essa equação.\n\n\n\\[\n\\begin{aligned}\n&S(2)\\\\\n\\hline\n&\\exists x S(x)\n\\end{aligned}\n\\]\n\n\n6.8.4 Instanciação Existencial\nA regra de Instanciação Existencial permite introduzir um novo termo como instância de uma variável existencialmente quantificada. Esta regra nos permite derivar exemplos de afirmações existenciais.\n\\[\\exists x P(x)\\]\n\\[\n\\begin{aligned}\n&\\exists x P(x)\\\\\n\\hline\n&P(b)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: existe um cachorro com rabo curto.\nConclusão: logo, algum cachorro específico (que podemos chamar de \\(c\\)) tem rabo curto.\n\nAlgumas aplicações da Instanciação Existencial:\n\nDerivar exemplos de existência previamente estabelecida. Por exemplo:\n\nProposição: existem estrelas, $ e $, maiores, $M $, que o Sol, $s $.\nConclusão: logo, existe uma estrela específica, \\(c\\), que é maior que o Sol.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (e (x) \\land M(x, s))\\\\\n\\hline\n&e(c) \\land M(c, s)\n\\end{aligned}\n\\]\n\nConstruir modelos satisfatíveis para predicados existenciais. Por exemplo:\n\nProposição: existem pessoas mais velhas que \\(25\\)Anos.\nConclusão: logo, John tem 30 anos.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (P(x) \\land V(x, 25))\\\\\n\\hline\n&P(j) \\land V(j, 30)\n\\end{aligned}\n\\]\n\nProvar que conjuntos não estão vazios. Por exemplo:\n\nProposição: existem números reais maiores que \\(2\\).\nConclusão: logo, \\(5\\) é um número real maior que \\(2\\).\n\n\n\\[\n\\begin{aligned}\n&\\exists x (R(x) \\land M(x, 2))\\\\\n\\hline\n&R(5) \\land M(5, 2)\n\\end{aligned}\n\\]",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#exercícios-de-conexão-com-o-prolog",
    "href": "04-logica-predicativa-e-quantificadores.html#exercícios-de-conexão-com-o-prolog",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.9 Exercícios de Conexão com o Prolog",
    "text": "6.9 Exercícios de Conexão com o Prolog\nEstas questões de Lógica Predicativa estabelecem os fundamentos conceituais essenciais para Prolog:\n\nPredicados se tornam fatos e cabeças de regras\nQuantificadores universais correspondem a variáveis em regras\n\nQuantificadores existenciais correspondem a consultas e instanciações\nImplicações se tornam regras (:-)\nConjunções se tornam múltiplas condições nas regras\nNegação se torna negação por falha (\\+)\n\nA modelagem em Lógica de Predicados fornece a base teórica que o Prolog implementa através de seu mecanismo de resolução e unificação.\nQuestão 1: Relações em um Sistema Acadêmico\nConsidere um “mundo” acadêmico com alunos e cursos. Use os seguintes predicados:\n\n\\(A(x)\\): “x é um aluno”\n\\(C(x)\\): “x é um curso”\n\n\\(M(x,y)\\): “o aluno x está matriculado no curso y”\n\nTraduza as seguintes sentenças para fórmulas da lógica de predicados:\n\nExiste pelo menos um aluno\nNem todo aluno está matriculado em algum curso\nTodo aluno está matriculado em pelo menos um curso\nExiste um curso no qual nenhum aluno está matriculado\nExiste um aluno que está matriculado em todos os cursos\n\nQuestão 2: O Escopo dos Quantificadores\nA ordem dos quantificadores altera drasticamente o significado de uma sentença. Usando os predicados \\(Pessoa(x)\\) e \\(Ama(x,y)\\) (“x ama y”), traduza e explique a diferença semântica entre as duas sentenças abaixo:\n\n\\(\\forall x \\exists y (Pessoa(x) \\to (Pessoa(y) \\land Ama(x,y)))\\)\n\\(\\exists y \\forall x (Pessoa(x) \\to (Pessoa(y) \\land Ama(x,y)))\\)\n\nQual das duas sentenças descreve melhor o conceito de “amor fraternal universal” e qual descreve a existência de uma “figura universalmente amada por todos”?\nQuestão 3: O Paradoxo do Barbeiro\nEm uma cidade, há um único barbeiro. A regra que define seu trabalho é: “O barbeiro barbeia todos os homens da cidade que não se barbeiam a si mesmos, e apenas esses”.\nUse o predicado \\(Barbeia(x,y)\\) para representar “x barbeia y”. Seja \\(b\\) a constante que representa o barbeiro.\n\nTraduza a regra para uma fórmula da lógica de predicados\nMostre, através de dedução lógica, que essa regra leva a uma contradição ao se perguntar: “Quem barbeia o barbeiro?” (ou seja, ao analisar a proposição \\(Barbeia(b,b)\\))\n\nQuestão 4: Especificação de um Sistema de Arquivos\nModele as permissões de um sistema de arquivos com os predicados:\n\n\\(Admin(x)\\): “x é um administrador”\n\\(Arquivo(y)\\): “y é um arquivo”\n\\(PodeAcessar(x,y)\\): “x pode acessar y”\n\nA política de segurança do sistema é: “Qualquer administrador pode acessar todos os arquivos. Ninguém que não seja administrador pode acessar algum arquivo”.\n\nTraduza a política para um conjunto de fórmulas lógicas\nSuponha os seguintes fatos: \\(Admin(ana)\\) e \\(\\neg Admin(beto)\\). O que podemos concluir sobre \\(PodeAcessar(ana, relatorio.doc)\\) e \\(PodeAcessar(beto, relatorio.doc)\\)?\n\nQuestão 5: Negando Afirmações Universais\nNegar sentenças com quantificadores é uma habilidade fundamental para entender a falha em Prolog (negação por falha). Forneça a negação formal das seguintes sentenças, movendo o símbolo de negação (\\(\\neg\\)) o mais para dentro possível da fórmula.\n\n“Todos os programas de computador têm pelo menos um bug”\n\nUse: \\(Programa(x)\\), \\(Bug(y)\\), \\(Tem(x,y)\\)\n\n“Existe um político que é honesto com todos os seus eleitores”\n\nUse: \\(Politico(x)\\), \\(Eleitor(y,x)\\) (“y é eleitor de x”), \\(HonestoCom(x,y)\\)\n\n\nQuestão 6: Mundo dos Blocos (Planejamento em IA) - Corrigida\nConsidere um cenário simples de IA com os predicados:\n\n\\(Bloco(x)\\): “x é um bloco”\n\\(EmCima(x,y)\\): “o bloco x está em cima do bloco y”\n\\(Azul(x)\\): “o bloco x é azul”\n\\(Verde(x)\\): “o bloco x é verde”\n\n\\(NaMesa(x)\\): “o bloco x está sobre a mesa”\n\nDados os seguintes fatos e regras sobre o estado do mundo:\n\nExiste um bloco verde em cima de um bloco azul\nTodos os blocos que estão sobre a mesa são azuis\nNenhum bloco pode estar em cima de outro bloco e na mesa ao mesmo tempo\nPremissa adicional: Nenhum bloco pode ser verde e azul simultaneamente\n\nProve que “Existe um bloco que não é verde”.\nQuestão 7: Propriedades dos Números Inteiros (Corrigida)\nSeja o domínio de discurso o conjunto dos números inteiros (\\(\\mathbb{Z}\\)). Use os predicados \\(Par(x)\\), \\(Impar(x)\\) e os símbolos usuais da matemática. Traduza as seguintes sentenças para a lógica de predicados:\n\nTodo número par é maior que algum número ímpar\nNão existe um número inteiro que seja o maior de todos\n\nA soma de quaisquer dois números pares é par\n\nQuestão 8: Dedução Lógica com Instanciação\nConsidere as seguintes premissas:\n\nTodos os leões são mamíferos: \\(\\forall x (Leao(x) \\to Mamifero(x))\\)\nAlguns leões vivem na savana: \\(\\exists x (Leao(x) \\land ViveNaSavana(x))\\)\n\nUsando as regras de dedução da lógica de predicados (Instanciação Universal, Instanciação Existencial, Modus Ponens, etc.), prove formalmente que “Alguns mamíferos vivem na savana”: \\(\\exists x (Mamifero(x) \\land ViveNaSavana(x))\\).\nQuestão 9: Consulta a uma Base de Dados Relacional (Corrigida)\nImagine uma base de dados com as tabelas Funcionario(ID, Nome, DeptoID) e Departamento(ID, NomeDepto). Modele este esquema com os predicados:\n\n\\(Func(x,n,d)\\): “o funcionário com ID x tem nome n e trabalha no departamento d”\n\\(Depto(d,m)\\): “o departamento com ID d tem nome m”\n\nFormule a seguinte consulta em lógica de predicados: “Encontre os nomes de todos os funcionários que trabalham no departamento de ‘Vendas’”.\nQuestão 10: Hierarquia Organizacional (Corrigida)\nModele a estrutura de uma empresa com os predicados:\n\n\\(Funcionario(x)\\): “x é um funcionário”\n\\(Gerente(x,y)\\): “x é gerente de y”\n\n\\(Salario(x,s)\\): “o salário de x é s”\n\nTraduza as seguintes regras de negócio para a lógica de predicados:\n\nTodo funcionário tem exatamente um gerente\nNenhum funcionário pode ser gerente de si mesmo\nTodo gerente é também um funcionário\nExiste um funcionário que não é gerente de ninguém",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html",
    "href": "05-formas-normais-e-skolemizacao.html",
    "title": "7  Formas Normais",
    "section": "",
    "text": "7.0.1 Forma Normal Negativa (FNN)\nA Forma Normal Negativa é uma representação canônica de fórmulas lógicas em que as negações são aplicadas apenas aos átomos da fórmula e não a expressões mais complexas. Em outras palavras, a negação está empurrada para dentro o máximo possível. A FNN é útil por sua simplicidade e é frequentemente um passo intermediário na conversão para outras formas normais.\nUma fórmula está na Forma Normal Negativa se:\nConverter uma fórmula para a FNN envolve os seguintes passos:",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#skolemização",
    "href": "05-formas-normais-e-skolemizacao.html#skolemização",
    "title": "7  Formas Normais",
    "section": "7.1 Skolemização",
    "text": "7.1 Skolemização\nA Skolemização é uma técnica usada na Lógica de Primeira Ordem para eliminar quantificadores existenciais em fórmulas. Consiste em substituir as variáveis existenciais por Constantes ou Funções Skolem. Considere a fórmula a seguir com um quantificador universal e um existencial:\n\\[\\forall x \\exists y P(x,y)\\]\nAo aplicar a Skolemização, a variável existencial \\(y\\) é substituída por uma Função de Skolem \\(f(x)\\):\n\\[P(x,f(x))\\]\nPara uma fórmula com dois quantificadores universais e dois existenciais:\n\\[\\forall x \\forall z \\exists y \\exists w R(x,y,z,w)\\]\nA Skolemização resultará em:\n\\[\\forall x \\forall z R(x,f(x),z,g(x,z))\\]\n\\(f(x)\\) e $ g(x,z)$ são Funções Skolem introduzidas para substituir as variáveis existenciais \\(y\\) e $w $ respectivamente. A escolha entre usar uma Constante Skolem ou uma Função Skolem durante a Skolemização depende do escopo dos quantificadores na fórmula original. Aqui estão as regras e passos para realizar a Skolemização de forma mais explicativa:\nPasso 1: Identificar os Quantificadores Existenciais: comece identificando os quantificadores existenciais na fórmula.\nPasso 2: Determinar se a Variável Existencial Depende de Variáveis Universais: para cada variável ligada a um quantificador existencial, determinamos se ela depende ou não de alguma variável universal. Isso significa verificar se existem quantificadores universais que dominam a variável existencial. Se a variável existencial não depende de variáveis universais, usamos uma Constante de Skolem. Caso contrário, usamos uma Função de Skolem que leva como parâmetros as variáveis universais que a dominam.\nPasso 3: Substituir as Variáveis Existenciais: agora, substituímos todas as variáveis existenciais na fórmula original de acordo com as decisões tomadas no Passo 2. Se usarmos Constantes de Skolem, substituímos as variáveis existenciais diretamente pelas constantes. Se usarmos Funções de Skolem, substituímos as variáveis existenciais pelas funções de Skolem aplicadas às variáveis universais apropriadas.\nExemplo 1: considere a Fórmula Bem Formada dada por: \\(\\forall x \\exists y \\ P(x,y)\\)\n\nIdentificamos o quantificador existencial que introduz a variável \\(y\\).\nA variável \\(y\\) não depende de nenhuma variável universal, então usamos uma Constante de Skolem, digamos \\(a\\). A fórmula se torna:\n\\[\\forall x \\ P(x,a)\\]\n\nExemplo 2: considere a fórmula original: \\(\\forall x \\forall z \\exists y \\ Q(x,y,z)\\)\n\nIdentificamos o quantificador existencial que introduz a variável \\(y\\).\nA variável \\(y\\) depende de duas variáveis universais, \\(x\\) e \\(z\\). Portanto, usamos uma Função de Skolem, digamos \\(f(x,z)\\). A fórmula se torna:\n\\[\\forall x \\forall z \\ Q(x,f(x,z),z)\\]\n\nSubstituímos \\(y\\) por \\(f(x,z)\\), que é uma função que depende das variáveis universais \\(x\\) e \\(z\\).\nEm resumo, a Skolemização simplifica fórmulas quantificadas, eliminando quantificadores existenciais e substituindo variáveis por Constantes ou Funções de Skolem, dependendo de sua relação com quantificadores universais. Isso auxilia na conversão de fórmulas quantificadas para a Forma Normal Conjuntiva e na simplificação da lógica.\n\n7.1.1 Exemplos de conversão em formas normais, conjuntiva e disjuntiva\n\nTodos os alunos estudam ou alguns professores ensinam matemática\n\nLógica de Primeiro Grau:\n\\[\\forall x(\\text{Aluno}(x) \\rightarrow \\text{Estuda}(x)) \\lor \\exists y(\\text{Professor}(y) \\land \\text{EnsinaMatemática}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Aluno}(x) \\lor \\text{Estuda}(x)\\]\nAdicionando a disjunção existencial:\n\\[(\\neg \\text{Aluno}(x) \\lor \\text{Estuda}(x)) \\land (\\text{Professor}(y) \\land \\text{EnsinaMatemática}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando o consequente do implicador:\n\\[\\text{Aluno}(x) \\land \\neg \\text{Estuda}(x)\\]\nAdicionando a conjunção existencial negada:\n\\[(\\text{Aluno}(x) \\land \\neg \\text{Estuda}(x)) \\lor (\\neg \\text{Professor}(y) \\lor \\neg \\text{EnsinaMatemática}(y))\\]\n\n\nAlgum aluno estuda e todo professor ensina\n\nLógica de Primeiro Grau:\n\\[\\exists x(\\text{Aluno}(x) \\land \\text{Estuda}(x)) \\land \\forall y(\\text{Professor}(y) \\rightarrow \\text{Ensina}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Professor}(y) \\lor \\text{Ensina}(y)\\]\nAdicionando a conjunção existencial:\n\\[(\\text{Aluno}(x) \\land \\text{Estuda}(x)) \\land (\\neg \\text{Professor}(y) \\lor \\text{Ensina}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando a conjunção existencial:\n\\[\\neg \\text{Aluno}(x) \\lor \\neg \\text{Estuda}(x)\\]\nAdicionando a conjunção negada do consequente do implicador:\n\\[(\\neg \\text{Aluno}(x) \\lor \\neg \\text{Estuda}(x)) \\lor (\\text{Professor}(y) \\land \\neg \\text{Ensina}(y))\\]\n\n\nTodo estudante é inteligente ou algum professor é sábio\n\nLógica de Primeiro Grau:\n\\[\\forall x(\\text{Estudante}(x) \\rightarrow \\text{Inteligente}(x)) \\lor \\exists y(\\text{Professor}(y) \\land \\text{Sábio}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Estudante}(x) \\lor \\text{Inteligente}(x)\\]\nAdicionando a disjunção existencial:\n\\[(\\neg \\text{Estudante}(x) \\lor \\text{Inteligente}(x)) \\land (\\text{Professor}(y) \\land \\text{Sábio}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando o consequente do implicador:\n\\[\\text{Estudante}(x) \\land \\neg \\text{Inteligente}(x)\\]\nAdicionando a conjunção existencial negada:\n\\[(\\text{Estudante}(x) \\land \\neg \\text{Inteligente}(x)) \\lor (\\neg \\text{Professor}(y) \\lor \\neg \\text{Sábio}(y))\\]\n\n\nTodo animal corre ou algum pássaro voa\n\nLógica de Primeiro Grau:\n\\[\\forall x(\\text{Animal}(x) \\rightarrow \\text{Corre}(x)) \\lor \\exists y(\\text{Pássaro}(y) \\land \\text{Voa}(y))\\]\nForma Normal Conjuntiva (FNC):\n\nConvertendo a implicação:\n\\[\\neg \\text{Animal}(x) \\lor \\text{Corre}(x)\\]\nAdicionando a disjunção existencial:\n\\[(\\neg \\text{Animal}(x) \\lor \\text{Corre}(x)) \\land (\\text{Pássaro}(y) \\land \\text{Voa}(y))\\]\n\nForma Normal Disjuntiva (FND):\n\nNegando o consequente do implicador:\n\\[\\text{Animal}(x) \\land \\neg \\text{Corre}(x)\\]\nAdicionando a conjunção existencial negada:\n\\[(\\text{Animal}(x) \\land \\neg \\text{Corre}(x)) \\lor (\\neg \\text{Pássaro}(y) \\lor \\neg \\text{Voa}(y))\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#exercícios-de-conexão-com-prolog",
    "href": "05-formas-normais-e-skolemizacao.html#exercícios-de-conexão-com-prolog",
    "title": "7  Formas Normais",
    "section": "7.2 Exercícios de Conexão com Prolog",
    "text": "7.2 Exercícios de Conexão com Prolog\nA conversão de fórmulas para uma Forma Normal (seja Conjuntiva - FNC, ou Disjuntiva - FND) é um processo algorítmico que permite a padronização e a manipulação de expressões lógicas por computadores. Este conjunto de questões foca nesta habilidade, que é a base para o funcionamento de provadores de teoremas e do mecanismo de resolução do Prolog.\nQuestão 1: Conversão Básica:\nDada a seguinte fórmula lógica, que representa uma regra de negócio simples: “Se o pedido (\\(P\\)) foi aprovado, então a nota fiscal (\\(N\\)) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (\\(E\\)).”\nFórmula:\n\\[(P \\to N) \\wedge \\neg (N \\wedge \\neg E)\\]\nConverta esta fórmula para:\n\nA Forma Normal Conjuntiva (FNC).\n\nA Forma Normal Disjuntiva (FND).\n\nQuestão 2: Cenários de Ativação de Sistema:\nUm sistema de irrigação automática (\\(I\\)) é ativado se o sensor de umidade do solo indicar que está seco (\\(S\\)) ou se não choveu nas últimas 24 horas (\\(\\neg C\\)) e a temperatura está alta (\\(T\\)).\n\nModele a condição de ativação (\\(I\\)) como uma fórmula lógica.\n\nConverta a fórmula para a Forma Normal Disjuntiva (FND). O que cada termo da FND representa em termos de cenários práticos de ativação?\n\nQuestão 3: Verificação de Consistência de Regras:\nAs regras de configuração de um firewall são:\n\nSe uma conexão é da rede interna (\\(I\\)), ela é permitida (\\(P\\)).\n\nSe uma conexão não é da rede interna, ela só é permitida se for uma conexão segura (\\(S\\)).\n\nUma conexão segura nunca vem da rede interna.\n\nModele as três regras como uma única fórmula. Converta-a para a Forma Normal Conjuntiva (FNC). A FNC resultante indica se as regras são consistentes? O que aconteceria se uma conexão fosse segura e viesse da rede interna?\nQuestão 4: Equivalência de Políticas de Segurança:\nDois administradores de sistemas escreveram políticas de acesso a um servidor de desenvolvimento.\n\nPolítica de Alice: “Um desenvolvedor (\\(D\\)) pode acessar o servidor se tiver uma chave de acesso (\\(C\\)), ou se não tiver uma chave de acesso mas estiver trabalhando em um projeto crítico (\\(P\\)).”\nPolítica de Beto: “Um desenvolvedor (\\(D\\)) pode acessar o servidor se estiver trabalhando em um projeto crítico (\\(P\\)), ou se tiver uma chave de acesso (\\(C\\)).”\n\nModele as duas políticas como fórmulas lógicas e converta ambas para a Forma Normal Disjuntiva Mínima. Elas são logicamente equivalentes?\nQuestão 5: Eliminando a Bicondicional:\nUma regra de um e-commerce afirma: “Um cliente recebe frete grátis (\\(F\\)) se, e somente se, ele for um membro Prime (\\(P\\)) ou o valor do seu pedido for superior a R$100 (\\(V\\)).”\nFórmula:\n\\[F \\leftrightarrow (P \\vee V)\\]\nConverta esta fórmula para a Forma Normal Conjuntiva (FNC). Cada cláusula da FNC representa que tipo de restrição no sistema?\nQuestão 6: Simplificação de Circuito Lógico:\nA saída de um circuito lógico com três entradas (\\(A\\), \\(B\\), \\(C\\)) é descrita pela seguinte tabela verdade:\n\n\n\n\\(A\\)\n\\(B\\)\n\\(C\\)\nSaída\n\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n0\n1\n\n\n1\n0\n1\n1\n\n\n1\n1\n0\n0\n\n\n1\n1\n1\n0\n\n\n\n\nEscreva a Forma Normal Disjuntiva (FND) canônica a partir da tabela.\nUse um Mapa de Karnaugh ou álgebra booleana para encontrar a FND mínima.\n\nQuestão 7: Validando uma Inferência (Tautologia):\nNo Bloco 2, vimos que de “Todos os leões são mamíferos” e “Simba é um leão”, podemos concluir “Simba é um mamífero”. A estrutura lógica desta inferência é uma tautologia:\n\\[\\left( (\\forall x (L(x) \\to M(x))) \\wedge L(s) \\right) \\to M(s)\\]\nPara um \\(s\\) específico, a fórmula se torna:\n\\[\\left( (L(s) \\to M(s)) \\wedge L(s) \\right) \\to M(s).\\]\nProve que esta fórmula é uma tautologia, mostrando que sua negação é insatisfatível (uma contradição). Para isso, negue a fórmula e converta o resultado para FNC.\nQuestão 8: Problema de Satisfatibilidade (SAT):\nTrês programadores (Ana, Beto, Carla) precisam ser alocados para um projeto. As restrições são:\n\nPelo menos um dos três deve ser alocado;\n\nAna e Beto não podem trabalhar juntos;\nSe Carla for alocada, então Ana também deve ser.\n\nSejam \\(A\\), \\(B\\), \\(C\\) as proposições “Ana foi alocada”, “Beto foi alocado” e “Carla foi alocada”. Modele as três restrições e converta-as para um conjunto de cláusulas em FNC. O conjunto de restrições é satisfatível? Se sim, apresente uma alocação válida.\nQuestão 9: Forma Normal Prenex:\nA conversão para Forma Normal Clausal (que veremos no próximo bloco) muitas vezes começa com a conversão para a Forma Normal Prenex, onde todos os quantificadores são movidos para o início da fórmula.\nConverta a seguinte fórmula para a Forma Normal Prenex:\n\\[\\forall x (P(x) \\to (\\exists y (Q(y) \\wedge R(x,y)))) \\vee \\exists z S(z)\\]\nQuestão 10: O Princípio da Resolução:\nO Princípio da Resolução é um método de inferência que opera sobre cláusulas em FNC. Dadas duas cláusulas \\((\\neg P \\vee Q)\\) e \\((P \\vee R)\\), podemos inferir a cláusula resolvente \\((Q \\vee R)\\).\nUse o Princípio da Resolução para provar que o seguinte conjunto de cláusulas é inconsistente (leva à cláusula vazia, \\(\\square\\)):\n\n\\(\\neg P \\vee \\neg Q \\vee R\\);\n\n\\(P \\vee R\\);\n\n\\(Q\\);\n\n\\(\\neg R\\).",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais</span>"
    ]
  },
  {
    "objectID": "06-construcao-de-mundos-logicos.html",
    "href": "06-construcao-de-mundos-logicos.html",
    "title": "8  Mundos na Lógica de Primeira Ordem",
    "section": "",
    "text": "8.0.1 Definição Formal de um Mundo\nNa Lógica de Primeira Ordem, um mundo ou modelo é uma estrutura que consiste em:\nUm modelo \\(M\\) para uma linguagem \\(L\\) é então definido como \\(M = (D, I)\\), sendo que \\(D\\) é o domínio e \\(I\\) é a interpretação.\nNeste exemplo, temos um modelo \\(M\\) no qual:\n\\[M = (\\{1, 2, 3, 4, 5\\}, I)\\]\ncom \\(I\\) definido como acima. Este modelo representa um “mundo” no qual podemos fazer afirmações sobre números inteiros de 1 a 5, suas relações de ordem e paridade.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mundos na **Lógica de Primeira Ordem**</span>"
    ]
  },
  {
    "objectID": "06-construcao-de-mundos-logicos.html#footnotes",
    "href": "06-construcao-de-mundos-logicos.html#footnotes",
    "title": "8  Mundos na Lógica de Primeira Ordem",
    "section": "",
    "text": "GHIDINI, C., & Serafini, L. (2013-2014). Mathematical Logic Exercises. Disponível em: https://disi.unitn.it/~ldkr/ml2014/ExercisesBooklet.pdf.↩︎",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mundos na **Lógica de Primeira Ordem**</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html",
    "href": "07-clausulas-de-horn-e-prolog.html",
    "title": "9  Cláusulas de Horn",
    "section": "",
    "text": "9.0.1 Definição da Cláusula de Horn\nA Cláusula de Horn é uma disjunção de literais que contém, no máximo, um literal positivo. Existem algumas formas equivalentes de representar Cláusulas de Horn:\nTipos de Cláusulas de Horn (baseado na forma disjuntiva \\(\\neg A_1 \\lor \\ldots \\lor \\neg A_k \\lor B\\)):\nPara entender melhor, imagine que estamos construindo um cenário mental fundamentado na lógica para construir o entendimento de um problema, uma espécie de paisagem mental onde as coisas fazem sentido. Nesse cenário, as Cláusulas de Horn serão os tijolos fundamentais que usaremos para construir estruturas lógicas.\n1. Fatos: os fatos são como pedras fundamentais desse cenário. Eles são afirmações simples e diretas que dizem como as coisas são. Considere, por exemplo: O céu é azul, \\(P\\) e A grama é verde\\(Q\\). Essas são verdades que não precisam de justificativa. Elas simplesmente são. os Fatos são axiomas.\n2. Regras: as regras são um pouco mais intrigantes. Elas são como as regras de um jogo que definem como as coisas se relacionam umas com as outras. Se não chover, a grama não ficará molhada. Essa é uma regra. Ela nos diz o que esperar se certas condições forem atendidas. As regras são como os conectores em nosso mundo lógico, ligando fatos e permitindo que façamos inferências. Elas são o motor que nos permite raciocinar e descobrir novas verdades a partir das que já conhecemos. Por exemplo:\n3. Metas ou Consultas: finalmente, temos as metas ou consultas. Essas são as perguntas que fazemos ao nosso mundo lógico. Está chovendo?, A grama está molhada? São os caminhos que usaremos para explorar o cenário criado, olhando ao redor e tentando entender o que está acontecendo. As consultas são a forma de interagir com nosso mundo lógico, usando os fatos e regras que estabelecemos para encontrar respostas e alcançar objetivos. Por exemplo:\nPodemos tentar avaliar alguns exemplos de uso de Fatos, Regras e Consultas:",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#exemplo-3---mundo-núcleo-familiar-lógica-de-primeira-ordem",
    "href": "07-clausulas-de-horn-e-prolog.html#exemplo-3---mundo-núcleo-familiar-lógica-de-primeira-ordem",
    "title": "9  Cláusulas de Horn",
    "section": "9.1 Exemplo 3 - Mundo Núcleo Familiar (Lógica de Primeira Ordem)",
    "text": "9.1 Exemplo 3 - Mundo Núcleo Familiar (Lógica de Primeira Ordem)\nO exemplo a seguir apresenta um mundo que representa uma família e suas relações, apresentado usando a sintaxe da Lógica de Primeira Ordem (FOL).\nFatos: os fatos são representados como predicados aplicados a constantes em FOL.\n\n\\(Homem(joão)\\);\n\\(Homem(pedro)\\);\n\\(Mulher(maria)\\);\n\\(Mulher(ana)\\);\n\\(Progenitor(joão, pedro)\\);\n\\(Progenitor(maria, pedro)\\);\n\\(Progenitor(joão, ana)\\);\n\\(Progenitor(maria, ana)\\).\n\nRegras:\n1. Pai:\n\nForma Implicativa:\n\\[\\forall X \\forall Y (Homem(X) \\land Progenitor(X, Y) \\rightarrow Pai(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y (\\neg Homem(X) \\lor \\neg Progenitor(X, Y) \\lor Pai(X, Y))\\]\n\n2. Mãe:\n\nForma Implicativa:\n\\[\\forall X \\forall Y (Mulher(X) \\land Progenitor(X, Y) \\rightarrow Mae(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y (\\neg Mulher(X) \\lor \\neg Progenitor(X, Y) \\lor Mae(X, Y))\\]\n\n3. Meio-Irmão: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Homem(X) \\land Progenitor(Z, X) \\land Progenitor(Z, Y) \\land X \\neq Y \\rightarrow MeioIrmao(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\lor \\neg Progenitor(Z, X) \\lor \\neg Progenitor(Z, Y) \\lor X = Y \\lor MeioIrmao(X, Y))\\]\n\n4. Meio-Irmã: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Mulher(X) \\land Progenitor(Z, X) \\land Progenitor(Z, Y) \\land X \\neq Y \\rightarrow MeioIrma(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\lor \\neg Progenitor(Z, X) \\lor \\neg Progenitor(Z, Y) \\lor X = Y \\lor MeioIrma(X, Y))\\]\n\n5. Irmão: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall P \\forall M (Homem(X) \\land Pai(P,X) \\land Pai(P,Y) \\land Mae(M,X) \\land Mae(M,Y) \\land X \\neq Y \\rightarrow Irmao(X,Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall P \\forall M (\\neg Homem(X) \\lor \\neg Pai(P,X) \\lor \\neg Pai(P,Y) \\lor \\neg Mae(M,X) \\lor \\neg Mae(M,Y) \\lor X = Y \\lor Irmao(X,Y))\\]\n\n6. Irmã: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall P \\forall M (Mulher(X) \\land Pai(P,X) \\land Pai(P,Y) \\land Mae(M,X) \\land Mae(M,Y) \\land X \\neq Y \\rightarrow Irma(X,Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall P \\forall M (\\neg Mulher(X) \\lor \\neg Pai(P,X) \\lor \\neg Pai(P,Y) \\lor \\neg Mae(M,X) \\lor \\neg Mae(M,Y) \\lor X = Y \\lor Irma(X,Y))\\]\n\n7. Avô:\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Homem(X) \\land Progenitor(X, Z) \\land Progenitor(Z, Y) \\rightarrow Avo(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\lor \\neg Progenitor(X, Z) \\lor \\neg Progenitor(Z, Y) \\lor Avo(X, Y))\\]\n\n8. Avó:\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Mulher(X) \\land Progenitor(X, Z) \\land Progenitor(Z, Y) \\rightarrow Avo(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\lor \\neg Progenitor(X, Z) \\lor \\neg Progenitor(Z, Y) \\lor Avo(X, Y))\\]\n\nConsultas (Metas):\n\npai(joão, pedro)\nPara verificar se \\(Pai(joão, pedro)\\) é uma consequência lógica da base de conhecimento, tenta-se provar que a base de conhecimento junto com \\(\\neg Pai(joão, pedro)\\) leva a uma contradição (\\(\\bot\\)). A meta é, portanto: \\[\\neg Pai(joão, pedro)\\]\nirmão(pedro, ana)\nPara verificar se \\(Irmao(pedro, ana)\\) é verdadeiro: \\[\\neg Irmao(pedro, ana)\\]\navó(X, ana)\nPara perguntar se “Existe uma avó X para Ana?”, a consulta seria \\(\\exists X (Avo(X, ana) \\land Mulher(X))\\). A forma de meta para refutação seria tentar provar que a base de conhecimento junto com \\(\\forall X (\\neg Avo(X, ana) \\lor \\neg Mulher(X))\\) leva a uma contradição.\n\nEm um sistema de prova por refutação, adicionamos a negação da consulta à base de conhecimento e tentamos derivar uma contradição (\\(\\bot\\)). As representações das metas como negações em FOL estão corretas nesse contexto. #### Exemplo 4 - Torre de Hanói\nA Torre de Hanói é um quebra-cabeça matemático que consiste em três postes e um número de discos de diferentes tamanhos que podem deslizar sobre qualquer poste. O quebra-cabeça começa com os discos empilhados em ordem decrescente de tamanho no primeiro poste, o menor disco no topo. O objetivo é mover toda a pilha para o último poste, obedecendo às seguintes regras:\nPredicados:\n\n\\(Disco(x)\\): \\(x\\) é um disco;\n\\(Poste(x)\\): \\(x\\) é um poste;\n\\(Menor(x)\\): \\(x\\) é o disco menor;\n\\(Maior(x, y)\\): o disco \\(x\\) é maior que o disco \\(y\\);\n\\(Em(x, y)\\): o disco \\(x\\) está no poste \\(y\\);\n\\(Sobre(x, y)\\): o disco \\(x\\) está sobre o disco \\(y\\).\n\nFatos (Cláusulas de Horn Unitárias):\n\n\\(Disco(d_1)\\);\n\\(Disco(d_2)\\);\n\\(Disco(d_3)\\);\n\\(Poste(p_1)\\);\n\\(Poste(p_2)\\);\n\\(Poste(p_3)\\);\n\\(Menor(d_1)\\);\n\\(Maior(d_2, d_1)\\);\n\\(Maior(d_3, d_2)\\).\n\nRegras (Cláusulas de Horn Não-Unitárias):\n\nMovimento válido:\n\\[\\neg Disco(x) \\lor \\neg Poste(y) \\lor \\neg Poste(z) \\lor \\neg Em(x, y) \\lor \\neg DiscoNoTopo(x, y) \\lor \\neg DiscoNoTopo(u, z) \\lor \\neg Maior(x, u) \\lor MovimentoValido(x, y, z)\\]\nCondição de vitória:\n\\[\\neg Disco(x) \\lor \\neg Disco(y) \\lor \\neg Disco(z) \\lor \\neg Em(x, p_3) \\lor \\neg Em(y, p_3) \\lor \\neg Em(z, p_3) \\lor Vitoria()\\]\nDisco válido (nenhum disco maior sobre um menor):\n\\[\\neg Sobre(x, y) \\lor \\neg Maior(x, y) \\lor DiscoValido(x, y)\\]\nMovimento único:\n\\[\\neg Disco(x) \\lor \\neg Disco(y) \\lor \\neg Poste(z) \\lor \\neg Poste(w) \\lor \\neg MovimentoValido(y, z, w) \\lor x = y \\lor MovimentoUnico(x)\\]\nEstado inicial:\n\\[\\neg Em(d_1, p_1) \\lor \\neg Em(d_2, p_1) \\lor \\neg Em(d_3, p_1) \\lor \\neg Sobre(d_3, d_2) \\lor \\neg Sobre(d_2, d_1) \\lor EstadoInicial()\\]\nDisco no topo:\n\\[\\neg Disco(x) \\lor \\neg Poste(y) \\lor \\neg Em(x, y) \\lor \\neg Disco(z) \\lor \\neg Em(z, y) \\lor \\neg Sobre(z, x) \\lor DiscoNoTopo(x, y)\\]\n\nConsultas (Metas):\n\nVerificar se um movimento é válido:\n\\[\\neg MovimentoValido(x, y, z)\\]\nVerificar se o jogo foi vencido:\n\\[\\neg Vitoria()\\]\nVerificar se um disco pode estar sobre outro:\n\\[\\neg DiscoValido(x, y)\\]\nVerificar se apenas um disco está sendo movido:\n\\[\\neg MovimentoUnico(x)\\]\nVerificar o estado inicial:\n\\[\\neg EstadoInicial()\\]\nVerificar se um disco está no topo de um poste:\n\\[\\neg DiscoNoTopo(x, y)\\]\n\n\n9.1.1 Quantificadores em Cláusulas de Horn\nOs quantificadores podem ser incluídos nas Cláusulas de Horn. Contudo, é importante notar que a forma padrão de Cláusulas de Horn em programação lógica geralmente lida com quantificação de forma implícita. A quantificação universal é comum e é geralmente assumida em regras, enquanto a quantificação existencial é muitas vezes tratada através de fatos específicos ou construção de termos.\nPrecisamos tomar cuidado porque a inclusão explícita de quantificadores pode levar a uma Lógica de Primeira Ordem mais rica, permitindo expressões mais complexas e poderosas. No entanto, isso também pode aumentar a complexidade do raciocínio e da resolução.\nO quantificador universal (representado por $$) afirma que uma propriedade é verdadeira para todos os membros de um domínio. Em Cláusulas de Horn, isso é geralmente representado implicitamente através de regras gerais que se aplicam a todos os membros de um conjunto. Por exemplo, considere a regra: Todos os pássaros podem voar. Em uma Cláusula de Horn, isso pode ser representado como:\nEm programação lógica e Cláusulas de Horn, a quantificação é frequentemente tratada implicitamente.\nQuantificador Universal em Regras: considere a afirmação: “Para todo x, se x é um pássaro, então x pode voar.”\n\nFórmula em Lógica de Primeira Ordem** (LPO)**: \\(\\forall x (\\text{Pássaro}(x) \\rightarrow \\text{Voa}(x))\\)\nForma clausal (Cláusula de Horn equivalente): \\(\\neg \\text{Pássaro}(x) \\lor \\text{Voa}(x)\\) (Aqui, \\(x\\) é implicitamente quantificado universalmente.)\nRepresentação em Prolog: voa(X) :- passaro(X). (A variável X é implicitamente quantificada universalmente.)\n\nQuantificador Existencial e Fatos: considere a afirmação: “Existe um pássaro que não pode voar.” * Fórmula em LPO: \\(\\exists x (\\text{Pássaro}(x) \\land \\neg \\text{Voa}(x))\\) * Tratamento em sistemas de Cláusulas de Horn: Afirmações existenciais puras como \\(\\exists x \\Phi(x)\\) não são diretamente representadas como regras de Cláusula de Horn. Para incorporar tal conhecimento, se o indivíduo específico for conhecido, ele é afirmado como um conjunto de fatos. Por exemplo, se sabemos que “Pengu” é um pássaro e não voa: * Fatos em Prolog: passaro(pengu). nao_voa(pengu). (ou voa(pengu) :- fail.)\n\nSe a existência é conhecida mas o indivíduo não é nomeado, em processos de prova teórica (como resolução), a Skolemização substituiria \\(x\\) por uma nova constante (constante de Skolem), resultando em: \\(\\text{Pássaro}(c) \\land \\neg \\text{Voa}(c)\\). Estes seriam então fatos no sistema: \\(\\text{Pássaro}(c).\\) e \\(\\neg \\text{Voa}(c).\\) (ou um predicado para a negação).\n\n\n\n9.1.2 Conversão de Fórmulas\nSeja uma Fórmula Bem Formada arbitrária da Lógica Proposicional. Alguns passos podem ser aplicados para obter uma cláusula de Horn equivalente:\n\nConverter a fórmula para Forma Normal Conjuntiva (FNC), obtendo uma conjunção de disjunções\nAplicar as seguintes técnicas em cada disjunção:\n\nInverter a polaridade de literais positivos extras;\nAdicionar literais negativos que preservem a satisfatibilidade;\nDividir em cláusulas menores se necessário.\n\nSimplificar a fórmula final obtida.\n\n\n9.1.2.1 Exemplo 1: dada a fórmula\n\\[(P \\land Q) \\lor (P \\land R)\\]\nPassos:\n\nConverter para FNC: \\((P \\lor Q) \\land (P \\lor R)\\);\nInverter P em uma das disjunções: \\((P \\lor Q) \\land (\\neg P \\lor R)\\);\nAdicionar literal negativo: \\((P \\lor Q \\lor \\neg S) \\land (\\neg P \\lor R \\lor \\neg T)\\);\nSimplificar: $S P T r $.\n\nA sequência destes passos permite encontrar uma conjunção de cláusulas de Horn equivalente à fórmula original.\n\n\n9.1.2.2 Transformação de Forma Normal Conjuntiva (FNC) para Cláusulas de Horn\nA Forma Normal Conjuntiva é uma conjunção de disjunções de literais. Uma Cláusula de Horn é um tipo especial de cláusula que contém no máximo um literal positivo. Considere que o objetivo das Cláusulas de Horn é criar um conjunto de Fórmulas Bem Formadas, divididas em Fatos, Regras e Consultas para permitir a resolução de problemas então, a transformação de uma FNC para Cláusulas de Horn pode incorrer em alguns problemas:\n\nPerda de Informação: Nem todas as cláusulas em FNC podem ser transformadas em Cláusulas de Horn. Para minimizar este risco atente para as regras de equivalência que vimos anteriormente.\nComplexidade: A transformação pode ser complexa e requer uma análise cuidadosa da lógica e do contexto.\n\nEtapas de Transformação\n\nConverter para FNC: Se a fórmula ainda não estiver em Forma Normal Conjuntiva, converta-a para Forma Normal Conjuntiva usando as técnicas descritas anteriormente;\nIdentificar Cláusulas de Horn: Verifique cada cláusula na Forma Normal Conjuntiva. Se uma cláusula contém no máximo um literal positivo, ela já é uma Cláusula de Horn;\nTransformar Cláusulas Não-Horn: Se uma cláusula contém mais de um literal positivo, ela não pode ser diretamente transformada em uma Cláusula de Horn sem perder informações.\n\n\n9.1.2.2.1 Exemplo 1: vamos considerar a seguinte Fórmula Bem Formada\n\\[(A \\rightarrow B) \\land (B \\lor C)\\]\n\nConverter para FNC:\n\nElimine a implicação: \\((\\neg A \\lor B) \\land (B \\lor C)\\);\nA fórmula já está em Forma Normal Conjuntiva.\n\nIdentificar Cláusulas de Horn:\n\nAmbas as cláusulas são Cláusulas de Horn, pois cada uma contém apenas um literal positivo.\n\nResultado:\n\nA fórmula em Cláusulas de Horn é: \\((\\neg A \\lor B) \\land (B \\lor C)\\)\n\n\n\n\n\n9.1.2.3 Problemas interessantes resolvidos com a Cláusula de Horn\nProblema 1 - O Mentiroso e o Verdadeiro:: Você encontra dois habitantes: \\(A\\) e \\(B\\). Você sabe que um sempre diz a verdade e o outro sempre mente, mas você não sabe quem é quem. Você consulta a \\(A\\), Você é o verdadeiro? A responde, mas você não consegue ouvir a resposta dele. \\(B\\) então te diz, A disse que ele é o mentiroso.\nFatos:\n\\(mentiroso(A)\\) \\(verdadeiro(B)\\)\nRegra:\n\\[\n\\forall x \\forall y (mentiroso(x) \\wedge consulta(y, \\text{Você é o verdadeiro?}) → Responde (x, \\text{Sou o mentiroso}))\n\\]\nConsulta:\n\\[ responde (A, \\text{Sou o mentiroso})?\\]\nProblema 2 - As Três Lâmpadas: existem três lâmpadas incandescentes em uma sala, e existem três interruptores fora da sala. Você pode manipular os interruptores o quanto quiser, mas só pode entrar na sala uma vez. Como você pode determinar qual interruptor opera qual lâmpada?\nFatos:\n\\(Interruptor(s_1)\\) \\(Interruptor(s_2)\\) \\(Interruptor(s_3)\\)\n\\(Lâmpada(b_1)\\) \\(Lâmpada(b_2)\\) \\(Lâmpada(b_3)\\)\nRegras:\n\\[\\forall x \\forall y (Interruptor(x) \\wedge Ligado(x) \\wedge Lâmpada(y) \\rightarrow Acende (y))\\]\n\\[\\forall x (Lâmpada(x) \\wedge FoiLigada(x) \\wedge AgoraDesligada(x) \\rightarrow EstáQuente (x))\\]\nConsulta:\n\\[Acende (b_2, s_2)?\\]\n\\[ estáQuente (b_1)?\\]\nProblema 3 - O Agricultor, a Raposa, o Ganso e o Grão: um agricultor quer atravessar um rio e levar consigo uma raposa, um ganso e um saco de grãos. O barco do agricultor só lhe permite levar um item além dele mesmo. Se a raposa e o ganso estiverem sozinhos, a raposa comerá o ganso. Se o ganso e o grão estiverem sozinhos, o ganso comerá o grão. Como o agricultor pode levar todas as suas posses para o outro lado do rio?\nFatos:\n\n\\(Raposa(r)\\);\n\\(Ganso(g)\\);\n\\(Grao(gr)\\).\n\nNestes fatos a atenta leitora deve observar que ‘\\(r\\)’ é uma raposa, ‘\\(g\\)’ é um ganso, e ‘\\(gr\\)’ é um saco de grãos.\nRegras:\n\nSe \\(x\\) é uma Raposa e \\(y\\) é um Ganso, e \\(x\\) e \\(y\\) estão sozinhos, então \\(x\\) come \\(y\\):\n\n\\[\\forall x \\forall y (Raposa(x) \\land Ganso(y) \\land Sozinhos(x, y) \\rightarrow Come(x, y))\\]\n\nSe \\(x\\) é um Ganso e \\(y\\) é Grão, e \\(x\\) e \\(y\\) estão sozinhos, então \\(x\\) come \\(y\\):\n\n\\[\\forall x \\forall y (Ganso(x) \\land Grao(y) \\land Sozinhos(x, y) \\rightarrow Come(x, y))\\]\nO predicado \\(Sozinhos(Item1, Item2)\\) significaria que \\(Item1\\) e \\(Item2\\) estão em uma margem do rio sem o agricultor. O predicado \\(Come(Predador, Presa)\\) significa que o predador come a presa.\nConsulta:\nAs consultas visam verificar se, em um determinado estado da travessia, certas condições de não comer são satisfeitas. Para um sistema de prova, estas seriam as metas a serem mantidas verdadeiras, ou suas negações a serem evitadas.\n\nA raposa \\(r\\) não come o ganso \\(g\\) (ou seja, é falso que \\(r\\) come \\(g\\))?\n\n\\[\\neg Come(r, g)\\]\n\nO ganso \\(g\\) não come o grão \\(gr\\) (ou seja, é falso que \\(g\\) come \\(gr\\))?\n\n\\[\\neg Come(g, gr)\\]\nEstas consultas, no contexto da resolução do problema, representam estados seguros que devem ser mantidos durante toda a travessia. A solução do problema envolve encontrar uma sequência de movimentos que leve todos ao outro lado do rio sem nunca satisfazer as condições de \\(Come(r,g)\\) ou \\(Come(g,gr)\\) quando o agricultor não está presente para supervisionar.\nProblema 4 - A Ponte e a Tocha: quatro pessoas chegam a um rio à noite. Há uma ponte estreita, mas ela só pode conter duas pessoas de cada vez. Eles têm uma tocha e, por ser noite, a tocha tem que ser usada ao atravessar a ponte. A pessoa A pode atravessar a ponte em um minuto, B em dois minutos, C em cinco minutos e D em oito minutos. Quando duas pessoas atravessam a ponte juntas, elas devem se mover no ritmo da pessoa mais lenta. Qual é a forma mais rápida para todos eles atravessarem a ponte?\nFatos (tempos):\n\n\\(tempo(a, 1)\\);\n\\(tempo(b, 2)\\);\n\\(tempo(c, 5)\\);\n\\(tempo(d, 8)\\).\n\nRegras:\n\nRegra para determinar qual pessoa é mais lenta:\n\\[\\neg tempo(X, TX) \\lor \\neg tempo(Y, TY) \\lor \\neg maior(TX, TY) \\lor mais\\_lento(X, Y, X)\\]\n\\[\\neg tempo(X, TX) \\lor \\neg tempo(Y, TY) \\lor \\neg maior(TY, TX) \\lor mais\\_lento(X, Y, Y)\\]\nRegra para calcular o tempo quando duas pessoas atravessam juntas:\n\\[\\neg mais\\_lento(X, Y, Z) \\lor \\neg tempo(Z, T) \\lor tempo\\_travessia(X, Y, T)\\]\nRelações “maior que” definidas como fatos:\n\n\\(maior(2, 1)\\);\n\\(maior(5, 1)\\);\n\\(maior(5, 2)\\);\n\\(maior(8, 1)\\);\n\\(maior(8, 2)\\);\n\\(maior(8, 5)\\).\n\nRegras para representar o plano de travessia:\n\\[\\neg atravessa\\_ida(X, Y, T1) \\lor \\neg volta(Z, T2) \\lor \\neg atravessa\\_ida(W, V, T3) \\lor \\neg volta(U, T4) \\lor \\neg atravessa\\_ida(S, R, T5) \\lor travessia\\_completa(T1+T2+T3+T4+T5)\\]\nOnde as variáveis representam as pessoas que atravessam em cada fase da solução.\n\nConsulta:\n\\[travessia\\_completa(15)?\\]\nEsta consulta verifica se existe um plano de travessia que soma exatamente 15 minutos, representando a solução ótima para o problema.\nProblema 5 - O Problema de Monty Hall: em um programa de game show, os concorrentes tentam adivinhar qual das três portas contém um prêmio valioso. Depois que um concorrente escolhe uma porta, o apresentador, que sabe o que está por trás de cada porta, abre uma das portas não escolhidas para revelar uma cabra (representando nenhum prêmio). O apresentador então pergunta ao concorrente se ele quer mudar sua escolha para a outra porta não aberta ou ficar com sua escolha inicial. O que o concorrente deve fazer para maximizar suas chances de ganhar o prêmio?\nFatos:\n\n\\(Porta(d_1)\\);\n\\(Porta(d_2)\\);\n\\(Porta(d_3)\\).\n\nRegras:\n\\[\\forall x Prêmio(x) \\rightarrow Porta(x)\\]\n\\[\\forall x \\forall y (Porta(x) \\wedge Porta(y) \\wedge x \\neq y \\rightarrow \\neg Prêmio(x) \\vee \\neg Prêmio(y))\\]\nConsulta:\n\\[\\exists x (Porta(x) \\wedge \\neg Revelada(x) \\wedge x \\neq PortaEscolhida \\rightarrow Prêmio(x))?\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "href": "07-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "title": "9  Cláusulas de Horn",
    "section": "9.2 O Prolog Entra em Cena",
    "text": "9.2 O Prolog Entra em Cena\nO Prolog é uma linguagem de programação lógica que utiliza Cláusulas de Horn para representar e manipular conhecimento. A sintaxe e a semântica do Prolog são diretamente mapeadas para Cláusulas de Horn:\n\nFatos: Em Prolog, fatos são representados como cláusulas sem antecedentes. Por exemplo, o fato John é humano pode ser representado como humano(john).\nRegras: As regras em Prolog são representadas como implicações, onde os antecedentes são literais negativos e o consequente é o literal positivo. Por exemplo, a regra Se X é humano, então X é mortal pode ser representada como mortal(X) :- humano(X).\nConsultas: As consultas em Prolog são feitas ao sistema para inferir informações com base nos fatos e regras definidos. Por exemplo, a consulta “Quem é mortal?” pode ser representada como ?- mortal(X).\n\nO Prolog utiliza um mecanismo de resolução baseado em Cláusulas de Horn para responder a consultas. Ele aplica uma técnica de busca em profundidade para encontrar uma substituição de variáveis que satisfaça a consulta.\n\n9.2.0.1 Exemplo 1: O mais simples possível\nFatos:\nhomem(joão).\nmulher(maria).\nOs fatos indicam que “João é homem” e “maria é mulher”.\nRegra:\nmortal(X) :- homem(X).\nA regra estabelece que “Se \\(X\\) é homem, então \\(X\\) é mortal”. O símbolo \\(:-\\) representa implicação.\nConsulta:\nmortal(joão).\nA consulta verifica se “João é mortal”, aplicando a regra definida anteriormente. O Prolog responderá True (verdadeiro ou \\(\\top\\)) pois a regra se aplica dado o fato de que João é homem.\n\n\n9.2.0.2 Exemplo 2: Sistema de Recomendação de Roupas em Prolog\nImagine que estamos construindo um sistema lógico simples em Prolog para recomendar o tipo de roupa que uma pessoa deve vestir com base no clima. Vamos usar Cláusulas de Horn para representar o conhecimento e a lógica do sistema.\nFatos: primeiro, estabelecemos os fatos, que são as verdades básicas sobre o mundo. Neste caso, os fatos podem ser informações sobre o clima atual.\n\nFato 1: está ensolarado.\n\n ensolarado.\n\nFato 2: a temperatura está acima de 20°C.\n\n temperatura_acima_de_20.\nRegras: em seguida, definimos as regras que descrevem como as coisas se relacionam. Essas regras nos dizem o tipo de roupa apropriada com base no clima.\n\nRegra 1: se está ensolarado e a temperatura está acima de 20°C, use óculos de sol.\n\n óculos_de_sol :- ensolarado, temperatura_acima_de_20.\n\nRegra 2: se está ensolarado, use chapéu.\n\n chapéu :- ensolarado.\n\nRegra 3: se a temperatura está acima de 20°C, use camiseta.\n\n camiseta :- temperatura_acima_de_20.\nAgora, podemos fazer consultas ao nosso sistema para obter recomendações de roupas.\n\nConsulta 1: está ensolarado e a temperatura está acima de 20°C. O que devo vestir?\n\n ?- óculos_de_sol, chapéu, camiseta.\n\n\n9.2.0.3 Exemplo 3: Torre de Hanói\n% Fatos\ndisco(d1).\ndisco(d2).\ndisco(d3).\nposte(p1).\nposte(p2).\nposte(p3).\nmenor(d1).\nmaior(d2, d1).\nmaior(d3, d2).\n\n% Regras (Cláusulas de Horn)\n\n% Um disco está em um poste\nem(D, P) :- disco(D), poste(P).\n\n% Um disco está sobre outro\nsobre(D1, D2) :- disco(D1), disco(D2), maior(D1, D2).\n\n% Movimento válido\nmovimento_valido(D, P1, P2) :-\n    em(D, P1),\n    poste(P2),\n    P1 \\= P2,\n    \\+ (em(D2, P2), menor(D2, D)).\n\n% Condição de vitória\nvitoria :-\n    disco(D1),\n    disco(D2),\n    disco(D3),\n    em(D1, p3),\n    em(D2, p3),\n    em(D3, p3).\n\n% Regra de que nenhum disco pode estar sobre um disco menor\ndisco_valido(D1, D2) :-\n    disco(D1),\n    disco(D2),\n    maior(D1, D2).\n\n% Apenas um disco pode ser movido de cada vez\nmovimento_unico(D) :-\n    disco(D),\n    \\+ (disco(D2), D \\= D2, movimento_valido(D2, _, _)).\n\n% Estado inicial\nestado_inicial :-\n    em(d1, p1),\n    em(d2, p1),\n    em(d3, p1),\n    sobre(d3, d2),\n    sobre(d2, d1).\n\n% Consultas possíveis\n% ?- movimento_valido(D, P1, P2).\n% ?- vitoria.\n% ?- disco_valido(D1, D2).\n% ?- movimento_unico(D).\n% ?- estado_inicial.\n\n9.2.0.3.1 Exemplo 4: O Narrador é seu próprio avô\nO problema do narrador que é seu próprio avô é um exemplo clássico de raciocínio lógico e relações familiares. O problema envolve a construção de uma base de conhecimento que representa as relações familiares e a aplicação de regras lógicas para determinar se o narrador realmente é seu próprio avô. Este exemplo foi publicado por Niklaus Wirth em seu livro Algorithms + Data Structures = Programs 1 fazendo referência a um problema que havia sido publicado em um jornal de Zürich em 1922, que cito em tradução livre a seguir:\nCasei com uma viúva (vamos chamá-la de W) que tem uma filha adulta (chame-a de D). Meu pai (F), que nos visitava com bastante frequência, apaixonou-se pela minha enteada e casou-se com ela. Por isso, meu pai se tornou meu genro e minha enteada se tornou minha madrasta. Alguns meses depois, minha esposa deu à luz um filho (S1), que se tornou cunhado do meu pai, e meu tio. A esposa do meu pai, ou seja, minha enteada, também teve um filho (S2). Em outras palavras, para todos os efeitos, eu sou meu próprio avo.\nUsando este relato como base podemos criar uma base de conhecimento em Prolog, incluir algumas regras, e finalmente verificar se é verdade que o narrador é o seu próprio avô.\n % predicados\nhomem(narrador).\nhomem(f).\nhomem(s1).\nhomem(s2).\n\n% Predicados para relações baseadas em casamentos\nparentesco_legal(narrador,w).\nparentesco_legal(narrador,f).\n\n% relações de parentesco, filhos, netos de sangue\nparentesco(w,d).\nparentesco(f,narrador).\nparentesco(narrador,s1).\nparentesco(f,s2).\n\n% Regras para definir, pai, padrasto e avo\npai(X,Y) :- homem(X), parentesco(X,Y).\npadrasto(X,Y) :-  homem(X), parentesco_legal(X,Y).\navo(X,Z) :- (pai(X,Y); padrasto(X,Y)), (pai(Y,Z) ; padrasto(Y,Z)).\n\n%pergunte se o narrador é avo dele mesmo avo(narrador,narrador)",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#footnotes",
    "href": "07-clausulas-de-horn-e-prolog.html#footnotes",
    "title": "9  Cláusulas de Horn",
    "section": "",
    "text": "WIRTH, Niklaus. Algorithms and Data Structures. [S.l.]: [s.n.], [s.d.]. Disponível em: https://cdn.preterhuman.net/texts/math/Data_StructureANDAlgorithms/Algorithms%20and%20Data%20Structures%20-%20Niklaus%20Wirth.pdf.↩︎",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html",
    "href": "08-verificacao-formal-de-programas.html",
    "title": "10  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "",
    "text": "10.0.1 Princípios fundamentais e triplas de Hoare\nA lógica de Hoare, desenvolvida por Tony Hoare em 1969, revolucionou a verificação formal ao estabelecer uma base axiomática para provar a correção de programas. O conceito central reside nas triplas de Hoare, que têm a forma {P} C {Q}, em que P representa a pré-condição (propriedade verdadeira antes da execução), C o comando ou programa, e Q a pós-condição (propriedade verdadeira após a execução).\nEsta notação expressa uma relação fundamental: “se P é verdadeiro antes da execução de C, e se C termina, então Q será verdadeiro após a execução de C”. Esta interpretação estabelece a base para correção parcial, distinguindo-se da correção total que também garante terminação.\nOs axiomas fundamentais da lógica de Hoare incluem o axioma da atribuição {Q[E/V]} V := E {Q}, que estabelece que para provar Q após a atribuição V := E, devemos provar Q com E substituído por V antes da atribuição. A regra de sequência {P} C1 {R}, {R} C2 {Q} / {P} C1; C2 {Q} permite compor provas de comandos sequenciais através de condições intermediárias.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "href": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "title": "10  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "10.1 Indução Estrutural: Verificação de Programas Recursivos",
    "text": "10.1 Indução Estrutural: Verificação de Programas Recursivos\n\n10.1.1 Princípios fundamentais e diferenças com indução matemática\nA indução estrutural estende a indução matemática tradicional para estruturas de dados definidas recursivamente. Enquanto a indução matemática opera sobre números naturais com estrutura linear, a indução estrutural aplica-se a estruturas como listas, árvores, e fórmulas lógicas que possuem múltiplas formas de construção.\nA indução matemática tradicional prova propriedades P(n) para números naturais através de um caso base P(0) e um caso indutivo P(k) → P(k+1). A indução estrutural generaliza este princípio para estruturas recursivamente definidas, em que múltiplos construtores podem criar novas instâncias a partir de instâncias existentes.\nPara estruturas de dados indutivos, a indução estrutural baseia-se em uma ordenação bem-fundada. Por exemplo, para listas, a relação “ser sublista de” é bem-fundada, e para árvores, “ser subárvore de” estabelece a ordem necessária. Esta fundamentação garante que toda sequência decrescente é finita, permitindo provas por indução.\n\n\n10.1.2 Aplicação para verificação de programas recursivos\nA indução estrutural é especialmente poderosa na verificação de programas funcionais que operam sobre tipos de dados algébricos. Considere a verificação da propriedade de associatividade para concatenação de listas:\n\nTheorem 10.1 (Associatividade da Concatenação) Para quaisquer listas xs, ys, e zs, a seguinte propriedade é válida: \\[\nxs \\oplus (ys \\oplus zs) = (xs \\oplus ys) \\oplus zs\n\\]\n\n\nProof. A prova é por indução estrutural em xs.\nCaso base: xs = [] \\[\n[] \\oplus (ys \\oplus zs) = ys \\oplus zs = ([] \\oplus ys) \\oplus zs\n\\]\nCaso indutivo: xs = h::t\nAssumimos a hipótese indutiva (H.I.): \\(t \\oplus (ys \\oplus zs) = (t \\oplus ys) \\oplus zs\\). \\[\n\\begin{aligned}\n  (h::t) \\oplus (ys \\oplus zs) &= h :: (t \\oplus (ys \\oplus zs)) \\\\\n                              &= h :: ((t \\oplus ys) \\oplus zs) \\quad \\text{[por H.I.]} \\\\\n                              &= (h :: (t \\oplus ys)) \\oplus zs \\\\\n                              &= ((h::t) \\oplus ys) \\oplus zs\n\\end{aligned}\n\\]\n\nEsta prova demonstra como a estrutura recursiva dos dados guia naturalmente a estrutura da prova, com cada constructor da estrutura correspondendo a um caso na indução.\n\n\n10.1.3 Provas de correção de algoritmos funcionais\nA indução estrutural permite provar correção de algoritmos complexos sobre estruturas recursivas. Para funções sobre árvores, consideremos a verificação de que a reflexão é uma involução:\n\nTheorem 10.2 (Reflexão como Involução) Para qualquer árvore t, a reflexão da reflexão de t é igual a t. \\[\n\\text{reflect}(\\text{reflect}(t)) = t\n\\]\n\n\nProof. A prova é por indução estrutural em t.\nCaso base: t = Leaf \\[\n\\text{reflect}(\\text{reflect}(\\text{Leaf})) = \\text{reflect}(\\text{Leaf}) = \\text{Leaf}\n\\]\nCaso indutivo: t = Node(l, v, r)\nAssumimos a H.I.: \\(\\text{reflect}(\\text{reflect}(l)) = l \\land \\text{reflect}(\\text{reflect}(r)) = r\\). \\[\n\\begin{aligned}\n  &\\text{reflect}(\\text{reflect}(\\text{Node}(l, v, r))) \\\\\n  &= \\text{reflect}(\\text{Node}(\\text{reflect}(r), v, \\text{reflect}(l))) \\\\\n  &= \\text{Node}(\\text{reflect}(\\text{reflect}(l)), v, \\text{reflect}(\\text{reflect}(r))) \\\\\n  &= \\text{Node}(l, v, r) \\quad \\text{[por H.I.]}\n\\end{aligned}\n\\]\n\nEsta prova ilustra como hipóteses indutivas múltiplas (para subárvores esquerda e direita) são necessárias para construtores com múltiplos argumentos recursivos.\n\n\n10.1.4 Exemplos práticos com funções recursivas\nA verificação de algoritmos de ordenação por inserção demonstra a aplicação prática da indução estrutural:\n\nTheorem 10.3 (Correção do Insertion Sort) Para qualquer lista lst, o algoritmo insertion_sort produz uma lista ordenada que contém os mesmos elementos da lista original. \\[\n\\forall \\text{lst}, \\text{sorted}(\\text{insertion\\_sort}(\\text{lst})) \\land \\text{same\\_elements}(\\text{lst}, \\text{insertion\\_sort}(\\text{lst}))\n\\]\n\n\nProof. A prova é por indução estrutural em lst.\nCaso base: lst = [] O resultado de insertion_sort([]) é []. A lista vazia é ordenada e contém os mesmos elementos que a original.\nCaso indutivo: lst = h::t Assumimos a H.I.: \\(\\text{sorted}(\\text{insertion\\_sort}(t)) \\land \\text{same\\_elements}(t, \\text{insertion\\_sort}(t))\\).\nSabemos que insertion_sort(h::t) é insert(h, insertion_sort(t)). A prova depende de um lema auxiliar que afirma que a função insert preserva tanto a ordenação quanto a coleção de elementos. Assumir a validade do lema nos permite concluir que a propriedade do teorema é mantida.\n\nO uso de lemmas auxiliares é frequentemente necessário para provas complexas, permitindo decomposição modular das verificações.\n\n\n10.1.5 Relação com tipos de dados indutivos e coinductivos\nA indução estrutural aplica-se naturalmente a tipos de dados indutivos, que são construídos através de construtores finitos. Tipos indutivos como listas e árvores são definidos através de casos base (lista vazia, folha) e casos recursivos (cons, nó interno).\nPor contraste, tipos coinductivos são definidos através de destrutores/observadores e podem representar estruturas potencialmente infinitas como streams. A coindução é o dual matemático da indução, apropriada para provar propriedades sobre estruturas infinitas através de consistência de observações.\nEm assistentes de prova como Coq, esta dualidade é expressa através da distinção entre tipos Inductive e CoInductive:\n(* Tipo indutivo - lista *)\nInductive list (A : Type) : Type :=\n| nil : list A\n| cons : A -&gt; list A -&gt; list A.\n\n(* Tipo coinductivo - stream *)\nCoInductive stream (A : Type) : Type :=\n| Cons : A -&gt; stream A -&gt; stream A.\nEsta distinção fundamental orienta a escolha entre técnicas de prova indutivas e coindutivas, dependendo da natureza finita ou infinita das estruturas sendo verificadas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "href": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "title": "10  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "10.2 Integração com Lógica de Primeira Ordem",
    "text": "10.2 Integração com Lógica de Primeira Ordem\n\n10.2.1 Especificação de propriedades de programas com FOL\nA Lógica de Primeira Ordem (FOL) fornece a base teórica fundamental para especificação de propriedades de programas. FOL permite expressar propriedades complexas através de quantificadores (∀ - para todo, ∃ - existe) e predicados, oferecendo expressividade suficiente para a maioria das especificações práticas.\nA especificação de contratos de programas utiliza FOL para definir pré-condições, pós-condições e invariantes. Por exemplo, uma função de ordenação pode ter especificação:\n\\[\n\\forall \\text{array} \\in \\text{int}[], \\text{sorted}(\\text{array}) \\iff \\forall i,j: (0 \\le i &lt; j &lt; \\text{array.length}) \\implies \\text{array}[i] \\le \\text{array}[j]\n\\]\nEsta especificação captura precisamente o conceito de array ordenado usando quantificadores universais sobre índices e uma implicação que define a relação de ordem.\nPara estruturas de dados mais complexas, FOL permite especificar invariantes estruturais:\n\\[\n\\forall \\text{tree} \\in \\text{BinaryTree}, \\text{balanced}(\\text{tree}) \\iff \\forall \\text{node} \\in \\text{tree}, |\\text{height}(\\text{left}(\\text{node})) - \\text{height}(\\text{right}(\\text{node}))| \\le 1\n\\]\n\n\n10.2.2 Relação entre lógica e correção de programas\nA relação entre FOL e correção de programas manifesta-se através da interpretação semântica das especificações. A lógica de Hoare utiliza FOL como metalinguagem para expressar a semântica de correção parcial e total, sendo que triplas de Hoare são interpretadas como fórmulas FOL.\nA verificação de correção transforma programas anotados em condições de verificação (VCs) expressas em FOL. Estas VCs são então enviadas para provadores automáticos de teoremas (SAT/SMT solvers) que determinam sua validade. Este processo automatiza significativamente a verificação, reduzindo o esforço manual necessário para provas de correção.\nA correção parcial especifica que se a pré-condição é verdadeira e o programa termina, então a pós-condição é verdadeira. A correção total adiciona a garantia de terminação, frequentemente expressa através de variantes que diminuem em relações bem-fundamentadas.\n\n\n10.2.3 Métodos formais em engenharia de software\nA integração de FOL com engenharia de software ocorre através de diversos métodos formais. Model checking explora exaustivamente o espaço de estados de sistemas finitos, verificando propriedades temporais expressas em lógicas como LTL (Linear Temporal Logic) e CTL (Computation Tree Logic).\nTheorem proving oferece verificação interativa ou semi-automática baseada em FOL e lógicas de ordem superior. Ferramentas como Coq, Isabelle/HOL e Lean permitem construção incremental de provas complexas, com verificação automática de correção.\nA abstract interpretation utiliza FOL para especificar domínios abstratos que aproximam o comportamento de programas, permitindo análise estática eficiente para detecção de erros como buffer overflows, null pointer dereferences, e violações de invariantes.\n\n\n10.2.4 Ferramentas modernas e aplicações práticas\nAs ferramentas modernas de verificação formal implementam integração sofisticada entre FOL e verificação de programas. Dafny utiliza Church’s Simple Type Theory, uma extensão de FOL, para especificação e verificação automática através do provador Z3.\nSPARK, baseado em Ada, expressa contratos como predicados FOL e utiliza múltiplos provadores SMT para verificação automática. Esta abordagem demonstra aplicabilidade industrial da verificação formal, com uso em sistemas críticos da aviação e automotivos.\nCoq/Rocq oferece ambiente de prova interativa onde FOL pode ser codificada dentro do sistema de tipos, permitindo formalização matemática rigorosa e extração automática de programas certificados. Projetos como CompCert (compilador C formalmente verificado) demonstram a viabilidade da verificação formal em larga escala.\n\n\n10.2.5 Aplicações em sistemas críticos\nA verificação formal com FOL encontra aplicações cruciais em sistemas críticos. Na aviação, padrões como DO-178C/ED-12C reconhecem métodos formais como meio aceitável para certificação de software aviônico. Projetos como o Airbus A380 utilizaram verificação formal para componentes críticos de controle.\nSistemas automotivos seguem a ISO 26262 para segurança funcional, onde verificação formal contribui para atendimento aos níveis mais altos de integridade de segurança (ASIL D). A verificação de ECUs (Electronic Control Units) utiliza especificações FOL para garantir ausência de erros críticos.\nNa segurança cibernética, a verificação formal de protocolos criptográficos utiliza FOL para especificar propriedades de segurança como confidencialidade, integridade e autenticidade. Projetos como a verificação do microkernel seL4 demonstram correção funcional completa usando Isabelle/HOL.\n\n\n10.2.6 Desafios e direções futuras\nA integração entre FOL e verificação formal enfrenta desafios significativos. A complexidade computacional da verificação cresce exponencialmente com o tamanho dos programas, exigindo técnicas de abstração e decomposição para escalabilidade.\nA usabilidade permanece um obstáculo para adoção ampla, requerendo conhecimento matemático especializado e ferramentas com interfaces ainda em evolução. Desenvolvimentos em automação inteligente, incluindo uso de aprendizado de máquina para geração de especificações e invariantes, prometem reduzir esta barreira.\nTendências emergentes incluem verificação contínua integrada a pipelines DevOps, synthesis automática de código a partir de especificações FOL, e aplicação a novos domínios como blockchain e sistemas de inteligência artificial.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html",
    "href": "09-desafios-logicos-enigmas-e-misterios.html",
    "title": "11  Problemas Interessantes Resolvidos com Lógica Proposicional e Predicativa",
    "section": "",
    "text": "Aqui estão cinco quebra-cabeças clássicos juntamente com suas soluções usando Lógica de Primeira Ordem\n\nQuebra-cabeça: O Mentiroso e o Verdadeiro Você encontra dois habitantes: \\(A\\) e \\(B\\). Você sabe que um sempre diz a verdade e o outro sempre mente, mas você não sabe quem é quem. Você pergunta a \\(A\\), Você é o verdadeiro? A responde, mas você não consegue ouvir a resposta dele. \\(B\\) então te diz, A disse que ele é o mentiroso.\nSolução: \\(A\\) deve ser o verdadeiro e \\(B\\) deve ser o mentiroso. Se \\(B\\) fosse o verdadeiro, ele nunca diria que é o mentiroso. Portanto, \\(B\\) deve ser o mentiroso e \\(A\\) deve ser o verdadeiro, independentemente do que \\(B\\) disse.\nUsando apenas Lógica Proposicional teremos:\nDefinições: VA: A é o verdadeiro MA: A é o mentiroso VB: B é o verdadeiro MB: B é o mentiroso RA: A respondeu “Sim” à pergunta “Você é o verdadeiro?”\nAxiomas:\n\n\\(VA \\lor MA\\) (A é verdadeiro ou mentiroso);\n\\(\\neg(VA \\land MA)\\) (A não é ambos verdadeiro e mentiroso);\n\\(VB \\lor MB\\) (B é verdadeiro ou mentiroso);\n\\(\\neg(VB \\land MB)\\) (B não é ambos verdadeiro e mentiroso);\n\\(VA \\to \\neg VB\\) (Se A é verdadeiro, B não é verdadeiro);\n\\(VA \\to RA\\) (Se A é verdadeiro, ele respondeu “Sim”);\n\\(MA \\to \\neg RA\\) (Se A é mentiroso, ele respondeu “Não”);\n\\(VB \\to (B \\text{ diz } \\neg RA)\\) (Se B é verdadeiro, ele diz a verdade sobre a resposta de A);\n\\(MB \\to (B \\text{ diz } RA)\\) (Se B é mentiroso, ele mente sobre a resposta de A).\n\nFato observado:\n\\[B \\text{ diz } \\neg RA\\]\nProva:\n\n\\(B \\text{ diz } \\neg RA\\) (Fato observado)\n\\((VB \\land \\neg RA) \\lor (MB \\land RA)\\) (Por 8, 9 e 1)\nSuponha \\(MA\\): 3.1. \\(\\neg RA\\) (Por 7) 3.2. \\(VB\\) (Por 3, 4 e 5) 3.3. Mas isto contradiz 2, pois teríamos \\((VB \\land RA)\\)\nPortanto, \\(\\neg MA\\) (Por reductio ad absurdum)\n\\(VA\\) (Por 1 e 4)\n\nConclusão:\n\\[VA \\land \\neg MA\\]\n\\(A\\) é o verdadeiro e não é o mentiroso.\nUsando lógica de primeiro grau teremos:\nDefinições:\n\n\\(V(x)\\): \\(x\\) é o verdadeiro;\n\\(M(x)\\): \\(x\\) é o mentiroso;\n\\(R(x)\\): \\(x\\) respondeu “Sim” à pergunta “Você é o verdadeiro?”;\n\\(D(x, p)\\): \\(x\\) diz que p é verdadeiro.\n\nAxiomas:\n\n\\(\\forall x (V(x) \\lor M(x))\\) (Todo x é verdadeiro ou mentiroso);\n\\(\\forall x (V(x) \\to \\neg M(x))\\) (Ninguém é ambos verdadeiro e mentiroso);\n\\(\\forall x (V(x) \\to R(x))\\) (Se x é verdadeiro, x responde “Sim”);\n\\(\\forall x (M(x) \\to \\neg R(x))\\) (Se x é mentiroso, x responde “Não”);\n\\(\\forall x \\forall y \\forall p (V(x) \\to (D(x, p) \\leftrightarrow p))\\) (Se x é verdadeiro, x diz p se e somente se p é verdadeiro);\n\\(\\forall x \\forall y \\forall p (M(x) \\to (D(x, p) \\leftrightarrow \\neg p))\\) (Se x é mentiroso, x diz p se e somente se p é falso).\n\nFatos observados:\n\\[D(B, \\neg R(A))\\]\nProva:\n\n\\(D(B, \\neg R(A))\\) (Fato observado);\n\\(V(A) \\lor M(A)\\) (Por 1);\nSuponha \\(M(A)\\): 3.1. \\(\\neg R(A)\\) (Por 4); 3.2. \\(V(B)\\) (Pois apenas um é mentiroso, por 1 e 2); 3.3. \\(D(B, \\neg R(A)) \\leftrightarrow \\neg R(A)\\) (Por 5); 3.4. \\(\\neg R(A)\\) (Por 1 e 3.3); 3.5. Mas isto contradiz 3.1 e 3.4.\nPortanto, \\(\\neg M(A)\\) (Por reductio ad absurdum)\n\\(V(A)\\) (Por 2 e 4)\n\nConclusão: \\[V(A) \\land \\neg M(A)\\]\n\\(A\\) é o verdadeiro e não é o mentiroso.\nQuebra-cabeça: As Três Lâmpadas Existem três lâmpadas incandescentes em uma sala, e existem três interruptores fora da sala. Você pode manipular os interruptores o quanto quiser, mas só pode entrar na sala uma vez. Como você pode determinar qual interruptor opera qual lâmpada?\nSolução: ligue um interruptor e espere um pouco. Então desligue esse interruptor e ligue um segundo interruptor. Entre na sala. A lâmpada que está acesa corresponde ao segundo interruptor. A lâmpada que está desligada e quente corresponde ao primeiro interruptor. A lâmpada que está desligada e fria corresponde ao terceiro interruptor.\nUsando Lógica de Primeira Ordem: Vamos denotar os interruptores como \\(s1, s2, s3\\) e as lâmpadas como \\(b1, b2, b3\\). Podemos definir predicados \\(On(b, s)\\) e \\(Hot(b)\\).\n\\[On(b1, s2) \\land Hot(b2) \\land \\neg (On(b3) \\lor Hot(b3))\\]\nQuebra-cabeça: O Agricultor, a Raposa, o Ganso e o Grão Um agricultor quer atravessar um rio e levar consigo uma raposa, um ganso e um saco de grãos. O barco do agricultor só lhe permite levar um item além dele mesmo. Se a raposa e o ganso estiverem sozinhos, a raposa comerá o ganso. Se o ganso e o grão estiverem sozinhos, o ganso comerá o grão. Como o agricultor pode levar todas as suas posses para o outro lado do rio?\nSolução: o agricultor leva o ganso através do rio primeiro, deixando a raposa e o grão no lado original. Ele deixa o ganso no outro lado e volta para pegar a raposa. Ele deixa a raposa no outro lado, mas leva o ganso de volta ao lado original para pegar o grão. Ele deixa o grão com a raposa no outro lado. Finalmente, ele retorna ao lado original mais uma vez para pegar o ganso.\nUsando Lógica de Primeira Ordem: Podemos definir predicados \\(mesmoLado(x, y)\\) e \\(come (x, y)\\). A solução envolve a sequência de ações que mantêm as seguintes condições:\n\\[\\neg (mesmoLado(Raposa, Ganso) \\land \\neg mesmoLado(Raposa, Fazendeiro))\\]\n\\[\\neg (mesmoLado(Ganso, Grãos) \\land \\neg mesmoLado(Ganso, Fazendeiro))\\]\nQuebra-cabeça: O Problema da Ponte e da Tocha Quatro pessoas chegam a um rio à noite. Há uma ponte estreita, mas ela só pode conter duas pessoas de cada vez. Eles têm uma tocha e, por ser noite, a tocha tem que ser usada ao atravessar a ponte. A pessoa \\(A\\) pode atravessar a ponte em um minuto, \\(B\\) em dois minutos, \\(C\\) em cinco minutos e \\(D\\) em oito minutos. Quando duas pessoas atravessam a ponte juntas, elas devem se mover no ritmo da pessoa mais lenta. Qual é a forma mais rápida para todos eles atravessarem a ponte?\nSolução: primeiro, \\(A\\) e \\(B\\) atravessam a ponte, o que leva 2 minutos. \\(A\\) então pega a tocha e volta para o lado original, levando 1 minuto. \\(A\\) fica no lado original enquanto \\(C\\) e \\(D\\) atravessam a ponte, levando 8 minutos. \\(B\\) então pega a tocha e volta para o lado original, levando 2 minutos. Finalmente, \\(A\\) e \\(B\\) atravessam a ponte novamente, levando 2 minutos. No total, teremos \\(2+1+8+2+2=15\\) minutos.\nUsando Lógica de Primeira Ordem: Vamos denotar o tempo que cada pessoa leva para atravessar a ponte como \\(t_A, t_B, t_C, t_D\\) e o tempo total como \\(T\\). O problema pode ser representado da seguinte forma:\n\\[(t_A + t_B + t_A + t_C + t_D + t_B + t_A) \\leq T\\]\nSubstituindo os valores dos tempos resulta em \\(15 \\leq T\\).\nQuebra-cabeça: O Problema de Monty Hall Em um programa de game show, os concorrentes tentam adivinhar qual das três portas contém um prêmio valioso. Depois que um concorrente escolhe uma porta, o apresentador, que sabe o que está por trás de cada porta, abre uma das portas não escolhidas para revelar uma cabra, representando nenhum prêmio. O apresentador então pergunta ao concorrente se ele quer mudar sua escolha para a outra porta não aberta ou ficar com sua escolha inicial. O que o concorrente deve fazer para maximizar suas chances de ganhar o prêmio?\nSolução: o concorrente deve sempre mudar sua escolha. Inicialmente, a chance do prêmio estar atrás da porta escolhida é \\(1/3\\) e a chance de estar atrás de uma das outras portas é \\(2/3\\). Depois que o apresentador abre uma porta para revelar uma cabra, a chance do prêmio estar atrás da porta não escolhida e não aberta ainda é \\(2/3\\).\nUsando Lógica de Primeira Ordem: Vamos denotar as portas como \\(d1, d2, d3\\) e o prêmio como \\(P\\). Podemos definir um predicado \\(contémPrêmio(d)\\). A solução pode ser representada pela seguinte condição:\n\\[(contémPrêmio(d1) \\land \\neg contémPrêmio(d2) \\land \\neg contémPrêmio(d3)) \\\\ \\lor (contémPrêmio(d2)  \\land \\neg contémPrêmio(d1) \\land \\neg contémPrêmio(d3)) \\\\ \\lor (contémPrêmio(d3) \\land \\neg contémPrêmio(d1) \\land \\neg contémPrêmio(d2))\\]\nEsta condição afirma que o prêmio está exatamente atrás de uma das portas, e o concorrente deve mudar sua escolha depois que uma das portas é aberta para revelar nenhum prêmio.\n\n\n11.0.1 O Mistério da Mansão Hollow – Um Desafio para Detetives Lógicos\n\nObjetivo: Aplicar os princípios da Lógica Proposicional e de predicados para analisar um conjunto complexo de informações, identificar contradições, realizar deduções formais e solucionar um enigma.\nDescrição: A esforçada leitora foi convidada a investigar um intrigante mistério ocorrido na antiga Mansão Hollow. O renomado inventor, Sir Arthur Blackwood, desapareceu em circunstâncias suspeitas, deixando para trás uma série de pistas, depoimentos de funcionários e familiares, e alguns bilhetes enigmáticos. A polícia local está confusa com a quantidade de informações, algumas aparentemente contraditórias. Você deve montar uma equipe de detetives e superar o famoso detetive Hercule Poirot. Para isso deverá:\n\nAnalisar cuidadosamente todo o material fornecido (descrições de personagens, mapa da mansão, horários, depoimentos, bilhetes).\nFormalizar as informações relevantes utilizando sentenças da Lógica Proposicional e, quando aplicável, da lógica de predicados.\nConstruir tabelas-verdade e/ou aplicar regras de inferência para verificar a consistência das informações e deduzir novos fatos.\nIdentificar o(s) responsável(is) pelo desaparecimento do Sr. Blackwood (ou determinar o que de fato aconteceu), justificando cada passo da sua conclusão com base nas deduções lógicas realizadas.\n\nA seguir a descrição do caso, o mapa da mansão e os depoimentos dos envolvidos.\n\n11.0.1.1 O Mistério da Mansão Hollow: O Desaparecimento de Sir Arthur Blackwood\nData do Incidente: Segunda-feira, 12 de Maio de 2025 Local: Mansão Hollow, uma propriedade rural isolada. Vítima (Desaparecido): Sir Arthur Blackwood, renomado inventor, 58 anos.\n1. Descrições dos Personagens:\n\nSir Arthur Blackwood: O inventor desaparecido. Gênio excêntrico e recluso, conhecido por sua mente brilhante e comportamento imprevisível. Estava trabalhando febrilmente em um novo projeto secreto chamado “Quimera”.\nSra. Eleanor Blackwood (50 anos): Esposa de Arthur. Uma mulher elegante e ambiciosa, visivelmente preocupada com a reputação e fortuna da família. Ela teme que o comportamento errático de Arthur possa arruiná-los.\nDr. Alistair Finch (45 anos): Um cientista brilhante, antigo protegido de Arthur, mas que se tornou seu principal rival acadêmico e comercial. Chegou à mansão no dia do desaparecimento, alegando buscar uma reconciliação e possível colaboração.\nMiss Clara Evans (28 anos): A jovem e inteligente assistente pessoal de Arthur. Dedicada e leal, trabalhava em estreita colaboração com ele no projeto “Quimera” e conhecia muitos de seus segredos.\nSr. Reginald “Reggie” Croft (65 anos): O mordomo, trabalha para a família Blackwood há mais de trinta anos. É um homem discreto, observador e extremamente leal à memória do falecido pai de Arthur, mas demonstra certa reserva em relação ao próprio Arthur.\nSra. Beatrice Croft (62 anos): Esposa de Reggie, a cozinheira da mansão. Conhece todos os cantos da casa e os hábitos de seus ocupantes. É prática e não se deixa levar por fantasias.\n\nNossos personagens podem ser vistos na imagem abaixo:\n{:class=“lazyload”}\n2. Mapa da Mansão Hollow (Descrição Textual): A Mansão Hollow é uma construção vitoriana de dois andares, com um vasto terreno.\n\nTérreo:\n\nHall de Entrada: Amplo, com piso de mármore, uma imponente escadaria de carvalho que leva ao andar superior. Portas levam à biblioteca (esquerda), sala de estar (direita) e, ao fundo, um corredor para a sala de jantar e a ala de serviço/cozinha.\nBiblioteca: Paredes forradas de estantes com livros antigos e científicos. Uma grande escrivaninha de mogno, poltronas de couro e uma lareira. Duas janelas altas com vista para o jardim da frente.\nSala de Estar: Mobiliário luxuoso, mas um pouco antiquado. Um piano de cauda, lareira e janelas com vista para o jardim lateral e o gazebo.\nSala de Jantar: Uma longa mesa de jantar polida, prataria reluzente. Acesso direto à cozinha.\nCozinha: Grande e funcional, com uma mesa rústica ao centro. Portas para a despensa, os aposentos dos Croft e uma saída para o jardim dos fundos/horta.\nLaboratório do Sr. Blackwood: Localizado no final de um corredor isolado, partindo do hall, perto da escada de serviço. A porta possui uma fechadura especial de alta segurança projetada pelo próprio Arthur. O interior é um caos organizado de equipamentos eletrônicos, protótipos mecânicos, quadros com equações e ferramentas. Possui uma única janela reforçada que dá para o jardim dos fundos. Este é o local principal da investigação inicial.\nEscritório do Sr. Blackwood: Uma sala menor, anexa ao laboratório, acessível apenas por uma porta dentro do laboratório. Mais organizada, com arquivos, patentes, um cofre e um computador.\n\nAndar Superior:\n\nQuarto Principal (Sr. e Sra. Blackwood): Espaçoso, com uma grande cama de dossel, penteadeira, armários embutidos e um banheiro privativo. Uma varanda com vista para o jardim da frente.\nQuarto de Hóspedes: Onde Dr. Finch deixou seus pertences (embora não tenha passado a noite). Confortável, com uma cama de solteiro, escrivaninha e janela para o jardim lateral.\nQuarto de Clara Evans: Menor e mais simples, localizado perto da escada de serviço, com vista para os fundos.\nAposentos do Mordomo e da Cozinheira (Sr. e Sra. Croft): Localizados na ala de serviço, acima da cozinha.\n\nExterior:\n\nJardim da Frente: Um gramado bem cuidado com um caminho circular de cascalho que leva à porta principal. Ladeado por sebes altas.\nJardim Lateral: Menos formal, com um gazebo antigo coberto de hera e canteiros de rosas.\nJardim dos Fundos: Uma área mais extensa e um pouco mais selvagem, com árvores antigas, uma pequena horta cultivada pela Sra. Croft e, nos limites da propriedade, uma velha estufa de vidro abandonada e parcialmente coberta por vegetação.\n\n\nAlguns ambientes da Mansão Hollow podem ser vistos na imagem abaixo:\n\n3. Linha do Tempo (Segunda-feira, 18 de Maio de 1915):\n\n08:00: Café da manhã servido na sala de jantar. Sra. Blackwood preside. Sr. Blackwood não comparece, o que, segundo Sra. Blackwood, era comum quando ele estava imerso em trabalho.\n09:00: Clara Evans leva uma bandeja com café e torradas para o laboratório do Sr. Blackwood.\n10:00: Dr. Alistair Finch chega pontualmente à Mansão Hollow. É recebido pelo mordomo, Sr. Croft, e anunciado à Sra. Blackwood.\n10:15 - 11:00 (aprox.): Dr. Finch e Sra. Blackwood conversam na sala de estar.\n11:00: Sra. Blackwood acompanha Dr. Finch até a porta do laboratório do Sr. Blackwood. Ela bate. Uma voz abafada, identificada por ela como sendo de Arthur, diz: “Estou no meio de algo crítico! Não me perturbem agora!”. Dr. Finch parece contrariado.\n11:05 - 13:00: Período decisivo com movimentações diversas e álibis a serem verificados.\n13:00: O almoço é servido. Sr. Blackwood novamente não aparece.\n14:00: Sra. Blackwood, demonstrando crescente preocupação, pede a Sr. Croft que vá verificar pessoalmente o Sr. Blackwood em seu laboratório.\n14:05: Sr. Croft dirige-se ao laboratório. Encontra a porta especial entreaberta. A fechadura de alta segurança parece ter sido arranhada (marcas de tentativa de arrombamento), mas está destrancada (possivelmente aberta corretamente após a tentativa de arrombamento). O interior do laboratório está em grande desordem: papéis e diagramas espalhados pelo chão, algumas ferramentas fora do lugar, uma cadeira virada. Sr. Blackwood não está em lugar nenhum. A janela dos fundos do laboratório está destrancada e aberta. Não há sinais óbvios de luta violenta (ex: sangue).\n14:15: Sra. Blackwood, após ser informada por Sr. Croft, instrui-o a chamar a polícia local.\n17:00: A notícia do desaparecimento e a natureza peculiar do caso chegam aos ouvidos de Hercule Poirot, que está concluindo um caso em uma cidade vizinha. Ele informa que só poderá dedicar-se ao mistério da Mansão Hollow na manhã seguinte. (Vocês têm até lá para resolver!)\n\n4. Depoimentos Iniciais (Coletados apressadamente pelo Sargento Davis, da polícia local):\n\nSra. Eleanor Clithering:\n\n“Arthur estava impossível nas últimas semanas, totalmente absorvido pelo tal projeto ‘Quimera’. Falava coisas sem sentido sobre revolucionar o mundo, mas também sobre pessoas que queriam roubá-lo. Ele sempre foi um pouco… dramático.”\n“Quando bati à porta do laboratório às 11:00, ouvi claramente Arthur dizer para não ser perturbado. Sim, a voz parecia um pouco abafada, mas era ele. Dr. Finch estava ao meu lado.”\n“Depois disso, subi para meus aposentos para descansar e escrever algumas cartas. Não vi mais o Dr. Finch até a hora do almoço.”\n“A fechadura do laboratório é uma invenção do próprio Arthur. Apenas ele possuía a chave mestra. Ouvi dizer que Clara talvez soubesse algum truque para abri-la, mas forçá-la… faria um barulho terrível, não acha?”\n“Desaparecer assim… não é do feitio de Arthur, a menos que seja parte de algum plano mirabolante dele. Ou então algo terrível aconteceu.”\n\nDr. Alistair Finch:\n\n“Eu vim em uma missão de paz, acreditem. Nossas divergências passadas foram puramente intelectuais. Eu esperava que pudéssemos colaborar. A ideia de roubar o trabalho de Arthur é um insulto.”\n“Sim, a Sra. Blackwood me acompanhou até a porta do laboratório. Ouvi uma voz masculina dizer para não sermos inoportunos. Não posso jurar que era Arthur, a voz estava abafada, como disse a Sra. Blackwood.”\n“Após a recusa, senti-me um pouco desconfortável. Decidi caminhar pelos jardins para espairecer, entre aproximadamente 11:05 e 12:45. Andei pela frente da casa e também pelo jardim lateral, perto do gazebo. O tempo estava agradável.”\n“Não vi ninguém suspeito. Vi o mordomo, Sr. Croft, por um instante, perto da entrada lateral da casa, por volta das 11:20. Ele parecia estar carregando uma caixa ou algo similar em direção à parte de trás da casa ou à adega.”\n“Eu nunca tocaria na fechadura do laboratório de Arthur sem permissão. Seria uma violação imperdoável da ética científica.”\n\nMiss Clara Evans:\n\n“Sr. Blackwood estava muito pressionado, mas também excitado com o ‘Quimera’. Ele dizia que mudaria tudo. Ele confiava em mim implicitamente.”\n“Sim, ele temia que o Dr. Finch, ou outros, pudessem tentar se apropriar de suas descobertas. Ele tomava muitas precauções.”\n“Quando levei seu café às 09:00, ele estava um pouco agitado, mas lúcido. Disse-me: ‘Clara, hoje é um dia de grandes decisões. Lembre-se dos nossos protocolos.’”\n“Entre 11:00 e 13:00, estive principalmente no escritório anexo ao laboratório, compilando dados. A porta entre o escritório e o laboratório estava fechada na maior parte do tempo para que ele tivesse silêncio. Saí brevemente, por volta das 11:30, para ir à biblioteca buscar o ‘Compêndio de Ligas Metálicas Raras’. Fiquei lá uns 15, talvez 20 minutos. Não cruzei com ninguém no corredor ou na biblioteca.”\n“O laboratório tem um bom isolamento acústico, especialmente com a porta do escritório fechada. Não ouvi nenhum barulho de arrombamento. A fechadura especial é complexa; apenas Sr. Blackwood tinha a chave. Eu conheço o procedimento de abertura manual de emergência, mas é uma sequência demorada e específica.”\n\nSr. Reginald “Reggie” Croft (Mordomo):\n\n“Dr. Finch chegou às 10:00. Parecia um pouco nervoso, na minha opinião. Ele e a patroa conversaram na sala de estar por um bom tempo.”\n“Por volta das 11:00, eu estava no hall polindo a prata, e ouvi as vozes da Sra. Blackwood e do Dr. Finch perto do corredor do laboratório. Não prestei muita atenção ao que foi dito. Logo depois, vi a Sra. Blackwood subir a escadaria principal.”\n“De fato, por volta das 11:15, eu estava transportando uma caixa de garrafas de vinho da entrada de serviço lateral para a adega no porão. Nesse momento, vi o Dr. Finch caminhando pelo jardim da frente, perto do portão principal. Ele olhava muito para o relógio.”\n“Quando fui chamado pela Sra. Blackwood às 14:00, encontrei a porta do laboratório como descrito: entreaberta, com arranhões na fechadura, mas destrancada. O Sr. Blackwood era metódico. Se ele não queria ser perturbado, ele trancava a porta de uma forma que ninguém entraria.”\n\nSra. Beatrice Croft (Cozinheira):\n\n“Da cozinha, não se ouve muito do resto da casa, a menos que seja uma gritaria. Estive ocupada com o almoço toda a manhã.”\n“Sr. Blackwood não aparecer para as refeições não era novidade quando estava às voltas com suas invenções malucas.”\n“Uma coisa estranha: Miss Evans passou rapidamente pela cozinha por volta das 12:50. Parecia muito pálida e apressada. Perguntei se estava tudo bem, e ela murmurou algo sobre ir verificar se o Sr. Blackwood queria que o almoço fosse servido no laboratório. Ela voltou alguns minutos depois, ainda mais pálida, e disse que ele não tinha respondido aos chamados dela na porta do laboratório e que era melhor não insistir. Achei estranho ela não ter comentado isso com a Sra. Blackwood imediatamente, antes do alarme oficial.”\n“A janela do laboratório? Sim, dá para uma parte mais isolada d-o jardim dos fundos, perto da minha horta. Se alguém pulou por ali, e se esgueirou pelas árvores, poderia sumir sem ser visto da casa principal.”\n\n\n5. Pistas e Bilhetes Enigmáticos:\n\nPista 1: Papel Amassado na Lixeira do Laboratório: Um pequeno pedaço de papel de anotações, claramente arrancado de um bloco maior, contém a seguinte mensagem escrita à mão por Sr. Blackwood (caligrafia confirmada):\n\n“Se A implica B, e o Corvo visita o Ninho, então a Hipótese se confirma. A negação do consequente é o único caminho seguro. Sigma Ativado.”\n\nPista 2: Objeto Encontrado no Chão do Laboratório, Perto da Mesa Principal: Um pequeno e incomum botão de metal fosco, com um desenho de uma engrenagem estilizada. Não parece pertencer a nenhuma roupa do Sr. Blackwood, nem faz parte do vestuário usual dos funcionários.\nPista 3: Anotação na Margem de um Livro na Biblioteca: No livro “Compêndio de Ligas Metálicas Raras” (o mesmo que Clara Evans mencionou ter pego), na página sobre o Bismuto, há uma pequena anotação a lápis, quase imperceptível:\n\n“Onde o passado encontra o futuro, a reflexão é a chave. \\((\\neg P \\lor Q)\\) é equivalente a ?” A caligrafia parece ser de Sr. Blackwood.\n\nPista 4: Marca Estranha no Batente da Janela Aberta do Laboratório: Do lado de fora do batente da janela do laboratório, há uma leve marca de fuligem ou graxa escura, como se algo metálico e sujo tivesse sido apoiado ali brevemente.\nPista 5: Na Estufa Abandonada (Jardim dos Fundos): Dentro da estufa, sobre uma bancada empoeirada, alguém desenhou com o dedo na poeira um símbolo: um triângulo equilátero com um pequeno círculo no centro. Ao lado do desenho, um único fósforo queimado. Não há outras pegadas recentes visíveis devido ao solo irregular e coberto de folhas secas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Problemas Interessantes Resolvidos com **Lógica Proposicional** e Predicativa</span>"
    ]
  },
  {
    "objectID": "apendice-a-glossario.html",
    "href": "apendice-a-glossario.html",
    "title": "12  Glossário",
    "section": "",
    "text": "Álgebra de Boole: Sistema algébrico usado na lógica matemática, baseado nos valores verdadeiro (1) e falso (0).\nAntecedente: Em uma implicação \\(P \\rightarrow Q\\), \\(P\\) é o antecedente.\nAridade: Número de argumentos que uma função ou predicado aceita.\nArgumento: Lista de proposições (premissas) seguidas de uma conclusão.\nAssociatividade: Propriedade onde \\((a * b) * c = a * (b * c)\\) para um operador \\(*\\).\nÁtomo: Proposição indivisível ou predicado aplicado a termos em uma fórmula.\nAxioma: Fórmula ou proposição aceita como verdadeira sem necessidade de demonstração.\nBicondicional (\\(\\leftrightarrow\\)): Operador lógico que indica equivalência entre duas proposições.\nCardinalidade: Número de elementos em um conjunto.\nCláusula: Disjunção de literais, como \\(P \\vee Q \\vee \\neg R\\).\nCláusula de Horn: Disjunção de literais com no máximo um literal positivo.\nComutatividade: Propriedade onde \\(a * b = b * a\\) para um operador \\(*\\).\nConclusão: Em um argumento, a proposição final que se deriva das premissas.\nConjunção (\\(\\wedge\\)): Operador lógico “E”.\nConsequente: Em uma implicação \\(P \\rightarrow Q\\), \\(Q\\) é o consequente.\nConstante: Símbolo que representa um objeto específico no domínio do discurso.\nConstante de Skolem: Termo introduzido para eliminar quantificadores existenciais.\nContradição: Fórmula que é sempre falsa, independentemente dos valores de suas variáveis.\nContrapositiva: Para uma implicação \\(P \\rightarrow Q\\), sua contrapositiva é \\(\\neg Q \\rightarrow \\neg P\\).\nDedução: Processo de derivar conclusões lógicas a partir de premissas.\nDisjunção (\\(\\vee\\)): Operador lógico “OU”.\nDistributividade: Propriedade onde \\(a * (b + c) = (a * b) + (a * c)\\) para operadores \\(*\\) e \\(+\\).\nDomínio do Discurso: Conjunto de objetos sobre os quais as variáveis quantificadas podem se referir.\nDupla Negação: Princípio onde \\(\\neg \\neg P \\equiv P\\).\nEquivalência Lógica (\\(\\equiv\\)): Relação entre duas fórmulas que têm o mesmo valor verdade para todas as interpretações.\nEscopo: Parte de uma fórmula à qual um quantificador ou operador se aplica.\nFato: Na programação lógica, afirmação considerada verdadeira sem condições.\nFalseabilidade: Propriedade de uma hipótese que pode ser provada falsa.\nForma Normal Conjuntiva (FNC): Fórmula que é uma conjunção de cláusulas, onde cada cláusula é uma disjunção de literais.\nForma Normal Disjuntiva (FND): Fórmula que é uma disjunção de conjunções de literais.\nForma Normal Negativa (FNN): Fórmula onde as negações aparecem apenas imediatamente antes das variáveis proposicionais.\nForma Normal Prenex: Fórmula onde todos os quantificadores estão no início, seguidos por uma matriz sem quantificadores.\nForma Normal Skolem: Forma Normal Prenex onde todos os quantificadores existenciais foram eliminados.\nFórmula Atômica: Fórmula que consiste em um predicado aplicado a termos.\nFórmula Bem Formada: Sequência de símbolos que segue as regras de formação da linguagem lógica.\nFunção: Mapeamento de um conjunto de argumentos para um valor único.\nFunção de Skolem: Função introduzida para eliminar quantificadores existenciais que dependem de variáveis universalmente quantificadas.\nIdempotência: Propriedade onde \\(a * a = a\\) para um operador \\(*\\).\nImplicação (\\(\\rightarrow\\)): Operador lógico “SE…ENTÃO”.\nIndução Matemática: Método de prova que envolve um caso base e um passo indutivo.\nInferência: Processo de derivar novas informações a partir de informações existentes.\nInstanciação: Substituição de uma variável por um termo específico.\nInterpretação: Atribuição de significado aos símbolos de uma linguagem formal.\nLeis de De Morgan: \\(\\neg(P \\wedge Q) \\equiv (\\neg P \\vee \\neg Q)\\) e \\(\\neg(P \\vee Q) \\equiv (\\neg P \\wedge \\neg Q)\\).\nLema: Proposição auxiliar demonstrável utilizada como passo intermediário na prova de um teorema.\nLiteral: Variável proposicional ou sua negação.\nLógica de Primeira Ordem: Sistema formal para representar e raciocinar sobre propriedades de objetos e relações entre eles.\nLógica Proposicional: Sistema lógico que lida com proposições e suas inter-relações.\nMeta-linguagem: Linguagem usada para descrever outra linguagem.\nModelo: Interpretação que satisfaz um conjunto de fórmulas.\nModus Ponens: Regra de inferência: \\(P, P \\rightarrow Q \\vdash Q\\).\nModus Tollens: Regra de inferência: \\(\\neg Q, P \\rightarrow Q \\vdash \\neg P\\).\nNegação (\\(\\neg\\)): Operador lógico que inverte o valor de verdade de uma proposição.\nPredicado: Função que mapeia objetos a valores de verdade.\nPremissa: Proposição a partir da qual se deriva uma conclusão em um argumento.\nProlog: Linguagem de programação baseada na Lógica de Primeira Ordem e Cláusulas de Horn.\nProva: Sequência de passos lógicos que demonstra a verdade de uma proposição.\nQuantificador Existencial (\\(\\exists\\)): Símbolo lógico que significa “existe pelo menos um”.\nQuantificador Universal (\\(\\forall\\)): Símbolo lógico que significa “para todo”.\nRecíproca: Para uma implicação \\(P \\rightarrow Q\\), sua recíproca é \\(Q \\rightarrow P\\).\nRedução ao Absurdo: Método de prova que assume a negação da conclusão e deriva uma contradição.\nRefutação: Prova da falsidade de uma proposição.\nRegra: Na programação lógica, implicação que define como derivar novos fatos.\nResolução: Regra de inferência usada em provas automatizadas.\nSatisfatibilidade: Propriedade de uma fórmula que é verdadeira para pelo menos uma interpretação.\nSemântica: Estudo do significado em linguagens formais e naturais.\nSilogismo: Forma de raciocínio dedutivo com duas premissas e uma conclusão.\nSintaxe: Conjunto de regras que definem as sequências bem formadas em uma linguagem.\nSkolemização: Processo de eliminação de quantificadores existenciais em uma fórmula lógica.\nTabela Verdade: Tabela que mostra os valores de verdade de uma fórmula para todas as combinações possíveis de seus componentes.\nTautologia: Fórmula que é sempre verdadeira, independentemente dos valores de suas variáveis.\nTeoria: Conjunto de fórmulas em um sistema lógico.\nTeorema: Afirmação que pode ser provada como verdadeira dentro de um sistema lógico.\nTermo: Constante, variável ou função aplicada a outros termos.\nUnificação: Processo de encontrar substituições que tornam dois termos idênticos.\nUniverso de Herbrand: Conjunto de todos os termos básicos que podem ser construídos a partir das constantes e funções de uma linguagem de primeira ordem.\nUniverso do Discurso: Conjunto de todas as entidades sobre as quais as variáveis em uma fórmula lógica podem assumir valores.\nValidade: Propriedade de um argumento onde a conclusão é verdadeira sempre que todas as premissas são verdadeiras.\nVariável: Símbolo que representa um objeto não especificado no domínio do discurso.\nVariável Livre: Variável em uma fórmula que não está ligada a nenhum quantificador.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Glossário</span>"
    ]
  },
  {
    "objectID": "apendice-b-referencias.html",
    "href": "apendice-b-referencias.html",
    "title": "13  Referências",
    "section": "",
    "text": "BOOLOS, G.; BURGESS, J.; JEFFREY, R. Computability and Logic. 5. ed. Cambridge: Cambridge University Press, 2007.\nCHANG, C.C.; KEISLER, H.J. Model Theory. Amsterdam: North-Holland, 1990.\nEBBINGHAUS, H.D.; FLUM, J. Finite Model Theory. 2. ed. Berlin: Springer, 2006.\nGALLIER, J.H. Logic for Computer Science: Foundations of Automatic Theorem Proving. 2. ed. Mineola: Dover Publications, 2015.\nGENESERETH, M.; NILSSON, N. Logical Foundations of Artificial Intelligence. San Francisco: Morgan Kaufmann, 1987.\nINTERNATIONAL MONETARY FUND. World Economic Outlook, October 2023: Navigating Global Divergences. IMF, out. 2023. Disponível em: https://www.imf.org/en/Publications/WEO/Issues/2023/10/10/world-economic-outlook-october-2023. Acesso em: 17 mai. 2025.\nKRIPKE, S. Naming and Necessity. Cambridge: Harvard University Press, 1980.\nMANNA, Z. Verification of Computer Programs. Cambridge: MIT Press, 1974.\nMDPI BLOG. Five Breakthrough Moments in Science and Technology in 2022. MDPI Blog, 23 jan. 2023. Disponível em: https://blog.mdpi.com/2023/01/23/breakthroughs-in-2022/. Acesso em: 17 mai. 2025.\nMIT TECHNOLOGY REVIEW. 10 Breakthrough Technologies 2022. MIT Technology Review, 23 fev. 2022. Disponível em: https://www.technologyreview.com/2022/02/23/1045416/10-breakthrough-technologies-2022/. Acesso em: 17 mai. 2025.\nQUINE, W.V.O. Word and Object. Cambridge: MIT Press, 1960.\nRUSSELL, S.; NORVIG, P. Artificial Intelligence: A Modern Approach. 4. ed. Upper Saddle River: Pearson, 2020.\nVAN HARMELEN, F.; LIFSCHITZ, V.; PORTER, B. (Ed.). Handbook of Knowledge Representation. Amsterdam: Elsevier, 2008.\nWIRTH, N. Algorithms + Data Structures = Programs. 3. ed. Englewood Cliffs: Prentice-Hall, 1976.\n\nAPT, Krzysztof R. Ten years of Hoare’s logic: a survey. ACM Transactions on Programming Languages and Systems, New York, v. 3, n. 4, p. 431-483, Oct. 1981.\nBERTOT, Yves; CASTÉRAN, Pierre. Interactive Theorem Proving and Program Development: Coq’Art: The Calculus of Inductive Constructions. Berlin: Springer, 2004. 469 p.\nBURSTALL, Rod M. Proving properties of programs by structural induction. The Computer Journal, Oxford, v. 12, n. 1, p. 41-48, Feb. 1969.\nDIJKSTRA, Edsger W. A discipline of programming. Englewood Cliffs: Prentice-Hall, 1976.\nFLOYD, Robert W. Assigning meaning to programs. In: SCHWARTZ, J. T. (Ed.). Mathematical Aspects of Computer Science. Providence: American Mathematical Society, 1967. p. 19-32.\nHOARE, Charles Antony Richard. An axiomatic basis for computer programming. Communications of the ACM, New York, v. 12, n. 10, p. 576-580, Oct. 1969.\nLEINO, K. Rustan M. Efficient weakest preconditions. Information Processing Letters, Amsterdam, v. 93, n. 6, p. 281-288, Mar. 2005.\nNIPKOW, Tobias; KLEIN, Gerwin. Concrete Semantics: With Isabelle/HOL. Cham: Springer, 2014. 298 p.\nPIERCE, Benjamin C. et al. Software Foundations. University of Pennsylvania, 2018. Disponível em: https://softwarefoundations.cis.upenn.edu/. Acesso em: 14 jul. 2025.\nREYNOLDS, John C. Theories of Programming Languages. Cambridge: Cambridge University Press, 1998. 513 p.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Referências</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html",
    "href": "Solucao-Exercicios.html",
    "title": "14  Solução dos Exercícios",
    "section": "",
    "text": "14.1 Section 14.1",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html#sec-logica-proposicional",
    "href": "Solucao-Exercicios.html#sec-logica-proposicional",
    "title": "14  Solução dos Exercícios",
    "section": "",
    "text": "14.1.1 Exercícios: Sintaxe e Fórmulas Bem Formadas\n\nSolução:\n\n\nVariáveis: \\(x\\)\nConstantes: \\(a\\)\nPredicados: \\(P\\), \\(Q\\)\nConectivos: \\(\\rightarrow\\)\nQuantificadores: \\(\\forall\\)\n\n\nSolução:\n\n\nVariáveis: \\(y\\)\nConstantes: \\(c\\)\nSímbolos de função: \\(f\\)\nPredicados: \\(R\\)\nQuantificadores: \\(\\exists\\)\n\n\nSolução:\n\n\nVariáveis: \\(x\\), \\(y\\)\nConstantes: \\(b\\)\nSímbolos de função: \\(f\\)\nPredicados: \\(P\\), \\(S\\), \\(R\\)\nConectivos: \\(\\land\\), \\(\\rightarrow\\)\nQuantificadores: \\(\\forall\\), \\(\\exists\\)\n\n\nSolução: Sim, é uma Fórmula Bem Formada (FBF). Justificativa: \\(a\\), \\(f(b)\\) e \\(c\\) são termos. \\(P\\) é um símbolo de predicado de aridade 3, aplicado a 3 termos, formando a fórmula atômica \\(P(a, f(b), c)\\). O operador de negação \\(\\neg\\) é aplicado a esta fórmula atômica, o que é uma regra de formação válida.\nSolução: Não, não é uma Fórmula Bem Formada (FBF). Justificativa: Falta um conectivo lógico (como \\(\\land\\), \\(\\lor\\), \\(\\rightarrow\\)) entre as fórmulas \\(\\forall x P(x)\\) e \\(Q(a)\\). Duas fórmulas devem ser unidas por um conectivo para formar uma nova fórmula.\nSolução: Não, não é uma Fórmula Bem Formada (FBF). Justificativa: \\(f(x)\\) é um termo, não uma fórmula. Conectivos lógicos como \\(\\rightarrow\\) devem conectar fórmulas. Um termo não pode ser um dos lados de uma implicação.\nSolução: Sim, é uma Fórmula Bem Formada (FBF). Justificativa: \\(P(x)\\) é uma fórmula atômica e \\(\\forall y Q(y)\\) também é uma fórmula. Elas estão corretamente unidas pelo conectivo \\(\\lor\\). Não, ela não é uma sentença. Uma sentença é uma FBF que não possui variáveis livres. Nesta fórmula, a variável \\(x\\) no predicado \\(P(x)\\) é uma variável livre, pois não está no escopo de nenhum quantificador (\\(\\forall x\\) ou \\(\\exists x\\)).\nSolução: Não, não é uma Fórmula Bem Formada (FBF). Justificativa: Os argumentos de um predicado devem ser termos (variáveis, constantes ou funções). Um quantificador como \\(\\forall x\\) não é um termo e não pode aparecer dentro dos parênteses de um predicado.\nSolução: Sim, é uma Fórmula Bem Formada (FBF). Justificativa: A estrutura segue todas as regras. \\(\\exists x P(f(z), x)\\) é uma FBF, sua negação também é. \\(R(z)\\) é uma FBF. As duas estão corretamente conectadas pelo bicondicional \\(\\leftrightarrow\\), e toda a expressão está corretamente no escopo do quantificador \\(\\forall z\\).\nSolução: Não, não é uma Fórmula Bem Formada (FBF). Justificativa: A expressão dentro dos parênteses, \\((P(x) \\land )\\), está sintaticamente incorreta. O conectivo de conjunção \\(\\land\\) é binário e requer uma fórmula em ambos os lados. Ele não pode ser seguido por um parêntese de fechamento.\n\n\n\n14.1.2 Exercícios: Tabelas-Verdade e Conectivos Lógicos\n(Nota: Usaremos V para Verdadeiro e F para Falso nas tabelas.)\n\nSolução para \\(P \\rightarrow \\neg Q\\): | \\(P\\) | \\(Q\\) | \\(\\neg Q\\) | \\(P \\rightarrow \\neg Q\\) | |:—:|:—:|:—:|:—:| | V | V | F | F | | V | F | V | V | | F | V | F | V | | F | F | V | V |\nSolução para \\((P \\lor Q) \\land R\\): | \\(P\\) | \\(Q\\) | \\(R\\) | \\(P \\lor Q\\) | \\((P \\lor Q) \\land R\\) | |:—:|:—:|:—:|:—:|:—:| | V | V | V | V | V | | V | V | F | V | F | | V | F | V | V | V | | V | F | F | V | F | | F | V | V | V | V | | F | V | F | V | F | | F | F | V | F | F | | F | F | F | F | F |\nSolução para \\(P \\leftrightarrow (P \\land Q)\\): | \\(P\\) | \\(Q\\) | \\(P \\land Q\\) | \\(P \\leftrightarrow (P \\land Q)\\) | |:—:|:—:|:—:|:—:| | V | V | V | V | | V | F | F | F | | F | V | F | V | | F | F | F | V |\nSolução para \\((P \\land (P \\rightarrow Q)) \\rightarrow Q\\): (Esta é a forma lógica do Modus Ponens) | \\(P\\) | \\(Q\\) | \\(P \\rightarrow Q\\) | \\(P \\land (P \\rightarrow Q)\\) | \\((P \\land (P \\rightarrow Q)) \\rightarrow Q\\) | |:—:|:—:|:—:|:—:|:—:| | V | V | V | V | V | | V | F | F | F | V | | F | V | V | F | V | | F | F | V | F | V | Conclusão: A fórmula é uma tautologia, pois a coluna final contém apenas V.\nSolução para \\((P \\rightarrow Q) \\land (P \\land \\neg Q)\\): | \\(P\\) | \\(Q\\) | \\(P \\rightarrow Q\\) | \\(\\neg Q\\) | \\(P \\land \\neg Q\\) | \\((P \\rightarrow Q) \\land (P \\land \\neg Q)\\) | |:—:|:—:|:—:|:—:|:—:|:—:| | V | V | V | F | F | F | | V | F | F | V | V | F | | F | V | V | F | F | F | | F | F | V | V | F | F | Conclusão: A fórmula é uma contradição, pois a coluna final contém apenas F.\nSolução para \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\): (Esta é a Lei da Contrapositiva) | \\(P\\) | \\(Q\\) | \\(P \\rightarrow Q\\) | \\(\\neg Q\\) | \\(\\neg P\\) | \\(\\neg Q \\rightarrow \\neg P\\) | \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\) | |:—:|:—:|:—:|:—:|:—:|:—:|:—:| | V | V | V | F | F | V | V | | V | F | F | V | F | F | V | | F | V | V | F | V | V | V | | F | F | V | V | V | V | V | Conclusão: A fórmula é uma tautologia, mostrando que uma implicação e sua contrapositiva são logicamente equivalentes.\nSolução para \\((A \\rightarrow B) \\lor (B \\rightarrow C)\\): | \\(A\\) | \\(B\\) | \\(C\\) | \\(A \\rightarrow B\\) | \\(B \\rightarrow C\\) | \\((A \\rightarrow B) \\lor (B \\rightarrow C)\\) | |:—:|:—:|:—:|:—:|:—:|:—:| | V | V | V | V | V | V | | V | V | F | V | F | V | | V | F | V | F | V | V | | V | F | F | F | V | V | | F | V | V | V | V | V | | F | V | F | V | F | V | | F | F | V | V | V | V | | F | F | F | V | V | V | Conclusão: Esta fórmula é uma tautologia.\nSolução para \\(\\neg(P \\land Q) \\leftrightarrow (\\neg P \\lor \\neg Q)\\): (Esta é uma das Leis de De Morgan) | \\(P\\) | \\(Q\\) | \\(P \\land Q\\) | \\(\\neg(P \\land Q)\\) | \\(\\neg P\\) | \\(\\neg Q\\) | \\(\\neg P \\lor \\neg Q\\) | \\(\\neg(P \\land Q) \\leftrightarrow (\\neg P \\lor \\neg Q)\\) | |:—:|:—:|:—:|:—:|:—:|:—:|:—:|:—:| | V | V | V | F | F | F | F | V | | V | F | F | V | F | V | V | V | | F | V | F | V | V | F | V | V | | F | F | F | V | V | V | V | V | Conclusão: A fórmula é uma tautologia, confirmando a validade da Lei de De Morgan.\nSolução para o argumento:\n\n\nPremissa 1: Se o programa é eficiente, o custo é baixo (\\(P \\rightarrow Q\\)).\nPremissa 2: O programa é eficiente (\\(P\\)).\nConclusão: O custo é baixo (\\(Q\\)).\nFórmula a ser testada: \\(((P \\rightarrow Q) \\land P) \\rightarrow Q\\). Esta é a mesma fórmula do exercício 4. | \\(P\\) | \\(Q\\) | \\(P \\rightarrow Q\\) | \\((P \\rightarrow Q) \\land P\\) | \\(((P \\rightarrow Q) \\land P) \\rightarrow Q\\) | |:—:|:—:|:—:|:—:|:—:| | V | V | V | V | V | | V | F | F | F | V | | F | V | V | F | V | | F | F | V | F | V | Conclusão: Como a fórmula que representa o argumento é uma tautologia, o argumento é válido.\n\n\nSolução para \\((P \\lor Q) \\rightarrow (P \\land Q)\\): | \\(P\\) | \\(Q\\) | \\(P \\lor Q\\) | \\(P \\land Q\\) | \\((P \\lor Q) \\rightarrow (P \\land Q)\\) | |:—:|:—:|:—:|:—:|:—:| | V | V | V | V | V | | V | F | V | F | F | | F | V | V | F | F | | F | F | F | F | V | Conclusão: A fórmula é contingente (satisfatível e falsificável).\n\n\n\n14.1.3 Exercícios: Simplificação com Equivalências Lógicas\n\nSolução para $ (P Q) $:\n\n\\[\n\\begin{align*}\n\\neg(P \\lor \\neg Q) &\\equiv \\neg P \\land \\neg(\\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv \\neg P \\land Q && \\text{Lei da Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para $ P (P Q) $: (Esta é a Lei da Absorção)\n\n\\[\n\\begin{align*}\nP \\lor (P \\land Q) &\\equiv (P \\land TRUE) \\lor (P \\land Q) && \\text{Lei da Identidade} \\\\\n&\\equiv P \\land (TRUE \\lor Q) && \\text{Lei da Distributividade} \\\\\n&\\equiv P \\land TRUE && \\text{Lei do Domínio} \\\\\n&\\equiv P && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para $ (P Q) $:\n\n\\[\n\\begin{align*}\n\\neg(P \\rightarrow \\neg Q) &\\equiv \\neg(\\neg P \\lor \\neg Q) && \\text{Definição de Implicação} \\\\\n&\\equiv \\neg(\\neg P) \\land \\neg(\\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv P \\land Q && \\text{Lei da Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para $ (P Q) (P Q) $:\n\n\\[\n\\begin{align*}\n(P \\lor Q) \\land (\\neg P \\lor Q) &\\equiv (Q \\lor P) \\land (Q \\lor \\neg P) && \\text{Lei da Comutatividade} \\\\\n&\\equiv Q \\lor (P \\land \\neg P) && \\text{Lei da Distributividade} \\\\\n&\\equiv Q \\lor FALSE && \\text{Lei da Contradição} \\\\\n&\\equiv Q && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para $ (P Q) (Q P) $:\n\n\\[\n\\begin{align*}\n(P \\rightarrow Q) \\lor (Q \\rightarrow P) &\\equiv (\\neg P \\lor Q) \\lor (\\neg Q \\lor P) && \\text{Definição de Implicação} \\\\\n&\\equiv (\\neg P \\lor P) \\lor (Q \\lor \\neg Q) && \\text{Leis da Associatividade e Comutatividade} \\\\\n&\\equiv TRUE \\lor TRUE && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Idempotência da Disjunção}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\nSolução para $ (P Q) $: (Esta é a definição de “ou exclusivo”, XOR)\n\n\\[\n\\begin{align*}\n\\neg(P \\leftrightarrow Q) &\\equiv \\neg((P \\rightarrow Q) \\land (Q \\rightarrow P)) && \\text{Definição de Equivalência} \\\\\n&\\equiv \\neg(P \\rightarrow Q) \\lor \\neg(Q \\rightarrow P) && \\text{Lei de De Morgan} \\\\\n&\\equiv \\neg(\\neg P \\lor Q) \\lor \\neg(\\neg Q \\lor P) && \\text{Definição de Implicação} \\\\\n&\\equiv (P \\land \\neg Q) \\lor (Q \\land \\neg P) && \\text{Lei de De Morgan e Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para $ (P Q) (P Q) $:\n\n\\[\n\\begin{align*}\n(P \\land Q) \\rightarrow (P \\lor Q) &\\equiv \\neg(P \\land Q) \\lor (P \\lor Q) && \\text{Definição de Implicação} \\\\\n&\\equiv (\\neg P \\lor \\neg Q) \\lor (P \\lor Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv (\\neg P \\lor P) \\lor (\\neg Q \\lor Q) && \\text{Leis da Associatividade e Comutatividade} \\\\\n&\\equiv TRUE \\lor TRUE && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Idempotência da Disjunção}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\nSolução para $ (P Q) (P Q) $:\n\n\\[\n\\begin{align*}\n(P \\lor Q) \\land \\neg(\\neg P \\land Q) &\\equiv (P \\lor Q) \\land (\\neg(\\neg P) \\lor \\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv (P \\lor Q) \\land (P \\lor \\neg Q) && \\text{Lei da Dupla Negação} \\\\\n&\\equiv P \\lor (Q \\land \\neg Q) && \\text{Lei da Distributividade} \\\\\n&\\equiv P \\lor FALSE && \\text{Lei da Contradição} \\\\\n&\\equiv P && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para $ (A B) (A B) $:\n\n\\[\n\\begin{align*}\n(A \\land \\neg B) \\lor (A \\lor \\neg B) &\\equiv (A \\lor (A \\lor \\neg B)) \\land (\\neg B \\lor (A \\lor \\neg B)) && \\text{Lei da Distributividade} \\\\\n&\\equiv (A \\lor A \\lor \\neg B) \\land (\\neg B \\lor \\neg B \\lor A) && \\text{Lei da Associatividade (e Comutatividade)} \\\\\n&\\equiv (A \\lor \\neg B) \\land (\\neg B \\lor A) && \\text{Lei da Idempotência} \\\\\n&\\equiv (A \\lor \\neg B) \\land (A \\lor \\neg B) && \\text{Lei da Comutatividade} \\\\\n&\\equiv A \\lor \\neg B && \\text{Lei da Idempotência}\n\\end{align*}\n\\]\nObservação: apesar de a aplicação da distributividade ser válida, o passo inicial pode parecer confuso. Um método mais direto é reconhecer que $ (A B) (A B) $ é equivalente a $ A B $, pois $ A B $ já cobre todas as possibilidades onde $ A B $ é verdadeiro.\nResultado final: $ A B $\n\nSolução para $ ((P Q) (Q R)) (P R) $:\n\n\\[\n\\begin{align*}\n&((P \\rightarrow Q) \\land (Q \\rightarrow R)) \\rightarrow (P \\rightarrow R) \\\\\n&\\equiv \\neg ((\\neg P \\lor Q) \\land (\\neg Q \\lor R)) \\lor (\\neg P \\lor R) && \\text{Definição de Implicação (3x)} \\\\\n&\\equiv (\\neg(\\neg P \\lor Q) \\lor \\neg(\\neg Q \\lor R)) \\lor (\\neg P \\lor R) && \\text{Lei de De Morgan} \\\\\n&\\equiv ((P \\land \\neg Q) \\lor (Q \\land \\neg R)) \\lor (\\neg P \\lor R) && \\text{De Morgan e Dupla Negação} \\\\\n&\\equiv (P \\land \\neg Q) \\lor (Q \\land \\neg R) \\lor \\neg P \\lor R && \\text{Lei da Associatividade} \\\\\n&\\equiv ((P \\land \\neg Q) \\lor \\neg P) \\lor ((Q \\land \\neg R) \\lor R) && \\text{Comutatividade e Associatividade} \\\\\n&\\equiv ((P \\lor \\neg P) \\land (\\neg Q \\lor \\neg P)) \\lor ((Q \\lor R) \\land (\\neg R \\lor R)) && \\text{Lei da Distributividade (2x)} \\\\\n&\\equiv (TRUE \\land (\\neg Q \\lor \\neg P)) \\lor ((Q \\lor R) \\land TRUE) && \\text{Lei do Terceiro Excluído (2x)} \\\\\n&\\equiv (\\neg Q \\lor \\neg P) \\lor (Q \\lor R) && \\text{Lei da Identidade (2x)} \\\\\n&\\equiv (\\neg Q \\lor Q) \\lor (\\neg P \\lor R) && \\text{Comutatividade e Associatividade} \\\\\n&\\equiv TRUE \\lor (\\neg P \\lor R) && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Lei do Domínio}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\n\n14.1.4 Exercícios: Provas com Regras de Inferência\n\nSolução:\n\\(P \\rightarrow Q\\) (Premissa 1)\n\\(P\\) (Premissa 2)\n\\(Q\\) (1, 2, Modus Ponens)\nSolução:\n\\(A \\rightarrow B\\) (Premissa 1)\n\\(\\neg B\\) (Premissa 2)\n\\(\\neg A\\) (1, 2, Modus Tollens)\nSolução:\n\\(P \\land Q\\) (Premissa 1)\n\\(P \\rightarrow R\\) (Premissa 2)\n\\(P\\) (1, Simplificação)\n\\(R\\) (2, 3, Modus Ponens)\nSolução:\n\\(S \\rightarrow \\neg T\\) (Premissa 1)\n\\(T\\) (Premissa 2)\n\\(S \\lor U\\) (Premissa 3)\n\\(\\neg\\neg T\\) (2, Dupla Negação)\n\\(\\neg S\\) (1, 4, Modus Tollens)\n\\(U\\) (3, 5, Silogismo Disjuntivo / Modus Tollendo Ponens)\nSolução:\n\\(A\\) (Premissa 1)\n\\(B\\) (Premissa 2)\n\\((A \\land B) \\rightarrow C\\) (Premissa 3)\n\\(A \\land B\\) (1, 2, Adjunção)\n\\(C\\) (3, 4, Modus Ponens)\nSolução:\n\\(P \\rightarrow Q\\) (Premissa 1)\n\\(Q \\rightarrow R\\) (Premissa 2)\n\\(P \\rightarrow R\\) (1, 2, Silogismo Hipotético) (Nota: Esta é uma aplicação direta da regra de inferência Silogismo Hipotético.)\nSolução:\n\\(A \\rightarrow B\\) (Premissa 1)\n\\(C \\rightarrow D\\) (Premissa 2)\n\\(A \\lor C\\) (Premissa 3)\n\\(B \\lor D\\) (1, 2, 3, Dilema Construtivo)\n\n(Nota: Esta é uma aplicação direta da regra de inferência Dilema Construtivo.)\n\nSolução:\n\\(\\neg A \\lor B\\) (Premissa 1)\n\\(C \\rightarrow A\\) (Premissa 2)\n\\(C\\) (Premissa 3)\n\\(A\\) (2, 3, Modus Ponens)\n\\(B\\) (1, 4, Silogismo Disjuntivo / Modus Tollendo Ponens)\n\n(Justificativa do passo 5: Como temos \\(\\neg A \\lor B\\) e provamos \\(A\\), a primeira parte da disjunção, \\(\\neg A\\), é falsa. Logo, a segunda parte, \\(B\\), deve ser verdadeira.)\n\nSolução:\n\n\nPremissas:\n\n\n\\(S \\rightarrow D\\)\n\\(D \\rightarrow R\\)\n\\(S\\)\n\n\nConclusão: \\(R\\)\nProva:\n\n\n\\(S \\rightarrow D\\) (Premissa 1)\n\\(D \\rightarrow R\\) (Premissa 2)\n\\(S\\) (Premissa 3)\n\\(S \\rightarrow R\\) (1, 2, Silogismo Hipotético)\n\\(R\\) (3, 4, Modus Ponens)\nSolução:\n\\((P \\land Q) \\rightarrow R\\) (Premissa 1)\n\\(\\neg R \\lor S\\) (Premissa 2)\n\\(P\\) (Premissa 3)\n\\(Q \\land T\\) (Premissa 4)\n\\(Q\\) (4, Simplificação)\n\\(P \\land Q\\) (3, 5, Adjunção)\n\\(R\\) (1, 6, Modus Ponens)\n\\(R \\rightarrow S\\) (2, Definição de Implicação)\n\\(S\\) (7, 8, Modus Ponens)\n\n\n\n14.1.5 Exercícios: Análise Semântica de Fórmulas\n\nSolução para \\(P \\rightarrow (P \\land Q)\\):\n\nClassificação: Contingência.\nJustificativa (Tabela-Verdade):\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\land Q\\)\n\\(P \\rightarrow (P \\land Q)\\)\n\n\n\n\nV\nV\nV\nV\n\n\nV\nF\nF\nF\n\n\nF\nV\nF\nV\n\n\nF\nF\nF\nV\n\n\n\nA coluna final possui tanto V quanto F.\n\nSolução para \\((P \\lor Q) \\lor (\\neg P \\land \\neg Q)\\):\n\nClassificação: Tautologia.\nJustificativa (Simplificação):\n\\[\n\\begin{align*}\n(P \\lor Q) \\lor (\\neg P \\land \\neg Q) &\\equiv (P \\lor Q) \\lor \\neg(P \\lor Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv TRUE && \\text{Lei do Terceiro Excluído (na forma } X \\lor \\neg X)\n\\end{align*}\n\\]\n\nSolução para \\((P \\leftrightarrow Q) \\land (P \\land \\neg Q)\\):\n\nClassificação: Contradição.\nJustificativa (Análise Lógica):\nPara a fórmula ser verdadeira, ambas as partes da conjunção precisam ser verdadeiras.\n\nA segunda parte, \\((P \\land \\neg Q)\\), só é verdadeira se \\(P=V\\) e \\(Q=F\\).\nVamos testar essa valoração na primeira parte: \\((P \\leftrightarrow Q)\\) se torna \\((V \\leftrightarrow F)\\), que é \\(FALSO\\).\nPortanto, a conjunção inteira se torna \\((FALSO \\land VERDADEIRO)\\), que é \\(FALSO\\).\n\nComo não existe nenhuma valoração que torne a fórmula verdadeira, ela é uma contradição.\n\nSolução (Valoração Verdadeira):\n\nUma implicação \\(X \\rightarrow Y\\) é verdadeira se o antecedente \\(X\\) for falso, ou se o consequente \\(Y\\) for verdadeiro.\n\nMétodo 1 (Consequente Verdadeiro): Vamos tornar \\((C \\rightarrow A)\\) verdadeiro. Isso acontece se \\(A=V\\).\nValoração: \\(A=V, B=V, C=V\\).\nVerificação: \\((\\neg V \\lor V) \\rightarrow (V \\rightarrow V) \\equiv (F \\lor V) \\rightarrow V \\equiv V \\rightarrow V \\equiv V\\). A valoração funciona.\n\n\nSolução (Valoração Falsa):\n\nUma implicação \\(X \\rightarrow Y\\) só é falsa se o antecedente \\(X\\) for verdadeiro e o consequente \\(Y\\) for falso.\n\nTornar o consequente \\((C \\rightarrow A)\\) falso: Para isso, precisamos de \\(C=V\\) e \\(A=F\\).\nVerificar se o antecedente \\((\\neg A \\lor B)\\) é verdadeiro com \\(A=F\\): \\((\\neg F \\lor B) \\equiv (V \\lor B)\\), que é sempre \\(V\\), não importa o valor de \\(B\\).\n\n\nValoração: \\(A=F, B=F, C=V\\).\nVerificação: \\((\\neg F \\lor F) \\rightarrow (V \\rightarrow F) \\equiv (V \\lor F) \\rightarrow F \\equiv V \\rightarrow F \\equiv F\\). A valoração funciona.\n\n\nSolução para \\((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\\):\n\nClassificação: Tautologia.\nJustificativa: Esta é uma das fórmulas axiomáticas da Lógica Proposicional, conhecida como Axioma de Frege. Provar por simplificação é longo, e por tabela-verdade requer 8 linhas. Todas as valorações possíveis resultam em Verdadeiro. É um princípio fundamental que permite a distribuição da implicação.\n\nSolução para \\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\land Q))\\):\n\nClassificação: Tautologia:\nJustificativa (Tabela-Verdade):\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(P \\land Q\\)\n\\(P \\leftrightarrow (P \\land Q)\\)\n\\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\land Q))\\)\n\n\n\n\nV\nV\nV\nV\nV\nV\n\n\nV\nF\nF\nF\nF\nV\n\n\nF\nV\nV\nF\nV\nV\n\n\nF\nF\nV\nF\nV\nV\n\n\n\nComo a coluna final só contém V, a fórmula é uma tautologia.\n\nSolução para \\(\\neg(((P \\lor Q) \\rightarrow P) \\lor Q)\\):\n\nClassificação: Contradição.:\nJustificativa (Simplificação):\n\\[\n\\begin{align*}\n\\neg(((P \\lor Q) \\rightarrow P) \\lor Q) &\\equiv \\neg((\\neg(P \\lor Q) \\lor P) \\lor Q) && \\text{Def. Implicação} \\\\\n&\\equiv \\neg(((\\neg P \\land \\neg Q) \\lor P) \\lor Q) && \\text{De Morgan} \\\\\n&\\equiv \\neg(((\\neg P \\lor P) \\land (\\neg Q \\lor P)) \\lor Q) && \\text{Distributividade} \\\\\n&\\equiv \\neg((TRUE \\land (\\neg Q \\lor P)) \\lor Q) && \\text{Terceiro Excluído} \\\\\n&\\equiv \\neg((\\neg Q \\lor P) \\lor Q) && \\text{Identidade} \\\\\n&\\equiv \\neg(\\neg Q \\lor Q \\lor P) && \\text{Associatividade} \\\\\n&\\equiv \\neg(TRUE \\lor P) && \\text{Terceiro Excluído} \\\\\n&\\equiv \\neg(TRUE) && \\text{Domínio} \\\\\n&\\equiv FALSE && \\text{Negação}\n\\end{align*}\n\\]\n\nSolução para o argumento:\n\nNão, não é logicamente consistente.\nJustificativa:\n\nA regra é: \\(D \\leftrightarrow (C \\land \\neg E)\\).\nA situação a ser testada é: \\(D \\land \\neg C\\). Para que isso seja verdade, \\(D=V\\) e \\(C=F\\).\nVamos substituir esses valores na regra: \\(V \\leftrightarrow (F \\land \\neg E)\\).\nA expressão \\((F \\land \\neg E)\\) será sempre \\(FALSO\\), não importa o valor de \\(E\\).\nEntão, a regra se torna \\(V \\leftrightarrow FALSO\\), o que é uma contradição (\\(FALSO\\)).\nComo a situação (\\(D \\land \\neg C\\)) leva a uma contradição da regra, ela não é consistente com a regra. É impossível satisfazer ambas as fórmulas ao mesmo tempo.\nSolução para \\((A \\leftrightarrow B) \\lor (B \\leftrightarrow C)\\):\n\nClassificação: Contingência.\nJustificativa (Análise de Casos):\n\nPode ser Verdadeiro: Se \\(A=V, B=V, C=V\\), a fórmula se torna \\((V \\leftrightarrow V) \\lor (V \\leftrightarrow V) \\equiv V \\lor V \\equiv V\\).\nPode ser Falso: Se \\(A=V, B=F, C=V\\), a fórmula se torna \\((V \\leftrightarrow F) \\lor (F \\leftrightarrow V) \\equiv F \\lor F \\equiv F\\). Como a fórmula pode ser tanto verdadeira quanto falsa dependendo da valoração, ela é uma contingência.\n\n\n\n14.1.6 Exercícios: Conexão com o Prolog\nQuestão 1: Diagnóstico de Sistema\n\nModelagem (Base de Conhecimento):\n\n\nS: O servidor está sobrecarregado.\n\nL: A latência da rede aumenta.\n\nN: O sistema de alerta envia uma notificação.\n\nRegras:\n\n\\(P_1: S \\to L\\)\n\n\\(P_2: L \\to N\\)\n\nFato:\n\n\\(P_3: \\neg N\\)\n\nConsulta: Prove \\(\\neg S\\).\n\nDedução Lógica (usando Modus Tollens):\n\n\nA partir de \\(P_2 (L \\to N)\\) e \\(P_3 (\\neg N)\\), podemos inferir \\(\\neg L\\) pela regra de Modus Tollens.\n\nAgora, usando \\(P_1 (S \\to L)\\) e nossa nova inferência \\(\\neg L\\), aplicamos Modus Tollens novamente para concluir \\(\\neg S\\).\n\nAlternativamente, podemos primeiro combinar \\(P_1\\) e \\(P_2\\) usando o Silogismo Hipotético: de \\((S \\to L)\\) e \\((L \\to N)\\), inferimos \\((S \\to N)\\). Com \\((S \\to N)\\) e \\(P_3 (\\neg N)\\), aplicamos Modus Tollens para obter \\(\\neg S\\).\n\n\nConexão com Prolog: Este exemplo mostra como fatos e regras interagem para produzir novas conclusões. Em Prolog, teríamos:\n\nlatencia_aumenta(X) :- servidor_sobrecarregado(X).\nalerta_enviado(X) :- latencia_aumenta(X).\n% Fato observado: não há alerta\n% Consulta: ?- servidor_sobrecarregado(servidor1).\n% Resposta: false (devido à cadeia de inferências)\nQuestão 2: Validação de Circuito Lógico (Half-Adder)\n\nTradução para Fórmulas:\n\n\nA condição para a saída S (“exatamente uma das entradas”) é um “ou exclusivo” (XOR):\n\\[S \\leftrightarrow (A \\land \\neg B) \\lor (\\neg A \\land B)\\]\nEm muitos contextos, isso é escrito como \\(A \\oplus B\\).\n\nA condição para a saída C (“ambas as entradas”):\n\\[C \\leftrightarrow A \\land B\\]\n\n\nTabela Verdade para Equivalência:\n\nVamos comparar a fórmula de S com a fórmula proposta \\(F \\equiv (A \\lor B) \\land \\neg(A \\land B)\\).\n\n\n\n\n\n\n\n\n\n\n\n\nA\nB\n\\(A \\oplus B\\) (Saída S)\n\\(A \\lor B\\)\n\\(A \\land B\\)\n\\(\\neg(A \\land B)\\)\n\\((A \\lor B) \\land \\neg(A \\land B)\\) (Fórmula F)\n\n\n\n\nV\nV\nF\nV\nV\nF\nF\n\n\nV\nF\nV\nV\nF\nV\nV\n\n\nF\nV\nV\nV\nF\nV\nV\n\n\nF\nF\nF\nF\nF\nV\nF\n\n\n\n\nConclusão: A coluna para a saída S e a coluna para a fórmula F são idênticas. Portanto, as duas fórmulas são logicamente equivalentes.\nConexão com Prolog: Em Prolog, poderíamos modelar o half-adder como:\n\nhalf_adder_sum(A, B, S) :- (A, \\+ B); (\\+ A, B).\nhalf_adder_carry(A, B, C) :- A, B.\nQuestão 3: Análise de Contrato de Serviço (Corrigida)\n\nModelagem:\n\n\nU: Uptime &lt; 99%\n\nC: Cliente recebe crédito\n\nT: Cliente abre ticket\n\nD: Cliente recebe desconto\n\nRegras:\n\n\\(P_1: U \\to C\\)\n\n\\(P_2: C \\to T\\)\n\n\\(P_3: \\neg(C \\land D)\\) (não pode ter ambos)\n\nFatos:\n\n\\(F_1: U\\) (uptime foi 98%)\n\n\\(F_2: \\neg T\\) (cliente não abriu ticket)\n\n\nAnálise da Contradição:\n\n\nDe \\(P_1 (U \\to C)\\) e \\(F_1 (U)\\), por Modus Ponens, concluímos \\(C\\).\n\nDe \\(P_2 (C \\to T)\\) e nossa conclusão \\(C\\), por Modus Ponens, deveríamos concluir \\(T\\).\n\nMas temos o fato \\(F_2 (\\neg T)\\).\n\nIsso cria uma contradição: \\(T \\land \\neg T\\).\n\n\nConclusão: As regras do contrato são inconsistentes. Quando o uptime é baixo mas o cliente não abre um ticket, o sistema de regras gera uma contradição. O contrato precisa ser reformulado para ser logicamente consistente.\nReformulação Sugerida: Modificar a regra 1 para: “Se o uptime for menor que 99% E o cliente abrir um ticket, então receberá um crédito”: \\((U \\land T) \\to C\\).\nConexão com Prolog: Este tipo de inconsistência poderia ser detectada automaticamente em Prolog:\n\n% Regras inconsistentes\ncredito(Cliente) :- uptime_baixo(Cliente).\ncredito(Cliente) :- ticket_aberto(Cliente).\n\n% Fatos\nuptime_baixo(cliente1).\n\\+ ticket_aberto(cliente1).\n\n% Consulta que revelaria a inconsistência\n?- credito(cliente1), \\+ ticket_aberto(cliente1).\n% A inconsistência seria revelada pela análise lógica\nQuestão 4: Dependências de Compilação (Corrigida)\n\nModelagem Correta:\n“Para compilar X, Y deve estar compilado” traduz-se em “Y deve estar compilado antes de X poder ser compilado”, ou seja: a capacidade de compilar X depende de Y estar compilado.\n\nRegras de Dependência:\n* \\(R_1: C \\to U\\) (para C ser compilado, U deve estar compilado)\n* \\(R_2: A \\to C\\) (para A ser compilado, C deve estar compilado)\n* \\(R_3: G \\to (A \\land L)\\) (para G ser compilado, A e L devem estar compilados)\nFato:\n* \\(F_1: U\\) (utils já compilado)\n\nAnálise de Viabilidade:\nPara compilar G, precisamos de A e L. A cadeia de dependências é: \\[G \\to (A \\land L) \\to (C \\land L) \\to (U \\land C \\land L)\\]\n\nA condição completa para compilar G é: \\(G \\to (U \\land C \\land A \\land L)\\).\n\nConclusão:\n\n\n\nTemos U compilado\n\nPodemos compilar C (pois U está disponível)\n\nPodemos compilar A (pois C pode ser compilado)\n\nNÃO podemos compilar G pois não sabemos o estado de L\n\nÉ necessário que a biblioteca assets (L) também seja compilada.\n\nConexão com Prolog:\n\npode_compilar(utils).\npode_compilar(core) :- pode_compilar(utils).\npode_compilar(api) :- pode_compilar(core).\npode_compilar(gui) :- pode_compilar(api), pode_compilar(assets).\n\n% Consulta: ?- pode_compilar(gui).\n% Resposta: false (pois assets não está definido)\nQuestão 5: Regras de um Jogo\n\nSimplificação da Condição de Vitória:\n\nSubstituindo a suposição F = verdadeiro e o fato \\(\\neg E\\) = verdadeiro:\n\n\\(V \\leftrightarrow (V \\land A) \\implies V \\leftrightarrow A\\) (já que F é verdadeiro)\n\n\\(A \\leftrightarrow (D \\lor F) \\implies A \\leftrightarrow D\\) (já que E é falso)\n\nPortanto: \\(V \\leftrightarrow D\\)\n\nAnálise da Condição para Derrotar o Dragão:\n\n\nA regra \\(D \\to S\\) estabelece que ter a espada é necessário para derrotar o dragão.\n\nO fato S nos diz que essa condição necessária é satisfeita.\n\nContudo, \\(D \\to S\\) não nos permite concluir D a partir de S (isso seria a falácia de afirmar o consequente).\n\n\nConclusão: Supondo que o jogador chegue à casa final, ele vencerá o jogo se, e somente se, derrotar o dragão (D). A posse da espada é uma pré-condição satisfeita, mas a derrota do dragão ainda deve ocorrer no mundo do jogo.\nConexão com Prolog: Este cenário de jogo poderia ser modelado em Prolog como:\n\n% Fatos\npossui(heroi, espada_prata).\nchegou_casa_final(heroi).\n\\+ resolveu_enigma(heroi).\n\n% Regras\nvence(X) :- chegou_casa_final(X), possui_amuleto(X).\npossui_amuleto(X) :- derrotou_dragao(X).\npossui_amuleto(X) :- resolveu_enigma(X).\npode_enfrentar_dragao(X) :- possui(X, espada_prata).\n\n% Consulta\n?- vence(heroi).\n% Dependeria de derrotou_dragao(heroi) ser provado\nQuestão 6: Decisão de um Robô Autônomo\n\nDedução da Contradição:\n\n\nDe O e \\(P_1 (O \\to (P \\land G))\\), por Modus Ponens: \\((P \\land G)\\), logo P e G.\n\nDe B e \\(P_2 (B \\to (P \\land R))\\), por Modus Ponens: \\((P \\land R)\\), logo P e R.\n\nDas inferências: G é verdadeiro e R é verdadeiro, portanto \\((G \\land R)\\) é verdadeiro.\n\nMas \\(P_3\\) afirma \\(\\neg(G \\land R)\\).\n\nContradição: \\((G \\land R) \\land \\neg(G \\land R)\\).\n\n\nResolução do Conflito:\n\nIntroduzir hierarquia de prioridades. Sugestão:\nRegra 1 Modificada: \\((O \\land \\neg B) \\to (P \\land G)\\)\nCom esta modificação, quando O e B são ambos verdadeiros, apenas a Regra 2 é acionada, e o robô para e retorna à base, eliminando a contradição.\n\nConexão com Prolog: Este exemplo ilustra a importância da ordem das regras em Prolog e como conflitos podem ser resolvidos através de condições mais específicas:\n\n% Versão com conflito\nacao_robo(parar_girar) :- obstaculo_detectado.\nacao_robo(parar_retornar) :- bateria_baixa.\n\n% Versão corrigida com prioridades\nacao_robo(parar_retornar) :- bateria_baixa.\nacao_robo(parar_girar) :- obstaculo_detectado, \\+ bateria_baixa.\n\n% Fatos\nobstaculo_detectado.\nbateria_baixa.\n\n% Consulta\n?- acao_robo(X).\n% X = parar_retornar (prioridade para bateria baixa)\nQuestão 7: Simplificação de Query de Banco de Dados (Corrigida)\n\nTabela Verdade Completa:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA\nS\nC\n\\(S \\lor C\\)\n\\(A \\land (S \\lor C)\\)\n\\(S \\land C\\)\n\\(\\neg A \\land (S \\land C)\\)\nFórmula Original\n\n\n\n\nV\nV\nV\nV\nV\nV\nF\nV\n\n\nV\nV\nF\nV\nV\nF\nF\nV\n\n\nV\nF\nV\nV\nV\nF\nF\nV\n\n\nV\nF\nF\nF\nF\nF\nF\nF\n\n\nF\nV\nV\nV\nF\nV\nV\nV\n\n\nF\nV\nF\nV\nF\nF\nF\nF\n\n\nF\nF\nV\nV\nF\nF\nF\nF\n\n\nF\nF\nF\nF\nF\nF\nF\nF\n\n\n\n\nForma Normal Disjuntiva Mínima:\n\nA fórmula é verdadeira para os seguintes mintermos:\n1. \\(A \\land S \\land C\\) (linha 1)\n2. \\(A \\land S \\land \\neg C\\) (linha 2)\n3. \\(A \\land \\neg S \\land C\\) (linha 3)\n4. \\(\\neg A \\land S \\land C\\) (linha 5)\nAgrupamento dos mintermos:\n\nAgrupando (1) e (2): \\((A \\land S \\land C) \\lor (A \\land S \\land \\neg C) \\equiv A \\land S\\)\n\nAgrupando (1) e (3): \\((A \\land S \\land C) \\lor (A \\land \\neg S \\land C) \\equiv A \\land C\\)\n\nAgrupando (1) e (4): \\((A \\land S \\land C) \\lor (\\neg A \\land S \\land C) \\equiv S \\land C\\)\n\nForma Normal Disjuntiva Mínima:\n\\((A \\land S) \\lor (A \\land C) \\lor (S \\land C)\\)\n\nVerificação: Esta forma não pode ser simplificada ainda mais sem perder informação, pois cada termo cobre casos distintos que não podem ser agrupados.\nEficiência: A forma simplificada \\((A \\land S) \\lor (A \\land C) \\lor (S \\land C)\\) é mais eficiente que a original pois:\n\n\n\nEstrutura “plana” de ORs de ANDs (Forma Normal Disjuntiva)\n\nPermite que o otimizador do banco use índices nas colunas A, S e C de forma mais eficaz\n\nReduz operações lógicas aninhadas, diminuindo o custo computacional da consulta\n\n\nConexão com Prolog: A simplificação lógica é fundamental em Prolog para otimização de consultas:\n\n% Consulta original (mais complexa)\nusuario_selecionado(U) :- \n (ativo(U), (sao_paulo(U) ; compras_altas(U))) ;\n (\\+ ativo(U), sao_paulo(U), compras_altas(U)).\n\n% Versão simplificada (mais eficiente)\nusuario_selecionado(U) :- ativo(U), sao_paulo(U).\nusuario_selecionado(U) :- ativo(U), compras_altas(U).\nusuario_selecionado(U) :- sao_paulo(U), compras_altas(U).\nQuestão 8: O Paradoxo do Mentiroso (Versão Proposicional)\n\nTabela Verdade:\nA fórmula \\(P \\leftrightarrow \\neg P\\) é equivalente a \\((P \\to \\neg P) \\land (\\neg P \\to P)\\).\n\n\n\n\nP\n\\(\\neg P\\)\n\\(P \\leftrightarrow \\neg P\\)\n\n\n\n\nV\nF\nF\n\n\nF\nV\nF\n\n\n\n\nAnálise: A tabela verdade mostra que a fórmula é sempre falsa, sendo portanto uma contradição.\nExplicação do Paradoxo: O paradoxo surge da autorreferência:\n\n\nSe a sentença é verdadeira, então deve ser o que afirma (falsa) → contradição\n\nSe a sentença é falsa, então sua afirmação é incorreta, logo deve ser verdadeira → contradição\n\n\nLimitações da Lógica Clássica: A lógica proposicional clássica não foi projetada para autorreferência. Lógicas paraconsistentes ou de múltiplos valores foram desenvolvidas para lidar com tais paradoxos.\nConexão com Prolog: O Prolog evita este tipo de paradoxo através de sua semântica operacional e da negação por falha:\n\n% Em Prolog, não podemos expressar diretamente:\n% p :- \\+ p.  % Isso causaria um loop infinito\n\n% O Prolog usa \"negação por falha\" que é diferente da negação lógica\n% Se algo não pode ser provado, é assumido como falso\nfalso_se_nao_provavel(X) :- \\+ provavel(X).\n\n% Isso evita contradições autorreferentes\nQuestão 9: Política de Firewall\n\nDedução Lógica:\n\n\nTemos \\(\\neg P\\) (verdadeiro).\n\nA premissa da Regra 2 é \\((\\neg I \\lor \\neg P)\\).\n\nComo \\(\\neg P\\) é verdadeiro, a disjunção \\((\\neg I \\lor \\neg P)\\) é verdadeira.\n\nPor Modus Ponens na Regra 2: A é verdadeiro.\n\n\nAnálise de Redundância:\nA condição total para A é: \\(((I \\land P) \\lor (\\neg I \\lor \\neg P))\\).\n\nPor De Morgan: \\((\\neg I \\lor \\neg P) \\equiv \\neg(I \\land P)\\).\nLogo: \\(A \\leftrightarrow ((I \\land P) \\lor \\neg(I \\land P))\\).\nSeja \\(X = (I \\land P)\\). A condição torna-se \\(X \\lor \\neg X\\), que é uma tautologia.\n\nConclusão: A política permite todas as requisições. É completamente ineficaz e altamente redundante, não bloqueando nada.\nConexão com Prolog: Este tipo de problema pode ser detectado analisando as regras em Prolog:\n\n% Política de firewall redundante\npermitida(Req) :- rede_interna(Req), porta_443(Req).\npermitida(Req) :- \\+ rede_interna(Req).\npermitida(Req) :- \\+ porta_443(Req).\n\n% Teste que mostra que tudo é permitido\n?- permitida(qualquer_requisicao).\n% true (sempre, devido à redundância)\n\n% Versão corrigida seria mais restritiva\npermitida(Req) :- rede_interna(Req).\npermitida(Req) :- \\+ rede_interna(Req), conexao_segura(Req).\nQuestão 10: Tautologia, Contradição ou Contingência?\n\nAnálise de Cenário Crítico:\nConsidere o caso onde T = verdadeiro e V = falso (fez treinamento, não bateu meta):\n\n\nPrimeira parte: \\((V \\lor T) \\to B\\)\nPremissa: \\((F \\lor V) = V\\) → Conclusão: B deve ser verdadeiro\nSegunda parte: \\((T \\land \\neg V) \\to \\neg B\\)\nPremissa: \\((V \\land V) = V\\) → Conclusão: B deve ser falso\nResultado: B deve ser simultaneamente verdadeiro e falso → contradição.\n\n\nDemonstração Formal:\nPara o caso \\((T \\land \\neg V)\\):\n\\[F \\equiv (V \\to B) \\land (V \\to \\neg B) \\equiv V \\land B \\land \\neg B\\]\n\nComo \\(B \\land \\neg B\\) é sempre falso, a fórmula é falsa para este caso específico.\n\nClassificação: A fórmula é uma contingência (pode ser verdadeira ou falsa dependendo dos valores), mas é logicamente inconsistente para o caso \\((T \\land \\neg V)\\).\nImplicação para a Empresa: A política de bônus é inaplicável - cria uma situação onde as regras simultaneamente concedem e negam o bônus para funcionários que fizeram treinamento mas não bateram a meta. A empresa precisa redefinir suas regras para serem consistentes.\nConexão com Prolog: Em Prolog, esta inconsistência seria revelada imediatamente:\n\n% Política inconsistente\nbonus(Func) :- meta_atingida(Func).\nbonus(Func) :- treinamento(Func).\n\\+ bonus(Func) :- treinamento(Func), \\+ meta_atingida(Func).\n\n% Fatos\ntreinamento(joao).\n\\+ meta_atingida(joao).\n\n% Consulta reveladoria\n?- bonus(joao).\n% Resultado inconsistente: true e false simultaneamente\n\n% Política corrigida\nbonus(Func) :- meta_atingida(Func).\nbonus(Func) :- treinamento(Func), meta_atingida(Func).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html#sec-logica-predicativa",
    "href": "Solucao-Exercicios.html#sec-logica-predicativa",
    "title": "14  Solução dos Exercícios",
    "section": "14.2 Section 14.2",
    "text": "14.2 Section 14.2\n\n14.2.1 Exercícios de Conexão com Prolog\nQuestão 1: Relações em um Sistema Acadêmico\nResoluções: 1. Existe pelo menos um aluno: \\(\\exists x A(x)\\) 2. Nem todo aluno está matriculado em algum curso: \\(\\neg \\forall x (A(x) \\to \\exists y (C(y) \\land M(x,y)))\\) 3. Todo aluno está matriculado em pelo menos um curso: \\(\\forall x (A(x) \\to \\exists y (C(y) \\land M(x,y)))\\) 4. Existe um curso no qual nenhum aluno está matriculado: \\(\\exists y (C(y) \\land \\neg \\exists x (A(x) \\land M(x,y)))\\) 5. Existe um aluno que está matriculado em todos os cursos: \\(\\exists x (A(x) \\land \\forall y (C(y) \\to M(x,y)))\\)\nConexão com Prolog: Em Prolog, estes predicados se tornariam fatos e regras:\naluno(joao).\ncurso(matematica).\nmatriculado(joao, matematica).\n\n% Consulta: ?- aluno(X).\n% Resposta: X = joao\nQuestão 2: O Escopo dos Quantificadores\nAnálise das Fórmulas:\n\nFórmula 1: \\(\\forall x \\exists y (Pessoa(x) \\to (Pessoa(y) \\land Ama(x,y)))\\)\n\nTradução: “Para toda pessoa x, existe uma pessoa y tal que x ama y”\nSignificado: Todo mundo ama alguém. A pessoa y que é amada pode ser diferente para cada x. Isso descreve o amor fraternal universal, onde o ato de amar é universal, mas o objeto do amor é individual.\n\nFórmula 2: \\(\\exists y \\forall x (Pessoa(x) \\to (Pessoa(y) \\land Ama(x,y)))\\)\n\nTradução: “Existe uma pessoa y tal que, para toda pessoa x, x ama y”\nSignificado: Existe um indivíduo específico (y) que é amado por todas as outras pessoas. Isso descreve a existência de uma figura universalmente amada.\n\n\nConexão com Prolog: A ordem dos quantificadores afeta diretamente como o Prolog resolve consultas e unifica variáveis.\nQuestão 3: O Paradoxo do Barbeiro\nResolução: 1. Tradução da Regra: A regra diz que o barbeiro (b) barbeia uma pessoa x se, e somente se, x não se barbeia a si mesmo: \\[\\forall x (Barbeia(b,x) \\leftrightarrow \\neg Barbeia(x,x))\\]\n\nDedução da Contradição: Vamos usar a Instanciação Universal, substituindo a variável universal x pela constante b (o próprio barbeiro): \\[Barbeia(b,b) \\leftrightarrow \\neg Barbeia(b,b)\\]\nSeja P a proposição \\(Barbeia(b,b)\\). A fórmula se torna \\(P \\leftrightarrow \\neg P\\). Como vimos na Lógica Proposicional, esta fórmula é uma contradição. Ela afirma que o barbeiro se barbeia se, e somente se, ele não se barbeia. Isso é impossível.\n\nConexão com Prolog: Este paradoxo ilustra por que o Prolog usa “negação por falha” em vez de negação clássica, evitando contradições deste tipo.\nQuestão 4: Especificação de um Sistema de Arquivos\nResolução: 1. Tradução da Política: * “Qualquer administrador pode acessar todos os arquivos”: \\[\\forall x \\forall y ((Admin(x) \\land Arquivo(y)) \\to PodeAcessar(x,y))\\] * “Ninguém que não seja administrador pode acessar algum arquivo”: \\[\\forall x \\forall y ((\\neg Admin(x) \\land Arquivo(y)) \\to \\neg PodeAcessar(x,y))\\]\n\nConclusões:\n\nPara \\(PodeAcessar(ana, relatorio.doc)\\): Dado \\(Admin(ana)\\), a primeira regra se aplica. Por Instanciação Universal com \\(x = ana\\) e \\(y = relatorio.doc\\), concluímos que \\(PodeAcessar(ana, relatorio.doc)\\) é verdadeiro.\nPara \\(PodeAcessar(beto, relatorio.doc)\\): Dado \\(\\neg Admin(beto)\\), a segunda regra se aplica. Por Instanciação Universal, concluímos que \\(\\neg PodeAcessar(beto, relatorio.doc)\\) é verdadeiro.\n\n\nConexão com Prolog:\nadmin(ana).\narquivo(relatorio_doc).\n\npode_acessar(X, Y) :- admin(X), arquivo(Y).\n\n% Consulta: ?- pode_acessar(ana, relatorio_doc).\n% Resposta: true\nQuestão 5: Negando Afirmações Universais\nResoluções:\n\nSentença Original: \\(\\forall x (Programa(x) \\to \\exists y (Bug(y) \\land Tem(x,y)))\\)\nNegação: \\[\\neg [\\forall x (Programa(x) \\to \\exists y (Bug(y) \\land Tem(x,y)))]\\] \\[\\equiv \\exists x \\neg [Programa(x) \\to \\exists y (Bug(y) \\land Tem(x,y))]\\] \\[\\equiv \\exists x [\\Programa(x) \\land \\neg \\exists y (Bug(y) \\land Tem(x,y))]\\] \\[\\equiv \\exists x [Programa(x) \\land \\forall y \\neg (Bug(y) \\land Tem(x,y))]\\] \\[\\equiv \\exists x [Programa(x) \\land \\forall y (Bug(y) \\to \\neg Tem(x,y))]\\]\nTradução: “Existe um programa de computador que não tem nenhum bug”\nSentença Original: \\(\\exists x (Politico(x) \\land \\forall y (Eleitor(y,x) \\to HonestoCom(x,y)))\\)\nNegação: \\[\\neg [\\exists x (Politico(x) \\land \\forall y (Eleitor(y,x) \\to HonestoCom(x,y)))]\\] \\[\\equiv \\forall x \\neg [Politico(x) \\land \\forall y (Eleitor(y,x) \\to HonestoCom(x,y))]\\] \\[\\equiv \\forall x [Politico(x) \\to \\neg \\forall y (Eleitor(y,x) \\to HonestoCom(x,y))]\\] \\[\\equiv \\forall x [Politico(x) \\to \\exists y \\neg (Eleitor(y,x) \\to HonestoCom(x,y))]\\] \\[\\equiv \\forall x [Politico(x) \\to \\exists y (Eleitor(y,x) \\land \\neg HonestoCom(x,y))]\\]\nTradução: “Todo político é desonesto com pelo menos um de seus eleitores”\n\nConexão com Prolog: A negação por falha em Prolog (\\+) aproxima-se dessas transformações lógicas.\nQuestão 6: Mundo dos Blocos (Planejamento em IA) - Corrigida\nResolução: 1. Modelagem: * \\(R_1: \\exists x \\exists y (Verde(x) \\land Azul(y) \\land EmCima(x,y))\\) * \\(R_2: \\forall z (NaMesa(z) \\to Azul(z))\\) * \\(R_3: \\forall w \\forall v \\neg (EmCima(w,v) \\land NaMesa(w))\\) * \\(R_4: \\forall u \\neg (Verde(u) \\land Azul(u))\\) (premissa adicional)\n\nDedução:\n\nDe \\(R_1\\), por Instanciação Existencial, sabemos que existem constantes \\(a\\) e \\(b\\) tais que: \\(Verde(a)\\), \\(Azul(b)\\), e \\(EmCima(a,b)\\).\nDe \\(R_4\\), por Instanciação Universal com \\(u = b\\), temos \\(\\neg (Verde(b) \\land Azul(b))\\).\nComo sabemos que \\(Azul(b)\\) é verdadeiro, então \\(\\neg Verde(b)\\) deve ser verdadeiro.\nPortanto, existe um bloco (\\(b\\)) que não é verde.\n\n\nConexão com Prolog:\nverde(bloco_a).\nazul(bloco_b).\nem_cima(bloco_a, bloco_b).\n\nna_mesa(X) :- azul(X), \\+ em_cima(_, X).\n\n% A exclusividade seria uma restrição adicional\nQuestão 7: Propriedades dos Números Inteiros (Corrigida)\nResoluções: 1. Todo número par é maior que algum número ímpar: \\[\\forall x (Par(x) \\to \\exists y (Impar(y) \\land x &gt; y))\\]\n\nNão existe um número inteiro que seja o maior de todos: \\[\\neg \\exists x \\forall y (y \\leq x)\\] ou, de forma equivalente: \\[\\forall x \\exists y (y &gt; x)\\]\nA soma de quaisquer dois números pares é par: \\[\\forall x \\forall y ((Par(x) \\land Par(y)) \\to Par(x + y))\\]\n\nConexão com Prolog:\npar(X) :- 0 is X mod 2.\nimpar(X) :- 1 is X mod 2.\n\nmaior_que_impar(X) :- par(X), impar(Y), X &gt; Y.\nQuestão 8: Dedução Lógica com Instanciação\nResolução: 1. Premissas: * \\(P_1: \\forall x (Leao(x) \\to Mamifero(x))\\) * \\(P_2: \\exists x (Leao(x) \\land ViveNaSavana(x))\\)\n\nProva Formal:\n\nDa premissa \\(P_2\\), por Instanciação Existencial, podemos afirmar que existe uma constante \\(c\\) (vamos chamá-lo de Simba) para a qual a afirmação é verdadeira: \\(Leao(c) \\land ViveNaSavana(c)\\).\nDesta conjunção, podemos separar os dois fatos: \\(Leao(c)\\) e \\(ViveNaSavana(c)\\).\nDa premissa \\(P_1\\), por Instanciação Universal, podemos aplicar a regra a qualquer objeto, incluindo nossa constante \\(c\\): \\(Leao(c) \\to Mamifero(c)\\).\nAgora temos a implicação \\(Leao(c) \\to Mamifero(c)\\) e o fato \\(Leao(c)\\). Por Modus Ponens, podemos concluir \\(Mamifero(c)\\).\nNeste ponto, sabemos duas coisas sobre \\(c\\): \\(Mamifero(c)\\) e \\(ViveNaSavana(c)\\). Podemos juntá-las em uma conjunção: \\(Mamifero(c) \\land ViveNaSavana(c)\\).\nFinalmente, como encontramos um exemplo específico (\\(c\\)) que satisfaz a condição, podemos usar a Generalização Existencial para concluir: \\(\\exists x (Mamifero(x) \\land ViveNaSavana(x))\\). Q.E.D.\n\n\nConexão com Prolog:\nleao(simba).\nvive_na_savana(simba).\n\nmamifero(X) :- leao(X).\n\n% Consulta: ?- mamifero(X), vive_na_savana(X).\n% Resposta: X = simba\nQuestão 9: Consulta a uma Base de Dados Relacional (Corrigida)\nResolução: A consulta pede os nomes (\\(n\\)) dos funcionários que trabalham no departamento de ‘Vendas’. A fórmula correta deve especificar que estamos procurando por nomes:\n\\[\\{n \\mid \\exists x \\exists d (Func(x,n,d) \\land Depto(d,'Vendas'))\\}\\]\nAlternativamente, como uma fórmula lógica que define a condição: \\[\\exists x \\exists d (Func(x,n,d) \\land Depto(d,'Vendas'))\\]\nonde \\(n\\) é uma variável livre que representa o nome que estamos buscando.\nConexão com Prolog:\nfunc(1, joao, vendas).\nfunc(2, maria, ti).\ndepto(vendas, 'Vendas').\ndepto(ti, 'TI').\n\nfuncionario_vendas(Nome) :- \n    func(_, Nome, Depto), \n    depto(Depto, 'Vendas').\n\n% Consulta: ?- funcionario_vendas(X).\n% Resposta: X = joao\nEm SQL seria: SELECT F.Nome FROM Funcionario F JOIN Departamento D ON F.DeptoID = D.ID WHERE D.NomeDepto = 'Vendas'.\nQuestão 10: Hierarquia Organizacional (Corrigida)\nResoluções: 1. Todo funcionário tem exatamente um gerente: Isso se divide em duas partes: “pelo menos um” e “no máximo um”: * \\(\\forall x (Funcionario(x) \\to \\exists y Gerente(y,x))\\) * \\(\\forall x \\forall y \\forall z ((Gerente(y,x) \\land Gerente(z,x)) \\to y = z)\\)\n\nNenhum funcionário pode ser gerente de si mesmo:\n\n\\(\\forall x \\neg Gerente(x,x)\\)\n\nTodo gerente é também um funcionário: (Corrigida)\n\n\\(\\forall x (\\exists y Gerente(x,y) \\to Funcionario(x))\\)\n\nExiste um funcionário que não é gerente de ninguém:\n\n\\(\\exists x (Funcionario(x) \\land \\neg \\exists y Gerente(x,y))\\)\n\n\nConexão com Prolog:\nfuncionario(joao).\nfuncionario(maria).\nfuncionario(pedro).\n\ngerente(maria, joao).\ngerente(pedro, maria).\n\n% Regra: todo gerente é funcionário\nfuncionario(X) :- gerente(X, _).\n\n% Consulta: funcionário que não é gerente de ninguém\nnao_gerente(X) :- funcionario(X), \\+ gerente(X, _).\n\n% Consulta: ?- nao_gerente(X).\n% Resposta: X = joao",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html#sec-formas-normais",
    "href": "Solucao-Exercicios.html#sec-formas-normais",
    "title": "14  Solução dos Exercícios",
    "section": "14.3 Section 14.3",
    "text": "14.3 Section 14.3\nQuestão 1: Conversão Básica: dada a seguinte fórmula lógica, que representa uma regra de negócio simples: “Se o pedido (\\(P\\)) foi aprovado, então a nota fiscal (\\(N\\)) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (\\(E\\)).”\nFórmula: \\[(P \\to N) \\wedge \\neg (N \\wedge \\neg E)\\]\n\nEliminar Implicação e Mover Negação:\n\\[(\\neg P \\vee N) \\wedge (\\neg N \\vee \\neg \\neg E)\\]\n\\[(\\neg P \\vee N) \\wedge (\\neg N \\vee E)\\]\nFNC: A fórmula já está em FNC. As cláusulas são \\[(\\neg P \\vee N)\\] e \\[(\\neg N \\vee E)\\].\nFND: Para obter a FND, aplicamos a distributividade:\n\n\\[((\\neg P \\vee N) \\wedge \\neg N) \\vee ((\\neg P \\vee N) \\wedge E)\\]\n\\[(\\neg P \\wedge \\neg N) \\vee (N \\wedge \\neg N) \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\n\\[(\\neg P \\wedge \\neg N) \\vee \\text{Falso} \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\nFND Final:\n\\[(\\neg P \\wedge \\neg N) \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\nEm Prolog:\n% Fórmula original: (P -&gt; N) ∧ ¬(N ∧ ¬E)\noriginal(P, N, E, Result) :-\n    (P -&gt; N, \\+ (N, \\+ E)) -&gt; Result = true ; Result = false.\n\n% FNC: (¬P ∨ N) ∧ (¬N ∨ E)\nfnc(P, N, E, Result) :-\n    ((\\+ P ; N), (\\+ N ; E)) -&gt; Result = true ; Result = false.\n\n% FND: (¬P ∧ ¬N) ∨ (¬P ∧ E) ∨ (N ∧ E)\nfnd(P, N, E, Result) :-\n    ((\\+ P, \\+ N) ; (\\+ P, E) ; (N, E)) -&gt; Result = true ; Result = false.\n\n% Testar equivalência\ntest_equivalence :-\n    findall([P, N, E], (member(P, [true, false]), member(N, [true, false]), member(E, [true, false])), Cases),\n    forall(member([P, N, E], Cases),\n           (original(P, N, E, Orig), fnc(P, N, E, FNC), fnd(P, N, E, FND),\n            (Orig = FNC, FNC = FND -&gt;\n                write('Caso '), write([P, N, E]), write(': Equivalente'), nl\n            ;   write('Caso '), write([P, N, E]), write(': Não Equivalente'), nl, fail))).\nQuestão 2: Cenários de Ativação de Sistema:\n\nModelagem: \\[I \\leftrightarrow (S \\vee (\\neg C \\wedge T))\\]\nFND: A fórmula \\[S \\vee (\\neg C \\wedge T)\\] já está em Forma Normal Disjuntiva.\n\n\nSignificado: Cada termo (disjunto) representa um cenário completo e independente que ativa a irrigação.\n\\(S\\): O sistema ativa se o solo estiver seco (independentemente de outros fatores).\n\\(\\neg C \\wedge T\\): O sistema ativa se não choveu E a temperatura está alta (mesmo que o solo ainda não esteja tecnicamente seco).\n\nEm Prolog:\n% Condição de ativação: I ↔ (S ∨ (¬C ∧ T))\nactivation(I, S, C, T, Result) :-\n    (I == (S ; (\\+ C, T))) -&gt; Result = true ; Result = false.\n\n% Testar cenários onde a irrigação é ativada\ntest_activation :-\n    findall([S, C, T, I], (member(S, [true, false]), member(C, [true, false]), member(T, [true, false]), member(I, [true, false])), Cases),\n    forall(member([S, C, T, I], Cases),\n           (activation(I, S, C, T, Res),\n            (Res = true -&gt;\n                write('Irrigação ativa para '), write([S, C, T, I]), nl\n            ;   true))).\nQuestão 3: Verificação de Consistência de Regras:\n\nModelagem:\n\n\nR1: \\[I \\to P\\]\n\nR2: \\[\\neg I \\to (P \\leftrightarrow S)\\]\n\nR3: \\[S \\to \\neg I\\]\n\nFórmula Conjunta: \\[(I \\to P) \\wedge (\\neg I \\to (P \\leftrightarrow S)) \\wedge (S \\to \\neg I)\\]\n\n\nConversão para FNC:\n\n\nR1: \\[\\neg I \\vee P\\]\n\nR3: \\[\\neg S \\vee \\neg I\\]\n\nR2: \\[I \\vee (P \\leftrightarrow S) \\equiv I \\vee ((P \\to S) \\wedge (S \\to P)) \\equiv I \\vee ((\\neg P \\vee S) \\wedge (\\neg S \\vee P)) \\equiv (I \\vee \\neg P \\vee S) \\wedge (I \\vee \\neg S \\vee P)\\]\n\n\nFNC Completa: \\[(\\neg I \\vee P) \\wedge (\\neg S \\vee \\neg I) \\wedge (I \\vee \\neg P \\vee S) \\wedge (I \\vee \\neg S \\vee P)\\]\nAnálise: As regras são consistentes. A FNC nos dá um conjunto de restrições que podem ser satisfeitas (ex: \\(I\\), \\(P\\), \\(\\neg S\\) é uma solução). Se uma conexão fosse segura e interna (\\(S \\wedge I\\)), a cláusula \\[(\\neg S \\vee \\neg I)\\] seria falsa, tornando todo o conjunto de regras falso. Isso significa que tal cenário é proibido pelas regras, o que é o comportamento esperado.\n\nEm Prolog:\n% Cláusulas\nclause1(I, P, _) :- \\+ I ; P.\nclause2(_, S, I) :- \\+ S ; \\+ I.\nclause3(I, P, S) :- I ; \\+ P ; S.\nclause4(I, P, S) :- I ; \\+ S ; P.\n\n% Verificar consistência\nconsistent(I, P, S) :- clause1(I, P, _), clause2(_, S, I), clause3(I, P, S), clause4(I, P, S).\n\n% Testar consistência\ntest_consistency :-\n    (consistent(true, true, false) -&gt;\n        write('Consistente: I=true, P=true, S=false'), nl\n    ;   write('Inconsistente para I=true, P=true, S=false'), nl),\n    (consistent(true, true, true) -&gt;\n        write('Consistente: I=true, P=true, S=true'), nl\n    ;   write('Inconsistente para I=true, P=true, S=true (S ∧ I é proibido)'), nl).\nQuestão 4: Equivalência de Políticas de Segurança:\n\nModelagem:\n\n\nAlice: \\[A \\leftrightarrow (D \\to (C \\vee (\\neg C \\wedge P)))\\]\nBeto: \\[B \\leftrightarrow (D \\to (P \\vee C))\\]\n\n\nSimplificação e FND Mínima:\n\n\nAlice: A condição de acesso é \\[C \\vee (\\neg C \\wedge P)\\]. Usando a lei da absorção \\[(X \\vee (\\neg X \\wedge Y)) \\equiv (X \\vee Y)\\], a fórmula simplifica para \\[C \\vee P\\].\nBeto: A condição de acesso é \\[P \\vee C\\].\n\n\nConclusão: Ambas as políticas simplificam para a mesma FND mínima: \\[C \\vee P\\]. Portanto, as políticas de Alice e Beto são logicamente equivalentes.\n\nEm Prolog:\n% Política de Alice: A ↔ (D → (C ∨ (¬C ∧ P)))\nalice(A, D, C, P) :- A == (D -&gt; (C ; (\\+ C, P))).\n\n% Política de Beto: B ↔ (D → (P ∨ C))\nbob(B, D, C, P) :- B == (D -&gt; (P ; C)).\n\n% Testar equivalência\ntest_equivalence :-\n    findall([A, B, D, C, P], (member(A, [true, false]), member(B, [true, false]), \n                              member(D, [true, false]), member(C, [true, false]), member(P, [true, false])), Cases),\n    forall(member([A, B, D, C, P], Cases),\n           (alice(A, D, C, P), bob(B, D, C, P),\n            (A = B -&gt;\n                write('Caso '), write([D, C, P]), write(': Equivalente'), nl\n            ;   write('Caso '), write([D, C, P]), write(': Não Equivalente'), nl, fail))).\nQuestão 5: Eliminando a Bicondicional:\n\nFórmula: \\[F \\leftrightarrow (P \\vee V)\\]\nConversão: A bicondicional \\[A \\leftrightarrow B\\] é equivalente a \\[(A \\to B) \\wedge (B \\to A)\\].\n\\[(F \\to (P \\vee V)) \\wedge ((P \\vee V) \\to F)\\]\nEliminar Implicações:\n\n\\[(\\neg F \\vee P \\vee V) \\wedge (\\neg (P \\vee V) \\vee F)\\]\n\\[(\\neg F \\vee P \\vee V) \\wedge ((\\neg P \\wedge \\neg V) \\vee F)\\]\n\nDistribuir para FNC:\n\n\nO primeiro termo já é uma cláusula.\n\nO segundo termo: \\[(\\neg P \\vee F) \\wedge (\\neg V \\vee F)\\].\n\n\nFNC Final: \\[(\\neg F \\vee P \\vee V) \\wedge (\\neg P \\vee F) \\wedge (\\neg V \\vee F)\\].\n\n\nSignificado das Cláusulas:\n\\((\\neg F \\vee P \\vee V)\\): Se o frete foi grátis (\\(F\\)), então o cliente deve ser Prime (\\(P\\)) ou o pedido deve ser de alto valor (\\(V\\)).\n\\((\\neg P \\vee F)\\): Se o cliente é Prime, o frete deve ser grátis.\n\\((\\neg V \\vee F)\\): Se o pedido é de alto valor, o frete deve ser grátis.\n\nEm Prolog:\n% Fórmula original: F ↔ (P ∨ V)\noriginal(F, P, V) :- F == (P ; V).\n\n% FNC: (¬F ∨ P ∨ V) ∧ (¬P ∨ F) ∧ (¬V ∨ F)\nfnc(F, P, V) :- (\\+ F ; P ; V), (\\+ P ; F), (\\+ V ; F).\n\n% Testar equivalência\ntest_equivalence :-\n    findall([F, P, V], (member(F, [true, false]), member(P, [true, false]), member(V, [true, false])), Cases),\n    forall(member([F, P, V], Cases),\n           (original(F, P, V), fnc(F, P, V),\n            (original(F, P, V) = fnc(F, P, V) -&gt;\n                write('Caso '), write([F, P, V]), write(': Equivalente'), nl\n            ;   write('Caso '), write([F, P, V]), write(': Não Equivalente'), nl, fail))).\nQuestão 6: Simplificação de Circuito Lógico:\n\nFND Canônica: Soma dos mintermos (casos onde a saída é 1):\n\n\\[(\\neg A \\wedge \\neg B \\wedge C) \\vee (\\neg A \\wedge B \\wedge C) \\vee (A \\wedge \\neg B \\wedge \\neg C) \\vee (A \\wedge \\neg B \\wedge C)\\]\n\nMapa de Karnaugh:\n\n\n\n\n\\(A\\)  \\(BC\\)\n00\n01\n11\n10\n\n\n\n\n0\n0\n1\n1\n0\n\n\n1\n1\n0\n0\n1\n\n\n\n\nAgrupamentos:\n\nGrupo 1 (vertical): Coluna \\(BC=01\\), linhas \\(A=0,1\\). Termo: \\[\\neg B \\wedge C\\].\nGrupo 2 (horizontal): Linha \\(A=1\\), colunas \\(BC=00,01\\). Termo: \\[A \\wedge \\neg B\\].\nFND Mínima: \\((\\neg B \\wedge C) \\vee (A \\wedge \\neg B)\\).\n\n\nEm Prolog:\n% Função de saída da tabela verdade\noutput(A, B, C, Result) :-\n    ((A=false, B=false, C=true); (A=false, B=true, C=true); \n     (A=true, B=false, C=false); (A=true, B=false, C=true)) -&gt; Result = true ; Result = false.\n\n% FND mínima: (¬B ∧ C) ∨ (A ∧ ¬B)\nfnd_min(A, B, C, Result) :-\n    ((\\+ B, C) ; (A, \\+ B)) -&gt; Result = true ; Result = false.\n\n% Testar equivalência\ntest_fnd :-\n    findall([A, B, C], (member(A, [true, false]), member(B, [true, false]), member(C, [true, false])), Cases),\n    forall(member([A, B, C], Cases),\n           (output(A, B, C, Out), fnd_min(A, B, C, FND),\n            (Out = FND -&gt;\n                write('Caso '), write([A, B, C]), write(': Equivalente'), nl\n            ;   write('Caso '), write([A, B, C]), write(': Não Equivalente'), nl, fail))).\nQuestão 7: Validando uma Inferência (Tautologia):\n\nFórmula: \\(\\left( (L \\to M) \\wedge L \\right) \\to M\\);\nNegação: \\(\\neg \\left[ \\left( (\\neg L \\vee M) \\wedge L \\right) \\to M \\right]\\)\nConversão:\n\n\\(\\neg \\left[ \\neg \\left( (\\neg L \\vee M) \\wedge L \\right) \\vee M \\right]\\);\n\\(\\left( (\\neg L \\vee M) \\wedge L \\right) \\wedge \\neg M\\)\n\\((\\neg L \\wedge L \\wedge \\neg M) \\vee (M \\wedge L \\wedge \\neg M)\\)\n\\((\\text{Falso} \\wedge \\neg M) \\vee (\\text{Falso} \\wedge L)\\)\n\\(\\text{Falso} \\vee \\text{Falso} \\equiv \\text{Falso}\\)\n\nConclusão: A negação da fórmula é uma contradição (sempre falsa). Portanto, a fórmula original é uma tautologia.\n\nEm Prolog:\n% Fórmula original: ((L → M) ∧ L) → M\noriginal(L, M) :- ((\\+ L ; M), L) -&gt; M.\n\n% Negação: (¬L ∨ M) ∧ L ∧ ¬M\nnegation(L, M) :- (\\+ L ; M), L, \\+ M.\n\n% Testar se é tautologia\ntest_tautology :-\n    (negation(true, _) ; negation(false, _)) -&gt;\n        write('Negação é satisfatível: Não é tautologia'), nl, fail\n    ;   write('Negação é insatisfatível: Fórmula é tautologia'), nl.\nQuestão 8: Problema de Satisfatibilidade (SAT)\n\nModelagem:\n\n\nR1: \\(A \\vee B \\vee C\\);\n\nR2: \\(\\neg (A \\wedge B) \\equiv \\neg A \\vee \\neg B\\);\n\nR3: \\(C \\to A \\equiv \\neg C \\vee A\\).\n\n\nFNC: O conjunto de cláusulas é: \\(\\{(A \\vee B \\vee C), (\\neg A \\vee \\neg B), (\\neg C \\vee A)\\}\\)\nSatisfatibilidade: Sim, o conjunto é satisfatível. Precisamos encontrar uma atribuição de Verdadeiro/Falso para \\(A\\), \\(B\\), \\(C\\) que torne todas as cláusulas verdadeiras.\n\n\nVamos tentar \\(A=\\text{V}\\).\n\\(\\neg C \\vee \\text{V} \\equiv \\text{Verdadeiro}\\). OK.\n\\(\\neg \\text{V} \\vee \\neg B \\equiv \\neg B\\) precisa ser verdadeiro, então \\(B=\\text{F}\\).\n\\(\\text{V} \\vee \\text{F} \\vee C \\equiv \\text{Verdadeiro}\\). OK.\nSolução Válida: \\(A=\\text{V}\\), \\(B=\\text{F}\\), \\(C=\\text{F}\\) (Apenas Ana é alocada).\nOutra solução: \\(A=\\text{V}\\), \\(B=\\text{F}\\), \\(C=\\text{V}\\) (Ana e Carla são alocadas).\n\nEm Prolog:\n% Cláusulas\nclause1(A, B, C) :- A ; B ; C.\nclause2(A, B, _) :- \\+ A ; \\+ B.\nclause3(A, _, C) :- \\+ C ; A.\n\n% Verificar satisfatibilidade\nsatisfiable(A, B, C) :- clause1(A, B, C), clause2(A, B, _), clause3(A, _, C).\n\n% Testar satisfatibilidade\ntest_satisfiability :-\n    findall([A, B, C], (member(A, [true, false]), member(B, [true, false]), member(C, [true, false]), \n                        satisfiable(A, B, C)), Solutions),\n    (Solutions \\= [] -&gt;\n        write('Satisfatível. Soluções: '), write(Solutions), nl\n    ;   write('Insatisfatível'), nl).\nQuestão 9: Forma Normal Prenex\n\nFórmula: \\(\\forall x (P(x) \\to (\\exists y (Q(y) \\wedge R(x,y)))) \\vee \\exists z S(z)\\);\nEliminar Implicação: \\(\\forall x (\\neg P(x) \\vee \\exists y (Q(y) \\wedge R(x,y))) \\vee \\exists z S(z)\\);\nRenomear Variáveis: Para evitar conflitos, renomeamos \\(z\\) para \\(w\\) (pois \\(z\\) não depende de \\(x\\)).\n\\[\\forall x (\\neg P(x) \\vee \\exists y (Q(y) \\wedge R(x,y))) \\vee \\exists w S(w)\\]\nMover Quantificadores:\n\n\n\\(\\forall x \\exists y (\\neg P(x) \\vee (Q(y) \\wedge R(x,y))) \\vee \\exists w S(w)\\);\n\\(\\forall x \\exists y \\exists w (\\neg P(x) \\vee (Q(y) \\wedge R(x,y)) \\vee S(w))\\);\n\n\nFNP Final: \\(\\forall x \\exists y \\exists w ((\\neg P(x) \\vee (Q(y) \\wedge R(x,y))) \\vee S(w))\\).\n\nEm Prolog:\n% Definir predicados para um domínio finito\np(x1). p(x2).\nq(y1). q(y2).\nr(x1, y1). r(x2, y2).\ns(z1).\n\n% Fórmula: ∀x (¬P(x) ∨ ∃y (Q(y) ∧ R(x,y))) ∨ ∃z S(z)\nformula :-\n    (forall(member(X, [x1, x2]),\n            (\\+ p(X) ; exists(member(Y, [y1, y2]), (q(Y), r(X, Y)))))\n    ; exists(member(Z, [z1]), s(Z))).\n\n% Testar a fórmula\ntest_formula :-\n    (formula -&gt;\n        write('Fórmula é satisfatível no domínio dado'), nl\n    ;   write('Fórmula não é satisfatível no domínio dado'), nl).\nQuestão 10: O Princípio da Resolução\n\nCláusulas:\n\n\n\\(\\neg P \\vee \\neg Q \\vee R\\);\n\n\\(P \\vee R\\);\n\n\\(Q\\);\n\n\\(\\neg R\\).\n\n\nProva por Resolução:\nResolvendo (1) e (2) sobre \\(P\\): \\[(\\neg Q \\vee R \\vee R) \\equiv (\\neg Q \\vee R)\\] (Cláusula 5)\nResolvendo (5) e (3) sobre \\(Q\\): \\[(R)\\] (Cláusula 6)\nResolvendo (6) e (4) sobre \\(R\\): \\[\\square\\] (Cláusula Vazia)\nConclusão: Como derivamos a cláusula vazia, o conjunto original de cláusulas é inconsistente (insatisfatível).\nConexão com Prolog: É exatamente isso que o Prolog faz. Para provar uma consulta ?- g, ele adiciona \\(\\neg g\\) à base de conhecimento e tenta derivar uma contradição (cláusula vazia). Se conseguir, a consulta original é tida como verdadeira.\n\nEm Prolog:\n% Cláusulas\nclause1(P, Q, R) :- \\+ P ; \\+ Q ; R.\nclause2(P, _, R) :- P ; R.\nclause3(_, Q, _) :- Q.\nclause4(_, _, R) :- \\+ R.\n\n% Verificar inconsistência\ninconsistent :-\n    \\+ (clause1(P, Q, R), clause2(P, Q, R), clause3(P, Q, R), clause4(P, Q, R)).\n\n% Testar inconsistência\ntest_inconsistency :-\n    (inconsistent -&gt;\n        write('Cláusulas são inconsistentes (deriva cláusula vazia)'), nl\n    ;   write('Cláusulas são consistentes'), nl, fail).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  }
]