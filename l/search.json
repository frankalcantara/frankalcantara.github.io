[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Programação Lógica",
    "section": "",
    "text": "1 Apresentação\nA Programação Lógica representa um paradigma fundamental na ciência da computação que tem suas raízes profundamente entrelaçadas com os princípios da lógica matemática e filosófica. Como Marvin Minsky observou, “Logic programming is the future of artificial intelligence”, destacando a importância central deste campo para o desenvolvimento de sistemas inteligentes.\nEste livro convida você a uma jornada através dos fundamentos da lógica e sua aplicação computacional, explorando desde os conceitos básicos da Lógica Proposicional até as aplicações mais avançadas em verificação formal de programas e inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#estrutura-do-livro",
    "href": "index.html#estrutura-do-livro",
    "title": "Introdução à Programação Lógica",
    "section": "1.1 Estrutura do Livro",
    "text": "1.1 Estrutura do Livro\nA obra está organizada em duas partes principais:\nParte I - Fundamentos da Lógica: Apresenta os conceitos fundamentais necessários para compreender a programação lógica, incluindo Lógica Proposicional, técnicas de prova, lógica predicativa e quantificadores.\nParte II - Aplicações Avançadas: Explora as aplicações práticas dos conceitos fundamentais, incluindo formas normais, construção de mundos lógicos, cláusulas de Horn, Prolog, verificação formal e desafios lógicos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#público-alvo",
    "href": "index.html#público-alvo",
    "title": "Introdução à Programação Lógica",
    "section": "1.2 Público-Alvo",
    "text": "1.2 Público-Alvo\nEste material foi desenvolvido para estudantes de ciência da computação, engenharia de software, matemática aplicada e profissionais interessados em compreender os fundamentos teóricos que sustentam muitas das tecnologias modernas de inteligência artificial e sistemas de inferência.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#metodologia",
    "href": "index.html#metodologia",
    "title": "Introdução à Programação Lógica",
    "section": "1.3 Metodologia",
    "text": "1.3 Metodologia\nCada capítulo combina teoria rigorosa com exemplos práticos e exercícios, permitindo ao leitor não apenas compreender os conceitos, mas também aplicá-los na resolução de problemas reais. O texto progride de forma gradual, construindo conhecimento de maneira incremental e sempre conectando novos conceitos aos já estabelecidos.\nEsperamos que esta jornada pela programação lógica seja tanto educativa quanto inspiradora, fornecendo as bases sólidas necessárias para explorar as fronteiras da computação e da inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "01-jornada-programacao-logica.html",
    "href": "01-jornada-programacao-logica.html",
    "title": "2  Introdução ao Paradigma da Programação Lógica",
    "section": "",
    "text": "Tip\n\n\n\nEstá sem tempo? Leia o Expresso.\n\n\nImagine, por um momento, que estamos explorando o universo dos computadores, mas em vez de sermos os comandantes, capazes de ditar todos os passos do caminho, nós fornecemos as diretrizes gerais e deixamos que o computador deduza o caminho. Pode parecer estranho para quem está envolvido com as linguagens do Paradigma Imperativo. Acredite ou não, isso é exatamente o que a Programação Lógica faz.\nEm vez de sermos forçados a ordenar cada detalhe do processo de solução de um problema, a Programação Lógica permite que declaremos o que queremos, e então deixemos o computador fazer o trabalho de encontrar os detalhes e processos necessários para resolver cada problema.\nNa Programação Imperativa partimos de uma determinada expressão e seguimos um conjunto de instruções até encontrar o resultado desejado. O programador fornece um conjunto de instruções que definem o fluxo de controle e modificam o estado da máquina a cada passo. O foco está em como o problema deve ser resolvido. Exemplos de linguagens imperativas incluem C++, Java e Python. Todas hoje são amplamente utilizadas e multiparadigmas, mas não são as únicas disponíveis. A Programação Imperativa é como um chef que segue uma receita passo a passo, onde cada etapa é crucial para o resultado final.\nNa Programação Declarativa, o programador fornece uma descrição lógica ou funcional, do que deve ser feito, sem especificar o fluxo de controle. O foco está no problema, não na solução. Exemplos incluem SQL, Prolog e Haskell. Na Programação Lógica, partimos de um objetivo (goal), quase como se fosse a prova de uma hipótese e, de acordo com um conjunto específico de regras, tentamos construir uma prova para esta hipótese.\nNa Programação Lógica, um dos paradigmas da Programação Declarativa, usamos a dedução para resolver problemas. Começamos com hipóteses e conjecturas.\nUma hipótese é uma suposição, expressa na forma de proposição, que é acreditada ser verdadeira, mas que ainda não foi provada. Uma conjectura, por sua vez, é uma proposição ou sentença declarativa assumida como verdadeira, mas que ainda não foi formalmente provada ou refutada. Com um pouco mais de formalidade, já que a formalidade é o combustível da lógica, podemos dizer:\nConjectura é uma proposição provisoriamente aceita como verdadeira com base em evidências incompletas ou raciocínio plausível, mas que ainda não foi provada ou refutada. É essencialmente uma suposição educada que serve como ponto de partida para investigação posterior. Conjecturas são frequentemente formuladas quando há padrões observáveis ou intuições teóricas, mas falta rigor demonstrativo. A conjetura de Goldbach, que afirma que todo número par maior que \\(2\\) pode ser expresso como a soma de dois números primos, é um exemplo clássico de conjectura. Embora muitos números pares tenham sido verificados e a conjectura pareça verdadeira, ainda não foi provada para todos os números pares.\nHipótese é uma proposição formulada de maneira mais sistemática e específica, que pode ser testada através de métodos empíricos ou dedutivos. Uma hipótese deve ser formulada de modo que seja possível, em princípio, confirmá-la ou refutá-la através de evidências ou procedimentos lógicos específicos. Por exemplo, a hipótese de que “a temperatura afeta a taxa de crescimento das plantas” pode ser testada através de experimentos controlados. Se os resultados do experimento confirmarem a relação entre temperatura e crescimento, a hipótese é apoiada; caso contrário, ela pode ser refutada ou modificada.\nNa Lógica de Primeira Ordem, conjecturas são expressas como fórmulas lógicas que precisam ser verificadas por meio de demonstrações ou contraexemplos. Por exemplo, considere a conjectura: “Todos os números primos são ímpares.” Em Lógica de Primeira Ordem, isso pode ser expresso como:\n\\[\n\\forall x (\\text{Primo}(x) \\rightarrow \\text{Ímpar}(x))\n\\]\nEssa conjectura pode ser refutada pelo contraexemplo do número 2, que é primo, mas não ímpar. Outro exemplo seria: “Todo ser humano é mortal,” expresso como:\n\\[\n\\forall x (\\text{Humano}(x) \\rightarrow \\text{Mortal}(x))\n\\]\nEssa conjectura pode ser considerada verdadeira em muitos contextos, mas requer verificação formal para ser aceita como teorema. Para testar a verdade expressa nessas sentenças, usaremos as ferramentas da Lógica de Primeira Ordem.\n Em resumo: programação imperativa focada no processo, no como chegar à solução; Programação Declarativa focada no problema em si, no o que precisa ser feito. Eu, sempre que posso, escolho uma linguagem descritiva. Não há glória, nem honra nesta escolha: apenas as lamúrias da opinião pessoal.\nSua escolha, pessoal e intransferível, entre estes paradigmas dependerá da aplicação que será construída, tanto quanto dependerá do estilo do programador. Contudo, o futuro parece cada vez mais orientado para linguagens declarativas, que permitam ao programador concentrar-se no problema, não nos detalhes da solução. Efeito que parece ser evidente se considerarmos os avanços da segunda década no século XXI no campo da Inteligência Artificial. Este documento contém a base matemática que suporta o entendimento da programação lógica e um pouco de Prolog, como linguagem de programação para solução de problemas. Será uma longa jornada.\nEm nossa jornada, percorreremos a Lógica de Primeira Ordem. Esta será a nossa primeira rota, que iremos subdividir em elementos interligados e interdependentes e, sem dúvida, de mesma importância e valor: a Lógica Proposicional e a lógica Predicativa. Não deixe de notar que muitos dos nossos companheiros de viagem, aqueles restritos à formalidade acadêmica, podem não entender as sutilezas desta divisão.\nEste timoneiro tenta não ser pretensioso. Partiremos da Lógica Proposicional com esperança de encontrar bons ventos que nos levem até o Prolog.\nA Lógica Proposicional é um tipo de linguagem matemática, suficientemente rica para expressar os problemas que precisamos resolver e suficientemente simples para que computadores possam lidar com ela. Quando esta ferramenta estiver conhecida mergulharemos na alma da Lógica de Primeira Ordem, a Lógica Predicativa, ou Lógica de Predicados, e então poderemos fazer sentido do mundo real de forma clara e bela.\nVamos enfrentar a inferência e a dedução, duas ferramentas fundamentais para extrair conhecimento de declarações lógicas. Imagine um detetive investigando um caso: ele coleta pistas, como pegadas no local do crime, uma testemunha que viu um suspeito de capa preta e a informação de que o crime ocorreu à noite. A inferência é como o processo que o detetive usa para conectar essas pistas. Para chegar a uma conclusão lógica. Por exemplo, se ele sabe que “toda pessoa de capa preta estava no evento à noite” e que “o crime aconteceu no evento à noite”, ele pode inferir que “o suspeito de capa preta é uma pessoa que pode ter cometido o crime”.\nNa Lógica de Primeira Ordem, esse processo é formalizado. Considere as seguintes declarações lógicas como nossas “pistas”:\n\nPremissa 1: Todo ser humano é mortal ((x ((x) (x)))).\nPremissa 2: Sócrates é humano ((())).\n\nUsando a inferência lógica, podemos deduzir que Sócrates é mortal ((())). Aqui, as premissas são as “pistas”, e a inferência é o raciocínio que nos leva à conclusão. Esse processo é incontestável na lógica: se as premissas são verdadeiras, a conclusão também será. Assim, a inferência nos permite extrair verdades novas a partir de verdades conhecidas, de forma clara e estruturada, como um detetive que resolve o caso sem deixar margem para dúvidas.\nNossos mares não serão brandos, mas não nos furtaremos a enfrentar os desafios da Cláusula de Horn, um conceito um pouco mais estranho. Uma restrição sintática sobre as cláusulas de uma fórmula lógica que torna o problema de satisfatibilidade mais fácil de resolver. Como um mapa que, se seguido corretamente, reduz a complexidade computacional de exponencial para polinomial. Muito mais simples, até mesmo passível de automatização eficiente através de algoritmos como unit propagation.\nAs águas se agitarão um pouco mais quando cruzarmos o território da satisfatibilidade, o problema central que governa toda a Lógica Proposicional. A questão fundamental de determinar se existe uma atribuição de valores de verdade que torna uma fórmula lógica verdadeira. Como um detetive que busca descobrir se uma combinação específica de pistas pode resolver completamente um mistério. Este problema, aparentemente simples em sua formulação, revela-se NP-completo, uma classe de problemas para os quais não se conhece algoritmo de tempo polinomial. Desafiando os limites da computação eficiente e impulsionando o desenvolvimento de algoritmos sofisticados como DPLL e CDCL.\n\n\n\n\n\n\nNote\n\n\n\nDPLL (Davis-Putnam-Logemann-Loveland) é um algoritmo clássico para resolver o problema SAT (satisfatibilidade) que utiliza backtracking sistemático. O algoritmo funciona atribuindo valores às variáveis de forma incremental e, quando encontra uma contradição, retrocede para explorar outras possibilidades. Incorpora otimizações como unit propagation (propagação de literais unitários) e pure literal elimination (eliminação de literais puros).\nCDCL (Conflict-Driven Clause Learning) representa a evolução moderna do DPLL. Quando o algoritmo encontra um conflito durante a busca, ao invés de simplesmente retroceder, ele analisa as causas do conflito e aprende uma nova cláusula que previne a repetição do mesmo erro. Essa capacidade de aprendizado, combinada com heurísticas sofisticadas para escolha de variáveis e níveis de backtrack não cronológico, torna o CDCL significativamente mais eficiente que o DPLL tradicional em instâncias práticas complexas.\n\n\nNo final do dia, cansados, porém felizes, vamos entender que, desde os tempos de Gödel, Turing e Church, tudo que queremos é que nossas máquinas sejam capazes de resolver problemas complexos com o mínimo de interferência nossa. Queremos que elas pensem, ou pelo menos, que simulem o pensamento. Aqui, neste objetivo, entre as pérolas mais reluzentes da evolução humana destaca-se a Programação Lógica.\nComo diria Newton podemos olhar tão longe porque nos apoiamos nos ombros de gigantes. Assim, precisamos visitar a história para entender como chegamos até aqui.\nO termo Programação Lógica aparece em meados dos anos 1970 como uma evolução dos esforços nas pesquisas sobre a prova computacional de teoremas matemáticos e Inteligência Artificial. O homem querendo fazer máquinas capazes de raciocinar como o homem. Deste esforço surgiu a esperança de que poderíamos usar a lógica como uma linguagem de programação, em inglês, programming in logic, ou Prolog. Aqui está a base deste conhecimento.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao Paradigma da Programação Lógica</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html",
    "href": "01a-introducao-prolog.html",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "",
    "text": "3.1 O que é Prolog?\nO Prolog (Programming in Logic) é uma linguagem de programação declarativa baseada na lógica de primeira ordem e no princípio de resolução SLD (Selective Linear Definite clause resolution). Desenvolvida por Alain Colmerauer e Philippe Roussel na Universidade de Marselha em 1972, representa um paradigma fundamentalmente diferente das linguagens imperativas tradicionais.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#o-que-é-prolog",
    "href": "01a-introducao-prolog.html#o-que-é-prolog",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "",
    "text": "3.1.1 Paradigma Declarativo vs. Imperativo\nEm linguagens imperativas (C, Java, Python), o programador especifica como resolver um problema através de uma sequência de comandos que modificam o estado do programa. Em Prolog, o programador especifica o que constitui uma solução através de:\n\nFatos: Afirmações básicas sobre o domínio do problema\nRegras: Relações lógicas entre fatos\nConsultas: Perguntas sobre o que pode ser deduzido\n\nO interpretador Prolog utiliza um mecanismo de inferência baseado em resolução e backtracking para encontrar provas construtivas, isto é, não apenas determina se uma afirmação é verdadeira, mas também fornece os valores das variáveis que a tornam verdadeira.\n\n\n3.1.2 Fundamentos Teóricos\nO Prolog baseia-se na correspondência entre:\n\nLógica de primeira ordem → Expressividade para representar conhecimento\nCláusulas de Horn → Subconjunto decidível da lógica proposicional\nPrincípio de resolução → Método de prova por refutação\nMundo fechado (Closed World Assumption) → O que não pode ser provado é falso\n\nPara nossos propósitos práticos, utilizaremos o SWISH, uma interface web que implementa o interpretador SWI-Prolog.\nO SWISH (SWI-Prolog for Philippe Rousselaring) é uma plataforma online que permite executar código Prolog diretamente no navegador, sem necessidade de instalação. Existem vários servidores gratuitos na internet com recursos disponíveis, como compartilhamento de código, colaboração em tempo real e uma interface amigável para iniciantes. Eu uso o SWI. Este servidor é mantido pela comunidade SWI-Prolog, é gratuito e quase sempre está disponível.\n\n\n3.1.3 Como Acessar o SWISH.SWI-Prolog\n\nVá para: https://swish.swi-prolog.org/\nClique em “Create a program” para criar um novo programa\nVocê verá uma interface dividida em duas partes:\n\nLado esquerdo: Editor de código no qual você escreve fatos e regras;\nLado direito: Console de consultas no qual você faz perguntas (consultas) ao Prolog.\n\n\nEste ambiente pode ser visto na Figure 3.1.\n\n\n\n\n\n\nScreenshot do SWISH\n\n\n\n\nFigure 3.1: Página padrão do Swish-swi-prolog.org com o editor de código à esquerda e o console de consultas à direita.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#estrutura-básica-do-prolog-cláusulas-de-horn",
    "href": "01a-introducao-prolog.html#estrutura-básica-do-prolog-cláusulas-de-horn",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.2 Estrutura Básica do Prolog: Cláusulas de Horn",
    "text": "3.2 Estrutura Básica do Prolog: Cláusulas de Horn\nO Prolog trabalha exclusivamente com cláusulas de Horn, uma forma restrita de fórmulas lógicas que possuem no máximo um literal positivo. Esta restrição garante a decidibilidade e eficiência do processo de inferência.\n\n3.2.1 Fatos (Cláusulas Unitárias)\nFatos são cláusulas de Horn unitárias da forma \\(P(t_1, t_2, ..., t_n)\\), onde \\(P\\) é um predicado e \\(t_i\\) são termos. Representam conhecimento básico incondicional sobre o domínio:\n% Predicados unários\nmamifero(gato).\nmamifero(cachorro).\n\n% Predicados binários (relações)\nmaior_que(5, 3).\npai(joao, pedro).\n\n% Predicados n-ários\ndistancia(sao_paulo, rio_janeiro, 400).\nInterpretação formal: Cada fato \\(P(a_1, ..., a_n)\\) é interpretado como “é verdade que \\(P(a_1, ..., a_n)\\)” no modelo mínimo de Herbrand.\n\n\n3.2.2 Regras (Cláusulas Definidas)\nRegras são cláusulas de Horn definidas da forma \\(H \\leftarrow B_1 \\land B_2 \\land ... \\land B_n\\), representadas como H :- B1, B2, ..., Bn. onde:\n\n\\(H\\) (cabeça): Consequente da implicação;\n\\(B_i\\) (corpo): Antecedentes que devem ser satisfeitos;\n\\(\\leftarrow\\): Implicação reversa (“se”);\n\\(\\land\\): Conjunção lógica (vírgula em Prolog).\n\n% Regra simples: ∀X (mamifero(X) → animal(X))\nanimal(X) :- mamifero(X).\n\n% Regra composta: ∀X (voa(X) ↔ ave(X) ∧ ¬pinguim(X))\nvoa(X) :- ave(X), \\+ pinguim(X).\n\n% Regra recursiva: ancestral\nancestral(X, Y) :- pai(X, Y).\nancestral(X, Z) :- pai(X, Y), ancestral(Y, Z).\nSemântica operacional: Para provar \\(H\\), o interpretador deve provar todos os \\(B_i\\) do corpo.\n\n\n3.2.3 Consultas (Goals)\nConsultas são cláusulas de Horn negativas da forma \\(\\leftarrow B_1 \\land B_2 \\land ... \\land B_n\\), representadas como ?- B1, B2, ..., Bn. O interpretador tenta encontrar uma refutação da negação da consulta.\n% Consulta ground (sem variáveis)\n?- mamifero(gato).\n% Resposta: true/false\n\n% Consulta com variáveis livres\n?- animal(X).\n% Resposta: substituições que tornam a consulta verdadeira\n\n% Consulta conjuntiva\n?- pai(X, Y), mae(Z, Y).\n% Encontra todos os X, Y, Z que satisfazem ambas as condições\nProcesso de resolução: O Prolog utiliza o algoritmo SLD-resolution para encontrar uma derivação vazia, provando a consulta por contradição.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#sintaxe-e-semântica-formal",
    "href": "01a-introducao-prolog.html#sintaxe-e-semântica-formal",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.3 Sintaxe e Semântica Formal",
    "text": "3.3 Sintaxe e Semântica Formal\n\n3.3.1 Termos e Estruturas de Dados\nO Prolog trabalha com uma hierarquia bem definida de termos:\n\n3.3.1.1 Termos Simples\n\nÁtomos: constantes simbólicas → joao, nil, [];\nNúmeros: inteiros e reais → 42, 3.14159, -273;\nVariáveis: começam com maiúscula → X, Lista, _Temp;\n\n_ = variável anônima (singleton).\n\n\n\n\n3.3.1.2 Termos Compostos\n\nEstruturas: functor(arg1, arg2, ..., argN);\nListas: [H|T] onde H é cabeça e T é cauda;\nStrings: \"texto\" (lista de códigos ASCII).\n\n% Estruturas complexas\npessoa(nome(joao, silva), idade(25), endereco(rua(x), numero(123))).\n\n% Listas\nlista_vazia([]).\nlista_numeros([1, 2, 3, 4]).\nlista_aninhada([[a, b], [c, d], [e]]).\n\n\n\n3.3.2 Operadores e Conectivos Lógicos\n\n3.3.2.1 Conectivos Básicos\n% Conjunção (∧): vírgula\nregra(X) :- condicao1(X), condicao2(X).\n\n% Disjunção (∨): múltiplas cláusulas\nopcao(X) :- caminho1(X).\nopcao(X) :- caminho2(X).\n% Equivale a: opcao(X) ← caminho1(X) ∨ caminho2(X)\n\n\n3.3.2.2 Negação por Falha (\\+)\n% NAF (Negation as Failure) - não é negação clássica!\nvoa(X) :- ave(X), \\+ pinguim(X).\n% Lê-se: \"X voa se X é ave E não pode ser provado que X é pinguim\"\n\n% CUIDADO: \\+ é não-monotônica\n% Se pinguim(tweety) for adicionado depois, voa(tweety) muda de true para false\n\n\n3.3.2.3 Operadores de Comparação\n% Unificação\nX = Y          % X unifica com Y\nX \\= Y         % X não unifica com Y\n\n% Comparação aritmética (após avaliação)\nX =:= Y        % X é aritmeticamente igual a Y\nX =\\= Y        % X é aritmeticamente diferente de Y\nX &lt; Y, X &gt; Y   % Comparações numéricas\nX =&lt; Y, X &gt;= Y\n\n% Comparação de termos (ordem lexicográfica)\nX == Y         % X é idêntico a Y\nX \\== Y        % X não é idêntico a Y\nX @&lt; Y, X @&gt; Y % Comparação de termos\n\n\n\n3.3.3 Comentários\n% Comentário de linha única\n\n/* Comentário\n   de múltiplas\n   linhas */",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#unificação-o-coração-do-prolog",
    "href": "01a-introducao-prolog.html#unificação-o-coração-do-prolog",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.4 Unificação: O Coração do Prolog",
    "text": "3.4 Unificação: O Coração do Prolog\nUnificação é o processo de encontrar substituições que tornam dois termos sintaticamente idênticos. É o mecanismo fundamental para:\n\nPassagem de parâmetros;\nPattern matching;\nResolução de consultas.\n\n\n3.4.1 Algoritmo de Unificação (Robinson, 1965)\nDados termos \\(s\\) e \\(t\\), a unificação encontra o unificador mais geral (MGU) \\(\\theta\\) tal que \\(s\\theta = t\\theta\\).\n% Casos básicos\n?- X = joao.           % X ← joao\n?- f(X, Y) = f(a, b).  % X ← a, Y ← b\n?- [H|T] = [1,2,3].    % H ← 1, T ← [2,3]\n\n% Unificação recursiva\n?- pessoa(nome(X), idade(Y)) = pessoa(nome(joao), idade(25)).\n% X ← joao, Y ← 25\n\n% Falha de unificação\n?- f(a) = g(a).        % false (functors diferentes)\n?- f(a, b) = f(a).     % false (aridades diferentes)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#backtracking-e-espaço-de-busca",
    "href": "01a-introducao-prolog.html#backtracking-e-espaço-de-busca",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.5 Backtracking e Espaço de Busca",
    "text": "3.5 Backtracking e Espaço de Busca\nBacktracking é a estratégia de busca sistemática que o Prolog usa para explorar todas as possíveis derivações. Implementa uma busca em profundidade com retrocesso.\n\n3.5.1 Mecanismo de Escolha e Retrocesso\n% Base de dados\ngosta(maria, comida, pizza).\ngosta(maria, comida, sushi).\ngosta(joao, comida, pizza).\ngosta(joao, bebida, cerveja).\n\nsaida(X, Y) :- gosta(X, comida, Y).\nsaida(X, Y) :- gosta(X, bebida, Y).\nTrace da consulta ?- saida(maria, X).:\n\nPonto de escolha: primeira cláusula de saida/2;\nUnificação: saida(maria, X) com saida(X, Y) :- gosta(X, comida, Y)\n\nX ← maria, Y ← X (variável da consulta);\n\nNova meta: gosta(maria, comida, X);\nPrimeira solução: X ← pizza;\nBacktrack (se solicitado): tenta próxima solução;\nSegunda solução: X ← sushi;\nBacktrack: tenta segunda cláusula de saida/2;\nNova meta: gosta(maria, bebida, X) → falha.\n\n\n\n3.5.2 Cut (!) - Controle de Backtracking\n% Sem cut - busca exaustiva\nmax_sem_cut(X, Y, X) :- X &gt;= Y.\nmax_sem_cut(X, Y, Y) :- Y &gt; X.\n\n% Com cut - determinístico\nmax_com_cut(X, Y, X) :- X &gt;= Y, !.\nmax_com_cut(X, Y, Y).\n\n% Green cut vs Red cut\ndeterministico(X) :- condicao(X), !.  % Green cut (não muda semântica)\ndeterministico(X) :- alternativa(X).\n\nperigoso(X) :- condicao1(X), !, acao_perigosa(X).  % Red cut (muda semântica)\nperigoso(X) :- condicao2(X).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#resolução-sld-e-árvores-de-prova",
    "href": "01a-introducao-prolog.html#resolução-sld-e-árvores-de-prova",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.6 Resolução SLD e Árvores de Prova",
    "text": "3.6 Resolução SLD e Árvores de Prova\n\n3.6.1 Processo de Resolução\nO Prolog implementa SLD-resolution (Selective Linear Definite clause resolution):\n\nSelecionar literal do goal atual\nUnificar com cabeça de uma cláusula\nResolver substituindo o literal pelo corpo da cláusula\nRepetir até goal vazio (sucesso) ou falha\n\n\n\n3.6.2 Árvore de Derivação SLD\nPara a consulta ?- ancestral(joao, X). com programa:\nancestral(X, Y) :- pai(X, Y).\nancestral(X, Z) :- pai(X, Y), ancestral(Y, Z).\npai(joao, pedro).\npai(pedro, ana).\n?- ancestral(joao, X)\n├─ (regra 1) pai(joao, X) ──→ X=pedro \n└─ (regra 2) pai(joao, Y), ancestral(Y, X)\n   └─ Y=pedro, ancestral(pedro, X)\n      ├─ (regra 1) pai(pedro, X) ──→ X=ana \n      └─ (regra 2) pai(pedro, Z), ancestral(Z, X) ──→ falha\n\n\n3.6.3 Complexidade e Limitações\n\nDecidibilidade: Programas Prolog podem não terminar;\nCompletude: SLD-resolution é completa para cláusulas de Horn;\nComplexidade: Exponencial no pior caso (backtracking);\nOrdem das cláusulas: Afeta eficiência e terminação.\n\n% Programa que não termina\nloop(X) :- loop(X).\n\n% Solução: reordenar para casos base primeiro\nfatorial(0, 1) :- !.\nfatorial(N, F) :- N &gt; 0, N1 is N-1, fatorial(N1, F1), F is N * F1.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#executando-código-no-swish",
    "href": "01a-introducao-prolog.html#executando-código-no-swish",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.7 Executando Código no SWISH",
    "text": "3.7 Executando Código no SWISH\n\n3.7.1 Passo 1: Escrever o Programa\nEm um arquivo novo, no editor (lado esquerdo), digite fatos e regras:\n% Base de conhecimento sobre família\npai(joao, pedro).\npai(pedro, ana).\nmae(maria, pedro).\nmae(ana, carlos).\n\n% Regra para definir genitor\ngenitor(X, Y) :- pai(X, Y).\ngenitor(X, Y) :- mae(X, Y).\n\n% Regra para definir avô\navo(X, Z) :- genitor(X, Y), genitor(Y, Z).\n\n\n3.7.2 Passo 2: Salvar e Carregar\n\nPara salvar um programa, você precisa estar logado no SWISH. Pode logar com o sua conta do Google ou com o StackOverflow.\nClique no menu File/Save para salvar o programa\nUma vez salvo, o programa é automaticamente carregado na memória do Prolog\n\n\n\n3.7.3 Passo 3: Fazer Consultas\nNo console (lado direito), digite consultas:\n?- pai(joao, pedro).\nResposta esperada: true.\n?- genitor(X, pedro).\nResposta esperada: X = joao ; X = maria.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#interpretando-respostas",
    "href": "01a-introducao-prolog.html#interpretando-respostas",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.8 Interpretando Respostas",
    "text": "3.8 Interpretando Respostas\n\n3.8.1 Respostas Simples\n\ntrue. → A consulta é verdadeira;\nfalse. → A consulta é falsa/não pode ser provada.\n\n\n\n3.8.2 Respostas com Variáveis\n?- pai(X, pedro).\nX = joao.\nO Prolog encontrou que X = joao satisfaz a consulta.\n\n\n3.8.3 Múltiplas Soluções\n?- genitor(X, Y).\nX = joao, Y = pedro ;\nX = pedro, Y = ana ;\nX = maria, Y = pedro ;\nX = ana, Y = carlos.\n\nUse ; (ponto e vírgula) ou barra de espaço para ver a próxima solução;\nO Prolog mostra todas as combinações possíveis.\n\n\n\n3.8.4 Forçando Múltiplas Respostas\nApós uma resposta, você pode:\n\nPressionar ; para ver mais soluções;\nPressionar . (ponto) para parar.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#aplicações-em-ciência-da-computação",
    "href": "01a-introducao-prolog.html#aplicações-em-ciência-da-computação",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.9 Aplicações em Ciência da Computação",
    "text": "3.9 Aplicações em Ciência da Computação\n\n3.9.1 1. Sistemas Especialistas e Representação de Conhecimento\n% Sistema de diagnóstico médico\nsintoma(joao, febre).\nsintoma(joao, tosse).\nsintoma(maria, febre).\nsintoma(maria, dor_cabeca).\n\n% Regras de diagnóstico\ndiagnostico(Paciente, gripe) :-\n    sintoma(Paciente, febre),\n    sintoma(Paciente, tosse),\n    \\+ sintoma(Paciente, erupcao).\n\ndiagnostico(Paciente, enxaqueca) :-\n    sintoma(Paciente, dor_cabeca),\n    sintoma(Paciente, nausea).\n\n% Incerteza bayesiana (extensão)\ndiagnostico_probabilistico(Paciente, Doenca, Prob) :-\n    findall(S, sintoma(Paciente, S), Sintomas),\n    calcular_probabilidade(Sintomas, Doenca, Prob).\n\n\n3.9.2 2. Processamento de Linguagem Natural\n% Gramática de cláusulas definidas (DCG)\nsentenca --&gt; sintagma_nominal, sintagma_verbal.\nsintagma_nominal --&gt; determinante, substantivo.\nsintagma_verbal --&gt; verbo, sintagma_nominal.\n\ndeterminante --&gt; [o].\ndeterminante --&gt; [a].\nsubstantivo --&gt; [gato].\nsubstantivo --&gt; [rato].\nverbo --&gt; [persegue].\n\n% Parsing\n?- sentenca([o, gato, persegue, o, rato], []).\n% true - sentença válida\n\n% Geração\n?- sentenca(S, []).\n% S = [o, gato, persegue, o, rato]\n% S = [o, gato, persegue, a, rato]\n% ... (todas as combinações válidas)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#limitações-e-considerações-de-performance",
    "href": "01a-introducao-prolog.html#limitações-e-considerações-de-performance",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.10 Limitações e Considerações de Performance",
    "text": "3.10 Limitações e Considerações de Performance\n\n3.10.1 Complexidade Computacional\n\nConsultas ground: Tempo linear no tamanho do programa;\nConsultas com variáveis: Potencialmente exponencial;\nProgramas recursivos: Podem não terminar;\nEspaço: Pilha de escolhas pode crescer exponencialmente.\n\n\n\n3.10.2 Otimizações Modernas\n% Tabling (memoização) - SWI-Prolog\n:- table fibonacci/2.\n\nfibonacci(0, 1) :- !.\nfibonacci(1, 1) :- !.\nfibonacci(N, F) :-\n    N &gt; 1,\n    N1 is N-1, N2 is N-2,\n    fibonacci(N1, F1),\n    fibonacci(N2, F2),\n    F is F1 + F2.\n\n% Constraint Logic Programming (CLP)\n:- use_module(library(clpfd)).\n\nsudoku(Vars) :-\n    Vars = [X11,X12,X13,X21,X22,X23,X31,X32,X33],\n    Vars ins 1..3,\n    all_different([X11,X12,X13]),\n    all_different([X21,X22,X23]),\n    all_different([X31,X32,X33]),\n    all_different([X11,X21,X31]),\n    all_different([X12,X22,X32]),\n    all_different([X13,X23,X33]).\n\n\n3.10.3 Boas Práticas para Eficiência\n\nOrdenação de cláusulas: Casos base primeiro;\nUso criterioso do cut: Evitar backtracking desnecessário;\nTail recursion: Para evitar estouro de pilha;\nIndexação: SWI-Prolog indexa primeiro argumento automaticamente;\nAvoid ground/1 quando possível: Use type checking específico.\n\nNós vamos voltar a esses tópicos ao longo do livro, mas é importante ter uma visão geral desde o início. Principalmente porque a partir deste ponto, podemos incluir testes com o Prolog para validar a lógica que suporta o funcionamento do próprio Prolog. Mais um círculo virtuoso de aprendizado e desenvolvimento tecnológico.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html",
    "href": "02-fundamentos-logica-proposicional.html",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "",
    "text": "4.0.1 Alfabeto e Sintaxe da Lógica de Primeira Ordem\nA Lógica de Primeira Ordem é uma linguagem e, consequentemente, foi criada a partir de um alfabeto, \\(\\Sigma\\), de um conjunto de axiomas e de um conjunto de regras de inferência. Esta linguagem consiste de todas as Fórmulas Bem Formadas da teoria das lógicas proposicional e predicativa. Neste ponto, a atenta leitora deve perceber que o conjunto de axiomas é um subconjunto do conjunto de Fórmulas Bem Formadas.\nO alfabeto \\(\\Sigma\\) que estamos definindo poderá ser dividido em classes formadas por conjuntos de símbolos agrupados por semelhança. Assim:\nNa lógica matemática, uma Fórmula Bem Formada, ou Expressão Bem Formada, é uma sequência finita de símbolos formada de acordo com as regras gramaticais de uma linguagem formal especificamente desenvolvida para a redação das fórmulas da lógica.\nEm Lógica de Primeira Ordem, uma Fórmula Bem Formada é uma expressão que só pode ser verdadeira ou falsa. As Fórmulas Bem Formadas são compostas de símbolos que representam quantificadores, variáveis, constantes, predicados, e conectivos lógicos. Cuja distribuição e uso seguirão as regras sintáticas, gramaticais e semânticas da linguagem da lógica. Aprender lógica é aprender esta linguagem.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#fundamentos-da-lógica-proposicional",
    "href": "02-fundamentos-logica-proposicional.html#fundamentos-da-lógica-proposicional",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.1 Fundamentos da Lógica Proposicional",
    "text": "4.1 Fundamentos da Lógica Proposicional\nEsse sistema, também chamado de álgebra booleana, fundamental para o desenvolvimento da computação, é uma verdadeira tapeçaria de possibilidades. Na Lógica Proposicional, declarações atômicas, que só podem ter valores verdadeiro, \\(TRUE\\), ou falso \\(FALSE\\), são entrelaçadas em declarações compostas cuja veracidade, segundo as regras desse cálculo, depende dos valores de verdade das declarações atômicas que as compõem quando sujeitas aos operadores, ou aos conectivos, que definimos anteriormente.\nNa Lógica Proposicional, representamos proposições atômicas por letras como \\(P\\), \\(Q\\), \\(R\\), \\(S\\), ou usando índices como em \\(X_1\\), \\(X_2\\), etc. Um literal será definido como uma variável literal, ou uma proposição atômica, (por exemplo, \\(P\\) ou \\(Q\\)) ou sua negação (por exemplo, \\(\\neg P\\) ou \\(\\neg Q\\)). Os literais são as unidades básicas da Lógica Proposicional, assumindo valores de verdade verdadeiro (\\(TRUE\\)) ou falso (\\(FALSE\\)), e são combinados por conectivos lógicos (\\(\\neg, \\wedge, \\vee, \\rightarrow, \\leftrightarrow\\)) para formar fórmulas mais complexas.\nNa Lógica Proposicional, as fórmulas são conhecidas como Fórmulas Bem Formadas. Elas podem ser atômicas ou compostas. Nas fórmulas compostas, um operador principal, um conectivo, liga duas fórmulas atômicas, ou duas fórmulas compostas. Ou seja, as declarações atômicas e compostas são costuradas por conectivos para produzir declarações compostas, cujo valor de verdade depende dos valores de verdade das declarações componentes. Os conectivos que consideramos inicialmente, e suas tabelas-verdade podem ser vistos na #tbl-verdade1:\n\n\n\nTable 4.1: Tabela Verdade, operadores básicos.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P\\vee Q\\)\n\\(P\\wedge Q\\)\n\\(\\neg P\\)\n\\(P\\rightarrow Q\\)\n\\(P\\leftrightarrow Q\\)\n\n\n\n\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\n\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\n\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\n\n\n\n\n4.1.0.1 Análise dos Conectivos Lógicos\nQuando usamos a Tabela Verdade em uma declaração composta, podemos verificar a fórmula como verdadeira ou falsa. Para tanto, basta seguir as regras de precedência e aplicar os valores representados na Tabela Verdade de cada conectivo, simplificando a expressão. O uso da Tabela Verdade é uma alternativa mais direta do que o uso dos axiomas da Lógica Proposicional.\nNa tabela Table 4.1, listamos os conectivos, ou operadores, da Lógica Proposicional.\nO operador \\(\\vee\\), também chamado de ou inclusivo, é verdadeiro quando pelo menos um dos termos é verdadeiro. A atenta leitora deve observar que o \\(\\vee\\) difere do operador \\(\\oplus\\), ou exclusivo, que será falso se ambos os termos forem iguais, sejam eles verdadeiros ou falsos.\nO operador \\(\\wedge\\), também chamado de conjunção, é verdadeiro apenas quando ambos os termos são verdadeiros. Em linguagem natural, corresponde ao “e” lógico, como em “o céu está azul e a grama é verde”.\nO condicional \\(\\rightarrow\\) não implica em causalidade. O condicional \\(\\rightarrow\\) é falso apenas quando o antecedente é verdadeiro e o consequente é falso.\nO bicondicional \\(\\leftrightarrow\\) equivale a ambos os componentes terem o mesmo valor-verdade. Em linguagem natural, corresponde à expressão “se e somente se”, indicando que as duas proposições são verdadeiras ou falsas simultaneamente.\nTodos os operadores, ou conectivos, conectam duas declarações, exceto \\(\\neg\\) que se aplica a apenas um termo. O operador \\(\\neg\\), chamado de negação, inverte o valor-verdade de uma proposição, sendo verdadeiro quando a proposição é falsa e vice-versa.\nCada operador com sua própria aridade como pode ser visto na Table 4.2:\n\n\n\nTable 4.2: Aridade dos Operadores da Lógica Proposicional.\n\n\n\n\n\nNo Argumentos\nAridade\nExemplos\n\n\n\n\n1\nUnário\n\\(P(x)\\), \\(7x\\)\n\n\n2\nBinário\n\\(x \\vee y\\), \\(c \\wedge y\\)\n\n\n\n\n\n\nAinda observando a Table 4.1, que contém a Tabela Verdade dos operadores da Lógica Proposicional, é possível perceber que se tivermos quatro termos diferentes, em vez de dois, teremos \\(2^4 = 16\\) linhas. Independentemente do número de termos, se para uma determinada Fórmula Bem Formada todos os resultados forem verdadeiros, \\(TRUE\\), teremos uma tautologia, se todos forem falsos, \\(FALSE\\) uma contradição.\n\n\n4.1.1 Exercícios: Tabelas-Verdade e Conectivos Lógicos\nInstrução: Para cada uma das fórmulas a seguir, construa a tabela-verdade completa.\n\n\\(P \\rightarrow \\neg Q\\)\n\\((P \\lor Q) \\land R\\)\n\\(P \\leftrightarrow (P \\land Q)\\)\n\\((P \\land (P \\rightarrow Q)) \\rightarrow Q\\)\n\\((P \\rightarrow Q) \\land (P \\land \\neg Q)\\)\n\\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\)\n\\((A \\rightarrow B) \\lor (B \\rightarrow C)\\)\n\\(\\neg(P \\land Q) \\leftrightarrow (\\neg P \\lor \\neg Q)\\)\nAnalise a validade do seguinte argumento construindo uma tabela-verdade para a fórmula correspondente: “Se o programa é eficiente (\\(P\\)), o custo é baixo (\\(Q\\)). O programa é eficiente. Portanto, o custo é baixo.”\nConstrua a tabela-verdade para a fórmula \\((P \\lor Q) \\rightarrow (P \\land Q)\\).\n\n\n\n4.1.2 Equivalências Lógicas\n\n4.1.2.1 Principais Leis da Lógica Proposicional\nUma tautologia é uma fórmula que é sempre verdadeira, não importa os valores dados às variáveis. Na Programação Lógica, tautologias são verdades universais no domínio do problema. Uma contradição é uma fórmula que é sempre falsa, independentemente dos valores das variáveis. Em Programação Lógica, contradições mostram inconsistências ou impossibilidades lógicas no domínio.\nIdentificar tautologias permite simplificar expressões e fazer inferências válidas automaticamente. Reconhecer contradições evita o custo de tentar provar algo logicamente impossível.\nLinguagens de programação que usam a Programação Lógica usam unificação e resolução para fazer deduções. Tautologias geram cláusulas vazias que simplificam esta resolução. Em problemas de satisfatibilidade, se obtivermos uma contradição, sabemos que as premissas são insatisfatíveis. Segure as lágrimas e o medo. Os termos unificação e satisfatibilidade serão explicados assim que sejam necessários. Antes disso, precisamos falar de equivalências. Para isso vamos incluir um metacaractere no alfabeto da nossa linguagem: o caractere \\(\\equiv\\) que permitirá o entendimento das principais equivalências da Lógica Proposicional explicitadas a seguir:\nAs equivalências lógicas permitem validar Fórmulas Bem Formadas sem recorrer a tabelas-verdade, simplificando expressões e facilitando provas lógicas. A tabela Table 4.3 que usa um metasímbolo para definir equivalência \\(\\equiv\\), que não faz parte da linguagem que definimos para a lógica de primeira ordem mas será usado aqui em prol da didática, apresenta as principais equivalências da Lógica Proposicional, usadas nos exemplos deste documento:\n\n\n\nTable 4.3: Tabela 3 - Equivalências em Lógica Proposicional.\n\n\n\n\n\n\n\n\n\n\nExpressão Lógica Equivalente\nNome da Lei/Propriedade\nRef.\n\n\n\n\n( P Q Q P )\nComutatividade da Conjunção\n(1)\n\n\n( P Q Q P )\nComutatividade da Disjunção\n(2)\n\n\n( P (Q R) (P Q) (P R) )\nDistributividade da Conjunção sobre a Disjunção\n(3)\n\n\n( P (Q R) (P Q) (P R) )\nDistributividade da Disjunção sobre a Conjunção\n(4)\n\n\n( (P Q) P Q )\nLei de De Morgan\n(5)\n\n\n( (P Q) P Q )\nLei de De Morgan\n(6)\n\n\n( P Q P Q )\nDefinição de Implicação\n(7)\n\n\n( P Q (P Q) (Q P) )\nDefinição de Equivalência\n(8)\n\n\n( P Q Q P )\nLei da Contrapositiva\n(9)\n\n\n( P P \\(FALSE\\) )\nLei da Contradição\n(10)\n\n\n( P P \\(TRUE\\) )\nLei do Terceiro Excluído\n(11)\n\n\n( (P) P )\nLei da Dupla Negação\n(12)\n\n\n( P P )\nLei da Identidade\n(13)\n\n\n( P \\(TRUE\\) P )\nLei da Identidade para a Conjunção\n(14)\n\n\n( P \\(FALSE\\) \\(FALSE\\) )\nLei do Domínio para a Conjunção\n(15)\n\n\n( P \\(TRUE\\) \\(TRUE\\) )\nLei do Domínio para a Disjunção\n(16)\n\n\n( P \\(FALSE\\) P )\nLei da Identidade para a Disjunção\n(17)\n\n\n( (P Q) R P (Q R) )\nAssociatividade da Conjunção\n(18)\n\n\n( (P Q) R P (Q R) )\nAssociatividade da Disjunção\n(19)\n\n\n( P P P )\nIdempotência da Conjunção\n(20)\n\n\n( P P P )\nIdempotência da Disjunção\n(21)\n\n\n\n\n\n\nComo as equivalências apresentadas na Tabela Table 4.3 permitem validar Fórmulas Bem Formadas, sem o uso de uma tabela verdade, a corajosa leitora poderia tentar provar cada uma delas.\n\n\n4.1.2.2 Aplicação das Equivalências Lógicas\nAs equivalências que mencionei surgiram quase naturalmente enquanto escrevia, mais por hábito e necessidade do que por um raciocínio organizado. Existem muitas equivalências, mas essas são as que uso com mais frequência. Talvez, alguns exemplos de validação de Fórmulas Bem Formadas, usando apenas as equivalências da Tabela 3, possam inflar as velas do conhecimento e nos guiar pelo caminho que devemos seguir:\n\n4.1.2.2.1 Exemplos de Simplificação - Nível Básico\nExemplo 1: Vamos simplificar a fórmula \\(P \\wedge (Q \\vee (P \\wedge R))\\) e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\nP \\wedge (Q \\vee (P \\wedge R)) &\\equiv (P \\wedge Q) \\vee (P \\wedge (P \\wedge R)) && \\text{Distributividade da Conjunção sobre a Disjunção} \\\\\n&\\equiv (P \\wedge Q) \\vee ((P \\wedge P) \\wedge R) && \\text{Associatividade da Conjunção} \\\\\n&\\equiv (P \\wedge Q) \\vee (P \\wedge R) && \\text{Idempotência da Conjunção}\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (P \\wedge R)\\). Para determinar se a fórmula é uma tautologia, satisfatível ou falsificável, construímos a tabela-verdade completa para as variáveis \\(P\\), \\(Q\\), \\(R\\):\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(P \\wedge Q\\)\n\\(P \\wedge R\\)\n\\((P \\wedge Q) \\vee (P \\wedge R)\\)\n\n\n\n\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nFALSE\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\n\n\nFALSE\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\nFALSE\n\n\n\nAnalisando a tabela completa: - A fórmula é verdadeira em 3 das 8 linhas (linhas 1, 2 e 3), portanto é satisfatível. - A fórmula é falsa em 5 das 8 linhas, portanto não é uma tautologia. - A presença de linhas falsas confirma que a fórmula é falsificável.\nConclusão: A fórmula \\(P \\wedge (Q \\vee (P \\wedge R))\\) simplifica para \\((P \\wedge Q) \\vee (P \\wedge R)\\), que é satisfatível e falsificável, mas não é uma tautologia. Exemplo 2: \\(P\\rightarrow (Q \\wedge (R \\vee P))\\)\n\\[\n\\begin{align*}\nP \\rightarrow (Q \\wedge (R \\vee P)) &\\equiv \\neg P \\vee (Q \\wedge (R \\vee P)) && \\text{(7)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (\\neg P \\vee (R \\vee P)) && \\text{(4)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (R \\vee \\neg P \\vee P) && \\text{(2)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge $TRUE$ && \\text{(11)} \\\\\n&\\equiv \\neg P \\vee Q && \\text{(14)}\n\\end{align*}\n\\]\nExemplo 3: \\(\\neg (P \\wedge (Q \\rightarrow R))\\)\n\\[\n\\begin{align*}\n\\neg (P \\wedge (Q \\rightarrow R)) &\\equiv \\neg (P \\wedge (\\neg Q \\vee R)) && \\text{(7)} \\\\\n&\\equiv \\neg P \\vee \\neg (\\neg Q \\vee R) && \\text{(5)} \\\\\n&\\equiv \\neg P \\vee (Q \\wedge \\neg R) && \\text{(6)}\n\\end{align*}\n\\]\n\n\n4.1.2.2.2 Exemplos de Simplificação - Nível Intermediário\nExemplo 4: \\(\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S))\\)\n\\[\n\\begin{align*}\n\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S)) &\\equiv \\neg ((\\neg P \\vee Q) \\wedge (\\neg R \\vee S)) && \\text{(7)} \\\\\n&\\equiv \\neg (\\neg P \\vee Q) \\vee \\neg (\\neg R \\vee S) && \\text{(5)} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (R \\wedge \\neg S) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 5: Vamos simplificar a fórmula \\((P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P)\\) e determinar suas propriedades lógicas.\n\\[\n\\begin{align*}\n(P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P) &\\equiv (\\neg P \\vee Q) \\vee (\\neg R \\vee S) \\vee (\\neg E \\vee P) && \\text{Definição de Implicação} \\\\\n&\\equiv \\neg P \\vee Q \\vee \\neg R \\vee S \\vee \\neg E \\vee P && \\text{Associatividade da Disjunção} \\\\\n&\\equiv (\\neg P \\vee P) \\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{Comutatividade da Disjunção} \\\\\n&\\equiv$TRUE$\\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv$TRUE$&& \\text{Lei da Dominação da Disjunção}\n\\end{align*}\n\\]\nA expressão se simplifica para\\(TRUE\\)pela lei da dominação, que estabelece que \\(TRUE \\vee X \\equiv TRUE\\) para qualquer proposição \\(X\\).\nComo a fórmula se reduz a\\(TRUE\\), ela é uma tautologia - sempre verdadeira independentemente das valorações das variáveis proposicionais.\nVerificação: Em qualquer linha de uma tabela-verdade para as cinco variáveis \\((P, Q, R, S, E)\\), a presença de \\(\\neg P \\vee P\\) (que é sempre \\(TRUE\\)) garante que toda a disjunção seja verdadeira.\nConclusão: A fórmula \\((P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P)\\) é uma tautologia, pois se simplifica para\\(TRUE\\)através da presença de \\(\\neg P \\vee P\\) na disjunção expandida.\nExemplo 6: Vamos simplificar a fórmula \\(P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P)\\) passo a passo e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\n& P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P) \\\\\n&\\equiv P \\wedge (Q \\vee (\\neg R \\vee S)) \\vee ((\\neg E \\rightarrow P) \\wedge (P \\rightarrow \\neg E)) && \\text{Definição de Implicação, Definição de Equivalência} \\\\\n&\\equiv P \\wedge (Q \\vee \\neg R \\vee S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Definição de Implicação} \\\\\n&\\equiv (P \\wedge (Q \\vee \\neg R \\vee S)) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Reorganização para clareza}\n\\end{align*}\n\\]\nAplicando a distributividade da conjunção sobre a disjunção no primeiro termo:\n\\[\n\\begin{align*}\n&\\equiv (P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Distributividade}\n\\end{align*}\n\\]\nPara o segundo termo, aplicamos a distributividade corretamente. Seja \\((A \\vee B) \\wedge (C \\vee D) \\equiv (A \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge C) \\vee (B \\wedge D)\\):\n\\[\n\\begin{align*}\n(E \\vee P) \\wedge (\\neg P \\vee \\neg E) &\\equiv (E \\wedge \\neg P) \\vee (E \\wedge \\neg E) \\vee (P \\wedge \\neg P) \\vee (P \\wedge \\neg E) \\\\\n&\\equiv (E \\wedge \\neg P) \\vee FALSE \\vee FALSE \\vee (P \\wedge \\neg E) && \\text{Lei da Contradição} \\\\\n&\\equiv (E \\wedge \\neg P) \\vee (P \\wedge \\neg E) && \\text{Lei da Identidade para a Disjunção}\n\\end{align*}\n\\]\nSubstituindo de volta na expressão principal:\n\\[\n\\begin{align*}\n&\\equiv (P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee (E \\wedge \\neg P) \\vee (P \\wedge \\neg E)\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee (E \\wedge \\neg P) \\vee (P \\wedge \\neg E)\\).\nPara cinco variáveis proposicionais, uma tabela-verdade completa teria \\(2^5 = 32\\) linhas. Em vez de apresentar toda a tabela, analisemos casos estratégicos para determinar as propriedades da fórmula:\nCasos em que a fórmula é \\(FALSE\\):\n\n\\(P = FALSE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\):\n\n\\((P \\wedge Q) = FALSE\\)\n\\((P \\wedge \\neg R) = FALSE\\)\n\\((P \\wedge S) = FALSE\\)\n\\((E \\wedge \\neg P) = FALSE \\wedge TRUE = FALSE\\)\n\\((P \\wedge \\neg E) = FALSE\\)\nResultado: todos os cinco termos da disjunção são falsos\n\n\nCasos em que a fórmula é \\(TRUE\\):\n\n\\(P = TRUE, Q = TRUE, R = TRUE, S = TRUE, E = FALSE\\): \\((P \\wedge Q) = TRUE\\)\n\\(P = TRUE, Q = FALSE, R = FALSE, S = FALSE, E = FALSE\\): \\((P \\wedge \\neg R) = TRUE\\)\n\\(P = FALSE, Q = FALSE, R = FALSE, S = FALSE, E = TRUE\\): \\((E \\wedge \\neg P) = TRUE\\)\n\nA análise destes casos representativos mostra que: - A fórmula não é uma tautologia, pois existem valorações que a tornam falsa - A fórmula é satisfatível, pois existem valorações que a tornam verdadeira\n- A fórmula é falsificável, pois existem valorações que a tornam falsa\nConclusão: A fórmula \\(P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P)\\) é satisfatível e falsificável, mas não é uma tautologia.\n\n\n4.1.2.2.3 Exemplos de Simplificação - Nível Avançado\nOs exemplos a seguir envolvem fórmulas com múltiplas variáveis proposicionais e conectivos complexos. Estes casos demonstram a aplicação sistemática das equivalências lógicas em situações mais desafiadoras, nas quais a análise de propriedades semânticas requer maior cuidado.\nExemplo 7: Determinar se a fórmula $ (P (Q R)) ((S E) (P Q)) $ é uma equivalência lógica.\nVamos simplificar ambos os lados separadamente:\nLado Esquerdo ($ (P (Q R)) $):\n\\[\n\\begin{align*}\n\\neg(P \\lor (Q \\land \\neg R)) &\\equiv \\neg P \\land \\neg(Q \\land \\neg R) && \\text{Lei de De Morgan (5)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor \\neg\\neg R) && \\text{Lei de De Morgan (6)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor R) && \\text{Lei da Dupla Negação (12)}\n\\end{align*}\n\\]\nLado Direito ($ (S E) (P Q) $):\n\\[\n\\begin{align*}\n(S \\lor E) \\rightarrow (P \\land Q) &\\equiv \\neg(S \\lor E) \\lor (P \\land Q) && \\text{Definição de Implicação (7)} \\\\\n&\\equiv (\\neg S \\land \\neg E) \\lor (P \\land Q) && \\text{Lei de De Morgan (6)}\n\\end{align*}\n\\]\nA fórmula completa é $ (P (Q R)) ((S E) (P Q)) $. Para verificar se é uma equivalência, testemos uma valoração específica, como $ P = \\(TRUE\\), Q = \\(FALSE\\), R = \\(TRUE\\), S = \\(FALSE\\), E = \\(FALSE\\) $:\n\nLado Esquerdo: $ P = \\(FALSE\\) $, $ Q = \\(TRUE\\) $, $ R = \\(TRUE\\) $, então $ Q R = \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $, e $ P (Q R) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\) $.\nLado Direito: $ S = \\(TRUE\\) $, $ E = \\(TRUE\\) $, então $ S E = \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $; $ P Q = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\) $, então $ (S E) (P Q) = \\(TRUE\\) \\(FALSE\\) = \\(TRUE\\) $.\nComo $ \\(FALSE\\) \\(TRUE\\) $, os lados não são iguais nesta valoração, indicando que a fórmula não é uma equivalência lógica.\n\nPara analisar as propriedades lógicas, consideremos a satisfatibilidade da expressão completa com uma tabela-verdade parcial:\n\n\n\n\n\n\n\n\n\n\n\n\n\n$ P $\n$ Q $\n$ R $\n$ S $\n$ E $\n$ P (Q R) $\n$ (S E) (P Q) $\n$ $\n\n\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\n\nNa primeira linha, a expressão é falsa ($ \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\) $), indicando que não é uma tautologia.\nNa segunda linha, a expressão é verdadeira ($ \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $), mostrando que é satisfatível.\n\nConclusão: A fórmula \\(\\neg(P \\vee (Q \\wedge \\neg R)) \\leftrightarrow ((S \\vee E) \\rightarrow (P \\wedge Q))\\) não é uma equivalência lógica, pois os lados diferem em algumas valorações (por exemplo, \\(P = TRUE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\)). Ela é satisfatível, pois há valorações em que é verdadeira (por exemplo, \\(P = FALSE, Q = TRUE, R = TRUE, S = TRUE, E = TRUE\\)), mas não é uma tautologia, pois também é falsificável, como mostrado pela tabela-verdade parcial.\nExemplo 8:\n\\(\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P))\\)\n\\[\n\\begin{align*}\n\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P)) &\\equiv \\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(8)}\\\\\n&\\equiv (\\neg(P \\rightarrow Q) \\vee \\neg(Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(5)}\\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 9: Simplificação e Análise da Fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\)\nVamos simplificar a fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\) passo a passo e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\n& (P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P)) \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg (\\neg R \\leftrightarrow S) \\vee (\\neg E \\wedge P)) && \\text{Lei 7: Definição de Implicação} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg ((\\neg R \\rightarrow S) \\wedge (S \\rightarrow \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 8: Definição de Equivalência} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg ((R \\vee S) \\wedge (\\neg S \\vee \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 7: Definição de Implicação, Lei 12: Dupla Negação} \\\\\n&\\equiv (P \\wedge Q) \\vee ((\\neg (R \\vee S) \\vee \\neg (\\neg S \\vee \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 5: Lei de De Morgan} \\\\\n&\\equiv (P \\wedge Q) \\vee ((\\neg R \\wedge \\neg S) \\vee (S \\wedge R) \\vee (\\neg E \\wedge P)) && \\text{Lei 6: Lei de De Morgan, Lei 12: Dupla Negação} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P) && \\text{Lei 19: Associatividade da Disjunção}\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\).\nPara analisar as propriedades lógicas, consideremos uma tabela-verdade parcial para as variáveis \\(P\\), \\(Q\\), \\(R\\), \\(S\\), \\(E\\). Uma tabela completa teria \\(2^5 = 32\\) linhas, mas casos representativos são suficientes para determinar se a fórmula é uma tautologia, satisfatível ou falsificável:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(S\\)\n\\(E\\)\n\\(P \\wedge Q\\)\n\\(\\neg R \\wedge \\neg S\\)\n\\(R \\wedge S\\)\n\\(\\neg E \\wedge P\\)\n\\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\)\n\n\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\n\n\nAnálise dos Casos:\n\nCasos em que a fórmula é TRUE: Nas primeiras cinco linhas, pelo menos um dos termos da disjunção é verdadeiro:\n\nLinha 1: \\((R \\wedge S) = TRUE\\)\nLinha 2: \\((R \\wedge S) = TRUE\\)\nLinha 3: \\((\\neg R \\wedge \\neg S) = TRUE\\)\nLinha 4: \\((\\neg R \\wedge \\neg S) = TRUE\\), \\((\\neg E \\wedge P) = TRUE\\)\nLinha 5: \\((R \\wedge S) = TRUE\\), \\((\\neg E \\wedge P) = TRUE\\)\n\nEsses casos mostram que a fórmula é satisfatível, pois há valorações em que ela é verdadeira.\nCasos em que a fórmula é FALSE: Na última linha ($P = \\(FALSE\\), Q = \\(TRUE\\), R = \\(FALSE\\), S = \\(TRUE\\), E = \\(TRUE\\)$):\n\n$(P Q) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\)$\n$(R S) = \\(FALSE\\) \\(TRUE\\) = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\)$\n$(R S) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\)$\n$(E P) = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\) \\(FALSE\\) = \\(FALSE\\)$\nResultado: \\[FALSE$ \\vee $FALSE$ \\vee $FALSE$ \\vee $FALSE$ = $FALSE\\]\n\nEsse caso mostra que a fórmula é falsificável, pois há uma valoração em que ela é falsa.\n\nConclusão: A fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\) simplifica para \\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\). Ela é satisfatível, pois há valorações em que é verdadeira, mas também é falsificável, pois existe pelo menos uma valoração ($P = \\(FALSE\\), Q = \\(TRUE\\), R = \\(FALSE\\), S = \\(TRUE\\), E = \\(TRUE\\)$) em que é falsa. Portanto, a fórmula não é uma tautologia. A tabela-verdade parcial apresentada é suficiente para confirmar essas propriedades, evitando a necessidade de uma tabela completa com 32 linhas.\nExemplo 10: Simplificação e Análise da Fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\)\nVamos simplificar a fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\) passo a passo e analisar suas propriedades lógicas.\nSimplifiquemos ambos os lados da equivalência separadamente:\nLado Esquerdo: \\(\\neg(P \\wedge (Q \\vee R))\\)\n\\[\n\\begin{align*}\n\\neg(P \\wedge (Q \\vee R)) &\\equiv \\neg P \\vee \\neg(Q \\vee R) && \\text{Lei 5: Lei de De Morgan} \\\\\n&\\equiv \\neg P \\vee (\\neg Q \\wedge \\neg R) && \\text{Lei 6: Lei de De Morgan}\n\\end{align*}\n\\]\nLado Direito: \\(\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q)\\)\n\\[\n\\begin{align*}\n\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q) &\\equiv \\neg(\\neg S \\vee E) \\vee \\neg(\\neg P \\vee Q) && \\text{Lei 7: Definição de Implicação} \\\\\n&\\equiv (S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) && \\text{Lei 6: Lei de De Morgan, Lei 12: Dupla Negação}\n\\end{align*}\n\\]\nA fórmula completa é: \\((\\neg P \\vee (\\neg Q \\wedge \\neg R)) \\leftrightarrow ((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q))\\)\nPara analisar as propriedades lógicas, consideremos uma tabela-verdade parcial para as variáveis \\(P\\), \\(Q\\), \\(R\\), \\(S\\), \\(E\\). Uma tabela completa teria \\(2^5 = 32\\) linhas, mas casos representativos são suficientes para determinar se a fórmula é uma tautologia, satisfatível ou falsificável:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(S\\)\n\\(E\\)\n\\(\\neg P \\vee (\\neg Q \\wedge \\neg R)\\)\n\\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q)\\)\n\\(\\leftrightarrow\\)\n\n\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\nFALSE\nFALSE\n\n\nTRUE\nTRUE\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\nTRUE\n\n\n\nAnálise dos Casos:\n\nLinha 1: (\\(P = TRUE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\))\n\nLado Esquerdo: \\(\\neg P = FALSE\\), \\(\\neg Q \\wedge \\neg R = \\neg FALSE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = FALSE \\vee FALSE = FALSE\\).\nLado Direito: \\(S \\wedge \\neg E = FALSE \\wedge \\neg FALSE = FALSE \\wedge TRUE = FALSE\\), \\(P \\wedge \\neg Q = TRUE \\wedge \\neg FALSE = TRUE \\wedge TRUE = TRUE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee TRUE = TRUE\\).\nResultado: \\(FALSE \\leftrightarrow TRUE = FALSE\\). A fórmula é falsa nesta valoração.\n\nLinha 2: (\\(P = FALSE, Q = TRUE, R = TRUE, S = TRUE, E = TRUE\\))\n\nLado Esquerdo: \\(\\neg P = TRUE\\), \\(\\neg Q \\wedge \\neg R = \\neg TRUE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = TRUE \\vee FALSE = TRUE\\).\nLado Direito: \\(S \\wedge \\neg E = TRUE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), \\(P \\wedge \\neg Q = FALSE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee FALSE = FALSE\\).\nResultado: \\(TRUE \\leftrightarrow FALSE = FALSE\\). A fórmula é falsa nesta valoração.\n\nLinha 3: (\\(P = TRUE, Q = TRUE, R = FALSE, S = FALSE, E = TRUE\\))\n\nLado Esquerdo: \\(\\neg P = FALSE\\), \\(\\neg Q \\wedge \\neg R = \\neg TRUE \\wedge \\neg FALSE = FALSE \\wedge TRUE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = FALSE \\vee FALSE = FALSE\\).\nLado Direito: \\(S \\wedge \\neg E = FALSE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), \\(P \\wedge \\neg Q = TRUE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee FALSE = FALSE\\).\nResultado: \\(FALSE \\leftrightarrow FALSE = TRUE\\). A fórmula é verdadeira nesta valoração.\n\n\nPropriedades Lógicas:\n\nNão é uma tautologia: As linhas 1 e 2 mostram que a fórmula pode ser falsa, pois o bicondicional \\(\\leftrightarrow\\) resulta em FALSE quando os lados têm valores diferentes.\nSatisfatível: A linha 3 mostra que há uma valoração em que a fórmula é verdadeira (\\(FALSE \\leftrightarrow FALSE = TRUE\\)).\nFalsificável: As linhas 1 e 2 confirmam que há valorações em que a fórmula é falsa.\nNão é uma equivalência lógica: Como os lados esquerdo e direito diferem em algumas valorações (por exemplo, linha 1), a fórmula não é uma equivalência lógica.\n\nConclusão: A fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\) simplifica para \\((\\neg P \\vee (\\neg Q \\wedge \\neg R)) \\leftrightarrow ((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q))\\). Ela é satisfatível, pois há valorações em que é verdadeira, mas também é falsificável, pois há valorações em que é falsa. Portanto, não é uma tautologia nem uma equivalência lógica. A tabela-verdade parcial apresentada é suficiente para confirmar essas propriedades. A Lógica Proposicional é essencial para entendermos o mundo. É a base de argumentos sólidos e da avaliação de proposições. Nasceu da necessidade humana de buscar a verdade e resolver conflitos com a lógica. Mas sua beleza vai além da filosofia, do discurso e da matemática. É a fundação da álgebra de George Boole, que sustenta o design de circuitos eletrônicos e a construção dos computadores modernos.\n\n\n\n\n4.1.3 Importância Histórica e Aplicações\nEm sua dissertação de final de curso, Claude Shannon usou a álgebra booleana para simplificar circuitos de controle. Desde então, as operações básicas dessa álgebra — AND, OR, NOT — tornaram-se os blocos fundamentais dos sistemas digitais. Elas formam o núcleo dos computadores, dos celulares e, na verdade, de toda a nossa civilização digital. A Lógica Proposicional é a base de todo o raciocínio lógico. Como a tabela periódica para químicos ou as leis de Newton para físicos. Ela é simples, elegante e poderosa.\nTão importante quanto o impacto da Lógica Proposicional na tecnologia digital é seu papel no pensamento racional, na tomada de decisões e na prova de teoremas. Neste caminho, nosso guia são as regras de inferência.\n\n\n4.1.4 Exercícios: Simplificação com Equivalências Lógicas\nInstrução: Use as leis de equivalência lógica (como as da Tabela 3) para simplificar as fórmulas a seguir até a forma mais simples possível. Justifique cada passo com o nome da lei ou propriedade utilizada.\n\nSimplifique: $ (P Q) $\nSimplifique: $ P (P Q) $\nSimplifique: $ (P Q) $\nSimplifique: $ (P Q) (P Q) $\nProve que a seguinte fórmula é uma tautologia: $ (P Q) (Q P) $\nSimplifique: $ (P Q) $\nSimplifique: $ (P Q) (P Q) $\nSimplifique: $ (P Q) (P Q) $\nSimplifique: $ (A B) (A B) $\nProve que a lei da Transitividade (ou Silogismo Hipotético) é uma tautologia: $ ((P Q) (Q R)) (P R) $",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#sistema-dedutivo-da-lógica-proposicional",
    "href": "02-fundamentos-logica-proposicional.html#sistema-dedutivo-da-lógica-proposicional",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.2 Sistema Dedutivo da Lógica Proposicional",
    "text": "4.2 Sistema Dedutivo da Lógica Proposicional\nO sistema dedutivo da Lógica Proposicional é um conjunto de regras e princípios que nos permite derivar conclusões a partir de premissas. Ele é fundamental para a construção de argumentos lógicos válidos e para a prova de teoremas. A seguir, apresentamos os principais componentes desse sistema:\n\n4.2.1 Regras de Inferência\nRegras de inferência são esquemas que proporcionam a estrutura para derivações lógicas. Estas regras formam a base dos sistemas de tomada de decisão computacional. Elas definem os passos legítimos que podem ser aplicados a uma ou mais proposições, sejam elas atômicas ou Fórmulas Bem Formadas, para produzir uma proposição nova. Em outras palavras, uma regra de inferência é uma transformação sintática de Formas Bem Formadas que preserva a verdade.\nAqui uma regra de inferência será representada por:\n\\[\\frac{P_1, P_2, ..., P_n}{C},\\]\nou, eventualmente por:\n\\[P_1, P_2, ..., P_n \\vdash C.\\]\nO conjunto formado \\(P_1, P_2, ..., P_n\\), chamado de contexto, ou antecedente, \\(\\Gamma\\), e \\(C\\), chamado de conclusão, ou consequente, são Fórmulas Bem Formadas. A regra significa que se as proposições que constituem a conjunção expressa no contexto são verdadeiras, então a conclusão \\(C\\), consequência, também será verdadeira. Em resumo, o contexto \\(\\Gamma\\) é o conjunto de premissas assumidas verdadeiras em uma dedução, e a conclusão \\(C\\) é derivada aplicando regras de inferência às premissas em \\(\\Gamma\\).\nEu vou tentar usar contexto e conclusão. Mas a compassiva leitora deve me perdoar se eu escapar para antecedente e consequente. É apenas o hábito.\nQuando estudamos lógica, chamamos de argumento uma lista de proposições, que aqui são as premissas. Elas vêm seguidas de uma palavra ou expressão (portanto, consequentemente, desta forma) e de outra proposição, que chamamos de conclusão. A forma que usamos para representar isso é chamada de sequência de dedução. É uma forma de mostrar que, se a proposição colocada acima da linha horizontal for verdadeira, então estamos afirmando que todas as proposições \\(P_1, P_2, ..., P_n\\) acima da linha são verdadeiras. E, por isso, a proposição abaixo da linha, a conclusão, também será verdadeira.\nAs regras de inferência são o alicerce da lógica dedutiva e das provas matemáticas. Elas permitem que raciocínios complexos sejam divididos em passos simples, com cada passo sendo justificado pela aplicação de uma regra de inferência. A seguir, estão algumas das regras de inferência mais usadas:\n\n4.2.1.1 Regras Básicas de Inferência\nAs regras básicas de inferência formam o núcleo fundamental do sistema dedutivo da lógica proposicional. Estas regras permitem derivar conclusões válidas a partir de premissas conhecidas e são amplamente utilizadas em demonstrações matemáticas e raciocínio lógico.\nA tabela Table 4.4 apresenta um resumo das regras de inferência mais comuns, suas descrições e as fórmulas associadas.\n\n\n\nTable 4.4: Resumo dos métodos de inferência.\n\n\n\n\n\n\n\n\n\n\nRegra\nDescrição\nFórmula\n\n\n\n\nModus Ponens\nSe \\(P \\rightarrow Q\\) e \\(P\\) são verdadeiros, então \\(Q\\) também é verdadeiro.\n\\(\\frac{P, P \\rightarrow Q}{Q}\\)\n\n\nModus Tollens\nSe \\(P \\rightarrow Q\\) e \\(\\neg Q\\) são verdadeiros, então \\(\\neg P\\) também é verdadeiro.\n\\(\\frac{\\neg Q, P \\rightarrow Q}{\\neg P}\\)\n\n\nDupla Negação\nA negação de uma negação é equivalente à afirmação original.\n\\(\\frac{\\neg \\neg P}{P}\\)\n\n\nAdição\nSe \\(P\\) é verdadeiro, então \\(P \\vee Q\\) também é verdadeiro.\n\\(\\frac{P}{P \\vee Q}\\)\n\n\nAdjunção\nSe \\(P\\) e \\(Q\\) são verdadeiros, então \\(P \\wedge Q\\) é verdadeiro.\n\\(\\frac{P, Q}{P \\wedge Q}\\)\n\n\nSimplificação\nSe \\(P \\wedge Q\\) é verdadeiro, então \\(P\\) (ou \\(Q\\)) é verdadeiro.\n\\(\\frac{P \\wedge Q}{P}\\)\n\n\nBicondicionalidade\nSe \\(P \\leftrightarrow Q\\), então \\(P \\rightarrow Q\\) e \\(Q \\rightarrow P\\) são verdadeiros.\n\\(\\frac{P \\leftrightarrow Q}{P \\rightarrow Q, Q \\rightarrow P}\\)\n\n\n\n\n\n\n\n4.2.1.1.1 Modus Ponens\nA regra do Modus Ponens permite inferir uma conclusão a partir de uma implicação e de sua premissa antecedente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(P\\) é verdadeiro, então podemos concluir que \\(Q\\) também é verdadeiro.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: se chover, \\((P)\\), então, \\((\\rightarrow)\\), a rua ficará molhada, \\((Q)\\);\nProposição 2: está chovendo, \\((P)\\) é verdadeira.\nConclusão: logo, a rua ficará molhada, \\((Q)\\).\n\nAlgumas aplicações do Modus Ponens:\n\nDerivar ações de regras e leis condicionais. Por exemplo:\n\nProposição: se a velocidade, \\(V\\), é maior que \\(80 \\text{km/h}\\), então é uma infração de trânsito, \\(IT\\).\nProposição: João está dirigindo, \\(d\\), à \\(90 \\text{km/h}\\).\nConclusão: logo, João cometeu uma infração de trânsito.\n\n\n\\[V &gt; 80 \\rightarrow IT\\]\n\\[\n\\begin{aligned}\n&D = 90\\\\\n\\hline\n&IT\n\\end{aligned}\n\\]\n\nAplicar implicações teóricas e chegar a novas conclusões. Por exemplo:\n\nProposição: se um número é par, \\(P\\), então é divisível por 2, $ d2$.\nProposição: 128 é par.\nConclusão: logo, 128 é divisível por 2.\n\n\n\\[x \\text{ é par} \\rightarrow \\text{divisível por dois}\\]\n\\[\n\\begin{aligned}\n&128 \\text{ é par}\\\\\n\\hline\n&128 \\text{ é divisível por 2}\n\\end{aligned}\n\\]\n\nFazer deduções lógicas em matemática e ciência. Por exemplo:\n\nProposição: se dois lados de um triângulo têm o mesmo comprimento, então o triângulo é isósceles.\nProposição: o triângulo \\(ABC\\) tem os lados \\(AB\\), \\(AC\\) e \\(BC\\) do mesmo comprimento.\nConclusão: logo, o triângulo \\(ABC\\) é isósceles.\n\n\n\\[\n\\begin{aligned}\n&(AB = AC) \\wedge (AB=CB) \\text{ no triângulo} ABC\\\\\n\\hline\n&\\text{o triângulo } ABC \\text{ é isósceles}\n\\end{aligned}\n\\]\n\nTirar conclusões com base no raciocínio condicional na vida cotidiana. Por exemplo:\n\nProposição: se hoje não chover, então irei à praia.\nProposição: Hoje não choveu.\nConclusão: logo, irei à praia.\n\n\n\\[\\neg (\\text{chover hoje}) \\rightarrow \\text{ir à praia}\\]\n\\[\n\\begin{aligned}\n&\\neg (\\text{choveu hoje})\\\\\n\\hline\n&(\\text{ir à praia})\n\\end{aligned}\n\\]\n\n\n4.2.1.1.2 Modus Tollens\nA regra do Modus Tollens permite inferir a negação da premissa antecedente a partir de uma implicação e da negação de sua premissa consequente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(Q\\) é falso (ou seja, \\(\\neg Q\\)), então podemos concluir que \\(P\\) também é falso.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&\\neg P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição 1: se uma pessoa tem 18 anos ou mais, \\((P)\\), então, \\((\\rightarrow)\\) ela pode votar, \\((Q)\\);\nProposição 2: Maria não pode votar, \\((\\neg Q)\\);\nConclusão: logo, Maria não tem 18 anos ou mais, \\((\\neg P)\\).\n\nAlgumas aplicações do Modus Tollens:\n\nRefutar teorias mostrando que suas previsões são falsas. Por exemplo:\n\nProposição: se a teoria da geração espontânea, \\(TG\\), é correta, então insetos irão se formar em carne deixada exposta ao ar, \\(I\\).\nProposição: insetos não se formam em carne deixada exposta ao ar, \\(\\neg I\\).\nConclusão: logo, a teoria da geração espontânea é falsa, \\(\\neg TG\\).\n\n\n\\[TG \\rightarrow I\\]\n\\[\n\\begin{aligned}\n&\\neg I\\\\\n\\hline\n&\\neg TG\n\\end{aligned}\n\\]\n\nIdentificar inconsistências ou contradições em raciocínios. Por exemplo:\n\nProposição: se João, \\(J\\), é mais alto que Maria, \\(M\\), então Maria não é mais alta que João.\nProposição: Maria é mais alta que João, \\((M &gt; J)\\).\nConclusão: logo, João não é mais alto que Maria, \\(\\neg(J &gt; M)\\). O raciocínio mostra que não podemos ter simultaneamente \\(J &gt; M\\) e \\(M &gt; J\\), pois a relação “maior que” é assimétrica.\n\n\n\\[(J &gt; M) \\rightarrow \\neg(M &gt; J)\\]\n\\[\n\\begin{aligned}\n&(M &gt; J)\\\\\n\\hline\n&\\neg(J &gt; M)\n\\end{aligned}\n\\]\n\nFazer deduções lógicas baseadas na negação da conclusão. Por exemplo:\n\nProposição: se hoje, \\(H\\), é sexta-feira, então amanhã é sábado, \\(A_{sab}\\).\nProposição: amanhã não é sábado, \\(\\neg A_{sab}\\).\nConclusão: logo, hoje não é sexta-feira, \\(\\neg H_{sex}\\).\n\n\n\\[H_{sex} \\rightarrow A_{sab}\\]\n\\[\n\\begin{aligned}\n&\\neg A_{sab}\\\\\n\\hline\n&\\neg H_{sex}\n\\end{aligned}\n\\]\n\nDescobrir causas de eventos por eliminação de possibilidades. Por exemplo:\n\nProposição: se a tomada está com defeito, \\(D\\), então a lâmpada não acende, \\(\\neg L\\).\nProposição: a lâmpada acendeu, \\(L\\).\nConclusão: logo, a tomada não está com defeito, \\(\\neg D\\).\n\n\n\\[D \\rightarrow \\neg L\\]\n\\[\n\\begin{aligned}\n&L\\\\\n\\hline\n&\\neg D\n\\end{aligned}\n\\]\nExplicação: Como a lâmpada acendeu (\\(L\\)), isso contradiz a consequência da implicação (\\(\\neg L\\)). Pelo Modus Tollens, se o consequente é falso, então o antecedente também deve ser falso. Portanto, a tomada não está com defeito (\\(\\neg D\\)).\n\n\n\n4.2.1.2 **Regras de Manipulação Lógica\nEstas regras permitem transformar e simplificar expressões lógicas, facilitando a análise e manipulação de fórmulas complexas. São fundamentais para a normalização de expressões e para preparar fórmulas para aplicação de outras regras de inferência.\n\n4.2.1.2.1 Dupla Negação\nA regra da Dupla Negação permite eliminar uma dupla negação, inferindo a afirmação original. A negação de uma negação é equivalente à afirmação original. Esta regra é importante para simplificar expressões lógicas.\n\\[\\neg \\neg P\\]\n\\[\n\\begin{aligned}\n&\\neg \\neg P\\\\\n\\hline\n&P\\\\\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n&P\\\\\n\\hline\n&\\neg \\neg P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: não é verdade que Maria não está feliz;\nConclusão: logo, Maria está feliz.\n\nA dupla negação pode parecer desnecessária, mas ela tem algumas aplicações na lógica:\n\nSimplifica expressões lógicas: remover duplas negações ajuda a simplificar e a normalizar expressões complexas, tornando-as mais fáceis de analisar. Por exemplo, transformar não é verdade que não está chovendo em simplesmente está chovendo.\n\n\\[\\neg \\neg \\text{Está chovendo} \\equiv \\text{Está chovendo}\\]\n\nPreserva o valor de verdade: inserir ou remover duplas negações não altera o valor de verdade original de uma proposição. Isso permite transformar proposições em formas logicamente equivalentes.\nAuxilia provas indiretas: em provas por contradição, ou contrapositiva, introduzir uma dupla negação permite assumir o oposto do que se quer provar e derivar uma contradição. Isso, indiretamente, prova a proposição original.\nConecta Lógica Proposicional e de predicados: em Lógica Predicativa, a negação de quantificadores universais e existenciais envolve dupla negação. Por exemplo, a negação de todo \\(x\\) é \\(P\\) é existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\n\n\\[\\neg \\forall x P(x) \\equiv \\exists x \\neg P(x)\\]\n\nPermite provar equivalências: uma identidade ou lei importante na lógica é que a dupla negação de uma proposição é logicamente equivalente à proposição original. A regra da dupla negação permite formalmente provar essa equivalência.\n\n\\[\\neg \\neg P \\equiv P\\]\n\n\n4.2.1.2.2 Adição\nA regra da Adição permite adicionar uma disjunção a uma afirmação, resultando em uma nova disjunção verdadeira. Esta regra é útil para introduzir alternativas em nosso raciocínio dedutivo.\n\\[P\\]\n\\[\\begin{aligned}\n&P\\\\\n\\hline\n&P \\vee Q\\\\\n\\end{aligned}\n\\]\n\\[\\begin{aligned}\n&Q\\\\\n\\hline\n&P \\vee Q\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: o céu está azul;\nConclusão: logo, o céu está azul ou gatos podem voar.\n\nA regra da Adição permite introduzir uma disjunção em uma prova ou argumento lógico. Especificamente, ela nos permite inferir uma disjunção \\(P\\vee Q\\) a partir de uma das afirmações disjuntivas (\\(P\\) ou \\(Q\\)) individualmente.\nAlguns usos e aplicações importantes da regra da Adição:\n\nIntroduzir alternativas ou possibilidades em um argumento: por exemplo, dado que João está em casa, podemos concluir que João está em casa ou no trabalho. E expandir este ou o quanto seja necessário para explicitar os lugares em que João pode estar.\nCombinar afirmações em novas disjunções: dadas duas afirmações quaisquer \\(P\\) e \\(Q\\), podemos inferir que \\(P\\) ou \\(Q\\) é verdadeiro.\nCriar casos ou opções exaustivas em uma prova: podemos derivar uma disjunção que cubra todas as possibilidades relevantes.\nIniciar provas por casos: ao assumir cada disjuntiva separadamente, podemos provar teoremas por casos exaustivos.\nRealizar provas indiretas: ao assumir a negação de uma disjunção, podemos chegar a uma contradição e provar a disjunção original.\n\nA regra da Adição amplia nossas capacidades de prova e abordagem de problemas.\n\n\n4.2.1.2.3 Modus Tollendo Ponens\nO Modus Tollendo Ponens permite inferir uma disjunção a partir da negação da outra disjunção.\nDada uma disjunção \\(P\\vee Q\\):\n\nSe \\(\\neg P\\), então \\(Q\\)\nSe \\(\\neg Q\\), então \\(P\\)\n\nEsta regra nos ajuda a chegar a conclusões a partir de disjunções, por exclusão de alternativas.\n\\[P \\vee Q\\]\n\\[\\begin{aligned}\n&\\neg P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\n\\]\n\\[\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição 1: ou o céu está azul ou a grama é roxa;\nProposição 2: a grama não é roxa;\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações do Modus Tollendo Ponens:\n\nDerivar ações a partir de regras disjuntivas. Por exemplo:\n\nProposição: ou João vai à praia, \\(P\\) ou João vai ao cinema, \\(c\\);\nProposição: João não vai ao cinema, \\(\\neg C\\);\nConclusão: logo, João vai à praia.\n\n\n\\[P \\vee C\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&P\n\\end{aligned}\n\\]\n\nSimplificar casos em provas por exaustão. Por exemplo:\n\nProposição: o número é par, \\(P\\), ou ímpar, \\(I\\);\nProposição: o número não é ímpar, \\(\\neg I\\);\nConclusão: logo, o número é par, \\(P\\).\n\n\n\\[P \\vee I\\]\n\\[\\begin{aligned}\n&\\neg I\\\\\n\\hline\n&P\n\\end{aligned}\n\\]\n\nEliminar opções em raciocínio dedutivo. Por exemplo:\n\nProposição: ou João estava em casa, \\(c\\), ou João estava no trabalho, \\(t\\);\nProposição: João não estava em casa;\nConclusão: logo, João estava no trabalho.\n\n\n\\[C \\vee TRUE\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&TRUE\n\\end{aligned}\n\\]\n\nFazer prova indireta da disjunção. Por exemplo:\n\nProposição: 1 é par, \\(1P\\), ou 1 é ímpar, \\(1I\\);\nProposição: 1 não é par;\nConclusão: logo, 1 é ímpar.\n\n\n\\[1P \\vee 1I\\]\n\\[\\begin{aligned}\n&\\neg 1P\\\\\n\\hline\n&1I\n\\end{aligned}\n\\]\n\n\n4.2.1.2.4 Adjunção\nA regra da Adjunção permite combinar duas afirmações em uma conjunção. Esta regra é útil para juntar duas premissas em uma única afirmação conjuntiva.\n\\[P\\]\n\\[Q\\]\n\\[\\begin{aligned}\n&P\\\\\n&Q\\\\\n\\hline\n&P \\land Q\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: o céu está azul;\nProposição 2: os pássaros estão cantando;\nConclusão: logo, o céu está azul e os pássaros estão cantando.\n\nAlgumas aplicações da Adjunção:\n\nCombinar proposições relacionadas em argumentos. Por exemplo:\n\nProposição: o céu está nublado, \\(N\\);\nProposição: está ventando, \\(V\\);\nConclusão: logo, o céu está nublado e está ventando.\n\n\n\\[\\begin{aligned}\n&N\\\\\n&V\\\\\n\\hline\n&N \\land V\n\\end{aligned}\\]\n\nCriar declarações conjuntivas complexas. Por exemplo:\n\nProposição: 1 é número natural, \\(N1\\);\nProposição: 2 é número natural, \\(N2\\);\nConclusão: logo, 1 é número natural e 2 é número natural.\n\n\n\\[\\begin{aligned}\n&N1\\\\\n&N2\\\\\n\\hline\n&N1 \\land N2\n\\end{aligned}\\]\n\nDerivar novas informações da interseção de fatos conhecidos. Por exemplo:\n\nProposição: o gato está em cima do tapete, \\(GT\\);\nProposição: o rato está em cima do tapete, \\(RT\\);\nConclusão: logo, o gato e o rato estão em cima do tapete.\n\n\n\\[\\begin{aligned}\n&GT\\\\\n&RT\\\\\n\\hline\n&GT \\land RT\n\\end{aligned}\\]\n\nFazer deduções lógicas baseadas em múltiplas proposições. Por exemplo:\n\nProposição: 2 + 2 = 4;\nProposição: 4 = 16;\nConclusão: logo, \\((2 + 2 = 4) \\land (4 \\times 4 = 16)\\).\n\n\n\\[\\begin{aligned}\n&(2 + 2 = 4)\\\\\n&(4 \\times 4 = 16)\\\\\n\\hline\n&(2 + 2 = 4) \\land (4 \\times 4 = 16)\n\\end{aligned}\\]\n\n\n4.2.1.2.5 Simplificação\nA regra da Simplificação permite inferir um componente individual a partir de uma conjunção composta. Esta regra nos permite derivar qualquer um dos elementos de uma conjunção, a partir da afirmação conjuntiva.\n\\[P \\land Q\\]\n\\[\\begin{aligned}\n&P \\land Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\\]\n\\[\\begin{aligned}\n&P \\land Q\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição: o céu está azul e os pássaros estão cantando;\nConclusão: logo, o céu está azul. Ou alternativamente, os pássaros estão cantando.\n\nAlgumas aplicações da Simplificação:\n\nDerivar elementos de conjunções complexas. Por exemplo:\n\nProposição: hoje está chovendo, \\(C\\), e fazendo frio, \\(F\\);\nConclusão: logo, está chovendo.\n\n\n\\[\\begin{aligned}\n&C \\land F\\\\\n\\hline\n&C\n\\end{aligned}\\]\n\nSimplificar provas baseadas em conjunções. Por exemplo:\n\nProposição: 2 é par, \\(2P\\), e 3 é ímpar, \\(3I\\);\nConclusão: logo, 3 é ímpar.\n\n\n\\[\\begin{aligned}\n&2P \\land 3I\\\\\n\\hline\n&3I\n\\end{aligned}\\]\n\nInferir detalhes específicos de declarações complexas. Por exemplo:\n\nProposição: o gato está dormindo, \\(D\\), e ronronando, \\(R\\);\nConclusão: logo, o gato está ronronando.\n\n\n\\[\\begin{aligned}\n&D \\land R\\\\\n\\hline\n&R\n\\end{aligned}\\]\n\nDerivar informações de premissas conjuntivas. Por exemplo:\n\nProposição: está chovendo, \\(C\\), e o jogo foi cancelado, \\(J\\);\nConclusão: logo, o jogo foi cancelado.\n\n\n\\[\\begin{aligned}\n&C \\land J\\\\\n\\hline\n&J\n\\end{aligned}\\]\n\n\n\n4.2.1.3 Regras de Equivalência e Bicondicionalidade\nAs regras de equivalência e bicondicionalidade são fundamentais para a lógica proposicional, pois permitem estabelecer relações de equivalência entre proposições e inferir conclusões a partir dessas relações. Elas são essenciais para simplificar expressões lógicas, provar teoremas e estabelecer definições matemáticas precisas. Estas regras trabalham com o conceito de equivalência lógica, no qual duas proposições têm o mesmo valor de verdade em todas as interpretações possíveis.\n\n4.2.1.3.1 Bicondicionalidade\nA regra da Bicondicionalidade permite inferir uma bicondicional a partir de duas condicionais. Esta regra nos permite combinar duas implicações para obter uma afirmação de equivalência lógica.\n\\[P \\rightarrow Q\\]\n\\[Q \\rightarrow P\\]\n\\[\\begin{aligned}\n&P \\rightarrow Q \\\\\n&Q \\rightarrow P \\\\\n\\hline\n&P \\leftrightarrow Q\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: se está chovendo, então a rua está molhada;\nProposição 2: se a rua está molhada, então está chovendo;\nConclusão: logo, está chovendo se e somente se a rua está molhada.\n\nAlgumas aplicações da Bicondicionalidade:\n\nInferir equivalências lógicas a partir de implicações bidirecionais. Por exemplo:\n\nProposição: se chove, \\(C\\), então a rua fica molhada, \\(M\\);\nProposição: se a rua fica molhada, então chove;\nConclusão: logo, chove se e somente se a rua fica molhada.\n\n\n\\[C \\rightarrow M\\]\n\\[\\begin{aligned}\n&M \\rightarrow C\\\\\n\\hline\n&C \\leftrightarrow M\n\\end{aligned}\\]\n\nEstabelecer definições matemáticas precisas. Por exemplo:\n\nProposição: se um número é múltiplo de 2, \\(M2\\), então é par, \\(P\\);\nProposição: se um número é par, então é múltiplo de 2;\nConclusão: logo, um número é par se e somente se é múltiplo de 2.\n\n\n\\[M2 \\rightarrow P\\]\n\\[\\begin{aligned}\n&P \\rightarrow M2\\\\\n\\hline\n&P \\leftrightarrow M2\n\\end{aligned}\\]\n\nEstabelecer equivalências algébricas. Por exemplo:\n\nProposição: se \\(x = 5\\), então \\(x^2 = 25\\);\nProposição: se \\(x^2 = 25\\) e \\(x &gt; 0\\), então \\(x = 5\\);\nConclusão: logo, para números positivos, \\(x = 5\\) se e somente se \\(x^2 = 25\\).\n\n\n\\[(x = 5) \\rightarrow (x^2 = 25)\\]\n\\[\\begin{aligned}\n&(x^2 = 25 \\land x &gt; 0) \\rightarrow (x = 5)\\\\\n\\hline\n&(x = 5) \\leftrightarrow (x^2 = 25 \\land x &gt; 0)\n\\end{aligned}\\]\n\nDefinir conceitos através de propriedades equivalentes. Por exemplo:\n\nProposição: se um triângulo é equilátero, \\(E\\), então todos os seus ângulos são iguais, \\(A\\);\nProposição: se um triângulo tem todos os ângulos iguais, então é equilátero;\nConclusão: logo, um triângulo é equilátero se e somente se todos os seus ângulos são iguais.\n\n\n\\[E \\rightarrow A\\]\n\\[\\begin{aligned}\n&A \\rightarrow E\\\\\n\\hline\n&E \\leftrightarrow A\n\\end{aligned}\\]\n\n\n4.2.1.3.2 Equivalência\nA regra da Equivalência permite inferir uma afirmação ou sua negação a partir de uma bicondicional. Esta regra nos permite aplicar bicondicionais para derivar novas afirmações baseadas nas equivalências lógicas.\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&\\neg P\\\\\n\\hline\n&\\neg Q\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&\\neg P\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: está chovendo se e somente se a rua está molhada;\nProposição 2: está chovendo;\nConclusão: logo, a rua está molhada.\n\nAlgumas aplicações da Equivalência:\n\nInferir fatos de equivalências estabelecidas. Por exemplo:\n\nProposição: o número é par, \\(P\\), se e somente se for divisível por 2, \\(D2\\);\nProposição: 156 é divisível por 2;\nConclusão: logo, 156 é par.\n\n\\[P \\leftrightarrow D2\\]\n\\[\\begin{aligned}\n&D2(156)\\\\\n\\hline\n&P(156)\n\\end{aligned}\\]\nDerivar negações de equivalências. Por exemplo:\n\nProposição: \\(x\\) é negativo, \\(N\\), se e somente se \\(x &lt; 0\\);\nProposição: \\(x\\) não é negativo;\nConclusão: logo, \\(x\\) não é menor que \\(0\\).\n\n\\[N \\leftrightarrow (x &lt; 0)\\]\n\\[\\begin{aligned}\n&\\neg N\\\\\n\\hline\n&\\neg (x &lt; 0)\n\\end{aligned}\\]\nFazer deduções baseadas em definições. Por exemplo:\n\nProposição: número ímpar, \\(I\\), é definido como não divisível por \\(2\\), \\(\\neg D2\\);\nProposição: \\(9\\) não é divisível por \\(2\\);\nConclusão: logo, \\(9\\) é ímpar.\n\n\\[I \\leftrightarrow \\neg D2\\]\n\\[\\begin{aligned}\n&\\neg D2(9)\\\\\n\\hline\n&I(9)\n\\end{aligned}\\]\n\n\n\n\n\n4.2.2 Exercícios: Provas com Regras de Inferência\nInstrução: Para cada um dos seguintes conjuntos de premissas, derive a conclusão indicada. Apresente a prova como uma sequência de passos numerados, onde cada passo é justificado pela regra de inferência aplicada e pelos números dos passos anteriores ou premissas utilizadas.\n\nPremissas:\n\n\\(P \\rightarrow Q\\)\n\\(P\\) Conclusão: \\(Q\\)\n\nPremissas:\n\n\\(A \\rightarrow B\\)\n\\(\\neg B\\) Conclusão: \\(\\neg A\\)\n\nPremissas:\n\n\\(P \\land Q\\)\n\\(P \\rightarrow R\\) Conclusão: \\(R\\)\n\nPremissas:\n\n\\(S \\rightarrow \\neg T\\)\n\\(T\\)\n\\(S \\lor U\\) Conclusão: \\(U\\)\n\nPremissas:\n\n\\(A\\)\n\\(B\\)\n\\((A \\land B) \\rightarrow C\\) Conclusão: \\(C\\)\n\nPremissas:\n\n\\(P \\rightarrow Q\\)\n\\(Q \\rightarrow R\\) Conclusão: \\(P \\rightarrow R\\) (Esta regra é conhecida como Silogismo Hipotético)\n\nPremissas:\n\n\\(A \\rightarrow B\\)\n\\(C \\rightarrow D\\)\n\\(A \\lor C\\) Conclusão: \\(B \\lor D\\) (Esta regra é conhecida como Dilema Construtivo)\n\nPremissas:\n\n\\(\\neg A \\lor B\\)\n\\(C \\rightarrow A\\)\n\\(C\\) Conclusão: \\(B\\)\n\nArgumento: “Se o servidor está online (\\(S\\)), então os dados foram processados (\\(D\\)). Se os dados foram processados, o relatório foi gerado (\\(R\\)). O servidor está online. Portanto, o relatório foi gerado.” Instrução: Formalize as premissas e a conclusão, e então derive a conclusão.\nPremissas:\n\n\\((P \\land Q) \\rightarrow R\\)\n\\(\\neg R \\lor S\\)\n\\(P\\)\n\\(Q \\land T\\) Conclusão: \\(S\\)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#análise-semântica-de-fórmulas",
    "href": "02-fundamentos-logica-proposicional.html#análise-semântica-de-fórmulas",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.3 Análise Semântica de Fórmulas",
    "text": "4.3 Análise Semântica de Fórmulas\nA análise semântica de fórmulas proposicionais estuda o significado e as propriedades de verdade das expressões lógicas. Enquanto a sintaxe se preocupa com a estrutura formal das fórmulas, a semântica examina quando e por que essas fórmulas são verdadeiras ou falsas. Esta análise permite uma compreensão mais profunda da lógica, ajudando a identificar inconsistências e a validar argumentos.\n\n4.3.1 Classificação das Fórmulas Proposicionais\nPodemos classificar fórmulas proposicionais de acordo com suas propriedades semânticas, analisando suas tabelas-verdade. Seja \\(R\\) uma fórmula proposicional:\n\n\\(R\\) é satisfatível se sua Tabela Verdade contém pelo menos uma linha verdadeira. Considere:\\(P\\wedge Q\\).\n\n\\[\\begin{array}{|c|c|c|}\n\\hline\nP & Q & P \\land Q \\\\\n\\hline\n$FALSE$ & $FALSE$ & $FALSE$ \\\\\n\\hline\n$FALSE$ & $TRUE$ & $FALSE$ \\\\\n\\hline\n$TRUE$ & $FALSE$ & $FALSE$ \\\\\n\\hline\n$TRUE$ & $TRUE$ & $TRUE$ \\\\\n\\hline\n\\end{array}\\]\n\n\\(R\\) é insatisfatível se sua Tabela Verdade contém apenas linhas falsas. Exemplo:\\(P\\wedge \\neg P\\).\n\\(R\\) é falsificável se sua Tabela Verdade contém pelo menos uma linha falsa. Exemplo:\\(P\\wedge Q\\).\n\\(R\\) é válida se sua Tabela Verdade contém apenas linhas verdadeiras. Exemplo:\\(P\\vee \\neg P\\).\n\nNote que:\n\nSe \\(A\\) é válida, então \\(A\\) é satisfatível.\nSe \\(A\\) é insatisfatível, então \\(A\\) é falsificável.\n\nUma fórmula válida (tautologia) é satisfatível porque tem pelo menos uma linha verdadeira (na verdade, todas são verdadeiras). Uma fórmula insatisfatível (contradição) é falsificável porque tem pelo menos uma linha falsa (na verdade, todas são falsas)\nFórmulas válidas são importantes na Lógica Proposicional, representando argumentos sempre verdadeiros independentemente da valoração de suas variáveis proposicionais atômicas. Na verdade, esta classificação será importante para:\n\nAnálise de Argumentos: Se uma argumentação lógica pode ser representada por uma fórmula que é insatisfatível, então sabemos que o argumento é inválido ou inconsistente. Isso é frequentemente usado em lógica e filosofia para analisar a validade dos argumentos.\nProva de Teoremas: Na prova de teoremas, essas classificações são úteis. Quando estamos tentando provar que uma fórmula é uma tautologia, podemos usar essas classificações para simplificar a tarefa. Podemos mostrar que a negação da fórmula é insatisfatível, mostrando que a fórmula original é uma tautologia.\nSimplificação de Fórmulas: Na simplificação de fórmulas, essas classificações também são úteis. Se temos uma fórmula complexa e podemos mostrar que uma parte dela é uma tautologia, podemos simplificar a fórmula removendo essa parte. Similarmente, se uma parte da fórmula é uma contradição (ou seja, é insatisfatível), sabemos que a fórmula inteira é insatisfatível.\nConstrução de Argumentos: Na construção de argumentos, estas classificações são úteis para garantir que os argumentos são válidos. Se estamos construindo um argumento e podemos mostrar que ele é representado por uma fórmula que é satisfatível (mas não uma tautologia), sabemos que existem algumas circunstâncias em que o argumento é válido e outras em que não é.\n\n\n\n4.3.2 Exercícios: Análise Semântica de Fórmulas\nInstrução: Para cada uma das fórmulas abaixo, determine se ela é uma Tautologia, uma Contradição ou uma Contingência (satisfatível, mas também falsificável). Use o método que preferir (tabela-verdade ou simplificação por equivalências lógicas) para justificar sua resposta.\n\nClassifique a fórmula: \\(P \\rightarrow (P \\land Q)\\)\nClassifique a fórmula: \\((P \\lor Q) \\lor (\\neg P \\land \\neg Q)\\)\nClassifique a fórmula: \\((P \\leftrightarrow Q) \\land (P \\land \\neg Q)\\)\nEncontre uma valoração (uma atribuição de Verdadeiro ou Falso para A, B e C) que torne a seguinte fórmula verdadeira: \\((\\neg A \\lor B) \\rightarrow (C \\rightarrow A)\\)\nEncontre uma valoração que torne a fórmula do exercício 4 falsa.\nClassifique a fórmula (Axioma de Frege): \\((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\\)\nClassifique a fórmula: \\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\land Q))\\)\nClassifique a fórmula: \\(\\neg(((P \\lor Q) \\rightarrow P) \\lor Q)\\)\nAnalise o argumento: “Uma pessoa pode dirigir (\\(D\\)) se, e somente se, ela tem uma carteira de motorista (\\(C\\)) e não está embriagada (\\(\\neg E\\)). É logicamente consistente (satisfatível) afirmar que uma pessoa está dirigindo sem ter carteira de motorista?”. Justifique sua resposta.\nClassifique a fórmula: \\((A \\leftrightarrow B) \\lor (B \\leftrightarrow C)\\)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#exercícios-de-conexão-com-o-prolog",
    "href": "02-fundamentos-logica-proposicional.html#exercícios-de-conexão-com-o-prolog",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.4 Exercícios de Conexão com o Prolog",
    "text": "4.4 Exercícios de Conexão com o Prolog\nEstas questões demonstram conceitos fundamentais que se traduzem diretamente para Prolog:\n\nFatos: Proposições básicas verdadeiras (como “U” na questão 4)\nRegras: Implicações lógicas (como “C → U” traduzido para pode_compilar(core) :- pode_compilar(utils).)\nConsultas: Questões que queremos responder usando a base de conhecimento\nConsistência: Importância de evitar contradições na base de conhecimento\nDedução: Como o motor de inferência do Prolog resolve consultas usando fatos e regras\n\nEste conjunto de questões foi elaborado para solidificar os fundamentos da Lógica Proposicional, servindo como base para a modelagem de sistemas e a programação em lógica. Cada problema apresenta um “mundo” a ser modelado com proposições e operadores lógicos, preparando para a construção de bases de conhecimento com fatos, regras e consultas.\n\n4.4.1 Questão 1: Diagnóstico de Sistema\nUm sistema de monitoramento de um servidor reporta os seguintes fatos:\n\nSe o servidor está sobrecarregado (S), então a latência da rede aumenta (L).\n\nSe a latência da rede aumenta (L), o sistema de alerta envia uma notificação (N).\n\nO sistema de alerta não enviou uma notificação.\n\nModele essas afirmações usando lógica proposicional e prove que o servidor não está sobrecarregado.\n\n\n4.4.2 Questão 2: Validação de Circuito Lógico (Half-Adder)\nUm circuito somador de meio bit (Half-Adder) recebe duas entradas, A e B, e produz duas saídas: a Soma (S) e o “Vai-um” (C, de Carry). A lógica é:\n\nA saída S é verdadeira se, e somente se, exatamente uma das entradas (A ou B) for verdadeira.\n\nA saída C é verdadeira se, e somente se, ambas as entradas (A e B) forem verdadeiras.\n\nTraduza as condições para as saídas S e C em fórmulas proposicionais. Em seguida, usando uma tabela verdade, demonstre que a fórmula \\((A \\lor B) \\land \\neg(A \\land B)\\) é logicamente equivalente à fórmula para a saída S.\n\n\n4.4.3 Questão 3: Análise de Contrato de Serviço (Corrigida)\nAs cláusulas de um contrato de nível de serviço (SLA) para uma plataforma de nuvem estipulam:\n\nSe o uptime do serviço for menor que 99% (U), o cliente receberá um crédito na fatura (C).\n\nPara receber o crédito (C), o cliente deve abrir um ticket de suporte (T).\n\nO cliente pode optar por um desconto de 10% no próximo mês (D) em vez de receber o crédito (C), mas não pode ter ambos.\n\nNeste mês, o uptime foi de 98% e o cliente não abriu um ticket de suporte.\n\nAnalise a consistência lógica das regras do contrato. O que acontece quando o uptime é baixo mas o cliente não abre um ticket?\n\n\n4.4.4 Questão 4: Dependências de Compilação (Corrigida)\nPara compilar um software, as seguintes dependências devem ser satisfeitas:\n\nA biblioteca utils (U) deve estar compilada para que o módulo core (C) possa ser compilado.\n\nO módulo core (C) deve estar compilado para que o módulo api (A) possa ser compilado.\n\nPara compilar a interface gráfica gui (G), tanto o módulo api (A) quanto a biblioteca assets (L) devem estar compilados.\n\nA biblioteca utils (U) já foi compilada.\n\nModele as dependências como regras lógicas. Construa uma fórmula que represente todas as condições necessárias para compilar a gui. É possível compilar a gui com as informações disponíveis?\n\n\n4.4.5 Questão 5: Regras de um Jogo\nEm um jogo de tabuleiro, um jogador vence (V) se chegar à casa final (F) e possuir o amuleto mágico (A). As regras para obter o amuleto são:\n\nO jogador obtém o amuleto (A) se derrotar o dragão (D) ou se resolver o enigma da esfinge (E).\n\nPara enfrentar o dragão (D), o jogador precisa da espada de prata (S).\n\nO jogador encontrou a espada de prata, mas não conseguiu resolver o enigma da esfinge.\n\nModele o cenário. Supondo que o jogador chegue à casa final, ele vencerá o jogo se e somente se qual condição for satisfeita? Use equivalência lógica para simplificar a condição de vitória.\n\n\n4.4.6 Questão 6: Decisão de um Robô Autônomo\nUm robô de limpeza opera com as seguintes regras de decisão:\n\nSe o sensor de proximidade frontal detectar um obstáculo (O), o robô deve parar (P) e girar para a direita (G).\n\nSe a bateria estiver baixa (B), o robô deve parar (P) e retornar à base de carregamento (R).\n\nO robô não pode girar para a direita (G) e retornar à base (R) ao mesmo tempo.\n\nNeste momento, o sensor de proximidade detectou um obstáculo e a bateria está baixa.\n\nMostre que as regras atuais levam a uma contradição lógica, o que “travaria” o robô. Sugira uma modificação em uma das regras para resolver o conflito.\n\n\n4.4.7 Questão 7: Simplificação de Query de Banco de Dados (Corrigida)\nUm analista de dados precisa selecionar usuários de uma base de dados que satisfaçam uma condição complexa: “Selecionar usuários que são ‘ativos’ E (moram em ‘São Paulo’ OU têm mais de 50 compras) OU selecionar usuários que NÃO são ‘ativos’ E (moram em ‘São Paulo’ E têm mais de 50 compras)”.\nSeja: * A: O usuário é ‘ativo’.\n* S: O usuário mora em ‘São Paulo’.\n* C: O usuário tem mais de 50 compras.\nA condição pode ser escrita como: \\((A \\land (S \\lor C)) \\lor (\\neg A \\land (S \\land C))\\).\nUse uma tabela verdade para encontrar a forma normal disjuntiva mínima desta expressão. Qual das formas seria mais eficiente para o banco de dados processar?\n\n\n4.4.8 Questão 8: O Paradoxo do Mentiroso (Versão Proposicional)\nConsidere a seguinte afirmação: “Esta frase é falsa”. Seja P a proposição que representa “Esta frase é verdadeira”. A afirmação pode ser escrita como \\(P \\leftrightarrow \\neg P\\).\nUsando uma tabela verdade, mostre que esta fórmula é uma contradição. Explique por que isso representa um paradoxo e como a lógica proposicional clássica lida com sentenças autorreferentes.\n\n\n4.4.9 Questão 9: Política de Firewall\nUma política de segurança de rede é definida por duas regras:\n\nRegra 1: Se uma requisição vem de uma rede interna (I) E se destina à porta 443 (P), então a requisição é permitida (A).\n\nRegra 2: Se uma requisição vem de uma rede externa (ou seja, \\(\\neg I\\)) OU se destina a um serviço de monitoramento (ou seja, \\(\\neg P\\)), então a requisição é permitida (A).\n\nUm pacote chega de uma rede interna (I) e não se destina à porta 443 (\\(\\neg P\\)). A requisição será permitida? Use dedução lógica para chegar à conclusão. A política é redundante ou conflitante em algum aspecto?\n\n\n4.4.10 Questão 10: Tautologia, Contradição ou Contingência?\nUma empresa define uma nova política de bônus: “Um funcionário recebe um bônus (B) se ele atingiu a meta de vendas (V) ou se participou do novo treinamento (T). No entanto, se o funcionário participou do novo treinamento (T) mas não atingiu a meta de vendas (V), ele não recebe o bônus (B)”.\nA fórmula que descreve a política é: \\(((V \\lor T) \\to B) \\land ((T \\land \\neg V) \\to \\neg B)\\).\nAnalise esta fórmula. Ela é uma tautologia, uma contradição ou uma contingência? O que sua conclusão significa para a aplicabilidade da política da empresa?",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "",
    "text": "5.1 Contrapositivas e Recíprocas\nAs implicações são um problema, do ponto de vista da matemática. Sentenças do tipo se…então induzem uma conclusão. Provar estas sentenças é uma preocupação constante da matemática. Dada uma implicação, existem duas fórmulas relacionadas que ocorrem com tanta frequência que possuem nomes especiais: contrapositivas e recíprocas. Antes de mergulharmos em contrapositivas, precisamos visitar alguns portos.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#logicamente-equivalente",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#logicamente-equivalente",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.2 Logicamente Equivalente",
    "text": "5.2 Logicamente Equivalente\nVamos imaginar um mundo de fórmulas que consistem apenas em duas proposições:\\(P\\) e \\(Q\\). Usando os operadores da Lógica Proposicional podemos escrever um número muito grande de fórmulas diferentes combinando estas duas proposições.\nA coisa interessante sobre as fórmulas que conseguimos criar com apenas duas proposições é que cada uma dessas fórmulas tem uma Tabela Verdade com exatamente quatro linhas, \\(2^2=4\\). Mesmo que isso pareça surpreendente, só existem dezesseis configurações possíveis para a última coluna de todas as Tabelas-Verdade de todas as tabelas que podemos criar, \\(2^4=16\\). Como resultado, muitas fórmulas compartilham a mesma configuração final em suas Tabelas Verdade. Todas as fórmulas que possuem a mesma configuração na última coluna são equivalentes.Terei ouvido um viva?\nPara que a esforçada leitora possa ver um pouco mais de formalidade considere as proposições \\(A\\) e \\(B\\). Estas proposições serão ditas logicamente equivalentes se, e somente se, a proposição \\(A \\Leftrightarrow B\\) for uma tautologia.\nExemplo 1: Vamos mostrar que \\(P \\rightarrow Q\\) é logicamente equivalente a \\(\\neg Q \\rightarrow \\neg P\\).\nSolução: Para isso, verificaremos se a coluna do conectivo principal na Tabela Verdade para a proposição bicondicional \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\) contém apenas valores verdadeiros:\n\\[\n\\begin{array}{|c|c|c|c|c|c|c|}\n\\hline\nP & Q & P \\rightarrow Q & \\neg Q & \\neg P & \\neg Q \\rightarrow \\neg P & (P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P) \\\\\n\\hline\nF & F & T & T & T & T & T \\\\\n\\hline\nF & T & T & F & T & T & T \\\\\n\\hline\nT & F & F & T & F & F & T \\\\\n\\hline\nT & T & T & F & F & T & T \\\\\n\\hline\n\\end{array}\n\\]\nComo a coluna da operação principal \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\) contém apenas valores verdadeiros (\\(T\\)), a proposição bicondicional é uma tautologia. Consequentemente, as fórmulas \\(P \\rightarrow Q\\) e \\(\\neg Q \\rightarrow \\neg P\\) são logicamente equivalentes.\nExemplo 2: Vamos mostrar que \\(P \\wedge Q\\) não é logicamente equivalente a \\(P \\vee Q\\).\nSolução Para mostrar que \\(P \\wedge Q\\) não é logicamente equivalente a \\(P \\vee Q\\), precisamos verificar se a proposição bicondicional \\((P \\wedge Q) \\leftrightarrow (P \\vee Q)\\) é uma tautologia. Se não for uma tautologia, então as duas fórmulas não são logicamente equivalentes.\nConstruindo a Tabela Verdade (usando T para Verdadeiro e F para Falso):\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nP & Q & P \\wedge Q & P \\vee Q & (P \\wedge Q) \\leftrightarrow (P \\vee Q) \\\\\n\\hline\nT & T & T & T & T \\\\\nT & F & F & T & F \\\\\nF & T & F & T & F \\\\\nF & F & F & F & T \\\\\n\\hline\n\\end{array}\n\\]\nComo a última coluna da Tabela Verdade para \\((P \\wedge Q) \\leftrightarrow (P \\vee Q)\\) não contém apenas valores \\(T\\) (há ocorrências de \\(F\\)), a proposição bicondicional não é uma tautologia. Portanto, \\(P \\wedge Q\\) e \\(P \\vee Q\\) não são logicamente equivalentes.\nExemplo 3: Vamos mostrar que \\(P\\rightarrow Q\\) é logicamente equivalente a \\(\\neg P \\vee Q\\).\nSolução Verificando a Tabela Verdade:\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline\nP & Q & \\neg P & \\neg P \\vee Q & P \\rightarrow Q \\leftrightarrow \\neg P \\vee Q\\\\\n\\hline\nT & T & F & T & T\\\\\n\\hline\nT & F & F & F & T\\\\\n\\hline\nF & T & T & T & T\\\\\n\\hline\nF & F & T & T & T\\\\ \\hline\n\\end{array}\n\\]\nNeste caso \\(P\\rightarrow Q\\) e \\(\\neg P \\vee Q\\) são logicamente equivalentes.\nEm resumo, duas fórmulas \\(P\\) e \\(Q\\), atômicas, ou não, são equivalentes se quando \\(P\\) for verdadeiro, \\(Q\\) também será e vice-versa. Agora que já sabemos o que significa logicamente equivalentes podemos entender o que é uma proposição contrapositiva.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#contrapositiva",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#contrapositiva",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.3 Contrapositiva",
    "text": "5.3 Contrapositiva\nA contrapositiva de uma implicação é obtida invertendo-se o antecedente e o consequente da implicação original e negando-os. Por exemplo, considere a seguinte implicação: se chove, então a rua fica molhada sua contrapositiva poderia ser: se a rua não está molhada, então não choveu. Sejam \\(P\\) e \\(Q\\) fórmulas proposicionais derivadas de uma sentença do tipo se … então. A implicação \\(P\\rightarrow Q\\) representa a sentença Se \\(P\\), então \\(Q\\). Neste caso, A contrapositiva de \\(P\\rightarrow Q\\) será dada por:\n\\[\n\\begin{aligned}\n\\lnot Q \\rightarrow \\lnot P\n\\end{aligned}\n\\]\nA contrapositiva pode ser lida como se não \\(Q\\), então não \\(P\\). Em outras palavras estamos dizendo: Se \\(Q\\) é falso, então \\(P\\) é falso. A contrapositiva de uma fórmula é importante porque, frequentemente, é mais fácil provar a contrapositiva de uma fórmula que a própria fórmula. E, como a contrapositiva é logicamente equivalente a sua fórmula, provar a contrapositiva é provar a fórmula. Como a contrapositiva de uma implicação e a própria implicação são logicamente equivalentes, se provamos uma, a outra está provada. Além disso, a contrapositiva preserva a validade das implicações proposicionais. Finalmente, observe que a contrapositiva troca o antecedente pelo negação do consequente e vice-versa.\nExemplo 1:\nA contrapositiva de \\(P\\rightarrow (Q \\vee R)\\) é \\(\\lnot(Q \\vee R) \\rightarrow \\neg P\\).\nExemplo 2: Dizemos que uma função é injetora se $x y $implica \\(f(x) \\neq f(y)\\). A contrapositiva desta implicação é: se \\(f(x) = f(y)\\) então \\(x = y\\).\nO Exemplo 2 é uma prova de conceito. Normalmente é mais fácil assumir \\(f(x) = f(y)\\) e deduzir \\(x = y\\) do que assumir \\(x \\neq y\\) e deduzir \\(f(x) \\neq f(y)\\). Isto pouco tem a ver com funções e muito com o fato de que \\(x \\neq y\\) geralmente não é uma informação útil.\nO que torna a contrapositiva importante é que toda implicação é logicamente equivalente à sua contrapositiva. Consequentemente, se queremos provar que uma função é injetora, é suficiente provar que se \\(f(x) = f(y)\\) então \\(x = y\\).\nA contrapositiva funciona para qualquer declaração condicional, e matemáticos gastam muito tempo provando declarações condicionais.\nO que não podemos esquecer de jeito nenhum é que toda fórmula condicional terá a forma \\(P\\rightarrow Q\\). Mostramos que isso é logicamente equivalente a \\(\\lnot Q \\rightarrow \\lnot P\\) verificando a Tabela Verdade para a declaração bicondicional construída a partir dessas fórmulas. E que para obter a contrapositiva basta inverter antecedente e consequente e negar ambos. mantendo a relação lógica entre os termos da implicação.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#recíproca",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#recíproca",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.4 Recíproca",
    "text": "5.4 Recíproca\nA recíproca, também conhecida como conversa por alguns acadêmicos brasileiros, é obtida apenas invertendo antecedente e consequente. Então, considerando a recíproca da condicional \\(P\\rightarrow Q\\) será \\(Q \\rightarrow P\\). Diferentemente da contrapositiva a recíproca não é necessariamente equivalente à implicação original. Além disso, a contrapositiva preserva a equivalência lógica, a recíproca não.\nExemplo 1: A recíproca de \\(P\\rightarrow (Q \\vee R)\\) será \\((Q \\vee R) \\rightarrow P\\).\nExemplo 2: Dizemos que uma função é bem definida se cada entrada tem uma saída única. Assim, uma função é bem definida se \\(x = y\\) implica \\(f(x) = f(y)\\). Observe estas fórmulas:\n\n\\(f(x)\\) é bem definida significa que \\(x = y \\rightarrow f(x) = f(y)\\).\n\\(f(x)\\) é injetora significa que \\(f(x) = f(y) \\rightarrow x = y\\).\n\nPodemos ver que \\(f(x)\\) é bem definida é a recíproca de \\(f(x)\\) é injetora.\nPara provar uma bicondicional, como \\(P \\leftrightarrow Q\\), um matemático frequentemente divide a prova em duas etapas. Primeiro, prova-se a implicação \\(P \\rightarrow Q\\) e, depois, prova-se a sua recíproca, \\(Q \\rightarrow P\\). Nenhuma dessas etapas pode ser pulada, pois uma implicação e sua recíproca não são, em geral, logicamente equivalentes; a verdade de uma não garante a verdade da outra.\nPor exemplo, considere a implicação verdadeira: “Se um animal é um cão, então ele é um mamífero”. Sua recíproca, “Se um animal é um mamífero, então ele é um cão”, é claramente falsa, pois existem muitos mamíferos que não são cães. Este exemplo mostra que uma implicação pode ser verdadeira enquanto sua recíproca é falsa. Apenas nos casos em que ambas são verdadeiras, como em “um número inteiro é par se, e somente se, é divisível por 2”, é que a relação bicondicional se sustenta.\nPara resumir, uma implicação é sempre equivalente à sua contrapositiva, mas pode não ser equivalente à sua recíproca.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.5 Análise de Argumentos",
    "text": "5.5 Análise de Argumentos\nQuando vimos regras de inferência, sem muitos floreios, definimos argumentos. mas, sem usar a palavra argumento em nenhum lugar. Vamos voltar um pouco. Definiremos um argumento proposicionalmente como sendo uma regra de inferência, então um argumento será definido por um conjunto de proposições. Quando estamos analisando argumentos chamamos as proposições de premissas, de modo que:\n\\[\\frac{P_1, P_2, ..., P_n}{C}\\]\nUm argumento é formado por um conjunto de premissas \\(P_1, P_2, ..., P_n\\), chamado de antecedente, e uma proposição \\(C\\), chamada de conclusão. Dizemos que o argumento será válido, só e somente se, a implicação definida por \\((P_1 \\wedge P_2 \\wedge ... \\wedge P_n) \\rightarrow C\\) for uma tautologia. Neste caso, é muito importante percebermos que a conclusão de um argumento logicamente válido não é necessariamente verdadeira. A única coisa que a validade lógica garante é que se todas as premissas forem verdadeiras, a conclusão será verdadeira.\nPodemos recuperar as regras de inferência e observá-las pelo ponto de vista da análise de argumentos. Se fizermos isso, vamos encontrar alguns formatos comuns:\nModus Ponens: se é verdade que se eu estudar para o exame \\(P\\), então eu passarei no exame, \\(Q\\), e também é verdade que eu estudei para o exame \\(P\\), então podemos concluir que eu passarei no exame \\(Q\\).\nmatematicamente, sejam \\(P\\) e \\(Q\\) Proposições. A forma do Modus Ponens é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\rightarrow Q \\quad \\text{(Se P, então Q)} \\\\\n& \\quad P \\quad \\text{(P é verdadeiro)} \\\\\n\\hline\n& \\quad Q \\quad \\text{(Portanto, Q é verdadeiro)}\n\\end{align*}\n\\]\nCuja Tabela Verdade será:\n\\[\n\\begin{array}{|c|c|c|}\n\\hline\nP & Q & P \\rightarrow Q \\\\\n\\hline\nT & T & T \\\\\nT & F & F \\\\\nF & T & T \\\\\nF & F & T \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a primeira linha, se \\(P\\) é verdadeiro e \\(P→ Q\\) é verdadeiro, então \\(Q\\) é necessariamente verdadeiro, o que é exatamente a forma de Modus Ponens.\nModus Tollens : se é verdade que se uma pessoa é um pássaro \\(P\\), então essa pessoa pode voar \\(Q\\), e também é verdade que essa pessoa não pode voar \\(\\neg Q\\), então podemos concluir que essa pessoa não é um pássaro \\(\\neg P\\). Ou:\nSejam \\(P\\) e \\(Q\\) Proposições. A forma do Modus Tollens é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\rightarrow Q \\quad \\text{(Se P, então Q)} \\\\\n& \\quad \\neg Q \\quad \\text{(Q é falso)} \\\\\n\\hline\n& \\quad \\neg P \\quad \\text{(Portanto, P é falso)}\n\\end{align*}\n\\]\nCuja Tabela Verdade será dada por:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nP & Q & \\neg Q & P \\rightarrow Q & \\neg P \\\\\n\\hline\nT & T & F & T & F \\\\\nT & F & T & F & F \\\\\nF & T & F & T & T \\\\\nF & F & T & T & T \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a quarta linha, se \\(Q\\) é falso e \\(P\\rightarrow Q\\) é verdadeiro, então \\(P\\) é necessariamente falso, o que é exatamente a forma de Modus Tollens.\nSilogismo Hipotético : se é verdade que se eu acordar cedo \\(P\\), então eu irei correr \\(Q\\), e também é verdade que se eu correr \\(Q\\), então eu irei tomar um café da manhã saudável \\(R\\), podemos concluir que se eu acordar cedo \\(P\\), então eu irei tomar um café da manhã saudável \\(R\\).\nmatematicamente teremos: sejam \\(P\\), \\(Q\\) e \\(R\\) Proposições. A forma do Silogismo Hipotético é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\rightarrow Q \\quad \\text{(Se P, então Q)} \\\\\n& \\quad Q \\rightarrow R \\quad \\text{(Se Q, então R)} \\\\\n\\hline\n& \\quad P \\rightarrow R \\quad \\text{(Portanto, se P, então R)}\n\\end{align*}\n\\]\nCuja Tabela Verdade será:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nP & Q & R & P \\rightarrow Q & Q \\rightarrow R & P \\rightarrow R \\\\\n\\hline\nT & T & T & T & T & T \\\\\nT & T & F & T & F & F \\\\\nT & F & T & F & T & T \\\\\nT & F & F & F & T & T \\\\\nF & T & T & T & T & T \\\\\nF & T & F & T & F & T \\\\\nF & F & T & T & T & T \\\\\nF & F & F & T & T & T \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a primeira linha, se \\(P\\) é verdadeiro, \\(P\\rightarrow Q\\) é verdadeiro e \\(Q \\rightarrow R\\) é verdadeiro, então \\(P\\rightarrow R\\) é necessariamente verdadeiro, o que é exatamente a forma de Silogismo Hipotético.\nSilogismo Disjuntivo: se é verdade que ou eu vou ao cinema \\(P\\) ou eu vou ao teatro \\(Q\\), e também é verdade que eu não vou ao cinema \\(\\neg P\\), então podemos concluir que eu vou ao teatro \\(Q\\). Ou, com um pouco mais de formalidade:\nSejam \\(P\\) e \\(Q\\) Proposições. A forma do Silogismo Disjuntivo é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\vee Q \\quad \\text{(P ou Q)} \\\\\n& \\quad \\neg P \\quad \\text{(não P)} \\\\\n\\hline\n&\\quad Q \\quad \\text{(Portanto, Q)}\n\\end{align*}\n\\]\nA Tabela Verdade será:\n\\[\n\\begin{array}{|c|c|c|c|}\n\\hline\nP & Q & \\neg P & P \\vee Q \\\\\n\\hline\nT & T & F & T \\\\\nT & F & F & T \\\\\nF & T & T & T \\\\\nF & F & T & F \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a terceira linha, se \\(P\\) é falso e \\(P\\vee Q\\) é verdadeiro, então \\(Q\\) é necessariamente verdadeiro, o que é exatamente a forma de Silogismo Disjuntivo.\nNão podemos esquecer: um argumento só é válido se, e somente se, a proposição condicional que o expresse seja uma tautologia. Agora podemos definir um sistema de prova.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#finalmente-um-sistema-de-prova",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#finalmente-um-sistema-de-prova",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.6 Finalmente, um Sistema de Prova",
    "text": "5.6 Finalmente, um Sistema de Prova\nAinda estamos no domínio da Lógica Proposicional e vamos definir um sistema de prova simples e direto chamado de \\(\\mathfrak{L}\\) desenvolvido por John Lemmon na segunda metade do século XX. Vamos construir a prova e, sintaticamente, em cada linha da nossa prova teremos:\n\num axioma de \\(\\mathfrak{L}\\). Um axioma é uma fórmula ou proposição que é aceita como verdadeira primitivamente, sem necessidade de demonstração. Por exemplo: \\((p \\rightarrow q) \\rightarrow ((q \\rightarrow r) \\rightarrow (p \\rightarrow r))\\);\no resultado da aplicação do Modus Ponens;\numa hipótese, na forma de fórmula;\nou um lema, uma proposição auxiliar demonstrável utilizada como passo intermediário na prova. Por exemplo: a derivação de fórmulas menores.\n\nAxiomas são proposições consideradas como verdades, são absolutos. Lemas são passos intermediários no processo de prova, pequenos teoremas já provados e, finalmente temos o teorema: representado por \\(\\varphi\\). Um teorema é uma fórmula demonstrável a partir de axiomas, lemas e das regras de inferência do sistema. Vamos começar dos axiomas.\nExistem três axiomas no sistema \\(\\mathfrak{L}\\). Estes axiomas formam a base do sistema dedutivo \\(\\mathfrak{L}\\) em Lógica Proposicional. Eles capturam propriedades fundamentais das implicações que permitem derivar teoremas válidos.\nAxioma 1: \\(A \\rightarrow (B \\rightarrow A)\\), este axioma estabelece que se \\(A\\) é verdadeiro, então a implicação \\(B \\rightarrow A\\) também é verdadeira, independentemente de \\(B\\). Isso porque a implicação \\(B \\rightarrow A\\) só será falsa se \\(B\\) for verdadeiro e \\(A\\) falso, o que não pode ocorrer se \\(A\\) é inicialmente verdadeiro.\nAxioma 2: \\((A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\rightarrow B) \\rightarrow (A \\rightarrow C))\\). Este axioma funciona como uma propriedade distributiva da implicação. Ele estabelece que, se uma hipótese \\(A\\) implica uma segunda implicação \\((B \\rightarrow C)\\), e se a mesma hipótese \\(A\\) também implica \\(B\\), então podemos concluir que a hipótese \\(A\\) necessariamente implica \\(C\\). Essencialmente, ele permite encadear deduções que dependem de uma mesma premissa inicial \\(A\\).\nAxioma 3: \\((\\lnot B \\rightarrow \\lnot A) \\rightarrow ((\\lnot B \\rightarrow A) \\rightarrow B)\\), este axioma garante que se de \\(\\lnot B\\) podemos inferir tanto \\(\\lnot A\\) quanto \\(A\\), então \\(B\\) deve ser verdadeiro. Isso porque \\(B\\) e \\(\\lnot B\\) não podem ser verdadeiros simultaneamente.\nAlém dos axiomas, usaremos apenas uma regra de inferência, o Modus Ponens. O Modus Ponens está intimamente relacionado à proposição \\((P \\wedge (P \\rightarrow Q)) \\rightarrow Q\\). Tanto a proposição quando a regra de inferência, de certa forma, dizem: “se \\(P\\) e \\(P\\rightarrow Q\\) são verdadeiros, então \\(Q\\) é verdadeiro”. Esta proposição é um exemplo de uma tautologia, porque é verdadeira para cada configuração de \\(P\\) e \\(Q\\). A diferença é que esta tautologia é uma única proposição, enquanto o Modus Ponens é uma regra de inferência que nos permite deduzir novas proposições a partir proposições já provadas.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#o-símbolo-de-demonstrabilidade-turnstile",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#o-símbolo-de-demonstrabilidade-turnstile",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.7 O Símbolo de Demonstrabilidade (Turnstile)",
    "text": "5.7 O Símbolo de Demonstrabilidade (Turnstile)\nAntes de apresentarmos nossas primeiras provas formais, precisamos introduzir um símbolo fundamental na teoria da demonstração: o turnstile ou catraca em português ou ainda, formalmente, símbolo de demonstrabilidade, representado por \\(\\vdash\\).\nO que significa \\(\\vdash\\)?\nO símbolo \\(\\vdash\\) (lê-se “demonstra” ou “deriva”) indica que uma fórmula pode ser demonstrada ou derivada dentro de um sistema formal específico. É um símbolo metalinguístico - ele fala sobre o que podemos fazer no sistema, não é parte das fórmulas em si.\nDiferentes usos do símbolo:\n\nTeorema sem hipóteses: \\(\\vdash A\\)\nSignifica: “A fórmula \\(A\\) é um teorema” (pode ser demonstrada usando apenas axiomas e regras de inferência)\nDerivação com hipóteses: \\(B_1, B_2, ..., B_n \\vdash A\\)\nSignifica: “A partir das hipóteses \\(B_1, B_2, ..., B_n\\), podemos demonstrar \\(A\\)”\nCom sistema específico: \\(\\vdash_{\\mathfrak{L}} A\\)\nSignifica: “A fórmula \\(A\\) é demonstrável no sistema \\(\\mathfrak{L}\\)”\n\nExemplos ilustrativos:\n\n\\(P, P \\rightarrow Q \\vdash Q\\)\n“Das hipóteses \\(P\\) e \\(P \\rightarrow Q\\), podemos demonstrar \\(Q\\)” (isso é o Modus Ponens)\n\\(\\vdash (A \\rightarrow A)\\)\n“A fórmula \\(A \\rightarrow A\\) é um teorema” (pode ser provada sem hipóteses adicionais)\n\\(A \\rightarrow B, B \\rightarrow C \\vdash A \\rightarrow C\\)\n“Das hipóteses \\(A \\rightarrow B\\) e \\(B \\rightarrow C\\), podemos demonstrar \\(A \\rightarrow C\\)”\n\nDiferença importante:\n\n\\(P \\rightarrow Q\\) é uma fórmula da lógica proposicional (objeto da linguagem)\n\\(P \\vdash Q\\) é uma afirmação sobre demonstrabilidade (metalinguagem)\n\nA primeira é uma implicação que pode ser verdadeira ou falsa em uma interpretação. A segunda afirma que existe uma sequência de passos dedutivos que vai de \\(P\\) até \\(Q\\).\nConvenção: Quando o sistema é claro pelo contexto, omitimos o subscrito. Assim, \\(\\vdash A\\) geralmente significa \\(\\vdash_{\\mathfrak{L}} A\\) quando estamos trabalhando no sistema \\(\\mathfrak{L}\\).\nCom esta notação estabelecida, podemos agora formalizar o conceito de teorema: uma fórmula \\(A\\) é um teorema do sistema \\(\\mathfrak{L}\\) se, e somente se, \\(\\vdash_{\\mathfrak{L}} A\\).\nNos resta apenas destacar a última linha de uma prova. No sistema \\(\\mathfrak{L}\\), a última fórmula será chamada de teorema. Representaremos como \\(\\vdash A\\) se \\(A\\) for um teorema. Escrevemos \\(B_1, B_2, ..., B_n \\vdash_L A\\) se, e somente se, \\(A\\) puder ser provado em \\(\\mathfrak{L}\\) a partir das fórmulas dadas \\(B_1, B_2, ..., B_n\\). Nesse caso:\n\n\\(A\\): Fórmula que é um teorema;\n\\(g_1, ..., g_n\\): Fórmulas que servem como premissas;\n\\(\\vdash_L\\): Símbolo para indicar demonstrável em \\(\\mathfrak{L}\\);\nescrevemos \\(\\mathfrak{L} A\\) para indicar que \\(A\\) é demonstrável no sistema \\(\\mathfrak{L}\\).\n\n\n5.7.1 Notação para Substituição em Provas\nAntes de iniciarmos nossas provas no sistema \\(\\mathfrak{L}\\), é importante esclarecer uma notação que usaremos por conveniência. Ao trabalhar com axiomas e teoremas, frequentemente precisamos indicar que estamos substituindo variáveis proposicionais por fórmulas específicas.\nNotação de Substituição: Usaremos o símbolo \\(:=\\) para indicar substituição. Este símbolo não faz parte do alfabeto da lógica proposicional - é apenas uma ferramenta metalinguística (uma notação sobre a linguagem, não dentro dela) que nos ajuda a explicar como estamos aplicando axiomas.\nQuando escrevemos \\(A := P\\), estamos dizendo: “onde aparece a variável \\(A\\) no axioma, substitua por \\(P\\)”.\nExemplo de uso: Considere o Axioma 1: \\(A \\rightarrow (B \\rightarrow A)\\)\nSe quisermos usar este axioma com proposições específicas, podemos escrever: - Com \\(A := P\\) e \\(B := Q\\), obtemos: \\(P \\rightarrow (Q \\rightarrow P)\\) - Com \\(A := (P \\land Q)\\) e \\(B := R\\), obtemos: \\((P \\land Q) \\rightarrow (R \\rightarrow (P \\land Q))\\)\nImportante: Esta é uma convenção notacional para facilitar a leitura. Formalmente, estamos criando uma instância do axioma - aplicando o esquema axiomático a fórmulas específicas. O símbolo \\(:=\\) é nossa forma concisa de indicar essa instanciação.\nAlternativamente, poderíamos dizer “substituindo \\(A\\) por…” ou “com \\(A\\) sendo…”, mas \\(:=\\) torna as provas mais claras e concisas. É uma licença pedagógica que tomamos para melhorar a legibilidade, similar a quando dizemos “seja \\(x\\) um número” em vez de usar quantificadores formais em textos introdutórios.\nAgora que temos uma notação adequada, podemos prosseguir com nossas provas, usando esta notação quando necessário.\nProva 1: nosso teorema é \\(A \\rightarrow A\\)\n\n\\(A \\rightarrow ((A \\rightarrow A) \\rightarrow A)\\) (Axioma 1 com \\(A := A\\) e \\(B := (A \\rightarrow A)\\))\nAqui usamos o primeiro axioma de \\(\\mathfrak{L}\\), que tem a forma \\((A \\rightarrow (B \\rightarrow A))\\). Para tanto usamos \\(A := A\\) e \\(B := (A \\rightarrow A)\\) para fazer a correspondência com o axioma, obtendo a fórmula na linha. Observe que usamos o símbolo \\(:=\\), um símbolo que não faz parte do nosso alfabeto e aqui está sendo usado com o sentido substituído por. Até na matemática usamos licenças poéticas.\n\\((A \\rightarrow ((A \\rightarrow A) \\rightarrow A)) \\rightarrow ((A \\rightarrow (A \\rightarrow A)) \\rightarrow (A \\rightarrow A))\\) (Axioma 2 com \\(A := A\\), \\(B := (A \\rightarrow A)\\) e $ c := A$)\nA segunda linha usa o segundo axioma de \\(\\mathfrak{L}\\), que é \\((A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\rightarrow B) \\rightarrow (A \\rightarrow C))\\). O autor substituiu \\(A := A\\), \\(B := (A \\rightarrow A)\\) e $ c := A$ para obter a fórmula na linha.\n\\(((A \\rightarrow (A \\rightarrow A)) \\rightarrow (A \\rightarrow A))\\) (Modus Ponens aplicado às linhas 1 e 2)\nFinalmente aplicamos a regra de Modus Ponens, que diz que se temos \\(A\\) e também temos \\(A \\rightarrow B\\), então podemos deduzir \\(B\\). As linhas 1 e 2 correspondem a \\(A\\) e \\(A \\rightarrow B\\), respectivamente, e ao aplicar Modus Ponens, obtemos \\(B\\), que é a fórmula na linha 3.\n\\((A \\rightarrow (A \\rightarrow A))\\) (Axioma 1 com \\(A := A\\) e \\(B := A\\))\nDe forma similar à primeira linha, a quarta linha usa o primeiro axioma com \\(A := A\\) e \\(B := A\\).\n\\((A \\rightarrow A)\\)(Modus Ponens aplicado às linhas 3 e 4)\nFinalmente, aplicamos o Modus Ponens às linhas 3 e 4 para obter a fórmula na última linha, que é o teorema que tentamos provar.\nEntão, o primeiro teorema está correto e podemos escrever \\(\\vdash \\mathfrak{L} A\\).\n\nProva 2: Vamos provar \\(\\vdash (\\lnot B \\rightarrow B) \\rightarrow B\\)\nPara esta prova, utilizaremos o Teorema 1 (\\(\\vdash A \\rightarrow A\\)) como um lema e o Axioma 3.\nRecordando o Axioma 3: \\((\\lnot X \\rightarrow \\lnot Y) \\rightarrow ((\\lnot X \\rightarrow Y) \\rightarrow X)\\)\nDemonstração:\n\n\\(\\lnot B \\rightarrow \\lnot B\\)\n(Lema: Teorema 1 com \\(A := \\lnot B\\))\nJustificativa: Como já provamos que \\(A \\rightarrow A\\) é um teorema, podemos usá-lo substituindo \\(A\\) por \\(\\lnot B\\).\n\\((\\lnot B \\rightarrow \\lnot B) \\rightarrow ((\\lnot B \\rightarrow B) \\rightarrow B)\\)\n(Instância do Axioma 3 com \\(X := B\\) e \\(Y := B\\))\nJustificativa: Substituindo no Axioma 3:\n\nOnde temos \\(\\lnot X\\), colocamos \\(\\lnot B\\)\nOnde temos \\(\\lnot Y\\), colocamos \\(\\lnot B\\)\n\nOnde temos \\(Y\\), colocamos \\(B\\)\nOnde temos \\(X\\), colocamos \\(B\\)\n\nAssim: \\((\\lnot B \\rightarrow \\lnot B) \\rightarrow ((\\lnot B \\rightarrow B) \\rightarrow B)\\)\n\\(((\\lnot B \\rightarrow B) \\rightarrow B)\\)\n(Modus Ponens aplicado às linhas 1 e 2)\nJustificativa: A linha 1 nos dá \\(\\lnot B \\rightarrow \\lnot B\\), que é exatamente o antecedente da implicação na linha 2. Aplicando Modus Ponens, obtemos o consequente.\n\nPortanto, provamos \\(\\vdash (\\lnot B \\rightarrow B) \\rightarrow B\\).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#explorando-as-limitações-do-sistema-mathfrakl",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#explorando-as-limitações-do-sistema-mathfrakl",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.8 Explorando as Limitações do Sistema \\(\\mathfrak{L}\\)",
    "text": "5.8 Explorando as Limitações do Sistema \\(\\mathfrak{L}\\)\nVamos tentar uma terceira prova, um pouco mais complexa e com mais nuances.\nObjetivo: Examinar por que NÃO podemos provar \\(\\vdash ((A \\land B) \\rightarrow C)\\) no sistema \\(\\mathfrak{L}\\).\nEsta seção é fundamental para entender as limitações de sistemas formais. Vamos analisar uma tentativa de prova que falha, e explicar por que isso ocorre.\n\n5.8.1 Tentativa (INVÁLIDA) de Demonstração\nAlguém poderia tentar provar \\(((A \\land B) \\rightarrow C)\\) assim:\n\n\\((A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\land B) \\rightarrow C)\\) ❌ [ERRO: Isto NÃO é um axioma de \\(\\mathfrak{L}\\)]\n\\(A \\rightarrow (B \\rightarrow C)\\) (Hipótese)\n\\((A \\land B) \\rightarrow C\\) (Tentativa de aplicar Modus Ponens às linhas 1 e 2) ❌ [INVÁLIDO]\n\n\n\n5.8.2 Por Que Esta Prova Falha?\n1. Limitação Fundamental: O sistema \\(\\mathfrak{L}\\) trabalha apenas com os conectivos \\(\\rightarrow\\) (implicação) e \\(\\lnot\\) (negação). O conectivo \\(\\land\\) (conjunção) não é primitivo neste sistema.\n2. Ausência de Axiomas para Conjunção: Os três axiomas de \\(\\mathfrak{L}\\) não fornecem nenhuma regra para manipular o conectivo \\(\\land\\). Observe:\n\nAxioma 1: Lida apenas com implicações;\nAxioma 2: Distribui implicações sobre implicações;\nAxioma 3: Relaciona negação e implicação.\n\nNenhum deles menciona ou permite derivar propriedades da conjunção.\n3. Problema da Linha 2: Mesmo que a linha 1 fosse válida (não é), a linha 2 introduz uma hipótese que não pode ser descartada adequadamente no sistema \\(\\mathfrak{L}\\) básico. Para trabalhar com hipóteses temporárias, precisaríamos do Teorema da Dedução, que não está disponível na versão básica do sistema.\n\n\n5.8.3 Verificação pela Tabela Verdade\nVamos verificar se \\((A \\land B) \\rightarrow C\\) é sequer uma tautologia:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nA & B & C & A \\land B & (A \\land B) \\rightarrow C \\\\\n\\hline\nT & T & T & T & T \\\\\nT & T & F & T & F \\\\\nT & F & T & F & T \\\\\nT & F & F & F & T \\\\\nF & T & T & F & T \\\\\nF & T & F & F & T \\\\\nF & F & T & F & T \\\\\nF & F & F & F & T \\\\\n\\hline\n\\end{array}\n\\]\nComo vemos, \\((A \\land B) \\rightarrow C\\) não é uma tautologia - é falsa quando \\(A\\) e \\(B\\) são verdadeiros mas \\(C\\) é falso. Portanto, não deveria ser demonstrável em nenhum sistema correto.\n\n\n5.8.4 Como Sistemas Mais Ricos Resolvem Isso\n1. Adicionando Axiomas para Conjunção: Sistemas como o cálculo proposicional clássico incluem axiomas específicos para \\(\\land\\):\n\n\\((A \\land B) \\rightarrow A\\) (eliminação da conjunção, esquerda);\n\\((A \\land B) \\rightarrow B\\) (eliminação da conjunção, direita);\n\\(A \\rightarrow (B \\rightarrow (A \\land B))\\) (introdução da conjunção).\n\n2. Definindo Conjunção via Outros Conectivos: Em alguns sistemas, podemos definir:\n\n\\(A \\land B \\equiv \\lnot(\\lnot A \\lor \\lnot B)\\) (Lei de De Morgan);\nMas isso requer também axiomas para disjunção (\\(\\lor\\)).\n\n3. Sistemas de Dedução Natural: Incluem regras específicas de introdução e eliminação para cada conectivo, tornando as provas mais intuitivas.\n\n\n5.8.5 Incompletude vs. Incorreção\nÉ importante que a curiosa leitora entenda a diferença:\nIncompletude: O sistema \\(\\mathfrak{L}\\) é incompleto para a lógica proposicional com todos os conectivos. Existem tautologias (como \\((P \\lor \\lnot P)\\)) que não podem ser provadas nele porque o sistema não tem ferramentas para lidar com disjunção.\nIncorreção: Se o sistema permitisse provar fórmulas que não são tautologias (como \\((A \\land B) \\rightarrow C\\)), ele seria incorreto. Felizmente, \\(\\mathfrak{L}\\) é correto - tudo que pode ser provado nele é de fato uma tautologia.\nCompletude Relativa: O sistema \\(\\mathfrak{L}\\) é completo para o fragmento implicacional da lógica proposicional - toda tautologia que usa apenas \\(\\rightarrow\\) e \\(\\lnot\\) pode ser provada nele.\n\n\n5.8.6 Lição Importante\nEsta tentativa falha de prova ilustra que:\n\nNem toda fórmula bem formada pode ser provada em um sistema formal;\nA escolha de axiomas e conectivos primitivos determina o poder expressivo do sistema;\nUm sistema pode ser correto mas incompleto;\nPara trabalhar com todos os conectivos lógicos, precisamos de sistemas mais ricos.\n\nO sistema \\(\\mathfrak{L}\\), apesar de suas limitações, é valioso pedagogicamente porque demonstra conceitos fundamentais de sistemas formais de forma simples e elegante. Esta última tentativa de prova é interessante. Para o teorema \\((A \\wedge B) \\rightarrow C\\), não é possível provar diretamente no sistema \\(\\mathfrak{L}\\) sem a presença de axiomas adicionais ou a introdução de hipóteses adicionais. Que não fazem parte do sistema \\(\\mathfrak{L}\\).\nO sistema \\(\\mathfrak{L}\\) é baseado em axiomas específicos (que utilizam os conectivos \\(\\rightarrow\\) e \\(\\lnot\\)) e em uma única regra de inferência (Modus Ponens), como vimos. O teorema \\(((A \\wedge B) \\rightarrow C)\\) não pode ser derivado diretamente apenas a partir dos axiomas do sistema \\(\\mathfrak{L}\\) porque o conectivo de conjunção (\\(\\wedge\\)) não é primitivo no sistema \\(\\mathfrak{L}\\) e não pode ser definido ou introduzido usando apenas os axiomas fornecidos e o Modus Ponens sem regras adicionais ou definições para \\(\\wedge\\). Os axiomas de \\(\\mathfrak{L}\\) focam na implicação e na negação.\nSe tivéssemos acesso a axiomas ou regras de inferência adicionais que lidam com a conjunção, ou se você tem permissão para introduzir hipóteses adicionais (por exemplo, você pode introduzir \\(A \\wedge B \\rightarrow C\\) como uma hipótese), então a prova pode ser possível. Em alguns sistemas de lógica, a conjunção pode ser definida em termos de negação e disjunção, e neste caso, o teorema pode ser provável.\nCom as ferramentas que vimos até agora, podemos tentar provar o teorema \\(((A \\wedge B) \\rightarrow C)\\) usando uma Tabela Verdade:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nA & B & C & A \\wedge B & (A \\wedge B) \\rightarrow C \\\\\n\\hline\nT & T & T & T & T \\\\\nT & T & F & T & F \\\\\nT & F & T & F & T \\\\\nT & F & F & F & T \\\\\nF & T & T & F & T \\\\\nF & T & F & F & T \\\\\nF & F & T & F & T \\\\\nF & F & F & F & T \\\\\n\\hline\n\\end{array}\n\\]\nComo podemos ver, a coluna final, que representa o teorema \\((A \\wedge B) \\rightarrow C\\), não é sempre verdadeira. Isso significa que a proposição \\((A \\wedge B) \\rightarrow C\\) não é uma tautologia, existe uma situação, quando \\(A\\) e \\(B\\) são verdadeiros, mas \\(C\\) é falso, em que a proposição inteira é falsa. Basta isso para que a proposição não seja uma tautologia e, portanto, não possa ser provada como um teorema.\nA nossa terceira prova mostra os limites do sistema \\(\\mathfrak{L}\\), o que pode dar uma falsa impressão sobre o a capacidade deste sistema de prova. Vamos tentar melhorar isso.\n\n\n5.8.7 Lema\nVamos lembrar a primeira prova, provamos \\(A \\rightarrow A\\) e, a partir deste momento, \\(A \\rightarrow A\\) se tornou um Lema. Um lema é uma afirmação que é provada não como um fim em si mesma, mas como um passo útil para a prova de outros teoremas.\nEm outras palavras, um lema é um resultado menor que serve de base para um resultado maior. Uma vez que um lema é provado, ele pode ser usado em provas subsequentes de teoremas mais complexos. Em geral, um lema é menos geral e menos notável do que um teorema.\nConsidere o seguinte Teorema: \\(\\vdash_L (\\lnot B \\rightarrow B) \\rightarrow B\\), podemos prová-lo da seguinte forma:\n\n\\(\\lnot B \\rightarrow \\lnot B\\) - Lembrando que \\(A := \\lnot B\\) do Teorema 1\n\\((\\lnot B \\rightarrow \\lnot B) \\rightarrow ((\\lnot B \\rightarrow B) \\rightarrow B)\\) - Decorrente do Axioma 3, em que \\(A := \\lnot B\\) e \\(B := B\\)\n\\(((\\lnot B \\rightarrow B) \\rightarrow B)\\)- Através do Modus Ponens Justificativa: Linhas 1 e 2\n\nA adoção de lemas é, na verdade, um mecanismo útil para economizar tempo e esforço. Ao invés de replicar o Teorema 1 na primeira linha dessa prova, nós poderíamos, alternativamente, copiar as 5 linhas da prova original do Teorema 1, substituindo todos os casos de \\(A\\) Por \\(\\lnot B\\). As justificativas seriam mantidas iguais às da prova original do Teorema 1. A prova resultante, então, consistiria exclusivamente de axiomas e aplicações do Modus Ponens. No entanto, uma vez que a prova do Teorema 1 já foi formalmente documentada, parece redundante replicá-la aqui. E eis o motivo da existência e uso dos lemas.\n\n\n5.8.8 Hipóteses\nHipóteses são suposições ou proposições feitas como base para o raciocínio, sem a suposição de sua veracidade. Elas são usadas como pontos de partida para investigações ou pesquisas científicas. Essencialmente uma hipótese é uma teoria ou ideia que você pode testar de alguma forma. Isso significa que, através de experimentação e observação, uma hipótese pode ser provada verdadeira ou falsa.\nPor exemplo, se você observar que uma planta está morrendo, pode formar a hipótese de que ela não está recebendo água suficiente. Para testar essa hipótese, você pode dar mais água à planta e observar se ela melhora. Se melhorar, isso suporta sua hipótese. Se não houver mudança, isso sugere que sua hipótese pode estar errada, e você pode então formular uma nova hipótese para testar.\nNa Lógica Proposicional, uma hipótese é uma proposição (ou afirmação) que é assumida como verdadeira para o propósito de argumentação ou investigação. Obviamente, pode ser uma fórmula atômica, ou complexa, desde que seja uma Fórmula Bem Formada.\nEm um sistema formal de provas, como o sistema \\(\\mathfrak{L}\\) uma hipótese é um ponto de partida para um processo de dedução. O objetivo é usar as regras do sistema para deduzir novas proposições a partir das hipóteses. Se uma proposição puder ser deduzida a partir das hipóteses usando as regras do sistema, dizemos que essa proposição é uma consequência lógica das hipóteses. Se temos as hipóteses \\(P\\) e \\(P\\rightarrow Q\\), podemos deduzir \\(Q\\) usando o Modus Ponens. Nesse caso, \\(Q\\) seria uma consequência lógica das hipóteses.\nNo contexto do sistema de provas \\(\\mathfrak{L}\\) e considerando apenas a Lógica Proposicional, uma hipótese é uma proposição ou conjunto de proposições assumidas como verdadeiras, a partir das quais outras proposições podem ser logicamente deduzidas.\nExemplo 1: considere o seguinte argumento:\n\\[\n\\begin{align*}\nA \\rightarrow (B \\rightarrow C) \\\\\nA \\rightarrow B \\\\\n\\hline\nA \\rightarrow C\n\\end{align*}\n\\]\nAplicando o processo de dedução do Sistema \\(\\mathfrak{L}\\), teremos:\n\\[\n\\begin{align*}\n& A \\rightarrow (B \\rightarrow C) &\\text{Hipótese} \\\\\n& A \\rightarrow B &\\text{Hipótese}\\\\\n& (A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\rightarrow B) \\rightarrow (A \\rightarrow C)) &\\text{Axioma 2}\\\\\n& (A \\rightarrow B) \\rightarrow (A \\rightarrow C) & \\text{Modus Ponens, linhas 1 e 3} \\\\\n& A \\rightarrow C & \\text{Modus Ponens, linhas 2 e 4}\\\\\n\\end{align*}\n\\]\nNeste exemplo, vemos o uso das Hipóteses. No processo de dedução, as hipóteses devem ser usadas na forma como são declaradas. O que as torna diferentes dos lemas.\nNeste ponto, podemos voltar um pouco e destacar um constructor importante na programação imperativa: se…então representando por \\(P\\rightarrow Q\\), uma implicação. Que pode ser lido como hipótese \\(P\\) e conclusão \\(Q\\).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.9 Análise de Argumentos Lógicos em Textos do Cotidiano",
    "text": "5.9 Análise de Argumentos Lógicos em Textos do Cotidiano\nUma das coisas mais importantes que a amável leitora irá aprender neste documento é que a lógica não é apenas uma disciplina acadêmica, mas uma ferramenta poderosa para analisar e compreender argumentos em textos do cotidiano. A lógica nos ajuda a identificar premissas e conclusões, avaliar a validade de argumentos e entender como as ideias estão interconectadas. A lógica é útil e pode ser a diferença entre um argumento persuasivo e um argumento falacioso. Além disso, o uso da lógica para entender textos do cotidiano criará as estruturas cognitivas necessários para a construção de soluções computacionais para os problemas mais complexos da atualidade.\nA análise de argumentos lógicos em textos do cotidiano envolve a identificação de premissas e conclusões, bem como a formalização dessas relações em Lógica Proposicional ou lógica de predicados.\nDeste ponto tem diante, caberá a esforçada leitora, aplicar os conceitos aprendidos neste documento para analisar textos de livros, notícias, especificações de sistemas e outros documentos. Comece vendo os textos de exemplo a seguir.\n\n5.9.1 Exemplo 1: Avanço Científico na Medicina (2022)\n“Em 2022, pesquisadores descobriram que a vacina contra a malária aprovada pela Organização Mundial da Saúde pode ajudar a salvar centenas de milhares de vidas por ano. É também a primeira vacina do mundo para uma infecção parasitária. A malária mata mais de 600.000 pessoas anualmente, a maioria crianças menores de cinco anos.”\n\n5.9.1.1 Premissas e Conclusão\nPremissas:\n\nA malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\nA vacina contra a malária foi aprovada pela Organização Mundial da Saúde;\nA vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária.\n\nConclusão:\n\nA vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\n\n\n5.9.1.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\n\\(Q\\): A vacina contra a malária foi aprovada pela OMS;\n\\(R\\): A vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária;\n\\(S\\): A vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\nEstrutura do argumento: \\((P \\wedge Q \\wedge R) \\rightarrow S\\)\nLógica de Predicados:\n\n\\(m\\): malária;\n\\(v\\): vacina contra a malária;\n\\(Mata(x, y)\\): x mata y pessoas anualmente;\n\\(MajoriaCriancas(x)\\): a maioria das vítimas de x são crianças menores de cinco anos;\n\\(Aprovada(x)\\): x foi aprovada pela OMS;\n\\(Primeira(x)\\): x é a primeira vacina para infecção parasitária;\n\\(PodeSalvar(x, y)\\): x pode salvar y vidas por ano.\n\nFormalização:\n\n\\(Mata(m, 600000) \\wedge MajoriaCriancas(m)\\);\n\\(Aprovada(v)\\);\n\\(Primeira(v)\\);\n\\([Mata(m, 600000) \\wedge MajoriaCriancas(m) \\wedge Aprovada(v) \\wedge Primeira(v)] \\rightarrow PodeSalvar(v, \\text{\"centenas de milhares\"})\\).\n\n\n\n5.9.1.3 Análise da Validade\nEste argumento não segue uma forma lógica estritamente válida. A relação entre as premissas e a conclusão depende de conhecimentos médicos implícitos.\nEstrutura implícita:\n\nSe uma doença mata muitas pessoas e existe uma vacina aprovada contra essa doença, então essa vacina pode salvar muitas vidas;\nA malária mata muitas pessoas;\nExiste uma vacina aprovada contra a malária;\nLogo, a vacina contra a malária pode salvar muitas vidas.\n\nEsta estrutura se aproxima de um modus ponens, mas depende de uma premissa implícita.\n\n\n5.9.1.4 Análise da Solidez\nAs premissas são verificáveis e consideradas verdadeiras:\n\nA mortalidade por malária é confirmada por dados epidemiológicos da OMS;\nA aprovação da vacina pela OMS é um fato verificável;\nSer a primeira vacina para infecção parasitária é historicamente verificável.\n\nA conclusão é razoável no contexto médico, mas sua solidez completa dependeria de dados específicos sobre a eficácia da vacina.\n\n\n\n5.9.2 Exemplo 2: Inovação Tecnológica Nuclear (2023)\n“O campo da fusão nuclear teve um grande avanço em 2023. A fusão nuclear é uma reação nuclear que produz uma grande quantidade de calor que pode ser usada para gerar energia. É o mesmo processo que alimenta o sol. A reação nuclear é produzida por dois núcleos atômicos leves que se combinam e formam um único núcleo atômico leve mais pesado. Isso produz uma grande quantidade de energia.”\n\n5.9.2.1 Premissas e Conclusão\nPremissas:\n\nA fusão nuclear é uma reação que ocorre quando dois núcleos atômicos leves se combinam formando um único núcleo mais pesado.\nEsta reação produz grande quantidade de calor.\nO calor pode ser usado para gerar energia.\nA fusão nuclear é o mesmo processo que alimenta o sol.\n\nConclusão:\n\nO campo da fusão nuclear teve um grande avanço em 2023.\n\n\n\n5.9.2.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A fusão nuclear é uma reação em que núcleos leves se combinam formando um núcleo mais pesado.\n\\(Q\\): A fusão nuclear produz grande quantidade de calor.\n\\(R\\): O calor pode ser usado para gerar energia.\n\\(S\\): A fusão nuclear é o mesmo processo que alimenta o sol.\n\\(T\\): O campo da fusão nuclear teve um grande avanço em 2023.\n\nEstrutura do argumento: \\((P \\wedge Q \\wedge R \\wedge S) \\rightarrow T\\)\nLógica de Predicados:\n\n\\(FusaoNuclear(x)\\): \\(x\\) é um processo de fusão nuclear.\n\\(Reacao(x, y, z)\\): \\(x\\) é uma reação em que \\(y\\) se combina formando \\(z\\).\n\\(Produz(x, y)\\): \\(x\\) produz \\(y\\).\n\\(PodeGerarEnergia(x)\\): \\(x\\) pode ser usado para gerar energia.\n\\(AlimentaSol(x)\\): \\(x\\) é o processo que alimenta o sol.\n\\(TeveAvanco(x, y, z)\\): o campo \\(x\\) teve um avanço de grau \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Reacao(x, \\text{\"núcleos leves\"}, \\text{\"núcleo mais pesado\"})]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Produz(x, \\text{\"grande quantidade de calor\"})]\\);\n\\(\\forall x [Produz(x, \\text{\"grande quantidade de calor\"}) \\rightarrow PodeGerarEnergia(x)]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow AlimentaSol(x)]\\);\n\\(TeveAvanco(\\text{\"campo da fusão nuclear\"}, \\text{\"grande\"}, 2023)\\).\n\n\n\n5.9.2.3 Análise da Validade\nEste argumento apresenta uma estrutura incomum, pois a conclusão não é derivada logicamente das premissas apresentadas. As premissas descrevem o que é a fusão nuclear e suas características, mas não estabelecem uma relação lógica com o avanço mencionado.\nSob análise de dedução natural, o argumento não é válido, pois a conclusão não é uma consequência lógica das premissas fornecidas.\n\n\n5.9.2.4 Análise da Solidez\nComo o argumento não é formalmente válido, não pode ser considerado sólido. Entretanto, suas premissas descritivas são majoritariamente verdadeiras:\n\nA definição de fusão nuclear como combinação de núcleos leves é cientificamente precisa.\nA produção de calor e seu potencial energético são verdadeiros.\nA fusão nuclear realmente alimenta o sol.\n\n\n\n\n5.9.3 Exemplo 3: Economia Global (2023)\n“As economias avançadas devem desacelerar de 2,6% em 2022 para 1,5% em 2023 e 1,4% em 2024, à medida que o aperto da política começa a surtir efeito. A inflação global deverá diminuir constantemente, de 8,7% em 2022 para 6,9% em 2023 e 5,8% em 2024, devido a uma política monetária mais rígida auxiliada por preços mais baixos das commodities internacionais.”\n\n5.9.3.1 Premissas e Conclusão\nPremissas:\n\nO aperto da política (monetária) está começando a surtir efeito;\nEstá sendo implementada uma política monetária mais rígida;\nOs preços das commodities internacionais estão mais baixos.\n\nConclusões:\n\nAs economias avançadas devem desacelerar de \\(2,6\\%\\) em 2022 para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\nA inflação global deverá diminuir constantemente, de \\(8,7\\%\\) em 2022 para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\n\n\n5.9.3.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): O aperto da política monetária está surtindo efeito;\n\\(Q\\): Está sendo implementada uma política monetária mais rígida;\n\\(R\\): Os preços das commodities internacionais estão mais baixos;\n\\(S\\): As economias avançadas desacelerarão para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\n\\(T\\): A inflação global diminuirá para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\nEstrutura do argumento: \\((P \\wedge Q \\wedge R) \\rightarrow (S \\wedge T)\\)\nLógica de Predicados:\n\n\\(ApertoSurteEfeito(x)\\): o aperto da política monetária \\(x\\) está surtindo efeito;\n\\(PoliticaRigida(x)\\): \\(x\\) é uma política monetária rígida;\n\\(PrecosBaixos(x)\\): os preços de \\(x\\) estão baixos;\n\\(Desacelerar(x, y, z)\\): a economia \\(x\\) desacelerará para taxa \\(y\\) no ano \\(z\\);\n\\(DiminuirInflacao(x, y, z)\\): a inflação \\(x\\) diminuirá para taxa \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(ApertoSurteEfeito(\\text{\"política monetária\"})\\);\n\\(PoliticaRigida(\\text{\"política monetária atual\"})\\);\n\\(PrecosBaixos(\\text{\"commodities internacionais\"})\\);\n\\([ApertoSurteEfeito(\\text{\"política monetária\"}) \\wedge PoliticaRigida(\\text{\"política monetária atual\"})] \\rightarrow Desacelerar(\\text{\"economias avançadas\"}, 1.5\\%, 2023) \\wedge Desacelerar(\\text{\"economias avançadas\"}, 1.4\\%, 2024)\\);\n\\([PoliticaRigida(\\text{\"política monetária atual\"}) \\wedge PrecosBaixos(\\text{\"commodities internacionais\"})] \\rightarrow DiminuirInflacao(\\text{\"global\"}, 6.9\\%, 2023) \\wedge DiminuirInflacao(\\text{\"global\"}, 5.8\\%, 2024)\\).\n\n\n\n5.9.3.3 Análise da Validade\nEste argumento segue uma estrutura causal que pode ser analisada pela forma lógica:\n\nSe \\(X\\) causa \\(Y\\), e \\(X\\) está ocorrendo, então \\(Y\\) ocorrerá;\n\\(X\\) está ocorrendo;\nPortanto, \\(Y\\) ocorrerá.\n\nEsta estrutura segue o padrão de modus ponens, que é uma forma de argumento válida.\n\n\n5.9.3.4 Análise da Solidez\nA validade lógica do argumento foi estabelecida, mas sua solidez depende da veracidade das premissas:\n\nA eficácia do aperto monetário é uma afirmação empírica que requer verificação com dados econômicos;\nA implementação de política monetária mais rígida era geralmente verdadeira no contexto de 2023;\nA afirmação sobre preços mais baixos de commodities depende do período específico e das commodities consideradas.\n\nAs conclusões são previsões específicas cuja solidez dependeria da veracidade das premissas, da robustez dos modelos econômicos e da ausência de fatores externos imprevistos.\nEm economia, relações causais são geralmente probabilísticas, tornando a solidez do argumento contingente a condições específicas.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#exercícios-de-análise-de-argumentos-lógicos",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#exercícios-de-análise-de-argumentos-lógicos",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.10 Exercícios de Análise de Argumentos Lógicos",
    "text": "5.10 Exercícios de Análise de Argumentos Lógicos\nObjetivo: aplicar técnicas de Lógica Proposicional e de predicados para analisar descrições e especificações de sistemas computacionais, traduzindo-as para a linguagem formal e avaliando sua consistência lógica como base para decisões de implementação.\nDescrição: na engenharia de software, especificações e requisitos de sistemas são frequentemente descritos em linguagem natural, o que pode levar a ambiguidades, inconsistências e interpretações equivocadas. A análise lógica formal dessas descrições pode ajudar a identificar tais problemas e proporcionar uma base sólida para o desenvolvimento de soluções computacionais. Nesta tarefa, você atuará como “Arquiteto Lógico de Sistemas” para traduzir especificações em linguagem natural para modelos lógicos formais.\n\n5.10.1 Exercício 1: Sistema de Autenticação Biométrica\nFragmento de Texto Original: O sistema de autenticação biométrica deve permitir o acesso a usuários autorizados por meio de reconhecimento facial ou impressão digital. Se um usuário não conseguir autenticar por nenhum dos métodos biométricos, o sistema deve oferecer como alternativa a autenticação por senha. Caso ocorram três tentativas falhas consecutivas por qualquer método, o acesso do usuário deve ser temporariamente bloqueado por 30 minutos por motivos de segurança.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nUsuários autorizados podem se autenticar por reconhecimento facial;\nUsuários autorizados podem se autenticar por impressão digital;\nSe a autenticação biométrica falhar, o usuário pode usar senha;\nTrês tentativas falhas consecutivas levam ao bloqueio temporário;\nO bloqueio temporário dura 30 minutos.\n\nConclusões:\n\nO sistema deve bloquear o acesso após três tentativas falhas consecutivas;\nO sistema deve permitir múltiplos métodos de autenticação.\n\n\n5.10.1.1 Formalização Lógica\nLógica Proposicional:\n\n\\(A\\): O usuário está autorizado;\n\\(F\\): O usuário autentica com reconhecimento facial;\n\\(D\\): O usuário autentica com impressão digital;\n\\(S\\): O usuário autentica com senha;\n\\(T\\): Ocorreram três tentativas falhas consecutivas;\n\\(B\\): O acesso do usuário está bloqueado temporariamente.\n\nEstrutura do argumento:\n\n\\(A \\rightarrow (F \\vee D \\vee S)\\);\n\\(\\neg(F \\vee D) \\rightarrow S\\);\n\\(T \\rightarrow B\\).\n\nLógica de Predicados:\n\n\\(Usuario(x)\\): \\(x\\) é um usuário;\n\\(Autorizado(x)\\): \\(x\\) é autorizado;\n\\(AutenticaFacial(x)\\): \\(x\\) autentica por reconhecimento facial;\n\\(AutenticaDigital(x)\\): \\(x\\) autentica por impressão digital;\n\\(AutenticaSenha(x)\\): \\(x\\) autentica por senha;\n\\(TentativasFalhas(x, n)\\): \\(x\\) teve \\(n\\) tentativas falhas consecutivas;\n\\(Bloqueado(x, t)\\): \\(x\\) está bloqueado por \\(t\\) minutos.\n\nFormalização:\n\n\\(\\forall x [Autorizado(x) \\rightarrow (AutenticaFacial(x) \\vee AutenticaDigital(x) \\vee AutenticaSenha(x))]\\);\n\\(\\forall x [(Usuario(x) \\wedge \\neg(AutenticaFacial(x) \\vee AutenticaDigital(x))) \\rightarrow AutenticaSenha(x)]\\);\n\\(\\forall x [TentativasFalhas(x, 3) \\rightarrow Bloqueado(x, 30)]\\).\n\nAnálise da Validade: o argumento é válido em termos de Lógica Proposicional e de predicados. A estrutura segue formas lógicas válidas:\n\nA primeira relação estabelece uma disjunção inclusiva (OR) de métodos de autenticação disponíveis para usuários autorizados;\nA segunda relação segue a forma \\((P \\wedge \\neg Q) \\rightarrow R\\), que é válida: se um usuário não consegue autenticar pelos métodos biométricos, então deve poder usar senha;\nA terceira relação segue a forma \\(P \\rightarrow Q\\), um modus ponens: se ocorrerem três tentativas falhas, então o bloqueio é implementado.\n\nAnálise da Solidez:\nAs premissas são razoáveis no contexto de sistemas de autenticação modernos:\n\nA disponibilidade de múltiplos métodos de autenticação aumenta a usabilidade;\nA provisão de métodos alternativos quando os biométricos falham é uma prática comum;\nO bloqueio após múltiplas tentativas falhas é um mecanismo de segurança padrão.\n\nAs conclusões derivadas são sólidas no contexto de sistemas de autenticação e seguem práticas recomendadas de segurança digital.\n\n\n\n5.10.2 Exercício 2: Processamento de Pagamentos Online\nFragmento de Texto Original: O sistema de pagamentos online deve processar transações com cartões de crédito, cartões de débito e carteiras digitais. Quando uma transação é iniciada, o sistema verifica primeiro se há fundos suficientes. Se houver fundos suficientes, o sistema realiza a verificação de segurança. Uma transação só é aprovada se ambas as verificações forem bem-sucedidas. Caso contrário, a transação é rejeitada e o cliente recebe uma notificação com o motivo da falha.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema processa transações com cartões de crédito, cartões de débito e carteiras digitais;\nQuando uma transação é iniciada, o sistema verifica a disponibilidade de fundos;\nSe há fundos suficientes, o sistema realiza verificação de segurança;\nUma transação é aprovada apenas se as verificações de fundos e segurança forem bem-sucedidas;\nTransações rejeitadas geram notificações com o motivo da falha.\n\nConclusão:\n\nSe uma verificação de fundos ou segurança falhar, a transação será rejeitada.\n\n\n5.10.2.1 Formalização Lógica\nLógica Proposicional:\n\n\\(C\\): A transação é com cartão de crédito;\n\\(D\\): A transação é com cartão de débito;\n\\(W\\): A transação é com carteira digital;\n\\(F\\): Há fundos suficientes;\n\\(S\\): A verificação de segurança é bem-sucedida;\n\\(A\\): A transação é aprovada;\n\\(R\\): A transação é rejeitada;\n\\(N\\): O cliente recebe notificação.\n\nEstrutura do argumento:\n\n\\((C \\vee D \\vee W)\\) (A transação é feita por um dos métodos aceitos);\n\\(F \\rightarrow S\\) (Se há fundos, realiza-se verificação de segurança);\n\\((F \\wedge S) \\rightarrow A\\) (Se há fundos e a verificação de segurança é bem-sucedida, a transação é aprovada);\n\\(\\neg(F \\wedge S) \\rightarrow (R \\wedge N)\\) (Se não há fundos ou a verificação falha, a transação é rejeitada e há notificação).\n\nLógica de Predicados:\n\n\\(Transacao(x)\\): \\(x\\) é uma transação;\n\\(Metodo(x, y)\\): a transação \\(x\\) utiliza o método de pagamento \\(y\\);\n\\(TemFundos(x)\\): a transação \\(x\\) tem fundos suficientes;\n\\(VerificacaoSeguranca(x)\\): a transação \\(x\\) passa na verificação de segurança;\n\\(Aprovada(x)\\): a transação \\(x\\) é aprovada;\n\\(Rejeitada(x)\\): a transação \\(x\\) é rejeitada;\n\\(Notifica(x, y)\\): o sistema notifica o cliente sobre \\(y\\) relacionado à transação \\(x\\).\n\nFormalização:\n\n\\(\\forall x [Transacao(x) \\rightarrow (Metodo(x, \\text{\"crédito\"}) \\vee Metodo(x, \\text{\"débito\"}) \\vee Metodo(x, \\text{\"carteira digital\"}))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (TemFundos(x) \\rightarrow VerificacaoSeguranca(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow ((TemFundos(x) \\wedge VerificacaoSeguranca(x)) \\rightarrow Aprovada(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (\\neg(TemFundos(x) \\wedge VerificacaoSeguranca(x)) \\rightarrow (Rejeitada(x) \\wedge \\exists y Notifica(x, y)))]\\).\n\nAnálise da Validade:\nO argumento é válido logicamente. As relações causais seguem formas lógicas consistentes:\n\nA primeira premissa estabelece os métodos de pagamento aceitos, formando uma disjunção inclusiva;\nA relação entre verificação de fundos e verificação de segurança segue um fluxo condicional válido;\nA aprovação da transação requer a conjunção (AND) de condições, seguindo o padrão \\((P \\wedge Q) \\rightarrow R\\);\nA rejeição da transação ocorre pela negação da conjunção, usando a lei de De Morgan: \\(\\neg(P \\wedge Q) \\equiv \\neg P \\vee \\neg Q\\);\n\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de processamento de pagamentos:\n\nOs métodos de pagamento mencionados são comuns em sistemas reais;\nA verificação de fundos antes de processamento é uma prática padrão;\nAs verificações de segurança são essenciais em transações financeiras;\nA notificação em caso de falha é uma boa prática para experiência do usuário.\n\nA conclusão derivada é sólida e consistente com o funcionamento esperado de um sistema de pagamentos seguro e funcional.\n\n\n\n5.10.3 Exercício 3: Sistema de Gerenciamento de Estoque\nFragmento de Texto Original: “O sistema de gerenciamento de estoque deve monitorar continuamente os níveis de produtos. Quando o estoque de um produto cai abaixo do limite mínimo configurado, o sistema deve gerar automaticamente uma ordem de reabastecimento. Se o produto estiver marcado como ‘crítico’, a ordem deve ser enviada com prioridade alta. Caso contrário, a ordem segue o fluxo padrão. Qualquer produto que não tenha movimento de venda por mais de 90 dias deve ser marcado para revisão de demanda.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema monitora continuamente os níveis de estoque dos produtos;\nExiste um limite mínimo configurado para cada produto;\nOrdens de reabastecimento são geradas quando o estoque cai abaixo do limite mínimo;\nProdutos podem ser marcados como ‘críticos’;\nProdutos críticos recebem prioridade alta no reabastecimento;\nProdutos sem movimento de venda por mais de 90 dias são marcados para revisão.\n\nConclusões:\n\nSe o estoque de um produto cai abaixo do limite e o produto é crítico, uma ordem de reabastecimento com prioridade alta é gerada;\nSe o estoque de um produto cai abaixo do limite e o produto não é crítico, uma ordem de reabastecimento padrão é gerada;\nSe um produto não tem vendas por mais de 90 dias, ele deve ser revisado.\n\n\n5.10.3.1 Formalização Lógica\nLógica Proposicional:\n\n\\(M\\): O sistema monitora os níveis de estoque;\n\\(B\\): O estoque está abaixo do limite mínimo;\n\\(O\\): Uma ordem de reabastecimento é gerada;\n\\(C\\): O produto é marcado como crítico;\n\\(P\\): A ordem é enviada com prioridade alta;\n\\(F\\): A ordem segue fluxo padrão;\n\\(N\\): O produto não tem movimento de venda por mais de 90 dias;\n\\(R\\): O produto é marcado para revisão de demanda.\n\nEstrutura do argumento:\n\n\\(M\\);\n\\(B \\rightarrow O\\);\n\\((B \\wedge C) \\rightarrow (O \\wedge P)\\);\n\\((B \\wedge \\neg C) \\rightarrow (O \\wedge F)\\);\n\\(N \\rightarrow R\\).\n\nLógica de Predicados:\n\n\\(Produto(x)\\): \\(x\\) é um produto;\n\\(Monitora(x)\\): o sistema monitora o estoque de \\(x\\);\n\\(AbaixoLimite(x)\\): o estoque de \\(x\\) está abaixo do limite mínimo;\n\\(Critico(x)\\): \\(x\\) é marcado como crítico;\n\\(GeraOrdem(x, y)\\): o sistema gera uma ordem de reabastecimento para \\(x\\) com prioridade \\(y\\);\n\\(SemVendas(x, d)\\): \\(x\\) não tem vendas por \\(d\\) dias;\n\\(MarcarRevisao(x)\\): \\(x\\) é marcado para revisão de demanda.\n\nFormalização:\n\n\\(\\forall x [Produto(x) \\rightarrow Monitora(x)]\\);\n\\(\\forall x [Produto(x) \\wedge AbaixoLimite(x) \\rightarrow \\exists y \\, GeraOrdem(x, y)]\\);\n\\(\\forall x [Produto(x) \\wedge AbaixoLimite(x) \\wedge Critico(x) \\rightarrow GeraOrdem(x, \\text{\"alta\"})]\\);\n\\(\\forall x [Produto(x) \\wedge AbaixoLimite(x) \\wedge \\neg Critico(x) \\rightarrow GeraOrdem(x, \\text{\"normal\"})]\\);\n\\(\\forall x [Produto(x) \\wedge SemVendas(x, 90) \\rightarrow MarcarRevisao(x)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura segue padrões lógicos consistentes:\n\nA relação entre níveis de estoque e geração de ordens segue um modus ponens;\nA distinção entre produtos críticos e não críticos usa corretamente a conjunção e a negação;\nA condição para revisão de demanda segue uma implicação simples.\n\nAs regras de negócio são representadas por condicionais bem formados, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de gerenciamento de estoque:\n\nO monitoramento contínuo de estoque é uma funcionalidade essencial desses sistemas;\nO conceito de limite mínimo para reabastecimento é uma prática comum;\nA priorização de produtos críticos é uma estratégia logística válida;\nA revisão de produtos sem movimentação é uma prática de otimização de estoque reconhecida.\n\nAs conclusões derivadas são sólidas e refletem procedimentos operacionais padrão em gerenciamento de estoque e logística.\n\n\n\n5.10.4 Exercício 4: Sistema de Recomendação de Conteúdo\n“O sistema de recomendação deve analisar o histórico de visualizações, preferências explícitas e comportamento de navegação de cada usuário. Com base nesses dados, o sistema calcula um score de relevância para cada item de conteúdo disponível. Itens com score acima de 0,7 são recomendados ao usuário. No entanto, se o usuário já visualizou um item nos últimos 30 dias, este não deve ser recomendado novamente, independentemente do score. Adicionalmente, se o usuário deu um feedback negativo a um conteúdo similar, o score desse tipo de conteúdo deve ser reduzido em 0,3 pontos.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas: 1. O sistema analisa o histórico de visualizações, preferências explícitas e comportamento de navegação. 2. Um score de relevância é calculado para cada item de conteúdo. 3. Itens com score acima de 0,7 são recomendados. 4. Itens visualizados nos últimos 30 dias não são recomendados, independentemente do score. 5. Feedback negativo a conteúdo similar reduz o score em 0,3 pontos.\nConclusões: - Um item será recomendado se seu score for maior que 0,7 E não tiver sido visualizado nos últimos 30 dias. - O feedback negativo do usuário influencia o cálculo do score para itens similares.\n\n5.10.4.1 Formalização Lógica\nLógica Proposicional:\n\n\\(A\\): O sistema analisa dados do usuário.\n\\(C\\): O sistema calcula scores de relevância.\n\\(S\\): O item tem score acima de 0,7.\n\\(V\\): O item foi visualizado nos últimos 30 dias.\n\\(R\\): O item é recomendado ao usuário.\n\\(F\\): O usuário deu feedback negativo a conteúdo similar.\n\\(D\\): O score é reduzido em 0,3 pontos.\n\nEstrutura do argumento:\n\n\\(A \\rightarrow C\\)\n\\((S \\wedge \\neg V) \\rightarrow R\\)\n\\(V \\rightarrow \\neg R\\)\n\\(F \\rightarrow D\\)\n\nLógica de Predicados:\n\n\\(Usuario(u)\\): u é um usuário;\n\\(Item(i)\\): i é um item de conteúdo;\n\\(AnalisaDados(u)\\): o sistema analisa dados do usuário u;\n\\(Score(i, s)\\): o item i tem score s;\n\\(Visualizado(u, i, d)\\): o usuário u visualizou o item i nos últimos d dias;\n\\(Recomendado(u, i)\\): o item i é recomendado ao usuário u;\n\\(FeedbackNegativo(u, t)\\): o usuário u deu feedback negativo ao tipo de conteúdo t;\n\\(Similar(i, t)\\): o item i é similar ao tipo de conteúdo t;\n\\(ReducaoScore(i, v)\\): o score do item i é reduzido em v pontos.\n\nFormalização:\n\n\\(\\forall u [Usuario(u) \\rightarrow AnalisaDados(u)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\wedge Item(i) \\wedge Score(i, s) \\wedge s &gt; 0.7 \\wedge \\neg Visualizado(u, i, 30) \\rightarrow Recomendado(u, i)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\wedge Item(i) \\wedge Visualizado(u, i, 30) \\rightarrow \\neg Recomendado(u, i)]\\);\n\\(\\forall u \\forall i \\forall t [Usuario(u) \\wedge Item(i) \\wedge Similar(i, t) \\wedge FeedbackNegativo(u, t) \\rightarrow ReducaoScore(i, 0.3)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. As regras de recomendação seguem formas lógicas bem definidas:\n\nA relação entre análise de dados e cálculo de scores é uma implicação simples;\nA condição para recomendação usa corretamente a conjunção entre score alto e não visualização recente;\nA exclusão de itens já visualizados é uma implicação direta;\nA redução de score baseada em feedback é uma relação causal válida.\n\nA estrutura lógica representa adequadamente as regras condicionais do sistema de recomendação.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de recomendação modernos:\n\nA utilização de histórico, preferências e comportamento de navegação é uma prática padrão;\nO uso de scores de relevância é uma abordagem quantitativa comum;\nA prevenção de recomendações repetitivas é uma boa prática de experiência do usuário;\nA consideração de feedback negativo reflete sistemas adaptativos reais.\n\nAs conclusões derivadas são sólidas e representam um sistema de recomendação funcional que equilibra relevância, novidade e preferências do usuário.\n\n\n\n5.10.5 Exercício 5: Sistema de Detecção de Fraudes\nFragmento Texto Original: “O sistema de detecção de fraudes deve analisar cada transação em tempo real. Uma transação é marcada como suspeita se atender a pelo menos um dos seguintes critérios: valor acima do padrão histórico do cliente, localização geográfica incomum, ou múltiplas tentativas em curto período de tempo. Se dois ou mais critérios forem atendidos simultaneamente, a transação é automaticamente bloqueada e enviada para revisão manual. Caso contrário, se apenas um critério for atendido, o cliente recebe uma notificação de confirmação. Se o cliente não confirmar em 5 minutos, a transação é bloqueada preventivamente”.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema analisa cada transação em tempo real;\nCritérios de suspeita: valor acima do padrão, localização incomum, múltiplas tentativas;\nUma transação é suspeita se atende a pelo menos um dos critérios;\nUma transação é automaticamente bloqueada se atende a dois ou mais critérios;\nSe apenas um critério for atendido, o cliente recebe notificação para confirmação;\nSe não houver confirmação em 5 minutos, a transação é bloqueada.\n\nConclusões:\n\nSe múltiplos critérios de suspeita são atendidos, a transação é bloqueada sem intervenção do cliente;\nSe um único critério é atendido, a transação depende de confirmação do cliente;\nToda transação suspeita é ou bloqueada automaticamente ou requer confirmação.\n\n\n5.10.5.1 Formalização Lógica\nLógica Proposicional:\n\n\\(R\\): O sistema analisa transações em tempo real;\n\\(V\\): A transação tem valor acima do padrão histórico;\n\\(L\\): A transação ocorre em localização geográfica incomum;\n\\(M\\): Há múltiplas tentativas em curto período;\n\\(S\\): A transação é marcada como suspeita;\n\\(B\\): A transação é bloqueada automaticamente;\n\\(N\\): O cliente recebe notificação de confirmação;\n\\(C\\): O cliente confirma a transação em 5 minutos;\n\\(P\\): A transação é bloqueada preventivamente.\n\nEstrutura do argumento:\n\n\\((V \\vee L \\vee M) \\rightarrow S\\);\n\\([(V \\wedge L) \\vee (V \\wedge M) \\vee (L \\wedge M)] \\rightarrow B\\);\n\\([S \\wedge \\neg((V \\wedge L) \\vee (V \\wedge M) \\vee (L \\wedge M))] \\rightarrow N\\);\n\\((N \\wedge \\neg C) \\rightarrow P\\).\n\nLógica de Predicados:\n\n\\(Transacao(t)\\): \\(t\\) é uma transação;\n\\(AnalisaTempoReal(t)\\): a transação \\(t\\) é analisada em tempo real;\n\\(ValorAlto(t)\\): a transação \\(t\\) tem valor acima do padrão histórico;\n\\(LocalizacaoIncomum(t)\\): a transação \\(t\\) ocorre em localização incomum;\n\\(MultiplasTentativas(t)\\): há múltiplas tentativas para a transação \\(t\\);\n\\(Suspeita(t)\\): a transação \\(t\\) é marcada como suspeita;\n\\(Bloqueada(t)\\): a transação \\(t\\) é bloqueada automaticamente;\n\\(EnviaNotificacao(t)\\): uma notificação é enviada para confirmar \\(t\\);\n\\(Confirma(t, m)\\): a transação \\(t\\) é confirmada dentro de m minutos;\n\\(BloqueioPreventivo(t)\\): a transação \\(t\\) recebe bloqueio preventivo.\n\nFormalização:\n\n\\(\\forall t [Transacao(t) \\rightarrow AnalisaTempoReal(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge (ValorAlto(t) \\vee LocalizacaoIncomum(t) \\vee MultiplasTentativas(t)) \\rightarrow Suspeita(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge ((ValorAlto(t) \\wedge LocalizacaoIncomum(t)) \\vee (ValorAlto(t) \\wedge MultiplasTentativas(t)) \\vee (LocalizacaoIncomum(t) \\wedge MultiplasTentativas(t))) \\rightarrow Bloqueada(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge Suspeita(t) \\wedge \\neg((ValorAlto(t) \\wedge LocalizacaoIncomum(t)) \\vee (ValorAlto(t) \\wedge MultiplasTentativas(t)) \\vee (LocalizacaoIncomum(t) \\wedge MultiplasTentativas(t))) \\rightarrow EnviaNotificacao(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge EnviaNotificacao(t) \\wedge \\neg Confirma(t, 5) \\rightarrow BloqueioPreventivo(t)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura representa corretamente o processo de decisão do sistema:\n\nA definição de transação suspeita usa uma disjunção (\\(OR\\)) adequada;\nA condição para bloqueio automático usa corretamente conjunções (\\(AND\\)) para representar a combinação de critérios;\nA notificação em caso de suspeita única é representada por uma conjunção com uma negação de múltiplos critérios;\nO bloqueio preventivo após falta de confirmação segue uma implicação lógica válida.\n\nO sistema de regras é coerente, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de detecção de fraudes:\n\nA análise em tempo real é essencial para sistemas antifraude eficazes;\nOs critérios mencionados são indicadores comuns de atividades potencialmente fraudulentas;\nA escalação baseada na quantidade de indicadores segue práticas reais de segurança;\nO envolvimento do cliente para confirmação é uma prática que equilibra segurança e usabilidade;\nO tempo limite para confirmação é uma medida preventiva razoável.\n\nAs conclusões derivadas são sólidas e representam um sistema de detecção de fraudes que equilibra detecção automática, envolvimento do cliente e proteção preventiva.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html",
    "href": "04-logica-predicativa-e-quantificadores.html",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "",
    "text": "6.1 Introdução aos Predicados\nUm predicado é como uma luneta que nos permite observar as propriedades de uma entidade. Um conjunto de lentes por meio do qual podemos ver se uma entidade particular possui ou não uma característica específica. A palavra predicado foi importada do campo da linguística e tem o mesmo significado: qualidade; característica. Por exemplo, ao observar o universo das letras por meio do telescópio do predicado ser uma vogal, percebemos que algumas entidades deste conjunto, como \\(a\\) e \\(e\\), possuem essa propriedade, enquanto outras, como \\(b\\) e \\(c\\), não.\nUm predicado não é uma afirmação absoluta de verdade ou falsidade. Divergindo das proposições, os predicados não são declarações completas. Pense neles como aquelas sentenças com espaços em branco, aguardando para serem preenchidos, que só têm sentido completo quando preenchidas:\nPreencha as lacunas, como quiser desde que faça sentido, e perceba que, em cada caso, ao preencher estamos atribuindo uma qualidade a um objeto. Esses são exemplos de predicados do nosso cotidiano, que sinteticamente o conceito que queremos abordar. Na lógica, os predicados são artefatos que possibilitam examinar o mundo ao nosso redor de forma organizada e exata.\nUm predicado pode ser entendido como uma função que recebe um objeto (ou um conjunto de objetos) e retorna um valor de verdade, \\(\\{\\text{TRUE, FALSE}\\}\\). Esta função descreve uma propriedade que o objeto pode possuir. Isto é, se \\(P\\) é uma função \\(P: u \\rightarrow \\{\\text{TRUE, FALSE}\\}\\) para um determinado conjunto $ u$ qualquer. Esse conjunto $ u$ é chamado de universo ou domínio do discurso, e dizemos que \\(P\\) é um predicado sobre $ u$.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#introdução-aos-predicados",
    "href": "04-logica-predicativa-e-quantificadores.html#introdução-aos-predicados",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "",
    "text": "O _______ está saboroso;\nO _______ é vermelho;\n_______ é alto.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#universo-do-discurso",
    "href": "04-logica-predicativa-e-quantificadores.html#universo-do-discurso",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.2 Universo do Discurso",
    "text": "6.2 Universo do Discurso\nO universo do discurso, \\(u\\), também chamado de universo, ou domínio, é o conjunto de objetos de interesse em um determinado cenário lógico para uma análise específica. O universo do discurso é importante porque as proposições na Lógica de Predicados serão declarações sobre objetos de um universo.\nO universo, \\(u\\), é o domínio das variáveis das nossas Fórmulas Bem Formadas. O universo do discurso pode ser o conjunto dos números reais, \\(\\mathbb{R}\\), o conjunto dos inteiros, \\(\\mathbb{Z}\\), o conjunto de todos os alunos em uma sala de aula que usam camisa amarela, ou qualquer outro conjunto que definamos. Na prática, o universo costuma ser deixado implícito e deveria ser óbvio a partir do contexto. Se não for o caso, precisa ser explicitado.\nSe estamos interessados em proposições sobre números naturais, \\(\\mathbb{N}\\), o universo do discurso é o conjunto \\(\\mathbb{N} = \\{0, 1, 2, 3,...\\}\\), um conjunto infinito. Já se estamos interessados em proposições sobre alunos de uma sala de aula, o universo do discurso poderia ser o conjunto $ u = {, , …}$, um conjunto finito.\nPara que este conceito fique mais claro, suponha que temos um conjunto de números \\(u = \\{1, 2, 3, 4, 5\\}\\) e um predicado \\(P(x)\\), que dizemos unário por ter um, e somente um, argumento, que afirma x é par. Ao aplicarmos este predicado a cada elemento do universo \\(u\\), obtemos um conjunto de valores verdade:\n\\[\n\\begin{align}\n&P(1) = \\text{FALSE};\\\\\n&P(2) = \\text{TRUE};\\\\\n&P(3) = \\text{FALSE};\\\\\n&P(4) = \\text{TRUE};\\\\\n&P(5) = \\text{FALSE}.\n\\end{align}\n\\]\nVemos que o predicado \\(P(u)\\) dado por u é par é uma propriedade que alguns números do conjunto $ u$ Possuem, e outros não. Vale notar que na Lógica Predicativa, a função que define um predicado pode ter múltiplos argumentos. Por exemplo, podemos ter um predicado \\(Q(x, y)\\) que afirma x é maior que y. Neste caso, o predicado \\(Q\\) é uma função de dois argumentos que retorna um valor de verdade. Dizemos que \\(Q(x, y)\\) é um predicado binário. Exemplos nos conduzem ao caminho do entendimento:\n\nExemplo 1:\n\nUniverso do discurso: \\(u = \\text{conjunto de todas as pessoas}\\).\nPredicado: \\(P(x) = \\{ x : x \\text{ é um matemático} \\}\\);\nItens para os quais \\(P(x)\\) é verdadeiro: Carl Gauss, Leonhard Euler, John Von Neumann.\n\nExemplo 2:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{Z} : x \\text{ é par}\\}\\)\nPredicado: \\(Q(x) = (x &gt; 5)\\);\nItens para os quais \\(Q(x)\\) é verdadeiro: $6 $, $8 $, \\(10 ...\\).\n\nExemplo 3:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{R} : x &gt; 0 \\text{ e } x &lt; 10\\}\\)\nPredicado: \\(R(x) = (x^2 - 4 = 0)\\);\nItens para os quais \\(R(x)\\) é verdadeiro: \\(2\\) (note que \\(-2\\) não pertence ao universo do discurso definido).\n\nExemplo 4:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{N} : x \\text{ é um múltiplo de } 3\\}\\)\nPredicado: \\(S(x) = (\\text{mod}(x, 2) = 0)\\);\nItens para os quais \\(S(x)\\) é verdadeiro: \\(6\\), \\(12\\), $18 $.\n\nExemplo 5:\n\nUniverso do discurso: \\(u = \\{(x, y) \\in \\mathbb{R}^2 : x \\neq y\\}\\)\nPredicado: \\(P(x, y) = (x &lt; y)\\);\nItens para os quais \\(P(x, y)\\) é verdadeiro: \\((1, 2)\\), \\((3, 4)\\), \\((5, 6)\\).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#entendendo-predicados",
    "href": "04-logica-predicativa-e-quantificadores.html#entendendo-predicados",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.3 Entendendo Predicados",
    "text": "6.3 Entendendo Predicados\nA aridade do predicado, número de argumentos, é limitado pela análise lógica que estamos fazendo. Considere um predicado ternário, \\(R\\), dado por x está entre y e z. Quando substituímos \\(x\\), \\(y\\) e \\(z\\) por números específicos podemos validar a verdade do predicado \\(R\\). Vamos considerar alguns exemplos adicionais de predicados baseados na aritmética e defini-los com menos formalidade e mais legibilidade:\n\n\\(Primo(x)\\): o número inteiro positivo \\(x\\) é um número primo.\n\\(PotênciaDe(x, y)\\): o número inteiro \\(x\\) é uma potência exata de \\(y : x = y^z\\) para algum \\(z \\in \\mathbb{Z}, z \\geq 0\\).\n\\(somaDeDoisPrimos(x)\\): o número inteiro positivo \\(x\\) é igual à soma de dois números primos.\n\nEm 1, 2 e 3 os predicados estão definidos com mnemônicos aumentando a legibilidade e melhorando nossa capacidade de manter o universo implícito. O uso de predicados, e da Lógica Proposicional, permite a escrita de sentenças menos ambíguas para a definição de conceitos lógicos em formato matemático. Por exemplo: se \\(x\\) é um ancestral de \\(y\\) e \\(y\\) é um ancestral de \\(z\\) então \\(x\\) é um ancestral de \\(z\\); que, se consideramos o predicado \\(ancestralDe\\) Pode ser escrito como \\(ancestralDe (x,y) \\wedge ancestralDe(y,z) \\rightarrow ancestralDe(x,z)\\). Ainda assim, falta alguma coisa. Algo que permita aplicar os predicados a um conjunto de elementos dentro do universo do discurso. É aqui que entram os quantificadores.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.4 Quantificadores",
    "text": "6.4 Quantificadores\nEmbora a Lógica Proposicional seja um bom ponto de partida, a maioria das afirmações interessantes em matemática contêm variáveis definidas em domínios maiores do que apenas \\(\\{\\text{TRUE, FALSE}\\}\\). Por exemplo, a afirmação \\(x \\text{é uma potência de } 2\\) não é uma proposição. Não temos como definir a verdade dessa afirmação até conhecermos o valor de \\(x\\). Se \\(P(x)\\) é definido como a afirmação \\(x \\text{é uma potência de } 2\\), então \\(P(8)\\) é verdadeiro e \\(P(7)\\) é falso.\nPara termos uma linguagem lógica que seja suficientemente flexível para representar os problemas que encontramos no Universo real, o Universo em que vivemos, precisaremos ser capazes de dizer quando o predicado \\(P\\) ou \\(Q\\) é verdadeiro para valores diferentes em seus argumentos. Para tanto, vincularemos as variáveis aos predicados usando operadores para indicar quantidade, chamados de quantificadores.\nOs quantificadores indicam se a sentença que estamos criando se aplica a todos os valores possíveis do argumento, quantificação universal, ou se esta sentença se aplica a um valor específico, quantificação existencial. Usaremos esses quantificadores para fazer declarações sobre todos os elementos de um universo de discurso específico, ou para afirmar que existe pelo menos um elemento do universo do discurso que satisfaz uma determinada qualidade.\nVamos remover o véu da dúvida usando como recurso metafórico uma experiência humana, social, comum e popular: imaginemos estar em uma festa e o anfitrião lhe pede para verificar se todos os convidados têm algo para beber. Você, prestativo e simpático, começa a percorrer a sala, verificando cada pessoa. Se você encontrar pelo menos uma pessoa sem bebida, você pode imediatamente dizer nem todos têm bebidas. mas, se você verificar cada convidado e todos eles tiverem algo para beber, você pode dizer com confiança todos têm bebidas. Este é o conceito do quantificador universal, matematicamente representado por \\(\\forall\\), que lemos como para todo.\nA festa continua e o anfitrião quer saber se alguém na festa está bebendo champanhe. Desta vez, assim que você encontrar uma pessoa com champanhe, você pode responder imediatamente sim, alguém está bebendo champanhe. Você não precisa verificar todo mundo para ter a resposta correta. Este é o conceito do quantificador existencial, denotado por \\(\\exists\\), que lemos existe algum.\nOs quantificadores nos permitem fazer declarações gerais, ou específicas, sobre os membros de um universo de discurso, de uma forma que seria difícil, ou impossível, sem estes operadores especiais.\n\n6.4.1 Quantificador Universal\nO quantificador universal \\(\\forall\\), lê-se para todo, indica que uma afirmação deve ser verdadeira para todos os valores de uma variável dentro de um universo de discurso definido para a criação de uma sentença contendo um predicado qualquer. Por exemplo, a proposição clássica todos os humanos são mortais pode ser escrita como \\(\\forall x Humano(x) \\rightarrow Mortal(x)\\). Ou recorrendo a um exemplo com mais de rigor matemático, teríamos o predicado se \\(x\\) é positivo então \\(x + 1\\) é positivo, que pode ser escrito \\(\\forall x (x &gt; 0 \\rightarrow x + 1 &gt; 0)\\). Neste último exemplo temos Quantificadores, Lógica Predicativa, Lógica Proposicional e Teoria dos Conjuntos em uma sentença.\nO quantificador universal pode ser representado usando apenas a Lógica Proposicional, com uma pequena trapaça. A afirmação \\(\\forall x P(x)\\) é, de certa forma, a operação \\(\\wedge\\), AND aplicada a todos os elementos do universo do discurso. Ou seja, o predicado:\n\\[\\forall x (x \\in \\mathbb{N} \\rightarrow P(x))\\]\nPode ser escrito como:\n\\[P(0) \\wedge P(1) \\wedge P(2) \\wedge P(3) \\wedge \\ldots\\]\nAssim, \\(P(0), P(1), P(2), P(3) \\ldots\\) representam a aplicação do predicado \\(P\\) a todos os elementos \\(x\\) do conjunto \\(\\mathbb{N}\\). A trapaça fica por conta de que, em Lógica Proposicional, não podemos escrever expressões com um número infinito de termos. Portanto, a expansão em conjunções de um predicado \\(P\\) em um Universo de Discurso, \\(u\\), não é uma Fórmula Bem Formada se a cardinalidade de \\(u\\) for infinita. De qualquer forma, podemos usar esta interpretação informal para entender o significado de \\(\\forall x P(x)\\).\nA representação do Quantificador Universal como uma conjunção não é uma Fórmula Bem Formada** a não ser que o Universo do Discurso seja não infinito. Neste caso, teremos uma conjunção que chamaremos de Conjunção Universal:\n\\[\\forall x (P(x) \\wedge Q(x))\\]\nIsso significa que para todo \\(x\\) no domínio, as propriedades \\(P\\), \\(Q\\), e outras listadas são todas verdadeiras. É uma forma de expressar que todas as condições listadas são verdadeiras para cada elemento no domínio. Esta fórmula será usada para simplificar sentenças, ou para criar formas normais.\nVamos voltar um pouco. O quantificador universal \\(\\forall x P(x)\\) afirma que a proposição \\(P(x)\\) é verdadeira para todo, e qualquer, valor possível de \\(x\\) como elemento de um conjunto, \\(u\\). Uma forma de interpretar isso é pensar em \\(x\\) como uma variável que pode ter qualquer valor dentro do universo do discurso.\nPara validar \\(\\forall x P(x)\\) escolhemos o pior caso possível para \\(x\\), todos os valores que suspeitamos possa fazer \\(P(x)\\) falso. Se conseguirmos provar que \\(P(x)\\) é verdadeira nestes casos específicos, então \\(\\forall x P(x)\\) deve ser verdadeira. Novamente, vamos recorrer a exemplos na esperança de explicitar este conceito.\nExemplo 1: todos os números reais são maiores que 0. (Universo do discurso: \\(\\{x \\in \\mathbb{R}\\}\\))\n\\[\\forall x (x \\in \\mathbb{R} \\rightarrow x &gt; 0)\\]\n\nObserve que este predicado, apesar de estar corretamente representado, é \\(Falso\\).\n\nExemplo 2: todos os triângulos em um plano euclidiano têm a soma dos ângulos internos igual a 180 graus. (Universo do discurso: \\(x\\) é um triângulo em um plano euclidiano)\n\\[\\forall x (Triângulo(x) \\rightarrow \\Sigma_{i=1}^3 ÂnguloInterno_i(x) = 180^\\circ)\\]\nExemplo 3: todas as pessoas com mais de 18 anos podem tirar carteira de motorista.” (Universo do discurso: \\(x\\) é uma pessoa no Brasil)\n\\[\\forall x (Pessoa(x) \\wedge Idade (x) \\geq 18 \\rightarrow PodeTirarCarteira(x))\\]\nExemplo 4: todo número par maior que 2 pode ser escrito como a soma de dois números primos. (Universo do discurso: \\(\\{x \\in \\mathbb{Z}\\}\\)\n\\[\\forall x\\,(Par(x) \\wedge x &gt; 2 \\rightarrow \\exists u\\exists v\\, (Primo(u) \\wedge Primo(v) \\wedge x = u + v))\\]\nExemplo 5: para todo número natural, se ele é múltiplo de 4 e múltiplo de 6, então ele também é múltiplo de 12. (Universo do discurso: \\(\\{x \\in \\mathbb{N}\\}\\))\n\\[\\forall x\\,((\\exists u\\in\\Bbb N\\,(x = 4u) \\wedge \\exists v\\in\\Bbb N\\,(x = 6v)) \\rightarrow \\exists w\\in\\Bbb N\\,(x = 12w))\\]\nO quantificador universal nos permite definir uma Fórmula Bem Formada representando todos os elementos de um conjunto, um universo do discurso, em relação a uma qualidade específica, um predicado. Esta é um artefato lógico interessante, mas não suficiente.\nUsamos, preferencialmente, a implicação, \\(\\to\\), com o quantificador universal, \\(\\forall\\), para indicar que uma propriedade vale para todos os elementos de um domínio, Porque permite afirmar que para todo \\(x\\), se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. Isso permite que \\(P(x)\\) seja falsa para alguns \\(x\\), mas a implicação como um todo permanece verdadeira. Ou, em outras palavras, quando usamos uma implicação, como \\(P(x) \\rightarrow Q(x)\\), estamos dizendo que se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. A implicação é uma forma lógica que permite conectar duas proposições, em que a veracidade de \\(Q(x)\\) depende da veracidade de \\(P(x)\\).\nImportante: A implicação \\(P(x) \\rightarrow Q(x)\\) é considerada verdadeira em qualquer dos seguintes casos:\n\\(P(x)\\) é verdadeira e \\(Q(x)\\) é verdadeira. \\(P(x)\\) é falsa, independentemente de \\(Q(x)\\). O ponto-chave é o segundo caso: se \\(P(x)\\) for falsa, a implicação \\(P(x) \\rightarrow Q(x)\\) ainda é verdadeira, não importa o valor de \\(Q(x)\\).\nEssa preferência não é arbitrária, mas baseada nas limitações que os outros conectivos apresentam quando combinados com o quantificador universal. Porém, uma análise de todos os operadores pode ser interessante para sedimentar os conceitos.\nComecemos com a conjunção. Quando usamos \\(\\forall x(P(x) ∧ Q(x))\\), estamos afirmando que para todo \\(x\\), tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiros. Isso é extremamente restritivo e raramente reflete situações do mundo real. Por exemplo, se disséssemos Todos os animais são mamíferos e podem voar, estaríamos fazendo uma afirmação falsa, pois nem todos os animais são mamíferos e nem todos podem voar. Outro exemplo seria Todos os números são pares e primos, o que é claramente falso, pois nenhum número (exceto 2) satisfaz ambas as condições simultaneamente.\nA disjunção, por outro lado, é muito fraca quando combinada com o quantificador universal. \\(\\forall x(P(x) ∨ Q(x))\\) afirma que para todo \\(x\\), ou \\(P(x)\\) ou \\(Q(x)\\) (ou ambos) são verdadeiros. Isso geralmente não captura relações condicionais úteis. Por exemplo, Todo número é par ou ímpar é uma afirmação verdadeira, mas não nos diz muito sobre a relação entre paridade e números. Da mesma forma, Toda pessoa é alta ou baixa é uma afirmação de tal amplitude que se torna quase sem sentido, pois não fornece informações úteis sobre a altura das pessoas.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador universal também apresenta problemas. \\(\\forall x(P(x) \\leftrightarrow Q(x))\\) afirma que para todo \\(x\\), \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso é uma condição muito forte e raramente é satisfeita em situações reais. Por exemplo, Um número é par se e somente se é divisível por 4 é falso, pois há números pares que não são divisíveis por \\(4\\) (como \\(2\\) e \\(6\\)). Outro exemplo seria Uma pessoa é feliz se e somente se é rica, o que claramente não reflete a realidade complexa da felicidade e riqueza.\nPor outro lado, a implicação (\\(\\to\\)) oferece várias vantagens quando usada com o quantificador universal. \\(\\forall x(P(x) \\to Q(x))\\) nos permite expressar relações condicionais de forma mais flexível e precisa. Por exemplo, Para todo número, se é par, então não é primo (exceto 2) é uma afirmação verdadeira e informativa. Outro exemplo seria Para toda pessoa, se é médico, então tem formação universitária. Esta formulação permite exceções (pode haver pessoas com formação universitária que não são médicos) e captura uma regra geral de forma precisa.\nA implicação também tem a vantagem de ser verdadeira quando o antecedente (\\(P(x)\\)) é falso, o que é útil para expressar regras gerais. Por exemplo, em Para todo \\(x\\), se \\(x\\) é um quadrado perfeito, então \\(x\\) é positivo, a implicação é verdadeira mesmo para números negativos (que não são quadrados perfeitos), mantendo a regra geral válida.\nEspero que tenha ficado claro. A implicação, quando combinada com o quantificador universal, oferece um equilíbrio entre flexibilidade e precisão que os outros conectivos lógicos não conseguem alcançar. Ela permite expressar relações condicionais, acomoda exceções e captura regras gerais de forma mais eficaz, tornando-a a escolha preferida em muitas situações da lógica formal e da matemática.\n\n\n6.4.2 Quantificador Existencial\nO quantificador existencial, \\(\\exists\\) nos permite fazer afirmações sobre a existência de objetos com certas propriedades, sem precisarmos especificar exatamente quais objetos são esses. Vamos tentar remover os véus da dúvida com um exemplo simples.\nConsideremos a sentença: existem humanos mortais. Com um pouco mais de detalhe e matemática, podemos escrever isso como: existe pelo menos um \\(x\\) tal que \\(x\\) é humano e mortal. Para escrever a mesma sentença com precisão matemática teremos:\n\\[\\exists x \\text{Humano}(x) \\wedge \\text{Mortal}(x)\\]\nLendo por partes: existe um \\(x\\), tal que \\(x\\) é humano AND \\(x\\) é mortal. Em outras palavras, existe pelo menos um humano que é mortal.\nNote duas coisas importantes:\n\nNós não precisamos dizer exatamente quem é esse humano mortal. Só afirmamos que existe um. O operador \\(\\exists\\) captura essa ideia.\nUsamos AND (\\(\\wedge\\)), não implicação (\\(\\rightarrow\\)). Se usássemos \\(\\rightarrow\\), a afirmação ficaria muito mais fraca. Veja:\n\n\\[\\exists x \\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\]\nQue pode ser lido como: existe um \\(x\\) tal que, SE \\(x\\) é humano, ENTÃO \\(x\\) é mortal. Essa afirmação é verdadeira em qualquer universo que contenha um unicórnio de bolinhas roxas imortal. Porque o unicórnio não é humano. neste caso, o predicado \\(\\text{Humano}(\\text{unicórnio})\\) é falso, e a implicação \\(\\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\) é verdadeira.\nPortanto, é importante usar o operador \\(\\wedge\\), e não \\(\\rightarrow\\) quando trabalhamos com quantificadores existenciais. O \\(\\wedge\\) garante que a propriedade se aplica ao objeto existente definido pelo \\(\\exists\\). Contudo, podemos melhorar um pouco isso:\nA conjunção, \\(\\wedge\\), é frequentemente empregada com o quantificador existencial, \\(\\exists\\), para expressar a presença de ao menos um elemento em determinado conjunto que possui múltiplas características simultaneamente. Isso nos possibilita declarar que há no mínimo um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são válidas. Tal afirmação confirma a existência de pelo menos um elemento que atende a ambos os critérios. Dito de outra forma, ao utilizarmos uma conjunção, como em \\(P(x) \\wedge Q(x)\\), estamos afirmando que existe ao menos um \\(x\\) em que \\(P(x)\\) é verdadeiro e, ao mesmo tempo, \\(Q(x)\\) também o é. A conjunção funciona como um operador lógico que une duas proposições, em que a validade da asserção existencial depende da ocorrência simultânea de \\(P(x)\\) e \\(Q(x)\\) para, no mínimo, um \\(x\\).\nNo contexto do quantificador existencial \\(\\exists x\\), a conjunção \\(P(x) \\wedge Q(x)\\) é tida como verdadeira se, e apenas se houver ao menos um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiras. Caso não exista tal \\(x\\), a afirmação existencial é considerada falsa.\nObserve que basta a existência de um único elemento satisfazendo ambas as condições para validar a afirmação existencial.\nEsta predileção não é fortuita, mas fundamentada na aptidão da conjunção em expressar com exatidão a existência de elementos dotados de múltiplos atributos concomitantes. No entanto, uma avaliação dos demais operadores pode ser proveitosa para consolidar esses conceitos.\nIniciemos com a implicação. Ao empregarmos \\(\\exists x(P(x) \\to Q(x))\\), declaramos a existência de ao menos um \\(x\\) tal que, se \\(P(x)\\) for verdadeiro, então \\(Q(x)\\) também o será. Esta formulação é menos elucidativa que a conjunção no âmbito existencial, pois seria verdadeira mesmo se \\(P(x)\\) fosse falso para todo \\(x\\). Ilustrando: Há um número que, se for ímpar, é múltiplo de 2 é verdadeiro (pois é válido para números pares), mas não esclarece se realmente existe um número ímpar que é múltiplo de 2.\nA disjunção aliada ao quantificador existencial, \\(\\exists x(P(x) \\vee Q(x))\\), assevera a existência de pelo menos um \\(x\\) que satisfaz \\(P(x)\\) ou \\(Q(x)\\) (ou ambos). Embora útil em certos contextos, geralmente é menos robusta que a conjunção para afirmar a existência de elementos com múltiplas propriedades. Por exemplo: Existe um número que é negativo ou racional é verdadeiro, mas não nos informa se há um número que é ambos.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador existencial também pode ser problemática. \\(\\exists x(P(x) \\leftrightarrow Q(x))\\) afirma a existência de ao menos um \\(x\\) para o qual \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso pode ser útil em alguns casos, mas frequentemente é mais restritivo do que o necessário. Por exemplo: Existe um número que é positivo se e somente se é inteiro é verdadeiro (o número 1 satisfaz isso), mas não captura a existência de números que são apenas positivos ou apenas inteiros.\nEm contrapartida, a conjunção (\\(\\wedge\\)) apresenta diversas vantagens quando utilizada com o quantificador existencial. \\(\\exists x(P(x) \\wedge Q(x))\\) nos permite afirmar a existência de elementos que possuem múltiplas propriedades simultaneamente. Por exemplo: Existe um número que é positivo e par é uma afirmação verdadeira e informativa (o número 2 satisfaz ambas as condições). Outro exemplo seria Existe uma substância que é líquida e condutora de eletricidade. Esta formulação afirma claramente a existência de substâncias com ambas as características.\nA conjunção também tem a vantagem de ser falsa quando não há elementos que satisfaçam ambas as condições, o que é útil para expressar a inexistência de certos tipos de elementos. Por exemplo: Existe um número que é natural e negativo simultaneamente é falso, indicando corretamente que não há tais números.\nEm suma, a conjunção, quando associada ao quantificador existencial, proporciona um meio preciso e informativo de expressar a existência de elementos com múltiplos atributos. Ela permite afirmar a presença de elementos que atendem a condições simultâneas, tornando-se a opção preferencial em diversas situações da lógica formal e da matemática quando se trata de asserções existenciais.\nAssim como o quantificador universal, \\(\\forall\\), o quantificador existencial, \\(\\exists\\) , também pode ser restrito a um universo específico, usando a notação de pertencimento:\n\\[\\exists x (x \\in \\mathbb{Z} \\wedge x = x^2)\\]\nEsta sentença afirma a existência de pelo menos um inteiro \\(x\\) tal que \\(x\\) é igual ao seu quadrado. Novamente, não precisamos dizer qual é esse inteiro, apenas que ele existe dentro do conjunto dos inteiros. A resposta é sim: tanto \\(x = 0\\) quanto \\(x = 1\\) satisfazem a equação \\(x = x^2\\).\nDe forma geral, o quantificador existencial serve para fazer afirmações elegantes sobre a existência de objetos com certas qualidades, sem necessariamente conhecermos ou elencarmos todos esses objetos. Isso agrega mais qualidade a representação do mundo real que podemos fazer com a Lógica de Primeira Ordem.\nTalvez, alguns exemplos possam ajudar no seu entendimento:\nExemplo 1: existe um animal que é vertebrado e não é mamífero.\n\\[\\exists x (Vertebrado(x) \\wedge \\neg Mamífero(x))\\]\nExemplo 2: existe uma equação do segundo grau com exatamente uma raiz real.\n\\[\\exists x (\\text{Eq2Grau}(x) \\wedge |\\text{RaízesReais}(x)| = 1)\\]\nExemplo 3: existe um número primo que é par.\n\\[\\exists x (Primo(x) \\wedge Par(x))\\]\nExemplo 4: existe um quadrado perfeito que pode ser escrito como o quadrado de um número racional.\n\\[\\exists x (QuadPerfeito(x) \\wedge \\exists u \\in \\mathbb{Q} \\ (x = u^2))\\]\nExemplo 5: existe um polígono convexo em que a soma dos ângulos internos não é igual a \\((n-2) \\cdot 180°\\), de tal forma que \\(n\\) é o número de lados desse polígono.\nPara expressar isso corretamente em lógica de primeira ordem, precisamos relacionar o número de lados com o polígono específico:\n\\[\\exists x (PolígonoConvexo(x) \\land \\exists n (NumLados(x, n) \\land SomaÂngulosInternos(x) \\neq (n-2) \\cdot 180°))\\]\nAlternativamente, podemos usar uma notação mais explícita:\n\\[\\exists x (PolígonoConvexo(x) \\land \\exists n (NumLados(x, n) \\land \\sum_{i=1}^{n} ÂnguloInterno_i(x) \\neq (n-2) \\cdot 180°))\\]\nA atenta leitora deve notar que este predicado é falso. Existe um teorema da geometria euclidiana que afirma que todos os polígonos convexos com \\(n\\) lados têm a soma dos ângulos internos exatamente igual a \\((n-2) \\cdot 180°\\).\nA atenta leitora deve observar também que a variável \\(n\\) está apropriadamente quantificada, com \\(\\exists n\\), e explicitamente relacionada ao polígono \\(x\\) por meio do predicado \\(NumLados(x, n)\\).\nExemplo de instanciação:\n\nPara um triângulo (\\(n = 3\\)): soma = \\((3-2) \\cdot 180° = 180°\\);\nPara um quadrilátero (\\(n = 4\\)): soma = \\((4-2) \\cdot 180° = 360°\\);\nPara um pentágono (\\(n = 5\\)): soma = \\((5-2) \\cdot 180° = 540°\\).\n\nEm todos os casos, a fórmula da soma é satisfeita, tornando nossa afirmação existencial falsa.\n\n\n6.4.3 Clarificação sobre o Uso de Operadores com Quantificadores\nEmbora seja verdade que frequentemente usamos implicação (\\(\\rightarrow\\)) com o quantificador universal (\\(\\forall\\)) e conjunção (\\(\\wedge\\)) com o quantificador existencial (\\(\\exists\\)), é importante esclarecer que estas são preferências contextuais, não regras absolutas. Há situações específicas nas quasi outras combinações são não apenas apropriadas, mas necessárias para expressar corretamente o significado desejado. A curiosa leitora deve considerar as seguintes situações:\n\n6.4.3.1 1. Quantificador Universal com Conjunção (\\(\\forall\\) com \\(\\wedge\\))\nUso apropriado: Quando queremos afirmar que todos os elementos de um conjunto possuem múltiplas propriedades simultaneamente.\nExemplo: “Todos os números primos maiores que 2 são ímpares e indivisíveis por 4” \\[\\forall x ((Primo(x) \\wedge x &gt; 2) \\rightarrow (Impar(x) \\wedge \\neg DivisívelPor4(x)))\\]\nNote que aqui usamos \\(\\wedge\\) tanto no antecedente quanto no consequente da implicação com \\(\\forall\\).\n\n\n6.4.3.2 2. Quantificador Existencial com Implicação (\\(\\exists\\) com \\(\\rightarrow\\))\nUso apropriado: Quando queremos afirmar a existência de elementos que satisfazem uma relação condicional.\nExemplo: “Existe um número tal que, se ele é par, então é maior que 10” \\[\\exists x (Par(x) \\rightarrow x &gt; 10)\\]\nEsta fórmula é verdadeira (por exemplo, \\(x = 12\\) ou qualquer número ímpar satisfaz a condição).\n\n\n6.4.3.3 3. Quantificador Universal com Disjunção (\\(\\forall\\) com \\(\\vee\\))\nUso apropriado: Para expressar propriedades alternativas que todos os elementos devem satisfazer.\nExemplo: “Todo número inteiro é positivo, negativo ou zero” \\[\\forall x (x \\in \\mathbb{Z} \\rightarrow (Positivo(x) \\vee Negativo(x) \\vee Zero(x)))\\]\n\n\n6.4.3.4 4. Quantificador Existencial com Bicondicional (\\(\\exists\\) com \\(\\leftrightarrow\\))\nUso apropriado: Para afirmar a existência de elementos que satisfazem uma equivalência.\nExemplo: “Existe um número que é primo se e somente se é ímpar” \\[\\exists x (Primo(x) \\leftrightarrow Impar(x))\\]\n(Verdadeiro para \\(x = 3\\), \\(5\\), \\(7\\), etc., mas falso para \\(x = 2\\) ou \\(x = 9\\))\n\n\n6.4.3.5 Diretrizes Práticas\nRegra geral para escolher o operador correto:\n\nCom \\(\\forall\\):\n\nUse \\(\\rightarrow\\) quando estiver restringindo o domínio (“para todos os \\(X\\) que satisfazem \\(P...\\)”);\nUse \\(\\wedge\\) quando estiver afirmando múltiplas propriedades sobre todo o domínio;\nUse \\(\\vee\\) quando todo elemento deve satisfazer pelo menos uma de várias condições.\n\nCom \\(\\exists\\):\n\nUse \\(\\wedge\\) quando procurar elementos que satisfazem todas as propriedades listadas;\nUse \\(\\vee\\) quando procurar elementos que satisfazem pelo menos uma propriedade;\nUse \\(\\rightarrow\\) quando a existência envolver uma condição condicional.\n\n\n\n6.4.3.5.1 Exemplo Comparativo\nConsidere a diferença entre estas duas afirmações sobre um sistema de banco de dados:\nAfirmação A: “Todos os usuários ativos têm senha” \\[\\forall x (UsuarioAtivo(x) \\rightarrow TemSenha(x))\\]\nAfirmação B: “Todos os usuários são ativos e têm senha” \\[\\forall x (Usuario(x) \\rightarrow (UsuarioAtivo(x) \\wedge TemSenha(x)))\\]\nA Afirmação A permite usuários inativos sem senha, enquanto a Afirmação B exige que todos os usuários sejam ativos e tenham senha - uma restrição muito mais forte.\nA escolha do operador lógico deve ser guiada pelo significado preciso que queremos expressar, não por uma regra mecânica. As preferências mencionadas (implicação com \\(\\forall\\) e conjunção com \\(\\exists\\)) são padrões comuns que funcionam bem em muitos contextos, mas a lógica de primeira ordem é rica o suficiente para requerer todas as combinações possíveis em diferentes situações.\nExiste uma regra de segurança que a esforçada leitora deve seguir: sempre traduza a fórmula de volta para linguagem natural para verificar se ela captura exatamente o significado pretendido. Se houver discrepância, reconsidere a escolha dos operadores.\n\n\n\n\n6.4.4 Equivalências Interessantes\nEstudando o quantificador universal encontramos duas equivalências interessantes:\n\\[\\lnot \\forall x P(x) \\leftrightarrow \\exists x \\lnot P(x)\\]\n\\[\\lnot \\exists x P(x) \\leftrightarrow \\forall x \\lnot P(x)\\]\nEssas equivalências são essencialmente as versões quantificadas das Leis de De Morgan. A primeira diz que nem todos os humanos são mortais, isso é equivalente a encontrar algum humano que não é mortal. A segunda diz que para mostrar que nenhum humano é mortal, temos que mostrar que todos os humanos não são mortais.\nPodemos representar uma declaração \\(\\exists x P(x)\\) como uma expressão OU. Por exemplo, \\(\\exists x (x \\in \\mathbb{N} \\wedge P(x))\\) poderia ser reescrito como:\n\\[P(0) \\vee P(1) \\vee P(2) \\vee P(3) \\vee \\ldots \\]\nLembrando do problema que encontramos quando fizemos isso com o quantificador $$: não podemos representar fórmulas sem fim em Lógica de Primeira Ordem. mas, novamente esta notação, ainda que inválida, nos permite entender melhor o quantificador existencial. Caso o Universo do Discurso seja finito, limitado e contável, teremos a Disjunção Existencial uma expressão na Lógica de Primeira Ordem que afirma que existe pelo menos um elemento em um domínio que satisfaz uma ou mais propriedades. A forma geral de uma disjunção existencial é:\n\\[\\exists x (P(x) \\vee Q(x))\\]\nIsso significa que existe pelo menos um \\(x\\) no domínio que satisfaz a propriedade \\(P\\), ou a propriedade \\(Q\\), ou ambas, ou outras propriedades listadas. É uma forma de expressar que pelo menos uma das condições listadas é verdadeira para algum elemento no domínio.\nA expansão de $$ usando $$ destaca que a proposição \\(P(x)\\) é verdadeira se pelo menos um valor de \\(x\\) dentro do universo do discurso atender ao predicado \\(P\\). O que a expansão de exemplo está dizendo é que existe pelo menos um número natural \\(x\\) tal que \\(P(x)\\) é verdadeiro. Não precisamos saber exatamente qual é esse \\(x\\). Apenas que existe um elemento dentro de \\(\\mathbb{N}\\) que atende o predicado.\nO quantificador existencial não especifica o objeto dentro do universo determinado. Esse operador permite fazer afirmações elegantes sobre a existência de objetos com certas características, certas qualidades, ou ainda, certos predicados, sem necessariamente conhecermos exatamente quais são esses objetos.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#dos-predicados-à-linguagem-natural",
    "href": "04-logica-predicativa-e-quantificadores.html#dos-predicados-à-linguagem-natural",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.5 Dos Predicados à Linguagem Natural",
    "text": "6.5 Dos Predicados à Linguagem Natural\nAo ler uma Fórmula Bem Formada contendo quantificadores, a ordem da leitura é geralmente da esquerda para a direita. A interpretação precisa, no entanto, depende diretamente da ordem e do tipo dos quantificadores.\nPor exemplo, \\(\\forall x\\) pode ser lido como “para todo objeto \\(x\\) no universo do discurso (em que este objeto está implícito), o seguinte se mantém”. Já o quantificador \\(\\exists x\\) pode ser lido como “existe um objeto \\(x\\) no universo que satisfaz o seguinte” ou “para algum objeto \\(x\\) no universo, o seguinte se mantém”.\nConverter uma Fórmula Bem Formada em uma sentença fluida em linguagem natural nem sempre é direto, mas é um passo valioso para a compreensão. Vamos considerar \\(U\\) como o universo do discurso (o conjunto de todos os aviões já fabricados) e \\(F(x,y)\\) como o predicado que denota “\\(x\\) voa mais rápido que \\(y\\)”. Analisemos algumas combinações de quantificadores:\n\n\\(\\forall x \\forall y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), e para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação é muito forte. Ela diz que cada avião no universo é mais rápido que todos os aviões no universo (incluindo ele mesmo, a menos que \\(F(x,x)\\) seja definido como falso ou que se adicione \\(x \\neq y\\)). Se o universo tiver mais de um avião, esta afirmação provavelmente será falsa, pois implicaria, por exemplo, que \\(A\\) é mais rápido que \\(B\\) e \\(B\\) é mais rápido que \\(A\\) simultaneamente.\n\n\\(\\exists x \\forall y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) tal que, para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que existe pelo menos um avião que é mais rápido que todos os outros (e, novamente, dependendo da definição de \\(F(x,x)\\), mais rápido que ele mesmo). Em outras palavras, existe um “avião mais rápido absoluto”.\n\n\\(\\forall x \\exists y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que para qualquer avião que escolhermos, podemos encontrar algum avião \\(y\\) que é mais lento que \\(x\\). Se \\(y\\) pode ser igual a \\(x\\), a afirmação é trivialmente verdadeira se \\(F(x,x)\\) for verdadeiro para algum \\(x\\). Se \\(y\\) deve ser diferente de \\(x\\), isso significaria que não existe um “avião mais lento absoluto” (a menos que o universo seja finito e ordenado de forma cíclica, ou que \\(F(x,y)\\) permita que \\(x\\) seja mais rápido que “nada” se \\(y\\) for o mais lento). Uma interpretação comum é que, para cada avião, há outro que ele supera em velocidade.\n\n\\(\\exists x \\exists y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) e existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta é a afirmação mais fraca entre as quatro. Ela simplesmente diz que a relação “voa mais rápido que” não é vazia; ou seja, há pelo menos um par de aviões \\((x,y)\\) em que \\(x\\) é mais rápido que \\(y\\).\n\n\nÉ fundamental perceber que estas quatro sentenças têm significados lógicos distintos e geralmente não expressam o mesmo contexto. A ordem dos quantificadores, especialmente quando misturamos \\(\\forall\\) e \\(\\exists\\), altera drasticamente o significado da afirmação. Por exemplo, \\(\\exists x \\forall y F(x,y)\\) (existe um avião mais rápido que todos) é uma afirmação muito mais forte e diferente de \\(\\forall x \\exists y F(x,y)\\) (para cada avião, existe um mais lento).\nAo traduzir da lógica para a linguagem natural ou vice-versa, a precisão na interpretação da ordem e do tipo dos quantificadores é essencial. A prática leva a uma maior fluidez nesse processo de tradução e compreensão.\n\n6.5.1 Exercícios Resolvidos de Conversão de Linguagem Natural em Expressões Predicativas\nSentença 1: Todo matemático que é professor tem alunos que são brilhantes e interessados.\n\\[\n\\forall x ((\\text{Matemático}(x) \\wedge \\text{Professor}(x)) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Matemático}(x) \\rightarrow (\\text{Professor}(x) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y))))\n\\]\nSentença 2: Alguns engenheiros não são nem ricos nem felizes.\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg (\\text{Rico}(x) \\vee \\text{Feliz}(x)))\\]\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg\\text{Rico}(x) \\wedge \\neg\\text{Feliz}(x))\\]\nSentença 3: Todos os planetas que têm água possuem vida ou têm potencial para vida.\n\\[\n\\forall x (\\text{Planeta}(x) \\wedge \\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x)))\n\\]\n\\[\n\\forall x (\\text{Planeta}(x) \\rightarrow (\\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x))))\n\\]\nSentença 4: Nenhum cientista que é cético acredita em todos os mitos.\n\\[\n\\neg \\exists x (Cientista(x) \\wedge Cético(x) \\wedge \\forall y (Mito(y) \\rightarrow Acredita(x,y)))\n\\]\n\\[\n\\forall x ((\\text{Cientista}(x) \\wedge \\text{Cético}(x)) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Cientista}(x) \\rightarrow (\\text{Cético}(x) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y))))\n\\]\nSentença 5: Alguns filósofos que escrevem sobre ética também leem ou estudam psicologia.\n\\[\n\\exists x (\\text{Filósofo}(x) \\wedge \\text{EscreveSobreÉtica}(x) \\wedge (\\text{LêPsicologia}(x) \\vee \\text{EstudaPsicologia}(x)))\n\\]\nSentença 6: Para todo escritor, existe pelo menos um livro que ele escreveu e que é tanto criticado quanto admirado.\n\\[\n\\forall x (\\text{Escritor}(x) \\rightarrow \\exists y (\\text{Livro}(y) \\wedge \\text{Escreveu}(x, y) \\wedge \\text{Criticado}(y) \\wedge \\text{Admirado}(y)))\n\\]\nSentença 7: Todos os pássaros voam e todos os peixes nadam.\n\\[\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\wedge \\forall y (Peixe(y) \\rightarrow Nada(y))\\]\nSentença 8: Todos os estudantes estudam ou todos os professores ensinam.\n\\[\\forall x (Estudante(x) \\rightarrow Estuda(x)) \\vee \\forall y (Professor(y) \\rightarrow Ensina(y))\\]\nSentença 9: Todos os cães latem e todos os gatos miam, mas nem todos os animais fazem barulho.\n\\[\\forall x (Cão(x) \\rightarrow Late(x)) \\wedge \\forall y (Gato(y) \\rightarrow Mia(y)) \\wedge \\neg \\forall z (Animal(z) \\rightarrow FazBarulho(z))\\]\nSentença 10: Se todos os carros são vermelhos, então todos os caminhões são azuis.\n\\[\\forall x (Carro(x) \\rightarrow Vermelho(x)) \\rightarrow \\forall y (Caminhão(y) \\rightarrow Azul(y))\\]\nSentença 11: Todos os planetas orbitam uma estrela e todos os asteroides orbitam o sol.\n\\[\\forall x (Planeta(x) \\rightarrow OrbitaEstrela(x)) \\wedge \\forall y (Asteroide(y) \\rightarrow OrbitaSol(y))\\]\nSentença 12: Alguns pássaros não voam.\n\\[\\exists x (Pássaro(x) \\wedge \\neg Voa(x))\\]\nSentença 13: Existe pelo menos um estudante que não estuda.\n\\[\\exists x (Estudante(x) \\wedge \\neg Estuda(x))\\]\n\\[\\exists x (Estudante(x) \\wedge \\neg Estuda(x))\\]\nSentença 14: Há algum animal que não faz barulho.\n\\[\\exists x (Animal(x) \\wedge \\neg FazBarulho(x))\\]\nSentença 15: Existe um carro que não é vermelho.\n\\[\\exists x (Carro(x) \\wedge \\neg Vermelho(x))\\]\n\\[\\exists x (Carro(x) \\wedge \\neg Vermelho(x))\\]\nSentença 16: Há um planeta que não orbita uma estrela.\n$$\\exists x (Planeta(x) \\wedge \\neg \\exists y (Estrela(y) \\wedge Orbita(x, y)))$$\n\nOu \n\n$$\\exists x (Planeta(x) \\wedge \\forall y (Estrela(y) \\rightarrow \\neg Orbita(x, y)))$$ (Existe um planeta $x$ tal que, para toda estrela $y$, $x$ não a orbita).\nSentença 17: _Todos os pássaros voam, mas existe um animal que não voa.\n$$\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\wedge \\exists y (Animal(y) \\wedge \\neg Voa(y))$$\nSentença 18: Para cada estudante, existe um professor que o ensina.\n$$\\forall x (Estudante(x) \\rightarrow \\exists y (Professor(y) \\wedge Ensina(y, x)))$$\nSentença 19: Existe um cão que late para todos os gatos.\n$$\\exists x (Cão(x) \\wedge \\forall y (Gato(y) \\rightarrow Late(x, y)))$$\nSentença 20: Para cada carro vermelho, existe um caminhão azul.\n$$\\forall x (Carro(x) \\wedge Vermelho(x) \\rightarrow \\exists y (Caminhão(y) \\wedge Azul(y)))$$\nSentença 21: Todos os planetas orbitam uma estrela, e existe um asteroide que orbita o sol.\n$$(\\forall x (Planeta(x) \\rightarrow \\exists y (Estrela(y) \\wedge Orbita(x, y)))) \\wedge (\\exists z (Asteroide(z) \\wedge Orbita(z, Sol)))$$\n\n\n6.5.2 Exercícios Resolvidos de Conversão de Expressões Predicativas em Linguagem Natural\n1. Fórmula Lógica: \\(\\forall x (\\text{Humano}(x) \\rightarrow (\\text{Mortal}(x) \\wedge \\text{Racional}(x)))\\)\n\nPredicados:\n\n\\(Humano(x)\\): \\(x\\) é um humano.\n\\(Mortal(x)\\): \\(x\\) é mortal.\n\\(Racional(x)\\): \\(x\\) é racional.\n\nSentença em Português: Todo humano é mortal e racional.\n\n2. Fórmula Lógica:\\(\\exists y (\\text{Livro}(y) \\wedge (\\text{Interessante}(y) \\vee \\text{Complicado}(y)))\\)\n\nPredicados:\n\n\\(Livro(y)\\): y é um livro.\n\\(Interessante(y)\\): y é interessante.\n\\(Complicado(y)\\): y é complicado.\n\nSentença em Português: Existe pelo menos um livro que é interessante ou complicado.\n\n3. Fórmula Lógica:\\(\\forall x \\forall y (\\text{Amigos}(x, y) \\rightarrow (\\text{Confiável}(x) \\wedge \\text{Honra}(x, y)))\\)\n\nPredicados:\n\n\\(Amigos(x, y)\\): x é amigo de y.\n\\(Confiável(x)\\): x é confiável.\n\\(Honra(x, y)\\): x honra y.\n\nSentença em Português: Todo amigo de alguém é confiável e honra o amigo.\n\n4. Fórmula Lógica:\\(\\exists x \\exists y (\\text{Animal}(x) \\wedge \\text{Planta}(y) \\wedge \\text{Convive}(x, y))\\)\n\nPredicados:\n\n\\(Animal(x)\\): x é um animal.\n\\(Planta(y)\\): y é uma planta.\n\\(Convive(x, y)\\): x e y convivem.\n\nSentença em Português: Existe pelo menos um animal e uma planta que convivem no mesmo ambiente.\n\n5. Fórmula Lógica:\\(\\forall x \\exists y (\\text{Professor}(x) \\rightarrow (\\text{Disciplina}(y) \\wedge \\text{Leciona}(x, y)))\\)\n\nPredicados:\n\n\\(Professor(x)\\): x é um professor.\n\\(Disciplina(y)\\): y é uma disciplina.\n\\(Leciona(x, y)\\): x leciona y.\n\nSentença em Português: Para todo professor, existe pelo menos uma disciplina que ele leciona.\n\n6. Fórmula Lógica:$ x ((x) y ((y) (x, y))) $\n\nPredicados:\n\n\\(Músico(x)\\): x é um músico;\n\\(Instrumento(y)\\): y é um instrumento;\n\\(Toca(x, y)\\): x toca y.\n\nSentença em Português: Existe pelo menos um músico que, se algo é um instrumento, então ele toca esse instrumento. Ou, Existe um músico que toca todos os instrumentos.\n\n7. Fórmula Lógica: \\(\\forall x (Gato(x) \\rightarrow (Peludo(x) \\wedge Dorminhoco(x)))\\)\n\\[\\text{Todo gato é peludo e dorminhoco.}\\]\n8. Fórmula Lógica:\\(\\forall y (Árvore(y) \\rightarrow (Verde(y) \\wedge Grande(y)))\\)\n\\[\\text{Toda árvore é verde e grande.}\\]\n9. Fórmula Lógica: \\((\\forall x (Cidade(x) \\rightarrow Populosa(x))) \\rightarrow (\\forall y (País(y) \\rightarrow Populoso(y)))\\)\n\\[\\text{Se toda cidade é populosa, então todo país é populoso.}\\]\n10. Fórmula Lógica: \\(\\forall x (Criança(x) \\rightarrow (Inocente(x) \\wedge Curiosa(x))) \\wedge \\neg \\exists y (Adulto(y) \\wedge (Inocente(y) \\wedge Curioso(y)))\\)\n\\[\\text{Toda criança é inocente e curiosa, e não existe um adulto que seja inocente e curioso.}\\]\n11. Fórmula Lógica: \\(\\forall x (Ave(x) \\rightarrow Voa(x)) \\wedge \\forall y (Peixe(y) \\rightarrow Nada(y))\\)\n\\[\\text{Toda ave voa e todo peixe nada.}\\]\n12. Fórmula Lógica: \\(\\exists x (Pessoa(x) \\wedge Feliz(x))\\)\n\\[\\text{Existe uma pessoa que é feliz.}\\]\n13. Fórmula Lógica: \\(\\exists y (Livro(y) \\wedge Interessante(y) \\wedge \\neg Longo(y))\\)\n\\[\\text{Há um livro que é interessante e não é longo.}\\]\n14. Fórmula Lógica: \\(\\exists x (Estudante(x) \\wedge (\\forall y (Disciplina(y) \\rightarrow Gosta(x, y))))\\)\n\\[\\text{Existe um estudante que gosta de todas as disciplinas.}\\]\n15. Fórmula Lógica: \\(\\exists x (Carro(x) \\wedge Rápido(x)) \\wedge \\exists y (Carro(y) \\wedge \\neg Rápido(y))\\)\n\\[\\text{Existe um carro que é rápido, e existe um carro que não é rápido.}\\]\n16. Fórmula Lógica: \\(\\neg \\exists x (Político(x) \\wedge Honesto(x))\\)\n$$\\text{Não existe um político que seja honesto.}$$\n17. Fórmula Lógica: \\(\\forall x (Cachorro(x) \\rightarrow (\\exists y (Pessoa(y) \\wedge Dono(y, x))))\\)\n$$\\text{Todo cachorro tem uma pessoa que é seu dono.}$$\n18. Fórmula Lógica: \\(\\exists x (Música(x) \\wedge (\\forall y (Pessoa(y) \\rightarrow Gosta(y, x))))\\)\n$$\\text{Existe uma música que todas as pessoas gostam.}$$\n19. Fórmula Lógica: \\(\\forall x (Estudante(x) \\rightarrow (\\exists y (Professor(y) \\wedge Ensina(y, x))))\\)\n$$\\text{Para todo estudante, existe um professor que o ensina.}$$\n20. Fórmula Lógica: \\((\\exists x (Médico(x) \\wedge Competente(x))) \\wedge (\\forall y (Médico(y) \\rightarrow Ocupado(y)))\\)\n$$\\text{Existe um médico que é competente, e todo médico é ocupado.}$$\n21. Fórmula Lógica: \\[(\\forall x (Artista(x) \\rightarrow Criativo(x))) \\rightarrow (\\exists y (Pintor(y) \\wedge Criativo(y)))\\]\n$$\\text{Se todo artista é criativo, então existe um pintor que é criativo.}$$",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#ordem-de-aplicação-dos-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#ordem-de-aplicação-dos-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.6 Ordem de Aplicação dos Quantificadores",
    "text": "6.6 Ordem de Aplicação dos Quantificadores\nQuando mais de uma variável é quantificada em uma Fórmula Bem Formada como \\(\\forall y\\forall x P(x,y)\\), elas são aplicadas da esquerda para a direita. Assim, \\(\\forall y\\forall x P(x,y)\\) se lê para todo \\(y\\), para todo \\(x\\), \\(P(x,y)\\) se mantém.\nAs posições dos mesmos tipos de quantificadores podem ser trocadas sem afetar o valor lógico, desde que não haja quantificadores do outro tipo entre os que serão trocados.\nPor exemplo, \\(\\forall x\\forall y\\forall z P(x,y,z)\\) é equivalente a \\(\\forall y\\forall x\\forall z P(x,y,z)\\), \\(\\forall z\\forall y\\forall x P(x,y,z)\\). O mesmo vale para o quantificador existencial.\nNo entanto, as posições de quantificadores de tipos diferentes não podem ser trocadas. Por exemplo, \\(\\forall x\\exists y P(x,y)\\) não é equivalente A\\(\\exists y\\forall x P(x,y)\\). Por exemplo, seja \\(P(x,y)\\) representando \\(x &lt; y\\) Para o conjunto dos números como universo. Então, \\(\\forall x\\exists y P(x,y)\\) se lê para todo número \\(x\\), existe um número \\(y\\) que é maior que \\(x\\), o que é verdadeiro, enquanto \\(\\exists y\\forall x P(x,y)\\) se lê existe um número que é maior que todo (qualquer) número, o que não é verdadeiro.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#negação-dos-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#negação-dos-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.7 Negação dos Quantificadores",
    "text": "6.7 Negação dos Quantificadores\nExiste uma equivalência entre as negações dos quantificadores. De tal forma que:\n\nNegação do Quantificador Universal ($$): A negação de uma afirmação universal significa que existe pelo menos um caso no Universo do Discurso em que a afirmação não é verdadeira. Isso pode ser expresso pela seguinte equivalência:\n\\[\\neg \\forall x \\, P(x) \\equiv \\exists x \\, \\neg P(x)\\]\nEm linguagem natural podemos entender como: negar que para todos os \\(x\\), \\(P(x)\\) é verdadeiro é equivalente a afirmar que existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\nNegação do Quantificador Existencial ( $$ ): A negação de uma afirmação existencial significa que a afirmação não é verdadeira para nenhum caso no Universo do Discurso. Isso pode ser expresso pela seguinte equivalência:\n\n\\[\\neg \\exists x \\, P(x) \\equiv \\forall x \\, \\neg P(x)\\]\nOu seja, negar que existe algum \\(x\\) tal que \\(P(x)\\) é verdadeiro é equivalente a afirmar que para todos os \\(x\\), \\(P(x)\\) não é verdadeiro.\nVamos tentar entender estas negações. Considere as expressões \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Essas fórmulas se aplicam a qualquer predicado \\(P\\), e possuem o mesmo valor de verdade para qualquer \\(P\\).\nNa Lógica Proposicional, poderíamos simplesmente verificar isso com uma tabela verdade, mas aqui, não podemos. Não existem proposições, conectadas por $$, $$, para construir uma tabela e não é possível determinar o valor verdade de forma genérica para uma determinada variável.\nVamos tentar entender isso com linguagem natural: afirmar que \\(\\neg (\\forall x P(x))\\) é verdadeiro significa que não é verdade que \\(P(x)\\) se aplica a todas as possíveis entidades \\(x\\). Deve haver alguma entidade \\(A\\) Para a qual\\(P(a)\\) é falso. Como \\(P(a)\\) é falso, \\(\\neg P(a)\\) é verdadeiro. Isso significa que \\(\\exists x (\\neg P(x))\\) é verdadeiro. Portanto, a verdade de \\(\\neg (\\forall x P(x))\\)implica a verdade de \\(\\exists x (\\neg P(x))\\).\nSe \\(\\neg (\\forall x P(x))\\) é falso, então \\(\\forall x P(x)\\) é verdadeiro. Como \\(P(x)\\) é verdadeiro para todos os \\(x\\), \\(\\neg P(x)\\) é falso para todos os \\(x\\). Logo, \\(\\exists x (\\neg P(x))\\) é falso.\nOs valores de verdade de \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\) são os mesmos. Como isso é verdadeiro para qualquer predicado \\(P\\), essas duas fórmulas são logicamente equivalentes, e podemos escrever \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\).\nMuita lógica? Que tal se tentarmos novamente, usando um pouco mais de linguagem natural. Considere as expressões lógicas \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Para ilustrar essas fórmulas, vamos usar um exemplo com um predicado \\(P(x)\\) que se aplica a uma entidade \\(x\\) se \\(x\\) é feliz.\nA expressão \\(\\forall x P(x)\\) significa que todos são felizes. A negação dessa afirmação, \\(\\neg (\\forall x P(x))\\), equivale logicamente a \\(\\exists x (\\neg P(x))\\), ou seja, existe pelo menos um indivíduo que não é feliz.\nA expressão \\(\\exists x (\\neg P(x))\\) significa que existe alguém que não está feliz. Você pode ver que isso é apenas outra forma de expressar a ideia contida em \\(\\neg (\\forall x P(x))\\).\nA afirmação de que não é verdade que todos estão felizes implica que deve haver alguém que não está feliz. Se a primeira afirmação é falsa (ou seja, todos estão felizes), então a segunda afirmação também deve ser falsa.\nPortanto, as duas fórmulas têm o mesmo valor verdade. Elas são logicamente equivalentes e podem ser representadas como \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\). Esta equivalência reflete uma relação profunda e intuitiva em nosso entendimento de declarações sobre entidades em nosso mundo.\n\n\n\nExpressão\nEquivalência\n\n\n\n\n\\(\\forall x P(x)\\)\n\\(\\neg \\exists x \\neg P(x)\\)\n\n\n\\(\\exists x \\, P(x)\\)\n\\(\\neg \\forall x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\forall x \\, P(x)\\)\n\\(\\exists x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\exists x \\, P(x)\\)\n\\(\\forall x \\, \\neg P(x)\\)\n\n\n\nTabela 5 - Equivalências entre Quantificadores.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#regras-de-inferência-usando-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#regras-de-inferência-usando-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.8 Regras de Inferência usando Quantificadores",
    "text": "6.8 Regras de Inferência usando Quantificadores\nAs regras de inferência com quantificadores lidam especificamente com as proposições que envolvem quantificadores. Estas regras nos permitem fazer generalizações ou especificações, transformando proposições universais em existenciais, e vice-versa. Compreender essas regras é essencial para aprofundar o entendimento da estrutura da lógica, o que nos permite analisar e construir argumentos mais complexos de forma precisa e coerente.\nNos próximos tópicos, exploraremos essas regras em detalhes, observando como elas interagem com os quantificadores universal e existencial.\n\n6.8.1 Repetição\nA regra de Repetição permite repetir uma afirmação. Esta regra é útil para propagar premissas em uma prova formal.\n\\[F\\]\n\\[\n\\begin{aligned}\n&F\\\\\n\\hline\n&F\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: o céu está azul.\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações da Repetição:\n\nReafirmar premissas em provas longas. Por exemplo:\n\nProposição: todos os homens, \\(H(x)\\), são mortais, \\(M(x)\\).\nConclusão: logo, todos os homens são mortais.\n\n\n\\[\n\\begin{aligned}\n&\\forall x(H(x) \\rightarrow M(x))\\\\\n\\hline\n&\\forall x(H(x) \\rightarrow M(x))\n\\end{aligned}\n\\]\n\nIntroduzir suposições em provas indiretas. Por exemplo:\n\nProposição: suponha que \\((2 + 2 = 5)\\).\nConclusão: logo, (2 + 2 = 5)$.\n\n\n\\[\n\\begin{aligned}\n&2 + 2 = 5\\\\\n\\hline\n&2 + 2 = 5\n\\end{aligned}\n\\]\n\nReafirmar fórmulas quantificadas. Por exemplo:\n\nProposição: para todo \\(x\\), \\(x + 0 = x\\).\nConclusão: logo, para todo \\(x\\), \\(x + 0 = x\\).\n\n\n\\[\n\\begin{aligned}\n&\\forall x(x + 0 = x)\\\\\n\\hline\n&\\forall x(x + 0 = x)\n\\end{aligned}\n\\]\n\n\n6.8.2 Instanciação Universal\nA regra de Instanciação Universal permite substituir a variável em uma afirmação universalmente quantificada por um termo concreto. Esta regra nos permite derivar casos particulares a partir de afirmações gerais.\n\\[\\forall x P(x)\\]\n\\[\\begin{aligned}\n&\\forall x P(x)\\\\\n\\hline\n&P(a)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: todos os humanos são mortais.\nConclusão: logo, Sócrates é mortal. Assumindo que Sócrates é humano.\n\nExemplo completo de aplicação:\n\nPremissa 1: todos os mamíferos respiram ar: \\(\\forall x(M(x) \\rightarrow R(x))\\);\nPremissa 2: a baleia é um mamífero: \\(M(b)\\);\nAplicação da Instanciação Universal à Premissa 1: \\(M(b) \\rightarrow R(b)\\);\nAplicação de Modus Ponens:\n\n\\[\\begin{aligned}\n&M(b) \\rightarrow R(b)\\\\\n&M(b)\\\\\n\\hline\n&R(b)\n\\end{aligned}\n\\]\n\nConclusão: logo, a baleia respira ar: \\(R(b)\\)\n\nAlgumas aplicações da Instanciação Universal:\n\nAplicar regras e princípios gerais. Por exemplo:\n\nProposição: todos os triângulos têm 180 graus internos: \\(\\forall t(T(t) \\rightarrow 180^\\circ(t))\\);\nPremissa adicional: ABC é um triângulo: \\(T(\\text{Triângulo }ABC)\\);\nAplicação da Instanciação Universal: \\(T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\);\nAplicação de Modus Ponens:\n\n\n\\[\\begin{aligned}\n&T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\\\\n&T(\\text{Triângulo }ABC)\\\\\n\\hline\n&180^\\circ(\\text{Triângulo }ABC)\n\\end{aligned}\n\\]\n\nConclusão: logo, o triângulo \\(ABC\\) tem 180 graus.\nTestar propriedades em membros de conjuntos. Por exemplo:\n\nProposição: todo inteiro é maior que seu antecessor: \\(\\forall x (\\mathbb{Z}(x) \\rightarrow (x &gt; x-1))\\);\nPremissa adicional: 5 é um inteiro: \\(\\mathbb{Z}(5)\\);\nAplicação da Instanciação Universal: \\(\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\);\nAplicação de Modus Ponens:\n\n\n\\[\\begin{aligned}\n&\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\\\\n&\\mathbb{Z}(5)\\\\\n\\hline\n&5 &gt; 4\n\\end{aligned}\n\\]\n\nConclusão: logo, \\(5\\) é maior que \\(4\\).\n\n\n\n6.8.3 Generalização Existencial\nA regra de Generalização Existencial permite inferir que algo existe a partir de uma afirmação concreta. Esta regra nos permite generalizar de exemplos específicos para a existência geral.\n\\[P(a)\\]\n\\[\n\\begin{aligned}\nP(a)\\\\\n\\hline\n\\exists x P(x)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: Rex é um cachorro.\nConclusão: logo, existe pelo menos um cachorro.\n\nAlgumas aplicações da Generalização Existencial:\n\nInferir existência a partir de exemplos concretos. Por exemplo:\n\nProposição: o urânio-235 é radioativo.\nConclusão: logo, existe pelo menos um elemento químico radioativo.\n\n\n\\[\n\\begin{aligned}\n&R(u_{235})\\\\\n\\hline\n&\\exists x R(x)\n\\end{aligned}\n\\]\n\nConcluir que uma propriedade não é vazia. Por exemplo:\n\nProposição: $7 $ é um número primo.\nConclusão: logo, existe pelo menos um número primo.\n\n\n\\[\n\\begin{aligned}\n&P(7)\\\\\n\\hline\n&\\exists x P(x)\n\\end{aligned}\n\\]\n\nInferir a existência de soluções para problemas. Por exemplo:\n\nProposição: $x = 2 $ satisfaz a equação $x + 3 = 5 $.\nConclusão: logo, existe pelo menos uma solução para essa equação.\n\n\n\\[\n\\begin{aligned}\n&S(2)\\\\\n\\hline\n&\\exists x S(x)\n\\end{aligned}\n\\]\n\n\n6.8.4 Instanciação Existencial\nA regra de Instanciação Existencial permite introduzir um novo termo como instância de uma variável existencialmente quantificada. Esta regra nos permite derivar exemplos de afirmações existenciais.\n\\[\\exists x P(x)\\]\n\\[\n\\begin{aligned}\n&\\exists x P(x)\\\\\n\\hline\n&P(b)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: existe um cachorro com rabo curto.\nConclusão: logo, algum cachorro específico (que podemos chamar de \\(c\\)) tem rabo curto.\n\nAlgumas aplicações da Instanciação Existencial:\n\nDerivar exemplos de existência previamente estabelecida. Por exemplo:\n\nProposição: existem estrelas, $ e $, maiores, $M $, que o Sol, $s $.\nConclusão: logo, existe uma estrela específica, \\(c\\), que é maior que o Sol.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (e (x) \\wedge M(x, s))\\\\\n\\hline\n&e(c) \\wedge M(c, s)\n\\end{aligned}\n\\]\n\nConstruir modelos satisfatíveis para predicados existenciais. Por exemplo:\n\nProposição: existem pessoas mais velhas que \\(25\\) Anos.\nConclusão: logo, John tem 30 anos.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (P(x) \\wedge \\text{Idade}(x) &gt; 25)\\\\\n\\hline\n&P(c) \\wedge \\text{Idade}(c) &gt; 25 \\quad (\\text{para uma nova constante } c)\n\\end{aligned}\n\\]\n\nProvar que conjuntos não estão vazios. Por exemplo:\n\nProposição: existem números reais maiores que \\(2\\).\nConclusão: logo, \\(5\\) é um número real maior que \\(2\\).\n\n\n\\[\n\\begin{aligned}\n&\\exists x (R(x) \\wedge x &gt; 2)\\\\\n\\hline\n&R(d) \\wedge d &gt; 2 \\quad (\\text{para uma nova constante } d)\n\\end{aligned}\n\\]",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#exercícios-de-conexão-com-o-prolog",
    "href": "04-logica-predicativa-e-quantificadores.html#exercícios-de-conexão-com-o-prolog",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.9 Exercícios de Conexão com o Prolog",
    "text": "6.9 Exercícios de Conexão com o Prolog\nEstas questões de Lógica Predicativa estabelecem os fundamentos conceituais essenciais para Prolog:\n\nPredicados se tornam fatos e cabeças de regras\nQuantificadores universais correspondem a variáveis em regras\n\nQuantificadores existenciais correspondem a consultas e instanciações\nImplicações se tornam regras (:-)\nConjunções se tornam múltiplas condições nas regras\nNegação se torna negação por falha (\\+)\n\nA modelagem em Lógica de Predicados fornece a base teórica que o Prolog implementa por meio de seu mecanismo de resolução e unificação.\nQuestão 1: Relações em um Sistema Acadêmico\nConsidere um “mundo” acadêmico com alunos e cursos. Use os seguintes predicados:\n\n\\(A(x)\\): “x é um aluno”\n\\(C(x)\\): “x é um curso”\n\n\\(M(x,y)\\): “o aluno x está matriculado no curso y”\n\nTraduza as seguintes sentenças para fórmulas da lógica de predicados:\n\nExiste pelo menos um aluno\nNem todo aluno está matriculado em algum curso\nTodo aluno está matriculado em pelo menos um curso\nExiste um curso no qual nenhum aluno está matriculado\nExiste um aluno que está matriculado em todos os cursos\n\nQuestão 2: O Escopo dos Quantificadores\nA ordem dos quantificadores altera drasticamente o significado de uma sentença. Usando os predicados \\(Pessoa(x)\\) e \\(Ama(x,y)\\) (“x ama y”), traduza e explique a diferença semântica entre as duas sentenças abaixo:\n\n\\(\\forall x \\exists y (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\\(\\exists y \\forall x (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\nQual das duas sentenças descreve melhor o conceito de “amor fraternal universal” e qual descreve a existência de uma “figura universalmente amada por todos”?\nQuestão 3: O Paradoxo do Barbeiro\nEm uma cidade, há um único barbeiro. A regra que define seu trabalho é: “O barbeiro barbeia todos os homens da cidade que não se barbeiam a si mesmos, e apenas esses”.\nUse o predicado \\(Barbeia(x,y)\\) para representar “x barbeia y”. Seja \\(b\\) a constante que representa o barbeiro.\n\nTraduza a regra para uma fórmula da lógica de predicados\nMostre, por meio de dedução lógica, que essa regra leva a uma contradição ao se perguntar: “Quem barbeia o barbeiro?” (ou seja, ao analisar a proposição \\(Barbeia(b,b)\\))\n\nQuestão 4: Especificação de um Sistema de Arquivos\nModele as permissões de um sistema de arquivos com os predicados:\n\n\\(Admin(x)\\): “x é um administrador”\n\\(Arquivo(y)\\): “y é um arquivo”\n\\(PodeAcessar(x,y)\\): “x pode acessar y”\n\nA política de segurança do sistema é: “Qualquer administrador pode acessar todos os arquivos. Ninguém que não seja administrador pode acessar algum arquivo”.\n\nTraduza a política para um conjunto de fórmulas lógicas\nSuponha os seguintes fatos: \\(Admin(ana)\\) e \\(\\neg Admin(beto)\\). O que podemos concluir sobre \\(PodeAcessar(ana, relatorio.doc)\\) e \\(PodeAcessar(beto, relatorio.doc)\\)?\n\nQuestão 5: Negando Afirmações Universais\nNegar sentenças com quantificadores é uma habilidade fundamental para entender a falha em Prolog (negação por falha). Forneça a negação formal das seguintes sentenças, movendo o símbolo de negação (\\(\\neg\\)) o mais para dentro possível da fórmula.\n\n“Todos os programas de computador têm pelo menos um bug”\n\nUse: \\(Programa(x)\\), \\(Bug(y)\\), \\(Tem(x,y)\\)\n\n“Existe um político que é honesto com todos os seus eleitores”\n\nUse: \\(Politico(x)\\), \\(Eleitor(y,x)\\) (“y é eleitor de x”), \\(HonestoCom(x,y)\\)\n\n\nQuestão 6: Mundo dos Blocos (Planejamento em IA)\nConsidere um cenário simples de IA com os predicados: * \\(Bloco(x)\\): “\\(x\\) é um bloco” * \\(EmCima(x,y)\\): “o bloco \\(x\\) está em cima do bloco \\(y\\)” * \\(Azul(x)\\): “o bloco \\(x\\) é azul” * \\(Verde(x)\\): “o bloco \\(x\\) é verde” * \\(NaMesa(x)\\): “o bloco \\(x\\) está diretamente sobre a mesa”\nDados os seguintes axiomas sobre o estado do mundo:\n\nAxioma 1: Existe um bloco verde em cima de um bloco azul \\[\\exists x \\exists y (Bloco(x) \\wedge Bloco(y) \\wedge Verde(x) \\wedge Azul(y) \\wedge EmCima(x,y))\\]\nAxioma 2: Todo bloco que está diretamente sobre a mesa é azul \\[\\forall x ((Bloco(x) \\wedge NaMesa(x)) \\rightarrow Azul(x))\\]\nAxioma 3: Nenhum bloco pode estar simultaneamente em cima de outro bloco e sobre a mesa \\[\\forall x (Bloco(x) \\rightarrow \\neg(\\exists y (Bloco(y) \\wedge EmCima(x,y)) \\wedge NaMesa(x)))\\]\nAxioma 4: Nenhum bloco pode ser verde e azul simultaneamente \\[\\forall x (Bloco(x) \\rightarrow \\neg(Verde(x) \\wedge Azul(x)))\\]\n\nProve formalmente que: “Existe um bloco que não é verde” \\[\\exists x (Bloco(x) \\wedge \\neg Verde(x))\\]\nDica para a prova: Use o Axioma 1 para estabelecer a existência de um bloco azul, depois aplique o Axioma 4 para mostrar que esse bloco não pode ser verde.\nQuestão 7: Propriedades dos Números Inteiros\nSeja o domínio de discurso o conjunto dos números inteiros (\\(\\mathbb{Z}\\)). Use os predicados \\(Par(x)\\), \\(Impar(x)\\) e os símbolos usuais da matemática. Traduza as seguintes sentenças para a lógica de predicados:\n\nTodo número par é maior que algum número ímpar\nNão existe um número inteiro que seja o maior de todos\n\nA soma de quaisquer dois números pares é par\n\nQuestão 8: Dedução Lógica com Instanciação\nConsidere as seguintes premissas:\n\nTodos os leões são mamíferos: \\(\\forall x (Leao(x) \\to Mamifero(x))\\)\nAlguns leões vivem na savana: \\(\\exists x (Leao(x) \\wedge ViveNaSavana(x))\\)\n\nUsando as regras de dedução da lógica de predicados (Instanciação Universal, Instanciação Existencial, Modus Ponens, etc.), prove formalmente que “Alguns mamíferos vivem na savana”: \\(\\exists x (Mamifero(x) \\wedge ViveNaSavana(x))\\).\nQuestão 9: Consulta a uma Base de Dados Relacional\nImagine uma base de dados com as tabelas Funcionario(ID, Nome, DeptoID) e Departamento(ID, NomeDepto). Modele este esquema com os predicados:\n\n\\(Func(x,n,d)\\): “o funcionário com ID x tem nome n e trabalha no departamento d”\n\\(Depto(d,m)\\): “o departamento com ID d tem nome m”\n\nFormule a seguinte consulta em lógica de predicados: “Encontre os nomes de todos os funcionários que trabalham no departamento de ‘Vendas’”.\nQuestão 10: Hierarquia Organizacional\nModele a estrutura de uma empresa com os predicados:\n\n\\(Funcionario(x)\\): “x é um funcionário”\n\\(Gerente(x,y)\\): “x é gerente de y”\n\n\\(Salario(x,s)\\): “o salário de x é s”\n\nTraduza as seguintes regras de negócio para a lógica de predicados:\n\nTodo funcionário tem exatamente um gerente\nNenhum funcionário pode ser gerente de si mesmo\nTodo gerente é também um funcionário\nExiste um funcionário que não é gerente de ninguém\n\nQuestão 11: Sistema Bancário:\nCenário: Banco com clientes e contas Entidades: Clientes, contas bancárias, transações Regras de Negócio:\n\nTodo cliente possui pelo menos uma conta;\nToda conta pertence a exatamente um cliente;\nContas podem ter saldo positivo ou negativo;\nExistem clientes VIP que têm mais de uma conta;\nNem todas as contas têm saldo positivo.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 12: Sistema de Saúde:\nCenário: Hospital com médicos, pacientes e tratamentos. Entidades: Médicos, pacientes, tratamentos, especialidades. Regras de Negócio:\n\nTodo paciente é atendido por pelo menos um médico;\nTodo médico tem uma especialidade;\nAlguns tratamentos requerem médicos especialistas;\nExistem pacientes internados e ambulatoriais;\nTodo tratamento é prescrito por algum médico.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 13: Rede Social:\nCenário: Plataforma social como Facebook Entidades: Usuários, postagens, curtidas, amizades Regras de Negócio:\n\nAmizade é uma relação simétrica;\nTodo usuário pode publicar postagens;\nUsuários podem curtir postagens de amigos;\nExistem usuários influenciadores;\nNem toda postagem recebe curtidas.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 14: Sistema de Biblioteca:\nCenário: Biblioteca universitária. Entidades: Livros, usuários, empréstimos, reservas. Regras de Negócio:\n\nUm usuário pode pegar vários livros;\nUm livro só pode estar com um usuário por vez;\nNem todos os livros estão emprestados;\nExistem livros que nunca foram emprestados;\nTodo empréstimo tem data de devolução.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 15: Sistema de E-commerce:\nCenário: Loja online como Amazon. Entidades: Produtos, clientes, pedidos, categorias, avaliações. Regras de Negócio:\n\nTodo produto pertence a pelo menos uma categoria;\nTodo pedido é feito por exatamente um cliente;\nNem todo produto tem avaliações;\nExistem produtos em promoção;\nClientes podem fazer múltiplos pedidos.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 16: Sistema de Transporte:\nCenário: App de transporte como Uber. Entidades: Motoristas, passageiros, viagens, veículos, avaliações.\nRegras de Negócio:\n\nTodo motorista possui exatamente um veículo;\nToda viagem conecta um passageiro a um motorista;\nNem toda viagem recebe avaliação;\nExistem motoristas premium (alta avaliação);\nPassageiros podem avaliar motoristas.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 17: Sistema Universitário:\nCenário: Gestão acadêmica completa. Entidades: Estudantes, professores, disciplinas, cursos, notas.\nRegras de Negócio:\n\nTodo estudante está matriculado em um curso;\nToda disciplina é ministrada por pelo menos um professor;\nNem todo estudante tem nota em todas as disciplinas;\nExistem disciplinas obrigatórias e optativas;\nTodo professor ensina disciplinas da sua área.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html",
    "href": "05-formas-normais-e-skolemizacao.html",
    "title": "7  Formas Normais Organizando o Pensamento Lógico",
    "section": "",
    "text": "7.1 Formas Normais Básicas\nExistem várias formas normais na Lógica Proposicional, cada uma com suas próprias regras e aplicações. A seguir, a esforçada leitora encontrará uma descrição resumida das formas normais, destacando algumas das principais:\n\\[\\forall x \\exists y (P(x,y))\\]\nSua forma após a Skolemização, que preserva a satisfatibilidade, será:\n\\[\\forall x (P(x, f(x)))\\]\nNosso objetivo, neste livro, é rever a matemática que suporta a Programação Lógica, entre as principais formas normais, para este objetivo, precisamos destacar duas formas:\nPara entender como conseguimos resolver problemas complexos de lógica, teremos que explorar essas formas normais em detalhes. Começando com a mais simples de todas, a Forma Normal Negativa.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais Organizando o Pensamento Lógico</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#formas-normais-básicas",
    "href": "05-formas-normais-e-skolemizacao.html#formas-normais-básicas",
    "title": "7  Formas Normais Organizando o Pensamento Lógico",
    "section": "",
    "text": "Forma Normal Negativa: Uma proposição está na Forma Normal Negativa se as operações de negação \\(\\neg\\) aparecerem apenas imediatamente antes das variáveis. Isso é conseguido aplicando as leis de De Morgan e eliminando as duplas negações.\n\\[\\neg (A \\wedge B) \\equiv (\\neg A \\vee \\neg B)\\]\nForma Normal Conjuntiva: uma proposição está na Forma Normal Conjuntiva se for uma conjunção, operação E, \\(\\wedge\\), de uma ou mais cláusulas, nas quais, cada cláusula é uma disjunção, operação OU, \\(\\vee\\), de literais. Em outras palavras, é uma série de cláusulas conectadas por Es, nas quais, cada cláusula é composta de variáveis conectadas por OUs. Uma forma normal conjuntiva é uma conjunção de disjunções.\n\\[(A \\vee B) \\wedge (C \\vee D) \\wedge (B \\vee D) \\wedge (A \\vee C)\\]\nForma Normal Disjuntiva: uma proposição está na Forma Normal Disjuntiva se for uma disjunção de uma ou mais cláusulas, na qual cada cláusula é uma conjunção de literais. Ou seja, é uma série de cláusulas conectadas por OUs, nas quais cada cláusula é composta de variáveis conectadas por Es, conjunções. A forma normal disjuntiva é uma disjunção de conjunções.\n\\[(A \\wedge B) \\vee (C \\wedge D) \\vee (A \\wedge C) \\vee (B \\wedge D)\\]\nForma Normal Prenex: uma proposição está na Forma Normal Prenex se todos os quantificadores, para a Lógica de Primeira Ordem, estiverem à esquerda, precedendo uma matriz quantificadora livre. Esta forma é útil na Lógica de Primeira Ordem e na teoria da prova.\n\\[\\forall x \\exists y \\forall z (P(x,y) \\wedge \\neg Q(z))\\]\nForma Normal Skolem: na Lógica de Primeira Ordem, uma fórmula está na Forma Normal de Skolem se estiver na Forma Normal Prenex e se todos os quantificadores existenciais forem eliminados. Isto é realizado através de um processo conhecido como Skolemização. Por exemplo, dada a fórmula:\n\n\n\n\n\n\nForma Normal Conjuntiva: a Forma Normal Conjuntiva é importante na Programação Lógica porque muitos sistemas de inferência, como a resolução, funcionam em fórmulas que estão na Forma Normal Conjuntiva. Além disso, os programas em Prolog, a linguagem de Programação Lógica que escolhemos, são formados por Cláusulas de Horn, que são um tipo específico de cláusula na Forma Normal Conjuntiva, cláusulas que possuem, no máximo, um literal positivo.\nForma Normal de Skolem: a Forma Normal de Skolem é útil na Programação Lógica porque a Skolemização, o processo de remover quantificadores existenciais transformando-os em funções de quantificadores universais, permite uma forma mais eficiente de representação e processamento de fórmulas lógicas. Essa forma normal é frequentemente usada em Lógica de Primeira Ordem e teoria da prova, ambas fundamentais para a Programação Lógica.\n\n\n\n7.1.1 Forma Normal Negativa\nA Forma Normal Negativa é como um capitão experiente que ajusta as velas de seu navio. Assim como o capitão remove o excesso de pano e reorganiza as velas para que cada uma capture o vento diretamente, a Forma Normal Negativa move cada negação para o mais próximo possível de seu alvo, os átomos da fórmula.”\nÉ como o processo de desenrolar as linhas de pesca emaranhadas: pegamos cada fio de negação e o seguimos até sua extremidade natural, eliminando as voltas e os nós desnecessários que encontramos no caminho.\nUma fórmula está na Forma Normal Negativa se:\n\ntodos os operadores de negação \\(\\neg\\) são aplicados diretamente aos átomos, variáveis ou constantes.\nusaremos apenas a negação \\(\\neg\\), a conjunção \\(\\wedge\\), e a disjunção \\(\\vee\\).\n\nConverter uma fórmula para a Forma Normal Negativa envolve os seguintes passos:\n\nEliminar os Bicondicionais: substitua todas as ocorrências de \\(A\\leftrightarrow B\\) Por \\(A\\rightarrow B \\wedge B\\rightarrow A\\).\nEliminar Implicações: substitua todas as ocorrências de implicação \\(A \\rightarrow B\\) Por \\(\\neg A \\vee B\\).\nAplicar as Leis de De Morgan: Use as leis de De Morgan para mover as negações para dentro, aplicando:\n\n\\(\\neg (A \\wedge  B) \\equiv \\neg A \\vee \\neg B\\);\n\\(\\neg (A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\).\n\nEliminar Dupla Negação: Substitua qualquer dupla negação \\(\\neg \\neg A\\) Por \\(A\\).\n\n\n7.1.1.1 Exemplo 1\nConverta a fórmula \\(\\neg (A \\wedge  (B \\rightarrow C))\\) Para Forma Normal Negativa\nPara converter a fórmula, seguimos o processo passo a passo para mover as negações para o interior da expressão até que elas se apliquem apenas aos átomos.\n\nEliminar Implicações: Primeiro, substituímos a implicação \\(B \\rightarrow C\\) por sua equivalência \\(\\neg B \\vee C\\).\n\\[\\neg (A \\wedge  (\\neg B \\vee C))\\]\nAplicar Lei de De Morgan (na Conjunção): Em seguida, aplicamos a lei de De Morgan \\(\\neg(P \\wedge  Q) \\equiv \\neg P \\vee \\neg Q\\) na conjunção principal.\n\\[\\neg A \\vee \\neg(\\neg B \\vee C)\\]\nAplicar Lei de De Morgan (na Disjunção): Agora, aplicamos a lei de De Morgan \\(\\neg(P \\vee Q) \\equiv \\neg P \\wedge  \\neg Q\\) na parte direita da expressão.\n\\[\\neg A \\vee (\\neg\\neg B \\wedge  \\neg C)\\]\nEliminar Dupla Negação: Finalmente, removemos a dupla negação \\(\\neg\\neg B\\), que é equivalente a \\(B\\).\n\\[\\neg A \\vee (B \\wedge  \\neg C)\\]\nA fórmula resultante está na Forma Normal Negativa, pois os operadores de negação (\\(\\neg\\)) aplicam-se diretamente aos átomos \\(A\\) e \\(C\\).\n\n\n\n7.1.1.2 Exemplo 2\nConverta a fórmula \\((A \\rightarrow B) \\wedge  \\neg (C \\vee D)\\) Para Forma Normal Negativa\nNeste exemplo, ambos os lados da conjunção principal (\\(\\wedge\\)) são tratados para se adequarem à Forma Normal Negativa.\n\nEliminar Implicações: O primeiro passo é converter a implicação \\(A \\rightarrow B\\) em sua equivalência, \\(\\neg A \\vee B\\). A segunda parte da fórmula não possui implicações.\n\\[(\\neg A \\vee B) \\wedge  \\neg (C \\vee D)\\]\nAplicar Lei de De Morgan: A seguir, aplicamos a lei de De Morgan na expressão \\(\\neg (C \\vee D)\\) para mover a negação para o interior dos parênteses.\n\\[(\\neg A \\vee B) \\wedge (\\neg C \\wedge \\neg D)\\]\n\nA fórmula final já se encontra na Forma Normal Negativa , pois todos os operadores de negação estão aplicados diretamente aos átomos (\\(A\\), \\(C\\) e \\(D\\)). Não há duplas negações que precisem ser eliminadas neste caso.\n\n\n\n7.1.2 Forma Normal Disjuntiva\nA Forma Normal Disjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma disjunção de conjunções. Trata-se de uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico.\nUma fórmula está na Forma Normal Disjuntiva se puder ser escrita como:\n\\[(C_1 \\wedge  C_2 \\wedge  \\ldots) \\vee (D_1 \\wedge  D_2 \\wedge  \\ldots) \\vee\\]\nNa qual, cada \\(C_i\\) e \\(D_i\\) é um literal. Ou seja, é uma variável ou sua negação. Com um pouco mais de formalidade matemática podemos afirmar que uma Fórmula Bem Formada está na Forma Normal Disjuntiva quando está na forma:\n\\[\\bigvee_{i=1}^{m} \\left( \\bigwedge_{j=1}^{n} L_{ij} \\right)\\]\nConverter uma fórmula para Forma Normal Disjuntiva é como identificar todas as combinações de ventos e correntes que levam o navio ao porto desejado. A fórmula original é a rota complexa, a disjunção de todas as opções de rotas. Cada termo da Forma Normal Disjuntiva final é como um cenário único e completo, uma conjunção de condições marítimas, que, por si só, garante que o navio chegue ao destino.\nPara esta conversão, a intrépida leitora deve seguir os seguintes passos:\n\nEliminar os Bicondicionais: substitua todas as ocorrências de \\(A\\leftrightarrow B\\) Por \\(A\\rightarrow B \\wedge B\\rightarrow A\\).\nEliminar Implicações: substitua todas as ocorrências de implicação \\(A \\rightarrow B\\) Por \\(\\neg A \\vee B\\).\nAplicar as Leis de De Morgan: use as leis de De Morgan para mover as negações para dentro, aplicando:\n\n\\(\\neg (A \\wedge  B) \\equiv \\neg A \\vee \\neg B\\)\n\\(\\neg (A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\)\n\nEliminar Dupla Negação: Substitua qualquer dupla negação \\(\\neg \\neg A\\) Por \\(A\\).\nAplicar a Lei Distributiva: Use a lei distributiva para expandir a fórmula, transformando-a em uma disjunção de conjunções.\n\n\n7.1.2.1 Exemplo 1\nConsidere a fórmula:\n\\[\n(A \\rightarrow B) \\wedge  (C \\vee \\neg (D \\wedge  E))\n\\]\nO objetivo é convertê-la para uma disjunção de conjunções.\n\nConverter para a Forma Normal Negativa \nPrimeiro, realizamos os passos iniciais para eliminar implicações e mover as negações para o interior da fórmula, o que nos dará uma forma intermediária.\n\nEliminar Implicações (\\(A \\rightarrow B \\equiv \\neg A \\vee B\\)):\n\\[(\\neg A \\vee B) \\wedge  (C \\vee \\neg (D \\wedge  E))\\]\nAplicar a Lei de De Morgan (\\(\\neg (D \\wedge  E) \\equiv \\neg D \\vee \\neg E\\)):\n\\[(\\neg A \\vee B) \\wedge  (C \\vee \\neg D \\vee \\neg E)\\]\n\nNeste ponto, a fórmula encontra-se na Forma Normal Conjuntiva . O passo seguinte é aplicar a distributividade para alcançar a Forma Normal Disjuntiva.\nAplicar a Lei Distributiva (Parte 1)\nUsamos a lei distributiva \\(P \\wedge  (Q \\vee R) \\equiv (P \\wedge  Q) \\vee (P \\wedge  R)\\). Vamos tratar o termo \\((\\neg A \\vee B)\\) como uma única unidade, \\(X\\), e distribuí-lo sobre \\((C \\vee \\neg D \\vee \\neg E)\\).\n\\[\n\\underbrace{(\\neg A \\vee B)}_{X} \\wedge  (C \\vee \\neg D \\vee \\neg E) \\equiv (X \\wedge  C) \\vee (X \\wedge  \\neg D) \\vee (X \\wedge  \\neg E)\n\\]\nSubstituindo \\(X\\) de volta, obtemos:\n\\[\n((\\neg A \\vee B) \\wedge  C) \\vee ((\\neg A \\vee B) \\wedge  \\neg D) \\vee ((\\neg A \\vee B) \\wedge  \\neg E)\n\\]\nAplicar a Lei Distributiva (Parte 2)\nAgora, aplicamos a lei distributiva \\((P \\vee Q) \\wedge  R \\equiv (P \\wedge  R) \\vee (Q \\wedge  R)\\) em cada uma das três cláusulas da expressão acima.\n\nPrimeiro termo: \\((\\neg A \\wedge  C) \\vee (B \\wedge  C)\\);\nSegundo termo: \\((\\neg A \\wedge  \\neg D) \\vee (B \\wedge  \\neg D)\\);\nTerceiro termo: \\((\\neg A \\wedge  \\neg E) \\vee (B \\wedge  \\neg E)\\).\n\nForma Normal Disjuntiva Final\nUnindo todos os termos expandidos com o operador \\(\\vee\\), chegamos à Forma Normal Disjuntiva final.\n\\[\n(\\neg A \\wedge  C) \\vee (B \\wedge  C) \\vee (\\neg A \\wedge  \\neg D) \\vee (B \\wedge  \\neg D) \\vee (\\neg A \\wedge  \\neg E) \\vee (B \\wedge  \\neg E)\n\\]\nA expressão agora é uma disjunção de múltiplas conjunções, que é a definição da Forma Normal Disjuntiva.\n\n\n\n7.1.2.2 Exemplo 2\nConsidere:\n\\[(\\neg A \\wedge  (B \\rightarrow C)) \\vee (D \\wedge  \\neg (E \\rightarrow F))\\]\n\nEliminar Implicações\n\\[(\\neg A \\wedge  (\\neg B \\vee C)) \\vee (D \\wedge  \\neg (\\neg E \\vee F)) \\equiv (\\neg A \\wedge  (\\neg B \\vee C)) \\vee (D \\wedge  (E \\wedge  \\neg F))\\]\nDistribuir a Disjunção\n\\[(\\neg A \\wedge  \\neg B \\vee \\neg A \\wedge  C) \\vee (D \\wedge  E \\wedge  \\neg F)\\]\nDistribuir a Disjunção Novamente\n\\[\\neg A \\wedge  \\neg B \\vee \\neg A \\wedge  C \\vee D \\wedge  E \\wedge  \\neg F\\]\n\n\n\n7.1.2.3 Exemplo 3\nConsidere a fórmula:\n\\[(p \\rightarrow q) \\rightarrow (r \\vee s)\\]\n\nRemover as implicações (\\(\\rightarrow\\)):\n\\[p \\rightarrow q \\equiv \\neg p \\vee q\\]\nSubstituir a expressão original com a equivalência encontrada no passo 1:\n\\[(\\neg p \\vee q) \\rightarrow (r \\vee s)\\]\nAplicar novamente a equivalência para remover a implicação:\n\\[\\neg (\\neg p \\vee q) \\vee (r \\vee s)\\]\nAplicar a lei de De Morgan para expandir a negação:\n\\[(p \\wedge \\neg q) \\vee (r \\vee s)\\]\n\n\n\n7.1.2.4 Exemplo 4\nConsidere a fórmula que representa a negação de uma bicondicional, que é logicamente equivalente a uma operação de “ou exclusivo” (XOR):\n\\[\n\\neg(p \\leftrightarrow q)\n\\]\nVamos convertê-la para a Forma Normal Disjuntiva.\n\nEliminar a Bicondicional\nO primeiro passo é substituir o operador de bicondicional (\\(A \\leftrightarrow B\\)) por sua definição equivalente: \\((A \\rightarrow B) \\wedge  (B \\rightarrow A)\\).\n\\[\n\\neg((p \\rightarrow q) \\wedge  (q \\rightarrow p))\n\\]\nEliminar as Implicações\nAgora, convertemos as duas implicações internas em suas formas disjuntivas, usando a regra \\(A \\rightarrow B \\equiv \\neg A \\vee B\\).\n\\[\n\\neg((\\neg p \\vee q) \\wedge  (\\neg q \\vee p))\n\\]\nAplicar a Lei de De Morgan\nAplicamos a lei de De Morgan na negação que cobre toda a expressão, transformando a conjunção (\\(\\wedge\\)) em disjunção (\\(\\vee\\)) e movendo a negação para os termos internos.\n\\[\n\\neg(\\neg p \\vee q) \\vee \\neg(\\neg q \\vee p)\n\\]\nAplicar a Lei de De Morgan Novamente e Simplificar\nPara finalizar, aplicamos a lei de De Morgan em cada um dos termos e removemos as duplas negações (\\(\\neg\\neg A \\equiv A\\)) que surgem no processo.\n\\[\n(\\neg\\neg p \\wedge  \\neg q) \\vee (\\neg\\neg q \\wedge  \\neg p)\n\\]\nSimplificando, obtemos a Forma Normal Disjuntiva final:\n\\[\n(p \\wedge  \\neg q) \\vee (\\neg p \\wedge  q)\n\\]\nA expressão resultante é uma disjunção de duas conjunções, o que corresponde perfeitamente à definição da Forma Normal Disjuntiva.\n\n\n\n7.1.2.5 Exemplo 5\nConsidere a seguinte fórmula com uma implicação principal e uma bicondicional aninhada: \\[\n\\neg(p \\wedge  q) \\rightarrow (r \\leftrightarrow s)\n\\] Nosso objetivo é convertê-la para a Forma Normal Disjuntiva.\n\nEliminar a Implicação Principal\nUtilizando a equivalência \\(A \\rightarrow B \\equiv \\neg A \\vee B\\), removemos o operador de implicação principal da fórmula.\n\\[\n\\neg(\\neg(p \\wedge  q)) \\vee (r \\leftrightarrow s)\n\\]\nEliminar a Dupla Negação\nA expressão \\(\\neg(\\neg(p \\wedge  q))\\) simplifica-se diretamente para \\((p \\wedge  q)\\), resultando em:\n\\[\n(p \\wedge  q) \\vee (r \\leftrightarrow s)\n\\]\nEliminar a Bicondicional\nSubstituímos a bicondicional \\(r \\leftrightarrow s\\) por sua definição equivalente: \\((r \\rightarrow s) \\wedge  (s \\rightarrow r)\\).\n\\[\n(p \\wedge  q) \\vee ((r \\rightarrow s) \\wedge  (s \\rightarrow r))\n\\]\nEm seguida, eliminamos as implicações restantes:\n\\[\n(p \\wedge  q) \\vee ((\\neg r \\vee s) \\wedge  (\\neg s \\vee r))\n\\]\nNote que a expressão ainda não está em Forma Normal Disjuntiva, pois a parte direita é uma conjunção.\nAplicar a Lei Distributiva\nPara que toda a expressão se torne uma disjunção de conjunções, precisamos converter a parte \\((\\neg r \\vee s) \\wedge  (\\neg s \\vee r)\\) para Forma Normal Disjuntiva. Fazemos isso aplicando a distributividade:\n\\[\n(\\neg r \\vee s) \\wedge  (\\neg s \\vee r) \\equiv (\\neg r \\wedge  \\neg s) \\vee (\\neg r \\wedge  r) \\vee (s \\wedge  \\neg s) \\vee (s \\wedge  r)\n\\]\nAs cláusulas \\((\\neg r \\wedge  r)\\) e \\((s \\wedge  \\neg s)\\) são contradições (sempre falsas), então podem ser removidas, simplificando a expressão para:\n\\[\n(\\neg r \\wedge  \\neg s) \\vee (s \\wedge  r)\n\\]\nForma Normal Disjuntiva Final\nAgora, substituímos a Forma Normal Disjuntiva que acabamos de derivar de volta na fórmula principal:\n\\[\n(p \\wedge  q) \\vee ((\\neg r \\wedge  \\neg s) \\vee (s \\wedge  r))\n\\]\nComo o operador \\(\\vee\\) é associativo, podemos remover os parênteses extras, chegando à Forma Normal Disjuntiva final:\n\\[\n(p \\wedge  q) \\vee (\\neg r \\wedge  \\neg s) \\vee (s \\wedge  r)\n\\]\nA fórmula final está corretamente expressa como uma disjunção de três conjunções de literais.\n\nA Forma Normal Disjuntiva é útil porque qualquer fórmula lógica pode ser representada desta forma. Além disso, essa representação é única, com exceção da ordem dos literais e das cláusulas.\n\n\n7.1.2.6 Exercícios de Conversão para Forma Normal Disjuntiva\n1. Converta a seguinte fórmula para Forma Normal Disjuntiva:\n\\[\n((P \\leftrightarrow Q) \\rightarrow R) \\wedge \\neg(R \\rightarrow (P \\vee Q))\n\\]\n2. Converta para Forma Normal Disjuntiva a fórmula que representa a negação de uma tautologia clássica:\n\\[\n\\neg((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R)))\n\\]\n3. Dada a fórmula com múltiplas bicondicionais aninhadas, obtenha sua Forma Normal Disjuntiva:\n\\[\n(P \\leftrightarrow (Q \\leftrightarrow R)) \\vee \\neg(P \\wedge Q \\wedge R)\n\\]\n4. Converta a seguinte fórmula complexa para Forma Normal Disjuntiva:\n\\[\n\\neg((P \\vee Q) \\rightarrow (R \\wedge S)) \\leftrightarrow (P \\rightarrow \\neg Q)\n\\]\n5. Transforme em Forma Normal Disjuntiva a fórmula:\n\\[\n((P \\wedge Q) \\rightarrow (R \\vee S)) \\wedge ((R \\rightarrow P) \\vee (S \\rightarrow Q))\n\\]\n6. Obtenha a Forma Normal Disjuntiva para:\n\\[\n\\neg(P \\leftrightarrow \\neg Q) \\rightarrow ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\n7. Converta para Forma Normal Disjuntiva a fórmula que combina negação de implicação com bicondicional:\n\\[\n\\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow R)) \\leftrightarrow (P \\wedge \\neg R)\n\\]\n\n\n\n7.1.3 Forma Normal Conjuntiva\nA Forma Normal Conjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma conjunção de disjunções. Em outras palavras, é uma expressão lógica na forma de uma conjunção de disjunções. É uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico e simplificação de fórmulas.\nA diferença entre Forma Normal Conjuntiva e Forma Normal Disjuntiva é como a diferença entre dois estilos de organização de uma biblioteca:\nA Forma Normal Conjuntiva é como uma esquadra naval na qual cada embarcação, conjunção, deve ter pelo menos um tripulante qualificado, disjunção. Você só fica satisfeito se TODAS as embarcações tiverem alguém capacitado a bordo.\nDizemos que uma fórmula está na Forma Normal Conjuntiva se puder ser expressa na forma:\n\\[(D_1 \\vee D_2 \\vee \\ldots \\vee D_n) \\wedge  (E_1 \\vee E_2 \\vee \\ldots \\vee E_m) \\wedge  \\ldots\\]\nNa qual, \\(D_1, \\ldots , D_n\\) e $ E_1, ,E_m $ representam literais. Podemos dizer que a Forma Normal Conjuntiva acontece quando a Fórmula Bem Formada está na forma:\n\\[\\bigwedge_{i=1}^{m} \\left( \\bigvee_{j=1}^{n} L_{ij} \\right)\\]\nConverter uma fórmula proposicional para a Forma Normal Conjuntiva é um processo algorítmico que garante que a expressão final seja uma conjunção de disjunções. Os passos são os seguintes:\n\nEliminar Bicondicionais: Substitua todas as ocorrências da bicondicional pela sua definição baseada em implicações.\n\\[\nA \\leftrightarrow B \\equiv (A \\rightarrow B) \\wedge  (B \\rightarrow A)\n\\]\nEliminar Implicações: Em seguida, remova todas as implicações, trocando-as por sua equivalência com o uso de disjunção e negação.\n\\[\nA \\rightarrow B \\equiv \\neg A \\vee B\n\\]\nMover Negações para o Interior (Converter para Forma Normal Negativa): Use as Leis de De Morgan e a Lei da Dupla Negação para mover todos os operadores de negação (\\(\\neg\\)) para dentro da expressão, até que eles se apliquem apenas diretamente às variáveis atômicas. As regras principais são:\n\n\\(\\neg(A \\wedge  B) \\equiv \\neg A \\vee \\neg B\\)\n\\(\\neg(A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\)\n\\(\\neg\\neg A \\equiv A\\)\n\nAo final deste passo, a fórmula estará em Forma Normal Negativa .\nAplicar a Lei Distributiva: Para finalizar, aplique a lei distributiva para garantir que nenhuma conjunção (\\(\\wedge\\)) esteja aninhada dentro de uma disjunção (\\(\\vee\\)). A regra chave é distribuir o \\(\\vee\\) sobre o \\(\\wedge\\).\n\\[\nA \\vee (B \\wedge  C) \\equiv (A \\vee B) \\wedge  (A \\vee C)\n\\]\nEste passo deve ser repetido até que a fórmula inteira seja uma conjunção de cláusulas, nas quais cada cláusula é uma disjunção de literais, satisfazendo a definição da Forma Normal Conjuntiva.\n\n\n7.1.3.1 Exemplo 1\nConsidere a fórmula:\n\\[(A \\wedge  B) \\rightarrow (C \\vee D)\\]\n\nEliminar Implicações:\n\\[\\neg (A \\wedge  B) \\vee (C \\vee D) \\equiv (\\neg A \\vee \\neg B) \\vee (C \\vee D)\\]\n\nNeste ponto temos \\((\\neg A \\vee \\neg B) \\vee (C \\vee D)\\) e podemos remover os parênteses obtendo:\n\\[\\neg A \\vee \\neg B \\vee C \\vee D\\]\nAqui a atenta leitora deve observar que temos uma única cláusula, ou seja, uma Forma Normal Conjuntiva com apenas uma cláusula. Nenhuma outra simplificação é necessária.\n\n\n7.1.3.2 Exemplo 2\nConsidere a fórmula:\n\\[(A \\wedge  \\neg B) \\vee (\\neg C \\wedge  D) \\rightarrow (E \\vee F)\\]\n\nEliminar Implicações (usando a equivalência \\(P \\rightarrow Q \\equiv \\neg P \\vee Q\\)):\n\n\\[\\neg ((A \\wedge  \\neg B) \\vee (\\neg C \\wedge  D)) \\vee (E \\vee F)\\]\n\nMover a Negação para Dentro (usando Leis de De Morgan):\n\n\\[((\\neg A \\vee B) \\wedge (C \\vee \\neg D)) \\vee (E \\vee F)\\]\n\nDistribuir a Disjunção sobre a Conjunção (usando a equivalência \\((P \\wedge Q) \\vee R \\equiv (P \\vee R) \\wedge (Q \\vee R)\\)):\n\n\\[(\\neg A \\vee B \\vee E \\vee F) \\wedge (C \\vee \\neg D \\vee E \\vee F)\\]\n\n\n7.1.3.3 Exemplo 3\nConsidere a fórmula:\n\\[\n(p \\wedge (q \\vee r)) \\vee (\\neg p \\wedge \\neg q)\n\\]\nConversão para Forma Normal Conjuntiva :\n\nAplicar a lei distributiva no primeiro termo: expandir \\((p \\wedge (q \\vee r))\\) usando \\(A \\wedge (B \\vee C) \\equiv (A \\wedge B) \\vee (A \\wedge C)\\)\n\\[\n(p \\wedge q) \\vee (p \\wedge r) \\vee (\\neg p \\wedge \\neg q)\n\\]\nNeste ponto, temos uma Forma Normal Disjuntiva .\nConstruir a tabela-verdade para determinar a Forma Normal Conjuntiva:\n\\[\n\\begin{array}{ccc|c|c|c}\np & q & r & p \\wedge q & p \\wedge r & \\neg p \\wedge \\neg q & \\text{Resultado} \\\\\n\\hline\nT & T & T & T & T & F & T \\\\\nT & T & F & T & F & F & T \\\\\nT & F & T & F & T & F & T \\\\\nT & F & F & F & F & F & F \\\\\nF & T & T & F & F & F & F \\\\\nF & T & F & F & F & F & F \\\\\nF & F & T & F & F & T & T \\\\\nF & F & F & F & F & T & T \\\\\n\\end{array}\n\\]\nIdentificar as linhas falsas: as linhas 4, 5 e 6 têm resultado falso.\nConstruir cláusulas excludentes: para cada linha falsa, criamos uma cláusula que a “proíbe”:\n\nLinha 4 (p=T, q=F, r=F): Para excluir esta combinação, criamos \\((\\neg p \\vee q \\vee r)\\)\nLinha 5 (p=F, q=T, r=T): Para excluir esta combinação, criamos \\((p \\vee \\neg q \\vee \\neg r)\\)\n\nLinha 6 (p=F, q=T, r=F): Para excluir esta combinação, criamos \\((p \\vee \\neg q \\vee r)\\)\n\nFormar a Forma Normal Conjuntiva: a conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:\n\\[\n(\\neg p \\vee q \\vee r) \\wedge (p \\vee \\neg q \\vee \\neg r) \\wedge (p \\vee \\neg q \\vee r)\n\\]\nSimplificação: podemos aplicar a lei da resolução nas duas últimas cláusulas:\nDe \\((p \\vee \\neg q \\vee \\neg r) \\wedge (p \\vee \\neg q \\vee r)\\), obtemos \\((p \\vee \\neg q)\\) (eliminando \\(r\\) e \\(\\neg r\\)).\nForma Normal Conjuntiva final simplificada:\n\\[\n(\\neg p \\vee q \\vee r) \\wedge (p \\vee \\neg q)\n\\]\n\n\n\n\n\n\n\nImportant\n\n\n\nObservação importante - Por que a conversão direta não funciona:\nA conversão direta de Forma Normal Disjuntiva para Forma Normal Conjuntiva através de distributividade simples frequentemente resulta em uma explosão exponencial de termos. Vamos ver por que:\nPara converter \\((p \\wedge q) \\vee (p \\wedge r) \\vee (\\neg p \\wedge \\neg q)\\) diretamente para Forma Normal Conjuntiva, precisaríamos aplicar a distributividade do \\(\\wedge\\) sobre \\(\\vee\\), usando a regra \\((A \\vee B) \\wedge (C \\vee D) \\equiv (A \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge C) \\vee (B \\wedge D)\\).\nSe tentássemos aplicar isso sistematicamente:\n\nPrimeiro, agruparíamos: \\(((p \\wedge q) \\vee (p \\wedge r)) \\vee (\\neg p \\wedge \\neg q)\\);\nCada aplicação de distributividade duplicaria o número de termos;\nCom 3 termos conjuntivos originais, cada um com 2 literais, a expansão completa geraria \\(2^3 = 8\\) combinações possíveis;\nMuitas dessas combinações seriam tautológicas ou contraditórias, requerendo simplificação adicional.\n\nExemplo da complexidade: Aplicando distributividade apenas ao primeiro passo:\n\n\\((p \\wedge q) \\vee (p \\wedge r)\\) precisa ser convertido para Forma Normal Conjuntiva\nIsso exigiria criar “pseudo-literais” para cada conjunção\nA expressão resultante seria muito mais complexa que a Forma Normal Conjuntiva obtida pela tabela-verdade\n\nPor isso, métodos alternativos são preferíveis:\n\nTabela-verdade: Identifica diretamente as condições falsas, gerando a Forma Normal Conjuntiva mínima\nAlgoritmo de Tseitin: Introduz variáveis auxiliares para evitar explosão exponencial\nResolução reversa: Constrói cláusulas incrementalmente\n\nA abordagem pela tabela-verdade, embora limitada a fórmulas proposicionais pequenas, é mais sistemática e garante uma Forma Normal Conjuntiva correta sem a complexidade da distributividade direta.\n\n\n\n\n7.1.3.4 Exemplo 4\nConsidere a fórmula:\n\\[ \\neg ((p \\wedge q) \\vee \\neg (r \\wedge s))\\]\n\nAplicando a Lei de De Morgan na expressão inteira:\n\\[\n\\begin{align*}\n\\neg ((p \\wedge q) \\vee \\neg (r \\wedge s)) &\\equiv \\neg (p \\wedge q) \\wedge (r \\wedge s) \\quad \\text{(Lei de De Morgan)}\n\\end{align*}\n\\]\naplicando a Lei de De Morgan nos termos internos:\n\\[\n\\begin{align*}\n\\neg (p \\wedge q) \\wedge (r \\wedge s) &\\equiv (\\neg p \\vee \\neg q) \\wedge (r \\wedge s) \\quad \\text{(Lei de De Morgan)}\n\\end{align*}\n\\]\n\n\n\n7.1.3.5 Exemplo 5\nConsidere a seguinte fórmula, que é a negação da Lei de Peirce (uma conhecida tautologia na lógica clássica):\n\\[\n\\neg (((p \\rightarrow q) \\rightarrow p) \\rightarrow p)\n\\]\nNosso objetivo é converter esta fórmula para a Forma Normal Conjuntiva para determinar sua natureza.\n\nEliminar a Implicação Mais Externa\nAplicamos a regra \\(A \\rightarrow B \\equiv \\neg A \\vee B\\) na implicação principal.\n\\[\n\\neg (\\neg((p \\rightarrow q) \\rightarrow p) \\vee p)\n\\]\nAplicar a Lei de De Morgan\nAgora, aplicamos a lei \\(\\neg(A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\) na fórmula.\n\\[\n\\neg\\neg((p \\rightarrow q) \\rightarrow p) \\wedge  \\neg p\n\\]\nEliminar a Dupla Negação\nA dupla negação é removida, simplificando a expressão.\n\\[\n((p \\rightarrow q) \\rightarrow p) \\wedge  \\neg p\n\\]\nEliminar as Implicações Restantes\nContinuamos eliminando as implicações de dentro para fora.\n\\[\n(\\neg(p \\rightarrow q) \\vee p) \\wedge  \\neg p\n\\]\n\\[\n(\\neg(\\neg p \\vee q) \\vee p) \\wedge  \\neg p\n\\]\nMover a Negação para o Interior\nAplicamos a Lei de De Morgan no primeiro termo aninhado.\n\\[\n((p \\wedge  \\neg q) \\vee p) \\wedge  \\neg p\n\\]\nNeste ponto, a expressão \\(((p \\wedge  \\neg q) \\vee p) \\wedge  \\neg p\\) está em Forma Normal Disjuntiva. Para prosseguir com a conversão para Forma Normal Conjuntiva, precisamos aplicar a lei distributiva nela.\nAplicar a Lei Distributiva\nDistribuímos \\(\\vee p\\) sobre \\((p \\wedge  \\neg q)\\) usando a regra \\((A \\wedge  B) \\vee C \\equiv (A \\vee C) \\wedge  (B \\vee C)\\).\n\\[\n((p \\vee p) \\wedge  (\\neg q \\vee p)) \\wedge  \\neg p\n\\]\nSimplificar e Reassociar\nSimplificamos \\((p \\vee p)\\) para \\(p\\) (Idempotência) e reassociamos os termos para agrupar \\(p\\) e \\(\\neg p\\).\n\\[\n(p \\wedge  (\\neg q \\vee p)) \\wedge  \\neg p\n\\]\n\\[\n(p \\wedge  \\neg p) \\wedge  (\\neg q \\vee p)\n\\]\nResultado Final\nA expressão \\((p \\wedge  \\neg p)\\) é uma contradição, equivalente a \\(Falso\\) (\\(F\\)). Qualquer conjunção com \\(F\\) resulta em \\(F\\).\n\\[\nF \\wedge  (\\neg q \\vee p)\n\\]\n\\[\nF\n\\]\nA fórmula original é uma contradição. A Forma Normal Conjuntiva de uma contradição pode ser representada simplesmente como \\(F\\), ou por qualquer conjunção contraditória, como \\((p \\wedge  \\neg p)\\).\n\nNegação da Lei de Peirce\nA Lei de Peirce é uma tautologia fundamental da lógica clássica, formulada como:\n\\[((P \\rightarrow Q) \\rightarrow P) \\rightarrow P\\]\nA negação da Lei de Peirce é expressa por:\n\\[\\neg(((P \\rightarrow Q) \\rightarrow P) \\rightarrow P)\\]\nEsta negação representa uma fórmula que é:\n\nSempre falsa na lógica clássica (sendo a negação de uma tautologia);\nSatisfazível em alguns sistemas de lógica intuicionista;\nUm exemplo importante de fórmula que distingue lógica clássica de lógica intuicionista.\n\nPara entender melhor, considere que a a lógica clássica é baseada em princípios fundamentais como:\n\nPrincípio do Terceiro Excluído: para qualquer proposição \\(P\\), ou \\(P\\) é verdadeira ou \\(\\neg P\\) é verdadeira: \\(P \\vee \\neg P\\);\nPrincípio da Não-Contradição: uma proposição não pode ser simultaneamente verdadeira e falsa: \\(\\neg(P \\wedge \\neg P)\\);\nReductio ad Absurdum: se assumir \\(\\neg P\\) leva a uma contradição, então \\(P\\) deve ser verdadeira.\n\nPor outro lado, a lógica intuicionista, desenvolvida por Brouwer e formalizada por Heyting, rejeita o princípio do terceiro excluído. Principais características:\n\nUma proposição só é considerada verdadeira se existe uma prova construtiva de sua verdade;\nA negação de uma proposição \\(\\neg P\\) significa que assumir \\(P\\) leva a uma contradição;\n\\(P \\vee \\neg P\\) não é universalmente válida - requer demonstração específica para cada \\(P\\).\n\nDiferenças Fundamentais entre a Lógica Clássica e a Intuicionista\n\nInterpretação da Implicação: Na lógica clássica, \\(P \\rightarrow Q\\) é falsa apenas quando \\(P\\) é verdadeira e \\(Q\\) é falsa. Na lógica intuicionista, \\(P \\rightarrow Q\\) requer uma construção que transforme qualquer prova de \\(P\\) em uma prova de \\(Q\\)\nExistência: Na lógica clássica, provar \\(\\exists x \\, P(x)\\) pode ser feito mostrando que \\(\\neg \\forall x \\, \\neg P(x)\\). Na lógica intuicionista, é necessário fornecer um exemplo específico\nDupla Negação: \\(\\neg \\neg P \\rightarrow P\\) é válida na lógica clássica, mas não na intuicionista\n\nNa lógica intuicionista, a negação da Lei de Peirce não é uma contradição, pois o princípio do terceiro excluído não é universalmente válido. Isso significa que existem modelos intuicionistas nos quais:\n\\[\\neg(((P \\rightarrow Q) \\rightarrow P) \\rightarrow P)\\]\npode ser verdadeira, demonstrando uma diferença fundamental entre os sistemas lógicos clássico e intuicionista.\nA fórmula original \\((((P \\rightarrow Q) \\rightarrow P) \\rightarrow P)\\) é equivalente ao reductio ad absurdum e ao princípio do terceiro excluído na lógica clássica.\n\n\n\n\n7.1.3.6 Exemplo 6\nConsidere a fórmula:\n\\[(p \\rightarrow q) \\leftrightarrow (p \\rightarrow r)\\]\n\nComeçamos pela definição de equivalência e implicação:\n\\[(p \\rightarrow q) \\leftrightarrow (p \\rightarrow r)\\]\nAplicamos as definições de implicação:\n\\[(\\neg p \\vee q) \\leftrightarrow (\\neg p \\vee r)\\]\nAgora, aplicamos a definição de equivalência, transformando-a em uma conjunção de duas implicações:\n\\[((\\neg p \\vee q) \\rightarrow (\\neg p \\vee r)) \\wedge  ((\\neg p \\vee r) \\rightarrow (\\neg p \\vee q))\\]\nEm seguida, aplicamos a definição de implicação novamente para cada uma das implicações internas:\n\\[(\\neg (\\neg p \\vee q) \\vee (\\neg p \\vee r)) \\wedge  (\\neg (\\neg p \\vee r) \\vee (\\neg p \\vee q))\\]\nVamos aplicar a lei de De Morgan e a lei da dupla negação para simplificar a expressão:\n\\[((p \\wedge  \\neg q) \\vee (\\neg p \\vee r)) \\wedge  ((p \\wedge  \\neg r) \\vee (\\neg p \\vee q))\\]\nAplicando a lei distributiva para desenvolver cada conjunção interna em disjunções:\n\\[((p \\vee (\\neg p \\vee r)) \\wedge  (\\neg q \\vee (\\neg p \\vee r))) \\wedge  ((p \\vee (\\neg p \\vee q)) \\wedge  (\\neg r \\vee (\\neg p \\vee q)))\\]\n\nA aplicação das equivalências não é, nem de longe, a única forma de percorrer a rota da conversão de uma Fórmula Bem Formada em Forma Normal Conjuntiva.\n\n\n7.1.3.7 Exercícios de Conversão para Forma Normal Conjuntiva\n1. Converta a seguinte fórmula para Forma Normal Conjuntiva:\n\\[(p \\leftrightarrow q) \\rightarrow ((p \\wedge r) \\vee (q \\wedge \\neg r))\\]\n\\[(p \\leftrightarrow q) \\rightarrow ((p \\wedge r) \\vee (q \\wedge \\neg r))\\]\n2. Transforme em Forma Normal Conjuntiva a fórmula: \\[\\neg((p \\rightarrow q) \\vee (q \\rightarrow p)) \\wedge (p \\vee q)\\]\n3. Converta para Forma Normal Conjuntiva a negação de uma tautologia distributiva:\n\\[\\neg((p \\wedge (q \\vee r)) \\leftrightarrow ((p \\wedge q) \\vee (p \\wedge r)))\\]\n4. Obtenha a Forma Normal Conjuntiva para:\n\\[((p \\vee q) \\rightarrow r) \\leftrightarrow (p \\rightarrow r) \\wedge (q \\rightarrow r)\\]\n5. Converta a seguinte fórmula complexa para Forma Normal Conjuntiva:\n\\[(p \\rightarrow (q \\rightarrow r)) \\wedge \\neg((p \\wedge q) \\rightarrow r)\\]\n6. Transforme em Forma Normal Conjuntiva:\n\\[((p \\leftrightarrow q) \\vee (q \\leftrightarrow r)) \\wedge \\neg(p \\leftrightarrow r)\\]\n7. Converta para Forma Normal Conjuntiva a fórmula:\n\\[\\neg(p \\rightarrow (q \\vee r)) \\vee ((p \\wedge \\neg q) \\rightarrow r)\\]\n\n\n\n7.1.4 Usando a Tabela-Verdade para Gerar Formas Normais\nA tabela-verdade é nosso navegador experiente que mapeia todas as rotas possíveis em águas desconhecidas das possibilidades lógicas. Como um cartógrafo naval que registra cada banco de areia e recife em uma nova rota marítima, a tabela-verdade cataloga cada combinação possível de verdades e falsidades, criando uma carta náutica completa do oceano lógico que a leitora deverá percorrer em busca da verdade.\nPara entender este conceito com um pouco mais de formalidade, considere a Fórmula Bem Formada dada por: \\((A \\vee B) \\rightarrow (C \\wedge  \\neg A)\\), se encontrarmos sua Tabela Verdade, poderemos encontrar, tanto a Forma Normal Conjuntiva quanto a Forma Normal Disjuntiva. Basta fixar nosso olhar nas linhas da verdade, ou da falsidade.\n\n7.1.4.1 Gerando a Forma Normal Disjuntiva\nPara transformar \\((A \\vee B) \\rightarrow (C \\wedge \\neg A)\\) na sua Forma Normal Conjuntiva, como um timoneiro disciplinado seguindo o roteiro de navegação, devemos seguir rigidamente, os seguintes passos:\n\nCriar a Tabela-Verdade\n\\[\n\\begin{array}{cccc|c|c|c}\nA & B & C & \\neg A & A \\vee B & C \\wedge  \\neg A & (A \\vee B) \\rightarrow (C \\wedge  \\neg A) \\\\\n\\hline\nT & T & T & F & T & F & F \\\\\nT & T & F & F & T & F & F \\\\\nT & F & T & F & T & F & F \\\\\nT & F & F & F & T & F & F \\\\\nF & T & T & T & T & T & T \\\\\nF & T & F & T & T & F & F \\\\\nF & F & T & T & F & T & T \\\\\nF & F & F & T & F & T & T \\\\\n\\end{array}\n\\]\nIdentificar as Linhas com Resultado Verdadeiro\nAs linhas 5, 7 e 8 têm resultado verdadeiro.\nConstruir a Forma Normal Disjuntiva usando as linhas com resultados verdadeiros:\n\nNeste passo, nosso objetivo é construir uma expressão que seja verdadeira nas linhas 5, 7 e 8 (as linhas nas quais o resultado é verdadeiro), e falsa em todos os outros casos. Para fazer isso, criamos uma disjunção (uma expressão OR) para cada linha verdadeira que reflete as condições das variáveis nesta linha, e então unimos essas disjunções com uma conjunção (uma operação AND) para criar a Forma Normal Disjuntiva desejada:\n\nPrimeiro Termo Correspondente a Linha 5: \\((\\neg A \\wedge  B \\wedge  C)\\) Este termo é verdadeiro quando \\(A\\) é falso, \\(B\\) é verdadeiro e \\(C\\) é verdadeiro, o que corresponde à linha 5 da tabela.\nSegundo Termo Correspondente a Linha 7: \\((\\neg A \\wedge  \\neg B \\wedge  C)\\) Este termo é verdadeiro quando \\(A\\) é falso, \\(B\\) é falso e \\(C\\) é verdadeiro, o que corresponde à linha 7 da tabela.\nTerceiro Correspondente a Linha 8: \\((\\neg A \\wedge  \\neg B \\wedge  \\neg C)\\) Este termo é verdadeiro quando \\(A\\) é falso, \\(B\\) é falso e \\(C\\) é falso, o que corresponde à linha 8 da tabela.\n\nFinalmente, unimos estes termos com operações OR (\\(\\vee\\)) para criar a expressão Forma Normal Disjuntiva completa:\n\\[\n(A \\vee B) \\rightarrow (C \\wedge  \\neg A) = (\\neg A \\wedge  B \\wedge  C) \\vee (\\neg A \\wedge  \\neg B \\wedge  C) \\vee (\\neg A \\wedge  \\neg B \\wedge  \\neg C)\n\\]\nA expressão acima será verdadeira se qualquer um dos termos (ou seja, qualquer uma das linhas 5, 7 ou 8 da tabela) for verdadeiro, garantindo que a expressão capture exatamente as condições em que \\((A \\vee B) \\rightarrow (C \\wedge  \\neg A)\\) é verdadeira de acordo com a tabela-verdade.\n\n\n7.1.4.2 Gerando a Forma Normal Conjuntiva\nPara transformar \\((A \\vee B) \\rightarrow (C \\wedge  \\neg A)\\) em sua Forma Normal Conjuntiva usando a tabela-verdade, devemos nos concentrar nas linhas nas quais a fórmula é falsa e criar cláusulas que “proíbam” essas combinações de valores.\nPrincípio fundamental: Para cada linha falsa, criamos uma cláusula que será verdadeira exceto naquela linha específica.\n\nIdentificar as Linhas com Resultado Falso\nAs linhas 1, 2, 3, 4 e 6 têm resultado falso.\nConstruir Cláusulas Excludentes: para cada linha falsa, criamos uma cláusula que “proíbe” aquela combinação específica de valores de verdade:\nRegra de construção: Para cada linha falsa, se uma variável tem valor V (verdadeiro), colocamos sua negação na cláusula; se tem valor F (falso), colocamos a variável sem negação.\n\nLinha 1 (A=V, B=V, C=V): Para excluir esta combinação, criamos \\((\\neg A \\vee \\neg B \\vee \\neg C)\\)\nLinha 2 (A=V, B=V, C=F): Para excluir esta combinação, criamos \\((\\neg A \\vee \\neg B \\vee C)\\)\n\nLinha 3 (A=V, B=F, C=V): Para excluir esta combinação, criamos \\((\\neg A \\vee B \\vee \\neg C)\\)\nLinha 4 (A=V, B=F, C=F): Para excluir esta combinação, criamos \\((\\neg A \\vee B \\vee C)\\)\nLinha 6 (A=F, B=V, C=F): Para excluir esta combinação, criamos \\((A \\vee \\neg B \\vee C)\\)\n\nFormar a Forma Normal Conjuntiva: A conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:\n\\[\\begin{align*}\n(A \\vee B) \\rightarrow (C \\wedge  \\neg A) &\\equiv (\\neg A \\vee \\neg B \\vee \\neg C) \\\\\n&\\wedge (\\neg A \\vee \\neg B \\vee C) \\\\\n&\\wedge (\\neg A \\vee B \\vee \\neg C) \\\\\n&\\wedge (\\neg A \\vee B \\vee C) \\\\\n&\\wedge (A \\vee \\neg B \\vee C)\n\\end{align*}\\]\n\nVerificação: Cada cláusula é falsa apenas na linha correspondente da tabela-verdade. A conjunção de todas as cláusulas será verdadeira exceto quando pelo menos uma cláusula for falsa, o que acontece exatamente nas linhas na quais a fórmula original é falsa.\nA atenta leitora deve perceber que cada cláusula funciona como uma boia de sinalização que impede navegação em águas perigosas. Cada cláusula exclui uma rota específica (linha falsa) do mapa lógico, garantindo que a expressão final seja verdadeira em todas as outras rotas (linhas verdadeiras).",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais Organizando o Pensamento Lógico</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#formas-normais-avançadas",
    "href": "05-formas-normais-e-skolemizacao.html#formas-normais-avançadas",
    "title": "7  Formas Normais Organizando o Pensamento Lógico",
    "section": "7.2 Formas Normais Avançadas",
    "text": "7.2 Formas Normais Avançadas\n\n7.2.1 Forma Normal Prenex\nA Forma Normal Prenex é como um almirante experiente organizando a cadeia de comando antes de uma operação naval complexa.\nA criativa leitora pode imaginar uma esquadra na qual as ordens estão sendo transmitidas de forma caótica, alguns capitães recebem instruções diretas, outros recebem ordens através de subordinados, e as responsabilidades estão misturadas com as tarefas operacionais. A Forma Normal Prenex é como este almirante que, antes de qualquer manobra, convoca todos os comandantes para a ponte principal, estabelecendo claramente a hierarquia completa, quem comanda o quê e em que ordem, antes de transmitir as instruções operacionais.\nAssim como o almirante separa completamente a estrutura de comando (todos os quantificadores universais \\(\\forall\\) e existenciais \\(\\exists\\) movidos para frente) das ordens de execução (a matriz livre de quantificadores), a Forma Normal Prenex cria uma divisão clara entre “quem decide” e “o que fazer”.\nCom um pouco de formalidade a atenta leitora verá que a Forma Normal Prenex é uma padronização para fórmulas da lógica de primeira ordem. Nela, todos os quantificadores são deslocados para a frente da fórmula, deixando a matriz da fórmula livre de quantificadores. A Forma Normal Prenex apresenta três características principais:\n\nFacilitação da Manipulação Lógica: ao separar os quantificadores da matriz, a Forma Normal Prenex simplifica a análise e manipulação da estrutura lógica da fórmula;\nPreparação para Outras Formas Normais: serve como uma etapa intermediária na conversão para outras formas normais, como as Forma Normal Conjuntiva e Forma Normal Disjuntiva;\nUso em Provas Automáticas: é amplamente empregada em métodos de prova automática, tornando o raciocínio sobre quantificadores mais acessível.\n\nExemplo de conversão para Forma Normal Prenex:\nConsidere a fórmula original que não está em Forma Normal Prenex:\n\\[\n\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists z R(z)\n\\]\nPara convertê-la para Forma Normal Prenex, seguimos os passos:\n\nPadronizar variáveis: renomear variáveis para evitar conflitos\n\n\\[\n\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists w R(w)\n\\]\n\nEliminar implicações: substituir \\(P(x) \\rightarrow Q(x,y)\\) por \\(\\neg P(x) \\vee Q(x,y)\\)\n\n\\[\n\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge \\exists w R(w)\n\\]\n\nMover quantificadores para fora: extrair \\(\\exists y\\) e \\(\\exists w\\) para a frente, preservando a ordem relativa\n\n\\[\n\\exists w \\forall x \\exists y (R(w) \\wedge (\\neg P(x) \\vee Q(x,y)))\n\\]\nExemplo de fórmula já em Forma Normal Prenex:\nA fórmula a seguir já está em Forma Normal Prenex e não precisa de conversão:\n\\[\n\\exists x \\forall y (P(x,y) \\wedge Q(y))\n\\]\n\n\n\n\n\n\nWarning\n\n\n\nOrdem Crítica dos Quantificadores\nA ordem relativa entre quantificadores de tipos diferentes não pode ser alterada sem modificar o significado lógico:\n\n\\(\\exists x \\forall y \\, P(x,y)\\): “Existe um x específico que funciona para todos os y”;\n\\(\\forall y \\exists x \\, P(x,y)\\): “Para cada y, pode existir um x diferente”.\n\nExemplo prático:\n\n\\(\\exists x \\forall y \\, \\text{AmaX}(x,y)\\): “Existe uma pessoa que ama todo mundo”;\n\\(\\forall y \\exists x \\, \\text{AmaX}(x,y)\\): “Todo mundo é amado por alguém”.\n\nApenas quantificadores do mesmo tipo podem ser reordenados sem alterar o significado:\n\n\\(\\forall x \\forall y \\, P(x,y) \\equiv \\forall y \\forall x \\, P(x,y)\\);\n\\(\\exists x \\exists y \\, P(x,y) \\equiv \\exists y \\exists x \\, P(x,y)\\).\n\n\n\nIMPORTANTE: Quantificadores de tipos diferentes não podem ser trocados de ordem sem alterar o significado lógico. As fórmulas \\(\\exists x \\forall y \\phi(x,y)\\) e \\(\\forall y \\exists x \\phi(x,y)\\) não são equivalentes. A primeira é logicamente mais forte (existe um \\(x\\) específico que funciona para todos os \\(y\\)), enquanto a segunda é mais fraca (para cada \\(y\\), pode existir um \\(x\\) diferente).\nUma fórmula na Forma Normal Prenex segue uma estrutura específica definida por:\n\\[\nQ_1 x_1 \\, Q_2 x_2 \\, \\ldots \\, Q_n x_n \\, M(x_1, x_2, \\ldots, x_n)\n\\]\nNessa estrutura:\n\n\\(Q_i\\) são quantificadores, podendo ser universais \\(\\forall\\) ou existenciais \\(\\exists\\);\n\\(x_i\\) são as variáveis vinculadas pelos quantificadores;\n\\(M(x_1, x_2, \\ldots, x_n)\\) representa a matriz da fórmula, uma expressão lógica sem quantificadores.\n\nConverter uma fórmula para a Forma Normal Prenex envolve os seguintes passos:\n\nEliminar Implicações: substitua todas as ocorrências de implicação por disjunções e negações;\nMover Negações para Dentro: use as leis de De Morgan para mover as negações para dentro dos quantificadores e proposições;\nPadronizar Variáveis: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas;\nMover Quantificadores para Fora: mova todos os quantificadores para a esquerda da expressão, mantendo a ordem relativa quando necessário para preservar o significado.\n\nA Forma Normal Prenex é uma representação canônica de fórmulas da lógica de primeira ordem que separa claramente os quantificadores da matriz da fórmula. Ela é uma ferramenta amplamente utilizada na lógica e na teoria da prova, e sua compreensão é essencial para trabalhar com lógica de primeira ordem, especialmente na Lógica de Primeira Ordem e teoria da prova, ambas aplicadas na Programação Lógica.\n\n7.2.1.1 Regras de Equivalência Prenex\nA Forma Prenex de uma fórmula lógica com quantificadores contém todos os quantificadores para o início da fórmula. Existem algumas regras de equivalência que preservam a Forma Prenex quando aplicadas a uma fórmula:\n1. Comutatividade de quantificadores do mesmo tipo: a ordem dos quantificadores do mesmo tipo pode ser trocada em uma fórmula na Forma Prenex. Por exemplo:\n\\[\n\\forall x \\forall y \\ P(x,y) \\Leftrightarrow \\forall y \\forall x \\ P(x,y)\n\\]\nIsso ocorre porque a ordem dos quantificadores universais \\(\\forall x\\) e \\(\\forall y\\) não altera o significado lógico da fórmula. Essa propriedade é conhecida como comutatividade dos quantificadores.\n2. Associatividade de quantificadores do mesmo tipo: quantificadores do mesmo tipo podem ser agrupados de forma associativa em uma Forma Prenex. Por exemplo:\n\\[\n\\forall x \\forall y \\forall z \\ P(x,y,z) \\Leftrightarrow \\forall x (\\forall y \\forall z \\ P(x,y,z))\n\\]\nNovamente, o agrupamento dos quantificadores universais não muda o significado da fórmula. Essa é a propriedade associativa.\n3. Distributividade de quantificadores sobre operadores lógicos: existem regras específicas para a distribuição de quantificadores:\n\nO quantificador universal distribui sobre conjunção:\n\n\\[\n\\forall x (P(x) \\wedge Q(x)) \\Leftrightarrow (\\forall x \\ P(x)) \\wedge (\\forall x \\ Q(x))\n\\]\n\nO quantificador existencial distribui sobre disjunção:\n\n\\[\n\\exists x (P(x) \\vee Q(x)) \\Leftrightarrow (\\exists x \\ P(x)) \\vee (\\exists x \\ Q(x))\n\\]\nNote que \\(\\forall\\) não distribui sobre \\(\\vee\\) e \\(\\exists\\) não distribui sobre \\(\\wedge\\).\n\n\n7.2.1.2 Conversão para Formas Normais Conjuntiva e Disjuntiva\nA conversão para formas clausais (CNF/DNF) em lógica de primeira ordem segue estes passos:\n1. Eliminar Implicações: substitua todas as ocorrências de implicação da forma \\(A \\rightarrow B\\) por \\(\\neg A \\vee B\\).\n2. Mover a Negação para Dentro: use as leis de De Morgan para mover a negação para dentro dos quantificadores e das proposições:\n\n\\(\\neg \\forall x P(x) \\Leftrightarrow \\exists x \\neg P(x)\\)\n\\(\\neg \\exists x P(x) \\Leftrightarrow \\forall x \\neg P(x)\\)\n\n3. Padronizar Variáveis: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas, renomeando-as se necessário.\n4. Converter para Forma Normal Prenex: mova todos os quantificadores para o prefixo, preservando a ordem relativa.\n5. Eliminar os Quantificadores Existenciais (Skolemização): substitua cada quantificador existencial \\(\\exists x\\) por um novo termo constante ou Função Skolem, dependendo das variáveis quantificadas universalmente à esquerda no prefixo Prenex:\n\nSe o quantificador existencial não tem quantificadores universais à sua esquerda: Substitua \\(\\exists x P(x)\\) por \\(P(c)\\), sendo que \\(c\\) é uma nova constante.\nSe o quantificador existencial tem quantificadores universais à sua esquerda: Substitua \\(\\exists x P(x)\\) por \\(P(f(y_1, y_2, \\ldots, y_n))\\), sendo que \\(f\\) é uma nova função Skolem, e \\(y_1, y_2, \\ldots, y_n\\) são as variáveis universais à esquerda do quantificador existencial.\n\n6. Eliminar os Quantificadores Universais: remova os quantificadores universais, deixando apenas a matriz da fórmula. As variáveis que eram ligadas pelo quantificador universal agora são tratadas como variáveis livres na matriz da fórmula.\n7. Conversão para Forma Normal Conjuntiva ou Forma Normal Disjuntiva:\n\nPara Forma Normal Conjuntiva: use as leis distributivas para converter a matriz em uma conjunção de disjunções (cláusulas)\nPara Forma Normal Disjuntiva: use as leis distributivas para converter a matriz em uma disjunção de conjunções\n\n\n\n7.2.1.3 Exemplo 1 - Duas fórmulas logicamente equivalentes\nVamos considerar duas fórmulas logicamente equivalentes, uma na Forma Prenex e outra não. Considere a fórmula original:\n\\[\n\\forall x \\exists y (P(x) \\rightarrow Q(y))\n\\]\nSe convertida para a Forma Prenex teremos:\n\\[\n\\exists y \\forall x (P(x) \\rightarrow Q(y))\n\\]\nA equivalência pode ser demonstrada por meio do seguinte raciocínio: seja \\(I\\) uma interpretação (estrutura) para os predicados \\(P\\) e \\(Q\\) em um domínio não vazio.\nSuponha \\(I\\) satisfaz \\(\\forall x \\exists y (P(x) \\rightarrow Q(y))\\). Existem dois casos a considerar:\n\nSe não existe nenhum \\(x\\) tal que \\(P(x)\\) seja verdadeiro, então a implicação é vacuamente verdadeira para todos os \\(x\\), e qualquer \\(y\\) satisfará \\(\\exists y \\forall x (P(x) \\rightarrow Q(y))\\)\nSe existe pelo menos um \\(x\\) tal que \\(P(x)\\) é verdadeiro, então deve existir um \\(y\\) correspondente tal que \\(Q(y)\\) é verdadeiro. Este mesmo \\(y\\) funcionará para todos os \\(x\\), satisfazendo \\(\\exists y \\forall x (P(x) \\rightarrow Q(y))\\)\n\nAssim, existe um \\(y\\) fixo que satisfaz a condição para todo \\(x\\), preservando a equivalência. O raciocínio inverso também se aplica. Portanto, as fórmulas são logicamente equivalentes.\n\n\n7.2.1.4 Exemplo 2 - Conversão para Forma Prenex\nA fórmula:\n\\[\n\\forall x (P(x) \\rightarrow \\exists y Q(x,y))\n\\]\nPode ser convertida para Forma Normal Prenex seguindo os passos:\n\nEliminar implicação: substituir \\(P(x) \\rightarrow \\exists y Q(x,y)\\) por \\(\\neg P(x) \\vee \\exists y Q(x,y)\\)\n\n\\[\n\\forall x (\\neg P(x) \\vee \\exists y Q(x,y))\n\\]\n\nMover quantificadores para fora: extrair \\(\\exists y\\) para a frente, preservando a ordem (∀ antes de ∃)\n\n\\[\n\\forall x \\exists y (\\neg P(x) \\vee Q(x,y))\n\\]\nA ordem dos quantificadores deve ser preservada para manter o significado original da fórmula.\n\n\n7.2.1.5 Exemplo 3 - Conversão para Forma Normal Conjuntiva\nConsidere a fórmula original em Forma Normal Prenex:\n\\[\n\\forall x \\exists y (P(x) \\wedge Q(y))\n\\]\nSiga os passos para conversão para Forma Normal Conjuntiva:\n\nEliminar os Quantificadores Existenciais (Skolemização): O quantificador existencial \\(\\exists y\\) tem um quantificador universal \\(\\forall x\\) à sua esquerda, então substitua por uma função Skolem \\(f(x)\\):\n\n\\[\n\\forall x (P(x) \\wedge Q(f(x)))\n\\]\n\nEliminar os Quantificadores Universais: Remova \\(\\forall x\\), tratando \\(x\\) como variável livre:\n\n\\[\nP(x) \\wedge Q(f(x))\n\\]\n\nConversão para Forma Normal Conjuntiva: A matriz já é uma conjunção de literais, resultando em cláusulas:\n\n\\[\nP(x) \\wedge Q(f(x))\n\\]\nIsso equivale a duas cláusulas: \\(\\{P(x)\\}\\) e \\(\\{Q(f(x))\\}\\).\n\n\n7.2.1.6 Exemplo 4 - Conversão para Forma Normal Conjuntiva\nConsidere a fórmula original:\n\\[\n\\forall x (P(x) \\rightarrow \\exists y Q(x,y))\n\\]\nPrimeiro, converta para Forma Normal Prenex (como no Exemplo 2):\n\\[\n\\forall x \\exists y (\\neg P(x) \\vee Q(x,y))\n\\]\nSiga os passos para conversão para Forma Normal Conjuntiva:\n\nEliminar os Quantificadores Existenciais (Skolemização): O quantificador existencial \\(\\exists y\\) tem \\(\\forall x\\) à sua esquerda, então substitua por \\(f(x)\\):\n\n\\[\n\\forall x (\\neg P(x) \\vee Q(x, f(x)))\n\\]\n\nEliminar os Quantificadores Universais: Remova \\(\\forall x\\):\n\n\\[\n\\neg P(x) \\vee Q(x, f(x))\n\\]\n\nConversão para Forma Normal Conjuntiva: A matriz já é uma disjunção (cláusula única):\n\n\\[\n\\neg P(x) \\vee Q(x, f(x))\n\\]\nIsso resulta na cláusula: \\(\\{\\neg P(x), Q(x, f(x))\\}\\).\n\n\n7.2.1.7 Exemplo 5 - Conversão para Forma Normal Conjuntiva\nConsidere a fórmula original em Forma Normal Prenex:\n\\[\n\\exists x \\forall y (P(x) \\vee Q(y))\n\\]\nSiga os passos para conversão para Forma Normal Conjuntiva:\n\nEliminar os Quantificadores Existenciais (Skolemização): O quantificador existencial \\(\\exists x\\) não tem quantificadores universais à sua esquerda, então substitua por uma constante Skolem \\(c\\):\n\n\\[\n\\forall y (P(c) \\vee Q(y))\n\\]\n\nEliminar os Quantificadores Universais: Remova \\(\\forall y\\):\n\n\\[\nP(c) \\vee Q(y)\n\\]\n\nConversão para Forma Normal Conjuntiva: A matriz é uma disjunção, resultando em uma cláusula única:\n\n\\[\nP(c) \\vee Q(y)\n\\]\nIsso equivale à cláusula: \\(\\{P(c), Q(y)\\}\\).\n\n\n\n\n\n\nWarning\n\n\n\nPreservação vs. Equivalência na Skolemização\nA Skolemização é um processo que preserva a satisfatibilidade mas não preserva a equivalência lógica. Isso significa:\n\nSe a fórmula original é satisfatível, a fórmula skolemizada também será;\nSe a fórmula original é insatisfatível, a fórmula skolemizada também será;\nPorém, a fórmula skolemizada pode ser verdadeira em modelos onde a original é falsa.\n\nEsta distinção é fundamental em: - Provas por refutação: onde buscamos inconsistência (adequado para Skolemização); - Verificação de modelos: onde precisamos preservar verdade (Skolemização inadequada); - Sistemas como Prolog: que utilizam formas clausais skolemizadas para inferência.\nPor isso a Skolemização é apropriada para métodos de prova automática como resolução, mas não para verificação direta de satisfação de fórmulas.\n\n\n\nA conversão para Forma Normal Conjuntiva (forma clausal) é amplamente utilizada em métodos de prova automática como resolução. A conversão para Forma Normal Disjuntiva é menos comum, mas pode ser aplicada em alguns contextos de análise lógica. OBSERVAÇÃO: a Skolemização (eliminação dos quantificadores existenciais) pode alterar a interpretação da fórmula em alguns modelos, mas preserva a satisfatibilidade, sendo apropriada para provas automáticas.\n\n\n\n\n7.2.2 Skolemização\nA Skolemização é como um pescador veterano que transforma indicações vagas de cardumes em coordenadas precisas de pesca. Quando encontramos uma afirmação do tipo ‘há peixes por aqui’, a Skolemização nos permite dizer ’muito bem, vamos marcar este ponto específico no GPS”.\nA criativa leitora pode se imaginar como um mestre de porto organizando o registro de embarcações: em vez de deixar referências vagas como ‘existe um navio cargueiro’, o mestre de porto cria um sistema de registro que permite localizar exatamente qual embarcação estamos procurando, baseados nas necessidades que definem nossos critérios de busca.\nConsidere a fórmula a seguir com um quantificador universal e um existencial:\n\\[\\forall x \\exists y P(x,y)\\]\nAo aplicar a Skolemização, a variável existencial \\(y\\) é substituída por uma Função de Skolem \\(f(x)\\):\n\\[P(x,f(x))\\]\nPara uma fórmula com dois quantificadores universais e dois existenciais:\n\\[\\forall x \\forall z \\exists y \\exists w R(x,y,z,w)\\]\nA Skolemização resultará em:\n\\[\\forall x \\forall z R(x,f(x),z,g(x,z))\\]\n\\(f(x)\\) e $ g(x,z)$ são Funções Skolem introduzidas para substituir as variáveis existenciais \\(y\\) e $w $ respectivamente. A escolha entre Constante e Função Skolem é como decidir entre definir valores definitivos ou sua ação e aplicação:\n\nA Constante Skolem é como batizar um navio com nome fixo, “Santa Maria sempre será Santa Maria”, independente da rota ou tripulação.\nA Função Skolem é como designar um papel dinâmico, “o navio de apoio da embarcação principal”, no qual a identidade específica muda dependendo de qual é a embarcação principal, mas a relação permanece consistente.\n\nSe nossa expedição marítima já tem os tripulantes estabelecidos, as variáveis universais, então nosso novo tripulante existencial precisa se adaptar a eles através de uma função. Isso pode ser feito com as fórmulas lógicas seguindo os seguintes passos:\nPasso 1: Identificar os Quantificadores Existenciais: comece identificando os quantificadores existenciais na fórmula.\nPasso 2: Determinar se a Variável Existencial Depende de Variáveis Universais: para cada variável ligada a um quantificador existencial, determinamos se ela depende ou não de alguma variável universal. Isso significa verificar se existem quantificadores universais que dominam a variável existencial. Se a variável existencial não depende de variáveis universais, usamos uma Constante de Skolem. Caso contrário, usamos uma Função de Skolem que leva como parâmetros as variáveis universais que a dominam.\nPasso 3: Substituir as Variáveis Existenciais: agora, substituímos todas as variáveis existenciais na fórmula original de acordo com as decisões tomadas no Passo 2. Se usarmos Constantes de Skolem, substituímos as variáveis existenciais diretamente pelas constantes. Se usarmos Funções de Skolem, substituímos as variáveis existenciais pelas funções de Skolem aplicadas às variáveis universais apropriadas.\nExemplo 1: considere a Fórmula Bem Formada dada por: \\(\\forall x \\exists y \\, P(x,y)\\)\n\nIdentificação do quantificador existencial: identificamos o quantificador existencial \\(\\exists y\\) que introduz a variável \\(y\\).\nAnálise de dependência: a variável existencial \\(y\\) depende da variável universal \\(x\\), pois o quantificador \\(\\forall x\\) aparece antes de \\(\\exists y\\) na fórmula. Isso significa que para cada valor específico de \\(x\\), existe um valor correspondente de \\(y\\) que pode variar com \\(x\\).\nEscolha da substituição: como \\(y\\) depende de \\(x\\), usamos uma Função de Skolem \\(f(x)\\) (não uma constante). A função \\(f\\) “escolhe” o valor apropriado de \\(y\\) para cada \\(x\\).\nSubstituição: substituímos \\(y\\) por \\(f(x)\\) na fórmula: \\[\\forall x \\ P(x,f(x))\\]\nRemoção dos quantificadores universais: removemos o quantificador universal restante, obtendo a forma final: \\[P(x,f(x))\\]\n\nIntuição: A função Skolem \\(f(x)\\) representa uma “regra de escolha” que, dado qualquer valor de \\(x\\), seleciona o valor apropriado de \\(y\\) que satisfaz \\(P(x,y)\\). Por exemplo, se \\(P(x,y)\\) significa “\\(y\\) é o dobro de \\(x\\)”, então \\(f(x) = 2x\\).\nExemplo 2: considere a fórmula original: \\(\\forall x \\forall z \\exists y \\ Q(x,y,z)\\)\n\nIdentificamos o quantificador existencial que introduz a variável \\(y\\).\nA variável \\(y\\) depende de duas variáveis universais, \\(x\\) e \\(z\\). Portanto, usamos uma Função de Skolem, digamos \\(f(x,z)\\). A fórmula se torna:\n\\[\\forall x \\forall z \\ Q(x,f(x,z),z)\\]\n\nSubstituímos \\(y\\) por \\(f(x,z)\\), que é uma função que depende das variáveis universais \\(x\\) e \\(z\\).\nEm resumo, a Skolemização simplifica fórmulas quantificadas, eliminando quantificadores existenciais e substituindo variáveis por Constantes ou Funções de Skolem, dependendo de sua relação com quantificadores universais. Isso auxilia na conversão de fórmulas quantificadas para a Forma Normal Conjuntiva e na simplificação da lógica.\n\n7.2.2.1 Exemplos de conversão em formas normais, conjuntiva e disjuntiva\n\nTodos os alunos estudam ou alguns professores ensinam matemática\n\nLógica de Primeira Ordem:\n\\[\n\\forall x(\\text{Aluno}(x) \\rightarrow \\text{Estuda}(x)) \\vee \\exists y(\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nConversão para Forma Normal Conjuntiva :\n\nEliminar implicações: converter \\(A \\rightarrow B\\) em \\(\\neg A \\vee B\\).\n\\[\n\\forall x(\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee \\exists y(\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nPadronizar variáveis: as variáveis \\(x\\) e \\(y\\) já são distintas e não há conflito de escopo. Nenhuma alteração é necessária.\nConverter para Forma Normal Prenex: mover todos os quantificadores para a frente da fórmula.\n\\[\n\\forall x \\exists y ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y)))\n\\]\nSkolemização: eliminar o quantificador existencial \\(\\exists y\\). Como \\(y\\) está no escopo de \\(\\forall x\\), ele é substituído por uma função Skolem \\(f(x)\\).\n\\[\n\\forall x ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(f(x)) \\wedge \\text{EnsinaMatemática}(f(x))))\n\\]\nAplicar distributividade: distribuir \\(\\vee\\) sobre \\(\\wedge\\) usando a regra \\((P \\vee (Q \\wedge R)) \\equiv ((P \\vee Q) \\wedge (P \\vee R))\\).\n\\[\n\\forall x ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{Professor}(f(x))) \\wedge (\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{EnsinaMatemática}(f(x))))\n\\]\nRemover quantificadores universais: na forma clausal, os quantificadores universais são implícitos.\n\\[\n(\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{Professor}(f(x))) \\wedge (\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{EnsinaMatemática}(f(x)))\n\\]\n\nResultado final em Forma Normal Conjuntiva: A fórmula está na Forma Normal Conjuntiva, representada como uma conjunção de duas cláusulas.\nConversão para Forma Normal Disjuntiva :\nA conversão para Forma Normal Disjuntiva segue um caminho diferente e não utiliza Skolemização, pois este processo não preserva a equivalência lógica. O ponto de partida correto é a Forma Normal Prenex (passo 3 da conversão anterior).\n\nPonto de Partida (Forma Normal Prenex):\n\\[\n\\forall x \\exists y ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y)))\n\\]\nAnalisar a Matriz da Fórmula: A matriz é a parte da fórmula sem os quantificadores. Vamos analisá-la:\n\\[\n(\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nUma fórmula está em Forma Normal Disjuntiva se for uma disjunção de conjunções de literais. Simplificando a expressão acima (removendo parênteses por associatividade), obtemos:\n\\[\n\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nEsta estrutura já corresponde a uma Forma Normal Disjuntiva. Ela é uma disjunção (termos ligados por \\(\\vee\\)) de três termos: \\(\\neg \\text{Aluno}(x)\\), \\(\\text{Estuda}(x)\\) e a conjunção \\((\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\\). Nenhum passo de distribuição é necessário.\n\nResultado final em Forma Normal Disjuntiva: A Forma Normal Disjuntiva da fórmula, mantendo os quantificadores, é:\n\\[\n\\forall x \\exists y (\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y)))\n\\]\nObservação: A estrutura da fórmula original, uma grande disjunção (\\(P \\vee Q\\)), faz com que ela seja naturalmente próxima da Forma Normal Disjuntiva, exigindo poucos ou nenhum passo de conversão. Em contraste, para chegar à Forma Normal Conjuntiva, foi necessário aplicar a lei da distributividade, resultando em uma expressão mais complexa.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais Organizando o Pensamento Lógico</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#sec-predicativa-conexao-prolog",
    "href": "05-formas-normais-e-skolemizacao.html#sec-predicativa-conexao-prolog",
    "title": "7  Formas Normais Organizando o Pensamento Lógico",
    "section": "7.3 Exercícios de Conexão com Prolog",
    "text": "7.3 Exercícios de Conexão com Prolog\nA conversão de fórmulas para uma Forma Normal (seja Conjuntiva - Forma Normal Conjuntiva, ou Disjuntiva - Forma Normal Disjuntiva) é um processo algorítmico que permite a padronização e a manipulação de expressões lógicas por computadores. Este conjunto de questões foca nesta habilidade, que é a base para o funcionamento de provadores de teoremas e do mecanismo de resolução do Prolog.\nQuestão 1: Conversão Básica: dada a seguinte fórmula lógica, que representa uma regra de negócio simples: “Se o pedido (\\(P\\)) foi aprovado, então a nota fiscal (\\(N\\)) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (\\(E\\)).” Fórmula:\n\\[(P \\to N) \\wedge \\neg (N \\wedge \\neg E)\\]\nConverta esta fórmula para:\n\nA Forma Normal Conjuntiva.\n\nA Forma Normal Disjuntiva.\n\nQuestão 2: Cenários de Ativação de Sistema: um sistema de irrigação automática (\\(I\\)) é ativado se o sensor de umidade do solo indicar que está seco (\\(S\\)) ou se não choveu nas últimas 24 horas (\\(\\neg C\\)) e a temperatura está alta (\\(T\\)).\n\nModele a condição de ativação (\\(I\\)) como uma fórmula lógica.\n\nConverta a fórmula para a Forma Normal Disjuntiva. O que cada termo da Forma Normal Disjuntiva representa em termos de cenários práticos de ativação?\n\nQuestão 3: Verificação de Consistência de Regras: as regras de configuração de um firewall são:\n\nSe uma conexão é da rede interna (\\(I\\)), ela é permitida (\\(P\\)).\n\nSe uma conexão não é da rede interna, ela só é permitida se for uma conexão segura (\\(S\\)).\n\nUma conexão segura nunca vem da rede interna.\n\nModele as três regras como uma única fórmula. Converta-a para a Forma Normal Conjuntiva. A Forma Normal Conjuntiva resultante indica se as regras são consistentes? O que aconteceria se uma conexão fosse segura e viesse da rede interna?\nQuestão 4: Equivalência de Políticas de Segurança: dois administradores de sistemas escreveram políticas de acesso a um servidor de desenvolvimento.\n\nPolítica de Alice: “Um desenvolvedor (\\(D\\)) pode acessar o servidor se tiver uma chave de acesso (\\(C\\)), ou se não tiver uma chave de acesso mas estiver trabalhando em um projeto crítico (\\(P\\)).”\nPolítica de Beto: “Um desenvolvedor (\\(D\\)) pode acessar o servidor se estiver trabalhando em um projeto crítico (\\(P\\)), ou se tiver uma chave de acesso (\\(C\\)).”\n\nModele as duas políticas como fórmulas lógicas e converta ambas para a Forma Normal Disjuntiva Mínima. Elas são logicamente equivalentes?\nQuestão 5: Eliminando a Bicondicional: uma regra de um e-commerce afirma: “Um cliente recebe frete grátis (\\(F\\)) se, e somente se, ele for um membro Prime (\\(P\\)) ou o valor do seu pedido for superior a R$100 (\\(V\\)).”\nFórmula:\n\\[F \\leftrightarrow (P \\vee V)\\]\nConverta esta fórmula para a Forma Normal Conjuntiva. Cada cláusula da Forma Normal Conjuntiva representa que tipo de restrição no sistema?\nQuestão 6: Simplificação de Circuito Lógico: a saída de um circuito lógico com três entradas (\\(A\\), \\(B\\), \\(C\\)) é descrita pela seguinte tabela verdade:\n\n\n\n\\(A\\)\n\\(B\\)\n\\(C\\)\nSaída\n\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n0\n1\n\n\n1\n0\n1\n1\n\n\n1\n1\n0\n0\n\n\n1\n1\n1\n0\n\n\n\n\nEscreva a Forma Normal Disjuntiva canônica a partir da tabela.\nUse um Mapa de Karnaugh ou álgebra booleana para encontrar a Forma Normal Disjuntiva mínima.\n\nQuestão 7: Validando uma Inferência (Tautologia): considere que “Todos os leões são mamíferos” e “Simba é um leão”, podemos concluir “Simba é um mamífero”. Prove que a estrutura lógica desta inferência é uma tautologia:\n\\[((\\forall x(L(x) \\to M(x))) \\wedge L(s)) \\to M(s)\\]\nQuestão 8: Problema de Satisfatibilidade (SAT): três programadores (Ana, Beto, Carla) precisam ser alocados para um projeto. As restrições são:\n\nPelo menos um dos três deve ser alocado;\n\nAna e Beto não podem trabalhar juntos;\nSe Carla for alocada, então Ana também deve ser.\n\nSejam \\(A\\), \\(B\\), \\(C\\) as proposições “Ana foi alocada”, “Beto foi alocado” e “Carla foi alocada”. Modele as três restrições e converta-as para um conjunto de cláusulas em Forma Normal Conjuntiva. O conjunto de restrições é satisfatível? Se sim, apresente uma alocação válida.\nQuestão 9: Forma Normal Prenex: a conversão para Forma Normal Clausal, que veremos no próximo capítulo, muitas vezes começa com a conversão para a Forma Normal Prenex, na qual todos os quantificadores são movidos para o início da fórmula.\nConverta a seguinte fórmula para a Forma Normal Prenex:\n\\[\\forall x (P(x) \\to (\\exists y (Q(y) \\wedge R(x,y)))) \\vee \\exists z S(z)\\]\nQuestão 10: O Princípio da Resolução: o Princípio da Resolução é um método de inferência que opera sobre cláusulas em Forma Normal Conjuntiva. Dadas duas cláusulas \\((\\neg P \\vee Q)\\) e \\((P \\vee R)\\), podemos inferir a cláusula resolvente \\((Q \\vee R)\\).\nUse o Princípio da Resolução para provar que o seguinte conjunto de cláusulas é inconsistente (leva à cláusula vazia, \\(\\square\\)):\n\n\\(\\neg P \\vee \\neg Q \\vee R\\);\n\n\\(P \\vee R\\);\n\n\\(Q\\);\n\n\\(\\neg R\\).",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais Organizando o Pensamento Lógico</span>"
    ]
  },
  {
    "objectID": "06-construcao-de-mundos-logicos.html",
    "href": "06-construcao-de-mundos-logicos.html",
    "title": "8  Mundos na Lógica de Primeira Ordem",
    "section": "",
    "text": "8.0.1 Definição Formal de um Mundo\nNa Lógica de Primeira Ordem, um mundo ou modelo é uma estrutura que consiste em:\nUm modelo \\(M\\) para uma linguagem \\(L\\) é então definido como \\(M = (D, I)\\), sendo que \\(D\\) é o domínio e \\(I\\) é a interpretação.\nNeste exemplo, temos um modelo \\(M\\) no qual:\n\\[M = (\\{1, 2, 3, 4, 5\\}, I)\\]\ncom \\(I\\) definido como acima. Este modelo representa um “mundo” no qual podemos fazer afirmações sobre números inteiros de 1 a 5, suas relações de ordem e paridade.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mundos na **Lógica de Primeira Ordem**</span>"
    ]
  },
  {
    "objectID": "06-construcao-de-mundos-logicos.html#footnotes",
    "href": "06-construcao-de-mundos-logicos.html#footnotes",
    "title": "8  Mundos na Lógica de Primeira Ordem",
    "section": "",
    "text": "GHIDINI, C., & Serafini, L. (2013-2014). Mathematical Logic Exercises. Disponível em: https://disi.unitn.it/~ldkr/ml2014/ExercisesBooklet.pdf.↩︎",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mundos na **Lógica de Primeira Ordem**</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html",
    "href": "07-clausulas-de-horn-e-prolog.html",
    "title": "9  Cláusulas de Horn",
    "section": "",
    "text": "9.0.1 Definição da Cláusula de Horn\nA Cláusula de Horn é uma disjunção de literais que contém, no máximo, um literal positivo. Existem algumas formas equivalentes de representar Cláusulas de Horn:\nTipos de Cláusulas de Horn (baseado na forma disjuntiva \\(\\neg A_1 \\lor \\ldots \\lor \\neg A_k \\lor B\\)):\nPara entender melhor, imagine que estamos construindo um cenário mental fundamentado na lógica para construir o entendimento de um problema, uma espécie de paisagem mental onde as coisas fazem sentido. Nesse cenário, as Cláusulas de Horn serão os tijolos fundamentais que usaremos para construir estruturas lógicas.\n1. Fatos: os fatos são como pedras fundamentais desse cenário. Eles são afirmações simples e diretas que dizem como as coisas são. Considere, por exemplo: O céu é azul, \\(P\\) e A grama é verde\\(Q\\). Essas são verdades que não precisam de justificativa. Elas simplesmente são. os Fatos são axiomas.\n2. Regras: as regras são um pouco mais intrigantes. Elas são como as regras de um jogo que definem como as coisas se relacionam umas com as outras. Se não chover, a grama não ficará molhada. Essa é uma regra. Ela nos diz o que esperar se certas condições forem atendidas. As regras são como os conectores em nosso mundo lógico, ligando fatos e permitindo que façamos inferências. Elas são o motor que nos permite raciocinar e descobrir novas verdades a partir das que já conhecemos. Por exemplo:\n3. Metas ou Consultas: finalmente, temos as metas ou consultas. Essas são as perguntas que fazemos ao nosso mundo lógico. Está chovendo?, A grama está molhada? São os caminhos que usaremos para explorar o cenário criado, olhando ao redor e tentando entender o que está acontecendo. As consultas são a forma de interagir com nosso mundo lógico, usando os fatos e regras que estabelecemos para encontrar respostas e alcançar objetivos. Por exemplo:\nPodemos tentar avaliar alguns exemplos de uso de Fatos, Regras e Consultas:",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#exemplo-3---mundo-núcleo-familiar-lógica-de-primeira-ordem",
    "href": "07-clausulas-de-horn-e-prolog.html#exemplo-3---mundo-núcleo-familiar-lógica-de-primeira-ordem",
    "title": "9  Cláusulas de Horn",
    "section": "9.1 Exemplo 3 - Mundo Núcleo Familiar (Lógica de Primeira Ordem)",
    "text": "9.1 Exemplo 3 - Mundo Núcleo Familiar (Lógica de Primeira Ordem)\nO exemplo a seguir apresenta um mundo que representa uma família e suas relações, apresentado usando a sintaxe da Lógica de Primeira Ordem (FOL).\nFatos: os fatos são representados como predicados aplicados a constantes em FOL.\n\n\\(Homem(joão)\\);\n\\(Homem(pedro)\\);\n\\(Mulher(maria)\\);\n\\(Mulher(ana)\\);\n\\(Progenitor(joão, pedro)\\);\n\\(Progenitor(maria, pedro)\\);\n\\(Progenitor(joão, ana)\\);\n\\(Progenitor(maria, ana)\\).\n\nRegras:\n1. Pai:\n\nForma Implicativa:\n\\[\\forall X \\forall Y (Homem(X) \\land Progenitor(X, Y) \\rightarrow Pai(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y (\\neg Homem(X) \\lor \\neg Progenitor(X, Y) \\lor Pai(X, Y))\\]\n\n2. Mãe:\n\nForma Implicativa:\n\\[\\forall X \\forall Y (Mulher(X) \\land Progenitor(X, Y) \\rightarrow Mae(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y (\\neg Mulher(X) \\lor \\neg Progenitor(X, Y) \\lor Mae(X, Y))\\]\n\n3. Meio-Irmão: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Homem(X) \\land Progenitor(Z, X) \\land Progenitor(Z, Y) \\land X \\neq Y \\rightarrow MeioIrmao(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\lor \\neg Progenitor(Z, X) \\lor \\neg Progenitor(Z, Y) \\lor X = Y \\lor MeioIrmao(X, Y))\\]\n\n4. Meio-Irmã: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Mulher(X) \\land Progenitor(Z, X) \\land Progenitor(Z, Y) \\land X \\neq Y \\rightarrow MeioIrma(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\lor \\neg Progenitor(Z, X) \\lor \\neg Progenitor(Z, Y) \\lor X = Y \\lor MeioIrma(X, Y))\\]\n\n5. Irmão: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall P \\forall M (Homem(X) \\land Pai(P,X) \\land Pai(P,Y) \\land Mae(M,X) \\land Mae(M,Y) \\land X \\neq Y \\rightarrow Irmao(X,Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall P \\forall M (\\neg Homem(X) \\lor \\neg Pai(P,X) \\lor \\neg Pai(P,Y) \\lor \\neg Mae(M,X) \\lor \\neg Mae(M,Y) \\lor X = Y \\lor Irmao(X,Y))\\]\n\n6. Irmã: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall P \\forall M (Mulher(X) \\land Pai(P,X) \\land Pai(P,Y) \\land Mae(M,X) \\land Mae(M,Y) \\land X \\neq Y \\rightarrow Irma(X,Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall P \\forall M (\\neg Mulher(X) \\lor \\neg Pai(P,X) \\lor \\neg Pai(P,Y) \\lor \\neg Mae(M,X) \\lor \\neg Mae(M,Y) \\lor X = Y \\lor Irma(X,Y))\\]\n\n7. Avô:\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Homem(X) \\land Progenitor(X, Z) \\land Progenitor(Z, Y) \\rightarrow Avo(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\lor \\neg Progenitor(X, Z) \\lor \\neg Progenitor(Z, Y) \\lor Avo(X, Y))\\]\n\n8. Avó:\n\nForma Implicativa:\n\\[\\forall X \\forall Y \\forall Z (Mulher(X) \\land Progenitor(X, Z) \\land Progenitor(Z, Y) \\rightarrow Avo(X, Y))\\]\nForma Clausal:\n\\[\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\lor \\neg Progenitor(X, Z) \\lor \\neg Progenitor(Z, Y) \\lor Avo(X, Y))\\]\n\nConsultas (Metas):\n\npai(joão, pedro)\nPara verificar se \\(Pai(joão, pedro)\\) é uma consequência lógica da base de conhecimento, tenta-se provar que a base de conhecimento junto com \\(\\neg Pai(joão, pedro)\\) leva a uma contradição (\\(\\bot\\)). A meta é, portanto: \\[\\neg Pai(joão, pedro)\\]\nirmão(pedro, ana)\nPara verificar se \\(Irmao(pedro, ana)\\) é verdadeiro: \\[\\neg Irmao(pedro, ana)\\]\navó(X, ana)\nPara perguntar se “Existe uma avó X para Ana?”, a consulta seria \\(\\exists X (Avo(X, ana) \\land Mulher(X))\\). A forma de meta para refutação seria tentar provar que a base de conhecimento junto com \\(\\forall X (\\neg Avo(X, ana) \\lor \\neg Mulher(X))\\) leva a uma contradição.\n\nEm um sistema de prova por refutação, adicionamos a negação da consulta à base de conhecimento e tentamos derivar uma contradição (\\(\\bot\\)). As representações das metas como negações em FOL estão corretas nesse contexto. #### Exemplo 4 - Torre de Hanói\nA Torre de Hanói é um quebra-cabeça matemático que consiste em três postes e um número de discos de diferentes tamanhos que podem deslizar sobre qualquer poste. O quebra-cabeça começa com os discos empilhados em ordem decrescente de tamanho no primeiro poste, o menor disco no topo. O objetivo é mover toda a pilha para o último poste, obedecendo às seguintes regras:\nPredicados:\n\n\\(Disco(x)\\): \\(x\\) é um disco;\n\\(Poste(x)\\): \\(x\\) é um poste;\n\\(Menor(x)\\): \\(x\\) é o disco menor;\n\\(Maior(x, y)\\): o disco \\(x\\) é maior que o disco \\(y\\);\n\\(Em(x, y)\\): o disco \\(x\\) está no poste \\(y\\);\n\\(Sobre(x, y)\\): o disco \\(x\\) está sobre o disco \\(y\\).\n\nFatos (Cláusulas de Horn Unitárias):\n\n\\(Disco(d_1)\\);\n\\(Disco(d_2)\\);\n\\(Disco(d_3)\\);\n\\(Poste(p_1)\\);\n\\(Poste(p_2)\\);\n\\(Poste(p_3)\\);\n\\(Menor(d_1)\\);\n\\(Maior(d_2, d_1)\\);\n\\(Maior(d_3, d_2)\\).\n\nRegras (Cláusulas de Horn Não-Unitárias):\n\nMovimento válido:\n\\[\\neg Disco(x) \\lor \\neg Poste(y) \\lor \\neg Poste(z) \\lor \\neg Em(x, y) \\lor \\neg DiscoNoTopo(x, y) \\lor \\neg DiscoNoTopo(u, z) \\lor \\neg Maior(x, u) \\lor MovimentoValido(x, y, z)\\]\nCondição de vitória:\n\\[\\neg Disco(x) \\lor \\neg Disco(y) \\lor \\neg Disco(z) \\lor \\neg Em(x, p_3) \\lor \\neg Em(y, p_3) \\lor \\neg Em(z, p_3) \\lor Vitoria()\\]\nDisco válido (nenhum disco maior sobre um menor):\n\\[\\neg Sobre(x, y) \\lor \\neg Maior(x, y) \\lor DiscoValido(x, y)\\]\nMovimento único:\n\\[\\neg Disco(x) \\lor \\neg Disco(y) \\lor \\neg Poste(z) \\lor \\neg Poste(w) \\lor \\neg MovimentoValido(y, z, w) \\lor x = y \\lor MovimentoUnico(x)\\]\nEstado inicial:\n\\[\\neg Em(d_1, p_1) \\lor \\neg Em(d_2, p_1) \\lor \\neg Em(d_3, p_1) \\lor \\neg Sobre(d_3, d_2) \\lor \\neg Sobre(d_2, d_1) \\lor EstadoInicial()\\]\nDisco no topo:\n\\[\\neg Disco(x) \\lor \\neg Poste(y) \\lor \\neg Em(x, y) \\lor \\neg Disco(z) \\lor \\neg Em(z, y) \\lor \\neg Sobre(z, x) \\lor DiscoNoTopo(x, y)\\]\n\nConsultas (Metas):\n\nVerificar se um movimento é válido:\n\\[\\neg MovimentoValido(x, y, z)\\]\nVerificar se o jogo foi vencido:\n\\[\\neg Vitoria()\\]\nVerificar se um disco pode estar sobre outro:\n\\[\\neg DiscoValido(x, y)\\]\nVerificar se apenas um disco está sendo movido:\n\\[\\neg MovimentoUnico(x)\\]\nVerificar o estado inicial:\n\\[\\neg EstadoInicial()\\]\nVerificar se um disco está no topo de um poste:\n\\[\\neg DiscoNoTopo(x, y)\\]\n\n\n9.1.1 Quantificadores em Cláusulas de Horn\nOs quantificadores podem ser incluídos nas Cláusulas de Horn. Contudo, é importante notar que a forma padrão de Cláusulas de Horn em programação lógica geralmente lida com quantificação de forma implícita. A quantificação universal é comum e é geralmente assumida em regras, enquanto a quantificação existencial é muitas vezes tratada através de fatos específicos ou construção de termos.\nPrecisamos tomar cuidado porque a inclusão explícita de quantificadores pode levar a uma Lógica de Primeira Ordem mais rica, permitindo expressões mais complexas e poderosas. No entanto, isso também pode aumentar a complexidade do raciocínio e da resolução.\nO quantificador universal (representado por $$) afirma que uma propriedade é verdadeira para todos os membros de um domínio. Em Cláusulas de Horn, isso é geralmente representado implicitamente através de regras gerais que se aplicam a todos os membros de um conjunto. Por exemplo, considere a regra: Todos os pássaros podem voar. Em uma Cláusula de Horn, isso pode ser representado como:\nEm programação lógica e Cláusulas de Horn, a quantificação é frequentemente tratada implicitamente.\nQuantificador Universal em Regras: considere a afirmação: “Para todo x, se x é um pássaro, então x pode voar.”\n\nFórmula em Lógica de Primeira Ordem** (LPO)**: \\(\\forall x (\\text{Pássaro}(x) \\rightarrow \\text{Voa}(x))\\)\nForma clausal (Cláusula de Horn equivalente): \\(\\neg \\text{Pássaro}(x) \\lor \\text{Voa}(x)\\) (Aqui, \\(x\\) é implicitamente quantificado universalmente.)\nRepresentação em Prolog: voa(X) :- passaro(X). (A variável X é implicitamente quantificada universalmente.)\n\nQuantificador Existencial e Fatos: considere a afirmação: “Existe um pássaro que não pode voar.” * Fórmula em LPO: \\(\\exists x (\\text{Pássaro}(x) \\land \\neg \\text{Voa}(x))\\) * Tratamento em sistemas de Cláusulas de Horn: Afirmações existenciais puras como \\(\\exists x \\Phi(x)\\) não são diretamente representadas como regras de Cláusula de Horn. Para incorporar tal conhecimento, se o indivíduo específico for conhecido, ele é afirmado como um conjunto de fatos. Por exemplo, se sabemos que “Pengu” é um pássaro e não voa: * Fatos em Prolog: passaro(pengu). nao_voa(pengu). (ou voa(pengu) :- fail.)\n\nSe a existência é conhecida mas o indivíduo não é nomeado, em processos de prova teórica (como resolução), a Skolemização substituiria \\(x\\) por uma nova constante (constante de Skolem), resultando em: \\(\\text{Pássaro}(c) \\land \\neg \\text{Voa}(c)\\). Estes seriam então fatos no sistema: \\(\\text{Pássaro}(c).\\) e \\(\\neg \\text{Voa}(c).\\) (ou um predicado para a negação).\n\n\n\n9.1.2 Conversão de Fórmulas\nSeja uma Fórmula Bem Formada arbitrária da Lógica Proposicional. Alguns passos podem ser aplicados para obter uma cláusula de Horn equivalente:\n\nConverter a fórmula para Forma Normal Conjuntiva (FNC), obtendo uma conjunção de disjunções\nAplicar as seguintes técnicas em cada disjunção:\n\nInverter a polaridade de literais positivos extras;\nAdicionar literais negativos que preservem a satisfatibilidade;\nDividir em cláusulas menores se necessário.\n\nSimplificar a fórmula final obtida.\n\n\n9.1.2.1 Exemplo 1: dada a fórmula\n\\[(P \\land Q) \\lor (P \\land R)\\]\nPassos:\n\nConverter para FNC: \\((P \\lor Q) \\land (P \\lor R)\\);\nInverter P em uma das disjunções: \\((P \\lor Q) \\land (\\neg P \\lor R)\\);\nAdicionar literal negativo: \\((P \\lor Q \\lor \\neg S) \\land (\\neg P \\lor R \\lor \\neg T)\\);\nSimplificar: $S P T r $.\n\nA sequência destes passos permite encontrar uma conjunção de cláusulas de Horn equivalente à fórmula original.\n\n\n9.1.2.2 Transformação de Forma Normal Conjuntiva (FNC) para Cláusulas de Horn\nA Forma Normal Conjuntiva é uma conjunção de disjunções de literais. Uma Cláusula de Horn é um tipo especial de cláusula que contém no máximo um literal positivo. Considere que o objetivo das Cláusulas de Horn é criar um conjunto de Fórmulas Bem Formadas, divididas em Fatos, Regras e Consultas para permitir a resolução de problemas então, a transformação de uma FNC para Cláusulas de Horn pode incorrer em alguns problemas:\n\nPerda de Informação: Nem todas as cláusulas em FNC podem ser transformadas em Cláusulas de Horn. Para minimizar este risco atente para as regras de equivalência que vimos anteriormente.\nComplexidade: A transformação pode ser complexa e requer uma análise cuidadosa da lógica e do contexto.\n\nEtapas de Transformação\n\nConverter para FNC: Se a fórmula ainda não estiver em Forma Normal Conjuntiva, converta-a para Forma Normal Conjuntiva usando as técnicas descritas anteriormente;\nIdentificar Cláusulas de Horn: Verifique cada cláusula na Forma Normal Conjuntiva. Se uma cláusula contém no máximo um literal positivo, ela já é uma Cláusula de Horn;\nTransformar Cláusulas Não-Horn: Se uma cláusula contém mais de um literal positivo, ela não pode ser diretamente transformada em uma Cláusula de Horn sem perder informações.\n\n\n9.1.2.2.1 Exemplo 1: vamos considerar a seguinte Fórmula Bem Formada\n\\[(A \\rightarrow B) \\land (B \\lor C)\\]\n\nConverter para FNC:\n\nElimine a implicação: \\((\\neg A \\lor B) \\land (B \\lor C)\\);\nA fórmula já está em Forma Normal Conjuntiva.\n\nIdentificar Cláusulas de Horn:\n\nAmbas as cláusulas são Cláusulas de Horn, pois cada uma contém apenas um literal positivo.\n\nResultado:\n\nA fórmula em Cláusulas de Horn é: \\((\\neg A \\lor B) \\land (B \\lor C)\\)\n\n\n\n\n\n9.1.2.3 Problemas interessantes resolvidos com a Cláusula de Horn\nProblema 1 - O Mentiroso e o Verdadeiro:: Você encontra dois habitantes: \\(A\\) e \\(B\\). Você sabe que um sempre diz a verdade e o outro sempre mente, mas você não sabe quem é quem. Você consulta a \\(A\\), Você é o verdadeiro? A responde, mas você não consegue ouvir a resposta dele. \\(B\\) então te diz, A disse que ele é o mentiroso.\nFatos:\n\\(mentiroso(A)\\) \\(verdadeiro(B)\\)\nRegra:\n\\[\n\\forall x \\forall y (mentiroso(x) \\wedge consulta(y, \\text{Você é o verdadeiro?}) → Responde (x, \\text{Sou o mentiroso}))\n\\]\nConsulta:\n\\[ responde (A, \\text{Sou o mentiroso})?\\]\nProblema 2 - As Três Lâmpadas: existem três lâmpadas incandescentes em uma sala, e existem três interruptores fora da sala. Você pode manipular os interruptores o quanto quiser, mas só pode entrar na sala uma vez. Como você pode determinar qual interruptor opera qual lâmpada?\nFatos:\n\\(Interruptor(s_1)\\) \\(Interruptor(s_2)\\) \\(Interruptor(s_3)\\)\n\\(Lâmpada(b_1)\\) \\(Lâmpada(b_2)\\) \\(Lâmpada(b_3)\\)\nRegras:\n\\[\\forall x \\forall y (Interruptor(x) \\wedge Ligado(x) \\wedge Lâmpada(y) \\rightarrow Acende (y))\\]\n\\[\\forall x (Lâmpada(x) \\wedge FoiLigada(x) \\wedge AgoraDesligada(x) \\rightarrow EstáQuente (x))\\]\nConsulta:\n\\[Acende (b_2, s_2)?\\]\n\\[ estáQuente (b_1)?\\]\nProblema 3 - O Agricultor, a Raposa, o Ganso e o Grão: um agricultor quer atravessar um rio e levar consigo uma raposa, um ganso e um saco de grãos. O barco do agricultor só lhe permite levar um item além dele mesmo. Se a raposa e o ganso estiverem sozinhos, a raposa comerá o ganso. Se o ganso e o grão estiverem sozinhos, o ganso comerá o grão. Como o agricultor pode levar todas as suas posses para o outro lado do rio?\nFatos:\n\n\\(Raposa(r)\\);\n\\(Ganso(g)\\);\n\\(Grao(gr)\\).\n\nNestes fatos a atenta leitora deve observar que ‘\\(r\\)’ é uma raposa, ‘\\(g\\)’ é um ganso, e ‘\\(gr\\)’ é um saco de grãos.\nRegras:\n\nSe \\(x\\) é uma Raposa e \\(y\\) é um Ganso, e \\(x\\) e \\(y\\) estão sozinhos, então \\(x\\) come \\(y\\):\n\n\\[\\forall x \\forall y (Raposa(x) \\land Ganso(y) \\land Sozinhos(x, y) \\rightarrow Come(x, y))\\]\n\nSe \\(x\\) é um Ganso e \\(y\\) é Grão, e \\(x\\) e \\(y\\) estão sozinhos, então \\(x\\) come \\(y\\):\n\n\\[\\forall x \\forall y (Ganso(x) \\land Grao(y) \\land Sozinhos(x, y) \\rightarrow Come(x, y))\\]\nO predicado \\(Sozinhos(Item1, Item2)\\) significaria que \\(Item1\\) e \\(Item2\\) estão em uma margem do rio sem o agricultor. O predicado \\(Come(Predador, Presa)\\) significa que o predador come a presa.\nConsulta:\nAs consultas visam verificar se, em um determinado estado da travessia, certas condições de não comer são satisfeitas. Para um sistema de prova, estas seriam as metas a serem mantidas verdadeiras, ou suas negações a serem evitadas.\n\nA raposa \\(r\\) não come o ganso \\(g\\) (ou seja, é falso que \\(r\\) come \\(g\\))?\n\n\\[\\neg Come(r, g)\\]\n\nO ganso \\(g\\) não come o grão \\(gr\\) (ou seja, é falso que \\(g\\) come \\(gr\\))?\n\n\\[\\neg Come(g, gr)\\]\nEstas consultas, no contexto da resolução do problema, representam estados seguros que devem ser mantidos durante toda a travessia. A solução do problema envolve encontrar uma sequência de movimentos que leve todos ao outro lado do rio sem nunca satisfazer as condições de \\(Come(r,g)\\) ou \\(Come(g,gr)\\) quando o agricultor não está presente para supervisionar.\nProblema 4 - A Ponte e a Tocha: quatro pessoas chegam a um rio à noite. Há uma ponte estreita, mas ela só pode conter duas pessoas de cada vez. Eles têm uma tocha e, por ser noite, a tocha tem que ser usada ao atravessar a ponte. A pessoa A pode atravessar a ponte em um minuto, B em dois minutos, C em cinco minutos e D em oito minutos. Quando duas pessoas atravessam a ponte juntas, elas devem se mover no ritmo da pessoa mais lenta. Qual é a forma mais rápida para todos eles atravessarem a ponte?\nFatos (tempos):\n\n\\(tempo(a, 1)\\);\n\\(tempo(b, 2)\\);\n\\(tempo(c, 5)\\);\n\\(tempo(d, 8)\\).\n\nRegras:\n\nRegra para determinar qual pessoa é mais lenta:\n\\[\\neg tempo(X, TX) \\lor \\neg tempo(Y, TY) \\lor \\neg maior(TX, TY) \\lor mais\\_lento(X, Y, X)\\]\n\\[\\neg tempo(X, TX) \\lor \\neg tempo(Y, TY) \\lor \\neg maior(TY, TX) \\lor mais\\_lento(X, Y, Y)\\]\nRegra para calcular o tempo quando duas pessoas atravessam juntas:\n\\[\\neg mais\\_lento(X, Y, Z) \\lor \\neg tempo(Z, T) \\lor tempo\\_travessia(X, Y, T)\\]\nRelações “maior que” definidas como fatos:\n\n\\(maior(2, 1)\\);\n\\(maior(5, 1)\\);\n\\(maior(5, 2)\\);\n\\(maior(8, 1)\\);\n\\(maior(8, 2)\\);\n\\(maior(8, 5)\\).\n\nRegras para representar o plano de travessia:\n\\[\\neg atravessa\\_ida(X, Y, T1) \\lor \\neg volta(Z, T2) \\lor \\neg atravessa\\_ida(W, V, T3) \\lor \\neg volta(U, T4) \\lor \\neg atravessa\\_ida(S, R, T5) \\lor travessia\\_completa(T1+T2+T3+T4+T5)\\]\nOnde as variáveis representam as pessoas que atravessam em cada fase da solução.\n\nConsulta:\n\\[travessia\\_completa(15)?\\]\nEsta consulta verifica se existe um plano de travessia que soma exatamente 15 minutos, representando a solução ótima para o problema.\nProblema 5 - O Problema de Monty Hall: em um programa de game show, os concorrentes tentam adivinhar qual das três portas contém um prêmio valioso. Depois que um concorrente escolhe uma porta, o apresentador, que sabe o que está por trás de cada porta, abre uma das portas não escolhidas para revelar uma cabra (representando nenhum prêmio). O apresentador então pergunta ao concorrente se ele quer mudar sua escolha para a outra porta não aberta ou ficar com sua escolha inicial. O que o concorrente deve fazer para maximizar suas chances de ganhar o prêmio?\nFatos:\n\n\\(Porta(d_1)\\);\n\\(Porta(d_2)\\);\n\\(Porta(d_3)\\).\n\nRegras:\n\\[\\forall x Prêmio(x) \\rightarrow Porta(x)\\]\n\\[\\forall x \\forall y (Porta(x) \\wedge Porta(y) \\wedge x \\neq y \\rightarrow \\neg Prêmio(x) \\vee \\neg Prêmio(y))\\]\nConsulta:\n\\[\\exists x (Porta(x) \\wedge \\neg Revelada(x) \\wedge x \\neq PortaEscolhida \\rightarrow Prêmio(x))?\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "href": "07-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "title": "9  Cláusulas de Horn",
    "section": "9.2 O Prolog Entra em Cena",
    "text": "9.2 O Prolog Entra em Cena\nO Prolog é uma linguagem de programação lógica que utiliza Cláusulas de Horn para representar e manipular conhecimento. A sintaxe e a semântica do Prolog são diretamente mapeadas para Cláusulas de Horn:\n\nFatos: Em Prolog, fatos são representados como cláusulas sem antecedentes. Por exemplo, o fato John é humano pode ser representado como humano(john).\nRegras: As regras em Prolog são representadas como implicações, onde os antecedentes são literais negativos e o consequente é o literal positivo. Por exemplo, a regra Se X é humano, então X é mortal pode ser representada como mortal(X) :- humano(X).\nConsultas: As consultas em Prolog são feitas ao sistema para inferir informações com base nos fatos e regras definidos. Por exemplo, a consulta “Quem é mortal?” pode ser representada como ?- mortal(X).\n\nO Prolog utiliza um mecanismo de resolução baseado em Cláusulas de Horn para responder a consultas. Ele aplica uma técnica de busca em profundidade para encontrar uma substituição de variáveis que satisfaça a consulta.\n\n9.2.0.1 Exemplo 1: O mais simples possível\nFatos:\nhomem(joão).\nmulher(maria).\nOs fatos indicam que “João é homem” e “maria é mulher”.\nRegra:\nmortal(X) :- homem(X).\nA regra estabelece que “Se \\(X\\) é homem, então \\(X\\) é mortal”. O símbolo \\(:-\\) representa implicação.\nConsulta:\nmortal(joão).\nA consulta verifica se “João é mortal”, aplicando a regra definida anteriormente. O Prolog responderá True (verdadeiro ou \\(\\top\\)) pois a regra se aplica dado o fato de que João é homem.\n\n\n9.2.0.2 Exemplo 2: Sistema de Recomendação de Roupas em Prolog\nImagine que estamos construindo um sistema lógico simples em Prolog para recomendar o tipo de roupa que uma pessoa deve vestir com base no clima. Vamos usar Cláusulas de Horn para representar o conhecimento e a lógica do sistema.\nFatos: primeiro, estabelecemos os fatos, que são as verdades básicas sobre o mundo. Neste caso, os fatos podem ser informações sobre o clima atual.\n\nFato 1: está ensolarado.\n\n ensolarado.\n\nFato 2: a temperatura está acima de 20°C.\n\n temperatura_acima_de_20.\nRegras: em seguida, definimos as regras que descrevem como as coisas se relacionam. Essas regras nos dizem o tipo de roupa apropriada com base no clima.\n\nRegra 1: se está ensolarado e a temperatura está acima de 20°C, use óculos de sol.\n\n óculos_de_sol :- ensolarado, temperatura_acima_de_20.\n\nRegra 2: se está ensolarado, use chapéu.\n\n chapéu :- ensolarado.\n\nRegra 3: se a temperatura está acima de 20°C, use camiseta.\n\n camiseta :- temperatura_acima_de_20.\nAgora, podemos fazer consultas ao nosso sistema para obter recomendações de roupas.\n\nConsulta 1: está ensolarado e a temperatura está acima de 20°C. O que devo vestir?\n\n ?- óculos_de_sol, chapéu, camiseta.\n\n\n9.2.0.3 Exemplo 3: Torre de Hanói\n% Fatos\ndisco(d1).\ndisco(d2).\ndisco(d3).\nposte(p1).\nposte(p2).\nposte(p3).\nmenor(d1).\nmaior(d2, d1).\nmaior(d3, d2).\n\n% Regras (Cláusulas de Horn)\n\n% Um disco está em um poste\nem(D, P) :- disco(D), poste(P).\n\n% Um disco está sobre outro\nsobre(D1, D2) :- disco(D1), disco(D2), maior(D1, D2).\n\n% Movimento válido\nmovimento_valido(D, P1, P2) :-\n    em(D, P1),\n    poste(P2),\n    P1 \\= P2,\n    \\+ (em(D2, P2), menor(D2, D)).\n\n% Condição de vitória\nvitoria :-\n    disco(D1),\n    disco(D2),\n    disco(D3),\n    em(D1, p3),\n    em(D2, p3),\n    em(D3, p3).\n\n% Regra de que nenhum disco pode estar sobre um disco menor\ndisco_valido(D1, D2) :-\n    disco(D1),\n    disco(D2),\n    maior(D1, D2).\n\n% Apenas um disco pode ser movido de cada vez\nmovimento_unico(D) :-\n    disco(D),\n    \\+ (disco(D2), D \\= D2, movimento_valido(D2, _, _)).\n\n% Estado inicial\nestado_inicial :-\n    em(d1, p1),\n    em(d2, p1),\n    em(d3, p1),\n    sobre(d3, d2),\n    sobre(d2, d1).\n\n% Consultas possíveis\n% ?- movimento_valido(D, P1, P2).\n% ?- vitoria.\n% ?- disco_valido(D1, D2).\n% ?- movimento_unico(D).\n% ?- estado_inicial.\n\n9.2.0.3.1 Exemplo 4: O Narrador é seu próprio avô\nO problema do narrador que é seu próprio avô é um exemplo clássico de raciocínio lógico e relações familiares. O problema envolve a construção de uma base de conhecimento que representa as relações familiares e a aplicação de regras lógicas para determinar se o narrador realmente é seu próprio avô. Este exemplo foi publicado por Niklaus Wirth em seu livro Algorithms + Data Structures = Programs 1 fazendo referência a um problema que havia sido publicado em um jornal de Zürich em 1922, que cito em tradução livre a seguir:\nCasei com uma viúva (vamos chamá-la de W) que tem uma filha adulta (chame-a de D). Meu pai (F), que nos visitava com bastante frequência, apaixonou-se pela minha enteada e casou-se com ela. Por isso, meu pai se tornou meu genro e minha enteada se tornou minha madrasta. Alguns meses depois, minha esposa deu à luz um filho (S1), que se tornou cunhado do meu pai, e meu tio. A esposa do meu pai, ou seja, minha enteada, também teve um filho (S2). Em outras palavras, para todos os efeitos, eu sou meu próprio avo.\nUsando este relato como base podemos criar uma base de conhecimento em Prolog, incluir algumas regras, e finalmente verificar se é verdade que o narrador é o seu próprio avô.\n % predicados\nhomem(narrador).\nhomem(f).\nhomem(s1).\nhomem(s2).\n\n% Predicados para relações baseadas em casamentos\nparentesco_legal(narrador,w).\nparentesco_legal(narrador,f).\n\n% relações de parentesco, filhos, netos de sangue\nparentesco(w,d).\nparentesco(f,narrador).\nparentesco(narrador,s1).\nparentesco(f,s2).\n\n% Regras para definir, pai, padrasto e avo\npai(X,Y) :- homem(X), parentesco(X,Y).\npadrasto(X,Y) :-  homem(X), parentesco_legal(X,Y).\navo(X,Z) :- (pai(X,Y); padrasto(X,Y)), (pai(Y,Z) ; padrasto(Y,Z)).\n\n%pergunte se o narrador é avo dele mesmo avo(narrador,narrador)",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "07-clausulas-de-horn-e-prolog.html#footnotes",
    "href": "07-clausulas-de-horn-e-prolog.html#footnotes",
    "title": "9  Cláusulas de Horn",
    "section": "",
    "text": "WIRTH, Niklaus. Algorithms and Data Structures. [S.l.]: [s.n.], [s.d.]. Disponível em: https://cdn.preterhuman.net/texts/math/Data_StructureANDAlgorithms/Algorithms%20and%20Data%20Structures%20-%20Niklaus%20Wirth.pdf.↩︎",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cláusulas de Horn</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html",
    "href": "08-verificacao-formal-de-programas.html",
    "title": "10  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "",
    "text": "10.0.1 Princípios fundamentais e triplas de Hoare\nA lógica de Hoare, desenvolvida por Tony Hoare em 1969, revolucionou a verificação formal ao estabelecer uma base axiomática para provar a correção de programas. O conceito central reside nas triplas de Hoare, que têm a forma {P} C {Q}, em que P representa a pré-condição (propriedade verdadeira antes da execução), C o comando ou programa, e Q a pós-condição (propriedade verdadeira após a execução).\nEsta notação expressa uma relação fundamental: “se P é verdadeiro antes da execução de C, e se C termina, então Q será verdadeiro após a execução de C”. Esta interpretação estabelece a base para correção parcial, distinguindo-se da correção total que também garante terminação.\nOs axiomas fundamentais da lógica de Hoare incluem o axioma da atribuição {Q[E/V]} V := E {Q}, que estabelece que para provar Q após a atribuição V := E, devemos provar Q com E substituído por V antes da atribuição. A regra de sequência {P} C1 {R}, {R} C2 {Q} / {P} C1; C2 {Q} permite compor provas de comandos sequenciais através de condições intermediárias.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "href": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "title": "10  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "10.1 Indução Estrutural: Verificação de Programas Recursivos",
    "text": "10.1 Indução Estrutural: Verificação de Programas Recursivos\n\n10.1.1 Princípios fundamentais e diferenças com indução matemática\nA indução estrutural estende a indução matemática tradicional para estruturas de dados definidas recursivamente. Enquanto a indução matemática opera sobre números naturais com estrutura linear, a indução estrutural aplica-se a estruturas como listas, árvores, e fórmulas lógicas que possuem múltiplas formas de construção.\nA indução matemática tradicional prova propriedades P(n) para números naturais através de um caso base P(0) e um caso indutivo P(k) → P(k+1). A indução estrutural generaliza este princípio para estruturas recursivamente definidas, em que múltiplos construtores podem criar novas instâncias a partir de instâncias existentes.\nPara estruturas de dados indutivos, a indução estrutural baseia-se em uma ordenação bem-fundada. Por exemplo, para listas, a relação “ser sublista de” é bem-fundada, e para árvores, “ser subárvore de” estabelece a ordem necessária. Esta fundamentação garante que toda sequência decrescente é finita, permitindo provas por indução.\n\n\n10.1.2 Aplicação para verificação de programas recursivos\nA indução estrutural é especialmente poderosa na verificação de programas funcionais que operam sobre tipos de dados algébricos. Considere a verificação da propriedade de associatividade para concatenação de listas:\n\nTheorem 10.1 (Associatividade da Concatenação) Para quaisquer listas xs, ys, e zs, a seguinte propriedade é válida: \\[\nxs \\oplus (ys \\oplus zs) = (xs \\oplus ys) \\oplus zs\n\\]\n\n\nProof. A prova é por indução estrutural em xs.\nCaso base: xs = [] \\[\n[] \\oplus (ys \\oplus zs) = ys \\oplus zs = ([] \\oplus ys) \\oplus zs\n\\]\nCaso indutivo: xs = h::t\nAssumimos a hipótese indutiva (H.I.): \\(t \\oplus (ys \\oplus zs) = (t \\oplus ys) \\oplus zs\\). \\[\n\\begin{aligned}\n  (h::t) \\oplus (ys \\oplus zs) &= h :: (t \\oplus (ys \\oplus zs)) \\\\\n                              &= h :: ((t \\oplus ys) \\oplus zs) \\quad \\text{[por H.I.]} \\\\\n                              &= (h :: (t \\oplus ys)) \\oplus zs \\\\\n                              &= ((h::t) \\oplus ys) \\oplus zs\n\\end{aligned}\n\\]\n\nEsta prova demonstra como a estrutura recursiva dos dados guia naturalmente a estrutura da prova, com cada constructor da estrutura correspondendo a um caso na indução.\n\n\n10.1.3 Provas de correção de algoritmos funcionais\nA indução estrutural permite provar correção de algoritmos complexos sobre estruturas recursivas. Para funções sobre árvores, consideremos a verificação de que a reflexão é uma involução:\n\nTheorem 10.2 (Reflexão como Involução) Para qualquer árvore t, a reflexão da reflexão de t é igual a t. \\[\n\\text{reflect}(\\text{reflect}(t)) = t\n\\]\n\n\nProof. A prova é por indução estrutural em t.\nCaso base: t = Leaf \\[\n\\text{reflect}(\\text{reflect}(\\text{Leaf})) = \\text{reflect}(\\text{Leaf}) = \\text{Leaf}\n\\]\nCaso indutivo: t = Node(l, v, r)\nAssumimos a H.I.: \\(\\text{reflect}(\\text{reflect}(l)) = l \\land \\text{reflect}(\\text{reflect}(r)) = r\\). \\[\n\\begin{aligned}\n  &\\text{reflect}(\\text{reflect}(\\text{Node}(l, v, r))) \\\\\n  &= \\text{reflect}(\\text{Node}(\\text{reflect}(r), v, \\text{reflect}(l))) \\\\\n  &= \\text{Node}(\\text{reflect}(\\text{reflect}(l)), v, \\text{reflect}(\\text{reflect}(r))) \\\\\n  &= \\text{Node}(l, v, r) \\quad \\text{[por H.I.]}\n\\end{aligned}\n\\]\n\nEsta prova ilustra como hipóteses indutivas múltiplas (para subárvores esquerda e direita) são necessárias para construtores com múltiplos argumentos recursivos.\n\n\n10.1.4 Exemplos práticos com funções recursivas\nA verificação de algoritmos de ordenação por inserção demonstra a aplicação prática da indução estrutural:\n\nTheorem 10.3 (Correção do Insertion Sort) Para qualquer lista lst, o algoritmo insertion_sort produz uma lista ordenada que contém os mesmos elementos da lista original. \\[\n\\forall \\text{lst}, \\text{sorted}(\\text{insertion\\_sort}(\\text{lst})) \\land \\text{same\\_elements}(\\text{lst}, \\text{insertion\\_sort}(\\text{lst}))\n\\]\n\n\nProof. A prova é por indução estrutural em lst.\nCaso base: lst = [] O resultado de insertion_sort([]) é []. A lista vazia é ordenada e contém os mesmos elementos que a original.\nCaso indutivo: lst = h::t Assumimos a H.I.: \\(\\text{sorted}(\\text{insertion\\_sort}(t)) \\land \\text{same\\_elements}(t, \\text{insertion\\_sort}(t))\\).\nSabemos que insertion_sort(h::t) é insert(h, insertion_sort(t)). A prova depende de um lema auxiliar que afirma que a função insert preserva tanto a ordenação quanto a coleção de elementos. Assumir a validade do lema nos permite concluir que a propriedade do teorema é mantida.\n\nO uso de lemmas auxiliares é frequentemente necessário para provas complexas, permitindo decomposição modular das verificações.\n\n\n10.1.5 Relação com tipos de dados indutivos e coinductivos\nA indução estrutural aplica-se naturalmente a tipos de dados indutivos, que são construídos através de construtores finitos. Tipos indutivos como listas e árvores são definidos através de casos base (lista vazia, folha) e casos recursivos (cons, nó interno).\nPor contraste, tipos coinductivos são definidos através de destrutores/observadores e podem representar estruturas potencialmente infinitas como streams. A coindução é o dual matemático da indução, apropriada para provar propriedades sobre estruturas infinitas através de consistência de observações.\nEm assistentes de prova como Coq, esta dualidade é expressa através da distinção entre tipos Inductive e CoInductive:\n(* Tipo indutivo - lista *)\nInductive list (A : Type) : Type :=\n| nil : list A\n| cons : A -&gt; list A -&gt; list A.\n\n(* Tipo coinductivo - stream *)\nCoInductive stream (A : Type) : Type :=\n| Cons : A -&gt; stream A -&gt; stream A.\nEsta distinção fundamental orienta a escolha entre técnicas de prova indutivas e coindutivas, dependendo da natureza finita ou infinita das estruturas sendo verificadas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "href": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "title": "10  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "10.2 Integração com Lógica de Primeira Ordem",
    "text": "10.2 Integração com Lógica de Primeira Ordem\n\n10.2.1 Especificação de propriedades de programas com FOL\nA Lógica de Primeira Ordem (FOL) fornece a base teórica fundamental para especificação de propriedades de programas. FOL permite expressar propriedades complexas através de quantificadores (∀ - para todo, ∃ - existe) e predicados, oferecendo expressividade suficiente para a maioria das especificações práticas.\nA especificação de contratos de programas utiliza FOL para definir pré-condições, pós-condições e invariantes. Por exemplo, uma função de ordenação pode ter especificação:\n\\[\n\\forall \\text{array} \\in \\text{int}[], \\text{sorted}(\\text{array}) \\iff \\forall i,j: (0 \\le i &lt; j &lt; \\text{array.length}) \\implies \\text{array}[i] \\le \\text{array}[j]\n\\]\nEsta especificação captura precisamente o conceito de array ordenado usando quantificadores universais sobre índices e uma implicação que define a relação de ordem.\nPara estruturas de dados mais complexas, FOL permite especificar invariantes estruturais:\n\\[\n\\forall \\text{tree} \\in \\text{BinaryTree}, \\text{balanced}(\\text{tree}) \\iff \\forall \\text{node} \\in \\text{tree}, |\\text{height}(\\text{left}(\\text{node})) - \\text{height}(\\text{right}(\\text{node}))| \\le 1\n\\]\n\n\n10.2.2 Relação entre lógica e correção de programas\nA relação entre FOL e correção de programas manifesta-se através da interpretação semântica das especificações. A lógica de Hoare utiliza FOL como metalinguagem para expressar a semântica de correção parcial e total, sendo que triplas de Hoare são interpretadas como fórmulas FOL.\nA verificação de correção transforma programas anotados em condições de verificação (VCs) expressas em FOL. Estas VCs são então enviadas para provadores automáticos de teoremas (SAT/SMT solvers) que determinam sua validade. Este processo automatiza significativamente a verificação, reduzindo o esforço manual necessário para provas de correção.\nA correção parcial especifica que se a pré-condição é verdadeira e o programa termina, então a pós-condição é verdadeira. A correção total adiciona a garantia de terminação, frequentemente expressa através de variantes que diminuem em relações bem-fundamentadas.\n\n\n10.2.3 Métodos formais em engenharia de software\nA integração de FOL com engenharia de software ocorre através de diversos métodos formais. Model checking explora exaustivamente o espaço de estados de sistemas finitos, verificando propriedades temporais expressas em lógicas como LTL (Linear Temporal Logic) e CTL (Computation Tree Logic).\nTheorem proving oferece verificação interativa ou semi-automática baseada em FOL e lógicas de ordem superior. Ferramentas como Coq, Isabelle/HOL e Lean permitem construção incremental de provas complexas, com verificação automática de correção.\nA abstract interpretation utiliza FOL para especificar domínios abstratos que aproximam o comportamento de programas, permitindo análise estática eficiente para detecção de erros como buffer overflows, null pointer dereferences, e violações de invariantes.\n\n\n10.2.4 Ferramentas modernas e aplicações práticas\nAs ferramentas modernas de verificação formal implementam integração sofisticada entre FOL e verificação de programas. Dafny utiliza Church’s Simple Type Theory, uma extensão de FOL, para especificação e verificação automática através do provador Z3.\nSPARK, baseado em Ada, expressa contratos como predicados FOL e utiliza múltiplos provadores SMT para verificação automática. Esta abordagem demonstra aplicabilidade industrial da verificação formal, com uso em sistemas críticos da aviação e automotivos.\nCoq/Rocq oferece ambiente de prova interativa onde FOL pode ser codificada dentro do sistema de tipos, permitindo formalização matemática rigorosa e extração automática de programas certificados. Projetos como CompCert (compilador C formalmente verificado) demonstram a viabilidade da verificação formal em larga escala.\n\n\n10.2.5 Aplicações em sistemas críticos\nA verificação formal com FOL encontra aplicações cruciais em sistemas críticos. Na aviação, padrões como DO-178C/ED-12C reconhecem métodos formais como meio aceitável para certificação de software aviônico. Projetos como o Airbus A380 utilizaram verificação formal para componentes críticos de controle.\nSistemas automotivos seguem a ISO 26262 para segurança funcional, onde verificação formal contribui para atendimento aos níveis mais altos de integridade de segurança (ASIL D). A verificação de ECUs (Electronic Control Units) utiliza especificações FOL para garantir ausência de erros críticos.\nNa segurança cibernética, a verificação formal de protocolos criptográficos utiliza FOL para especificar propriedades de segurança como confidencialidade, integridade e autenticidade. Projetos como a verificação do microkernel seL4 demonstram correção funcional completa usando Isabelle/HOL.\n\n\n10.2.6 Desafios e direções futuras\nA integração entre FOL e verificação formal enfrenta desafios significativos. A complexidade computacional da verificação cresce exponencialmente com o tamanho dos programas, exigindo técnicas de abstração e decomposição para escalabilidade.\nA usabilidade permanece um obstáculo para adoção ampla, requerendo conhecimento matemático especializado e ferramentas com interfaces ainda em evolução. Desenvolvimentos em automação inteligente, incluindo uso de aprendizado de máquina para geração de especificações e invariantes, prometem reduzir esta barreira.\nTendências emergentes incluem verificação contínua integrada a pipelines DevOps, synthesis automática de código a partir de especificações FOL, e aplicação a novos domínios como blockchain e sistemas de inteligência artificial.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html",
    "href": "09-desafios-logicos-enigmas-e-misterios.html",
    "title": "11  Problemas Interessantes Resolvidos com Lógica Proposicional e Predicativa",
    "section": "",
    "text": "Aqui estão cinco quebra-cabeças clássicos juntamente com suas soluções usando Lógica de Primeira Ordem\n\nQuebra-cabeça: O Mentiroso e o Verdadeiro Você encontra dois habitantes: \\(A\\) e \\(B\\). Você sabe que um sempre diz a verdade e o outro sempre mente, mas você não sabe quem é quem. Você pergunta a \\(A\\), Você é o verdadeiro? A responde, mas você não consegue ouvir a resposta dele. \\(B\\) então te diz, A disse que ele é o mentiroso.\nSolução: \\(A\\) deve ser o verdadeiro e \\(B\\) deve ser o mentiroso. Se \\(B\\) fosse o verdadeiro, ele nunca diria que é o mentiroso. Portanto, \\(B\\) deve ser o mentiroso e \\(A\\) deve ser o verdadeiro, independentemente do que \\(B\\) disse.\nUsando apenas Lógica Proposicional teremos:\nDefinições: VA: A é o verdadeiro MA: A é o mentiroso VB: B é o verdadeiro MB: B é o mentiroso RA: A respondeu “Sim” à pergunta “Você é o verdadeiro?”\nAxiomas:\n\n\\(VA \\lor MA\\) (A é verdadeiro ou mentiroso);\n\\(\\neg(VA \\land MA)\\) (A não é ambos verdadeiro e mentiroso);\n\\(VB \\lor MB\\) (B é verdadeiro ou mentiroso);\n\\(\\neg(VB \\land MB)\\) (B não é ambos verdadeiro e mentiroso);\n\\(VA \\to \\neg VB\\) (Se A é verdadeiro, B não é verdadeiro);\n\\(VA \\to RA\\) (Se A é verdadeiro, ele respondeu “Sim”);\n\\(MA \\to \\neg RA\\) (Se A é mentiroso, ele respondeu “Não”);\n\\(VB \\to (B \\text{ diz } \\neg RA)\\) (Se B é verdadeiro, ele diz a verdade sobre a resposta de A);\n\\(MB \\to (B \\text{ diz } RA)\\) (Se B é mentiroso, ele mente sobre a resposta de A).\n\nFato observado:\n\\[B \\text{ diz } \\neg RA\\]\nProva:\n\n\\(B \\text{ diz } \\neg RA\\) (Fato observado)\n\\((VB \\land \\neg RA) \\lor (MB \\land RA)\\) (Por 8, 9 e 1)\nSuponha \\(MA\\): 3.1. \\(\\neg RA\\) (Por 7) 3.2. \\(VB\\) (Por 3, 4 e 5) 3.3. Mas isto contradiz 2, pois teríamos \\((VB \\land RA)\\)\nPortanto, \\(\\neg MA\\) (Por reductio ad absurdum)\n\\(VA\\) (Por 1 e 4)\n\nConclusão:\n\\[VA \\land \\neg MA\\]\n\\(A\\) é o verdadeiro e não é o mentiroso.\nUsando Lógica de Primeira Ordem teremos:\nDefinições:\n\n\\(V(x)\\): \\(x\\) é o verdadeiro;\n\\(M(x)\\): \\(x\\) é o mentiroso;\n\\(R(x)\\): \\(x\\) respondeu “Sim” à pergunta “Você é o verdadeiro?”;\n\\(D(x, p)\\): \\(x\\) diz que p é verdadeiro.\n\nAxiomas:\n\n\\(\\forall x (V(x) \\lor M(x))\\) (Todo x é verdadeiro ou mentiroso);\n\\(\\forall x (V(x) \\to \\neg M(x))\\) (Ninguém é ambos verdadeiro e mentiroso);\n\\(\\forall x (V(x) \\to R(x))\\) (Se x é verdadeiro, x responde “Sim”);\n\\(\\forall x (M(x) \\to \\neg R(x))\\) (Se x é mentiroso, x responde “Não”);\n\\(\\forall x \\forall y \\forall p (V(x) \\to (D(x, p) \\leftrightarrow p))\\) (Se x é verdadeiro, x diz p se e somente se p é verdadeiro);\n\\(\\forall x \\forall y \\forall p (M(x) \\to (D(x, p) \\leftrightarrow \\neg p))\\) (Se x é mentiroso, x diz p se e somente se p é falso).\n\nFatos observados:\n\\[D(B, \\neg R(A))\\]\nProva:\n\n\\(D(B, \\neg R(A))\\) (Fato observado);\n\\(V(A) \\lor M(A)\\) (Por 1);\nSuponha \\(M(A)\\): 3.1. \\(\\neg R(A)\\) (Por 4); 3.2. \\(V(B)\\) (Pois apenas um é mentiroso, por 1 e 2); 3.3. \\(D(B, \\neg R(A)) \\leftrightarrow \\neg R(A)\\) (Por 5); 3.4. \\(\\neg R(A)\\) (Por 1 e 3.3); 3.5. Mas isto contradiz 3.1 e 3.4.\nPortanto, \\(\\neg M(A)\\) (Por reductio ad absurdum)\n\\(V(A)\\) (Por 2 e 4)\n\nConclusão: \\[V(A) \\land \\neg M(A)\\]\n\\(A\\) é o verdadeiro e não é o mentiroso.\nQuebra-cabeça: As Três Lâmpadas Existem três lâmpadas incandescentes em uma sala, e existem três interruptores fora da sala. Você pode manipular os interruptores o quanto quiser, mas só pode entrar na sala uma vez. Como você pode determinar qual interruptor opera qual lâmpada?\nSolução: ligue um interruptor e espere um pouco. Então desligue esse interruptor e ligue um segundo interruptor. Entre na sala. A lâmpada que está acesa corresponde ao segundo interruptor. A lâmpada que está desligada e quente corresponde ao primeiro interruptor. A lâmpada que está desligada e fria corresponde ao terceiro interruptor.\nUsando Lógica de Primeira Ordem: Vamos denotar os interruptores como \\(s1, s2, s3\\) e as lâmpadas como \\(b1, b2, b3\\). Podemos definir predicados \\(On(b, s)\\) e \\(Hot(b)\\).\n\\[On(b1, s2) \\land Hot(b2) \\land \\neg (On(b3) \\lor Hot(b3))\\]\nQuebra-cabeça: O Agricultor, a Raposa, o Ganso e o Grão Um agricultor quer atravessar um rio e levar consigo uma raposa, um ganso e um saco de grãos. O barco do agricultor só lhe permite levar um item além dele mesmo. Se a raposa e o ganso estiverem sozinhos, a raposa comerá o ganso. Se o ganso e o grão estiverem sozinhos, o ganso comerá o grão. Como o agricultor pode levar todas as suas posses para o outro lado do rio?\nSolução: o agricultor leva o ganso através do rio primeiro, deixando a raposa e o grão no lado original. Ele deixa o ganso no outro lado e volta para pegar a raposa. Ele deixa a raposa no outro lado, mas leva o ganso de volta ao lado original para pegar o grão. Ele deixa o grão com a raposa no outro lado. Finalmente, ele retorna ao lado original mais uma vez para pegar o ganso.\nUsando Lógica de Primeira Ordem: Podemos definir predicados \\(mesmoLado(x, y)\\) e \\(come (x, y)\\). A solução envolve a sequência de ações que mantêm as seguintes condições:\n\\[\\neg (mesmoLado(Raposa, Ganso) \\land \\neg mesmoLado(Raposa, Fazendeiro))\\]\n\\[\\neg (mesmoLado(Ganso, Grãos) \\land \\neg mesmoLado(Ganso, Fazendeiro))\\]\nQuebra-cabeça: O Problema da Ponte e da Tocha Quatro pessoas chegam a um rio à noite. Há uma ponte estreita, mas ela só pode conter duas pessoas de cada vez. Eles têm uma tocha e, por ser noite, a tocha tem que ser usada ao atravessar a ponte. A pessoa \\(A\\) pode atravessar a ponte em um minuto, \\(B\\) em dois minutos, \\(C\\) em cinco minutos e \\(D\\) em oito minutos. Quando duas pessoas atravessam a ponte juntas, elas devem se mover no ritmo da pessoa mais lenta. Qual é a forma mais rápida para todos eles atravessarem a ponte?\nSolução: primeiro, \\(A\\) e \\(B\\) atravessam a ponte, o que leva 2 minutos. \\(A\\) então pega a tocha e volta para o lado original, levando 1 minuto. \\(A\\) fica no lado original enquanto \\(C\\) e \\(D\\) atravessam a ponte, levando 8 minutos. \\(B\\) então pega a tocha e volta para o lado original, levando 2 minutos. Finalmente, \\(A\\) e \\(B\\) atravessam a ponte novamente, levando 2 minutos. No total, teremos \\(2+1+8+2+2=15\\) minutos.\nUsando Lógica de Primeira Ordem: Vamos denotar o tempo que cada pessoa leva para atravessar a ponte como \\(t_A, t_B, t_C, t_D\\) e o tempo total como \\(T\\). O problema pode ser representado da seguinte forma:\n\\[(t_A + t_B + t_A + t_C + t_D + t_B + t_A) \\leq T\\]\nSubstituindo os valores dos tempos resulta em \\(15 \\leq T\\).\nQuebra-cabeça: O Problema de Monty Hall Em um programa de game show, os concorrentes tentam adivinhar qual das três portas contém um prêmio valioso. Depois que um concorrente escolhe uma porta, o apresentador, que sabe o que está por trás de cada porta, abre uma das portas não escolhidas para revelar uma cabra, representando nenhum prêmio. O apresentador então pergunta ao concorrente se ele quer mudar sua escolha para a outra porta não aberta ou ficar com sua escolha inicial. O que o concorrente deve fazer para maximizar suas chances de ganhar o prêmio?\nSolução: o concorrente deve sempre mudar sua escolha. Inicialmente, a chance do prêmio estar atrás da porta escolhida é \\(1/3\\) e a chance de estar atrás de uma das outras portas é \\(2/3\\). Depois que o apresentador abre uma porta para revelar uma cabra, a chance do prêmio estar atrás da porta não escolhida e não aberta ainda é \\(2/3\\).\nUsando Lógica de Primeira Ordem: Vamos denotar as portas como \\(d1, d2, d3\\) e o prêmio como \\(P\\). Podemos definir um predicado \\(contémPrêmio(d)\\). A solução pode ser representada pela seguinte condição:\n\\[(contémPrêmio(d1) \\land \\neg contémPrêmio(d2) \\land \\neg contémPrêmio(d3)) \\\\ \\lor (contémPrêmio(d2)  \\land \\neg contémPrêmio(d1) \\land \\neg contémPrêmio(d3)) \\\\ \\lor (contémPrêmio(d3) \\land \\neg contémPrêmio(d1) \\land \\neg contémPrêmio(d2))\\]\nEsta condição afirma que o prêmio está exatamente atrás de uma das portas, e o concorrente deve mudar sua escolha depois que uma das portas é aberta para revelar nenhum prêmio.\n\n\n11.0.1 O Mistério da Mansão Hollow – Um Desafio para Detetives Lógicos\n\nObjetivo: Aplicar os princípios da Lógica Proposicional e de predicados para analisar um conjunto complexo de informações, identificar contradições, realizar deduções formais e solucionar um enigma.\nDescrição: A esforçada leitora foi convidada a investigar um intrigante mistério ocorrido na antiga Mansão Hollow. O renomado inventor, Sir Arthur Blackwood, desapareceu em circunstâncias suspeitas, deixando para trás uma série de pistas, depoimentos de funcionários e familiares, e alguns bilhetes enigmáticos. A polícia local está confusa com a quantidade de informações, algumas aparentemente contraditórias. Você deve montar uma equipe de detetives e superar o famoso detetive Hercule Poirot. Para isso deverá:\n\nAnalisar cuidadosamente todo o material fornecido (descrições de personagens, mapa da mansão, horários, depoimentos, bilhetes).\nFormalizar as informações relevantes utilizando sentenças da Lógica Proposicional e, quando aplicável, da lógica de predicados.\nConstruir tabelas-verdade e/ou aplicar regras de inferência para verificar a consistência das informações e deduzir novos fatos.\nIdentificar o(s) responsável(is) pelo desaparecimento do Sr. Blackwood (ou determinar o que de fato aconteceu), justificando cada passo da sua conclusão com base nas deduções lógicas realizadas.\n\nA seguir a descrição do caso, o mapa da mansão e os depoimentos dos envolvidos.\n\n11.0.1.1 O Mistério da Mansão Hollow: O Desaparecimento de Sir Arthur Blackwood\nData do Incidente: Segunda-feira, 12 de Maio de 2025 Local: Mansão Hollow, uma propriedade rural isolada. Vítima (Desaparecido): Sir Arthur Blackwood, renomado inventor, 58 anos.\n1. Descrições dos Personagens:\n\nSir Arthur Blackwood: O inventor desaparecido. Gênio excêntrico e recluso, conhecido por sua mente brilhante e comportamento imprevisível. Estava trabalhando febrilmente em um novo projeto secreto chamado “Quimera”.\nSra. Eleanor Blackwood (50 anos): Esposa de Arthur. Uma mulher elegante e ambiciosa, visivelmente preocupada com a reputação e fortuna da família. Ela teme que o comportamento errático de Arthur possa arruiná-los.\nDr. Alistair Finch (45 anos): Um cientista brilhante, antigo protegido de Arthur, mas que se tornou seu principal rival acadêmico e comercial. Chegou à mansão no dia do desaparecimento, alegando buscar uma reconciliação e possível colaboração.\nMiss Clara Evans (28 anos): A jovem e inteligente assistente pessoal de Arthur. Dedicada e leal, trabalhava em estreita colaboração com ele no projeto “Quimera” e conhecia muitos de seus segredos.\nSr. Reginald “Reggie” Croft (65 anos): O mordomo, trabalha para a família Blackwood há mais de trinta anos. É um homem discreto, observador e extremamente leal à memória do falecido pai de Arthur, mas demonstra certa reserva em relação ao próprio Arthur.\nSra. Beatrice Croft (62 anos): Esposa de Reggie, a cozinheira da mansão. Conhece todos os cantos da casa e os hábitos de seus ocupantes. É prática e não se deixa levar por fantasias.\n\nNossos personagens podem ser vistos na imagem abaixo:\n{:class=“lazyload”}\n2. Mapa da Mansão Hollow (Descrição Textual): A Mansão Hollow é uma construção vitoriana de dois andares, com um vasto terreno.\n\nTérreo:\n\nHall de Entrada: Amplo, com piso de mármore, uma imponente escadaria de carvalho que leva ao andar superior. Portas levam à biblioteca (esquerda), sala de estar (direita) e, ao fundo, um corredor para a sala de jantar e a ala de serviço/cozinha.\nBiblioteca: Paredes forradas de estantes com livros antigos e científicos. Uma grande escrivaninha de mogno, poltronas de couro e uma lareira. Duas janelas altas com vista para o jardim da frente.\nSala de Estar: Mobiliário luxuoso, mas um pouco antiquado. Um piano de cauda, lareira e janelas com vista para o jardim lateral e o gazebo.\nSala de Jantar: Uma longa mesa de jantar polida, prataria reluzente. Acesso direto à cozinha.\nCozinha: Grande e funcional, com uma mesa rústica ao centro. Portas para a despensa, os aposentos dos Croft e uma saída para o jardim dos fundos/horta.\nLaboratório do Sr. Blackwood: Localizado no final de um corredor isolado, partindo do hall, perto da escada de serviço. A porta possui uma fechadura especial de alta segurança projetada pelo próprio Arthur. O interior é um caos organizado de equipamentos eletrônicos, protótipos mecânicos, quadros com equações e ferramentas. Possui uma única janela reforçada que dá para o jardim dos fundos. Este é o local principal da investigação inicial.\nEscritório do Sr. Blackwood: Uma sala menor, anexa ao laboratório, acessível apenas por uma porta dentro do laboratório. Mais organizada, com arquivos, patentes, um cofre e um computador.\n\nAndar Superior:\n\nQuarto Principal (Sr. e Sra. Blackwood): Espaçoso, com uma grande cama de dossel, penteadeira, armários embutidos e um banheiro privativo. Uma varanda com vista para o jardim da frente.\nQuarto de Hóspedes: Onde Dr. Finch deixou seus pertences (embora não tenha passado a noite). Confortável, com uma cama de solteiro, escrivaninha e janela para o jardim lateral.\nQuarto de Clara Evans: Menor e mais simples, localizado perto da escada de serviço, com vista para os fundos.\nAposentos do Mordomo e da Cozinheira (Sr. e Sra. Croft): Localizados na ala de serviço, acima da cozinha.\n\nExterior:\n\nJardim da Frente: Um gramado bem cuidado com um caminho circular de cascalho que leva à porta principal. Ladeado por sebes altas.\nJardim Lateral: Menos formal, com um gazebo antigo coberto de hera e canteiros de rosas.\nJardim dos Fundos: Uma área mais extensa e um pouco mais selvagem, com árvores antigas, uma pequena horta cultivada pela Sra. Croft e, nos limites da propriedade, uma velha estufa de vidro abandonada e parcialmente coberta por vegetação.\n\n\nAlguns ambientes da Mansão Hollow podem ser vistos na imagem abaixo:\n\n3. Linha do Tempo (Segunda-feira, 18 de Maio de 1915):\n\n08:00: Café da manhã servido na sala de jantar. Sra. Blackwood preside. Sr. Blackwood não comparece, o que, segundo Sra. Blackwood, era comum quando ele estava imerso em trabalho.\n09:00: Clara Evans leva uma bandeja com café e torradas para o laboratório do Sr. Blackwood.\n10:00: Dr. Alistair Finch chega pontualmente à Mansão Hollow. É recebido pelo mordomo, Sr. Croft, e anunciado à Sra. Blackwood.\n10:15 - 11:00 (aprox.): Dr. Finch e Sra. Blackwood conversam na sala de estar.\n11:00: Sra. Blackwood acompanha Dr. Finch até a porta do laboratório do Sr. Blackwood. Ela bate. Uma voz abafada, identificada por ela como sendo de Arthur, diz: “Estou no meio de algo crítico! Não me perturbem agora!”. Dr. Finch parece contrariado.\n11:05 - 13:00: Período decisivo com movimentações diversas e álibis a serem verificados.\n13:00: O almoço é servido. Sr. Blackwood novamente não aparece.\n14:00: Sra. Blackwood, demonstrando crescente preocupação, pede a Sr. Croft que vá verificar pessoalmente o Sr. Blackwood em seu laboratório.\n14:05: Sr. Croft dirige-se ao laboratório. Encontra a porta especial entreaberta. A fechadura de alta segurança parece ter sido arranhada (marcas de tentativa de arrombamento), mas está destrancada (possivelmente aberta corretamente após a tentativa de arrombamento). O interior do laboratório está em grande desordem: papéis e diagramas espalhados pelo chão, algumas ferramentas fora do lugar, uma cadeira virada. Sr. Blackwood não está em lugar nenhum. A janela dos fundos do laboratório está destrancada e aberta. Não há sinais óbvios de luta violenta (ex: sangue).\n14:15: Sra. Blackwood, após ser informada por Sr. Croft, instrui-o a chamar a polícia local.\n17:00: A notícia do desaparecimento e a natureza peculiar do caso chegam aos ouvidos de Hercule Poirot, que está concluindo um caso em uma cidade vizinha. Ele informa que só poderá dedicar-se ao mistério da Mansão Hollow na manhã seguinte. (Vocês têm até lá para resolver!)\n\n4. Depoimentos Iniciais (Coletados apressadamente pelo Sargento Davis, da polícia local):\n\nSra. Eleanor Clithering:\n\n“Arthur estava impossível nas últimas semanas, totalmente absorvido pelo tal projeto ‘Quimera’. Falava coisas sem sentido sobre revolucionar o mundo, mas também sobre pessoas que queriam roubá-lo. Ele sempre foi um pouco… dramático.”\n“Quando bati à porta do laboratório às 11:00, ouvi claramente Arthur dizer para não ser perturbado. Sim, a voz parecia um pouco abafada, mas era ele. Dr. Finch estava ao meu lado.”\n“Depois disso, subi para meus aposentos para descansar e escrever algumas cartas. Não vi mais o Dr. Finch até a hora do almoço.”\n“A fechadura do laboratório é uma invenção do próprio Arthur. Apenas ele possuía a chave mestra. Ouvi dizer que Clara talvez soubesse algum truque para abri-la, mas forçá-la… faria um barulho terrível, não acha?”\n“Desaparecer assim… não é do feitio de Arthur, a menos que seja parte de algum plano mirabolante dele. Ou então algo terrível aconteceu.”\n\nDr. Alistair Finch:\n\n“Eu vim em uma missão de paz, acreditem. Nossas divergências passadas foram puramente intelectuais. Eu esperava que pudéssemos colaborar. A ideia de roubar o trabalho de Arthur é um insulto.”\n“Sim, a Sra. Blackwood me acompanhou até a porta do laboratório. Ouvi uma voz masculina dizer para não sermos inoportunos. Não posso jurar que era Arthur, a voz estava abafada, como disse a Sra. Blackwood.”\n“Após a recusa, senti-me um pouco desconfortável. Decidi caminhar pelos jardins para espairecer, entre aproximadamente 11:05 e 12:45. Andei pela frente da casa e também pelo jardim lateral, perto do gazebo. O tempo estava agradável.”\n“Não vi ninguém suspeito. Vi o mordomo, Sr. Croft, por um instante, perto da entrada lateral da casa, por volta das 11:20. Ele parecia estar carregando uma caixa ou algo similar em direção à parte de trás da casa ou à adega.”\n“Eu nunca tocaria na fechadura do laboratório de Arthur sem permissão. Seria uma violação imperdoável da ética científica.”\n\nMiss Clara Evans:\n\n“Sr. Blackwood estava muito pressionado, mas também excitado com o ‘Quimera’. Ele dizia que mudaria tudo. Ele confiava em mim implicitamente.”\n“Sim, ele temia que o Dr. Finch, ou outros, pudessem tentar se apropriar de suas descobertas. Ele tomava muitas precauções.”\n“Quando levei seu café às 09:00, ele estava um pouco agitado, mas lúcido. Disse-me: ‘Clara, hoje é um dia de grandes decisões. Lembre-se dos nossos protocolos.’”\n“Entre 11:00 e 13:00, estive principalmente no escritório anexo ao laboratório, compilando dados. A porta entre o escritório e o laboratório estava fechada na maior parte do tempo para que ele tivesse silêncio. Saí brevemente, por volta das 11:30, para ir à biblioteca buscar o ‘Compêndio de Ligas Metálicas Raras’. Fiquei lá uns 15, talvez 20 minutos. Não cruzei com ninguém no corredor ou na biblioteca.”\n“O laboratório tem um bom isolamento acústico, especialmente com a porta do escritório fechada. Não ouvi nenhum barulho de arrombamento. A fechadura especial é complexa; apenas Sr. Blackwood tinha a chave. Eu conheço o procedimento de abertura manual de emergência, mas é uma sequência demorada e específica.”\n\nSr. Reginald “Reggie” Croft (Mordomo):\n\n“Dr. Finch chegou às 10:00. Parecia um pouco nervoso, na minha opinião. Ele e a patroa conversaram na sala de estar por um bom tempo.”\n“Por volta das 11:00, eu estava no hall polindo a prata, e ouvi as vozes da Sra. Blackwood e do Dr. Finch perto do corredor do laboratório. Não prestei muita atenção ao que foi dito. Logo depois, vi a Sra. Blackwood subir a escadaria principal.”\n“De fato, por volta das 11:15, eu estava transportando uma caixa de garrafas de vinho da entrada de serviço lateral para a adega no porão. Nesse momento, vi o Dr. Finch caminhando pelo jardim da frente, perto do portão principal. Ele olhava muito para o relógio.”\n“Quando fui chamado pela Sra. Blackwood às 14:00, encontrei a porta do laboratório como descrito: entreaberta, com arranhões na fechadura, mas destrancada. O Sr. Blackwood era metódico. Se ele não queria ser perturbado, ele trancava a porta de uma forma que ninguém entraria.”\n\nSra. Beatrice Croft (Cozinheira):\n\n“Da cozinha, não se ouve muito do resto da casa, a menos que seja uma gritaria. Estive ocupada com o almoço toda a manhã.”\n“Sr. Blackwood não aparecer para as refeições não era novidade quando estava às voltas com suas invenções malucas.”\n“Uma coisa estranha: Miss Evans passou rapidamente pela cozinha por volta das 12:50. Parecia muito pálida e apressada. Perguntei se estava tudo bem, e ela murmurou algo sobre ir verificar se o Sr. Blackwood queria que o almoço fosse servido no laboratório. Ela voltou alguns minutos depois, ainda mais pálida, e disse que ele não tinha respondido aos chamados dela na porta do laboratório e que era melhor não insistir. Achei estranho ela não ter comentado isso com a Sra. Blackwood imediatamente, antes do alarme oficial.”\n“A janela do laboratório? Sim, dá para uma parte mais isolada d-o jardim dos fundos, perto da minha horta. Se alguém pulou por ali, e se esgueirou pelas árvores, poderia sumir sem ser visto da casa principal.”\n\n\n5. Pistas e Bilhetes Enigmáticos:\n\nPista 1: Papel Amassado na Lixeira do Laboratório: Um pequeno pedaço de papel de anotações, claramente arrancado de um bloco maior, contém a seguinte mensagem escrita à mão por Sr. Blackwood (caligrafia confirmada):\n\n“Se A implica B, e o Corvo visita o Ninho, então a Hipótese se confirma. A negação do consequente é o único caminho seguro. Sigma Ativado.”\n\nPista 2: Objeto Encontrado no Chão do Laboratório, Perto da Mesa Principal: Um pequeno e incomum botão de metal fosco, com um desenho de uma engrenagem estilizada. Não parece pertencer a nenhuma roupa do Sr. Blackwood, nem faz parte do vestuário usual dos funcionários.\nPista 3: Anotação na Margem de um Livro na Biblioteca: No livro “Compêndio de Ligas Metálicas Raras” (o mesmo que Clara Evans mencionou ter pego), na página sobre o Bismuto, há uma pequena anotação a lápis, quase imperceptível:\n\n“Onde o passado encontra o futuro, a reflexão é a chave. \\((\\neg P \\lor Q)\\) é equivalente a ?” A caligrafia parece ser de Sr. Blackwood.\n\nPista 4: Marca Estranha no Batente da Janela Aberta do Laboratório: Do lado de fora do batente da janela do laboratório, há uma leve marca de fuligem ou graxa escura, como se algo metálico e sujo tivesse sido apoiado ali brevemente.\nPista 5: Na Estufa Abandonada (Jardim dos Fundos): Dentro da estufa, sobre uma bancada empoeirada, alguém desenhou com o dedo na poeira um símbolo: um triângulo equilátero com um pequeno círculo no centro. Ao lado do desenho, um único fósforo queimado. Não há outras pegadas recentes visíveis devido ao solo irregular e coberto de folhas secas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Problemas Interessantes Resolvidos com **Lógica Proposicional** e Predicativa</span>"
    ]
  },
  {
    "objectID": "apendice-a-glossario.html",
    "href": "apendice-a-glossario.html",
    "title": "12  Glossário",
    "section": "",
    "text": "Álgebra de Boole: Sistema algébrico usado na lógica matemática, baseado nos valores verdadeiro (1) e falso (0).\nAntecedente: Em uma implicação \\(P \\rightarrow Q\\), \\(P\\) é o antecedente.\nAridade: Número de argumentos que uma função ou predicado aceita.\nArgumento: Lista de proposições (premissas) seguidas de uma conclusão.\nAssociatividade: Propriedade onde \\((a * b) * c = a * (b * c)\\) para um operador \\(*\\).\nÁtomo: Proposição indivisível ou predicado aplicado a termos em uma fórmula.\nAxioma: Fórmula ou proposição aceita como verdadeira sem necessidade de demonstração.\nBicondicional (\\(\\leftrightarrow\\)): Operador lógico que indica equivalência entre duas proposições.\nCardinalidade: Número de elementos em um conjunto.\nCláusula: Disjunção de literais, como \\(P \\vee Q \\vee \\neg R\\).\nCláusula de Horn: Disjunção de literais com no máximo um literal positivo.\nComutatividade: Propriedade onde \\(a * b = b * a\\) para um operador \\(*\\).\nConclusão: Em um argumento, a proposição final que se deriva das premissas.\nConjunção (\\(\\wedge\\)): Operador lógico “E”.\nConsequente: Em uma implicação \\(P \\rightarrow Q\\), \\(Q\\) é o consequente.\nConstante: Símbolo que representa um objeto específico no domínio do discurso.\nConstante de Skolem: Termo introduzido para eliminar quantificadores existenciais.\nContradição: Fórmula que é sempre falsa, independentemente dos valores de suas variáveis.\nContrapositiva: Para uma implicação \\(P \\rightarrow Q\\), sua contrapositiva é \\(\\neg Q \\rightarrow \\neg P\\).\nDedução: Processo de derivar conclusões lógicas a partir de premissas.\nDisjunção (\\(\\vee\\)): Operador lógico “OU”.\nDistributividade: Propriedade onde \\(a * (b + c) = (a * b) + (a * c)\\) para operadores \\(*\\) e \\(+\\).\nDomínio do Discurso: Conjunto de objetos sobre os quais as variáveis quantificadas podem se referir.\nDupla Negação: Princípio onde \\(\\neg \\neg P \\equiv P\\).\nEquivalência Lógica (\\(\\equiv\\)): Relação entre duas fórmulas que têm o mesmo valor verdade para todas as interpretações.\nEscopo: Parte de uma fórmula à qual um quantificador ou operador se aplica.\nFato: Na programação lógica, afirmação considerada verdadeira sem condições.\nFalseabilidade: Propriedade de uma hipótese que pode ser provada falsa.\nForma Normal Conjuntiva (FNC): Fórmula que é uma conjunção de cláusulas, onde cada cláusula é uma disjunção de literais.\nForma Normal Disjuntiva (FND): Fórmula que é uma disjunção de conjunções de literais.\nForma Normal Negativa (FNN): Fórmula onde as negações aparecem apenas imediatamente antes das variáveis proposicionais.\nForma Normal Prenex: Fórmula onde todos os quantificadores estão no início, seguidos por uma matriz sem quantificadores.\nForma Normal Skolem: Forma Normal Prenex onde todos os quantificadores existenciais foram eliminados.\nFórmula Atômica: Fórmula que consiste em um predicado aplicado a termos.\nFórmula Bem Formada: Sequência de símbolos que segue as regras de formação da linguagem lógica.\nFunção: Mapeamento de um conjunto de argumentos para um valor único.\nFunção de Skolem: Função introduzida para eliminar quantificadores existenciais que dependem de variáveis universalmente quantificadas.\nIdempotência: Propriedade onde \\(a * a = a\\) para um operador \\(*\\).\nImplicação (\\(\\rightarrow\\)): Operador lógico “SE…ENTÃO”.\nIndução Matemática: Método de prova que envolve um caso base e um passo indutivo.\nInferência: Processo de derivar novas informações a partir de informações existentes.\nInstanciação: Substituição de uma variável por um termo específico.\nInterpretação: Atribuição de significado aos símbolos de uma linguagem formal.\nLeis de De Morgan: \\(\\neg(P \\wedge Q) \\equiv (\\neg P \\vee \\neg Q)\\) e \\(\\neg(P \\vee Q) \\equiv (\\neg P \\wedge \\neg Q)\\).\nLema: Proposição auxiliar demonstrável utilizada como passo intermediário na prova de um teorema.\nLiteral: Variável proposicional ou sua negação.\nLógica de Primeira Ordem: Sistema formal para representar e raciocinar sobre propriedades de objetos e relações entre eles.\nLógica Proposicional: Sistema lógico que lida com proposições e suas inter-relações.\nMeta-linguagem: Linguagem usada para descrever outra linguagem.\nModelo: Interpretação que satisfaz um conjunto de fórmulas.\nModus Ponens: Regra de inferência: \\(P, P \\rightarrow Q \\vdash Q\\).\nModus Tollens: Regra de inferência: \\(\\neg Q, P \\rightarrow Q \\vdash \\neg P\\).\nNegação (\\(\\neg\\)): Operador lógico que inverte o valor de verdade de uma proposição.\nPredicado: Função que mapeia objetos a valores de verdade.\nPremissa: Proposição a partir da qual se deriva uma conclusão em um argumento.\nProlog: Linguagem de programação baseada na Lógica de Primeira Ordem e Cláusulas de Horn.\nProva: Sequência de passos lógicos que demonstra a verdade de uma proposição.\nQuantificador Existencial (\\(\\exists\\)): Símbolo lógico que significa “existe pelo menos um”.\nQuantificador Universal (\\(\\forall\\)): Símbolo lógico que significa “para todo”.\nRecíproca: Para uma implicação \\(P \\rightarrow Q\\), sua recíproca é \\(Q \\rightarrow P\\).\nRedução ao Absurdo: Método de prova que assume a negação da conclusão e deriva uma contradição.\nRefutação: Prova da falsidade de uma proposição.\nRegra: Na programação lógica, implicação que define como derivar novos fatos.\nResolução: Regra de inferência usada em provas automatizadas.\nSatisfatibilidade: Propriedade de uma fórmula que é verdadeira para pelo menos uma interpretação.\nSemântica: Estudo do significado em linguagens formais e naturais.\nSilogismo: Forma de raciocínio dedutivo com duas premissas e uma conclusão.\nSintaxe: Conjunto de regras que definem as sequências bem formadas em uma linguagem.\nSkolemização: Processo de eliminação de quantificadores existenciais em uma fórmula lógica.\nTabela Verdade: Tabela que mostra os valores de verdade de uma fórmula para todas as combinações possíveis de seus componentes.\nTautologia: Fórmula que é sempre verdadeira, independentemente dos valores de suas variáveis.\nTeoria: Conjunto de fórmulas em um sistema lógico.\nTeorema: Afirmação que pode ser provada como verdadeira dentro de um sistema lógico.\nTermo: Constante, variável ou função aplicada a outros termos.\nUnificação: Processo de encontrar substituições que tornam dois termos idênticos.\nUniverso de Herbrand: Conjunto de todos os termos básicos que podem ser construídos a partir das constantes e funções de uma linguagem de primeira ordem.\nUniverso do Discurso: Conjunto de todas as entidades sobre as quais as variáveis em uma fórmula lógica podem assumir valores.\nValidade: Propriedade de um argumento onde a conclusão é verdadeira sempre que todas as premissas são verdadeiras.\nVariável: Símbolo que representa um objeto não especificado no domínio do discurso.\nVariável Livre: Variável em uma fórmula que não está ligada a nenhum quantificador.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Glossário</span>"
    ]
  },
  {
    "objectID": "apendice-b-referencias.html",
    "href": "apendice-b-referencias.html",
    "title": "13  Referências",
    "section": "",
    "text": "BOOLOS, G.; BURGESS, J.; JEFFREY, R. Computability and Logic. 5. ed. Cambridge: Cambridge University Press, 2007.\nCHANG, C.C.; KEISLER, H.J. Model Theory. Amsterdam: North-Holland, 1990.\nEBBINGHAUS, H.D.; FLUM, J. Finite Model Theory. 2. ed. Berlin: Springer, 2006.\nGALLIER, J.H. Logic for Computer Science: Foundations of Automatic Theorem Proving. 2. ed. Mineola: Dover Publications, 2015.\nGENESERETH, M.; NILSSON, N. Logical Foundations of Artificial Intelligence. San Francisco: Morgan Kaufmann, 1987.\nINTERNATIONAL MONETARY FUND. World Economic Outlook, October 2023: Navigating Global Divergences. IMF, out. 2023. Disponível em: https://www.imf.org/en/Publications/WEO/Issues/2023/10/10/world-economic-outlook-october-2023. Acesso em: 17 mai. 2025.\nKRIPKE, S. Naming and Necessity. Cambridge: Harvard University Press, 1980.\nMANNA, Z. Verification of Computer Programs. Cambridge: MIT Press, 1974.\nMDPI BLOG. Five Breakthrough Moments in Science and Technology in 2022. MDPI Blog, 23 jan. 2023. Disponível em: https://blog.mdpi.com/2023/01/23/breakthroughs-in-2022/. Acesso em: 17 mai. 2025.\nMIT TECHNOLOGY REVIEW. 10 Breakthrough Technologies 2022. MIT Technology Review, 23 fev. 2022. Disponível em: https://www.technologyreview.com/2022/02/23/1045416/10-breakthrough-technologies-2022/. Acesso em: 17 mai. 2025.\nQUINE, W.V.O. Word and Object. Cambridge: MIT Press, 1960.\nRUSSELL, S.; NORVIG, P. Artificial Intelligence: A Modern Approach. 4. ed. Upper Saddle River: Pearson, 2020.\nVAN HARMELEN, F.; LIFSCHITZ, V.; PORTER, B. (Ed.). Handbook of Knowledge Representation. Amsterdam: Elsevier, 2008.\nWIRTH, N. Algorithms + Data Structures = Programs. 3. ed. Englewood Cliffs: Prentice-Hall, 1976.\n\nAPT, Krzysztof R. Ten years of Hoare’s logic: a survey. ACM Transactions on Programming Languages and Systems, New York, v. 3, n. 4, p. 431-483, Oct. 1981.\nBERTOT, Yves; CASTÉRAN, Pierre. Interactive Theorem Proving and Program Development: Coq’Art: The Calculus of Inductive Constructions. Berlin: Springer, 2004. 469 p.\nBURSTALL, Rod M. Proving properties of programs by structural induction. The Computer Journal, Oxford, v. 12, n. 1, p. 41-48, Feb. 1969.\nDIJKSTRA, Edsger W. A discipline of programming. Englewood Cliffs: Prentice-Hall, 1976.\nFLOYD, Robert W. Assigning meaning to programs. In: SCHWARTZ, J. T. (Ed.). Mathematical Aspects of Computer Science. Providence: American Mathematical Society, 1967. p. 19-32.\nHOARE, Charles Antony Richard. An axiomatic basis for computer programming. Communications of the ACM, New York, v. 12, n. 10, p. 576-580, Oct. 1969.\nLEINO, K. Rustan M. Efficient weakest preconditions. Information Processing Letters, Amsterdam, v. 93, n. 6, p. 281-288, Mar. 2005.\nNIPKOW, Tobias; KLEIN, Gerwin. Concrete Semantics: With Isabelle/HOL. Cham: Springer, 2014. 298 p.\nPIERCE, Benjamin C. et al. Software Foundations. University of Pennsylvania, 2018. Disponível em: https://softwarefoundations.cis.upenn.edu/. Acesso em: 14 jul. 2025.\nREYNOLDS, John C. Theories of Programming Languages. Cambridge: Cambridge University Press, 1998. 513 p.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Referências</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html",
    "href": "Solucao-Exercicios.html",
    "title": "14  Solução dos Exercícios",
    "section": "",
    "text": "14.1 Lógica Proposicional Chapter 4",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html#lógica-proposicional-sec-logica-proposicional",
    "href": "Solucao-Exercicios.html#lógica-proposicional-sec-logica-proposicional",
    "title": "14  Solução dos Exercícios",
    "section": "",
    "text": "14.1.1 Exercícios: Sintaxe e Fórmulas Bem Formadas\n\n\nVariáveis: \\(x\\);\nConstantes: \\(a\\);\nPredicados: \\(P\\), \\(Q\\);\nConectivos: \\(\\rightarrow\\);\nQuantificadores: \\(\\forall\\).\n\n\nVariáveis: \\(y\\);\nConstantes: \\(c\\);\nSímbolos de função: \\(f\\);\nPredicados: \\(R\\);\nQuantificadores: \\(\\exists\\).\n\n\nVariáveis: \\(x\\), \\(y\\);\nConstantes: \\(b\\);\nSímbolos de função: \\(f\\);\nPredicados: \\(P\\), \\(S\\), \\(R\\);\nConectivos: \\(\\wedge\\), \\(\\rightarrow\\);\nQuantificadores: \\(\\forall\\), \\(\\exists\\).\n\nSim, é uma Fórmula Bem Formada (FBF).\nJustificativa: \\(a\\), \\(f(b)\\) e \\(c\\) são termos. \\(P\\) é um símbolo de predicado de aridade 3, aplicado a 3 termos, formando a fórmula atômica \\(P(a, f(b), c)\\). O operador de negação \\(\\neg\\) é aplicado a esta fórmula atômica, o que é uma regra de formação válida.\nNão, não é uma Fórmula Bem Formada (FBF).\nJustificativa: Falta um conectivo lógico (como \\(\\wedge\\), \\(\\vee\\), \\(\\rightarrow\\)) entre as fórmulas \\(\\forall x P(x)\\) e \\(Q(a)\\). Duas fórmulas devem ser unidas por um conectivo para formar uma nova fórmula.\nNão, não é uma Fórmula Bem Formada (FBF).\nJustificativa: \\(f(x)\\) é um termo, não uma fórmula. Conectivos lógicos como \\(\\rightarrow\\) devem conectar fórmulas. Um termo não pode ser um dos lados de uma implicação.\nSim, é uma Fórmula Bem Formada (FBF).\nJustificativa: \\(P(x)\\) é uma fórmula atômica e \\(\\forall y Q(y)\\) também é uma fórmula. Elas estão corretamente unidas pelo conectivo \\(\\vee\\).\nNão, ela não é uma sentença. Uma sentença é uma FBF que não possui variáveis livres. Nesta fórmula, a variável \\(x\\) no predicado \\(P(x)\\) é uma variável livre, pois não está no escopo de nenhum quantificador (\\(\\forall x\\) ou \\(\\exists x\\)).\nNão, não é uma Fórmula Bem Formada (FBF).\nJustificativa: Os argumentos de um predicado devem ser termos (variáveis, constantes ou funções). Um quantificador como \\(\\forall x\\) não é um termo e não pode aparecer dentro dos parênteses de um predicado.\n\n\nSim, é uma Fórmula Bem Formada (FBF).\nJustificativa: A estrutura segue todas as regras. \\(\\exists x P(f(z), x)\\) é uma FBF, sua negação também é. \\(R(z)\\) é uma FBF. As duas estão corretamente conectadas pelo bicondicional \\(\\leftrightarrow\\), e toda a expressão está corretamente no escopo do quantificador \\(\\forall z\\).\n\n\n\nNão, não é uma Fórmula Bem Formada (FBF).\nJustificativa: A expressão dentro dos parênteses, \\((P(x) \\wedge )\\), está sintaticamente incorreta. O conectivo de conjunção \\(\\wedge\\) é binário e requer uma fórmula em ambos os lados. Ele não pode ser seguido por um parêntese de fechamento.\n\n\n14.1.2 Exercícios: Tabelas-Verdade e Conectivos Lógicos\n(Nota: Usaremos T para Verdadeiro e F para Falso nas tabelas.)\n\nSolução para: \\(P \\rightarrow \\neg Q\\)\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(\\neg Q\\)\n\\(P \\rightarrow \\neg Q\\)\n\n\n\n\nT\nT\nF\nF\n\n\nT\nF\nT\nT\n\n\nF\nT\nF\nT\n\n\nF\nF\nT\nT\n\n\n\n\nSolução para: \\((P \\vee Q) \\wedge R\\)\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(P \\vee Q\\)\n\\((P \\vee Q) \\wedge R\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nT\nF\nT\nF\n\n\nT\nF\nT\nT\nT\n\n\nT\nF\nF\nT\nF\n\n\nF\nT\nT\nT\nT\n\n\nF\nT\nF\nT\nF\n\n\nF\nF\nT\nF\nF\n\n\nF\nF\nF\nF\nF\n\n\n\n\nSolução para: \\(P \\leftrightarrow (P \\wedge Q)\\)\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\wedge Q\\)\n\\(P \\leftrightarrow (P \\wedge Q)\\)\n\n\n\n\nT\nT\nT\nT\n\n\nT\nF\nF\nF\n\n\nF\nT\nF\nT\n\n\nF\nF\nF\nT\n\n\n\n\nSolução para: \\((P \\wedge (P \\rightarrow Q)) \\rightarrow Q\\): (Esta é a forma lógica do Modus Ponens)\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(P \\wedge (P \\rightarrow Q)\\)\n\\((P \\wedge (P \\rightarrow Q)) \\rightarrow Q\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\n\n\nF\nF\nT\nF\nT\n\n\n\nConclusão: A fórmula é uma tautologia, pois a coluna final contém apenas T.\n\nSolução para: \\((P \\rightarrow Q) \\wedge (P \\wedge \\neg Q)\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(\\neg Q\\)\n\\(P \\wedge \\neg Q\\)\n\\((P \\rightarrow Q) \\wedge (P \\wedge \\neg Q)\\)\n\n\n\n\nT\nT\nT\nF\nF\nF\n\n\nT\nF\nF\nT\nT\nF\n\n\nF\nT\nT\nF\nF\nF\n\n\nF\nF\nT\nT\nF\nF\n\n\n\nConclusão: A fórmula é uma contradição, pois a coluna final contém apenas F.\n\nSolução para: \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\) (Esta é a Lei da Contrapositiva)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(\\neg Q\\)\n\\(\\neg P\\)\n\\(\\neg Q \\rightarrow \\neg P\\)\n\\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\)\n\n\n\n\nT\nT\nT\nF\nF\nT\nT\n\n\nT\nF\nF\nT\nF\nF\nT\n\n\nF\nT\nT\nF\nT\nT\nT\n\n\nF\nF\nT\nT\nT\nT\nT\n\n\n\nConclusão: A fórmula é uma tautologia, mostrando que uma implicação e sua contrapositiva são logicamente equivalentes.\n\nSolução para: \\((A \\rightarrow B) \\vee (B \\rightarrow C)\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\\(A\\)\n\\(B\\)\n\\(C\\)\n\\(A \\rightarrow B\\)\n\\(B \\rightarrow C\\)\n\\((A \\rightarrow B) \\vee (B \\rightarrow C)\\)\n\n\n\n\nT\nT\nT\nT\nT\nT\n\n\nT\nT\nF\nT\nF\nT\n\n\nT\nF\nT\nF\nT\nT\n\n\nT\nF\nF\nF\nT\nT\n\n\nF\nT\nT\nT\nT\nT\n\n\nF\nT\nF\nT\nF\nT\n\n\nF\nF\nT\nT\nT\nT\n\n\nF\nF\nF\nT\nT\nT\n\n\n\nConclusão: Esta fórmula é uma tautologia.\n\nSolução para: \\(\\neg(P \\wedge Q) \\leftrightarrow (\\neg P \\vee \\neg Q)\\) (Esta é uma das Leis de De Morgan)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\wedge Q\\)\n\\(\\neg(P \\wedge Q)\\)\n\\(\\neg P\\)\n\\(\\neg Q\\)\n\\(\\neg P \\vee \\neg Q\\)\n\\(\\neg(P \\wedge Q) \\leftrightarrow (\\neg P \\vee \\neg Q)\\)\n\n\n\n\nT\nT\nT\nF\nF\nF\nF\nT\n\n\nT\nF\nF\nT\nF\nT\nT\nT\n\n\nF\nT\nF\nT\nT\nF\nT\nT\n\n\nF\nF\nF\nT\nT\nT\nT\nT\n\n\n\nConclusão: A fórmula é uma tautologia, confirmando a validade da Lei de De Morgan.\n\nSolução para o argumento:\n\n\nPremissa 1: Se o programa é eficiente, o custo é baixo (\\(P \\rightarrow Q\\)).\nPremissa 2: O programa é eficiente (\\(P\\)).\nConclusão: O custo é baixo (\\(Q\\)).\nFórmula a ser testada: \\(((P \\rightarrow Q) \\wedge P) \\rightarrow Q\\). Esta é a mesma fórmula do exercício 4.\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\((P \\rightarrow Q) \\wedge P\\)\n\\(((P \\rightarrow Q) \\wedge P) \\rightarrow Q\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\n\n\nF\nF\nT\nF\nT\n\n\n\nConclusão: Como a fórmula que representa o argumento é uma\ntautologia, o argumento é válido.\n\nSolução para: \\((P \\vee Q) \\rightarrow (P \\wedge Q)\\)\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\vee Q\\)\n\\(P \\wedge Q\\)\n\\((P \\vee Q) \\rightarrow (P \\wedge Q)\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nT\nF\nF\n\n\nF\nT\nT\nF\nF\n\n\nF\nF\nF\nF\nT\n\n\n\nConclusão: A fórmula é contingente (satisfatível e falsificável).\n\n\n14.1.3 Exercícios: Simplificação com Equivalências Lógicas\n\nSolução para: $ (P Q) $**:\n\n\\[\n\\begin{align*}\n\\neg(P \\vee \\neg Q) &\\equiv \\neg P \\wedge \\neg(\\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv \\neg P \\wedge Q && \\text{Lei da Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para: \\(P \\vee (P \\wedge Q)\\): (Esta é a Lei da Absorção)\n\n\\[\n\\begin{align*}\nP \\vee (P \\wedge Q) &\\equiv (P \\wedge TRUE) \\vee (P \\wedge Q) && \\text{Lei da Identidade} \\\\\n&\\equiv P \\wedge (TRUE \\vee Q) && \\text{Lei da Distributividade} \\\\\n&\\equiv P \\wedge TRUE && \\text{Lei do Domínio} \\\\\n&\\equiv P && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para: \\(\\neg(P \\rightarrow \\neg Q)\\)\n\n\\[\n\\begin{align*}\n\\neg(P \\rightarrow \\neg Q) &\\equiv \\neg(\\neg P \\vee \\neg Q) && \\text{Definição de Implicação} \\\\\n&\\equiv \\neg(\\neg P) \\wedge \\neg(\\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv P \\wedge Q && \\text{Lei da Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para: \\((P \\vee Q) \\wedge (\\neg P \\vee Q)\\):\n\n\\[\n\\begin{align*}\n(P \\vee Q) \\wedge (\\neg P \\vee Q) &\\equiv (Q \\vee P) \\wedge (Q \\vee \\neg P) && \\text{Lei da Comutatividade} \\\\\n&\\equiv Q \\vee (P \\wedge \\neg P) && \\text{Lei da Distributividade} \\\\\n&\\equiv Q \\vee FALSE && \\text{Lei da Contradição} \\\\\n&\\equiv Q && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para: \\((P \\rightarrow Q) \\vee (Q \\rightarrow P)\\)\n\n\\[\n\\begin{align*}\n(P \\rightarrow Q) \\vee (Q \\rightarrow P) &\\equiv (\\neg P \\vee Q) \\vee (\\neg Q \\vee P) && \\text{Definição de Implicação} \\\\\n&\\equiv (\\neg P \\vee P) \\vee (Q \\vee \\neg Q) && \\text{Leis da Associatividade e Comutatividade} \\\\\n&\\equiv TRUE \\vee TRUE && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Idempotência da Disjunção}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\nSolução para: \\(\\neg(P \\leftrightarrow Q)\\) (Esta é a definição de “ou exclusivo”, XOR)\n\n\\[\n\\begin{align*}\n\\neg(P \\leftrightarrow Q) &\\equiv \\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) && \\text{Definição de Equivalência} \\\\\n&\\equiv \\neg(P \\rightarrow Q) \\vee \\neg(Q \\rightarrow P) && \\text{Lei de De Morgan} \\\\\n&\\equiv \\neg(\\neg P \\vee Q) \\vee \\neg(\\neg Q \\vee P) && \\text{Definição de Implicação} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P) && \\text{Lei de De Morgan e Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para: \\((P \\wedge Q) \\rightarrow (P \\vee Q)\\)\n\n\\[\n\\begin{align*}\n(P \\wedge Q) \\rightarrow (P \\vee Q) &\\equiv \\neg(P \\wedge Q) \\vee (P \\vee Q) && \\text{Definição de Implicação} \\\\\n&\\equiv (\\neg P \\vee \\neg Q) \\vee (P \\vee Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv (\\neg P \\vee P) \\vee (\\neg Q \\vee Q) && \\text{Leis da Associatividade e Comutatividade} \\\\\n&\\equiv TRUE \\vee TRUE && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Idempotência da Disjunção}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\nSolução para: \\((P \\vee Q) \\wedge \\neg(\\neg P \\wedge Q)\\)\n\n\\[\n\\begin{align*}\n(P \\vee Q) \\wedge \\neg(\\neg P \\wedge Q) &\\equiv (P \\vee Q) \\wedge (\\neg(\\neg P) \\vee \\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv (P \\vee Q) \\wedge (P \\vee \\neg Q) && \\text{Lei da Dupla Negação} \\\\\n&\\equiv P \\vee (Q \\wedge \\neg Q) && \\text{Lei da Distributividade} \\\\\n&\\equiv P \\vee FALSE && \\text{Lei da Contradição} \\\\\n&\\equiv P && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para: \\((A \\wedge \\neg B) \\vee (A \\vee \\neg B)\\):\n\n\\[\n\\begin{align*}\n(A \\wedge \\neg B) \\vee (A \\vee \\neg B) &\\equiv (A \\vee (A \\vee \\neg B)) \\wedge (\\neg B \\vee (A \\vee \\neg B)) && \\text{Lei da Distributividade} \\\\\n&\\equiv (A \\vee A \\vee \\neg B) \\wedge (\\neg B \\vee \\neg B \\vee A) && \\text{Lei da Associatividade (e Comutatividade)} \\\\\n&\\equiv (A \\vee \\neg B) \\wedge (\\neg B \\vee A) && \\text{Lei da Idempotência} \\\\\n&\\equiv (A \\vee \\neg B) \\wedge (A \\vee \\neg B) && \\text{Lei da Comutatividade} \\\\\n&\\equiv A \\vee \\neg B && \\text{Lei da Idempotência}\n\\end{align*}\n\\]\nObservação: apesar de a aplicação da distributividade ser válida, o passo inicial pode parecer confuso. Um método mais direto é reconhecer que $ (A B) (A B) $ é equivalente a $ A B $, pois $ A B $ já cobre todas as possibilidades onde $ A B $ é verdadeiro.\nResultado final: $ A B $\n\nSolução para: $ ((P Q) (Q R)) (P R) $:\n\n\\[\n\\begin{align*}\n&((P \\rightarrow Q) \\wedge (Q \\rightarrow R)) \\rightarrow (P \\rightarrow R) \\\\\n&\\equiv \\neg ((\\neg P \\vee Q) \\wedge (\\neg Q \\vee R)) \\vee (\\neg P \\vee R) && \\text{Definição de Implicação (3x)} \\\\\n&\\equiv (\\neg(\\neg P \\vee Q) \\vee \\neg(\\neg Q \\vee R)) \\vee (\\neg P \\vee R) && \\text{Lei de De Morgan} \\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg R)) \\vee (\\neg P \\vee R) && \\text{De Morgan e Dupla Negação} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (Q \\wedge \\neg R) \\vee \\neg P \\vee R && \\text{Lei da Associatividade} \\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee \\neg P) \\vee ((Q \\wedge \\neg R) \\vee R) && \\text{Comutatividade e Associatividade} \\\\\n&\\equiv ((P \\vee \\neg P) \\wedge (\\neg Q \\vee \\neg P)) \\vee ((Q \\vee R) \\wedge (\\neg R \\vee R)) && \\text{Lei da Distributividade (2x)} \\\\\n&\\equiv (TRUE \\wedge (\\neg Q \\vee \\neg P)) \\vee ((Q \\vee R) \\wedge TRUE) && \\text{Lei do Terceiro Excluído (2x)} \\\\\n&\\equiv (\\neg Q \\vee \\neg P) \\vee (Q \\vee R) && \\text{Lei da Identidade (2x)} \\\\\n&\\equiv (\\neg Q \\vee Q) \\vee (\\neg P \\vee R) && \\text{Comutatividade e Associatividade} \\\\\n&\\equiv TRUE \\vee (\\neg P \\vee R) && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Lei do Domínio}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\n\n14.1.4 Exercícios: Provas com Regras de Inferência\n\nSolução:\n\n\\(P \\rightarrow Q\\) (Premissa 1)\n\\(P\\) (Premissa 2)\n\\(Q\\) (1, 2, Modus Ponens)\n\nSolução:\n\n\\(A \\rightarrow B\\) (Premissa 1)\n\\(\\neg B\\) (Premissa 2)\n\\(\\neg A\\) (1, 2, Modus Tollens)\n\nSolução:\n\n\\(P \\wedge Q\\) (Premissa 1)\n\\(P \\rightarrow R\\) (Premissa 2)\n\\(P\\) (1, Simplificação)\n\\(R\\) (2, 3, Modus Ponens)\n\nSolução:\n\n\\(S \\rightarrow \\neg T\\) (Premissa 1)\n\\(T\\) (Premissa 2)\n\\(S \\vee U\\) (Premissa 3)\n\\(\\neg\\neg T\\) (2, Dupla Negação)\n\\(\\neg S\\) (1, 4, Modus Tollens)\n\\(U\\) (3, 5, Silogismo Disjuntivo / Modus Tollendo Ponens)\n\nSolução:\n\n\\(A\\) (Premissa 1)\n\\(B\\) (Premissa 2)\n\\((A \\wedge B) \\rightarrow C\\) (Premissa 3)\n\\(A \\wedge B\\) (1, 2, Adjunção)\n\\(C\\) (3, 4, Modus Ponens)\n\nSolução:\n\n\\(P \\rightarrow Q\\) (Premissa 1)\n\\(Q \\rightarrow R\\) (Premissa 2)\n\\(P \\rightarrow R\\) (1, 2, Silogismo Hipotético)\n\n(Nota: Esta é uma aplicação direta da regra de inferência Silogismo Hipotético.)\nSolução:\n\n\\(A \\rightarrow B\\) (Premissa 1)\n\\(C \\rightarrow D\\) (Premissa 2)\n\\(A \\vee C\\) (Premissa 3)\n\\(B \\vee D\\) (1, 2, 3, Dilema Construtivo)\n\n(Nota: Esta é uma aplicação direta da regra de inferência Dilema Construtivo.)\nSolução:\n\n\\(\\neg A \\vee B\\) (Premissa 1)\n\\(C \\rightarrow A\\) (Premissa 2)\n\\(C\\) (Premissa 3)\n\\(A\\) (2, 3, Modus Ponens)\n\\(B\\) (1, 4, Silogismo Disjuntivo / Modus Tollendo Ponens)\n\n(Justificativa do passo 5: Como temos \\(\\neg A \\vee B\\) e provamos \\(A\\), a primeira parte da disjunção, \\(\\neg A\\), é falsa. Logo, a segunda parte, \\(B\\), deve ser verdadeira.)\nSolução:\n\nPremissas:\n\n\n\\(S \\rightarrow D\\)\n\\(D \\rightarrow R\\)\n\\(S\\)\n\n\nConclusão: \\(R\\)\nProva:\n\n\n\\(S \\rightarrow D\\) (Premissa 1)\n\\(D \\rightarrow R\\) (Premissa 2)\n\\(S\\) (Premissa 3)\n\\(S \\rightarrow R\\) (1, 2, Silogismo Hipotético)\n\\(R\\) (3, 4, Modus Ponens)\n\nSolução:\n\n\\((P \\wedge Q) \\rightarrow R\\) (Premissa 1)\n\\(\\neg R \\vee S\\) (Premissa 2)\n\\(P\\) (Premissa 3)\n\\(Q \\wedge T\\) (Premissa 4)\n\\(Q\\) (4, Simplificação)\n\\(P \\wedge Q\\) (3, 5, Adjunção)\n\\(R\\) (1, 6, Modus Ponens)\n\\(R \\rightarrow S\\) (2, Definição de Implicação)\n\\(S\\) (7, 8, Modus Ponens)\n\n\n\n\n14.1.5 Exercícios: Análise Semântica de Fórmulas\n\nSolução para \\(P \\rightarrow (P \\wedge Q)\\):\nClassificação: Contingência.\nJustificativa (Tabela-Verdade):\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\wedge Q\\)\n\\(P \\rightarrow (P \\wedge Q)\\)\n\n\n\n\nT\nT\nT\nT\n\n\nT\nF\nF\nF\n\n\nF\nT\nF\nT\n\n\nF\nF\nF\nT\n\n\n\nA coluna final possui tanto T quanto F.\nSolução para \\((P \\vee Q) \\vee (\\neg P \\wedge \\neg Q)\\):\nClassificação: Tautologia.\nJustificativa (Simplificação):\n\\[\n\\begin{align*}\n(P \\vee Q) \\vee (\\neg P \\wedge \\neg Q) &\\equiv (P \\vee Q) \\vee \\neg(P \\vee Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv TRUE && \\text{Lei do Terceiro Excluído (na forma } X \\vee \\neg X)\n\\end{align*}\n\\]\nSolução para \\((P \\leftrightarrow Q) \\wedge (P \\wedge \\neg Q)\\):\n\nClassificação: Contradição.\nJustificativa (Análise Lógica):\nPara a fórmula ser verdadeira, ambas as partes da conjunção precisam ser verdadeiras.\n\nA segunda parte, \\((P \\wedge \\neg Q)\\), só é verdadeira se \\(P=T\\) e \\(Q=F\\).\nVamos testar essa valoração na primeira parte: \\((P \\leftrightarrow Q)\\) se torna \\((T \\leftrightarrow F)\\), que é \\(FALSO\\).\nPortanto, a conjunção inteira se torna \\((FALSO \\wedge VERDADEIRO)\\), que é \\(FALSO\\).\n\nComo não existe nenhuma valoração que torne a fórmula verdadeira, ela é uma contradição.\n\nSolução (Valoração Verdadeira):\n\nUma implicação \\(X \\rightarrow Y\\) é verdadeira se o antecedente \\(X\\) for falso, ou se o consequente \\(Y\\) for verdadeiro.\n\nMétodo 1 (Consequente Verdadeiro): Vamos tornar \\((C \\rightarrow A)\\) verdadeiro. Isso acontece se \\(A=T\\).\nValoração: \\(A=T, B=T, C=T\\).\nVerificação: \\((\\neg T \\vee T) \\rightarrow (T \\rightarrow T) \\equiv (F \\vee T) \\rightarrow T \\equiv T \\rightarrow T \\equiv T\\). A valoração funciona.\n\n\nSolução (Valoração Falsa):\n\nUma implicação \\(X \\rightarrow Y\\) só é falsa se o antecedente \\(X\\) for verdadeiro e o consequente \\(Y\\) for falso.\n\nTornar o consequente \\((C \\rightarrow A)\\) falso: Para isso, precisamos de \\(C=T\\) e \\(A=F\\).\nVerificar se o antecedente \\((\\neg A \\vee B)\\) é verdadeiro com \\(A=F\\): \\((\\neg F \\vee B) \\equiv (T \\vee B)\\), que é sempre \\(T\\), não importa o valor de \\(B\\).\n\n\nValoração: \\(A=F, B=F, C=T\\).\nVerificação: \\((\\neg F \\vee F) \\rightarrow (T \\rightarrow F) \\equiv (T \\vee F) \\rightarrow F \\equiv T \\rightarrow F \\equiv F\\). A valoração funciona.\n\n\nSolução para \\((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\\):\n\nClassificação: Tautologia.\nJustificativa: Esta é uma das fórmulas axiomáticas da Lógica Proposicional, conhecida como Axioma de Frege. Provar por simplificação é longo, e por tabela-verdade requer 8 linhas. Todas as valorações possíveis resultam em Verdadeiro. É um princípio fundamental que permite a distribuição da implicação.\n\nSolução para \\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\wedge Q))\\):\n\nClassificação: Tautologia:\nJustificativa (Tabela-Verdade):\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(P \\wedge Q\\)\n\\(P \\leftrightarrow (P \\wedge Q)\\)\n\\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\wedge Q))\\)\n\n\n\n\nT\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\nT\n\n\nF\nF\nT\nF\nT\nT\n\n\n\nComo a coluna final só contém T, a fórmula é uma tautologia.\n\nSolução para \\(\\neg(((P \\vee Q) \\rightarrow P) \\vee Q)\\):\n\nClassificação: Contradição.:\nJustificativa (Simplificação):\n\\[\n\\begin{align*}\n\\neg(((P \\vee Q) \\rightarrow P) \\vee Q) &\\equiv \\neg((\\neg(P \\vee Q) \\vee P) \\vee Q) && \\text{Def. Implicação} \\\\\n&\\equiv \\neg(((\\neg P \\wedge \\neg Q) \\vee P) \\vee Q) && \\text{De Morgan} \\\\\n&\\equiv \\neg(((\\neg P \\vee P) \\wedge (\\neg Q \\vee P)) \\vee Q) && \\text{Distributividade} \\\\\n&\\equiv \\neg((TRUE \\wedge (\\neg Q \\vee P)) \\vee Q) && \\text{Terceiro Excluído} \\\\\n&\\equiv \\neg((\\neg Q \\vee P) \\vee Q) && \\text{Identidade} \\\\\n&\\equiv \\neg(\\neg Q \\vee Q \\vee P) && \\text{Associatividade} \\\\\n&\\equiv \\neg(TRUE \\vee P) && \\text{Terceiro Excluído} \\\\\n&\\equiv \\neg(TRUE) && \\text{Domínio} \\\\\n&\\equiv FALSE && \\text{Negação}\n\\end{align*}\n\\]\n\nSolução para o argumento:\n\nNão, não é logicamente consistente.\nJustificativa:\n\nA regra é: \\(D \\leftrightarrow (C \\wedge \\neg E)\\).\nA situação a ser testada é: \\(D \\wedge \\neg C\\). Para que isso seja verdade, \\(D=T\\) e \\(C=F\\).\nVamos substituir esses valores na regra: \\(T \\leftrightarrow (F \\wedge \\neg E)\\).\nA expressão \\((F \\wedge \\neg E)\\) será sempre \\(FALSO\\), não importa o valor de \\(E\\).\nEntão, a regra se torna \\(T \\leftrightarrow FALSO\\), o que é uma contradição (\\(FALSO\\)).\nComo a situação (\\(D \\wedge \\neg C\\)) leva a uma contradição da regra, ela não é consistente com a regra. É impossível satisfazer ambas as fórmulas ao mesmo tempo.\nSolução para \\((A \\leftrightarrow B) \\vee (B \\leftrightarrow C)\\):\n\nClassificação: Contingência.\nJustificativa (Análise de Casos):\n\nPode ser Verdadeiro: Se \\(A=T, B=T, C=T\\), a fórmula se torna \\((T \\leftrightarrow T) \\vee (T \\leftrightarrow T) \\equiv T \\vee T \\equiv T\\).\nPode ser Falso: Se \\(A=T, B=F, C=T\\), a fórmula se torna \\((T \\leftrightarrow F) \\vee (F \\leftrightarrow T) \\equiv F \\vee F \\equiv F\\). Como a fórmula pode ser tanto verdadeira quanto falsa dependendo da valoração, ela é uma contingência.\n\n\n\n14.1.6 Exercícios: Conexão com o Prolog\nQuestão 1: Diagnóstico de Sistema\n\nModelagem (Base de Conhecimento):\n\n\nS: O servidor está sobrecarregado.\n\nL: A latência da rede aumenta.\n\nN: O sistema de alerta envia uma notificação.\n\nRegras:\n\n\\(P_1: S \\to L\\)\n\n\\(P_2: L \\to N\\)\n\nFato:\n\n\\(P_3: \\neg N\\)\n\nConsulta: Prove \\(\\neg S\\).\n\nDedução Lógica (usando Modus Tollens):\n\n\nA partir de \\(P_2 (L \\to N)\\) e \\(P_3 (\\neg N)\\), podemos inferir \\(\\neg L\\) pela regra de Modus Tollens.\n\nAgora, usando \\(P_1 (S \\to L)\\) e nossa nova inferência \\(\\neg L\\), aplicamos Modus Tollens novamente para concluir \\(\\neg S\\).\n\nAlternativamente, podemos primeiro combinar \\(P_1\\) e \\(P_2\\) usando o Silogismo Hipotético: de \\((S \\to L)\\) e \\((L \\to N)\\), inferimos \\((S \\to N)\\). Com \\((S \\to N)\\) e \\(P_3 (\\neg N)\\), aplicamos Modus Tollens para obter \\(\\neg S\\).\n\n\nConexão com Prolog: Este exemplo mostra como fatos e regras interagem para produzir novas conclusões. Em Prolog, teríamos:\n\nlatencia_aumenta(X) :- servidor_sobrecarregado(X).\nalerta_enviado(X) :- latencia_aumenta(X).\n% Fato observado: não há alerta\n% Consulta: ?- servidor_sobrecarregado(servidor1).\n% Resposta: false (devido à cadeia de inferências)\nQuestão 2: Validação de Circuito Lógico (Half-Adder)\n\nTradução para Fórmulas:\n\n\nA condição para a saída S (“exatamente uma das entradas”) é um “ou exclusivo” (XOR):\n\\[S \\leftrightarrow (A \\wedge \\neg B) \\vee (\\neg A \\wedge B)\\]\nEm muitos contextos, isso é escrito como \\(A \\oplus B\\).\n\nA condição para a saída C (“ambas as entradas”):\n\\[C \\leftrightarrow A \\wedge B\\]\n\n\nTabela Verdade para Equivalência:\n\nVamos comparar a fórmula de S com a fórmula proposta \\(F \\equiv (A \\vee B) \\wedge \\neg(A \\wedge B)\\).\n\n\n\n\n\n\n\n\n\n\n\n\nA\nB\n\\(A \\oplus B\\) (Saída S)\n\\(A \\vee B\\)\n\\(A \\wedge B\\)\n\\(\\neg(A \\wedge B)\\)\n\\((A \\vee B) \\wedge \\neg(A \\wedge B)\\) (Fórmula F)\n\n\n\n\nT\nT\nF\nT\nT\nF\nF\n\n\nT\nF\nT\nT\nF\nT\nT\n\n\nF\nT\nT\nT\nF\nT\nT\n\n\nF\nF\nF\nF\nF\nT\nF\n\n\n\n\nConclusão: A coluna para a saída S e a coluna para a fórmula F são idênticas. Portanto, as duas fórmulas são logicamente equivalentes.\nConexão com Prolog: Em Prolog, poderíamos modelar o half-adder como:\n\nhalf_adder_sum(A, B, S) :- (A, \\+ B); (\\+ A, B).\nhalf_adder_carry(A, B, C) :- A, B.\nQuestão 3: Análise de Contrato de Serviço \n\nModelagem:\n\n\nU: Uptime &lt; 99%\n\nC: Cliente recebe crédito\n\nT: Cliente abre ticket\n\nD: Cliente recebe desconto\n\nRegras:\n\n\\(P_1: U \\to C\\)\n\n\\(P_2: C \\to T\\)\n\n\\(P_3: \\neg(C \\wedge D)\\) (não pode ter ambos)\n\nFatos:\n\n\\(F_1: U\\) (uptime foi 98%)\n\n\\(F_2: \\neg T\\) (cliente não abriu ticket)\n\n\nAnálise da Contradição:\n\n\nDe \\(P_1 (U \\to C)\\) e \\(F_1 (U)\\), por Modus Ponens, concluímos \\(C\\).\n\nDe \\(P_2 (C \\to T)\\) e nossa conclusão \\(C\\), por Modus Ponens, deveríamos concluir \\(T\\).\n\nMas temos o fato \\(F_2 (\\neg T)\\).\n\nIsso cria uma contradição: \\(T \\wedge \\neg T\\).\n\n\nConclusão: As regras do contrato são inconsistentes. Quando o uptime é baixo mas o cliente não abre um ticket, o sistema de regras gera uma contradição. O contrato precisa ser reformulado para ser logicamente consistente.\nReformulação Sugerida: Modificar a regra 1 para: “Se o uptime for menor que 99% E o cliente abrir um ticket, então receberá um crédito”: \\((U \\wedge T) \\to C\\).\nConexão com Prolog: Este tipo de inconsistência poderia ser detectada automaticamente em Prolog:\n\n% Regras inconsistentes\ncredito(Cliente) :- uptime_baixo(Cliente).\ncredito(Cliente) :- ticket_aberto(Cliente).\n\n% Fatos\nuptime_baixo(cliente1).\n\\+ ticket_aberto(cliente1).\n\n% Consulta que revelaria a inconsistência\n?- credito(cliente1), \\+ ticket_aberto(cliente1).\n% A inconsistência seria revelada pela análise lógica\nQuestão 4: Dependências de Compilação\n\nModelagem Correta:\n“Para compilar X, Y deve estar compilado” traduz-se em “Y deve estar compilado antes de X poder ser compilado”, ou seja: a capacidade de compilar X depende de Y estar compilado.\n\nRegras de Dependência:\n* \\(R_1: C \\to U\\) (para C ser compilado, U deve estar compilado)\n* \\(R_2: A \\to C\\) (para A ser compilado, C deve estar compilado)\n* \\(R_3: G \\to (A \\wedge L)\\) (para G ser compilado, A e L devem estar compilados)\nFato:\n* \\(F_1: U\\) (utils já compilado)\n\nAnálise de Viabilidade:\nPara compilar G, precisamos de A e L. A cadeia de dependências é: \\[G \\to (A \\wedge L) \\to (C \\wedge L) \\to (U \\wedge C \\wedge L)\\]\n\nA condição completa para compilar G é: \\(G \\to (U \\wedge C \\wedge A \\wedge L)\\).\n\nConclusão:\n\n\n\nTemos U compilado\n\nPodemos compilar C (pois U está disponível)\n\nPodemos compilar A (pois C pode ser compilado)\n\nNÃO podemos compilar G pois não sabemos o estado de L\n\nÉ necessário que a biblioteca assets (L) também seja compilada.\n\nConexão com Prolog:\n\npode_compilar(utils).\npode_compilar(core) :- pode_compilar(utils).\npode_compilar(api) :- pode_compilar(core).\npode_compilar(gui) :- pode_compilar(api), pode_compilar(assets).\n\n% Consulta: ?- pode_compilar(gui).\n% Resposta: false (pois assets não está definido)\nQuestão 5: Regras de um Jogo\n\nSimplificação da Condição de Vitória:\n\nSubstituindo a suposição F = verdadeiro e o fato \\(\\neg E\\) = verdadeiro:\n\n\\(T \\leftrightarrow (T \\wedge A) \\implies T \\leftrightarrow A\\) (já que F é verdadeiro)\n\n\\(A \\leftrightarrow (D \\vee F) \\implies A \\leftrightarrow D\\) (já que E é falso)\n\nPortanto: \\(T \\leftrightarrow D\\)\n\nAnálise da Condição para Derrotar o Dragão:\n\n\nA regra \\(D \\to S\\) estabelece que ter a espada é necessário para derrotar o dragão.\n\nO fato S nos diz que essa condição necessária é satisfeita.\n\nContudo, \\(D \\to S\\) não nos permite concluir D a partir de S (isso seria a falácia de afirmar o consequente).\n\n\nConclusão: Supondo que o jogador chegue à casa final, ele vencerá o jogo se, e somente se, derrotar o dragão (D). A posse da espada é uma pré-condição satisfeita, mas a derrota do dragão ainda deve ocorrer no mundo do jogo.\nConexão com Prolog: Este cenário de jogo poderia ser modelado em Prolog como:\n\n% Fatos\npossui(heroi, espada_prata).\nchegou_casa_final(heroi).\n\\+ resolveu_enigma(heroi).\n\n% Regras\nvence(X) :- chegou_casa_final(X), possui_amuleto(X).\npossui_amuleto(X) :- derrotou_dragao(X).\npossui_amuleto(X) :- resolveu_enigma(X).\npode_enfrentar_dragao(X) :- possui(X, espada_prata).\n\n% Consulta\n?- vence(heroi).\n% Dependeria de derrotou_dragao(heroi) ser provado\nQuestão 6: Decisão de um Robô Autônomo\n\nDedução da Contradição:\n\n\nDe O e \\(P_1 (O \\to (P \\wedge G))\\), por Modus Ponens: \\((P \\wedge G)\\), logo P e G.\n\nDe B e \\(P_2 (B \\to (P \\wedge R))\\), por Modus Ponens: \\((P \\wedge R)\\), logo P e R.\n\nDas inferências: G é verdadeiro e R é verdadeiro, portanto \\((G \\wedge R)\\) é verdadeiro.\n\nMas \\(P_3\\) afirma \\(\\neg(G \\wedge R)\\).\n\nContradição: \\((G \\wedge R) \\wedge \\neg(G \\wedge R)\\).\n\n\nResolução do Conflito:\n\nIntroduzir hierarquia de prioridades. Sugestão:\nRegra 1 Modificada: \\((O \\wedge \\neg B) \\to (P \\wedge G)\\)\nCom esta modificação, quando O e B são ambos verdadeiros, apenas a Regra 2 é acionada, e o robô para e retorna à base, eliminando a contradição.\n\nConexão com Prolog: Este exemplo ilustra a importância da ordem das regras em Prolog e como conflitos podem ser resolvidos através de condições mais específicas:\n\n% Versão com conflito\nacao_robo(parar_girar) :- obstaculo_detectado.\nacao_robo(parar_retornar) :- bateria_baixa.\n\n% Versão corrigida com prioridades\nacao_robo(parar_retornar) :- bateria_baixa.\nacao_robo(parar_girar) :- obstaculo_detectado, \\+ bateria_baixa.\n\n% Fatos\nobstaculo_detectado.\nbateria_baixa.\n\n% Consulta\n?- acao_robo(X).\n% X = parar_retornar (prioridade para bateria baixa)\nQuestão 7: Simplificação de Query de Banco de Dados \n\nTabela Verdade Completa:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA\nS\nC\n\\(S \\vee C\\)\n\\(A \\wedge (S \\vee C)\\)\n\\(S \\wedge C\\)\n\\(\\neg A \\wedge (S \\wedge C)\\)\nFórmula Original\n\n\n\n\nT\nT\nT\nT\nT\nT\nF\nT\n\n\nT\nT\nF\nT\nT\nF\nF\nT\n\n\nT\nF\nT\nT\nT\nF\nF\nT\n\n\nT\nF\nF\nF\nF\nF\nF\nF\n\n\nF\nT\nT\nT\nF\nT\nT\nT\n\n\nF\nT\nF\nT\nF\nF\nF\nF\n\n\nF\nF\nT\nT\nF\nF\nF\nF\n\n\nF\nF\nF\nF\nF\nF\nF\nF\n\n\n\n\nForma Normal Disjuntiva Mínima:\n\nA fórmula é verdadeira para os seguintes mintermos:\n\n\\(A \\wedge S \\wedge C\\) (linha 1);\n\n\\(A \\wedge S \\wedge \\neg C\\) (linha 2);\n\n\\(A \\wedge \\neg S \\wedge C\\) (linha 3);\n\n\\(\\neg A \\wedge S \\wedge C\\) (linha 5).\n\nAgrupamento dos mintermos:\n\nAgrupando (1) e (2): \\((A \\wedge S \\wedge C) \\vee (A \\wedge S \\wedge \\neg C) \\equiv A \\wedge S\\);\n\nAgrupando (1) e (3): \\((A \\wedge S \\wedge C) \\vee (A \\wedge \\neg S \\wedge C) \\equiv A \\wedge C\\);\n\nAgrupando (1) e (4): \\((A \\wedge S \\wedge C) \\vee (\\neg A \\wedge S \\wedge C) \\equiv S \\wedge C\\).\n\nForma Normal Disjuntiva Mínima:\n\\((A \\wedge S) \\vee (A \\wedge C) \\vee (S \\wedge C)\\)\n\nVerificação: Esta forma não pode ser simplificada ainda mais sem perder informação, pois cada termo cobre casos distintos que não podem ser agrupados.\nEficiência: A forma simplificada \\((A \\wedge S) \\vee (A \\wedge C) \\vee (S \\wedge C)\\) é mais eficiente que a original pois:\n\n\nEstrutura “plana” de ORs de ANDs (Forma Normal Disjuntiva);\n\nPermite que o otimizador do banco use índices nas colunas A, S e C de forma mais eficaz;\n\nReduz operações lógicas aninhadas, diminuindo o custo computacional da consulta.\n\n\nConexão com Prolog: A simplificação lógica é fundamental em Prolog para otimização de consultas:\n\n% Consulta original (mais complexa)\nusuario_selecionado(U) :- \n (ativo(U), (sao_paulo(U) ; compras_altas(U))) ;\n (\\+ ativo(U), sao_paulo(U), compras_altas(U)).\n\n% Versão simplificada (mais eficiente)\nusuario_selecionado(U) :- ativo(U), sao_paulo(U).\nusuario_selecionado(U) :- ativo(U), compras_altas(U).\nusuario_selecionado(U) :- sao_paulo(U), compras_altas(U).\nQuestão 8: O Paradoxo do Mentiroso (Versão Proposicional)\n\nTabela Verdade:\nA fórmula \\(P \\leftrightarrow \\neg P\\) é equivalente a \\((P \\to \\neg P) \\wedge (\\neg P \\to P)\\).\n\n\n\n\nP\n\\(\\neg P\\)\n\\(P \\leftrightarrow \\neg P\\)\n\n\n\n\nT\nF\nF\n\n\nF\nT\nF\n\n\n\n\nAnálise: A tabela verdade mostra que a fórmula é sempre falsa, sendo portanto uma contradição.\nExplicação do Paradoxo: O paradoxo surge da autorreferência:\n\n\nSe a sentença é verdadeira, então deve ser o que afirma (falsa) → contradição\n\nSe a sentença é falsa, então sua afirmação é incorreta, logo deve ser verdadeira → contradição\n\n\nLimitações da Lógica Clássica: A lógica proposicional clássica não foi projetada para autorreferência. Lógicas paraconsistentes ou de múltiplos valores foram desenvolvidas para lidar com tais paradoxos.\nConexão com Prolog: O Prolog evita este tipo de paradoxo através de sua semântica operacional e da negação por falha:\n\n% Em Prolog, não podemos expressar diretamente:\n% p :- \\+ p.  % Isso causaria um loop infinito\n\n% O Prolog usa \"negação por falha\" que é diferente da negação lógica\n% Se algo não pode ser provado, é assumido como falso\nfalso_se_nao_provavel(X) :- \\+ provavel(X).\n\n% Isso evita contradições autorreferentes\nQuestão 9: Política de Firewall\n\nDedução Lógica:\n\n\nTemos \\(\\neg P\\) (verdadeiro).\n\nA premissa da Regra 2 é \\((\\neg I \\vee \\neg P)\\).\n\nComo \\(\\neg P\\) é verdadeiro, a disjunção \\((\\neg I \\vee \\neg P)\\) é verdadeira.\n\nPor Modus Ponens na Regra 2: A é verdadeiro.\n\n\nAnálise de Redundância:\nA condição total para A é: \\(((I \\wedge P) \\vee (\\neg I \\vee \\neg P))\\).\n\nPor De Morgan: \\((\\neg I \\vee \\neg P) \\equiv \\neg(I \\wedge P)\\).\nLogo: \\(A \\leftrightarrow ((I \\wedge P) \\vee \\neg(I \\wedge P))\\).\nSeja \\(X = (I \\wedge P)\\). A condição torna-se \\(X \\vee \\neg X\\), que é uma tautologia.\n\nConclusão: A política permite todas as requisições. É completamente ineficaz e altamente redundante, não bloqueando nada.\nConexão com Prolog: Este tipo de problema pode ser detectado analisando as regras em Prolog:\n\n% Política de firewall redundante\npermitida(Req) :- rede_interna(Req), porta_443(Req).\npermitida(Req) :- \\+ rede_interna(Req).\npermitida(Req) :- \\+ porta_443(Req).\n\n% Teste que mostra que tudo é permitido\n?- permitida(qualquer_requisicao).\n% true (sempre, devido à redundância)\n\n% Versão corrigida seria mais restritiva\npermitida(Req) :- rede_interna(Req).\npermitida(Req) :- \\+ rede_interna(Req), conexao_segura(Req).\nQuestão 10: Tautologia, Contradição ou Contingência?\n\nAnálise de Cenário Crítico:\nConsidere o caso onde T = verdadeiro e T = falso (fez treinamento, não bateu meta):\n\n\nPrimeira parte: \\((T \\vee T) \\to B\\)\nPremissa: \\((F \\vee T) = T\\) → Conclusão: B deve ser verdadeiro\nSegunda parte: \\((T \\wedge \\neg T) \\to \\neg B\\)\nPremissa: \\((T \\wedge T) = T\\) → Conclusão: B deve ser falso\nResultado: B deve ser simultaneamente verdadeiro e falso → contradição.\n\n\nDemonstração Formal:\nPara o caso \\((T \\wedge \\neg T)\\):\n\\[F \\equiv (T \\to B) \\wedge (T \\to \\neg B) \\equiv T \\wedge B \\wedge \\neg B\\]\n\nComo \\(B \\wedge \\neg B\\) é sempre falso, a fórmula é falsa para este caso específico.\n\nClassificação: A fórmula é uma contingência (pode ser verdadeira ou falsa dependendo dos valores), mas é logicamente inconsistente para o caso \\((T \\wedge \\neg T)\\).\nImplicação para a Empresa: A política de bônus é inaplicável - cria uma situação onde as regras simultaneamente concedem e negam o bônus para funcionários que fizeram treinamento mas não bateram a meta. A empresa precisa redefinir suas regras para serem consistentes.\nConexão com Prolog: Em Prolog, esta inconsistência seria revelada imediatamente:\n\n% Política inconsistente\nbonus(Func) :- meta_atingida(Func).\nbonus(Func) :- treinamento(Func).\n\\+ bonus(Func) :- treinamento(Func), \\+ meta_atingida(Func).\n\n% Fatos\ntreinamento(joao).\n\\+ meta_atingida(joao).\n\n% Consulta reveladoria\n?- bonus(joao).\n% Resultado inconsistente: true e false simultaneamente\n\n% Política corrigida\nbonus(Func) :- meta_atingida(Func).\nbonus(Func) :- treinamento(Func), meta_atingida(Func).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html#lógica-predicativa-sec-logica-predicativa",
    "href": "Solucao-Exercicios.html#lógica-predicativa-sec-logica-predicativa",
    "title": "14  Solução dos Exercícios",
    "section": "14.2 Lógica Predicativa Chapter 6",
    "text": "14.2 Lógica Predicativa Chapter 6\n\n14.2.1 Exercícios de Conexão com Prolog Section 7.3\nQuestão 1: Relações em um Sistema Acadêmico\nResoluções:\n\nExiste pelo menos um aluno: \\(\\exists x A(x)\\);\nNem todo aluno está matriculado em algum curso: \\(\\neg \\forall x (A(x) \\to \\exists y (C(y) \\wedge M(x,y)))\\);\nTodo aluno está matriculado em pelo menos um curso: \\(\\forall x (A(x) \\to \\exists y (C(y) \\wedge M(x,y)))\\);\nExiste um curso no qual nenhum aluno está matriculado: \\(\\exists y (C(y) \\wedge \\neg \\exists x (A(x) \\wedge M(x,y)))\\);\nExiste um aluno que está matriculado em todos os cursos: \\(\\exists x (A(x) \\wedge \\forall y (C(y) \\to M(x,y)))\\).\n\nConexão com Prolog: Em Prolog, estes predicados se tornariam fatos e regras:\naluno(joao).\ncurso(matematica).\nmatriculado(joao, matematica).\n\n% Consulta: ?- aluno(X).\n% Resposta: X = joao\nQuestão 2: O Escopo dos Quantificadores\nAnálise das Fórmulas:\n\nFórmula 1: \\(\\forall x \\exists y (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\nTradução: “Para toda pessoa x, existe uma pessoa y tal que x ama y”\nSignificado: Todo mundo ama alguém. A pessoa y que é amada pode ser diferente para cada x. Isso descreve o amor fraternal universal, onde o ato de amar é universal, mas o objeto do amor é individual.\n\nFórmula 2: \\(\\exists y \\forall x (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\nTradução: “Existe uma pessoa y tal que, para toda pessoa x, x ama y”\nSignificado: Existe um indivíduo específico (y) que é amado por todas as outras pessoas. Isso descreve a existência de uma figura universalmente amada.\n\n\nConexão com Prolog: A ordem dos quantificadores afeta diretamente como o Prolog resolve consultas e unifica variáveis.\nQuestão 3: O Paradoxo do Barbeiro\nResolução: 1. Tradução da Regra: A regra diz que o barbeiro (b) barbeia uma pessoa \\(x\\) se, e somente se, \\(x\\) não se barbeia a si mesmo: \\[\\forall x (Barbeia(b,x) \\leftrightarrow \\neg Barbeia(x,x))\\]\n\nDedução da Contradição: Vamos usar a Instanciação Universal, substituindo a variável universal \\(x\\) pela constante \\(b\\) (o próprio barbeiro): \\[Barbeia(b,b) \\leftrightarrow \\neg Barbeia(b,b)\\]\nSeja \\(P\\) a proposição \\(Barbeia(b,b)\\). A fórmula se torna \\(P \\leftrightarrow \\neg P\\). Como vimos na Lógica Proposicional, esta fórmula é uma contradição. Ela afirma que o barbeiro se barbeia se, e somente se, ele não se barbeia. Isso é impossível.\n\nConexão com Prolog: Este paradoxo ilustra por que o Prolog usa “negação por falha” em vez de negação clássica, evitando contradições deste tipo.\nQuestão 4: Especificação de um Sistema de Arquivos\nResolução:\n\nTradução da Política:\n\n\n“Qualquer administrador pode acessar todos os arquivos”:\n\n\\[\\forall x \\forall y ((Admin(x) \\wedge Arquivo(y)) \\to PodeAcessar(x,y))\\]\n\n“Ninguém que não seja administrador pode acessar algum arquivo”:\n\n\\[\\forall x \\forall y ((\\neg Admin(x) \\wedge Arquivo(y)) \\to \\neg PodeAcessar(x,y))\\]\n\nConclusões:\n\n\nPara \\(PodeAcessar(ana, relatorio.doc)\\): Dado \\(Admin(ana)\\), a primeira regra se aplica. Por Instanciação Universal com \\(x = ana\\) e \\(y = relatorio.doc\\), concluímos que \\(PodeAcessar(ana, relatorio.doc)\\) é verdadeiro.\nPara \\(PodeAcessar(beto, relatorio.doc)\\): Dado \\(\\neg Admin(beto)\\), a segunda regra se aplica. Por Instanciação Universal, concluímos que \\(\\neg PodeAcessar(beto, relatorio.doc)\\) é verdadeiro.\n\nConexão com Prolog:\nadmin(ana).\narquivo(relatorio_doc).\n\npode_acessar(X, Y) :- admin(X), arquivo(Y).\n\n% Consulta: ?- pode_acessar(ana, relatorio_doc).\n% Resposta: true\nQuestão 5: Negando Afirmações Universais\nResoluções:\n\nSentença Original: \\(\\forall x (Programa(x) \\to \\exists y (Bug(y) \\wedge Tem(x,y)))\\)\nNegação:\n\n\\[\\neg [\\forall x (Programa(x) \\to \\exists y (Bug(y) \\wedge Tem(x,y)))]\\]\n\\[\\equiv \\exists x \\neg [Programa(x) \\to \\exists y (Bug(y) \\wedge Tem(x,y))]\\]\n\\[\\equiv \\exists x [\\Programa(x) \\wedge \\neg \\exists y (Bug(y) \\wedge Tem(x,y))]\\]\n\\[\\equiv \\exists x [Programa(x) \\wedge \\forall y \\neg (Bug(y) \\wedge Tem(x,y))]\\]\n\\[\\equiv \\exists x [Programa(x) \\wedge \\forall y (Bug(y) \\to \\neg Tem(x,y))]\\]\nTradução: “Existe um programa de computador que não tem nenhum bug”\n\nSentença Original: \\(\\exists x (Politico(x) \\wedge \\forall y (Eleitor(y,x) \\to HonestoCom(x,y)))\\)\n\nNegação: \\[\\neg [\\exists x (Politico(x) \\wedge \\forall y (Eleitor(y,x) \\to HonestoCom(x,y)))]\\]\n\\[\\equiv \\forall x \\neg [Politico(x) \\wedge \\forall y (Eleitor(y,x) \\to HonestoCom(x,y))]\\]\n\\[\\equiv \\forall x [Politico(x) \\to \\neg \\forall y (Eleitor(y,x) \\to HonestoCom(x,y))]\\]\n\\[\\equiv \\forall x [Politico(x) \\to \\exists y \\neg (Eleitor(y,x) \\to HonestoCom(x,y))]\\]\n\\[\\equiv \\forall x [Politico(x) \\to \\exists y (Eleitor(y,x) \\wedge \\neg HonestoCom(x,y))]\\]\nTradução: “Todo político é desonesto com pelo menos um de seus eleitores”\nConexão com Prolog: A negação por falha em Prolog (\\+) aproxima-se dessas transformações lógicas.\nQuestão 6: Mundo dos Blocos (Planejamento em IA) - Corrigida\n\nModelagem Formal dos Axiomas:\n\nAxioma 1: Existe um bloco verde em cima de um bloco azul \\[\\exists x \\exists y (Bloco(x) \\wedge Bloco(y) \\wedge Verde(x) \\wedge Azul(y) \\wedge EmCima(x,y))\\]\nAxioma 2: Todo bloco que está diretamente sobre a mesa é azul \\[\\forall x ((Bloco(x) \\wedge NaMesa(x)) \\rightarrow Azul(x))\\]\nAxioma 3: Nenhum bloco pode estar simultaneamente em cima de outro bloco e sobre a mesa \\[\\forall x (Bloco(x) \\rightarrow \\neg(\\exists y (Bloco(y) \\wedge EmCima(x,y)) \\wedge NaMesa(x)))\\]\nAxioma 4: Nenhum bloco pode ser verde e azul simultaneamente \\[\\forall x (Bloco(x) \\rightarrow \\neg(Verde(x) \\wedge Azul(x)))\\]\n\nObjetivo: Provar que “Existe um bloco que não é verde” \\[\\exists x (Bloco(x) \\wedge \\neg Verde(x))\\]\nProva Formal:\n\nPasso 1: Do Axioma 1, por Instanciação Existencial, obtemos constantes \\(a\\) e \\(b\\) tais que: \\[Bloco(a) \\wedge Bloco(b) \\wedge Verde(a) \\wedge Azul(b) \\wedge EmCima(a,b)\\]\nPasso 2: Por Simplificação, podemos separar as propriedades:\n\n\n\\(Bloco(a)\\) é verdadeiro\n\\(Bloco(b)\\) é verdadeiro\n\n\\(Verde(a)\\) é verdadeiro\n\\(Azul(b)\\) é verdadeiro\n\\(EmCima(a,b)\\) é verdadeiro\n\n\nPasso 3: Do Axioma 4, por Instanciação Universal com \\(x = b\\): \\[Bloco(b) \\rightarrow \\neg(Verde(b) \\wedge Azul(b))\\]\nPasso 4: Como sabemos que \\(Bloco(b)\\) é verdadeiro (do Passo 2), por Modus Ponens: \\[\\neg(Verde(b) \\wedge Azul(b))\\]\nPasso 5: Aplicando De Morgan: \\[\\neg Verde(b) \\vee \\neg Azul(b)\\]\nPasso 6: Como sabemos que \\(Azul(b)\\) é verdadeiro (do Passo 2), e temos \\(\\neg Verde(b) \\vee \\neg Azul(b)\\), por Silogismo Disjuntivo: \\[\\neg Verde(b)\\]\nPasso 7: Combinando com \\(Bloco(b)\\) (do Passo 2) usando Adjunção: \\[Bloco(b) \\wedge \\neg Verde(b)\\]\nPasso 8: Por Generalização Existencial: \\[\\exists x (Bloco(x) \\wedge \\neg Verde(x))\\]\n\nC.Q.D. - Provamos que existe um bloco (especificamente o bloco \\(b\\)) que não é verde.\nAnálise Adicional:\nNote que o bloco \\(a\\) (verde) não pode estar na mesa devido ao Axioma 3, pois está em cima de \\(b\\). O bloco \\(b\\) (azul) poderia estar na mesa (consistente com o Axioma 2), mas isso não é necessário para a prova. O importante é que \\(b\\) é azul e, pelo Axioma 4, não pode ser simultaneamente verde.\n\nConexão com Prolog:\n% Definição dos fatos base do mundo dos blocos\nbloco(bloco_a).\nbloco(bloco_b).\nbloco(bloco_c).  % Podemos ter outros blocos no mundo\n\n% Axioma 1: Existe um bloco verde em cima de um bloco azul\nverde(bloco_a).\nazul(bloco_b).\nem_cima(bloco_a, bloco_b).\n\n% Axioma 2: Todo bloco que está sobre a mesa é azul\n% Implementado como regra\nazul(X) :- bloco(X), na_mesa(X).\n\n% Axioma 3: Nenhum bloco pode estar em cima de outro E na mesa\n% Implementado como restrição\nvalido(X) :- \n    bloco(X),\n    \\+ (em_cima(X, _), na_mesa(X)).\n\n% Axioma 4: Nenhum bloco pode ser verde e azul simultaneamente\n% Implementado como restrição\ncor_valida(X) :- \n    bloco(X),\n    \\+ (verde(X), azul(X)).\n\n% Regra derivada: Um bloco não é verde se é azul\nnao_verde(X) :- \n    bloco(X),\n    azul(X),\n    cor_valida(X).\n\n% Consulta principal: Existe um bloco que não é verde?\nexiste_bloco_nao_verde :- \n    bloco(X),\n    \\+ verde(X).\n\n% Testes\ntest_mundo_blocos :-\n    % Verificar que bloco_b não é verde\n    (nao_verde(bloco_b) -&gt;\n        write('Bloco b não é verde (correto)'), nl\n    ;   write('Erro: Bloco b deveria não ser verde'), nl),\n    \n    % Verificar que existe pelo menos um bloco não verde\n    (existe_bloco_nao_verde -&gt;\n        write('Existe um bloco que não é verde (teorema provado)'), nl\n    ;   write('Erro: Deveria existir um bloco não verde'), nl),\n    \n    % Verificar consistência das cores\n    (cor_valida(bloco_a), cor_valida(bloco_b) -&gt;\n        write('Cores são consistentes com Axioma 4'), nl\n    ;   write('Erro: Violação do Axioma 4'), nl).\n\n% Consulta\n% ?- existe_bloco_nao_verde.\n% true.\n\n% ?- nao_verde(X).\n% X = bloco_b.\nQuestão 7: Propriedades dos Números Inteiros \nResoluções: 1. Todo número par é maior que algum número ímpar: \\[\\forall x (Par(x) \\to \\exists y (Impar(y) \\wedge x &gt; y))\\]\n\nNão existe um número inteiro que seja o maior de todos: \\[\\neg \\exists x \\forall y (y \\leq x)\\] ou, de forma equivalente: \\[\\forall x \\exists y (y &gt; x)\\]\nA soma de quaisquer dois números pares é par: \\[\\forall x \\forall y ((Par(x) \\wedge Par(y)) \\to Par(x + y))\\]\n\nConexão com Prolog:\npar(X) :- 0 is X mod 2.\nimpar(X) :- 1 is X mod 2.\n\nmaior_que_impar(X) :- par(X), impar(Y), X &gt; Y.\nQuestão 8: Dedução Lógica com Instanciação\nResolução: 1. Premissas: * \\(P_1: \\forall x (Leao(x) \\to Mamifero(x))\\) * \\(P_2: \\exists x (Leao(x) \\wedge ViveNaSavana(x))\\)\n\nProva Formal:\n\nDa premissa \\(P_2\\), por Instanciação Existencial, podemos afirmar que existe uma constante \\(c\\) (vamos chamá-lo de Simba) para a qual a afirmação é verdadeira: \\(Leao(c) \\wedge ViveNaSavana(c)\\).\nDesta conjunção, podemos separar os dois fatos: \\(Leao(c)\\) e \\(ViveNaSavana(c)\\).\nDa premissa \\(P_1\\), por Instanciação Universal, podemos aplicar a regra a qualquer objeto, incluindo nossa constante \\(c\\): \\(Leao(c) \\to Mamifero(c)\\).\nAgora temos a implicação \\(Leao(c) \\to Mamifero(c)\\) e o fato \\(Leao(c)\\). Por Modus Ponens, podemos concluir \\(Mamifero(c)\\).\nNeste ponto, sabemos duas coisas sobre \\(c\\): \\(Mamifero(c)\\) e \\(ViveNaSavana(c)\\). Podemos juntá-las em uma conjunção: \\(Mamifero(c) \\wedge ViveNaSavana(c)\\).\nFinalmente, como encontramos um exemplo específico (\\(c\\)) que satisfaz a condição, podemos usar a Generalização Existencial para concluir: \\(\\exists x (Mamifero(x) \\wedge ViveNaSavana(x))\\). Q.E.D.\n\n\nConexão com Prolog:\nleao(simba).\nvive_na_savana(simba).\n\nmamifero(X) :- leao(X).\n\n% Consulta: ?- mamifero(X), vive_na_savana(X).\n% Resposta: X = simba\nQuestão 9: Consulta a uma Base de Dados Relacional \nResolução: A consulta pede os nomes (\\(n\\)) dos funcionários que trabalham no departamento de ‘Vendas’. A fórmula correta deve especificar que estamos procurando por nomes:\n\\[\\{n \\mid \\exists x \\exists d (Func(x,n,d) \\wedge Depto(d,'Vendas'))\\}\\]\nAlternativamente, como uma fórmula lógica que define a condição: \\[\\exists x \\exists d (Func(x,n,d) \\wedge Depto(d,'Vendas'))\\]\nonde \\(n\\) é uma variável livre que representa o nome que estamos buscando.\nConexão com Prolog:\nfunc(1, joao, vendas).\nfunc(2, maria, ti).\ndepto(vendas, 'Vendas').\ndepto(ti, 'TI').\n\nfuncionario_vendas(Nome) :- \n    func(_, Nome, Depto), \n    depto(Depto, 'Vendas').\n\n% Consulta: ?- funcionario_vendas(X).\n% Resposta: X = joao\nEm SQL seria:\nSELECT F.Nome FROM Funcionario F \n  JOIN Departamento D ON F.DeptoID = D.ID \n  WHERE D.NomeDepto = 'Vendas'.\nQuestão 10: Hierarquia Organizacional\nResoluções:\n\nTodo funcionário tem exatamente um gerente: Isso se divide em duas partes: “pelo menos um” e “no máximo um”:\n\n\\(\\forall x (Funcionario(x) \\to \\exists y Gerente(y,x))\\);\n\\(\\forall x \\forall y \\forall z ((Gerente(y,x) \\wedge Gerente(z,x)) \\to y = z)\\).\n\nNenhum funcionário pode ser gerente de si mesmo:\n\n\\(\\forall x \\neg Gerente(x,x)\\)\n\nTodo gerente é também um funcionário: **\n\n\\(\\forall x (\\exists y Gerente(x,y) \\to Funcionario(x))\\)\n\nExiste um funcionário que não é gerente de ninguém:\n\n\\(\\exists x (Funcionario(x) \\wedge \\neg \\exists y Gerente(x,y))\\)\n\n\nConexão com Prolog:\nfuncionario(joao).\nfuncionario(maria).\nfuncionario(pedro).\n\ngerente(maria, joao).\ngerente(pedro, maria).\n\n% Regra: todo gerente é funcionário\nfuncionario(X) :- gerente(X, _).\n\n% Consulta: funcionário que não é gerente de ninguém\nnao_gerente(X) :- funcionario(X), \\+ gerente(X, _).\n\n% Consulta: ?- nao_gerente(X).\n% Resposta: X = joao\nQuestão 11 - Sistema Bancário\n1. Predicados definidos:\n\n\\(Cliente(x)\\): x é um cliente\n\\(Conta(y)\\): y é uma conta bancária\n\\(Possui(x, y)\\): cliente x possui conta y\n\\(SaldoPositivo(y)\\): conta y tem saldo positivo\n\\(SaldoNegativo(y)\\): conta y tem saldo negativo\n\\(VIP(x)\\): cliente x é VIP\n\\(Transacao(z)\\): z é uma transação\n\\(RealizouTransacao(x, z)\\): cliente x realizou transação z\n\n2. Regras formalizadas: - Todo cliente possui pelo menos uma conta:\n\\[∀x (Cliente(x) → ∃y (Conta(y) ∧ Possui(x, y)))\\]\n\nToda conta pertence a exatamente um cliente:\n\\[∀y (Conta(y) → ∃x (Cliente(x) ∧ Possui(x, y) ∧ ∀z ((Cliente(z) ∧ Possui(z, y)) → z = x)))\\]\nContas podem ter saldo positivo ou negativo:\n\\[∀y (Conta(y) → (SaldoPositivo(y) ∨ SaldoNegativo(y)))\\]\nExistem clientes VIP que têm mais de uma conta:\n\\[∃x (Cliente(x) ∧ VIP(x) ∧ ∃y ∃z (Conta(y) ∧ Conta(z) ∧ y ≠ z ∧ Possui(x, y) ∧ Possui(x, z)))\\]\nNem todas as contas têm saldo positivo:\n\\[¬∀y (Conta(y) → SaldoPositivo(y))\\]\n\n3. Consultas úteis: - Encontrar todos os clientes VIP:\n\\[∃x (Cliente(x) ∧ VIP(x))\\]\n\nVerificar se existe alguma conta com saldo negativo:\n\\[∃y (Conta(y) ∧ SaldoNegativo(y))\\]\nEncontrar clientes com múltiplas contas: \\[∃x ∃y ∃z (Cliente(x) ∧ Conta(y) ∧ Conta(z) ∧ y ≠ z ∧ Possui(x, y) ∧ Possui(x, z))\\]\n\nEm Prolog\n% ====================================================================\n% EXERCÍCIO 1 - SISTEMA BANCÁRIO\n% ====================================================================\n\n% Fatos base (dados de exemplo)\ncliente(joao).\ncliente(maria).\ncliente(pedro).\ncliente(ana).\n\nconta(conta1).\nconta(conta2).\nconta(conta3).\nconta(conta4).\nconta(conta5).\n\n% Relação de posse de contas\npossui(joao, conta1).\npossui(maria, conta2).\npossui(maria, conta3).  % Maria tem duas contas (VIP)\npossui(pedro, conta4).\npossui(ana, conta5).\n\n% Status de saldo das contas\nsaldo_positivo(conta1).\nsaldo_positivo(conta2).\nsaldo_positivo(conta4).\n\nsaldo_negativo(conta3).\nsaldo_negativo(conta5).\n\n% Clientes VIP\nvip(maria).\n\n% Transações\ntransacao(trans1).\ntransacao(trans2).\nrealizou_transacao(joao, trans1).\nrealizou_transacao(maria, trans2).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo cliente possui pelo menos uma conta\ncliente_tem_conta(X) :- \n    cliente(X), \n    conta(Y), \n    possui(X, Y).\n\n% Regra 2: Toda conta pertence a exatamente um cliente\nconta_tem_dono_unico(Y) :- \n    conta(Y),\n    possui(X, Y),\n    \\+ (possui(Z, Y), X \\= Z).\n\n% Regra 3: Contas podem ter saldo positivo ou negativo\nconta_tem_saldo(Y) :- \n    conta(Y),\n    (saldo_positivo(Y) ; saldo_negativo(Y)).\n\n% Regra 4: Existem clientes VIP que têm mais de uma conta\ncliente_vip_multiplas_contas(X) :- \n    cliente(X),\n    vip(X),\n    possui(X, Y1),\n    possui(X, Y2),\n    Y1 \\= Y2.\n\n% Regra 5: Nem todas as contas têm saldo positivo (verificação)\nexiste_conta_saldo_negativo :- \n    conta(Y),\n    saldo_negativo(Y).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar todos os clientes VIP\n% ?- vip(X).\n\n% Consulta 2: Verificar se existe alguma conta com saldo negativo\n% ?- existe_conta_saldo_negativo.\n\n% Consulta 3: Encontrar clientes com múltiplas contas\ncliente_multiplas_contas(X) :- \n    cliente(X),\n    possui(X, Y1),\n    possui(X, Y2),\n    Y1 \\= Y2.\n% ?- cliente_multiplas_contas(X).\nQuestão 12 - Sistema de Saúde\n1. Predicados definidos:\n\n\\(Medico(x)\\): x é um médico\n\\(Paciente(y)\\): y é um paciente\n\\(Tratamento(z)\\): z é um tratamento\n\\(Especialidade(w)\\): w é uma especialidade\n\\(Atende(x, y)\\): médico x atende paciente y\n\\(TemEspecialidade(x, w)\\): médico x tem especialidade w\n\\(RequerEspecialista(z)\\): tratamento z requer especialista\n\\(Internado(y)\\): paciente y está internado\n\\(Ambulatorial(y)\\): paciente y é ambulatorial\n\\(Prescreveu(x, z)\\): médico x prescreveu tratamento z\n\n2. Regras formalizadas: - Todo paciente é atendido por pelo menos um médico:\n\\[∀y (Paciente(y) → ∃x (Medico(x) ∧ Atende(x, y)))\\]\n\nTodo médico tem uma especialidade:\n\\[∀x (Medico(x) → ∃w (Especialidade(w) ∧ TemEspecialidade(x, w)))\\]\nAlguns tratamentos requerem médicos especialistas:\n\\[∃z (Tratamento(z) ∧ RequerEspecialista(z))\\]\nExistem pacientes internados e ambulatoriais:\n\\[∃y (Paciente(y) ∧ Internado(y)) ∧ ∃y (Paciente(y) ∧ Ambulatorial(y))\\]\nTodo tratamento é prescrito por algum médico:\n\\[∀z (Tratamento(z) → ∃x (Medico(x) ∧ Prescreveu(x, z)))\\]\n\n3. Consultas úteis: - Encontrar médicos que atendem pacientes internados:\n\\[∃x ∃y (Medico(x) ∧ Paciente(y) ∧ Internado(y) ∧ Atende(x, y))\\]\n\nVerificar se há tratamentos sem médico responsável:\n\\[∃z (Tratamento(z) ∧ ¬∃x (Medico(x) ∧ Prescreveu(x, z)))\\]\nListar pacientes atendidos por múltiplos médicos:\n\\[∃y ∃x₁ ∃x₂ (Paciente(y) ∧ Medico(x₁) ∧ Medico(x₂) ∧ x₁ ≠ x₂ ∧ Atende(x₁, y) ∧ Atende(x₂, y))\\]\n\nEm Prolog\n% ====================================================================\n% EXERCÍCIO 2 - SISTEMA DE SAÚDE\n% ====================================================================\n\n% Fatos base\nmedico(dr_silva).\nmedico(dra_santos).\nmedico(dr_costa).\n\npaciente(carlos).\npaciente(lucia).\npaciente(roberto).\npaciente(amanda).\n\ntratamento(trat1).\ntratamento(trat2).\ntratamento(trat3).\n\nespecialidade(cardiologia).\nespecialidade(neurologia).\nespecialidade(pediatria).\n\n% Relações\natende(dr_silva, carlos).\natende(dr_silva, lucia).\natende(dra_santos, roberto).\natende(dr_costa, amanda).\n\ntem_especialidade(dr_silva, cardiologia).\ntem_especialidade(dra_santos, neurologia).\ntem_especialidade(dr_costa, pediatria).\n\nrequer_especialista(trat2).\n\ninternado(carlos).\nambulatorial(lucia).\nambulatorial(roberto).\ninternado(amanda).\n\nprescreveu(dr_silva, trat1).\nprescreveu(dra_santos, trat2).\nprescreveu(dr_costa, trat3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo paciente é atendido por pelo menos um médico\npaciente_tem_medico(Y) :- \n    paciente(Y),\n    medico(X),\n    atende(X, Y).\n\n% Regra 2: Todo médico tem uma especialidade\nmedico_tem_especialidade(X) :- \n    medico(X),\n    especialidade(W),\n    tem_especialidade(X, W).\n\n% Regra 3: Alguns tratamentos requerem médicos especialistas\ntratamento_especialista(Z) :- \n    tratamento(Z),\n    requer_especialista(Z).\n\n% Regra 4: Existem pacientes internados e ambulatoriais\nexiste_internado :- paciente(Y), internado(Y).\nexiste_ambulatorial :- paciente(Y), ambulatorial(Y).\n\n% Regra 5: Todo tratamento é prescrito por algum médico\ntratamento_tem_medico(Z) :- \n    tratamento(Z),\n    medico(X),\n    prescreveu(X, Z).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar médicos que atendem pacientes internados\nmedico_atende_internado(X) :- \n    medico(X),\n    paciente(Y),\n    internado(Y),\n    atende(X, Y).\n% ?- medico_atende_internado(X).\n\n% Consulta 2: Verificar se há tratamentos sem médico responsável\ntratamento_sem_medico(Z) :- \n    tratamento(Z),\n    \\+ prescreveu(_, Z).\n% ?- tratamento_sem_medico(Z).\n\n% Consulta 3: Listar pacientes atendidos por múltiplos médicos\npaciente_multiplos_medicos(Y) :- \n    paciente(Y),\n    atende(X1, Y),\n    atende(X2, Y),\n    X1 \\= X2.\n% ?- paciente_multiplos_medicos(Y).\nQuestão 13 - Rede Social\n1. Predicados definidos:\n\n\\(Usuario(x)\\): x é um usuário\n\\(Postagem(y)\\): y é uma postagem\n\\(Curtida(z)\\): z é uma curtida\n\\(Amigo(x, y)\\): usuário x é amigo de usuário y\n\\(Publicou(x, y)\\): usuário x publicou postagem y\n\\(Curtiu(x, y)\\): usuário x curtiu postagem y\n\\(Influenciador(x)\\): usuário x é influenciador\n\\(Segue(x, y)\\): usuário x segue usuário y\n\n2. Regras formalizadas: - Amizade é uma relação simétrica:\n\\[∀x ∀y (Amigo(x, y) → Amigo(y, x))\\]\n\nTodo usuário pode publicar postagens:\n\\[∀x (Usuario(x) → ∃y (Postagem(y) ∧ Publicou(x, y)))\\]\nUsuários podem curtir postagens de amigos:\n\\[\n∀x ∀y ∀z ((Usuario(x) ∧ Usuario(y) ∧ Postagem(z) ∧ Amigo(x, y) ∧ Publicou(y, z)) → Curtiu(x, z))\n\\]\nExistem usuários influenciadores:\n\\[\n∃x (Usuario(x) ∧ Influenciador(x) ∧ ∀y ((Usuario(y) ∧ y ≠ x) → Segue(y, x)))\n\\]\nNem toda postagem recebe curtidas:\n\\[\n¬∀y (Postagem(y) → ∃x (Usuario(x) ∧ Curtiu(x, y)))\n\\]\n\n3. Consultas úteis: - Encontrar postagens mais populares (com curtidas):\n\\[\n  ∃y ∃x₁ ∃x₂ (Postagem(y) ∧ Usuario(x₁) ∧ Usuario(x₂) ∧ x₁ ≠ x₂ ∧ Curtiu(x₁, y) ∧ Curtiu(x₂, y))\n  \\]\n\nVerificar usuários sem amigos:\n\\[\n∃x (Usuario(x) ∧ ¬∃y (Usuario(y) ∧ Amigo(x, y)))\n\\]\nListar influenciadores:\n\\[\n∃x (Usuario(x) ∧ Influenciador(x))\n\\]\n\nEm Prolog\n% ====================================================================\n% EXERCÍCIO 3 - REDE SOCIAL\n% ====================================================================\n\n% Fatos base\nusuario(alice).\nusuario(bob).\nusuario(carol).\nusuario(david).\nusuario(eva).\n\npostagem(post1).\npostagem(post2).\npostagem(post3).\npostagem(post4).\n\n% Amizades (relação simétrica)\namigo(alice, bob).\namigo(bob, alice).\namigo(bob, carol).\namigo(carol, bob).\namigo(carol, david).\namigo(david, carol).\n\npublicou(alice, post1).\npublicou(bob, post2).\npublicou(carol, post3).\npublicou(eva, post4).\n\ncurtiu(bob, post1).\ncurtiu(alice, post2).\ncurtiu(carol, post2).\ncurtiu(david, post3).\n% post4 não tem curtidas\n\ninfluenciador(eva).\n\nsegue(alice, eva).\nsegue(bob, eva).\nsegue(carol, eva).\nsegue(david, eva).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Amizade é uma relação simétrica (já implementada nos fatos)\namizade_simetrica(X, Y) :- \n    amigo(X, Y),\n    amigo(Y, X).\n\n% Regra 2: Todo usuário pode publicar postagens\nusuario_pode_publicar(X) :- \n    usuario(X),\n    postagem(Y),\n    publicou(X, Y).\n\n% Regra 3: Usuários podem curtir postagens de amigos\npode_curtir_de_amigo(X, Z) :- \n    usuario(X),\n    usuario(Y),\n    postagem(Z),\n    amigo(X, Y),\n    publicou(Y, Z).\n\n% Regra 4: Existem usuários influenciadores\nusuario_influenciador(X) :- \n    usuario(X),\n    influenciador(X),\n    findall(Y, (usuario(Y), Y \\= X, segue(Y, X)), Seguidores),\n    length(Seguidores, N),\n    N &gt; 3.  % Tem mais de 3 seguidores\n\n% Regra 5: Nem toda postagem recebe curtidas\npostagem_sem_curtida(Y) :- \n    postagem(Y),\n    \\+ curtiu(_, Y).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar postagens populares (com múltiplas curtidas)\npostagem_popular(Y) :- \n    postagem(Y),\n    curtiu(X1, Y),\n    curtiu(X2, Y),\n    X1 \\= X2.\n% ?- postagem_popular(Y).\n\n% Consulta 2: Verificar usuários sem amigos\nusuario_sem_amigos(X) :- \n    usuario(X),\n    \\+ amigo(X, _).\n% ?- usuario_sem_amigos(X).\n\n% Consulta 3: Listar influenciadores\n% ?- influenciador(X).\nQuestão 14 - Sistema de Biblioteca\n1. Predicados definidos:\n\n\\(Livro(x)\\): x é um livro\n\\(Usuario(y)\\): y é um usuário\n\\(Emprestado(x, y)\\): livro x está emprestado para usuário y\n\\(Disponivel(x)\\): livro x está disponível\n\\(Reservado(x, y)\\): livro x está reservado por usuário y\n\\(DataDevolucao(x, d)\\): empréstimo do livro x tem data de devolução d\n\\(JaFoiEmprestado(x)\\): livro x já foi emprestado alguma vez\n\n2. Regras formalizadas: - Um usuário pode pegar vários livros:\n\\[∃y ∃x₁ ∃x₂ (Usuario(y) ∧ Livro(x₁) ∧ Livro(x₂) ∧ x₁ ≠ x₂ ∧ Emprestado(x₁, y) ∧ Emprestado(x₂, y))\\]\n\nUm livro só pode estar com um usuário por vez:\n\\[∀x ∀y₁ ∀y₂ ((Livro(x) ∧ Emprestado(x, y₁) ∧ Emprestado(x, y₂)) → y₁ = y₂)\\]\nNem todos os livros estão emprestados:\n\\[¬∀x (Livro(x) → ∃y Emprestado(x, y))\\]\nExistem livros que nunca foram emprestados: \\[∃x (Livro(x) ∧ ¬JaFoiEmprestado(x))\\]\nTodo empréstimo tem data de devolução: \\[∀x ∀y (Emprestado(x, y) → ∃d DataDevolucao(x, d))\\]\n\n3. Consultas úteis: - Encontrar livros disponíveis: \\[∃x (Livro(x) ∧ Disponivel(x))\\]\n\nVerificar usuários com empréstimos ativos: \\[∃y ∃x (Usuario(y) ∧ Livro(x) ∧ Emprestado(x, y))\\]\nListar livros nunca emprestados: \\[∃x (Livro(x) ∧ ¬JaFoiEmprestado(x))\\]\n\nEm Prolog\n% ====================================================================\n% EXERCÍCIO 4 - SISTEMA DE BIBLIOTECA\n% ====================================================================\n\n% Fatos base\nlivro(livro1).\nlivro(livro2).\nlivro(livro3).\nlivro(livro4).\nlivro(livro5).\n\nusuario_bib(user1).\nusuario_bib(user2).\nusuario_bib(user3).\n\nemprestado(livro1, user1).\nemprestado(livro2, user1).  % user1 tem 2 livros\nemprestado(livro3, user2).\n\ndisponivel(livro4).\ndisponivel(livro5).\n\ndata_devolucao(livro1, '2025-02-15').\ndata_devolucao(livro2, '2025-02-20').\ndata_devolucao(livro3, '2025-02-18').\n\nja_foi_emprestado(livro1).\nja_foi_emprestado(livro2).\nja_foi_emprestado(livro3).\n% livro4 e livro5 nunca foram emprestados\n\nreservado(livro4, user3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Um usuário pode pegar vários livros\nusuario_multiplos_livros(Y) :- \n    usuario_bib(Y),\n    emprestado(X1, Y),\n    emprestado(X2, Y),\n    X1 \\= X2.\n\n% Regra 2: Um livro só pode estar com um usuário por vez\nlivro_usuario_unico(X) :- \n    livro(X),\n    emprestado(X, Y),\n    \\+ (emprestado(X, Z), Y \\= Z).\n\n% Regra 3: Nem todos os livros estão emprestados\nexiste_livro_disponivel :- \n    livro(X),\n    \\+ emprestado(X, _).\n\n% Regra 4: Existem livros que nunca foram emprestados\nlivro_nunca_emprestado(X) :- \n    livro(X),\n    \\+ ja_foi_emprestado(X).\n\n% Regra 5: Todo empréstimo tem data de devolução\nemprestimo_tem_data(X, Y) :- \n    emprestado(X, Y),\n    data_devolucao(X, _).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar livros disponíveis\n% ?- disponivel(X).\n\n% Consulta 2: Verificar usuários com empréstimos ativos\nusuario_com_emprestimo(Y) :- \n    usuario_bib(Y),\n    emprestado(_, Y).\n% ?- usuario_com_emprestimo(Y).\n\n% Consulta 3: Listar livros nunca emprestados\n% ?- livro_nunca_emprestado(X).\nQuestão 15 - Sistema de E-commerce\n1. Predicados definidos:\n\n\\(Produto(x)\\): x é um produto\n\\(Cliente(y)\\): y é um cliente\n\\(Pedido(z)\\): z é um pedido\n\\(Categoria(c)\\): c é uma categoria\n\\(PertenceCategoria(x, c)\\): produto x pertence à categoria c\n\\(FezPedido(y, z)\\): cliente y fez pedido z\n\\(ContemProduto(z, x)\\): pedido z contém produto x\n\\(TemAvaliacao(x)\\): produto x tem avaliação\n\\(EmPromocao(x)\\): produto x está em promoção\n\\(Avaliou(y, x, nota)\\): cliente y avaliou produto x com nota\n\n2. Regras formalizadas: - Todo produto pertence a pelo menos uma categoria:\n\\[∀x (Produto(x) → ∃c (Categoria(c) ∧ PertenceCategoria(x, c)))\\]\n\nTodo pedido é feito por exatamente um cliente:\n\\[∀z (Pedido(z) → ∃y (Cliente(y) ∧ FezPedido(y, z) ∧ ∀w ((Cliente(w) ∧ FezPedido(w, z)) → w = y)))\\]\nNem todo produto tem avaliações:\n\\[¬∀x (Produto(x) → TemAvaliacao(x))\\]\nExistem produtos em promoção:\n\\[∃x (Produto(x) ∧ EmPromocao(x))\\]\nClientes podem fazer múltiplos pedidos: \\[∃y ∃z₁ ∃z₂ (Cliente(y) ∧ Pedido(z₁) ∧ Pedido(z₂) ∧ z₁ ≠ z₂ ∧ FezPedido(y, z₁) ∧ FezPedido(y, z₂))\\]\n\n3. Consultas úteis: - Encontrar produtos populares (com muitas avaliações):\n\\[∃x ∃y₁ ∃y₂ (Produto(x) ∧ Cliente(y₁) ∧ Cliente(y₂) ∧ y₁ ≠ y₂ ∧ ∃n₁ ∃n₂ (Avaliou(y₁, x, n₁) ∧ Avaliou(y₂, x, n₂)))\\]\n\nListar produtos em promoção sem avaliações:\n∃x (Produto(x) ∧ EmPromocao(x) ∧ ¬TemAvaliacao(x))\nVerificar clientes frequentes:\n\\[∃y ∃z₁ ∃z₂ ∃z₃ (Cliente(y) ∧ Pedido(z₁) ∧ Pedido(z₂) ∧ Pedido(z₃) ∧ z₁ ≠ z₂ ∧ z₂ ≠ z₃ ∧ z₁ ≠ z₃ ∧ FezPedido(y, z₁) ∧ FezPedido(y, z₂) ∧ FezPedido(y, z₃))\\]\n\nEm Prolog\n% ====================================================================\n% EXERCÍCIO 5 - SISTEMA DE E-COMMERCE\n% ====================================================================\n\n% Fatos base\nproduto(prod1).\nproduto(prod2).\nproduto(prod3).\nproduto(prod4).\n\ncliente_ec(cliente1).\ncliente_ec(cliente2).\ncliente_ec(cliente3).\n\npedido(pedido1).\npedido(pedido2).\npedido(pedido3).\npedido(pedido4).\n\ncategoria(eletronicos).\ncategoria(livros).\ncategoria(roupas).\n\npertence_categoria(prod1, eletronicos).\npertence_categoria(prod2, livros).\npertence_categoria(prod3, roupas).\npertence_categoria(prod4, eletronicos).\npertence_categoria(prod4, roupas).  % prod4 em duas categorias\n\nfez_pedido(cliente1, pedido1).\nfez_pedido(cliente1, pedido2).  % cliente1 fez múltiplos pedidos\nfez_pedido(cliente2, pedido3).\nfez_pedido(cliente3, pedido4).\n\ncontem_produto(pedido1, prod1).\ncontem_produto(pedido2, prod2).\ncontem_produto(pedido3, prod3).\ncontem_produto(pedido4, prod4).\n\ntem_avaliacao(prod1).\ntem_avaliacao(prod2).\n% prod3 e prod4 não têm avaliação\n\nem_promocao(prod3).\nem_promocao(prod4).\n\navaliou(cliente1, prod1, 5).\navaliou(cliente2, prod1, 4).\navaliou(cliente1, prod2, 3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo produto pertence a pelo menos uma categoria\nproduto_tem_categoria(X) :- \n    produto(X),\n    categoria(C),\n    pertence_categoria(X, C).\n\n% Regra 2: Todo pedido é feito por exatamente um cliente\npedido_cliente_unico(Z) :- \n    pedido(Z),\n    fez_pedido(Y, Z),\n    \\+ (fez_pedido(W, Z), Y \\= W).\n\n% Regra 3: Nem todo produto tem avaliações\nproduto_sem_avaliacao(X) :- \n    produto(X),\n    \\+ tem_avaliacao(X).\n\n% Regra 4: Existem produtos em promoção\nexiste_promocao :- \n    produto(X),\n    em_promocao(X).\n\n% Regra 5: Clientes podem fazer múltiplos pedidos\ncliente_multiplos_pedidos(Y) :- \n    cliente_ec(Y),\n    fez_pedido(Y, Z1),\n    fez_pedido(Y, Z2),\n    Z1 \\= Z2.\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar produtos populares (com múltiplas avaliações)\nproduto_popular(X) :- \n    produto(X),\n    avaliou(Y1, X, _),\n    avaliou(Y2, X, _),\n    Y1 \\= Y2.\n% ?- produto_popular(X).\n\n% Consulta 2: Listar produtos em promoção sem avaliações\npromocao_sem_avaliacao(X) :- \n    produto(X),\n    em_promocao(X),\n    \\+ tem_avaliacao(X).\n% ?- promocao_sem_avaliacao(X).\n\n% Consulta 3: Verificar clientes frequentes (3+ pedidos)\ncliente_frequente(Y) :- \n    cliente_ec(Y),\n    findall(Z, fez_pedido(Y, Z), Pedidos),\n    length(Pedidos, N),\n    N &gt;= 2.  % Ajustado para o exemplo\n% ?- cliente_frequente(Y).\nQuestão 16 - Sistema de Transporte\n1. Predicados definidos:\n\n\\(Motorista(x)\\): x é um motorista\n\\(Passageiro(y)\\): y é um passageiro\n\\(Viagem(v)\\): v é uma viagem\n\\(Veiculo(c)\\): c é um veículo\n\\(Possui(x, c)\\): motorista x possui veículo c\n\\(RealizouViagem(x, y, v)\\): motorista x realizou viagem v com passageiro y\n\\(RecebeuAvaliacao(v, nota)\\): viagem v recebeu avaliação com nota\n\\(Premium(x)\\): motorista x é premium\n\\(AvaliacaoAlta(x)\\): motorista x tem avaliação alta\n\n2. Regras formalizadas:\n\nTodo motorista possui exatamente um veículo:\n$$∀x (Motorista(x) → ∃c (Veiculo(c) ∧ Possui(x, c) ∧ ∀d ((Veiculo(d) ∧ Possui(x, d)) → d = c)))`\nToda viagem conecta um passageiro a um motorista:\n\\[∀v (Viagem(v) → ∃x ∃y (Motorista(x) ∧ Passageiro(y) ∧ RealizouViagem(x, y, v)))\\]\nNem toda viagem recebe avaliação:\n\\[¬∀v (Viagem(v) → ∃nota RecebeuAvaliacao(v, nota))\\]\nExistem motoristas premium (alta avaliação):\n\\[∃x (Motorista(x) ∧ Premium(x) ∧ AvaliacaoAlta(x))\\]\nPassageiros podem avaliar motoristas:\n\\[∀y ∀x ∀v ((Passageiro(y) ∧ Motorista(x) ∧ Viagem(v) ∧ RealizouViagem(x, y, v)) → ∃nota RecebeuAvaliacao(v, nota))\\]\n\n3. Consultas úteis:\n\nEncontrar motoristas premium:\n\\[∃x (Motorista(x) ∧ Premium(x))\\]\nVerificar viagens sem avaliação:\n\\[∃v (Viagem(v) ∧ ¬∃nota RecebeuAvaliacao(v, nota))\\]\nListar passageiros frequentes:\n\\[∃y ∃v₁ ∃v₂ (Passageiro(y) ∧ Viagem(v₁) ∧ Viagem(v₂) ∧ v₁ ≠ v₂ ∧ ∃x₁ ∃x₂ (RealizouViagem(x₁, y, v₁) ∧ RealizouViagem(x₂, y, v₂)))\\]\n\n% ====================================================================\n% EXERCÍCIO 6 - SISTEMA DE TRANSPORTE\n% ====================================================================\n\n% Fatos base\nmotorista(mot1).\nmotorista(mot2).\nmotorista(mot3).\n\npassageiro(pass1).\npassageiro(pass2).\npassageiro(pass3).\n\nviagem(viagem1).\nviagem(viagem2).\nviagem(viagem3).\nviagem(viagem4).\n\nveiculo(carro1).\nveiculo(carro2).\nveiculo(carro3).\n\npossui_veiculo(mot1, carro1).\npossui_veiculo(mot2, carro2).\npossui_veiculo(mot3, carro3).\n\nrealizou_viagem(mot1, pass1, viagem1).\nrealizou_viagem(mot1, pass2, viagem2).\nrealizou_viagem(mot2, pass3, viagem3).\nrealizou_viagem(mot3, pass1, viagem4).\n\nrecebeu_avaliacao(viagem1, 5).\nrecebeu_avaliacao(viagem2, 4).\nrecebeu_avaliacao(viagem4, 5).\n% viagem3 não recebeu avaliação\n\npremium(mot1).\npremium(mot3).\n\navaliacao_alta(mot1).\navaliacao_alta(mot3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo motorista possui exatamente um veículo\nmotorista_veiculo_unico(X) :- \n    motorista(X),\n    possui_veiculo(X, C),\n    \\+ (possui_veiculo(X, D), C \\= D).\n\n% Regra 2: Toda viagem conecta um passageiro a um motorista\nviagem_conecta(T) :- \n    viagem(T),\n    motorista(X),\n    passageiro(Y),\n    realizou_viagem(X, Y, T).\n\n% Regra 3: Nem toda viagem recebe avaliação\nviagem_sem_avaliacao(T) :- \n    viagem(T),\n    \\+ recebeu_avaliacao(T, _).\n\n% Regra 4: Existem motoristas premium (alta avaliação)\nmotorista_premium(X) :- \n    motorista(X),\n    premium(X),\n    avaliacao_alta(X).\n\n% Regra 5: Passageiros podem avaliar motoristas (através das viagens)\npassageiro_pode_avaliar(Y, X) :- \n    passageiro(Y),\n    motorista(X),\n    viagem(T),\n    realizou_viagem(X, Y, T),\n    recebeu_avaliacao(T, _).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar motoristas premium\n% ?- premium(X).\n\n% Consulta 2: Verificar viagens sem avaliação\n% ?- viagem_sem_avaliacao(T).\n\n% Consulta 3: Listar passageiros frequentes\npassageiro_frequente(Y) :- \n    passageiro(Y),\n    realizou_viagem(_, Y, V1),\n    realizou_viagem(_, Y, V2),\n    V1 \\= V2.\n% ?- passageiro_frequente(Y).\nQuestão 17 - Sistema Universitário\n1. Predicados definidos:\n\n\\(Estudante(x)\\): x é um estudante\n\\(Professor(y)\\): y é um professor\n\\(Disciplina(d)\\): d é uma disciplina\n\\(Curso(c)\\): c é um curso\n\\(Matriculado(x, c)\\): estudante x está matriculado no curso c\n\\(Ministra(y, d)\\): professor y ministra disciplina d\n\\(TemNota(x, d, n)\\): estudante x tem nota n na disciplina d\n\\(Obrigatoria(d)\\): disciplina d é obrigatória\n\\(Optativa(d)\\): disciplina d é optativa\n\\(AreaProfessor(y, a)\\): professor y é da área a\n\\(AreaDisciplina(d, a)\\): disciplina d é da área a\n\n2. Regras formalizadas: - Todo estudante está matriculado em um curso:\n\\[∀x (Estudante(x) → ∃c (Curso(c) ∧ Matriculado(x, c)))\\]\n\nToda disciplina é ministrada por pelo menos um professor:\n\\[∀d (Disciplina(d) → ∃y (Professor(y) ∧ Ministra(y, d)))\\]\nNem todo estudante tem nota em todas as disciplinas:\n\\[¬∀x ∀d ((Estudante(x) ∧ Disciplina(d)) → ∃n TemNota(x, d, n))\\]\nExistem disciplinas obrigatórias e optativas:\n\\[∃d (Disciplina(d) ∧ Obrigatoria(d)) ∧ ∃d (Disciplina(d) ∧ Optativa(d))\\]\nTodo professor ensina disciplinas da sua área:\n\\[∀y ∀d ∀a ((Professor(y) ∧ Disciplina(d) ∧ AreaProfessor(y, a) ∧ Ministra(y, d)) → AreaDisciplina(d, a))\\]\n\n3. Consultas úteis: - Encontrar estudantes com notas em todas as disciplinas obrigatórias:\n\\[∃x (Estudante(x) ∧ ∀d ((Disciplina(d) ∧ Obrigatoria(d)) → ∃n TemNota(x, d, n)))\\]\n\nVerificar disciplinas sem professor:\n\\[∃d (Disciplina(d) ∧ ¬∃y (Professor(y) ∧ Ministra(y, d)))\\]\nListar professores que ministram múltiplas disciplinas:\n\\[∃y ∃d₁ ∃d₂ (Professor(y) ∧ Disciplina(d₁) ∧ Disciplina(d₂) ∧ d₁ ≠ d₂ ∧ Ministra(y, d₁) ∧ Ministra(y, d₂))\\]\n\nEm Prolog\n% ====================================================================\n% EXERCÍCIO 7 - SISTEMA UNIVERSITÁRIO\n% ====================================================================\n\n% Fatos base\nestudante(est1).\nestudante(est2).\nestudante(est3).\n\nprofessor(prof1).\nprofessor(prof2).\n\ndisciplina(disc1).\ndisciplina(disc2).\ndisciplina(disc3).\ndisciplina(disc4).\n\ncurso(computacao).\ncurso(matematica).\n\nmatriculado(est1, computacao).\nmatriculado(est2, computacao).\nmatriculado(est3, matematica).\n\nministra(prof1, disc1).\nministra(prof1, disc2).\nministra(prof2, disc3).\nministra(prof2, disc4).\n\ntem_nota(est1, disc1, 8).\ntem_nota(est1, disc2, 9).\ntem_nota(est2, disc1, 7).\ntem_nota(est3, disc3, 10).\n% nem todos têm nota em todas as disciplinas\n\nobrigatoria(disc1).\nobrigatoria(disc2).\noptativa(disc3).\noptativa(disc4).\n\narea_professor(prof1, exatas).\narea_professor(prof2, exatas).\n\narea_disciplina(disc1, exatas).\narea_disciplina(disc2, exatas).\narea_disciplina(disc3, exatas).\narea_disciplina(disc4, exatas).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo estudante está matriculado em um curso\nestudante_tem_curso(X) :- \n    estudante(X),\n    curso(C),\n    matriculado(X, C).\n\n% Regra 2: Toda disciplina é ministrada por pelo menos um professor\ndisciplina_tem_professor(D) :- \n    disciplina(D),\n    professor(Y),\n    ministra(Y, D).\n\n% Regra 3: Nem todo estudante tem nota em todas as disciplinas\nestudante_sem_nota_completa(X) :- \n    estudante(X),\n    disciplina(D),\n    \\+ tem_nota(X, D, _).\n\n% Regra 4: Existem disciplinas obrigatórias e optativas\nexiste_obrigatoria :- disciplina(D), obrigatoria(D).\nexiste_optativa :- disciplina(D), optativa(D).\n\n% Regra 5: Todo professor ensina disciplinas da sua área\nprofessor_ensina_sua_area(Y) :- \n    professor(Y),\n    area_professor(Y, A),\n    ministra(Y, D),\n    area_disciplina(D, A).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar estudantes com notas em todas as disciplinas obrigatórias\nestudante_completo_obrigatorias(X) :- \n    estudante(X),\n    \\+ (disciplina(D), obrigatoria(D), \\+ tem_nota(X, D, _)).\n% ?- estudante_completo_obrigatorias(X).\n\n% Consulta 2: Verificar disciplinas sem professor\ndisciplina_sem_professor(D) :- \n    disciplina(D),\n    \\+ ministra(_, D).\n% ?- disciplina_sem_professor(D).\n\n% Consulta 3: Listar professores que ministram múltiplas disciplinas\nprofessor_multiplas_disciplinas(Y) :- \n    professor(Y),\n    ministra(Y, D1),\n    ministra(Y, D2),\n    D1 \\= D2.\n% ?- professor_multiplas_disciplinas(Y).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  },
  {
    "objectID": "Solucao-Exercicios.html#formas-normais-sec-formas-normais",
    "href": "Solucao-Exercicios.html#formas-normais-sec-formas-normais",
    "title": "14  Solução dos Exercícios",
    "section": "14.3 Formas Normais Chapter 7",
    "text": "14.3 Formas Normais Chapter 7\n\n14.3.1 Exercícios Conversão Forma Normal Disjuntiva Section 7.1.2.6\n\n14.3.1.1 Solução do Exercício 1\nConverter \\(((P \\leftrightarrow Q) \\rightarrow R) \\wedge \\neg(R \\rightarrow (P \\vee Q))\\) para Forma Normal Disjuntiva.\nPasso 1: Eliminar a bicondicional\n\\[\n((P \\leftrightarrow Q) \\rightarrow R) \\equiv (((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) \\rightarrow R)\n\\]\nPasso 2: Eliminar as implicações internas\n\\[\n(((\\neg P \\vee Q) \\wedge (\\neg Q \\vee P)) \\rightarrow R)\n\\]\nPasso 3: Eliminar a implicação principal do primeiro termo\n\\[\n(\\neg((\\neg P \\vee Q) \\wedge (\\neg Q \\vee P)) \\vee R)\n\\]\nPasso 4: Aplicar De Morgan no primeiro termo\n\\[\n((\\neg(\\neg P \\vee Q) \\vee \\neg(\\neg Q \\vee P)) \\vee R)\n\\]\n\\[\n(((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee R)\n\\]\nPasso 5: Trabalhar o segundo termo da conjunção original\n\\[\n\\neg(R \\rightarrow (P \\vee Q)) \\equiv \\neg(\\neg R \\vee (P \\vee Q)) \\equiv R \\wedge \\neg(P \\vee Q) \\equiv R \\wedge \\neg P \\wedge \\neg Q\n\\]\nPasso 6: Formar a conjunção completa\n\\[\n(((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee R) \\wedge (R \\wedge \\neg P \\wedge \\neg Q)\n\\]\nPasso 7: Aplicar distributividade\n\\[\n((P \\wedge \\neg Q) \\wedge R \\wedge \\neg P \\wedge \\neg Q) \\vee ((Q \\wedge \\neg P) \\wedge R \\wedge \\neg P \\wedge \\neg Q) \\vee (R \\wedge R \\wedge \\neg P \\wedge \\neg Q)\n\\]\nPasso 8: Simplificar\nO primeiro termo contém \\(P \\wedge \\neg P\\) (contradição), o segundo termo se reduz a \\((Q \\wedge \\neg P \\wedge R \\wedge \\neg Q)\\) que contém \\(Q \\wedge \\neg Q\\) (contradição).\nResultado Final:\n\\[\nR \\wedge \\neg P \\wedge \\neg Q\n\\]\n\n\n14.3.1.2 Solução do Exercício 2\nConverter \\(\\neg((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R)))\\) para Forma Normal Disjuntiva.\nPasso 1: Aplicar a negação da implicação principal\n\\[\n(P \\rightarrow (Q \\rightarrow R)) \\wedge \\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\n\\]\nPasso 2: Eliminar implicações no primeiro termo\n\\[\n(\\neg P \\vee (\\neg Q \\vee R)) \\wedge \\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\n\\]\n\\[\n(\\neg P \\vee \\neg Q \\vee R) \\wedge \\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\n\\]\nPasso 3: Trabalhar o segundo termo\n\\[\n\\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R)) \\equiv (P \\rightarrow Q) \\wedge \\neg(P \\rightarrow R)\n\\]\n\\[\n(\\neg P \\vee Q) \\wedge \\neg(\\neg P \\vee R) \\equiv (\\neg P \\vee Q) \\wedge (P \\wedge \\neg R)\n\\]\nPasso 4: Formar a conjunção completa\n\\[\n(\\neg P \\vee \\neg Q \\vee R) \\wedge (\\neg P \\vee Q) \\wedge P \\wedge \\neg R\n\\]\nPasso 5: Aplicar distributividade\n\\[\n((\\neg P \\wedge \\neg P \\wedge P \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge P \\wedge \\neg R) \\vee (\\neg Q \\wedge \\neg P \\wedge P \\wedge \\neg R) \\vee (\\neg Q \\wedge Q \\wedge P \\wedge \\neg R) \\vee (R \\wedge \\neg P \\wedge P \\wedge \\neg R) \\vee (R \\wedge Q \\wedge P \\wedge \\neg R))\n\\]\nPasso 6: Simplificar removendo contradições\nTodos os termos contêm contradições (\\(P \\wedge \\neg P\\), \\(Q \\wedge \\neg Q\\) ou \\(R \\wedge \\neg R\\)).\nResultado Final:\n\\[\n\\bot \\text{ (fórmula insatisfatível)}\n\\]\n\n\n14.3.1.3 Solução do Exercício 3\nConverter \\((P \\leftrightarrow (Q \\leftrightarrow R)) \\vee \\neg(P \\wedge Q \\wedge R)\\) para Forma Normal Disjuntiva.\nPasso 1: Analisar as duas partes da disjunção\nA fórmula é uma disjunção \\(A \\vee B\\), onde \\(A = (P \\leftrightarrow (Q \\leftrightarrow R))\\) e \\(B = \\neg(P \\wedge Q \\wedge R)\\). Para obter a FND, podemos encontrar a FND de cada parte e uni-las.\nPasso 2: Converter a primeira parte (\\(A\\)) para FND\nA expressão \\(A = (P \\leftrightarrow (Q \\leftrightarrow R))\\) é verdadeira quando um número par de proposições atômicas é falso (zero ou duas). Isso corresponde aos casos \\((T, T, T)\\), \\((T, F, F)\\), \\((F, T, F)\\) e \\((F, F, T)\\). A FND equivalente é:\n\\[A \\equiv (P \\wedge Q \\wedge R) \\vee (P \\wedge \\neg Q \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge \\neg R) \\vee (\\neg P \\wedge \\neg Q \\wedge R)\\]\nPasso 3: Converter a segunda parte (\\(B\\)) para FND\nAplicando a Lei de De Morgan em \\(B\\):\n\\[B \\equiv \\neg(P \\wedge Q \\wedge R) \\equiv \\neg P \\vee \\neg Q \\vee \\neg R\\]\nPasso 4: Unir as duas partes\nAgora, unimos as FNDs de \\(A\\) e \\(B\\) com a disjunção original da fórmula:\n\\[( (P \\wedge Q \\wedge R) \\vee (P \\wedge \\neg Q \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge \\neg R) \\vee (\\neg P \\wedge \\neg Q \\wedge R) ) \\vee (\\neg P \\vee \\neg Q \\vee \\neg R)\\]\nPasso 5: Simplificar usando a Lei da Absorção\nA Lei da Absorção, \\(X \\vee (X \\wedge Y) \\equiv X\\), permite simplificar a expressão. Os literais \\(\\neg P\\), \\(\\neg Q\\) e \\(\\neg R\\) absorverão qualquer conjunção que os contenha.\n\n\\(\\neg P\\) absorve \\((\\neg P \\wedge Q \\wedge \\neg R)\\) e \\((\\neg P \\wedge \\neg Q \\wedge R)\\).\n\\(\\neg Q\\) absorve \\((P \\wedge \\neg Q \\wedge \\neg R)\\).\n\\(\\neg R\\) também absorve \\((P \\wedge \\neg Q \\wedge \\neg R)\\).\n\nApós a absorção, a expressão se torna muito mais simples.\nResultado Final:\n\\[(P \\wedge Q \\wedge R) \\vee \\neg P \\vee \\neg Q \\vee \\neg R\\]\n\n\n14.3.1.4 Solução do Exercício 4\nConverter \\(\\neg((P \\vee Q) \\rightarrow (R \\wedge S)) \\leftrightarrow (P \\rightarrow \\neg Q)\\) para Forma Normal Disjuntiva.\nPasso 1: Trabalhar o lado esquerdo da bicondicional\n\\[\n\\neg((P \\vee Q) \\rightarrow (R \\wedge S)) \\equiv (P \\vee Q) \\wedge \\neg(R \\wedge S) \\equiv (P \\vee Q) \\wedge (\\neg R \\vee \\neg S)\n\\]\nPasso 2: Aplicar distributividade no lado esquerdo\n\\[\n(P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)\n\\]\nPasso 3: Trabalhar o lado direito\n\\[\nP \\rightarrow \\neg Q \\equiv \\neg P \\vee \\neg Q\n\\]\nPasso 4: Eliminar a bicondicional\n\\[\n((P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)) \\leftrightarrow (\\neg P \\vee \\neg Q)\n\\]\nPasso 5: Aplicar definição de bicondicional\nSeja \\(A = (P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)\\) e \\(B = \\neg P \\vee \\neg Q\\)\n\\[\n(A \\wedge B) \\vee (\\neg A \\wedge \\neg B)\n\\]\nPasso 6: Expandir \\(\\neg B\\)\n\\[\n\\neg B = \\neg(\\neg P \\vee \\neg Q) = P \\wedge Q\n\\]\nPasso 7: Formar a expressão final\n\\[\n(((P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)) \\wedge (\\neg P \\vee \\neg Q)) \\vee (\\neg A \\wedge P \\wedge Q)\n\\]\nPasso 8: Aplicar distributividade e simplificar\nApós aplicar distributividade e eliminar contradições:\nResultado Final:\n\\[\n(P \\wedge \\neg Q \\wedge \\neg R) \\vee (P \\wedge \\neg Q \\wedge \\neg S) \\vee (\\neg P \\wedge Q \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge \\neg S) \\vee (P \\wedge Q \\wedge R \\wedge S)\n\\]\n\n\n14.3.1.5 Solução do Exercício 5\nConverter \\(((P \\wedge Q) \\rightarrow (R \\vee S)) \\wedge ((R \\rightarrow P) \\vee (S \\rightarrow Q))\\) para Forma Normal Disjuntiva.\nPasso 1: Eliminar implicações no primeiro termo\n\\[\n(\\neg(P \\wedge Q) \\vee (R \\vee S)) \\equiv (\\neg P \\vee \\neg Q \\vee R \\vee S)\n\\]\nPasso 2: Eliminar implicações no segundo termo\n\\[\n((\\neg R \\vee P) \\vee (\\neg S \\vee Q)) \\equiv (\\neg R \\vee P \\vee \\neg S \\vee Q)\n\\]\nPasso 3: Formar a conjunção\n\\[\n(\\neg P \\vee \\neg Q \\vee R \\vee S) \\wedge (\\neg R \\vee P \\vee \\neg S \\vee Q)\n\\]\nPasso 4: Aplicar distributividade\nDistribuindo o primeiro termo sobre o segundo:\n\\[\n(\\neg P \\wedge \\neg R) \\vee (\\neg P \\wedge P) \\vee (\\neg P \\wedge \\neg S) \\vee (\\neg P \\wedge Q) \\vee\n\\]\n\\[\n(\\neg Q \\wedge \\neg R) \\vee (\\neg Q \\wedge P) \\vee (\\neg Q \\wedge \\neg S) \\vee (\\neg Q \\wedge Q) \\vee\n\\]\n\\[\n(R \\wedge \\neg R) \\vee (R \\wedge P) \\vee (R \\wedge \\neg S) \\vee (R \\wedge Q) \\vee\n\\]\n\\[\n(S \\wedge \\neg R) \\vee (S \\wedge P) \\vee (S \\wedge \\neg S) \\vee (S \\wedge Q)\n\\]\nPasso 5: Eliminar contradições\nRemovendo termos com contradições (\\(P \\wedge \\neg P\\), \\(Q \\wedge \\neg Q\\), \\(R \\wedge \\neg R\\), \\(S \\wedge \\neg S\\)):\nResultado Final:\n\\[\n(\\neg P \\wedge \\neg R) \\vee (\\neg P \\wedge \\neg S) \\vee (\\neg P \\wedge Q) \\vee (\\neg Q \\wedge \\neg R) \\vee (\\neg Q \\wedge P) \\vee (\\neg Q \\wedge \\neg S) \\vee (R \\wedge P) \\vee (R \\wedge \\neg S) \\vee (R \\wedge Q) \\vee (S \\wedge \\neg R) \\vee (S \\wedge P) \\vee (S \\wedge Q)\n\\]\n\n\n14.3.1.6 Solução do Exercício 6\nConverter \\(\\neg(P \\leftrightarrow \\neg Q) \\rightarrow ((P \\wedge R) \\vee (Q \\wedge \\neg R))\\) para Forma Normal Disjuntiva.\nPasso 1: Trabalhar a negação da bicondicional\n\\[\n\\neg(P \\leftrightarrow \\neg Q) \\equiv (P \\wedge Q) \\vee (\\neg P \\wedge \\neg Q)\n\\]\nPasso 2: Eliminar a implicação principal\n\\[\n\\neg((P \\wedge Q) \\vee (\\neg P \\wedge \\neg Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nPasso 3: Aplicar De Morgan\n\\[\n(\\neg(P \\wedge Q) \\wedge \\neg(\\neg P \\wedge \\neg Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\n\\[\n((\\neg P \\vee \\neg Q) \\wedge (P \\vee Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nPasso 4: Expandir o primeiro termo\n\\[\n((\\neg P \\wedge P) \\vee (\\neg P \\wedge Q) \\vee (\\neg Q \\wedge P) \\vee (\\neg Q \\wedge Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nPasso 5: Simplificar removendo contradições\n\\[\n((\\neg P \\wedge Q) \\vee (P \\wedge \\neg Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nResultado Final:\n\\[\n(\\neg P \\wedge Q) \\vee (P \\wedge \\neg Q) \\vee (P \\wedge R) \\vee (Q \\wedge \\neg R)\n\\]\n\n\n14.3.1.7 Solução do Exercício 7\n\n\n\n14.3.2 Exercícios Conversão Forma Normal Conjuntiva Section 7.1.3.7\n\n14.3.2.1 Solução do Exercício 1\nConverter \\((p \\leftrightarrow q) \\rightarrow ((p \\wedge r) \\vee (q \\wedge \\neg r))\\) para Forma Normal Conjuntiva.\nOs passos 1 a 3 da solução original estão corretos. O erro ocorreu na conversão da forma intermediária para a FNC. Vamos retomar do final do passo 3.\nPasso 3: Expressão intermediária\nA fórmula é equivalente a:\n\\[\n((\\neg p \\vee \\neg q) \\wedge (p \\vee q)) \\vee ((p \\wedge r) \\vee (q \\wedge \\neg r))\n\\]\nPasso 4: Aplicar a distributividade de \\(\\vee\\) sobre \\(\\wedge\\)\nUsando a regra \\((A \\wedge B) \\vee C \\equiv (A \\vee C) \\wedge (B \\vee C)\\), obtemos:\n\\[\n((\\neg p \\vee \\neg q) \\vee ((p \\wedge r) \\vee (q \\wedge \\neg r))) \\wedge ((p \\vee q) \\vee ((p \\wedge r) \\vee (q \\wedge \\neg r)))\n\\]\nPasso 5: Simplificar a primeira grande cláusula\n\\[\n\\neg p \\vee \\neg q \\vee (p \\wedge r) \\vee (q \\wedge \\neg r)\n\\]\nAplicando distributividade e absorção: \\((\\neg p \\vee (p \\wedge r)) \\equiv (\\neg p \\vee p) \\wedge (\\neg p \\vee r) \\equiv \\top \\wedge (\\neg p \\vee r) \\equiv (\\neg p \\vee r)\\). E \\((\\neg q \\vee (q \\wedge \\neg r)) \\equiv (\\neg q \\vee q) \\wedge (\\neg q \\vee \\neg r) \\equiv \\top \\wedge (\\neg q \\vee \\neg r) \\equiv (\\neg q \\vee \\neg r)\\). A cláusula se torna \\((\\neg p \\vee r) \\vee (\\neg q \\vee \\neg r) \\equiv \\neg p \\vee \\neg q \\vee r \\vee \\neg r\\), que é uma tautologia (\\(\\top\\)).\nPasso 6: Simplificar a segunda grande cláusula\n\\[\np \\vee q \\vee (p \\wedge r) \\vee (q \\wedge \\neg r)\n\\]\nPela lei de absorção, \\((p \\vee (p \\wedge r)) \\equiv p\\) e \\((q \\vee (q \\wedge \\neg r)) \\equiv q\\). A cláusula se torna \\(p \\vee q\\).\nPasso 7: Combinar os resultados\nA fórmula completa é \\(\\top \\wedge (p \\vee q)\\).\nResultado Final:\n\\[\np \\vee q\n\\]\n\n\n14.3.2.2 Solução do Exercício 2\nConverter \\(\\neg((p \\rightarrow q) \\vee (q \\rightarrow p)) \\wedge (p \\vee q)\\) para Forma Normal Conjuntiva.\nPasso 1: Aplicar De Morgan no primeiro termo\n\\[\n\\neg(p \\rightarrow q) \\wedge \\neg(q \\rightarrow p) \\wedge (p \\vee q)\n\\]\nPasso 2: Eliminar implicações\n\\[\n\\neg(\\neg p \\vee q) \\wedge \\neg(\\neg q \\vee p) \\wedge (p \\vee q)\n\\]\nPasso 3: Aplicar De Morgan\n\\[\n(p \\wedge \\neg q) \\wedge (q \\wedge \\neg p) \\wedge (p \\vee q)\n\\]\nPasso 4: Expandir a conjunção\n\\[\np \\wedge \\neg q \\wedge q \\wedge \\neg p \\wedge (p \\vee q)\n\\]\nPasso 5: Identificar contradição\nA expressão contém \\(p \\wedge \\neg p\\) e \\(q \\wedge \\neg q\\), que são contradições.\nResultado Final:\n\\[\n\\bot \\text{ (fórmula insatisfatível)}\n\\]\n\n\n14.3.2.3 Solução do Exercício 3\nConverter \\(\\neg((p \\wedge (q \\vee r)) \\leftrightarrow ((p \\wedge q) \\vee (p \\wedge r)))\\) para Forma Normal Conjuntiva.\nPasso 1: Observar que é a negação de uma tautologia\nA bicondicional \\((p \\wedge (q \\vee r)) \\leftrightarrow ((p \\wedge q) \\vee (p \\wedge r))\\) é a lei distributiva, que é uma tautologia. Sua negação é uma contradição.\nPasso 2: Verificar por expansão\nLado esquerdo: \\(p \\wedge (q \\vee r)\\)\nLado direito: \\((p \\wedge q) \\vee (p \\wedge r)\\)\nAplicando distributividade no lado esquerdo:\n\\[\np \\wedge (q \\vee r) \\equiv (p \\wedge q) \\vee (p \\wedge r)\n\\]\nOs dois lados são idênticos, confirmando que a bicondicional é uma tautologia.\nResultado Final:\n\\[\n\\bot \\text{ (fórmula insatisfatível)}\n\\]\n\n\n14.3.2.4 Solução do Exercício 4\nConverter \\(((p \\vee q) \\rightarrow r) \\leftrightarrow (p \\rightarrow r) \\wedge (q \\rightarrow r)\\) para Forma Normal Conjuntiva.\nPasso 1: Trabalhar o lado esquerdo\n\\[\n(p \\vee q) \\rightarrow r \\equiv \\neg(p \\vee q) \\vee r \\equiv (\\neg p \\wedge \\neg q) \\vee r\n\\]\nPasso 2: Trabalhar o lado direito\n\\[\n(p \\rightarrow r) \\wedge (q \\rightarrow r) \\equiv (\\neg p \\vee r) \\wedge (\\neg q \\vee r)\n\\]\nAplicando distributividade:\n\\[\n(\\neg p \\wedge \\neg q) \\vee (\\neg p \\wedge r) \\vee (r \\wedge \\neg q) \\vee (r \\wedge r)\n\\]\nSimplificando:\n\\[\n(\\neg p \\wedge \\neg q) \\vee r\n\\]\nPasso 3: Observar que ambos os lados são equivalentes\nComo ambos os lados da bicondicional são iguais, a fórmula é uma tautologia.\nResultado Final:\n\\[\n\\top \\text{ (tautologia)}\n\\]\nComo é uma tautologia, sua Forma Normal Conjuntiva é vazia ou pode ser representada por qualquer cláusula tautológica como \\((p \\vee \\neg p)\\).\n\n\n14.3.2.5 Solução do Exercício 5\nConverter \\((p \\rightarrow (q \\rightarrow r)) \\wedge \\neg((p \\wedge q) \\rightarrow r)\\) para Forma Normal Conjuntiva.\nPasso 1: Eliminar implicações no primeiro termo\n\\[\np \\rightarrow (q \\rightarrow r) \\equiv \\neg p \\vee (\\neg q \\vee r) \\equiv \\neg p \\vee \\neg q \\vee r\n\\]\nPasso 2: Trabalhar o segundo termo\n\\[\n\\neg((p \\wedge q) \\rightarrow r) \\equiv \\neg(\\neg(p \\wedge q) \\vee r) \\equiv (p \\wedge q) \\wedge \\neg r\n\\]\n\\[\np \\wedge q \\wedge \\neg r\n\\]\nPasso 3: Formar a conjunção completa\n\\[\n(\\neg p \\vee \\neg q \\vee r) \\wedge p \\wedge q \\wedge \\neg r\n\\]\nPasso 4: Reorganizar como cláusulas\n\\[\n(\\neg p \\vee \\neg q \\vee r) \\wedge p \\wedge q \\wedge \\neg r\n\\]\nPasso 5: Aplicar a regra de unidade\nQuando temos cláusulas unitárias (\\(p\\), \\(q\\), \\(\\neg r\\)), podemos simplificar a primeira cláusula:\n\nComo \\(p\\) é verdadeiro, \\(\\neg p\\) é falso\nComo \\(q\\) é verdadeiro, \\(\\neg q\\) é falso\nComo \\(\\neg r\\) é verdadeiro, \\(r\\) é falso\n\nA primeira cláusula se torna: \\((F \\vee F \\vee F) = F\\)\nResultado Final:\n\\[\n\\bot \\text{ (fórmula insatisfatível)}\n\\]\n\n\n14.3.2.6 Solução do Exercício 6\nConverter \\(((p \\leftrightarrow q) \\vee (q \\leftrightarrow r)) \\wedge \\neg(p \\leftrightarrow r)\\) para Forma Normal Conjuntiva.\nA conversão para a Forma Normal Disjuntiva no Passo 5 estava correta, mas a conversão subsequente para FNC estava incorreta. Uma abordagem mais segura é converter cada parte para FNC separadamente.\nPasso 1: Converter \\(\\neg(p \\leftrightarrow r)\\) para FNC\n\\[\n\\neg(p \\leftrightarrow r) \\equiv (p \\wedge \\neg r) \\vee (\\neg p \\wedge r)\n\\]\nAplicando a distributividade:\n\\[\n(p \\vee \\neg p) \\wedge (p \\vee r) \\wedge (\\neg r \\vee \\neg p) \\wedge (\\neg r \\vee r) \\equiv (p \\vee r) \\wedge (\\neg p \\vee \\neg r)\n\\]\nPasso 2: Converter \\((p \\leftrightarrow q) \\vee (q \\leftrightarrow r)\\) para FNC\nPrimeiro, as FNCs das bicondicionais: \\(p \\leftrightarrow q \\equiv (\\neg p \\vee q) \\wedge (p \\vee \\neg q)\\) \\(q \\leftrightarrow r \\equiv (\\neg q \\vee r) \\wedge (q \\vee \\neg r)\\) A expressão é \\(((\\neg p \\vee q) \\wedge (p \\vee \\neg q)) \\vee ((\\neg q \\vee r) \\wedge (q \\vee \\neg r))\\). Aplicando a distributividade \\((A \\wedge B) \\vee (C \\wedge D) \\equiv (A \\vee C) \\wedge (A \\vee D) \\wedge (B \\vee C) \\wedge (B \\vee D)\\):\n\n\\((\\neg p \\vee q) \\vee (\\neg q \\vee r) \\equiv \\neg p \\vee \\top \\vee r \\equiv \\top\\)\n\\((\\neg p \\vee q) \\vee (q \\vee \\neg r) \\equiv \\neg p \\vee q \\vee \\neg r\\)\n\\((p \\vee \\neg q) \\vee (\\neg q \\vee r) \\equiv p \\vee \\neg q \\vee r\\)\n\\((p \\vee \\neg q) \\vee (q \\vee \\neg r) \\equiv p \\vee \\top \\vee \\neg r \\equiv \\top\\)\n\nEsta parte simplifica para \\((\\neg p \\vee q \\vee \\neg r) \\wedge (p \\vee \\neg q \\vee r)\\).\nPasso 3: Formar a conjunção completa\nJuntando as FNCs de ambas as partes:\nResultado Final:\n\\[\n(\\neg p \\vee q \\vee \\neg r) \\wedge (p \\vee \\neg q \\vee r) \\wedge (p \\vee r) \\wedge (\\neg p \\vee \\neg r)\n\\]\n\n\n14.3.2.7 Solução do Exercício 7\nConverter \\(\\neg(p \\rightarrow (q \\vee r)) \\vee ((p \\wedge \\neg q) \\rightarrow r)\\) para Forma Normal Conjuntiva.\nOs passos 1 a 3 da solução original estão corretos, resultando em:\n\\[\n(p \\wedge \\neg q \\wedge \\neg r) \\vee (\\neg p \\vee q \\vee r)\n\\]\nO erro ocorreu na simplificação final após a distributividade.\nPasso 4: Aplicar distributividade para obter FNC\nSeja \\(A = (\\neg p \\vee q \\vee r)\\). A expressão é \\((p \\wedge \\neg q \\wedge \\neg r) \\vee A\\). Distribuindo, temos:\n\\[\n(p \\vee A) \\wedge (\\neg q \\vee A) \\wedge (\\neg r \\vee A)\n\\]\nSubstituindo \\(A\\) de volta:\n\\[\n(p \\vee (\\neg p \\vee q \\vee r)) \\wedge (\\neg q \\vee (\\neg p \\vee q \\vee r)) \\wedge (\\neg r \\vee (\\neg p \\vee q \\vee r))\n\\]\nPasso 5: Simplificar\nAnalisamos cada cláusula:\n\n\\(p \\vee \\neg p \\vee q \\vee r \\equiv \\top \\vee q \\vee r \\equiv \\top\\);\n\\(\\neg q \\vee \\neg p \\vee q \\vee r \\equiv \\neg p \\vee (q \\vee \\neg q) \\vee r \\equiv \\neg p \\vee \\top \\vee r \\equiv \\top\\);\n\\(\\neg r \\vee \\neg p \\vee q \\vee r \\equiv \\neg p \\vee q \\vee (r \\vee \\neg r) \\equiv \\neg p \\vee q \\vee \\top \\equiv \\top\\).\n\nA expressão completa é \\(\\top \\wedge \\top \\wedge \\top\\).\nResultado Final:\n\\[\n\\top \\text{ (a fórmula é uma tautologia)}\n\\]\n\n\n\n14.3.3 Conexão com o Prolog Section 7.3\n\n14.3.3.1 Questão 1\nDada a seguinte fórmula lógica, que representa uma regra de negócio simples: “Se o pedido (\\(P\\)) foi aprovado, então a nota fiscal (\\(N\\)) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (\\(E\\)).”\nFórmula: \\[(P \\to N) \\wedge \\neg (N \\wedge \\neg E)\\]\n\nEliminar Implicação e Mover Negação:\n\\[(\\neg P \\vee N) \\wedge (\\neg N \\vee \\neg \\neg E)\\]\n\\[(\\neg P \\vee N) \\wedge (\\neg N \\vee E)\\]\nFNC: A fórmula já está em FNC. As cláusulas são \\[(\\neg P \\vee N)\\] e \\[(\\neg N \\vee E)\\].\nFND: Para obter a FND, aplicamos a distributividade:\n\n\\[((\\neg P \\vee N) \\wedge \\neg N) \\vee ((\\neg P \\vee N) \\wedge E)\\]\n\\[(\\neg P \\wedge \\neg N) \\vee (N \\wedge \\neg N) \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\n\\[(\\neg P \\wedge \\neg N) \\vee \\text{Falso} \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\nFND Final:\n\\[(\\neg P \\wedge \\neg N) \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\nEm Prolog:\n% Fórmula original: (P -&gt; N) ∧ ¬(N ∧ ¬E)\noriginal(P, N, E, Result) :-\n    (P -&gt; N, \\+ (N, \\+ E)) -&gt; Result = true ; Result = false.\n\n% FNC: (¬P ∨ N) ∧ (¬N ∨ E)\nfnc(P, N, E, Result) :-\n    ((\\+ P ; N), (\\+ N ; E)) -&gt; Result = true ; Result = false.\n\n% FND: (¬P ∧ ¬N) ∨ (¬P ∧ E) ∨ (N ∧ E)\nfnd(P, N, E, Result) :-\n    ((\\+ P, \\+ N) ; (\\+ P, E) ; (N, E)) -&gt; Result = true ; Result = false.\n\n% Testar equivalência\ntest_equivalence :-\n    findall([P, N, E], (member(P, [true, false]), member(N, [true, false]), member(E, [true, false])), Cases),\n    forall(member([P, N, E], Cases),\n           (original(P, N, E, Orig), fnc(P, N, E, FNC), fnd(P, N, E, FND),\n            (Orig = FNC, FNC = FND -&gt;\n                write('Caso '), write([P, N, E]), write(': Equivalente'), nl\n            ;   write('Caso '), write([P, N, E]), write(': Não Equivalente'), nl, fail))).\n\n\n14.3.3.2 Questão 2\n\nModelagem: \\[I \\leftrightarrow (S \\vee (\\neg C \\wedge T))\\]\nFND: A fórmula \\[S \\vee (\\neg C \\wedge T)\\] já está em Forma Normal Disjuntiva.\n\n\nSignificado: Cada termo (disjunto) representa um cenário completo e independente que ativa a irrigação.\n\\(S\\): O sistema ativa se o solo estiver seco (independentemente de outros fatores).\n\\(\\neg C \\wedge T\\): O sistema ativa se não choveu E a temperatura está alta (mesmo que o solo ainda não esteja tecnicamente seco).\n\nEm Prolog:\n% Condição de ativação: I ↔ (S ∨ (¬C ∧ T))\nactivation(I, S, C, T, Result) :-\n    (I == (S ; (\\+ C, T))) -&gt; Result = true ; Result = false.\n\n% Testar cenários onde a irrigação é ativada\ntest_activation :-\n    findall([S, C, T, I], (member(S, [true, false]), member(C, [true, false]), member(T, [true, false]), member(I, [true, false])), Cases),\n    forall(member([S, C, T, I], Cases),\n           (activation(I, S, C, T, Res),\n            (Res = true -&gt;\n                write('Irrigação ativa para '), write([S, C, T, I]), nl\n            ;   true))).\n\n\n14.3.3.3 Questão 3\n\nModelagem:\n\n\nR1: \\[I \\to P\\]\n\nR2: \\[\\neg I \\to (P \\leftrightarrow S)\\]\n\nR3: \\[S \\to \\neg I\\]\n\nFórmula Conjunta: \\[(I \\to P) \\wedge (\\neg I \\to (P \\leftrightarrow S)) \\wedge (S \\to \\neg I)\\]\n\n\nConversão para FNC:\n\n\nR1: \\[\\neg I \\vee P\\]\n\nR3: \\[\\neg S \\vee \\neg I\\]\n\nR2: \\[I \\vee (P \\leftrightarrow S) \\equiv I \\vee ((P \\to S) \\wedge (S \\to P)) \\equiv I \\vee ((\\neg P \\vee S) \\wedge (\\neg S \\vee P)) \\equiv (I \\vee \\neg P \\vee S) \\wedge (I \\vee \\neg S \\vee P)\\]\n\n\nFNC Completa: \\[(\\neg I \\vee P) \\wedge (\\neg S \\vee \\neg I) \\wedge (I \\vee \\neg P \\vee S) \\wedge (I \\vee \\neg S \\vee P)\\]\nAnálise: As regras são consistentes. A FNC nos dá um conjunto de restrições que podem ser satisfeitas (ex: \\(I\\), \\(P\\), \\(\\neg S\\) é uma solução). Se uma conexão fosse segura e interna (\\(S \\wedge I\\)), a cláusula \\[(\\neg S \\vee \\neg I)\\] seria falsa, tornando todo o conjunto de regras falso. Isso significa que tal cenário é proibido pelas regras, o que é o comportamento esperado.\n\nEm Prolog:\n% Cláusulas\nclause1(I, P, _) :- \\+ I ; P.\nclause2(_, S, I) :- \\+ S ; \\+ I.\nclause3(I, P, S) :- I ; \\+ P ; S.\nclause4(I, P, S) :- I ; \\+ S ; P.\n\n% Verificar consistência\nconsistent(I, P, S) :- clause1(I, P, _), clause2(_, S, I), clause3(I, P, S), clause4(I, P, S).\n\n% Testar consistência\ntest_consistency :-\n    (consistent(true, true, false) -&gt;\n        write('Consistente: I=true, P=true, S=false'), nl\n    ;   write('Inconsistente para I=true, P=true, S=false'), nl),\n    (consistent(true, true, true) -&gt;\n        write('Consistente: I=true, P=true, S=true'), nl\n    ;   write('Inconsistente para I=true, P=true, S=true (S ∧ I é proibido)'), nl).\n\n\n14.3.3.4 Questão 4\n\nModelagem:\n\n\nAlice: \\[A \\leftrightarrow (D \\to (C \\vee (\\neg C \\wedge P)))\\]\nBeto: \\[B \\leftrightarrow (D \\to (P \\vee C))\\]\n\n\nSimplificação e FND Mínima:\n\n\nAlice: A condição de acesso é \\[C \\vee (\\neg C \\wedge P)\\]. Usando a lei da absorção \\[(X \\vee (\\neg X \\wedge Y)) \\equiv (X \\vee Y)\\], a fórmula simplifica para \\[C \\vee P\\].\nBeto: A condição de acesso é \\[P \\vee C\\].\n\n\nConclusão: Ambas as políticas simplificam para a mesma FND mínima: \\[C \\vee P\\]. Portanto, as políticas de Alice e Beto são logicamente equivalentes.\n\nEm Prolog:\n% Política de Alice: A ↔ (D → (C ∨ (¬C ∧ P)))\nalice(A, D, C, P) :- A == (D -&gt; (C ; (\\+ C, P))).\n\n% Política de Beto: B ↔ (D → (P ∨ C))\nbob(B, D, C, P) :- B == (D -&gt; (P ; C)).\n\n% Testar equivalência\ntest_equivalence :-\n    findall([A, B, D, C, P], (member(A, [true, false]), member(B, [true, false]), \n                              member(D, [true, false]), member(C, [true, false]), member(P, [true, false])), Cases),\n    forall(member([A, B, D, C, P], Cases),\n           (alice(A, D, C, P), bob(B, D, C, P),\n            (A = B -&gt;\n                write('Caso '), write([D, C, P]), write(': Equivalente'), nl\n            ;   write('Caso '), write([D, C, P]), write(': Não Equivalente'), nl, fail))).\n\n\n14.3.3.5 Questão 5\n\nFórmula: \\[F \\leftrightarrow (P \\vee T)\\]\nConversão: A bicondicional \\[A \\leftrightarrow B\\] é equivalente a \\[(A \\to B) \\wedge (B \\to A)\\].\n\\[(F \\to (P \\vee T)) \\wedge ((P \\vee T) \\to F)\\]\nEliminar Implicações:\n\n\\[(\\neg F \\vee P \\vee T) \\wedge (\\neg (P \\vee T) \\vee F)\\]\n\\[(\\neg F \\vee P \\vee T) \\wedge ((\\neg P \\wedge \\neg T) \\vee F)\\]\n\nDistribuir para FNC:\n\n\nO primeiro termo já é uma cláusula.\n\nO segundo termo: \\[(\\neg P \\vee F) \\wedge (\\neg T \\vee F)\\].\n\n\nFNC Final: \\[(\\neg F \\vee P \\vee T) \\wedge (\\neg P \\vee F) \\wedge (\\neg T \\vee F)\\].\n\n\nSignificado das Cláusulas:\n\\((\\neg F \\vee P \\vee T)\\): Se o frete foi grátis (\\(F\\)), então o cliente deve ser Prime (\\(P\\)) ou o pedido deve ser de alto valor (\\(T\\)).\n\\((\\neg P \\vee F)\\): Se o cliente é Prime, o frete deve ser grátis.\n\\((\\neg T \\vee F)\\): Se o pedido é de alto valor, o frete deve ser grátis.\n\nEm Prolog:\n% Fórmula original: F ↔ (P ∨ T)\noriginal(F, P, T) :- F == (P ; T).\n\n% FNC: (¬F ∨ P ∨ T) ∧ (¬P ∨ F) ∧ (¬V ∨ F)\nfnc(F, P, T) :- (\\+ F ; P ; T), (\\+ P ; F), (\\+ T ; F).\n\n% Testar equivalência\ntest_equivalence :-\n    findall([F, P, T], (member(F, [true, false]), member(P, [true, false]), member(T, [true, false])), Cases),\n    forall(member([F, P, T], Cases),\n           (original(F, P, T), fnc(F, P, T),\n            (original(F, P, T) = fnc(F, P, T) -&gt;\n                write('Caso '), write([F, P, T]), write(': Equivalente'), nl\n            ;   write('Caso '), write([F, P, T]), write(': Não Equivalente'), nl, fail))).\n\n\n14.3.3.6 Questão 6\n\nFND Canônica: Soma dos mintermos (casos onde a saída é 1):\n\n\\[(\\neg A \\wedge \\neg B \\wedge C) \\vee (\\neg A \\wedge B \\wedge C) \\vee (A \\wedge \\neg B \\wedge \\neg C) \\vee (A \\wedge \\neg B \\wedge C)\\]\n\nMapa de Karnaugh:\n\n\n\n\n\\(A\\)  \\(BC\\)\n00\n01\n11\n10\n\n\n\n\n0\n0\n1\n1\n0\n\n\n1\n1\n0\n0\n1\n\n\n\n\nAgrupamentos:\n\nGrupo 1 (vertical): Coluna \\(BC=01\\), linhas \\(A=0,1\\). Termo: \\[\\neg B \\wedge C\\].\nGrupo 2 (horizontal): Linha \\(A=1\\), colunas \\(BC=00,01\\). Termo: \\[A \\wedge \\neg B\\].\nFND Mínima: \\((\\neg B \\wedge C) \\vee (A \\wedge \\neg B)\\).\n\n\nEm Prolog:\n% Função de saída da tabela verdade\noutput(A, B, C, Result) :-\n    ((A=false, B=false, C=true); (A=false, B=true, C=true); \n     (A=true, B=false, C=false); (A=true, B=false, C=true)) -&gt; Result = true ; Result = false.\n\n% FND mínima: (¬B ∧ C) ∨ (A ∧ ¬B)\nfnd_min(A, B, C, Result) :-\n    ((\\+ B, C) ; (A, \\+ B)) -&gt; Result = true ; Result = false.\n\n% Testar equivalência\ntest_fnd :-\n    findall([A, B, C], (member(A, [true, false]), member(B, [true, false]), member(C, [true, false])), Cases),\n    forall(member([A, B, C], Cases),\n           (output(A, B, C, Out), fnd_min(A, B, C, FND),\n            (Out = FND -&gt;\n                write('Caso '), write([A, B, C]), write(': Equivalente'), nl\n            ;   write('Caso '), write([A, B, C]), write(': Não Equivalente'), nl, fail))).\n\n\n14.3.3.7 Questão 7\nSolução:\nPasso 1 - Aplicação da Instanciação Universal\nComo temos \\(\\forall x (L(x) \\to M(x))\\) e queremos aplicar isso ao indivíduo específico \\(s\\), podemos usar a regra de instanciação universal para obter \\(L(s) \\to M(s)\\). Assim, a fórmula se torna:\n\\[((L(s) \\to M(s)) \\wedge L(s)) \\to M(s)\\]\nPasso 2 - Prova por Tabela-Verdade\nPara provar que esta fórmula é uma tautologia, vamos verificar que ela é verdadeira em todas as atribuições possíveis. Primeiro, vamos eliminar a implicação interna:\n\\[((\\neg L(s) \\vee M(s)) \\wedge L(s)) \\to M(s)\\]\nConstruindo a tabela-verdade:\n\n\n\n\n\n\n\n\n\n\n\\(L(s)\\)\n\\(M(s)\\)\n\\(\\neg L(s) \\vee M(s)\\)\n\\((\\neg L(s) \\vee M(s)) \\wedge L(s)\\)\nFórmula Final\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\n\n\nF\nF\nT\nF\nT\n\n\n\nA fórmula é verdadeira em todas as linhas, portanto é uma tautologia.\nPasso 3 - Prova Alternativa por Contradição\nAlternativamente, podemos provar que a fórmula é uma tautologia mostrando que sua negação é insatisfatível (sempre falsa). Negando a fórmula original:\n\\[\\neg [((L(s) \\to M(s)) \\wedge L(s)) \\to M(s)]\\]\nAplicando \\(\\neg(A \\to B) \\equiv A \\wedge \\neg B\\):\n\\[((L(s) \\to M(s)) \\wedge L(s)) \\wedge \\neg M(s)\\]\nExpandindo \\(L(s) \\to M(s) \\equiv \\neg L(s) \\vee M(s)\\):\n\\[((\\neg L(s) \\vee M(s)) \\wedge L(s)) \\wedge \\neg M(s)\\]\nDistribuindo \\(L(s)\\) sobre a disjunção:\n\\[((\\neg L(s) \\wedge L(s)) \\vee (M(s) \\wedge L(s))) \\wedge \\neg M(s)\\]\nComo \\(\\neg L(s) \\wedge L(s)\\) é sempre falso:\n\\[(M(s) \\wedge L(s)) \\wedge \\neg M(s)\\]\nReorganizando:\n\\[L(s) \\wedge M(s) \\wedge \\neg M(s)\\]\nEsta fórmula contém a contradição \\(M(s) \\wedge \\neg M(s)\\), que é sempre falsa.\nPasso 4 - Conversão para Forma Normal Conjuntiva\nA negação da fórmula original (que é uma contradição) já está em Forma Normal Conjuntiva:\n\\[L(s) \\wedge M(s) \\wedge \\neg M(s)\\]\nEsta é uma conjunção de três cláusulas unitárias. Como esta Forma Normal Conjuntiva é sempre falsa (contradição), a fórmula original é sempre verdadeira (tautologia).\nConclusão: como demonstrado tanto pela tabela-verdade quanto pela prova por contradição, a fórmula \\(((\\forall x(L(x) \\to M(x))) \\wedge L(s)) \\to M(s)\\) é uma tautologia. Isso confirma que a inferência “Todos os leões são mamíferos, Simba é um leão, portanto Simba é um mamífero” é logicamente válida em qualquer interpretação. Em Prolog:\n% Implementação da prova de tautologia em SWI-Prolog\n% Fórmula: ((∀x(L(x) → M(x))) ∧ L(s)) → M(s)\n\n% ============================================================================\n% PARTE 1: DEFINIÇÃO DOS FATOS E REGRAS BASE\n% ============================================================================\n\n% Regra universal: todos os leões são mamíferos\nmamifero(X) :- leao(X).\n\n% Fato específico: Simba é um leão\nleao(simba).\n\n% ============================================================================\n% PARTE 2: VERIFICAÇÃO DIRETA DA INFERÊNCIA\n% ============================================================================\n\n% Predicado que verifica se a inferência é válida para um indivíduo específico\ninferencia_valida(Individuo) :-\n    % Se o indivíduo é leão E todos os leões são mamíferos\n    % Então o indivíduo é mamífero\n    (leao(Individuo) -&gt; mamifero(Individuo)).\n\n% Teste da inferência para Simba\nteste_simba :-\n    write('Testando inferência para Simba:'), nl,\n    (inferencia_valida(simba) -&gt;\n        write('✓ Inferência válida: Se Simba é leão, então Simba é mamífero') ;\n        write('✗ Inferência inválida')\n    ), nl.\n\n% ============================================================================\n% PARTE 3: SIMULAÇÃO DA TABELA-VERDADE\n% ============================================================================\n\n% Predicado auxiliar para implicação lógica\nimplica(A, B) :- \\+ A ; B.\n\n% Avaliação da fórmula para todos os valores possíveis\ntabela_verdade :-\n    write('Tabela-verdade para ((L(s) → M(s)) ∧ L(s)) → M(s):'), nl,\n    write('L(s) | M(s) | L(s)→M(s) | (L(s)→M(s))∧L(s) | Fórmula'), nl,\n    write('-----|-----|---------|-------------|--------'), nl,\n    \n    % Testando todas as combinações\n    member(L, [true, false]),\n    member(M, [true, false]),\n    \n    % Calculando subformulas\n    implica(L, M, Impl1),\n    and_logic(Impl1, L, Antecedente),\n    implica(Antecedente, M, Formula),\n    \n    % Exibindo resultado\n    format(' ~w  | ~w  |   ~w   |     ~w     |   ~w  ~n', \n           [L, M, Impl1, Antecedente, Formula]),\n    \n    fail. % Força backtracking para testar todas as combinações\n\ntabela_verdade :- \n    nl, write('Resultado: A fórmula é verdadeira em todas as linhas (TAUTOLOGIA)'), nl.\n\n% Predicados auxiliares para lógica booleana\nimplica(false, _, true).\nimplica(true, true, true).\nimplica(true, false, false).\n\nand_logic(true, true, true).\nand_logic(_, _, false).\n\n% ============================================================================\n% PARTE 4: PROVA POR CONTRADIÇÃO\n% ============================================================================\n\n% Verifica se a negação da fórmula é contraditória\nprova_contradicao :-\n    write('Prova por contradição:'), nl,\n    write('Assumindo que a fórmula é falsa...'), nl,\n    \n    % Negação: ((L(s) → M(s)) ∧ L(s)) ∧ ¬M(s)\n    write('Isso significa: ((L(s) → M(s)) ∧ L(s)) ∧ ¬M(s)'), nl,\n    \n    % Para que isso seja verdade, precisamos:\n    % 1. L(s) → M(s) seja verdade\n    % 2. L(s) seja verdade  \n    % 3. M(s) seja falso\n    \n    write('Para isso ser verdade, precisamos:'), nl,\n    write('1. L(s) → M(s) = verdade'), nl,\n    write('2. L(s) = verdade'), nl,\n    write('3. M(s) = falso'), nl,\n    \n    % Mas se L(s) é verdade e L(s) → M(s) é verdade,\n    % então M(s) deve ser verdade (modus ponens)\n    write('Mas se L(s) = verdade e L(s) → M(s) = verdade,'), nl,\n    write('então M(s) deve ser verdade (modus ponens)'), nl,\n    write('Contradição: M(s) não pode ser verdade e falso simultaneamente'), nl,\n    write('Portanto, a fórmula original é uma TAUTOLOGIA'), nl.\n\n% ============================================================================\n% PARTE 5: VERIFICAÇÃO EM FORMA NORMAL CONJUNTIVA\n% ============================================================================\n\n% Simulação da conversão para FNC da negação\nfnc_negacao :-\n    write('Forma Normal Conjuntiva da negação:'), nl,\n    write('¬[((L(s) → M(s)) ∧ L(s)) → M(s)]'), nl,\n    write('≡ ((L(s) → M(s)) ∧ L(s)) ∧ ¬M(s)'), nl,\n    write('≡ ((¬L(s) ∨ M(s)) ∧ L(s)) ∧ ¬M(s)'), nl,\n    write('≡ L(s) ∧ M(s) ∧ ¬M(s)'), nl,\n    write('Esta FNC contém a contradição M(s) ∧ ¬M(s)'), nl,\n    write('Logo, a fórmula original é uma TAUTOLOGIA'), nl.\n\n% ============================================================================\n% PARTE 6: PREDICADOS DE TESTE PRINCIPAL\n% ============================================================================\n\n% Executa todos os testes\nexecutar_todos_testes :-\n    write('=========================================='), nl,\n    write('VERIFICAÇÃO DE TAUTOLOGIA EM PROLOG'), nl,\n    write('=========================================='), nl, nl,\n    \n    teste_simba, nl,\n    tabela_verdade, nl,\n    prova_contradicao, nl,\n    fnc_negacao, nl,\n    \n    write('=========================================='), nl,\n    write('CONCLUSÃO: A inferência é logicamente válida'), nl,\n    write('=========================================='), nl.\n\n% Predicado conveniente para verificar a validade da regra\nverificar_regra_universal :-\n    write('Verificando regra universal:'), nl,\n    forall(leao(X), \n           (mamifero(X) -&gt; \n               format('✓ ~w é leão e é mamífero~n', [X]) ;\n               format('✗ ~w é leão mas não é mamífero~n', [X])\n           )).\n\n% ============================================================================\n% CONSULTAS DE EXEMPLO\n% ============================================================================\n\n% ?- executar_todos_testes.\n% ?- teste_simba.\n% ?- tabela_verdade.\n% ?- prova_contradicao.\n% ?- verificar_regra_universal.\n\n\n14.3.3.8 Questão 8\n\nModelagem:\n\n\nR1: \\(A \\vee B \\vee C\\);\n\nR2: \\(\\neg (A \\wedge B) \\equiv \\neg A \\vee \\neg B\\);\n\nR3: \\(C \\to A \\equiv \\neg C \\vee A\\).\n\n\nFNC: O conjunto de cláusulas é: \\(\\{(A \\vee B \\vee C), (\\neg A \\vee \\neg B), (\\neg C \\vee A)\\}\\)\nSatisfatibilidade: Sim, o conjunto é satisfatível. Precisamos encontrar uma atribuição de Verdadeiro/Falso para \\(A\\), \\(B\\), \\(C\\) que torne todas as cláusulas verdadeiras.\n\n\nVamos tentar \\(A=\\text{T}\\).\n\\(\\neg C \\vee \\text{T} \\equiv \\text{Verdadeiro}\\). OK.\n\\(\\neg \\text{T} \\vee \\neg B \\equiv \\neg B\\) precisa ser verdadeiro, então \\(B=\\text{F}\\).\n\\(\\text{T} \\vee \\text{F} \\vee C \\equiv \\text{Verdadeiro}\\). OK.\nSolução Válida: \\(A=\\text{T}\\), \\(B=\\text{F}\\), \\(C=\\text{F}\\) (Apenas Ana é alocada).\nOutra solução: \\(A=\\text{T}\\), \\(B=\\text{F}\\), \\(C=\\text{T}\\) (Ana e Carla são alocadas).\n\nEm Prolog:\n% Cláusulas\nclause1(A, B, C) :- A ; B ; C.\nclause2(A, B, _) :- \\+ A ; \\+ B.\nclause3(A, _, C) :- \\+ C ; A.\n\n% Verificar satisfatibilidade\nsatisfiable(A, B, C) :- clause1(A, B, C), clause2(A, B, _), clause3(A, _, C).\n\n% Testar satisfatibilidade\ntest_satisfiability :-\n    findall([A, B, C], (member(A, [true, false]), member(B, [true, false]), member(C, [true, false]), \n                        satisfiable(A, B, C)), Solutions),\n    (Solutions \\= [] -&gt;\n        write('Satisfatível. Soluções: '), write(Solutions), nl\n    ;   write('Insatisfatível'), nl).\n\n\n14.3.3.9 Questão 9\n\nFórmula: \\(\\forall x (P(x) \\to (\\exists y (Q(y) \\wedge R(x,y)))) \\vee \\exists z S(z)\\);\nEliminar Implicação: \\(\\forall x (\\neg P(x) \\vee \\exists y (Q(y) \\wedge R(x,y))) \\vee \\exists z S(z)\\);\nRenomear Variáveis: Para evitar conflitos, renomeamos \\(z\\) para \\(w\\) (pois \\(z\\) não depende de \\(x\\)).\n\\[\\forall x (\\neg P(x) \\vee \\exists y (Q(y) \\wedge R(x,y))) \\vee \\exists w S(w)\\]\nMover Quantificadores:\n\n\n\\(\\forall x \\exists y (\\neg P(x) \\vee (Q(y) \\wedge R(x,y))) \\vee \\exists w S(w)\\);\n\\(\\forall x \\exists y \\exists w (\\neg P(x) \\vee (Q(y) \\wedge R(x,y)) \\vee S(w))\\);\n\n\nFNP Final: \\(\\forall x \\exists y \\exists w ((\\neg P(x) \\vee (Q(y) \\wedge R(x,y))) \\vee S(w))\\).\n\nEm Prolog:\n% Definir predicados para um domínio finito\np(x1). p(x2).\nq(y1). q(y2).\nr(x1, y1). r(x2, y2).\ns(z1).\n\n% Fórmula: ∀x (¬P(x) ∨ ∃y (Q(y) ∧ R(x,y))) ∨ ∃z S(z)\nformula :-\n    (forall(member(X, [x1, x2]),\n            (\\+ p(X) ; exists(member(Y, [y1, y2]), (q(Y), r(X, Y)))))\n    ; exists(member(Z, [z1]), s(Z))).\n\n% Testar a fórmula\ntest_formula :-\n    (formula -&gt;\n        write('Fórmula é satisfatível no domínio dado'), nl\n    ;   write('Fórmula não é satisfatível no domínio dado'), nl).\n\n\n14.3.3.10 Questão 10\n\nCláusulas:\n\\(\\neg P \\vee \\neg Q \\vee R\\);\n\n\\(P \\vee R\\);\n\n\\(Q\\);\n\n\\(\\neg R\\).\nProva por Resolução:\n\n\nResolvendo (1) e (2) sobre \\(P\\): \\[(\\neg Q \\vee R \\vee R) \\equiv (\\neg Q \\vee R)\\] (Cláusula 5)\nResolvendo (5) e (3) sobre \\(Q\\): \\[(R)\\] (Cláusula 6)\nResolvendo (6) e (4) sobre \\(R\\): \\[\\square\\] (Cláusula Vazia)\nConclusão: Como derivamos a cláusula vazia, o conjunto original de cláusulas é inconsistente (insatisfatível).\n\n\nConexão com Prolog: É exatamente isso que o Prolog faz. Para provar uma consulta ?- g, ele adiciona \\(\\neg g\\) à base de conhecimento e tenta derivar uma contradição (cláusula vazia). Se conseguir, a consulta original é tida como verdadeira.\n\nEm Prolog:\n% Implementação do Princípio da Resolução em SWI-Prolog\n% Demonstração da inconsistência de um conjunto de cláusulas\n\n% ============================================================================\n% PARTE 1: REPRESENTAÇÃO DAS CLÁUSULAS\n% ============================================================================\n\n% Representamos cláusulas como listas de literais\n% Literal positivo: p, Literal negativo: neg(p)\n% Cláusula vazia: []\n\n% Conjunto original de cláusulas\nclausula(1, [neg(p), neg(q), r]).     % ¬P ∨ ¬Q ∨ R\nclausula(2, [p, r]).                  % P ∨ R  \nclausula(3, [q]).                     % Q\nclausula(4, [neg(r)]).                % ¬R\n\n% ============================================================================\n% PARTE 2: ALGORITMO DE RESOLUÇÃO\n% ============================================================================\n\n% Predicado principal para resolver duas cláusulas\nresolver_clausulas(C1, C2, Resolvente) :-\n    clausula(C1, Lista1),\n    clausula(C2, Lista2),\n    resolucao(Lista1, Lista2, Resolvente).\n\n% Encontra literais complementares e resolve\nresolucao(Lista1, Lista2, Resolvente) :-\n    % Encontra um literal L em Lista1 \n    member(L, Lista1),\n    % Encontra seu complemento em Lista2\n    complemento(L, CompL),\n    member(CompL, Lista2),\n    % Remove os literais complementares e une as listas\n    select(L, Lista1, Resto1),\n    select(CompL, Lista2, Resto2),\n    append(Resto1, Resto2, Temp),\n    % Remove duplicatas e simplifica\n    sort(Temp, Resolvente).\n\n% Define literais complementares\ncomplemento(X, neg(X)) :- \\+ functor(X, neg, 1).\ncomplemento(neg(X), X).\n\n% ============================================================================\n% PARTE 3: PROCESSO DE PROVA PASSO A PASSO\n% ============================================================================\n\n% Executa a prova completa do exemplo\nprova_resolucao :-\n    write('PROVA POR RESOLUÇÃO'), nl,\n    write('=================='), nl, nl,\n    \n    % Mostra cláusulas originais\n    write('Cláusulas originais:'), nl,\n    mostrar_clausula(1),\n    mostrar_clausula(2),\n    mostrar_clausula(3),\n    mostrar_clausula(4), nl,\n    \n    % Passo 1: Resolver (1) e (2) sobre P\n    write('Passo 1: Resolvendo cláusulas (1) e (2) sobre P'), nl,\n    resolver_clausulas(1, 2, C5),\n    format('Resultado: ~w~n', [C5]),\n    assert(clausula(5, C5)), nl,\n    \n    % Passo 2: Resolver (5) e (3) sobre Q  \n    write('Passo 2: Resolvendo resultado anterior com (3) sobre Q'), nl,\n    resolucao(C5, [q], C6),\n    format('Resultado: ~w~n', [C6]),\n    assert(clausula(6, C6)), nl,\n    \n    % Passo 3: Resolver (6) e (4) sobre R\n    write('Passo 3: Resolvendo resultado anterior com (4) sobre R'), nl,\n    resolucao(C6, [neg(r)], Vazia),\n    format('Resultado: ~w~n', [Vazia]),\n    \n    % Verifica se obtivemos a cláusula vazia\n    (Vazia = [] -&gt;\n        (nl, write('✓ CLÁUSULA VAZIA DERIVADA!'), nl,\n         write('✓ O conjunto de cláusulas é INCONSISTENTE'), nl) ;\n        (write('✗ Não foi possível derivar a cláusula vazia'), nl)\n    ).\n\n% Predicado auxiliar para mostrar cláusulas formatadas\nmostrar_clausula(N) :-\n    clausula(N, Lista),\n    format('(~w) ~w~n', [N, Lista]).\n\n% ============================================================================\n% PARTE 4: SIMULAÇÃO DO FUNCIONAMENTO INTERNO DO PROLOG\n% ============================================================================\n\n% Base de conhecimento de exemplo baseada nas cláusulas\n% Convertendo para cláusulas de Horn (apenas para demonstração)\n\n% Da cláusula (1): ¬P ∨ ¬Q ∨ R  ===&gt;  R :- P, Q\nregra_r :- p, q.\n\n% Da cláusula (2): P ∨ R  ===&gt;  Se não podemos provar R, então P\n% (Esta não é uma cláusula de Horn diretamente)\n\n% Da cláusula (3): Q é um fato\nq.\n\n% Para demonstrar a inconsistência, vamos negar R e tentar prová-lo\ndemonstrar_inconsistencia_prolog :-\n    write('DEMONSTRAÇÃO DA INCONSISTÊNCIA VIA PROLOG'), nl,\n    write('=========================================='), nl, nl,\n    \n    write('Base de conhecimento:'), nl,\n    write('- q (fato)'), nl,\n    write('- r :- p, q (regra)'), nl,\n    write('- Tentando provar ¬r'), nl, nl,\n    \n    write('Para provar ¬r, o Prolog adiciona r à base e busca contradição:'), nl,\n    \n    % Simula o processo de resolução do Prolog\n    (q -&gt;\n        write('✓ q é verdadeiro') ; \n        write('✗ q é falso')\n    ), nl,\n    \n    write('Se assumirmos p verdadeiro:'), nl,\n    write('- De \"r :- p, q\" e sabendo que p e q são verdadeiros'), nl,\n    write('- Podemos inferir r'), nl,\n    write('- Mas isso contradiz nossa tentativa de provar ¬r'), nl,\n    write('- Logo, a suposição inicial leva à contradição'), nl.\n\n% ============================================================================\n% PARTE 5: ALGORITMO GERAL DE RESOLUÇÃO\n% ============================================================================\n\n% Implementação mais geral do algoritmo de resolução\nresolucao_geral(Clausulas, Resultado) :-\n    resolucao_loop(Clausulas, [], Resultado).\n\n% Loop principal do algoritmo\nresolucao_loop(Clausulas, Derivadas, inconsistente) :-\n    % Tenta encontrar duas cláusulas que podem ser resolvidas\n    member(C1, Clausulas),\n    member(C2, Clausulas),\n    C1 \\= C2,\n    resolucao(C1, C2, Nova),\n    \n    % Se derivamos a cláusula vazia, temos inconsistência\n    (Nova = [] -&gt;\n        true\n    ;\n        % Senão, adiciona a nova cláusula e continua\n        \\+ member(Nova, Clausulas),\n        \\+ member(Nova, Derivadas),\n        append(Clausulas, [Nova], NovasClausulas),\n        resolucao_loop(NovasClausulas, [Nova|Derivadas], inconsistente)\n    ).\n\nresolucao_loop(_, _, satisfativel).\n\n% ============================================================================\n% PARTE 6: TESTES E VERIFICAÇÕES\n% ============================================================================\n\n% Teste do algoritmo com o exemplo dado\ntestar_exemplo :-\n    write('TESTE DO ALGORITMO DE RESOLUÇÃO'), nl,\n    write('==============================='), nl, nl,\n    \n    % Coleta todas as cláusulas originais\n    findall(C, (clausula(N, C), N =&lt; 4), Clausulas),\n    write('Testando conjunto de cláusulas: '), nl,\n    forall(member(C, Clausulas), \n           format('  ~w~n', [C])\n    ), nl,\n    \n    % Aplica o algoritmo\n    resolucao_geral(Clausulas, Resultado),\n    format('Resultado: ~w~n', [Resultado]).\n\n% Teste com conjunto satisfatível\ntestar_satisfativel :-\n    write('TESTE COM CONJUNTO SATISFATÍVEL'), nl,\n    write('==============================='), nl,\n    \n    % Um conjunto que não leva à contradição\n    ClausulasSat = [[p], [neg(p), q], [neg(q), r]],\n    write('Cláusulas: '), nl,\n    forall(member(C, ClausulasSat), \n           format('  ~w~n', [C])\n    ), nl,\n    \n    resolucao_geral(ClausulasSat, Resultado),\n    format('Resultado: ~w~n', [Resultado]).\n\n% ============================================================================\n% PARTE 7: PREDICADOS PRINCIPAIS DE EXECUÇÃO\n% ============================================================================\n\n% Executa todas as demonstrações\nexecutar_resolucao :-\n    write('PRINCÍPIO DA RESOLUÇÃO - DEMONSTRAÇÃO COMPLETA'), nl,\n    write('=============================================='), nl, nl,\n    \n    prova_resolucao, nl,\n    demonstrar_inconsistencia_prolog, nl,\n    testar_exemplo, nl,\n    testar_satisfativel, nl,\n    \n    write('=============================================='), nl,\n    write('CONCLUSÃO: O Princípio da Resolução é a base'), nl,\n    write('do mecanismo de inferência do Prolog'), nl,\n    write('=============================================='), nl.\n\n% Limpa cláusulas derivadas para novo teste\nlimpar_clausulas :-\n    retractall(clausula(N, _)),\n    % Reestabelece cláusulas originais\n    assert(clausula(1, [neg(p), neg(q), r])),\n    assert(clausula(2, [p, r])),\n    assert(clausula(3, [q])),\n    assert(clausula(4, [neg(r)])).\n\n% ============================================================================\n% CONSULTAS DE EXEMPLO\n% ============================================================================\n\n% ?- executar_resolucao.\n% ?- prova_resolucao.\n% ?- testar_exemplo.\n% ?- limpar_clausulas.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Solução dos Exercícios</span>"
    ]
  }
]