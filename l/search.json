[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Programação Lógica",
    "section": "",
    "text": "1 Apresentação\nA Programação Lógica representa um paradigma fundamental na ciência da computação que tem suas raízes profundamente entrelaçadas com os princípios da lógica matemática e filosófica. Como Marvin Minsky observou, “Logic programming is the future of artificial intelligence”, destacando a importância central deste campo para o desenvolvimento de sistemas inteligentes.\nEste livro convida você a uma jornada através dos fundamentos da lógica e sua aplicação computacional, explorando desde os conceitos básicos da Lógica Proposicional até as aplicações mais avançadas em verificação formal de programas e inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#estrutura-do-livro",
    "href": "index.html#estrutura-do-livro",
    "title": "Introdução à Programação Lógica",
    "section": "1.1 Estrutura do Livro",
    "text": "1.1 Estrutura do Livro\nA obra está organizada em duas partes principais:\nParte I - Fundamentos da Lógica: Apresenta os conceitos fundamentais necessários para compreender a programação lógica, incluindo Lógica Proposicional, técnicas de prova, lógica predicativa e quantificadores.\nParte II - Aplicações Avançadas: Explora as aplicações práticas dos conceitos fundamentais, incluindo formas normais, construção de mundos lógicos, cláusulas de Horn, Prolog, verificação formal e desafios lógicos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#público-alvo",
    "href": "index.html#público-alvo",
    "title": "Introdução à Programação Lógica",
    "section": "1.2 Público-Alvo",
    "text": "1.2 Público-Alvo\nEste material foi desenvolvido para estudantes de ciência da computação, engenharia de software, matemática aplicada e profissionais interessados em compreender os fundamentos teóricos que sustentam muitas das tecnologias modernas de inteligência artificial e sistemas de inferência.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "index.html#metodologia",
    "href": "index.html#metodologia",
    "title": "Introdução à Programação Lógica",
    "section": "1.3 Metodologia",
    "text": "1.3 Metodologia\nCada capítulo combina teoria rigorosa com exemplos práticos e exercícios, permitindo ao leitor não apenas compreender os conceitos, mas também aplicá-los na resolução de problemas reais. O texto progride de forma gradual, construindo conhecimento de maneira incremental e sempre conectando novos conceitos aos já estabelecidos.\nEsperamos que esta jornada pela programação lógica seja tanto educativa quanto inspiradora, fornecendo as bases sólidas necessárias para explorar as fronteiras da computação e da inteligência artificial.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "01-jornada-programacao-logica.html",
    "href": "01-jornada-programacao-logica.html",
    "title": "2  Introdução ao Paradigma da Programação Lógica",
    "section": "",
    "text": "Tip\n\n\n\nEstá sem tempo? Leia o Expresso.\n\n\nImagine, por um momento, que estamos explorando o universo dos computadores, mas em vez de sermos os comandantes, capazes de ditar todos os passos do caminho, nós fornecemos as diretrizes gerais e deixamos que o computador deduza o caminho. Pode parecer estranho para quem está envolvido com as linguagens do Paradigma Imperativo. Acredite ou não, isso é exatamente o que a Programação Lógica faz.\nEm vez de sermos forçados a ordenar cada detalhe do processo de solução de um problema, a Programação Lógica permite que declaremos o que queremos, e então deixemos o computador fazer o trabalho de encontrar os detalhes e processos necessários para resolver cada problema.\nNa Programação Imperativa partimos de uma determinada expressão e seguimos um conjunto de instruções até encontrar o resultado desejado. O programador fornece um conjunto de instruções que definem o fluxo de controle e modificam o estado da máquina a cada passo. O foco está em como o problema deve ser resolvido. Exemplos de linguagens imperativas incluem C++, Java e Python. Todas hoje são amplamente utilizadas e multiparadigmas, mas não são as únicas disponíveis. A Programação Imperativa é como um chef que segue uma receita passo a passo, onde cada etapa é crucial para o resultado final.\nNa Programação Declarativa, o programador fornece uma descrição lógica ou funcional, do que deve ser feito, sem especificar o fluxo de controle. O foco está no problema, não na solução. Exemplos incluem SQL, Prolog e Haskell. Na Programação Lógica, partimos de um objetivo (goal), quase como se fosse a prova de uma hipótese e, de acordo com um conjunto específico de regras, tentamos construir uma prova para esta hipótese.\nNa Programação Lógica, um dos paradigmas da Programação Declarativa, usamos a dedução para resolver problemas. Começamos com hipóteses e conjecturas.\nUma hipótese é uma suposição, expressa na forma de proposição, que é acreditada ser verdadeira, mas que ainda não foi provada. Uma conjectura, por sua vez, é uma proposição ou sentença declarativa assumida como verdadeira, mas que ainda não foi formalmente provada ou refutada. Com um pouco mais de formalidade, já que a formalidade é o combustível da lógica, podemos dizer:\nConjectura é uma proposição provisoriamente aceita como verdadeira com base em evidências incompletas ou raciocínio plausível, mas que ainda não foi provada ou refutada. É essencialmente uma suposição educada que serve como ponto de partida para investigação posterior. Conjecturas são frequentemente formuladas quando há padrões observáveis ou intuições teóricas, mas falta rigor demonstrativo. A conjetura de Goldbach, que afirma que todo número par maior que \\(2\\) pode ser expresso como a soma de dois números primos, é um exemplo clássico de conjectura. Embora muitos números pares tenham sido verificados e a conjectura pareça verdadeira, ainda não foi provada para todos os números pares.\nHipótese é uma proposição formulada de maneira mais sistemática e específica, que pode ser testada através de métodos empíricos ou dedutivos. Uma hipótese deve ser formulada de modo que seja possível, em princípio, confirmá-la ou refutá-la através de evidências ou procedimentos lógicos específicos. Por exemplo, a hipótese de que “a temperatura afeta a taxa de crescimento das plantas” pode ser testada através de experimentos controlados. Se os resultados do experimento confirmarem a relação entre temperatura e crescimento, a hipótese é apoiada; caso contrário, ela pode ser refutada ou modificada.\nNa Lógica de Primeira Ordem, conjecturas são expressas como fórmulas lógicas que precisam ser verificadas por meio de demonstrações ou contraexemplos. Por exemplo, considere a conjectura: “Todos os números primos são ímpares.” Em Lógica de Primeira Ordem, isso pode ser expresso como:\n\\[\n\\forall x (\\text{Primo}(x) \\rightarrow \\text{Ímpar}(x))\n\\]\nEssa conjectura pode ser refutada pelo contraexemplo do número 2, que é primo, mas não ímpar. Outro exemplo seria: “Todo ser humano é mortal,” expresso como:\n\\[\n\\forall x (\\text{Humano}(x) \\rightarrow \\text{Mortal}(x))\n\\]\nEssa conjectura pode ser considerada verdadeira em muitos contextos, mas requer verificação formal para ser aceita como teorema. Para testar a verdade expressa nessas sentenças, usaremos as ferramentas da Lógica de Primeira Ordem.\n Em resumo: programação imperativa focada no processo, no como chegar à solução; Programação Declarativa focada no problema em si, no o que precisa ser feito. Eu, sempre que posso, escolho uma linguagem descritiva. Não há glória, nem honra nesta escolha: apenas as lamúrias da opinião pessoal.\nSua escolha, pessoal e intransferível, entre estes paradigmas dependerá da aplicação que será construída, tanto quanto dependerá do estilo do programador. Contudo, o futuro parece cada vez mais orientado para linguagens declarativas, que permitam ao programador concentrar-se no problema, não nos detalhes da solução. Efeito que parece ser evidente se considerarmos os avanços da segunda década no século XXI no campo da Inteligência Artificial. Este documento contém a base matemática que suporta o entendimento da programação lógica e um pouco de Prolog, como linguagem de programação para solução de problemas. Será uma longa jornada.\nEm nossa jornada, percorreremos a Lógica de Primeira Ordem. Esta será a nossa primeira rota, que iremos subdividir em elementos interligados e interdependentes e, sem dúvida, de mesma importância e valor: a Lógica Proposicional e a lógica Predicativa. Não deixe de notar que muitos dos nossos companheiros de viagem, aqueles restritos à formalidade acadêmica, podem não entender as sutilezas desta divisão.\nEste timoneiro tenta não ser pretensioso. Partiremos da Lógica Proposicional com esperança de encontrar bons ventos que nos levem até o Prolog.\nA Lógica Proposicional é um tipo de linguagem matemática, suficientemente rica para expressar os problemas que precisamos resolver e suficientemente simples para que computadores possam lidar com ela. Quando esta ferramenta estiver conhecida mergulharemos na alma da Lógica de Primeira Ordem, a Lógica Predicativa, ou Lógica de Predicados, e então poderemos fazer sentido do mundo real de forma clara e bela.\nVamos enfrentar a inferência e a dedução, duas ferramentas fundamentais para extrair conhecimento de declarações lógicas. Imagine um detetive investigando um caso: ele coleta pistas, como pegadas no local do crime, uma testemunha que viu um suspeito de capa preta e a informação de que o crime ocorreu à noite. A inferência é como o processo que o detetive usa para conectar essas pistas. Para chegar a uma conclusão lógica. Por exemplo, se ele sabe que “toda pessoa de capa preta estava no evento à noite” e que “o crime aconteceu no evento à noite”, ele pode inferir que “o suspeito de capa preta é uma pessoa que pode ter cometido o crime”.\nNa Lógica de Primeira Ordem, esse processo é formalizado. Considere as seguintes declarações lógicas como nossas “pistas”:\n\nPremissa 1: Todo ser humano é mortal ((x ((x) (x)))).\nPremissa 2: Sócrates é humano ((())).\n\nUsando a inferência lógica, podemos deduzir que Sócrates é mortal ((())). Aqui, as premissas são as “pistas”, e a inferência é o raciocínio que nos leva à conclusão. Esse processo é incontestável na lógica: se as premissas são verdadeiras, a conclusão também será. Assim, a inferência nos permite extrair verdades novas a partir de verdades conhecidas, de forma clara e estruturada, como um detetive que resolve o caso sem deixar margem para dúvidas.\nNossos mares não serão brandos, mas não nos furtaremos a enfrentar os desafios da Cláusula de Horn, um conceito um pouco mais estranho. Uma restrição sintática sobre as cláusulas de uma fórmula lógica que torna o problema de satisfatibilidade mais fácil de resolver. Como um mapa que, se seguido corretamente, reduz a complexidade computacional de exponencial para polinomial. Muito mais simples, até mesmo passível de automatização eficiente através de algoritmos como unit propagation.\nAs águas se agitarão um pouco mais quando cruzarmos o território da satisfatibilidade, o problema central que governa toda a Lógica Proposicional. A questão fundamental de determinar se existe uma atribuição de valores de verdade que torna uma fórmula lógica verdadeira. Como um detetive que busca descobrir se uma combinação específica de pistas pode resolver completamente um mistério. Este problema, aparentemente simples em sua formulação, revela-se NP-completo, uma classe de problemas para os quais não se conhece algoritmo de tempo polinomial. Desafiando os limites da computação eficiente e impulsionando o desenvolvimento de algoritmos sofisticados como DPLL e CDCL.\n\n\n\n\n\n\nNote\n\n\n\nDPLL (Davis-Putnam-Logemann-Loveland) é um algoritmo clássico para resolver o problema SAT (satisfatibilidade) que utiliza backtracking sistemático. O algoritmo funciona atribuindo valores às variáveis de forma incremental e, quando encontra uma contradição, retrocede para explorar outras possibilidades. Incorpora otimizações como unit propagation (propagação de literais unitários) e pure literal elimination (eliminação de literais puros).\nCDCL (Conflict-Driven Clause Learning) representa a evolução moderna do DPLL. Quando o algoritmo encontra um conflito durante a busca, ao invés de simplesmente retroceder, ele analisa as causas do conflito e aprende uma nova cláusula que previne a repetição do mesmo erro. Essa capacidade de aprendizado, combinada com heurísticas sofisticadas para escolha de variáveis e níveis de backtrack não cronológico, torna o CDCL significativamente mais eficiente que o DPLL tradicional em instâncias práticas complexas.\n\n\nNo final do dia, cansados, porém felizes, vamos entender que, desde os tempos de Gödel, Turing e Church, tudo que queremos é que nossas máquinas sejam capazes de resolver problemas complexos com o mínimo de interferência nossa. Queremos que elas pensem, ou pelo menos, que simulem o pensamento. Aqui, neste objetivo, entre as pérolas mais reluzentes da evolução humana destaca-se a Programação Lógica.\nComo diria Newton podemos olhar tão longe porque nos apoiamos nos ombros de gigantes. Assim, precisamos visitar a história para entender como chegamos até aqui.\nO termo Programação Lógica aparece em meados dos anos 1970 como uma evolução dos esforços nas pesquisas sobre a prova computacional de teoremas matemáticos e Inteligência Artificial. O homem querendo fazer máquinas capazes de raciocinar como o homem. Deste esforço surgiu a esperança de que poderíamos usar a lógica como uma linguagem de programação, em inglês, programming in logic, ou Prolog. Aqui está a base deste conhecimento.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao Paradigma da Programação Lógica</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html",
    "href": "01a-introducao-prolog.html",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "",
    "text": "3.1 O que é Prolog?\nO Prolog (Programming in Logic) é uma linguagem de programação declarativa baseada na lógica de primeira ordem e no princípio de resolução SLD (Selective Linear Definite clause resolution). Desenvolvida por Alain Colmerauer e Philippe Roussel na Universidade de Marselha em 1972, representa um paradigma fundamentalmente diferente das linguagens imperativas tradicionais.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#o-que-é-prolog",
    "href": "01a-introducao-prolog.html#o-que-é-prolog",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "",
    "text": "3.1.1 Paradigma Declarativo vs. Imperativo\nEm linguagens imperativas (C, Java, Python), o programador especifica como resolver um problema através de uma sequência de comandos que modificam o estado do programa. Em Prolog, o programador especifica o que constitui uma solução através de:\n\nFatos: Afirmações básicas sobre o domínio do problema\nRegras: Relações lógicas entre fatos\nConsultas: Perguntas sobre o que pode ser deduzido\n\nO interpretador Prolog utiliza um mecanismo de inferência baseado em resolução e backtracking para encontrar provas construtivas, isto é, não apenas determina se uma afirmação é verdadeira, mas também fornece os valores das variáveis que a tornam verdadeira.\n\n\n3.1.2 Fundamentos Teóricos\nO Prolog baseia-se na correspondência entre:\n\nLógica de primeira ordem → Expressividade para representar conhecimento;\nCláusulas de Horn → Subconjunto da lógica de primeira ordem que permite um mecanismo de prova eficiente;\nPrincípio de resolução → Método de prova por refutação;\nMundo fechado (Closed World Assumption) → O que não pode ser provado é falso.\n\nPara nossos propósitos práticos, utilizaremos o SWISH, uma interface web que implementa o interpretador SWI-Prolog.\nO SWISH (SWI-Prolog for SHaring)é uma plataforma online que permite executar código Prolog diretamente no navegador, sem necessidade de instalação. Existem vários servidores gratuitos na internet com recursos disponíveis, como compartilhamento de código, colaboração em tempo real e uma interface amigável para iniciantes. Eu uso o SWI. Este servidor é mantido pela comunidade SWI-Prolog, é gratuito e quase sempre está disponível.\n\n\n3.1.3 Como Acessar o SWISH.SWI-Prolog\n\nVá para: https://swish.swi-prolog.org/\nClique em “Create a program” para criar um novo programa\nVocê verá uma interface dividida em duas partes:\n\nLado esquerdo: Editor de código no qual você escreve fatos e regras;\nLado direito: Console de consultas no qual você faz perguntas (consultas) ao Prolog.\n\n\nEste ambiente pode ser visto na Figure 3.1.\n\n\n\n\n\n\nScreenshot do SWISH\n\n\n\n\nFigure 3.1: Página padrão do Swish-swi-prolog.org com o editor de código à esquerda e o console de consultas à direita.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#estrutura-básica-do-prolog-cláusulas-de-horn",
    "href": "01a-introducao-prolog.html#estrutura-básica-do-prolog-cláusulas-de-horn",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.2 Estrutura Básica do Prolog: Cláusulas de Horn",
    "text": "3.2 Estrutura Básica do Prolog: Cláusulas de Horn\nO Prolog trabalha exclusivamente com cláusulas de Horn, uma forma restrita de fórmulas lógicas que possuem no máximo um literal positivo. Esta restrição garante a decidibilidade e eficiência do processo de inferência.\n\n3.2.1 Fatos (Cláusulas Unitárias)\nFatos são cláusulas de Horn unitárias da forma \\(P(t_1, t_2, ..., t_n)\\), onde \\(P\\) é um predicado e \\(t_i\\) são termos. Representam conhecimento básico incondicional sobre o domínio:\n% Predicados unários\nmamifero(gato).\nmamifero(cachorro).\n\n% Predicados binários (relações)\nmaior_que(5, 3).\npai(joao, pedro).\n\n% Predicados n-ários\ndistancia(sao_paulo, rio_janeiro, 400).\nInterpretação formal: Cada fato \\(P(a_1, ..., a_n)\\) é interpretado como “é verdade que \\(P(a_1, ..., a_n)\\)” no modelo mínimo de Herbrand.\n\n\n3.2.2 Regras (Cláusulas Definidas)\nRegras são cláusulas de Horn definidas da forma \\(H \\leftarrow B_1 \\land B_2 \\land ... \\land B_n\\), representadas como H :- B1, B2, ..., Bn. onde:\n\n\\(H\\) (cabeça): Consequente da implicação;\n\\(B_i\\) (corpo): Antecedentes que devem ser satisfeitos;\n\\(\\leftarrow\\): Implicação reversa (“se”);\n\\(\\land\\): Conjunção lógica (vírgula em Prolog).\n\n% Regra simples: ∀X (mamifero(X) → animal(X))\nanimal(X) :- mamifero(X).\n\n% Regra composta: ∀X (voa(X) → ave(X) ∧ ¬pinguim(X))\nvoa(X) :- ave(X), \\+ pinguim(X).\n\n% Regra recursiva: ancestral\nancestral(X, Y) :- pai(X, Y).\nancestral(X, Z) :- pai(X, Y), ancestral(Y, Z).\nSemântica operacional: Para provar \\(H\\), o interpretador deve provar todos os \\(B_i\\) do corpo.\n\n\n3.2.3 Consultas (Goals)\nConsultas são cláusulas de Horn negativas da forma \\(\\leftarrow B_1 \\land B_2 \\land ... \\land B_n\\), representadas como ?- B1, B2, ..., Bn. O interpretador tenta encontrar uma refutação da negação da consulta.\n% Consulta ground (sem variáveis)\n?- mamifero(gato).\n% Resposta: true/false\n\n% Consulta com variáveis livres\n?- animal(X).\n% Resposta: substituições que tornam a consulta verdadeira\n\n% Consulta conjuntiva\n?- pai(X, Y), mae(Z, Y).\n% Encontra todos os X, Y, Z que satisfazem ambas as condições\nProcesso de resolução: O Prolog utiliza o algoritmo SLD-resolution para encontrar uma derivação vazia, provando a consulta por contradição.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#sintaxe-e-semântica-formal",
    "href": "01a-introducao-prolog.html#sintaxe-e-semântica-formal",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.3 Sintaxe e Semântica Formal",
    "text": "3.3 Sintaxe e Semântica Formal\n\n3.3.1 Termos e Estruturas de Dados\nO Prolog trabalha com uma hierarquia bem definida de termos:\n\n3.3.1.1 Termos Simples\n\nÁtomos: constantes simbólicas → joao, nil, [];\nNúmeros: inteiros e reais → 42, 3.14159, -273;\nVariáveis: começam com maiúscula → X, Lista, _Temp;\n\n_ = variável anônima, usada como um marcador de posição para um valor que não é relevante para o resto da cláusula.\n\n\n\n\n3.3.1.2 Termos Compostos\n\nEstruturas: functor(arg1, arg2, ..., argN);\nListas: [H|T] onde H é cabeça e T é cauda;\nStrings: \"texto\" (lista de códigos ASCII).\n\n% Estruturas complexas\npessoa(nome(joao, silva), idade(25), endereco(rua(x), numero(123))).\n\n% Listas\nlista_vazia([]).\nlista_numeros([1, 2, 3, 4]).\nlista_aninhada([[a, b], [c, d], [e]]).\n\n\n\n3.3.2 Operadores e Conectivos Lógicos\n\n3.3.2.1 Conectivos Básicos\n% Conjunção (∧): vírgula\nregra(X) :- condicao1(X), condicao2(X).\n\n% Disjunção (∨): múltiplas cláusulas\nopcao(X) :- caminho1(X).\nopcao(X) :- caminho2(X).\n% Equivale a: opcao(X) ← caminho1(X) ∨ caminho2(X)\n\n\n3.3.2.2 Negação por Falha (\\+)\n% NAF (Negation as Failure) - não é negação clássica!\nvoa(X) :- ave(X), \\+ pinguim(X).\n% Lê-se: \"X voa se X é ave E não pode ser provado que X é pinguim\"\n\n% CUIDADO: \\+ é não-monotônica\n% Se pinguim(tweety) for adicionado depois, voa(tweety) muda de true para false\n\n\n3.3.2.3 Operadores de Comparação\n% Unificação\nX = Y          % X unifica com Y\nX \\= Y         % X não unifica com Y\n\n% Comparação aritmética (após avaliação)\nX =:= Y        % X é aritmeticamente igual a Y\nX =\\= Y        % X é aritmeticamente diferente de Y\nX &lt; Y, X &gt; Y   % Comparações numéricas\nX =&lt; Y, X &gt;= Y\n\n% Comparação de termos (ordem lexicográfica)\nX == Y         % X é idêntico a Y\nX \\== Y        % X não é idêntico a Y\nX @&lt; Y, X @&gt; Y % Comparação de termos\n\n\n\n3.3.3 Comentários\n% Comentário de linha única\n\n/* Comentário\n   de múltiplas\n   linhas */",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#unificação-o-coração-do-prolog",
    "href": "01a-introducao-prolog.html#unificação-o-coração-do-prolog",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.4 Unificação: O Coração do Prolog",
    "text": "3.4 Unificação: O Coração do Prolog\nUnificação é o processo de encontrar substituições que tornam dois termos sintaticamente idênticos. É o mecanismo fundamental para:\n\nPassagem de parâmetros;\nPattern matching;\nResolução de consultas.\n\n\n3.4.1 Algoritmo de Unificação (Robinson, 1965)\nDados termos \\(s\\) e \\(t\\), a unificação encontra o unificador mais geral (MGU) \\(\\theta\\) tal que \\(s\\theta = t\\theta\\).\n% Casos básicos\n?- X = joao.           % X ← joao\n?- f(X, Y) = f(a, b).  % X ← a, Y ← b\n?- [H|T] = [1,2,3].    % H ← 1, T ← [2,3]\n\n% Unificação recursiva\n?- pessoa(nome(X), idade(Y)) = pessoa(nome(joao), idade(25)).\n% X ← joao, Y ← 25\n\n% Falha de unificação\n?- f(a) = g(a).        % false (functors diferentes)\n?- f(a, b) = f(a).     % false (aridades diferentes)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#backtracking-e-espaço-de-busca",
    "href": "01a-introducao-prolog.html#backtracking-e-espaço-de-busca",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.5 Backtracking e Espaço de Busca",
    "text": "3.5 Backtracking e Espaço de Busca\nBacktracking é a estratégia de busca sistemática que o Prolog usa para explorar todas as possíveis derivações. Implementa uma busca em profundidade com retrocesso.\n\n3.5.1 Mecanismo de Escolha e Retrocesso\n% Base de dados\ngosta(maria, comida, pizza).\ngosta(maria, comida, sushi).\ngosta(joao, comida, pizza).\ngosta(joao, bebida, cerveja).\n\nsaida(X, Y) :- gosta(X, comida, Y).\nsaida(X, Y) :- gosta(X, bebida, Y).\nTrace da consulta ?- saida(maria, X).:\n\nPonto de escolha: primeira cláusula de saida/2;\nUnificação: saida(maria, X) com saida(X, Y) :- gosta(X, comida, Y)\n\nX ← maria, Y ← X (variável da consulta);\n\nNova meta: gosta(maria, comida, X);\nPrimeira solução: X ← pizza;\nBacktrack (se solicitado): tenta próxima solução;\nSegunda solução: X ← sushi;\nBacktrack: tenta segunda cláusula de saida/2;\nNova meta: gosta(maria, bebida, X) → falha.\n\n\n\n3.5.2 Cut (!) - Controle de Backtracking\n% Sem cut - busca exaustiva\nmax_sem_cut(X, Y, X) :- X &gt;= Y.\nmax_sem_cut(X, Y, Y) :- Y &gt; X.\n\n% Com cut - determinístico\nmax_com_cut(X, Y, X) :- X &gt;= Y, !.\nmax_com_cut(X, Y, Y).\n\n% Green cut vs Red cut\ndeterministico(X) :- condicao(X), !.  % Green cut (não muda semântica)\ndeterministico(X) :- alternativa(X).\n\nperigoso(X) :- condicao1(X), !, acao_perigosa(X).  % Red cut (muda semântica)\nperigoso(X) :- condicao2(X).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#resolução-sld-e-árvores-de-prova",
    "href": "01a-introducao-prolog.html#resolução-sld-e-árvores-de-prova",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.6 Resolução SLD e Árvores de Prova",
    "text": "3.6 Resolução SLD e Árvores de Prova\n\n3.6.1 Processo de Resolução\nO Prolog implementa SLD-resolution (Selective Linear Definite clause resolution):\n\nSelecionar literal do goal atual\nUnificar com cabeça de uma cláusula\nResolver substituindo o literal pelo corpo da cláusula\nRepetir até goal vazio (sucesso) ou falha\n\n\n\n3.6.2 Árvore de Derivação SLD\nPara a consulta ?- ancestral(joao, X). com programa:\nancestral(X, Y) :- pai(X, Y).\nancestral(X, Z) :- pai(X, Y), ancestral(Y, Z).\npai(joao, pedro).\npai(pedro, ana).\n?- ancestral(joao, X)\n├─ (regra 1) pai(joao, X) ──→ X=pedro \n└─ (regra 2) pai(joao, Y), ancestral(Y, X)\n   └─ Y=pedro, ancestral(pedro, X)\n      ├─ (regra 1) pai(pedro, X) ──→ X=ana \n      └─ (regra 2) pai(pedro, Z), ancestral(Z, X) ──→ falha\n\n\n3.6.3 Complexidade e Limitações\n\nDecidibilidade: Programas Prolog podem não terminar;\nCompletude: SLD-resolution é completa para cláusulas de Horn;\nComplexidade: Exponencial no pior caso (backtracking);\nOrdem das cláusulas: Afeta eficiência e terminação.\n\n% Programa que não termina\nloop(X) :- loop(X).\n\n% Solução: reordenar para casos base primeiro\nfatorial(0, 1) :- !.\nfatorial(N, F) :- N &gt; 0, N1 is N-1, fatorial(N1, F1), F is N * F1.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#executando-código-no-swish",
    "href": "01a-introducao-prolog.html#executando-código-no-swish",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.7 Executando Código no SWISH",
    "text": "3.7 Executando Código no SWISH\n\n3.7.1 Passo 1: Escrever o Programa\nEm um arquivo novo, no editor (lado esquerdo), digite fatos e regras:\n% Base de conhecimento sobre família\npai(joao, pedro).\npai(pedro, ana).\nmae(maria, pedro).\nmae(ana, carlos).\n\n% Regra para definir genitor\ngenitor(X, Y) :- pai(X, Y).\ngenitor(X, Y) :- mae(X, Y).\n\n% Regra para definir avô\navo(X, Z) :- genitor(X, Y), genitor(Y, Z).\n\n\n3.7.2 Passo 2: Salvar e Carregar\n\nPara salvar um programa, você precisa estar logado no SWISH. Pode logar com o sua conta do Google ou com o StackOverflow.\nClique no menu File/Save para salvar o programa\nUma vez salvo, o programa é automaticamente carregado na memória do Prolog\n\n\n\n3.7.3 Passo 3: Fazer Consultas\nNo console (lado direito), digite consultas:\n?- pai(joao, pedro).\nResposta esperada: true.\n?- genitor(X, pedro).\nResposta esperada: X = joao ; X = maria.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#interpretando-respostas",
    "href": "01a-introducao-prolog.html#interpretando-respostas",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.8 Interpretando Respostas",
    "text": "3.8 Interpretando Respostas\n\n3.8.1 Respostas Simples\n\ntrue. → A consulta é verdadeira;\nfalse. → A consulta é falsa/não pode ser provada.\n\n\n\n3.8.2 Respostas com Variáveis\n?- pai(X, pedro).\nX = joao.\nO Prolog encontrou que X = joao satisfaz a consulta.\n\n\n3.8.3 Múltiplas Soluções\n?- genitor(X, Y).\nX = joao, Y = pedro ;\nX = pedro, Y = ana ;\nX = maria, Y = pedro ;\nX = ana, Y = carlos.\n\nUse ; (ponto e vírgula) ou barra de espaço para ver a próxima solução;\nO Prolog mostra todas as combinações possíveis.\n\n\n\n3.8.4 Forçando Múltiplas Respostas\nApós uma resposta, você pode:\n\nPressionar ; para ver mais soluções;\nPressionar . (ponto) para parar.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#aplicações-em-ciência-da-computação",
    "href": "01a-introducao-prolog.html#aplicações-em-ciência-da-computação",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.9 Aplicações em Ciência da Computação",
    "text": "3.9 Aplicações em Ciência da Computação\n\n3.9.1 1. Sistemas Especialistas e Representação de Conhecimento\n% Sistema de diagnóstico médico\nsintoma(joao, febre).\nsintoma(joao, tosse).\nsintoma(maria, febre).\nsintoma(maria, dor_cabeca).\n\n% Regras de diagnóstico\ndiagnostico(Paciente, gripe) :-\n    sintoma(Paciente, febre),\n    sintoma(Paciente, tosse),\n    \\+ sintoma(Paciente, erupcao).\n\ndiagnostico(Paciente, enxaqueca) :-\n    sintoma(Paciente, dor_cabeca),\n    sintoma(Paciente, nausea).\n\n% Incerteza bayesiana (extensão)\ndiagnostico_probabilistico(Paciente, Doenca, Prob) :-\n    findall(S, sintoma(Paciente, S), Sintomas),\n    calcular_probabilidade(Sintomas, Doenca, Prob).\n\n\n3.9.2 2. Processamento de Linguagem Natural\n% Gramática de cláusulas definidas (DCG)\nsentenca --&gt; sintagma_nominal, sintagma_verbal.\nsintagma_nominal --&gt; determinante, substantivo.\nsintagma_verbal --&gt; verbo, sintagma_nominal.\n\ndeterminante --&gt; [o].\ndeterminante --&gt; [a].\nsubstantivo --&gt; [gato].\nsubstantivo --&gt; [rato].\nverbo --&gt; [persegue].\n\n% Parsing\n?- sentenca([o, gato, persegue, o, rato], []).\n% true - sentença válida\n\n% Geração\n?- sentenca(S, []).\n% S = [o, gato, persegue, o, rato]\n% S = [o, gato, persegue, a, rato]\n% ... (todas as combinações válidas)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "01a-introducao-prolog.html#limitações-e-considerações-de-performance",
    "href": "01a-introducao-prolog.html#limitações-e-considerações-de-performance",
    "title": "3  Introdução Prática ao Prolog com Swish",
    "section": "3.10 Limitações e Considerações de Performance",
    "text": "3.10 Limitações e Considerações de Performance\n\n3.10.1 Complexidade Computacional\n\nConsultas ground: Tempo linear no tamanho do programa;\nConsultas com variáveis: Potencialmente exponencial;\nProgramas recursivos: Podem não terminar;\nEspaço: Pilha de escolhas pode crescer exponencialmente.\n\n\n\n3.10.2 Otimizações Modernas\n% Tabling (memoização) - SWI-Prolog\n:- table fibonacci/2.\n\nfibonacci(0, 0) :- !.\nfibonacci(1, 1) :- !.\nfibonacci(N, F) :-\n    N &gt; 1,\n    N1 is N-1, N2 is N-2,\n    fibonacci(N1, F1),\n    fibonacci(N2, F2),\n    F is F1 + F2.\n\n% Constraint Logic Programming (CLP)\n:- use_module(library(clpfd)).\n\nsudoku(Vars) :-\n    Vars = [X11,X12,X13,X21,X22,X23,X31,X32,X33],\n    Vars ins 1..3,\n    all_different([X11,X12,X13]),\n    all_different([X21,X22,X23]),\n    all_different([X31,X32,X33]),\n    all_different([X11,X21,X31]),\n    all_different([X12,X22,X32]),\n    all_different([X13,X23,X33]).\n\n\n3.10.3 Boas Práticas para Eficiência\n\nOrdenação de cláusulas: Casos base primeiro;\nUso criterioso do cut: Evitar backtracking desnecessário;\nTail recursion: Para evitar estouro de pilha;\nIndexação: SWI-Prolog indexa primeiro argumento automaticamente;\nAvoid ground/1 quando possível: Use type checking específico.\n\nNós vamos voltar a esses tópicos ao longo do livro, mas é importante ter uma visão geral desde o início. Principalmente porque a partir deste ponto, podemos incluir testes com o Prolog para validar a lógica que suporta o funcionamento do próprio Prolog. Mais um círculo virtuoso de aprendizado e desenvolvimento tecnológico.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução Prática ao Prolog com Swish</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html",
    "href": "02-fundamentos-logica-proposicional.html",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "",
    "text": "4.0.1 Alfabeto e Sintaxe da Lógica de Primeira Ordem\nA Lógica de Primeira Ordem é uma linguagem e, consequentemente, foi criada a partir de um alfabeto, \\(\\Sigma\\), de um conjunto de axiomas e de um conjunto de regras de inferência. Esta linguagem consiste de todas as Fórmulas Bem Formadas da teoria das lógicas proposicional e predicativa. Neste ponto, a atenta leitora deve perceber que o conjunto de axiomas é um subconjunto do conjunto de Fórmulas Bem Formadas.\nO alfabeto \\(\\Sigma\\) que estamos definindo poderá ser dividido em classes formadas por conjuntos de símbolos agrupados por semelhança. Assim:\nNa lógica matemática, uma Fórmula Bem Formada, ou Expressão Bem Formada, é uma sequência finita de símbolos formada de acordo com as regras gramaticais de uma linguagem formal especificamente desenvolvida para a redação das fórmulas da lógica.\nEm Lógica de Primeira Ordem, uma Fórmula Bem Formada é uma expressão que só pode ser verdadeira ou falsa. As Fórmulas Bem Formadas são compostas de símbolos que representam quantificadores, variáveis, constantes, predicados, e conectivos lógicos. Cuja distribuição e uso seguirão as regras sintáticas, gramaticais e semânticas da linguagem da lógica. Aprender lógica é aprender esta linguagem.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#fundamentos-da-lógica-proposicional",
    "href": "02-fundamentos-logica-proposicional.html#fundamentos-da-lógica-proposicional",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.1 Fundamentos da Lógica Proposicional",
    "text": "4.1 Fundamentos da Lógica Proposicional\nEsse sistema, também chamado de álgebra booleana, fundamental para o desenvolvimento da computação, é uma verdadeira tapeçaria de possibilidades. Na Lógica Proposicional, declarações atômicas, que só podem ter valores verdadeiro, \\(TRUE\\), ou falso \\(FALSE\\), são entrelaçadas em declarações compostas cuja veracidade, segundo as regras desse cálculo, depende dos valores de verdade das declarações atômicas que as compõem quando sujeitas aos operadores, ou aos conectivos, que definimos anteriormente.\nNa Lógica Proposicional, representamos proposições atômicas por letras como \\(P\\), \\(Q\\), \\(R\\), \\(S\\), ou usando índices como em \\(X_1\\), \\(X_2\\), etc. Um literal será definido como uma variável literal, ou uma proposição atômica, (por exemplo, \\(P\\) ou \\(Q\\)) ou sua negação (por exemplo, \\(\\neg P\\) ou \\(\\neg Q\\)). Os literais são as unidades básicas da Lógica Proposicional, assumindo valores de verdade verdadeiro (\\(TRUE\\)) ou falso (\\(FALSE\\)), e são combinados por conectivos lógicos (\\(\\neg, \\wedge, \\vee, \\rightarrow, \\leftrightarrow\\)) para formar fórmulas mais complexas.\nNa Lógica Proposicional, as fórmulas são conhecidas como Fórmulas Bem Formadas. Elas podem ser atômicas ou compostas. Nas fórmulas compostas, um operador principal, um conectivo, liga duas fórmulas atômicas, ou duas fórmulas compostas. Ou seja, as declarações atômicas e compostas são costuradas por conectivos para produzir declarações compostas, cujo valor de verdade depende dos valores de verdade das declarações componentes. Os conectivos que consideramos inicialmente, e suas tabelas-verdade podem ser vistos na #tbl-verdade1:\n\n\n\nTable 4.1: Tabela Verdade, operadores básicos.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P\\vee Q\\)\n\\(P\\wedge Q\\)\n\\(\\neg P\\)\n\\(P\\rightarrow Q\\)\n\\(P\\leftrightarrow Q\\)\n\n\n\n\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\n\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\n\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\n\n\n\n\n4.1.0.1 Análise dos Conectivos Lógicos\nQuando usamos a Tabela Verdade em uma declaração composta, podemos verificar a fórmula como verdadeira ou falsa. Para tanto, basta seguir as regras de precedência e aplicar os valores representados na Tabela Verdade de cada conectivo, simplificando a expressão. O uso da Tabela Verdade é uma alternativa mais direta do que o uso dos axiomas da Lógica Proposicional.\nNa tabela Table 4.1, listamos os conectivos, ou operadores, da Lógica Proposicional.\nO operador \\(\\vee\\), também chamado de ou inclusivo, é verdadeiro quando pelo menos um dos termos é verdadeiro. A atenta leitora deve observar que o \\(\\vee\\) difere do operador \\(\\oplus\\), ou exclusivo, que será falso se ambos os termos forem iguais, sejam eles verdadeiros ou falsos.\nO operador \\(\\wedge\\), também chamado de conjunção, é verdadeiro apenas quando ambos os termos são verdadeiros. Em linguagem natural, corresponde ao “e” lógico, como em “o céu está azul e a grama é verde”.\nO condicional \\(\\rightarrow\\) não implica em causalidade. O condicional \\(\\rightarrow\\) é falso apenas quando o antecedente é verdadeiro e o consequente é falso.\nO bicondicional \\(\\leftrightarrow\\) equivale a ambos os componentes terem o mesmo valor-verdade. Em linguagem natural, corresponde à expressão “se e somente se”, indicando que as duas proposições são verdadeiras ou falsas simultaneamente.\nTodos os operadores, ou conectivos, conectam duas declarações, exceto \\(\\neg\\) que se aplica a apenas um termo. O operador \\(\\neg\\), chamado de negação, inverte o valor-verdade de uma proposição, sendo verdadeiro quando a proposição é falsa e vice-versa.\nCada operador com sua própria aridade como pode ser visto na Table 4.2:\n\n\n\nTable 4.2: Aridade dos Operadores da Lógica Proposicional.\n\n\n\n\n\nNo Argumentos\nAridade\nExemplos\n\n\n\n\n1\nUnário\n\\(P(x)\\), \\(7x\\)\n\n\n2\nBinário\n\\(x \\vee y\\), \\(c \\wedge y\\)\n\n\n\n\n\n\nAinda observando a Table 4.1, que contém a Tabela Verdade dos operadores da Lógica Proposicional, é possível perceber que se tivermos quatro termos diferentes, em vez de dois, teremos \\(2^4 = 16\\) linhas. Independentemente do número de termos, se para uma determinada Fórmula Bem Formada todos os resultados forem verdadeiros, \\(TRUE\\), teremos uma tautologia, se todos forem falsos, \\(FALSE\\) uma contradição.\n\n\n4.1.1 Exercícios: Tabelas-Verdade e Conectivos Lógicos\nInstrução: Para cada uma das fórmulas a seguir, construa a tabela-verdade completa.\n\n\\(P \\rightarrow \\neg Q\\)\n\\((P \\lor Q) \\land R\\)\n\\(P \\leftrightarrow (P \\land Q)\\)\n\\((P \\land (P \\rightarrow Q)) \\rightarrow Q\\)\n\\((P \\rightarrow Q) \\land (P \\land \\neg Q)\\)\n\\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\)\n\\((A \\rightarrow B) \\lor (B \\rightarrow C)\\)\n\\(\\neg(P \\land Q) \\leftrightarrow (\\neg P \\lor \\neg Q)\\)\nAnalise a validade do seguinte argumento construindo uma tabela-verdade para a fórmula correspondente: “Se o programa é eficiente (\\(P\\)), o custo é baixo (\\(Q\\)). O programa é eficiente. Portanto, o custo é baixo.”\nConstrua a tabela-verdade para a fórmula \\((P \\lor Q) \\rightarrow (P \\land Q)\\).\n\n\n\n4.1.2 Equivalências Lógicas\n\n4.1.2.1 Principais Leis da Lógica Proposicional\nUma tautologia é uma fórmula que é sempre verdadeira, não importa os valores dados às variáveis. Na Programação Lógica, tautologias são verdades universais no domínio do problema. Uma contradição é uma fórmula que é sempre falsa, independentemente dos valores das variáveis. Em Programação Lógica, contradições mostram inconsistências ou impossibilidades lógicas no domínio.\nIdentificar tautologias permite simplificar expressões e fazer inferências válidas automaticamente. Reconhecer contradições evita o custo de tentar provar algo logicamente impossível.\nLinguagens de programação que usam a Programação Lógica usam unificação e resolução para fazer deduções. Tautologias geram cláusulas vazias que simplificam esta resolução. Em problemas de satisfatibilidade, se obtivermos uma contradição, sabemos que as premissas são insatisfatíveis. Segure as lágrimas e o medo. Os termos unificação e satisfatibilidade serão explicados assim que sejam necessários. Antes disso, precisamos falar de equivalências. Para isso vamos incluir um metacaractere no alfabeto da nossa linguagem: o caractere \\(\\equiv\\) que permitirá o entendimento das principais equivalências da Lógica Proposicional explicitadas a seguir:\nAs equivalências lógicas permitem validar Fórmulas Bem Formadas sem recorrer a tabelas-verdade, simplificando expressões e facilitando provas lógicas. A tabela Table 4.3 que usa um metasímbolo para definir equivalência \\(\\equiv\\), que não faz parte da linguagem que definimos para a lógica de primeira ordem mas será usado aqui em prol da didática, apresenta as principais equivalências da Lógica Proposicional, usadas nos exemplos deste documento:\n\n\n\nTable 4.3: Tabela 3 - Equivalências em Lógica Proposicional.\n\n\n\n\n\n\n\n\n\n\nExpressão Lógica Equivalente\nNome da Lei/Propriedade\nRef.\n\n\n\n\n( P Q Q P )\nComutatividade da Conjunção\n(1)\n\n\n( P Q Q P )\nComutatividade da Disjunção\n(2)\n\n\n( P (Q R) (P Q) (P R) )\nDistributividade da Conjunção sobre a Disjunção\n(3)\n\n\n( P (Q R) (P Q) (P R) )\nDistributividade da Disjunção sobre a Conjunção\n(4)\n\n\n( (P Q) P Q )\nLei de De Morgan\n(5)\n\n\n( (P Q) P Q )\nLei de De Morgan\n(6)\n\n\n( P Q P Q )\nDefinição de Implicação\n(7)\n\n\n( P Q (P Q) (Q P) )\nDefinição de Equivalência\n(8)\n\n\n( P Q Q P )\nLei da Contrapositiva\n(9)\n\n\n( P P \\(FALSE\\) )\nLei da Contradição\n(10)\n\n\n( P P \\(TRUE\\) )\nLei do Terceiro Excluído\n(11)\n\n\n( (P) P )\nLei da Dupla Negação\n(12)\n\n\n( P P )\nLei da Identidade\n(13)\n\n\n( P \\(TRUE\\) P )\nLei da Identidade para a Conjunção\n(14)\n\n\n( P \\(FALSE\\) \\(FALSE\\) )\nLei do Domínio para a Conjunção\n(15)\n\n\n( P \\(TRUE\\) \\(TRUE\\) )\nLei do Domínio para a Disjunção\n(16)\n\n\n( P \\(FALSE\\) P )\nLei da Identidade para a Disjunção\n(17)\n\n\n( (P Q) R P (Q R) )\nAssociatividade da Conjunção\n(18)\n\n\n( (P Q) R P (Q R) )\nAssociatividade da Disjunção\n(19)\n\n\n( P P P )\nIdempotência da Conjunção\n(20)\n\n\n( P P P )\nIdempotência da Disjunção\n(21)\n\n\n\n\n\n\nComo as equivalências apresentadas na Tabela Table 4.3 permitem validar Fórmulas Bem Formadas, sem o uso de uma tabela verdade, a corajosa leitora poderia tentar provar cada uma delas.\n\n\n4.1.2.2 Aplicação das Equivalências Lógicas\nAs equivalências que mencionei surgiram quase naturalmente enquanto escrevia, mais por hábito e necessidade do que por um raciocínio organizado. Existem muitas equivalências, mas essas são as que uso com mais frequência. Talvez, alguns exemplos de validação de Fórmulas Bem Formadas, usando apenas as equivalências da Tabela 3, possam inflar as velas do conhecimento e nos guiar pelo caminho que devemos seguir:\n\n4.1.2.2.1 Exemplos de Simplificação - Nível Básico\nExemplo 1: Vamos simplificar a fórmula \\(P \\wedge (Q \\vee (P \\wedge R))\\) e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\nP \\wedge (Q \\vee (P \\wedge R)) &\\equiv (P \\wedge Q) \\vee (P \\wedge (P \\wedge R)) && \\text{Distributividade da Conjunção sobre a Disjunção} \\\\\n&\\equiv (P \\wedge Q) \\vee ((P \\wedge P) \\wedge R) && \\text{Associatividade da Conjunção} \\\\\n&\\equiv (P \\wedge Q) \\vee (P \\wedge R) && \\text{Idempotência da Conjunção}\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (P \\wedge R)\\). Para determinar se a fórmula é uma tautologia, satisfatível ou falsificável, construímos a tabela-verdade completa para as variáveis \\(P\\), \\(Q\\), \\(R\\):\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(P \\wedge Q\\)\n\\(P \\wedge R\\)\n\\((P \\wedge Q) \\vee (P \\wedge R)\\)\n\n\n\n\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nFALSE\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\n\\(TRUE\\)\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\n\n\nFALSE\n\\(TRUE\\)\nFALSE\nFALSE\nFALSE\nFALSE\n\n\n\nAnalisando a tabela completa: - A fórmula é verdadeira em 3 das 8 linhas (linhas 1, 2 e 3), portanto é satisfatível. - A fórmula é falsa em 5 das 8 linhas, portanto não é uma tautologia. - A presença de linhas falsas confirma que a fórmula é falsificável.\nConclusão: A fórmula \\(P \\wedge (Q \\vee (P \\wedge R))\\) simplifica para \\((P \\wedge Q) \\vee (P \\wedge R)\\), que é satisfatível e falsificável, mas não é uma tautologia. Exemplo 2: \\(P\\rightarrow (Q \\wedge (R \\vee P))\\)\n\\[\n\\begin{align*}\nP \\rightarrow (Q \\wedge (R \\vee P)) &\\equiv \\neg P \\vee (Q \\wedge (R \\vee P)) && \\text{(7)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (\\neg P \\vee (R \\vee P)) && \\text{(4)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge (R \\vee \\neg P \\vee P) && \\text{(2)} \\\\\n&\\equiv (\\neg P \\vee Q) \\wedge $TRUE$ && \\text{(11)} \\\\\n&\\equiv \\neg P \\vee Q && \\text{(14)}\n\\end{align*}\n\\]\nExemplo 3: \\(\\neg (P \\wedge (Q \\rightarrow R))\\)\n\\[\n\\begin{align*}\n\\neg (P \\wedge (Q \\rightarrow R)) &\\equiv \\neg (P \\wedge (\\neg Q \\vee R)) && \\text{(7)} \\\\\n&\\equiv \\neg P \\vee \\neg (\\neg Q \\vee R) && \\text{(5)} \\\\\n&\\equiv \\neg P \\vee (Q \\wedge \\neg R) && \\text{(6)}\n\\end{align*}\n\\]\n\n\n4.1.2.2.2 Exemplos de Simplificação - Nível Intermediário\nExemplo 4: \\(\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S))\\)\n\\[\n\\begin{align*}\n\\neg ((P \\rightarrow Q) \\wedge (R \\rightarrow S)) &\\equiv \\neg ((\\neg P \\vee Q) \\wedge (\\neg R \\vee S)) && \\text{(7)} \\\\\n&\\equiv \\neg (\\neg P \\vee Q) \\vee \\neg (\\neg R \\vee S) && \\text{(5)} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (R \\wedge \\neg S) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 5: Vamos simplificar a fórmula \\((P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P)\\) e determinar suas propriedades lógicas.\n\\[\n\\begin{align*}\n(P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P) &\\equiv (\\neg P \\vee Q) \\vee (\\neg R \\vee S) \\vee (\\neg E \\vee P) && \\text{Definição de Implicação} \\\\\n&\\equiv \\neg P \\vee Q \\vee \\neg R \\vee S \\vee \\neg E \\vee P && \\text{Associatividade da Disjunção} \\\\\n&\\equiv (\\neg P \\vee P) \\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{Comutatividade da Disjunção} \\\\\n&\\equiv$TRUE$\\vee Q \\vee \\neg R \\vee S \\vee \\neg E && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv$TRUE$&& \\text{Lei da Dominação da Disjunção}\n\\end{align*}\n\\]\nA expressão se simplifica para\\(TRUE\\)pela lei da dominação, que estabelece que \\(TRUE \\vee X \\equiv TRUE\\) para qualquer proposição \\(X\\).\nComo a fórmula se reduz a\\(TRUE\\), ela é uma tautologia - sempre verdadeira independentemente das valorações das variáveis proposicionais.\nVerificação: Em qualquer linha de uma tabela-verdade para as cinco variáveis \\((P, Q, R, S, E)\\), a presença de \\(\\neg P \\vee P\\) (que é sempre \\(TRUE\\)) garante que toda a disjunção seja verdadeira.\nConclusão: A fórmula \\((P \\rightarrow Q) \\vee (R \\rightarrow S) \\vee (E \\rightarrow P)\\) é uma tautologia, pois se simplifica para\\(TRUE\\)através da presença de \\(\\neg P \\vee P\\) na disjunção expandida.\nExemplo 6: Vamos simplificar a fórmula \\(P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P)\\) passo a passo e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\n& P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P) \\\\\n&\\equiv P \\wedge (Q \\vee (\\neg R \\vee S)) \\vee ((\\neg E \\rightarrow P) \\wedge (P \\rightarrow \\neg E)) && \\text{Definição de Implicação, Definição de Equivalência} \\\\\n&\\equiv P \\wedge (Q \\vee \\neg R \\vee S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Definição de Implicação} \\\\\n&\\equiv (P \\wedge (Q \\vee \\neg R \\vee S)) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Reorganização para clareza}\n\\end{align*}\n\\]\nAplicando a distributividade da conjunção sobre a disjunção no primeiro termo:\n\\[\n\\begin{align*}\n&\\equiv (P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee ((E \\vee P) \\wedge (\\neg P \\vee \\neg E)) && \\text{Distributividade}\n\\end{align*}\n\\]\nPara o segundo termo, aplicamos a distributividade corretamente. Seja \\((A \\vee B) \\wedge (C \\vee D) \\equiv (A \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge C) \\vee (B \\wedge D)\\):\n\\[\n\\begin{align*}\n(E \\vee P) \\wedge (\\neg P \\vee \\neg E) &\\equiv (E \\wedge \\neg P) \\vee (E \\wedge \\neg E) \\vee (P \\wedge \\neg P) \\vee (P \\wedge \\neg E) \\\\\n&\\equiv (E \\wedge \\neg P) \\vee FALSE \\vee FALSE \\vee (P \\wedge \\neg E) && \\text{Lei da Contradição} \\\\\n&\\equiv (E \\wedge \\neg P) \\vee (P \\wedge \\neg E) && \\text{Lei da Identidade para a Disjunção}\n\\end{align*}\n\\]\nSubstituindo de volta na expressão principal:\n\\[\n\\begin{align*}\n&\\equiv (P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee (E \\wedge \\neg P) \\vee (P \\wedge \\neg E)\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (P \\wedge \\neg R) \\vee (P \\wedge S) \\vee (E \\wedge \\neg P) \\vee (P \\wedge \\neg E)\\).\nPara cinco variáveis proposicionais, uma tabela-verdade completa teria \\(2^5 = 32\\) linhas. Em vez de apresentar toda a tabela, analisemos casos estratégicos para determinar as propriedades da fórmula:\nCasos em que a fórmula é \\(FALSE\\):\n\n\\(P = FALSE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\):\n\n\\((P \\wedge Q) = FALSE\\)\n\\((P \\wedge \\neg R) = FALSE\\)\n\\((P \\wedge S) = FALSE\\)\n\\((E \\wedge \\neg P) = FALSE \\wedge TRUE = FALSE\\)\n\\((P \\wedge \\neg E) = FALSE\\)\nResultado: todos os cinco termos da disjunção são falsos\n\n\nCasos em que a fórmula é \\(TRUE\\):\n\n\\(P = TRUE, Q = TRUE, R = TRUE, S = TRUE, E = FALSE\\): \\((P \\wedge Q) = TRUE\\)\n\\(P = TRUE, Q = FALSE, R = FALSE, S = FALSE, E = FALSE\\): \\((P \\wedge \\neg R) = TRUE\\)\n\\(P = FALSE, Q = FALSE, R = FALSE, S = FALSE, E = TRUE\\): \\((E \\wedge \\neg P) = TRUE\\)\n\nA análise destes casos representativos mostra que: - A fórmula não é uma tautologia, pois existem valorações que a tornam falsa - A fórmula é satisfatível, pois existem valorações que a tornam verdadeira\n- A fórmula é falsificável, pois existem valorações que a tornam falsa\nConclusão: A fórmula \\(P \\wedge (Q \\vee (R \\rightarrow S)) \\vee (\\neg E \\leftrightarrow P)\\) é satisfatível e falsificável, mas não é uma tautologia.\n\n\n4.1.2.2.3 Exemplos de Simplificação - Nível Avançado\nOs exemplos a seguir envolvem fórmulas com múltiplas variáveis proposicionais e conectivos complexos. Estes casos demonstram a aplicação sistemática das equivalências lógicas em situações mais desafiadoras, nas quais a análise de propriedades semânticas requer maior cuidado.\nExemplo 7: Determinar se a fórmula $ (P (Q R)) ((S E) (P Q)) $ é uma equivalência lógica.\nVamos simplificar ambos os lados separadamente:\nLado Esquerdo ($ (P (Q R)) $):\n\\[\n\\begin{align*}\n\\neg(P \\lor (Q \\land \\neg R)) &\\equiv \\neg P \\land \\neg(Q \\land \\neg R) && \\text{Lei de De Morgan (5)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor \\neg\\neg R) && \\text{Lei de De Morgan (6)} \\\\\n&\\equiv \\neg P \\land (\\neg Q \\lor R) && \\text{Lei da Dupla Negação (12)}\n\\end{align*}\n\\]\nLado Direito ($ (S E) (P Q) $):\n\\[\n\\begin{align*}\n(S \\lor E) \\rightarrow (P \\land Q) &\\equiv \\neg(S \\lor E) \\lor (P \\land Q) && \\text{Definição de Implicação (7)} \\\\\n&\\equiv (\\neg S \\land \\neg E) \\lor (P \\land Q) && \\text{Lei de De Morgan (6)}\n\\end{align*}\n\\]\nA fórmula completa é $ (P (Q R)) ((S E) (P Q)) $. Para verificar se é uma equivalência, testemos uma valoração específica, como $ P = \\(TRUE\\), Q = \\(FALSE\\), R = \\(TRUE\\), S = \\(FALSE\\), E = \\(FALSE\\) $:\n\nLado Esquerdo: $ P = \\(FALSE\\) $, $ Q = \\(TRUE\\) $, $ R = \\(TRUE\\) $, então $ Q R = \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $, e $ P (Q R) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\) $.\nLado Direito: $ S = \\(TRUE\\) $, $ E = \\(TRUE\\) $, então $ S E = \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $; $ P Q = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\) $, então $ (S E) (P Q) = \\(TRUE\\) \\(FALSE\\) = \\(TRUE\\) $.\nComo $ \\(FALSE\\) \\(TRUE\\) $, os lados não são iguais nesta valoração, indicando que a fórmula não é uma equivalência lógica.\n\nPara analisar as propriedades lógicas, consideremos a satisfatibilidade da expressão completa com uma tabela-verdade parcial:\n\n\n\n\n\n\n\n\n\n\n\n\n\n$ P $\n$ Q $\n$ R $\n$ S $\n$ E $\n$ P (Q R) $\n$ (S E) (P Q) $\n$ $\n\n\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\n\nNa primeira linha, a expressão é falsa ($ \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\) $), indicando que não é uma tautologia.\nNa segunda linha, a expressão é verdadeira ($ \\(TRUE\\) \\(TRUE\\) = \\(TRUE\\) $), mostrando que é satisfatível.\n\nConclusão: A fórmula \\(\\neg(P \\vee (Q \\wedge \\neg R)) \\leftrightarrow ((S \\vee E) \\rightarrow (P \\wedge Q))\\) não é uma equivalência lógica, pois os lados diferem em algumas valorações (por exemplo, \\(P = TRUE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\)). Ela é satisfatível, pois há valorações em que é verdadeira (por exemplo, \\(P = FALSE, Q = TRUE, R = TRUE, S = TRUE, E = TRUE\\)), mas não é uma tautologia, pois também é falsificável, como mostrado pela tabela-verdade parcial.\nExemplo 8:\n\\(\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P))\\)\n\\[\n\\begin{align*}\n\\neg(P \\leftrightarrow Q) \\vee ((R \\rightarrow S) \\wedge (\\neg E \\vee \\neg P)) &\\equiv \\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(8)}\\\\\n&\\equiv (\\neg(P \\rightarrow Q) \\vee \\neg(Q \\rightarrow P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(5)}\\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee ((\\neg R \\vee S) \\wedge (\\neg E \\vee \\neg P)) && \\text{(6)}\n\\end{align*}\n\\]\nExemplo 9: Simplificação e Análise da Fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\)\nVamos simplificar a fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\) passo a passo e analisar suas propriedades lógicas.\n\\[\n\\begin{align*}\n& (P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P)) \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg (\\neg R \\leftrightarrow S) \\vee (\\neg E \\wedge P)) && \\text{Lei 7: Definição de Implicação} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg ((\\neg R \\rightarrow S) \\wedge (S \\rightarrow \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 8: Definição de Equivalência} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg ((R \\vee S) \\wedge (\\neg S \\vee \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 7: Definição de Implicação, Lei 12: Dupla Negação} \\\\\n&\\equiv (P \\wedge Q) \\vee ((\\neg (R \\vee S) \\vee \\neg (\\neg S \\vee \\neg R)) \\vee (\\neg E \\wedge P)) && \\text{Lei 5: Lei de De Morgan} \\\\\n&\\equiv (P \\wedge Q) \\vee ((\\neg R \\wedge \\neg S) \\vee (S \\wedge R) \\vee (\\neg E \\wedge P)) && \\text{Lei 6: Lei de De Morgan, Lei 12: Dupla Negação} \\\\\n&\\equiv (P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P) && \\text{Lei 19: Associatividade da Disjunção}\n\\end{align*}\n\\]\nA expressão final é \\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\).\nPara analisar as propriedades lógicas, consideremos uma tabela-verdade parcial para as variáveis \\(P\\), \\(Q\\), \\(R\\), \\(S\\), \\(E\\). Uma tabela completa teria \\(2^5 = 32\\) linhas, mas casos representativos são suficientes para determinar se a fórmula é uma tautologia, satisfatível ou falsificável:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(S\\)\n\\(E\\)\n\\(P \\wedge Q\\)\n\\(\\neg R \\wedge \\neg S\\)\n\\(R \\wedge S\\)\n\\(\\neg E \\wedge P\\)\n\\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\)\n\n\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\n\n\\(FALSE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(TRUE\\)\n\\(TRUE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\\(FALSE\\)\n\n\n\nAnálise dos Casos:\n\nCasos em que a fórmula é TRUE: Nas primeiras cinco linhas, pelo menos um dos termos da disjunção é verdadeiro:\n\nLinha 1: \\((R \\wedge S) = TRUE\\)\nLinha 2: \\((R \\wedge S) = TRUE\\)\nLinha 3: \\((\\neg R \\wedge \\neg S) = TRUE\\)\nLinha 4: \\((\\neg R \\wedge \\neg S) = TRUE\\), \\((\\neg E \\wedge P) = TRUE\\)\nLinha 5: \\((R \\wedge S) = TRUE\\), \\((\\neg E \\wedge P) = TRUE\\)\n\nEsses casos mostram que a fórmula é satisfatível, pois há valorações em que ela é verdadeira.\nCasos em que a fórmula é FALSE: Na última linha ($P = \\(FALSE\\), Q = \\(TRUE\\), R = \\(FALSE\\), S = \\(TRUE\\), E = \\(TRUE\\)$):\n\n$(P Q) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\)$\n$(R S) = \\(FALSE\\) \\(TRUE\\) = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\)$\n$(R S) = \\(FALSE\\) \\(TRUE\\) = \\(FALSE\\)$\n$(E P) = \\(TRUE\\) \\(FALSE\\) = \\(FALSE\\) \\(FALSE\\) = \\(FALSE\\)$\nResultado: \\[FALSE$ \\vee $FALSE$ \\vee $FALSE$ \\vee $FALSE$ = $FALSE\\]\n\nEsse caso mostra que a fórmula é falsificável, pois há uma valoração em que ela é falsa.\n\nConclusão: A fórmula \\((P \\wedge Q) \\vee ((\\neg R \\leftrightarrow S) \\rightarrow (\\neg E \\wedge P))\\) simplifica para \\((P \\wedge Q) \\vee (\\neg R \\wedge \\neg S) \\vee (R \\wedge S) \\vee (\\neg E \\wedge P)\\). Ela é satisfatível, pois há valorações em que é verdadeira, mas também é falsificável, pois existe pelo menos uma valoração ($P = \\(FALSE\\), Q = \\(TRUE\\), R = \\(FALSE\\), S = \\(TRUE\\), E = \\(TRUE\\)$) em que é falsa. Portanto, a fórmula não é uma tautologia. A tabela-verdade parcial apresentada é suficiente para confirmar essas propriedades, evitando a necessidade de uma tabela completa com 32 linhas.\nExemplo 10: Simplificação e Análise da Fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\)\nVamos simplificar a fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\) passo a passo e analisar suas propriedades lógicas.\nSimplifiquemos ambos os lados da equivalência separadamente:\nLado Esquerdo: \\(\\neg(P \\wedge (Q \\vee R))\\)\n\\[\n\\begin{align*}\n\\neg(P \\wedge (Q \\vee R)) &\\equiv \\neg P \\vee \\neg(Q \\vee R) && \\text{Lei 5: Lei de De Morgan} \\\\\n&\\equiv \\neg P \\vee (\\neg Q \\wedge \\neg R) && \\text{Lei 6: Lei de De Morgan}\n\\end{align*}\n\\]\nLado Direito: \\(\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q)\\)\n\\[\n\\begin{align*}\n\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q) &\\equiv \\neg(\\neg S \\vee E) \\vee \\neg(\\neg P \\vee Q) && \\text{Lei 7: Definição de Implicação} \\\\\n&\\equiv (S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) && \\text{Lei 6: Lei de De Morgan, Lei 12: Dupla Negação}\n\\end{align*}\n\\]\nA fórmula completa é: \\((\\neg P \\vee (\\neg Q \\wedge \\neg R)) \\leftrightarrow ((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q))\\)\nPara analisar as propriedades lógicas, consideremos uma tabela-verdade parcial para as variáveis \\(P\\), \\(Q\\), \\(R\\), \\(S\\), \\(E\\). Uma tabela completa teria \\(2^5 = 32\\) linhas, mas casos representativos são suficientes para determinar se a fórmula é uma tautologia, satisfatível ou falsificável:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(S\\)\n\\(E\\)\n\\(\\neg P \\vee (\\neg Q \\wedge \\neg R)\\)\n\\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q)\\)\n\\(\\leftrightarrow\\)\n\n\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\nFALSE\nFALSE\n\n\nTRUE\nTRUE\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\nTRUE\n\n\n\nAnálise dos Casos:\n\nLinha 1: (\\(P = TRUE, Q = FALSE, R = TRUE, S = FALSE, E = FALSE\\))\n\nLado Esquerdo: \\(\\neg P = FALSE\\), \\(\\neg Q \\wedge \\neg R = \\neg FALSE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = FALSE \\vee FALSE = FALSE\\).\nLado Direito: \\(S \\wedge \\neg E = FALSE \\wedge \\neg FALSE = FALSE \\wedge TRUE = FALSE\\), \\(P \\wedge \\neg Q = TRUE \\wedge \\neg FALSE = TRUE \\wedge TRUE = TRUE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee TRUE = TRUE\\).\nResultado: \\(FALSE \\leftrightarrow TRUE = FALSE\\). A fórmula é falsa nesta valoração.\n\nLinha 2: (\\(P = FALSE, Q = TRUE, R = TRUE, S = TRUE, E = TRUE\\))\n\nLado Esquerdo: \\(\\neg P = TRUE\\), \\(\\neg Q \\wedge \\neg R = \\neg TRUE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = TRUE \\vee FALSE = TRUE\\).\nLado Direito: \\(S \\wedge \\neg E = TRUE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), \\(P \\wedge \\neg Q = FALSE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee FALSE = FALSE\\).\nResultado: \\(TRUE \\leftrightarrow FALSE = FALSE\\). A fórmula é falsa nesta valoração.\n\nLinha 3: (\\(P = TRUE, Q = TRUE, R = FALSE, S = FALSE, E = TRUE\\))\n\nLado Esquerdo: \\(\\neg P = FALSE\\), \\(\\neg Q \\wedge \\neg R = \\neg TRUE \\wedge \\neg FALSE = FALSE \\wedge TRUE = FALSE\\), então \\(\\neg P \\vee (\\neg Q \\wedge \\neg R) = FALSE \\vee FALSE = FALSE\\).\nLado Direito: \\(S \\wedge \\neg E = FALSE \\wedge \\neg TRUE = FALSE \\wedge FALSE = FALSE\\), \\(P \\wedge \\neg Q = TRUE \\wedge \\neg TRUE = TRUE \\wedge FALSE = FALSE\\), então \\((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q) = FALSE \\vee FALSE = FALSE\\).\nResultado: \\(FALSE \\leftrightarrow FALSE = TRUE\\). A fórmula é verdadeira nesta valoração.\n\n\nPropriedades Lógicas:\n\nNão é uma tautologia: As linhas 1 e 2 mostram que a fórmula pode ser falsa, pois o bicondicional \\(\\leftrightarrow\\) resulta em FALSE quando os lados têm valores diferentes.\nSatisfatível: A linha 3 mostra que há uma valoração em que a fórmula é verdadeira (\\(FALSE \\leftrightarrow FALSE = TRUE\\)).\nFalsificável: As linhas 1 e 2 confirmam que há valorações em que a fórmula é falsa.\nNão é uma equivalência lógica: Como os lados esquerdo e direito diferem em algumas valorações (por exemplo, linha 1), a fórmula não é uma equivalência lógica.\n\nConclusão: A fórmula \\(\\neg(P \\wedge (Q \\vee R)) \\leftrightarrow (\\neg(S \\rightarrow E) \\vee \\neg(P \\rightarrow Q))\\) simplifica para \\((\\neg P \\vee (\\neg Q \\wedge \\neg R)) \\leftrightarrow ((S \\wedge \\neg E) \\vee (P \\wedge \\neg Q))\\). Ela é satisfatível, pois há valorações em que é verdadeira, mas também é falsificável, pois há valorações em que é falsa. Portanto, não é uma tautologia nem uma equivalência lógica. A tabela-verdade parcial apresentada é suficiente para confirmar essas propriedades. A Lógica Proposicional é essencial para entendermos o mundo. É a base de argumentos sólidos e da avaliação de proposições. Nasceu da necessidade humana de buscar a verdade e resolver conflitos com a lógica. Mas sua beleza vai além da filosofia, do discurso e da matemática. É a fundação da álgebra de George Boole, que sustenta o design de circuitos eletrônicos e a construção dos computadores modernos.\n\n\n\n\n4.1.3 Importância Histórica e Aplicações\nEm sua dissertação de final de curso, Claude Shannon usou a álgebra booleana para simplificar circuitos de controle. Desde então, as operações básicas dessa álgebra — AND, OR, NOT — tornaram-se os blocos fundamentais dos sistemas digitais. Elas formam o núcleo dos computadores, dos celulares e, na verdade, de toda a nossa civilização digital. A Lógica Proposicional é a base de todo o raciocínio lógico. Como a tabela periódica para químicos ou as leis de Newton para físicos. Ela é simples, elegante e poderosa.\nTão importante quanto o impacto da Lógica Proposicional na tecnologia digital é seu papel no pensamento racional, na tomada de decisões e na prova de teoremas. Neste caminho, nosso guia são as regras de inferência.\n\n\n4.1.4 Exercícios: Simplificação com Equivalências Lógicas\nInstrução: Use as leis de equivalência lógica (como as da Tabela 3) para simplificar as fórmulas a seguir até a forma mais simples possível. Justifique cada passo com o nome da lei ou propriedade utilizada.\n\nSimplifique: $ (P Q) $\nSimplifique: $ P (P Q) $\nSimplifique: $ (P Q) $\nSimplifique: $ (P Q) (P Q) $\nProve que a seguinte fórmula é uma tautologia: $ (P Q) (Q P) $\nSimplifique: $ (P Q) $\nSimplifique: $ (P Q) (P Q) $\nSimplifique: $ (P Q) (P Q) $\nSimplifique: $ (A B) (A B) $\nProve que a lei da Transitividade (ou Silogismo Hipotético) é uma tautologia: $ ((P Q) (Q R)) (P R) $",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#sistema-dedutivo-da-lógica-proposicional",
    "href": "02-fundamentos-logica-proposicional.html#sistema-dedutivo-da-lógica-proposicional",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.2 Sistema Dedutivo da Lógica Proposicional",
    "text": "4.2 Sistema Dedutivo da Lógica Proposicional\nO sistema dedutivo da Lógica Proposicional é um conjunto de regras e princípios que nos permite derivar conclusões a partir de premissas. Ele é fundamental para a construção de argumentos lógicos válidos e para a prova de teoremas. A seguir, apresentamos os principais componentes desse sistema:\n\n4.2.1 Regras de Inferência\nRegras de inferência são esquemas que proporcionam a estrutura para derivações lógicas. Estas regras formam a base dos sistemas de tomada de decisão computacional. Elas definem os passos legítimos que podem ser aplicados a uma ou mais proposições, sejam elas atômicas ou Fórmulas Bem Formadas, para produzir uma proposição nova. Em outras palavras, uma regra de inferência é uma transformação sintática de Formas Bem Formadas que preserva a verdade.\nAqui uma regra de inferência será representada por:\n\\[\\frac{P_1, P_2, ..., P_n}{C},\\]\nou, eventualmente por:\n\\[P_1, P_2, ..., P_n \\vdash C.\\]\nO conjunto formado \\(P_1, P_2, ..., P_n\\), chamado de contexto, ou antecedente, \\(\\Gamma\\), e \\(C\\), chamado de conclusão, ou consequente, são Fórmulas Bem Formadas. A regra significa que se as proposições que constituem a conjunção expressa no contexto são verdadeiras, então a conclusão \\(C\\), consequência, também será verdadeira. Em resumo, o contexto \\(\\Gamma\\) é o conjunto de premissas assumidas verdadeiras em uma dedução, e a conclusão \\(C\\) é derivada aplicando regras de inferência às premissas em \\(\\Gamma\\).\nEu vou tentar usar contexto e conclusão. Mas a compassiva leitora deve me perdoar se eu escapar para antecedente e consequente. É apenas o hábito.\nQuando estudamos lógica, chamamos de argumento uma lista de proposições, que aqui são as premissas. Elas vêm seguidas de uma palavra ou expressão (portanto, consequentemente, desta forma) e de outra proposição, que chamamos de conclusão. A forma que usamos para representar isso é chamada de sequência de dedução. É uma forma de mostrar que, se a proposição colocada acima da linha horizontal for verdadeira, então estamos afirmando que todas as proposições \\(P_1, P_2, ..., P_n\\) acima da linha são verdadeiras. E, por isso, a proposição abaixo da linha, a conclusão, também será verdadeira.\nAs regras de inferência são o alicerce da lógica dedutiva e das provas matemáticas. Elas permitem que raciocínios complexos sejam divididos em passos simples, com cada passo sendo justificado pela aplicação de uma regra de inferência. A seguir, estão algumas das regras de inferência mais usadas:\n\n4.2.1.1 Regras Básicas de Inferência\nAs regras básicas de inferência formam o núcleo fundamental do sistema dedutivo da lógica proposicional. Estas regras permitem derivar conclusões válidas a partir de premissas conhecidas e são amplamente utilizadas em demonstrações matemáticas e raciocínio lógico.\nA tabela Table 4.4 apresenta um resumo das regras de inferência mais comuns, suas descrições e as fórmulas associadas.\n\n\n\nTable 4.4: Resumo dos métodos de inferência.\n\n\n\n\n\n\n\n\n\n\nRegra\nDescrição\nFórmula\n\n\n\n\nModus Ponens\nSe \\(P \\rightarrow Q\\) e \\(P\\) são verdadeiros, então \\(Q\\) também é verdadeiro.\n\\(\\frac{P, P \\rightarrow Q}{Q}\\)\n\n\nModus Tollens\nSe \\(P \\rightarrow Q\\) e \\(\\neg Q\\) são verdadeiros, então \\(\\neg P\\) também é verdadeiro.\n\\(\\frac{\\neg Q, P \\rightarrow Q}{\\neg P}\\)\n\n\nDupla Negação\nA negação de uma negação é equivalente à afirmação original.\n\\(\\frac{\\neg \\neg P}{P}\\)\n\n\nAdição\nSe \\(P\\) é verdadeiro, então \\(P \\vee Q\\) também é verdadeiro.\n\\(\\frac{P}{P \\vee Q}\\)\n\n\nAdjunção\nSe \\(P\\) e \\(Q\\) são verdadeiros, então \\(P \\wedge Q\\) é verdadeiro.\n\\(\\frac{P, Q}{P \\wedge Q}\\)\n\n\nSimplificação\nSe \\(P \\wedge Q\\) é verdadeiro, então \\(P\\) (ou \\(Q\\)) é verdadeiro.\n\\(\\frac{P \\wedge Q}{P}\\)\n\n\nBicondicionalidade\nSe \\(P \\leftrightarrow Q\\), então \\(P \\rightarrow Q\\) e \\(Q \\rightarrow P\\) são verdadeiros.\n\\(\\frac{P \\leftrightarrow Q}{P \\rightarrow Q, Q \\rightarrow P}\\)\n\n\n\n\n\n\n\n4.2.1.1.1 Modus Ponens\nA regra do Modus Ponens permite inferir uma conclusão a partir de uma implicação e de sua premissa antecedente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(P\\) é verdadeiro, então podemos concluir que \\(Q\\) também é verdadeiro.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: se chover, \\((P)\\), então, \\((\\rightarrow)\\), a rua ficará molhada, \\((Q)\\);\nProposição 2: está chovendo, \\((P)\\) é verdadeira.\nConclusão: logo, a rua ficará molhada, \\((Q)\\).\n\nAlgumas aplicações do Modus Ponens:\n\nDerivar ações de regras e leis condicionais. Por exemplo:\n\nProposição: se a velocidade, \\(V\\), é maior que \\(80 \\text{km/h}\\), então é uma infração de trânsito, \\(IT\\).\nProposição: João está dirigindo, \\(d\\), à \\(90 \\text{km/h}\\).\nConclusão: logo, João cometeu uma infração de trânsito.\n\n\n\\[V &gt; 80 \\rightarrow IT\\]\n\\[\n\\begin{aligned}\n&D = 90\\\\\n\\hline\n&IT\n\\end{aligned}\n\\]\n\nAplicar implicações teóricas e chegar a novas conclusões. Por exemplo:\n\nProposição: se um número é par, \\(P\\), então é divisível por 2, $ d2$.\nProposição: 128 é par.\nConclusão: logo, 128 é divisível por 2.\n\n\n\\[x \\text{ é par} \\rightarrow \\text{divisível por dois}\\]\n\\[\n\\begin{aligned}\n&128 \\text{ é par}\\\\\n\\hline\n&128 \\text{ é divisível por 2}\n\\end{aligned}\n\\]\n\nFazer deduções lógicas em matemática e ciência. Por exemplo:\n\nProposição: se dois lados de um triângulo têm o mesmo comprimento, então o triângulo é isósceles.\nProposição: o triângulo \\(ABC\\) tem os lados \\(AB\\), \\(AC\\) e \\(BC\\) do mesmo comprimento.\nConclusão: logo, o triângulo \\(ABC\\) é isósceles.\n\n\n\\[\n\\begin{aligned}\n&(AB = AC) \\wedge (AB=CB) \\text{ no triângulo} ABC\\\\\n\\hline\n&\\text{o triângulo } ABC \\text{ é isósceles}\n\\end{aligned}\n\\]\n\nTirar conclusões com base no raciocínio condicional na vida cotidiana. Por exemplo:\n\nProposição: se hoje não chover, então irei à praia.\nProposição: Hoje não choveu.\nConclusão: logo, irei à praia.\n\n\n\\[\\neg (\\text{chover hoje}) \\rightarrow \\text{ir à praia}\\]\n\\[\n\\begin{aligned}\n&\\neg (\\text{choveu hoje})\\\\\n\\hline\n&(\\text{ir à praia})\n\\end{aligned}\n\\]\n\n\n4.2.1.1.2 Modus Tollens\nA regra do Modus Tollens permite inferir a negação da premissa antecedente a partir de uma implicação e da negação de sua premissa consequente. Se temos uma implicação \\(P\\rightarrow Q\\), e sabemos que \\(Q\\) é falso (ou seja, \\(\\neg Q\\)), então podemos concluir que \\(P\\) também é falso.\n\\[P \\rightarrow Q\\]\n\\[\n\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&\\neg P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição 1: se uma pessoa tem 18 anos ou mais, \\((P)\\), então, \\((\\rightarrow)\\) ela pode votar, \\((Q)\\);\nProposição 2: Maria não pode votar, \\((\\neg Q)\\);\nConclusão: logo, Maria não tem 18 anos ou mais, \\((\\neg P)\\).\n\nAlgumas aplicações do Modus Tollens:\n\nRefutar teorias mostrando que suas previsões são falsas. Por exemplo:\n\nProposição: se a teoria da geração espontânea, \\(TG\\), é correta, então insetos irão se formar em carne deixada exposta ao ar, \\(I\\).\nProposição: insetos não se formam em carne deixada exposta ao ar, \\(\\neg I\\).\nConclusão: logo, a teoria da geração espontânea é falsa, \\(\\neg TG\\).\n\n\n\\[TG \\rightarrow I\\]\n\\[\n\\begin{aligned}\n&\\neg I\\\\\n\\hline\n&\\neg TG\n\\end{aligned}\n\\]\n\nIdentificar inconsistências ou contradições em raciocínios. Por exemplo:\n\nProposição: se João, \\(J\\), é mais alto que Maria, \\(M\\), então Maria não é mais alta que João.\nProposição: Maria é mais alta que João, \\((M &gt; J)\\).\nConclusão: logo, João não é mais alto que Maria, \\(\\neg(J &gt; M)\\). O raciocínio mostra que não podemos ter simultaneamente \\(J &gt; M\\) e \\(M &gt; J\\), pois a relação “maior que” é assimétrica.\n\n\n\\[(J &gt; M) \\rightarrow \\neg(M &gt; J)\\]\n\\[\n\\begin{aligned}\n&(M &gt; J)\\\\\n\\hline\n&\\neg(J &gt; M)\n\\end{aligned}\n\\]\n\nFazer deduções lógicas baseadas na negação da conclusão. Por exemplo:\n\nProposição: se hoje, \\(H\\), é sexta-feira, então amanhã é sábado, \\(A_{sab}\\).\nProposição: amanhã não é sábado, \\(\\neg A_{sab}\\).\nConclusão: logo, hoje não é sexta-feira, \\(\\neg H_{sex}\\).\n\n\n\\[H_{sex} \\rightarrow A_{sab}\\]\n\\[\n\\begin{aligned}\n&\\neg A_{sab}\\\\\n\\hline\n&\\neg H_{sex}\n\\end{aligned}\n\\]\n\nDescobrir causas de eventos por eliminação de possibilidades. Por exemplo:\n\nProposição: se a tomada está com defeito, \\(D\\), então a lâmpada não acende, \\(\\neg L\\).\nProposição: a lâmpada acendeu, \\(L\\).\nConclusão: logo, a tomada não está com defeito, \\(\\neg D\\).\n\n\n\\[D \\rightarrow \\neg L\\]\n\\[\n\\begin{aligned}\n&L\\\\\n\\hline\n&\\neg D\n\\end{aligned}\n\\]\nExplicação: Como a lâmpada acendeu (\\(L\\)), isso contradiz a consequência da implicação (\\(\\neg L\\)). Pelo Modus Tollens, se o consequente é falso, então o antecedente também deve ser falso. Portanto, a tomada não está com defeito (\\(\\neg D\\)).\n\n\n\n4.2.1.2 **Regras de Manipulação Lógica\nEstas regras permitem transformar e simplificar expressões lógicas, facilitando a análise e manipulação de fórmulas complexas. São fundamentais para a normalização de expressões e para preparar fórmulas para aplicação de outras regras de inferência.\n\n4.2.1.2.1 Dupla Negação\nA regra da Dupla Negação permite eliminar uma dupla negação, inferindo a afirmação original. A negação de uma negação é equivalente à afirmação original. Esta regra é importante para simplificar expressões lógicas.\n\\[\\neg \\neg P\\]\n\\[\n\\begin{aligned}\n&\\neg \\neg P\\\\\n\\hline\n&P\\\\\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n&P\\\\\n\\hline\n&\\neg \\neg P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: não é verdade que Maria não está feliz;\nConclusão: logo, Maria está feliz.\n\nA dupla negação pode parecer desnecessária, mas ela tem algumas aplicações na lógica:\n\nSimplifica expressões lógicas: remover duplas negações ajuda a simplificar e a normalizar expressões complexas, tornando-as mais fáceis de analisar. Por exemplo, transformar não é verdade que não está chovendo em simplesmente está chovendo.\n\n\\[\\neg \\neg \\text{Está chovendo} \\equiv \\text{Está chovendo}\\]\n\nPreserva o valor de verdade: inserir ou remover duplas negações não altera o valor de verdade original de uma proposição. Isso permite transformar proposições em formas logicamente equivalentes.\nAuxilia provas indiretas: em provas por contradição, ou contrapositiva, introduzir uma dupla negação permite assumir o oposto do que se quer provar e derivar uma contradição. Isso, indiretamente, prova a proposição original.\nConecta Lógica Proposicional e de predicados: em Lógica Predicativa, a negação de quantificadores universais e existenciais envolve dupla negação. Por exemplo, a negação de todo \\(x\\) é \\(P\\) é existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\n\n\\[\\neg \\forall x P(x) \\equiv \\exists x \\neg P(x)\\]\n\nPermite provar equivalências: uma identidade ou lei importante na lógica é que a dupla negação de uma proposição é logicamente equivalente à proposição original. A regra da dupla negação permite formalmente provar essa equivalência.\n\n\\[\\neg \\neg P \\equiv P\\]\n\n\n4.2.1.2.2 Adição\nA regra da Adição permite adicionar uma disjunção a uma afirmação, resultando em uma nova disjunção verdadeira. Esta regra é útil para introduzir alternativas em nosso raciocínio dedutivo.\n\\[P\\]\n\\[\\begin{aligned}\n&P\\\\\n\\hline\n&P \\vee Q\\\\\n\\end{aligned}\n\\]\n\\[\\begin{aligned}\n&Q\\\\\n\\hline\n&P \\vee Q\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: o céu está azul;\nConclusão: logo, o céu está azul ou gatos podem voar.\n\nA regra da Adição permite introduzir uma disjunção em uma prova ou argumento lógico. Especificamente, ela nos permite inferir uma disjunção \\(P\\vee Q\\) a partir de uma das afirmações disjuntivas (\\(P\\) ou \\(Q\\)) individualmente.\nAlguns usos e aplicações importantes da regra da Adição:\n\nIntroduzir alternativas ou possibilidades em um argumento: por exemplo, dado que João está em casa, podemos concluir que João está em casa ou no trabalho. E expandir este ou o quanto seja necessário para explicitar os lugares em que João pode estar.\nCombinar afirmações em novas disjunções: dadas duas afirmações quaisquer \\(P\\) e \\(Q\\), podemos inferir que \\(P\\) ou \\(Q\\) é verdadeiro.\nCriar casos ou opções exaustivas em uma prova: podemos derivar uma disjunção que cubra todas as possibilidades relevantes.\nIniciar provas por casos: ao assumir cada disjuntiva separadamente, podemos provar teoremas por casos exaustivos.\nRealizar provas indiretas: ao assumir a negação de uma disjunção, podemos chegar a uma contradição e provar a disjunção original.\n\nA regra da Adição amplia nossas capacidades de prova e abordagem de problemas.\n\n\n4.2.1.2.3 Modus Tollendo Ponens\nO Modus Tollendo Ponens permite inferir uma disjunção a partir da negação da outra disjunção.\nDada uma disjunção \\(P\\vee Q\\):\n\nSe \\(\\neg P\\), então \\(Q\\)\nSe \\(\\neg Q\\), então \\(P\\)\n\nEsta regra nos ajuda a chegar a conclusões a partir de disjunções, por exclusão de alternativas.\n\\[P \\vee Q\\]\n\\[\\begin{aligned}\n&\\neg P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\n\\]\n\\[\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição 1: ou o céu está azul ou a grama é roxa;\nProposição 2: a grama não é roxa;\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações do Modus Tollendo Ponens:\n\nDerivar ações a partir de regras disjuntivas. Por exemplo:\n\nProposição: ou João vai à praia, \\(P\\) ou João vai ao cinema, \\(c\\);\nProposição: João não vai ao cinema, \\(\\neg C\\);\nConclusão: logo, João vai à praia.\n\n\n\\[P \\vee C\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&P\n\\end{aligned}\n\\]\n\nSimplificar casos em provas por exaustão. Por exemplo:\n\nProposição: o número é par, \\(P\\), ou ímpar, \\(I\\);\nProposição: o número não é ímpar, \\(\\neg I\\);\nConclusão: logo, o número é par, \\(P\\).\n\n\n\\[P \\vee I\\]\n\\[\\begin{aligned}\n&\\neg I\\\\\n\\hline\n&P\n\\end{aligned}\n\\]\n\nEliminar opções em raciocínio dedutivo. Por exemplo:\n\nProposição: ou João estava em casa, \\(c\\), ou João estava no trabalho, \\(t\\);\nProposição: João não estava em casa;\nConclusão: logo, João estava no trabalho.\n\n\n\\[C \\vee TRUE\\]\n\\[\\begin{aligned}\n&\\neg C\\\\\n\\hline\n&TRUE\n\\end{aligned}\n\\]\n\nFazer prova indireta da disjunção. Por exemplo:\n\nProposição: 1 é par, \\(1P\\), ou 1 é ímpar, \\(1I\\);\nProposição: 1 não é par;\nConclusão: logo, 1 é ímpar.\n\n\n\\[1P \\vee 1I\\]\n\\[\\begin{aligned}\n&\\neg 1P\\\\\n\\hline\n&1I\n\\end{aligned}\n\\]\n\n\n4.2.1.2.4 Adjunção\nA regra da Adjunção permite combinar duas afirmações em uma conjunção. Esta regra é útil para juntar duas premissas em uma única afirmação conjuntiva.\n\\[P\\]\n\\[Q\\]\n\\[\\begin{aligned}\n&P\\\\\n&Q\\\\\n\\hline\n&P \\land Q\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: o céu está azul;\nProposição 2: os pássaros estão cantando;\nConclusão: logo, o céu está azul e os pássaros estão cantando.\n\nAlgumas aplicações da Adjunção:\n\nCombinar proposições relacionadas em argumentos. Por exemplo:\n\nProposição: o céu está nublado, \\(N\\);\nProposição: está ventando, \\(V\\);\nConclusão: logo, o céu está nublado e está ventando.\n\n\n\\[\\begin{aligned}\n&N\\\\\n&V\\\\\n\\hline\n&N \\land V\n\\end{aligned}\\]\n\nCriar declarações conjuntivas complexas. Por exemplo:\n\nProposição: 1 é número natural, \\(N1\\);\nProposição: 2 é número natural, \\(N2\\);\nConclusão: logo, 1 é número natural e 2 é número natural.\n\n\n\\[\\begin{aligned}\n&N1\\\\\n&N2\\\\\n\\hline\n&N1 \\land N2\n\\end{aligned}\\]\n\nDerivar novas informações da interseção de fatos conhecidos. Por exemplo:\n\nProposição: o gato está em cima do tapete, \\(GT\\);\nProposição: o rato está em cima do tapete, \\(RT\\);\nConclusão: logo, o gato e o rato estão em cima do tapete.\n\n\n\\[\\begin{aligned}\n&GT\\\\\n&RT\\\\\n\\hline\n&GT \\land RT\n\\end{aligned}\\]\n\nFazer deduções lógicas baseadas em múltiplas proposições. Por exemplo:\n\nProposição: 2 + 2 = 4;\nProposição: 4 = 16;\nConclusão: logo, \\((2 + 2 = 4) \\land (4 \\times 4 = 16)\\).\n\n\n\\[\\begin{aligned}\n&(2 + 2 = 4)\\\\\n&(4 \\times 4 = 16)\\\\\n\\hline\n&(2 + 2 = 4) \\land (4 \\times 4 = 16)\n\\end{aligned}\\]\n\n\n4.2.1.2.5 Simplificação\nA regra da Simplificação permite inferir um componente individual a partir de uma conjunção composta. Esta regra nos permite derivar qualquer um dos elementos de uma conjunção, a partir da afirmação conjuntiva.\n\\[P \\land Q\\]\n\\[\\begin{aligned}\n&P \\land Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\\]\n\\[\\begin{aligned}\n&P \\land Q\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição: o céu está azul e os pássaros estão cantando;\nConclusão: logo, o céu está azul. Ou alternativamente, os pássaros estão cantando.\n\nAlgumas aplicações da Simplificação:\n\nDerivar elementos de conjunções complexas. Por exemplo:\n\nProposição: hoje está chovendo, \\(C\\), e fazendo frio, \\(F\\);\nConclusão: logo, está chovendo.\n\n\n\\[\\begin{aligned}\n&C \\land F\\\\\n\\hline\n&C\n\\end{aligned}\\]\n\nSimplificar provas baseadas em conjunções. Por exemplo:\n\nProposição: 2 é par, \\(2P\\), e 3 é ímpar, \\(3I\\);\nConclusão: logo, 3 é ímpar.\n\n\n\\[\\begin{aligned}\n&2P \\land 3I\\\\\n\\hline\n&3I\n\\end{aligned}\\]\n\nInferir detalhes específicos de declarações complexas. Por exemplo:\n\nProposição: o gato está dormindo, \\(D\\), e ronronando, \\(R\\);\nConclusão: logo, o gato está ronronando.\n\n\n\\[\\begin{aligned}\n&D \\land R\\\\\n\\hline\n&R\n\\end{aligned}\\]\n\nDerivar informações de premissas conjuntivas. Por exemplo:\n\nProposição: está chovendo, \\(C\\), e o jogo foi cancelado, \\(J\\);\nConclusão: logo, o jogo foi cancelado.\n\n\n\\[\\begin{aligned}\n&C \\land J\\\\\n\\hline\n&J\n\\end{aligned}\\]\n\n\n\n4.2.1.3 Regras de Equivalência e Bicondicionalidade\nAs regras de equivalência e bicondicionalidade são fundamentais para a lógica proposicional, pois permitem estabelecer relações de equivalência entre proposições e inferir conclusões a partir dessas relações. Elas são essenciais para simplificar expressões lógicas, provar teoremas e estabelecer definições matemáticas precisas. Estas regras trabalham com o conceito de equivalência lógica, no qual duas proposições têm o mesmo valor de verdade em todas as interpretações possíveis.\n\n4.2.1.3.1 Bicondicionalidade\nA regra da Bicondicionalidade permite inferir uma bicondicional a partir de duas condicionais. Esta regra nos permite combinar duas implicações para obter uma afirmação de equivalência lógica.\n\\[P \\rightarrow Q\\]\n\\[Q \\rightarrow P\\]\n\\[\\begin{aligned}\n&P \\rightarrow Q \\\\\n&Q \\rightarrow P \\\\\n\\hline\n&P \\leftrightarrow Q\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: se está chovendo, então a rua está molhada;\nProposição 2: se a rua está molhada, então está chovendo;\nConclusão: logo, está chovendo se e somente se a rua está molhada.\n\nAlgumas aplicações da Bicondicionalidade:\n\nInferir equivalências lógicas a partir de implicações bidirecionais. Por exemplo:\n\nProposição: se chove, \\(C\\), então a rua fica molhada, \\(M\\);\nProposição: se a rua fica molhada, então chove;\nConclusão: logo, chove se e somente se a rua fica molhada.\n\n\n\\[C \\rightarrow M\\]\n\\[\\begin{aligned}\n&M \\rightarrow C\\\\\n\\hline\n&C \\leftrightarrow M\n\\end{aligned}\\]\n\nEstabelecer definições matemáticas precisas. Por exemplo:\n\nProposição: se um número é múltiplo de 2, \\(M2\\), então é par, \\(P\\);\nProposição: se um número é par, então é múltiplo de 2;\nConclusão: logo, um número é par se e somente se é múltiplo de 2.\n\n\n\\[M2 \\rightarrow P\\]\n\\[\\begin{aligned}\n&P \\rightarrow M2\\\\\n\\hline\n&P \\leftrightarrow M2\n\\end{aligned}\\]\n\nEstabelecer equivalências algébricas. Por exemplo:\n\nProposição: se \\(x = 5\\), então \\(x^2 = 25\\);\nProposição: se \\(x^2 = 25\\) e \\(x &gt; 0\\), então \\(x = 5\\);\nConclusão: logo, para números positivos, \\(x = 5\\) se e somente se \\(x^2 = 25\\).\n\n\n\\[(x = 5) \\rightarrow (x^2 = 25)\\]\n\\[\\begin{aligned}\n&(x^2 = 25 \\land x &gt; 0) \\rightarrow (x = 5)\\\\\n\\hline\n&(x = 5) \\leftrightarrow (x^2 = 25 \\land x &gt; 0)\n\\end{aligned}\\]\n\nDefinir conceitos através de propriedades equivalentes. Por exemplo:\n\nProposição: se um triângulo é equilátero, \\(E\\), então todos os seus ângulos são iguais, \\(A\\);\nProposição: se um triângulo tem todos os ângulos iguais, então é equilátero;\nConclusão: logo, um triângulo é equilátero se e somente se todos os seus ângulos são iguais.\n\n\n\\[E \\rightarrow A\\]\n\\[\\begin{aligned}\n&A \\rightarrow E\\\\\n\\hline\n&E \\leftrightarrow A\n\\end{aligned}\\]\n\n\n4.2.1.3.2 Equivalência\nA regra da Equivalência permite inferir uma afirmação ou sua negação a partir de uma bicondicional. Esta regra nos permite aplicar bicondicionais para derivar novas afirmações baseadas nas equivalências lógicas.\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&P\\\\\n\\hline\n&Q\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&Q\\\\\n\\hline\n&P\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&\\neg P\\\\\n\\hline\n&\\neg Q\\\\\n\\end{aligned}\\]\n\\[P \\leftrightarrow Q\\]\n\\[\\begin{aligned}\n&\\neg Q\\\\\n\\hline\n&\\neg P\\\\\n\\end{aligned}\\]\nEm linguagem natural:\n\nProposição 1: está chovendo se e somente se a rua está molhada;\nProposição 2: está chovendo;\nConclusão: logo, a rua está molhada.\n\nAlgumas aplicações da Equivalência:\n\nInferir fatos de equivalências estabelecidas. Por exemplo:\n\nProposição: o número é par, \\(P\\), se e somente se for divisível por 2, \\(D2\\);\nProposição: 156 é divisível por 2;\nConclusão: logo, 156 é par.\n\n\\[P \\leftrightarrow D2\\]\n\\[\\begin{aligned}\n&D2(156)\\\\\n\\hline\n&P(156)\n\\end{aligned}\\]\nDerivar negações de equivalências. Por exemplo:\n\nProposição: \\(x\\) é negativo, \\(N\\), se e somente se \\(x &lt; 0\\);\nProposição: \\(x\\) não é negativo;\nConclusão: logo, \\(x\\) não é menor que \\(0\\).\n\n\\[N \\leftrightarrow (x &lt; 0)\\]\n\\[\\begin{aligned}\n&\\neg N\\\\\n\\hline\n&\\neg (x &lt; 0)\n\\end{aligned}\\]\nFazer deduções baseadas em definições. Por exemplo:\n\nProposição: número ímpar, \\(I\\), é definido como não divisível por \\(2\\), \\(\\neg D2\\);\nProposição: \\(9\\) não é divisível por \\(2\\);\nConclusão: logo, \\(9\\) é ímpar.\n\n\\[I \\leftrightarrow \\neg D2\\]\n\\[\\begin{aligned}\n&\\neg D2(9)\\\\\n\\hline\n&I(9)\n\\end{aligned}\\]\n\n\n\n\n\n4.2.2 Exercícios: Provas com Regras de Inferência\nInstrução: Para cada um dos seguintes conjuntos de premissas, derive a conclusão indicada. Apresente a prova como uma sequência de passos numerados, onde cada passo é justificado pela regra de inferência aplicada e pelos números dos passos anteriores ou premissas utilizadas.\n\nPremissas:\n\n\\(P \\rightarrow Q\\)\n\\(P\\) Conclusão: \\(Q\\)\n\nPremissas:\n\n\\(A \\rightarrow B\\)\n\\(\\neg B\\) Conclusão: \\(\\neg A\\)\n\nPremissas:\n\n\\(P \\land Q\\)\n\\(P \\rightarrow R\\) Conclusão: \\(R\\)\n\nPremissas:\n\n\\(S \\rightarrow \\neg T\\)\n\\(T\\)\n\\(S \\lor U\\) Conclusão: \\(U\\)\n\nPremissas:\n\n\\(A\\)\n\\(B\\)\n\\((A \\land B) \\rightarrow C\\) Conclusão: \\(C\\)\n\nPremissas:\n\n\\(P \\rightarrow Q\\)\n\\(Q \\rightarrow R\\) Conclusão: \\(P \\rightarrow R\\) (Esta regra é conhecida como Silogismo Hipotético)\n\nPremissas:\n\n\\(A \\rightarrow B\\)\n\\(C \\rightarrow D\\)\n\\(A \\lor C\\) Conclusão: \\(B \\lor D\\) (Esta regra é conhecida como Dilema Construtivo)\n\nPremissas:\n\n\\(\\neg A \\lor B\\)\n\\(C \\rightarrow A\\)\n\\(C\\) Conclusão: \\(B\\)\n\nArgumento: “Se o servidor está online (\\(S\\)), então os dados foram processados (\\(D\\)). Se os dados foram processados, o relatório foi gerado (\\(R\\)). O servidor está online. Portanto, o relatório foi gerado.” Instrução: Formalize as premissas e a conclusão, e então derive a conclusão.\nPremissas:\n\n\\((P \\land Q) \\rightarrow R\\)\n\\(\\neg R \\lor S\\)\n\\(P\\)\n\\(Q \\land T\\) Conclusão: \\(S\\)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#análise-semântica-de-fórmulas",
    "href": "02-fundamentos-logica-proposicional.html#análise-semântica-de-fórmulas",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.3 Análise Semântica de Fórmulas",
    "text": "4.3 Análise Semântica de Fórmulas\nA análise semântica de fórmulas proposicionais estuda o significado e as propriedades de verdade das expressões lógicas. Enquanto a sintaxe se preocupa com a estrutura formal das fórmulas, a semântica examina quando e por que essas fórmulas são verdadeiras ou falsas. Esta análise permite uma compreensão mais profunda da lógica, ajudando a identificar inconsistências e a validar argumentos.\n\n4.3.1 Classificação das Fórmulas Proposicionais\nPodemos classificar fórmulas proposicionais de acordo com suas propriedades semânticas, analisando suas tabelas-verdade. Seja \\(R\\) uma fórmula proposicional:\n\n\\(R\\) é satisfatível se sua Tabela Verdade contém pelo menos uma linha verdadeira. Considere:\\(P\\wedge Q\\).\n\n\\[\\begin{array}{|c|c|c|}\n\\hline\nP & Q & P \\land Q \\\\\n\\hline\n$FALSE$ & $FALSE$ & $FALSE$ \\\\\n\\hline\n$FALSE$ & $TRUE$ & $FALSE$ \\\\\n\\hline\n$TRUE$ & $FALSE$ & $FALSE$ \\\\\n\\hline\n$TRUE$ & $TRUE$ & $TRUE$ \\\\\n\\hline\n\\end{array}\\]\n\n\\(R\\) é insatisfatível se sua Tabela Verdade contém apenas linhas falsas. Exemplo:\\(P\\wedge \\neg P\\).\n\\(R\\) é falsificável se sua Tabela Verdade contém pelo menos uma linha falsa. Exemplo:\\(P\\wedge Q\\).\n\\(R\\) é válida se sua Tabela Verdade contém apenas linhas verdadeiras. Exemplo:\\(P\\vee \\neg P\\).\n\nNote que:\n\nSe \\(A\\) é válida, então \\(A\\) é satisfatível.\nSe \\(A\\) é insatisfatível, então \\(A\\) é falsificável.\n\nUma fórmula válida (tautologia) é satisfatível porque tem pelo menos uma linha verdadeira (na verdade, todas são verdadeiras). Uma fórmula insatisfatível (contradição) é falsificável porque tem pelo menos uma linha falsa (na verdade, todas são falsas)\nFórmulas válidas são importantes na Lógica Proposicional, representando argumentos sempre verdadeiros independentemente da valoração de suas variáveis proposicionais atômicas. Na verdade, esta classificação será importante para:\n\nAnálise de Argumentos: Se uma argumentação lógica pode ser representada por uma fórmula que é insatisfatível, então sabemos que o argumento é inválido ou inconsistente. Isso é frequentemente usado em lógica e filosofia para analisar a validade dos argumentos.\nProva de Teoremas: Na prova de teoremas, essas classificações são úteis. Quando estamos tentando provar que uma fórmula é uma tautologia, podemos usar essas classificações para simplificar a tarefa. Podemos mostrar que a negação da fórmula é insatisfatível, mostrando que a fórmula original é uma tautologia.\nSimplificação de Fórmulas: Na simplificação de fórmulas, essas classificações também são úteis. Se temos uma fórmula complexa e podemos mostrar que uma parte dela é uma tautologia, podemos simplificar a fórmula removendo essa parte. Similarmente, se uma parte da fórmula é uma contradição (ou seja, é insatisfatível), sabemos que a fórmula inteira é insatisfatível.\nConstrução de Argumentos: Na construção de argumentos, estas classificações são úteis para garantir que os argumentos são válidos. Se estamos construindo um argumento e podemos mostrar que ele é representado por uma fórmula que é satisfatível (mas não uma tautologia), sabemos que existem algumas circunstâncias em que o argumento é válido e outras em que não é.\n\n\n\n4.3.2 Exercícios: Análise Semântica de Fórmulas\nInstrução: Para cada uma das fórmulas abaixo, determine se ela é uma Tautologia, uma Contradição ou uma Contingência (satisfatível, mas também falsificável). Use o método que preferir (tabela-verdade ou simplificação por equivalências lógicas) para justificar sua resposta.\n\nClassifique a fórmula: \\(P \\rightarrow (P \\land Q)\\)\nClassifique a fórmula: \\((P \\lor Q) \\lor (\\neg P \\land \\neg Q)\\)\nClassifique a fórmula: \\((P \\leftrightarrow Q) \\land (P \\land \\neg Q)\\)\nEncontre uma valoração (uma atribuição de Verdadeiro ou Falso para A, B e C) que torne a seguinte fórmula verdadeira: \\((\\neg A \\lor B) \\rightarrow (C \\rightarrow A)\\)\nEncontre uma valoração que torne a fórmula do exercício 4 falsa.\nClassifique a fórmula (Axioma de Frege): \\((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\\)\nClassifique a fórmula: \\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\land Q))\\)\nClassifique a fórmula: \\(\\neg(((P \\lor Q) \\rightarrow P) \\lor Q)\\)\nAnalise o argumento: “Uma pessoa pode dirigir (\\(D\\)) se, e somente se, ela tem uma carteira de motorista (\\(C\\)) e não está embriagada (\\(\\neg E\\)). É logicamente consistente (satisfatível) afirmar que uma pessoa está dirigindo sem ter carteira de motorista?”. Justifique sua resposta.\nClassifique a fórmula: \\((A \\leftrightarrow B) \\lor (B \\leftrightarrow C)\\)",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "02-fundamentos-logica-proposicional.html#exercícios-de-conexão-com-o-prolog",
    "href": "02-fundamentos-logica-proposicional.html#exercícios-de-conexão-com-o-prolog",
    "title": "4  Lógica de Primeira Ordem: Lógica Proposicional",
    "section": "4.4 Exercícios de Conexão com o Prolog",
    "text": "4.4 Exercícios de Conexão com o Prolog\nEstas questões demonstram conceitos fundamentais que se traduzem diretamente para Prolog:\n\nFatos: Proposições básicas verdadeiras (como “U” na questão 4)\nRegras: Implicações lógicas (como “C → U” traduzido para pode_compilar(core) :- pode_compilar(utils).)\nConsultas: Questões que queremos responder usando a base de conhecimento\nConsistência: Importância de evitar contradições na base de conhecimento\nDedução: Como o motor de inferência do Prolog resolve consultas usando fatos e regras\n\nEste conjunto de questões foi elaborado para solidificar os fundamentos da Lógica Proposicional, servindo como base para a modelagem de sistemas e a programação em lógica. Cada problema apresenta um “mundo” a ser modelado com proposições e operadores lógicos, preparando para a construção de bases de conhecimento com fatos, regras e consultas.\n\n4.4.1 Questão 1: Diagnóstico de Sistema\nUm sistema de monitoramento de um servidor reporta os seguintes fatos:\n\nSe o servidor está sobrecarregado (S), então a latência da rede aumenta (L).\n\nSe a latência da rede aumenta (L), o sistema de alerta envia uma notificação (N).\n\nO sistema de alerta não enviou uma notificação.\n\nModele essas afirmações usando lógica proposicional e prove que o servidor não está sobrecarregado.\n\n\n4.4.2 Questão 2: Validação de Circuito Lógico (Half-Adder)\nUm circuito somador de meio bit (Half-Adder) recebe duas entradas, A e B, e produz duas saídas: a Soma (S) e o “Vai-um” (C, de Carry). A lógica é:\n\nA saída S é verdadeira se, e somente se, exatamente uma das entradas (A ou B) for verdadeira.\n\nA saída C é verdadeira se, e somente se, ambas as entradas (A e B) forem verdadeiras.\n\nTraduza as condições para as saídas S e C em fórmulas proposicionais. Em seguida, usando uma tabela verdade, demonstre que a fórmula \\((A \\lor B) \\land \\neg(A \\land B)\\) é logicamente equivalente à fórmula para a saída S.\n\n\n4.4.3 Questão 3: Análise de Contrato de Serviço (Corrigida)\nAs cláusulas de um contrato de nível de serviço (SLA) para uma plataforma de nuvem estipulam:\n\nSe o uptime do serviço for menor que 99% (U), o cliente receberá um crédito na fatura (C).\n\nPara receber o crédito (C), o cliente deve abrir um ticket de suporte (T).\n\nO cliente pode optar por um desconto de 10% no próximo mês (D) em vez de receber o crédito (C), mas não pode ter ambos.\n\nNeste mês, o uptime foi de 98% e o cliente não abriu um ticket de suporte.\n\nAnalise a consistência lógica das regras do contrato. O que acontece quando o uptime é baixo mas o cliente não abre um ticket?\n\n\n4.4.4 Questão 4: Dependências de Compilação (Corrigida)\nPara compilar um software, as seguintes dependências devem ser satisfeitas:\n\nA biblioteca utils (U) deve estar compilada para que o módulo core (C) possa ser compilado.\n\nO módulo core (C) deve estar compilado para que o módulo api (A) possa ser compilado.\n\nPara compilar a interface gráfica gui (G), tanto o módulo api (A) quanto a biblioteca assets (L) devem estar compilados.\n\nA biblioteca utils (U) já foi compilada.\n\nModele as dependências como regras lógicas. Construa uma fórmula que represente todas as condições necessárias para compilar a gui. É possível compilar a gui com as informações disponíveis?\n\n\n4.4.5 Questão 5: Regras de um Jogo\nEm um jogo de tabuleiro, um jogador vence (V) se chegar à casa final (F) e possuir o amuleto mágico (A). As regras para obter o amuleto são:\n\nO jogador obtém o amuleto (A) se derrotar o dragão (D) ou se resolver o enigma da esfinge (E).\n\nPara enfrentar o dragão (D), o jogador precisa da espada de prata (S).\n\nO jogador encontrou a espada de prata, mas não conseguiu resolver o enigma da esfinge.\n\nModele o cenário. Supondo que o jogador chegue à casa final, ele vencerá o jogo se e somente se qual condição for satisfeita? Use equivalência lógica para simplificar a condição de vitória.\n\n\n4.4.6 Questão 6: Decisão de um Robô Autônomo\nUm robô de limpeza opera com as seguintes regras de decisão:\n\nSe o sensor de proximidade frontal detectar um obstáculo (O), o robô deve parar (P) e girar para a direita (G).\n\nSe a bateria estiver baixa (B), o robô deve parar (P) e retornar à base de carregamento (R).\n\nO robô não pode girar para a direita (G) e retornar à base (R) ao mesmo tempo.\n\nNeste momento, o sensor de proximidade detectou um obstáculo e a bateria está baixa.\n\nMostre que as regras atuais levam a uma contradição lógica, o que “travaria” o robô. Sugira uma modificação em uma das regras para resolver o conflito.\n\n\n4.4.7 Questão 7: Simplificação de Query de Banco de Dados (Corrigida)\nUm analista de dados precisa selecionar usuários de uma base de dados que satisfaçam uma condição complexa: “Selecionar usuários que são ‘ativos’ E (moram em ‘São Paulo’ OU têm mais de 50 compras) OU selecionar usuários que NÃO são ‘ativos’ E (moram em ‘São Paulo’ E têm mais de 50 compras)”.\nSeja: * A: O usuário é ‘ativo’.\n* S: O usuário mora em ‘São Paulo’.\n* C: O usuário tem mais de 50 compras.\nA condição pode ser escrita como: \\((A \\land (S \\lor C)) \\lor (\\neg A \\land (S \\land C))\\).\nUse uma tabela verdade para encontrar a forma normal disjuntiva mínima desta expressão. Qual das formas seria mais eficiente para o banco de dados processar?\n\n\n4.4.8 Questão 8: O Paradoxo do Mentiroso (Versão Proposicional)\nConsidere a seguinte afirmação: “Esta frase é falsa”. Seja P a proposição que representa “Esta frase é verdadeira”. A afirmação pode ser escrita como \\(P \\leftrightarrow \\neg P\\).\nUsando uma tabela verdade, mostre que esta fórmula é uma contradição. Explique por que isso representa um paradoxo e como a lógica proposicional clássica lida com sentenças autorreferentes.\n\n\n4.4.9 Questão 9: Política de Firewall\nUma política de segurança de rede é definida por duas regras:\n\nRegra 1: Se uma requisição vem de uma rede interna (I) E se destina à porta 443 (P), então a requisição é permitida (A).\n\nRegra 2: Se uma requisição vem de uma rede externa (ou seja, \\(\\neg I\\)) OU se destina a um serviço de monitoramento (ou seja, \\(\\neg P\\)), então a requisição é permitida (A).\n\nUm pacote chega de uma rede interna (I) e não se destina à porta 443 (\\(\\neg P\\)). A requisição será permitida? Use dedução lógica para chegar à conclusão. A política é redundante ou conflitante em algum aspecto?\n\n\n4.4.10 Questão 10: Tautologia, Contradição ou Contingência?\nUma empresa define uma nova política de bônus: “Um funcionário recebe um bônus (B) se ele atingiu a meta de vendas (V) ou se participou do novo treinamento (T). No entanto, se o funcionário participou do novo treinamento (T) mas não atingiu a meta de vendas (V), ele não recebe o bônus (B)”.\nA fórmula que descreve a política é: \\(((V \\lor T) \\to B) \\land ((T \\land \\neg V) \\to \\neg B)\\).\nAnalise esta fórmula. Ela é uma tautologia, uma contradição ou uma contingência? O que sua conclusão significa para a aplicabilidade da política da empresa?",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Proposicional</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "",
    "text": "5.1 Contrapositivas e Recíprocas\nAs implicações são um problema, do ponto de vista da matemática. Sentenças do tipo se…então induzem uma conclusão. Provar estas sentenças é uma preocupação constante da matemática. Dada uma implicação, existem duas fórmulas relacionadas que ocorrem com tanta frequência que possuem nomes especiais: contrapositivas e recíprocas. Antes de mergulharmos em contrapositivas, precisamos visitar alguns portos.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#logicamente-equivalente",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#logicamente-equivalente",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.2 Logicamente Equivalente",
    "text": "5.2 Logicamente Equivalente\nVamos imaginar um mundo de fórmulas que consistem apenas em duas proposições:\\(P\\) e \\(Q\\). Usando os operadores da Lógica Proposicional podemos escrever um número muito grande de fórmulas diferentes combinando estas duas proposições.\nA coisa interessante sobre as fórmulas que conseguimos criar com apenas duas proposições é que cada uma dessas fórmulas tem uma Tabela Verdade com exatamente quatro linhas, \\(2^2=4\\). Mesmo que isso pareça surpreendente, só existem dezesseis configurações possíveis para a última coluna de todas as Tabelas-Verdade de todas as tabelas que podemos criar, \\(2^4=16\\). Como resultado, muitas fórmulas compartilham a mesma configuração final em suas Tabelas Verdade. Todas as fórmulas que possuem a mesma configuração na última coluna são equivalentes.Terei ouvido um viva?\nPara que a esforçada leitora possa ver um pouco mais de formalidade considere as proposições \\(A\\) e \\(B\\). Estas proposições serão ditas logicamente equivalentes se, e somente se, a proposição \\(A \\Leftrightarrow B\\) for uma tautologia.\nExemplo 1: Vamos mostrar que \\(P \\rightarrow Q\\) é logicamente equivalente a \\(\\neg Q \\rightarrow \\neg P\\).\nSolução: Para isso, verificaremos se a coluna do conectivo principal na Tabela Verdade para a proposição bicondicional \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\) contém apenas valores verdadeiros:\n\\[\n\\begin{array}{|c|c|c|c|c|c|c|}\n\\hline\nP & Q & P \\rightarrow Q & \\neg Q & \\neg P & \\neg Q \\rightarrow \\neg P & (P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P) \\\\\n\\hline\nF & F & T & T & T & T & T \\\\\n\\hline\nF & T & T & F & T & T & T \\\\\n\\hline\nT & F & F & T & F & F & T \\\\\n\\hline\nT & T & T & F & F & T & T \\\\\n\\hline\n\\end{array}\n\\]\nComo a coluna da operação principal \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\) contém apenas valores verdadeiros (\\(T\\)), a proposição bicondicional é uma tautologia. Consequentemente, as fórmulas \\(P \\rightarrow Q\\) e \\(\\neg Q \\rightarrow \\neg P\\) são logicamente equivalentes.\nExemplo 2: Vamos mostrar que \\(P \\wedge Q\\) não é logicamente equivalente a \\(P \\vee Q\\).\nSolução Para mostrar que \\(P \\wedge Q\\) não é logicamente equivalente a \\(P \\vee Q\\), precisamos verificar se a proposição bicondicional \\((P \\wedge Q) \\leftrightarrow (P \\vee Q)\\) é uma tautologia. Se não for uma tautologia, então as duas fórmulas não são logicamente equivalentes.\nConstruindo a Tabela Verdade (usando T para Verdadeiro e F para Falso):\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nP & Q & P \\wedge Q & P \\vee Q & (P \\wedge Q) \\leftrightarrow (P \\vee Q) \\\\\n\\hline\nT & T & T & T & T \\\\\nT & F & F & T & F \\\\\nF & T & F & T & F \\\\\nF & F & F & F & T \\\\\n\\hline\n\\end{array}\n\\]\nComo a última coluna da Tabela Verdade para \\((P \\wedge Q) \\leftrightarrow (P \\vee Q)\\) não contém apenas valores \\(T\\) (há ocorrências de \\(F\\)), a proposição bicondicional não é uma tautologia. Portanto, \\(P \\wedge Q\\) e \\(P \\vee Q\\) não são logicamente equivalentes.\nExemplo 3: Vamos mostrar que \\(P\\rightarrow Q\\) é logicamente equivalente a \\(\\neg P \\vee Q\\).\nSolução Verificando a Tabela Verdade:\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline\nP & Q & \\neg P & \\neg P \\vee Q & P \\rightarrow Q \\leftrightarrow \\neg P \\vee Q\\\\\n\\hline\nT & T & F & T & T\\\\\n\\hline\nT & F & F & F & T\\\\\n\\hline\nF & T & T & T & T\\\\\n\\hline\nF & F & T & T & T\\\\ \\hline\n\\end{array}\n\\]\nNeste caso \\(P\\rightarrow Q\\) e \\(\\neg P \\vee Q\\) são logicamente equivalentes.\nEm resumo, duas fórmulas \\(P\\) e \\(Q\\), atômicas, ou não, são equivalentes se quando \\(P\\) for verdadeiro, \\(Q\\) também será e vice-versa. Agora que já sabemos o que significa logicamente equivalentes podemos entender o que é uma proposição contrapositiva.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#contrapositiva",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#contrapositiva",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.3 Contrapositiva",
    "text": "5.3 Contrapositiva\nA contrapositiva de uma implicação é obtida invertendo-se o antecedente e o consequente da implicação original e negando-os. Por exemplo, considere a seguinte implicação: se chove, então a rua fica molhada sua contrapositiva poderia ser: se a rua não está molhada, então não choveu. Sejam \\(P\\) e \\(Q\\) fórmulas proposicionais derivadas de uma sentença do tipo se … então. A implicação \\(P\\rightarrow Q\\) representa a sentença Se \\(P\\), então \\(Q\\). Neste caso, A contrapositiva de \\(P\\rightarrow Q\\) será dada por:\n\\[\n\\begin{aligned}\n\\lnot Q \\rightarrow \\lnot P\n\\end{aligned}\n\\]\nA contrapositiva pode ser lida como se não \\(Q\\), então não \\(P\\). Em outras palavras estamos dizendo: Se \\(Q\\) é falso, então \\(P\\) é falso. A contrapositiva de uma fórmula é importante porque, frequentemente, é mais fácil provar a contrapositiva de uma fórmula que a própria fórmula. E, como a contrapositiva é logicamente equivalente a sua fórmula, provar a contrapositiva é provar a fórmula. Como a contrapositiva de uma implicação e a própria implicação são logicamente equivalentes, se provamos uma, a outra está provada. Além disso, a contrapositiva preserva a validade das implicações proposicionais. Finalmente, observe que a contrapositiva troca o antecedente pelo negação do consequente e vice-versa.\nExemplo 1:\nA contrapositiva de \\(P\\rightarrow (Q \\vee R)\\) é \\(\\lnot(Q \\vee R) \\rightarrow \\neg P\\).\nExemplo 2: Dizemos que uma função é injetora se $x y $implica \\(f(x) \\neq f(y)\\). A contrapositiva desta implicação é: se \\(f(x) = f(y)\\) então \\(x = y\\).\nO Exemplo 2 é uma prova de conceito. Normalmente é mais fácil assumir \\(f(x) = f(y)\\) e deduzir \\(x = y\\) do que assumir \\(x \\neq y\\) e deduzir \\(f(x) \\neq f(y)\\). Isto pouco tem a ver com funções e muito com o fato de que \\(x \\neq y\\) geralmente não é uma informação útil.\nO que torna a contrapositiva importante é que toda implicação é logicamente equivalente à sua contrapositiva. Consequentemente, se queremos provar que uma função é injetora, é suficiente provar que se \\(f(x) = f(y)\\) então \\(x = y\\).\nA contrapositiva funciona para qualquer declaração condicional, e matemáticos gastam muito tempo provando declarações condicionais.\nO que não podemos esquecer de jeito nenhum é que toda fórmula condicional terá a forma \\(P\\rightarrow Q\\). Mostramos que isso é logicamente equivalente a \\(\\lnot Q \\rightarrow \\lnot P\\) verificando a Tabela Verdade para a declaração bicondicional construída a partir dessas fórmulas. E que para obter a contrapositiva basta inverter antecedente e consequente e negar ambos. mantendo a relação lógica entre os termos da implicação.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#recíproca",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#recíproca",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.4 Recíproca",
    "text": "5.4 Recíproca\nA recíproca, também conhecida como conversa por alguns acadêmicos brasileiros, é obtida apenas invertendo antecedente e consequente. Então, considerando a recíproca da condicional \\(P\\rightarrow Q\\) será \\(Q \\rightarrow P\\). Diferentemente da contrapositiva a recíproca não é necessariamente equivalente à implicação original. Além disso, a contrapositiva preserva a equivalência lógica, a recíproca não.\nExemplo 1: A recíproca de \\(P\\rightarrow (Q \\vee R)\\) será \\((Q \\vee R) \\rightarrow P\\).\nExemplo 2: Dizemos que uma função é bem definida se cada entrada tem uma saída única. Assim, uma função é bem definida se \\(x = y\\) implica \\(f(x) = f(y)\\). Observe estas fórmulas:\n\n\\(f(x)\\) é bem definida significa que \\(x = y \\rightarrow f(x) = f(y)\\).\n\\(f(x)\\) é injetora significa que \\(f(x) = f(y) \\rightarrow x = y\\).\n\nPodemos ver que \\(f(x)\\) é bem definida é a recíproca de \\(f(x)\\) é injetora.\nPara provar uma bicondicional, como \\(P \\leftrightarrow Q\\), um matemático frequentemente divide a prova em duas etapas. Primeiro, prova-se a implicação \\(P \\rightarrow Q\\) e, depois, prova-se a sua recíproca, \\(Q \\rightarrow P\\). Nenhuma dessas etapas pode ser pulada, pois uma implicação e sua recíproca não são, em geral, logicamente equivalentes; a verdade de uma não garante a verdade da outra.\nPor exemplo, considere a implicação verdadeira: “Se um animal é um cão, então ele é um mamífero”. Sua recíproca, “Se um animal é um mamífero, então ele é um cão”, é claramente falsa, pois existem muitos mamíferos que não são cães. Este exemplo mostra que uma implicação pode ser verdadeira enquanto sua recíproca é falsa. Apenas nos casos em que ambas são verdadeiras, como em “um número inteiro é par se, e somente se, é divisível por 2”, é que a relação bicondicional se sustenta.\nPara resumir, uma implicação é sempre equivalente à sua contrapositiva, mas pode não ser equivalente à sua recíproca.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.5 Análise de Argumentos",
    "text": "5.5 Análise de Argumentos\nQuando vimos regras de inferência, sem muitos floreios, definimos argumentos. mas, sem usar a palavra argumento em nenhum lugar. Vamos voltar um pouco. Definiremos um argumento proposicionalmente como sendo uma regra de inferência, então um argumento será definido por um conjunto de proposições. Quando estamos analisando argumentos chamamos as proposições de premissas, de modo que:\n\\[\\frac{P_1, P_2, ..., P_n}{C}\\]\nUm argumento é formado por um conjunto de premissas \\(P_1, P_2, ..., P_n\\), chamado de antecedente, e uma proposição \\(C\\), chamada de conclusão. Dizemos que o argumento será válido, só e somente se, a implicação definida por \\((P_1 \\wedge P_2 \\wedge ... \\wedge P_n) \\rightarrow C\\) for uma tautologia. Neste caso, é muito importante percebermos que a conclusão de um argumento logicamente válido não é necessariamente verdadeira. A única coisa que a validade lógica garante é que se todas as premissas forem verdadeiras, a conclusão será verdadeira.\nPodemos recuperar as regras de inferência e observá-las pelo ponto de vista da análise de argumentos. Se fizermos isso, vamos encontrar alguns formatos comuns:\nModus Ponens: se é verdade que se eu estudar para o exame \\(P\\), então eu passarei no exame, \\(Q\\), e também é verdade que eu estudei para o exame \\(P\\), então podemos concluir que eu passarei no exame \\(Q\\).\nmatematicamente, sejam \\(P\\) e \\(Q\\) Proposições. A forma do Modus Ponens é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\rightarrow Q \\quad \\text{(Se P, então Q)} \\\\\n& \\quad P \\quad \\text{(P é verdadeiro)} \\\\\n\\hline\n& \\quad Q \\quad \\text{(Portanto, Q é verdadeiro)}\n\\end{align*}\n\\]\nCuja Tabela Verdade será:\n\\[\n\\begin{array}{|c|c|c|}\n\\hline\nP & Q & P \\rightarrow Q \\\\\n\\hline\nT & T & T \\\\\nT & F & F \\\\\nF & T & T \\\\\nF & F & T \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a primeira linha, se \\(P\\) é verdadeiro e \\(P→ Q\\) é verdadeiro, então \\(Q\\) é necessariamente verdadeiro, o que é exatamente a forma de Modus Ponens.\nModus Tollens : se é verdade que se uma pessoa é um pássaro \\(P\\), então essa pessoa pode voar \\(Q\\), e também é verdade que essa pessoa não pode voar \\(\\neg Q\\), então podemos concluir que essa pessoa não é um pássaro \\(\\neg P\\). Ou:\nSejam \\(P\\) e \\(Q\\) Proposições. A forma do Modus Tollens é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\rightarrow Q \\quad \\text{(Se P, então Q)} \\\\\n& \\quad \\neg Q \\quad \\text{(Q é falso)} \\\\\n\\hline\n& \\quad \\neg P \\quad \\text{(Portanto, P é falso)}\n\\end{align*}\n\\]\nCuja Tabela Verdade será dada por:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nP & Q & \\neg Q & P \\rightarrow Q & \\neg P \\\\\n\\hline\nT & T & F & T & F \\\\\nT & F & T & F & F \\\\\nF & T & F & T & T \\\\\nF & F & T & T & T \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a quarta linha, se \\(Q\\) é falso e \\(P\\rightarrow Q\\) é verdadeiro, então \\(P\\) é necessariamente falso, o que é exatamente a forma de Modus Tollens.\nSilogismo Hipotético : se é verdade que se eu acordar cedo \\(P\\), então eu irei correr \\(Q\\), e também é verdade que se eu correr \\(Q\\), então eu irei tomar um café da manhã saudável \\(R\\), podemos concluir que se eu acordar cedo \\(P\\), então eu irei tomar um café da manhã saudável \\(R\\).\nmatematicamente teremos: sejam \\(P\\), \\(Q\\) e \\(R\\) Proposições. A forma do Silogismo Hipotético é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\rightarrow Q \\quad \\text{(Se P, então Q)} \\\\\n& \\quad Q \\rightarrow R \\quad \\text{(Se Q, então R)} \\\\\n\\hline\n& \\quad P \\rightarrow R \\quad \\text{(Portanto, se P, então R)}\n\\end{align*}\n\\]\nCuja Tabela Verdade será:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nP & Q & R & P \\rightarrow Q & Q \\rightarrow R & P \\rightarrow R \\\\\n\\hline\nT & T & T & T & T & T \\\\\nT & T & F & T & F & F \\\\\nT & F & T & F & T & T \\\\\nT & F & F & F & T & T \\\\\nF & T & T & T & T & T \\\\\nF & T & F & T & F & T \\\\\nF & F & T & T & T & T \\\\\nF & F & F & T & T & T \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a primeira linha, se \\(P\\) é verdadeiro, \\(P\\rightarrow Q\\) é verdadeiro e \\(Q \\rightarrow R\\) é verdadeiro, então \\(P\\rightarrow R\\) é necessariamente verdadeiro, o que é exatamente a forma de Silogismo Hipotético.\nSilogismo Disjuntivo: se é verdade que ou eu vou ao cinema \\(P\\) ou eu vou ao teatro \\(Q\\), e também é verdade que eu não vou ao cinema \\(\\neg P\\), então podemos concluir que eu vou ao teatro \\(Q\\). Ou, com um pouco mais de formalidade:\nSejam \\(P\\) e \\(Q\\) Proposições. A forma do Silogismo Disjuntivo é a seguinte:\n\\[\n\\begin{align*}\n& \\quad P \\vee Q \\quad \\text{(P ou Q)} \\\\\n& \\quad \\neg P \\quad \\text{(não P)} \\\\\n\\hline\n&\\quad Q \\quad \\text{(Portanto, Q)}\n\\end{align*}\n\\]\nA Tabela Verdade será:\n\\[\n\\begin{array}{|c|c|c|c|}\n\\hline\nP & Q & \\neg P & P \\vee Q \\\\\n\\hline\nT & T & F & T \\\\\nT & F & F & T \\\\\nF & T & T & T \\\\\nF & F & T & F \\\\\n\\hline\n\\end{array}\n\\]\nSe olharmos para a terceira linha, se \\(P\\) é falso e \\(P\\vee Q\\) é verdadeiro, então \\(Q\\) é necessariamente verdadeiro, o que é exatamente a forma de Silogismo Disjuntivo.\nNão podemos esquecer: um argumento só é válido se, e somente se, a proposição condicional que o expresse seja uma tautologia. Agora podemos definir um sistema de prova.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#finalmente-um-sistema-de-prova",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#finalmente-um-sistema-de-prova",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.6 Finalmente, um Sistema de Prova",
    "text": "5.6 Finalmente, um Sistema de Prova\nAinda estamos no domínio da Lógica Proposicional e vamos definir um sistema de prova simples e direto chamado de \\(\\mathfrak{L}\\) desenvolvido por John Lemmon na segunda metade do século XX. Vamos construir a prova e, sintaticamente, em cada linha da nossa prova teremos:\n\num axioma de \\(\\mathfrak{L}\\). Um axioma é uma fórmula ou proposição que é aceita como verdadeira primitivamente, sem necessidade de demonstração. Por exemplo: \\((p \\rightarrow q) \\rightarrow ((q \\rightarrow r) \\rightarrow (p \\rightarrow r))\\);\no resultado da aplicação do Modus Ponens;\numa hipótese, na forma de fórmula;\nou um lema, uma proposição auxiliar demonstrável utilizada como passo intermediário na prova. Por exemplo: a derivação de fórmulas menores.\n\nAxiomas são proposições consideradas como verdades, são absolutos. Lemas são passos intermediários no processo de prova, pequenos teoremas já provados e, finalmente temos o teorema: representado por \\(\\varphi\\). Um teorema é uma fórmula demonstrável a partir de axiomas, lemas e das regras de inferência do sistema. Vamos começar dos axiomas.\nExistem três axiomas no sistema \\(\\mathfrak{L}\\). Estes axiomas formam a base do sistema dedutivo \\(\\mathfrak{L}\\) em Lógica Proposicional. Eles capturam propriedades fundamentais das implicações que permitem derivar teoremas válidos.\nAxioma 1: \\(A \\rightarrow (B \\rightarrow A)\\), este axioma estabelece que se \\(A\\) é verdadeiro, então a implicação \\(B \\rightarrow A\\) também é verdadeira, independentemente de \\(B\\). Isso porque a implicação \\(B \\rightarrow A\\) só será falsa se \\(B\\) for verdadeiro e \\(A\\) falso, o que não pode ocorrer se \\(A\\) é inicialmente verdadeiro.\nAxioma 2: \\((A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\rightarrow B) \\rightarrow (A \\rightarrow C))\\). Este axioma funciona como uma propriedade distributiva da implicação. Ele estabelece que, se uma hipótese \\(A\\) implica uma segunda implicação \\((B \\rightarrow C)\\), e se a mesma hipótese \\(A\\) também implica \\(B\\), então podemos concluir que a hipótese \\(A\\) necessariamente implica \\(C\\). Essencialmente, ele permite encadear deduções que dependem de uma mesma premissa inicial \\(A\\).\nAxioma 3: \\((\\lnot B \\rightarrow \\lnot A) \\rightarrow ((\\lnot B \\rightarrow A) \\rightarrow B)\\), este axioma garante que se de \\(\\lnot B\\) podemos inferir tanto \\(\\lnot A\\) quanto \\(A\\), então \\(B\\) deve ser verdadeiro. Isso porque \\(B\\) e \\(\\lnot B\\) não podem ser verdadeiros simultaneamente.\nAlém dos axiomas, usaremos apenas uma regra de inferência, o Modus Ponens. O Modus Ponens está intimamente relacionado à proposição \\((P \\wedge (P \\rightarrow Q)) \\rightarrow Q\\). Tanto a proposição quando a regra de inferência, de certa forma, dizem: “se \\(P\\) e \\(P\\rightarrow Q\\) são verdadeiros, então \\(Q\\) é verdadeiro”. Esta proposição é um exemplo de uma tautologia, porque é verdadeira para cada configuração de \\(P\\) e \\(Q\\). A diferença é que esta tautologia é uma única proposição, enquanto o Modus Ponens é uma regra de inferência que nos permite deduzir novas proposições a partir proposições já provadas.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#o-símbolo-de-demonstrabilidade-turnstile",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#o-símbolo-de-demonstrabilidade-turnstile",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.7 O Símbolo de Demonstrabilidade (Turnstile)",
    "text": "5.7 O Símbolo de Demonstrabilidade (Turnstile)\nAntes de apresentarmos nossas primeiras provas formais, precisamos introduzir um símbolo fundamental na teoria da demonstração: o turnstile ou catraca em português ou ainda, formalmente, símbolo de demonstrabilidade, representado por \\(\\vdash\\).\nO que significa \\(\\vdash\\)?\nO símbolo \\(\\vdash\\) (lê-se “demonstra” ou “deriva”) indica que uma fórmula pode ser demonstrada ou derivada dentro de um sistema formal específico. É um símbolo metalinguístico - ele fala sobre o que podemos fazer no sistema, não é parte das fórmulas em si.\nDiferentes usos do símbolo:\n\nTeorema sem hipóteses: \\(\\vdash A\\)\nSignifica: “A fórmula \\(A\\) é um teorema” (pode ser demonstrada usando apenas axiomas e regras de inferência)\nDerivação com hipóteses: \\(B_1, B_2, ..., B_n \\vdash A\\)\nSignifica: “A partir das hipóteses \\(B_1, B_2, ..., B_n\\), podemos demonstrar \\(A\\)”\nCom sistema específico: \\(\\vdash_{\\mathfrak{L}} A\\)\nSignifica: “A fórmula \\(A\\) é demonstrável no sistema \\(\\mathfrak{L}\\)”\n\nExemplos ilustrativos:\n\n\\(P, P \\rightarrow Q \\vdash Q\\)\n“Das hipóteses \\(P\\) e \\(P \\rightarrow Q\\), podemos demonstrar \\(Q\\)” (isso é o Modus Ponens)\n\\(\\vdash (A \\rightarrow A)\\)\n“A fórmula \\(A \\rightarrow A\\) é um teorema” (pode ser provada sem hipóteses adicionais)\n\\(A \\rightarrow B, B \\rightarrow C \\vdash A \\rightarrow C\\)\n“Das hipóteses \\(A \\rightarrow B\\) e \\(B \\rightarrow C\\), podemos demonstrar \\(A \\rightarrow C\\)”\n\nDiferença importante:\n\n\\(P \\rightarrow Q\\) é uma fórmula da lógica proposicional (objeto da linguagem)\n\\(P \\vdash Q\\) é uma afirmação sobre demonstrabilidade (metalinguagem)\n\nA primeira é uma implicação que pode ser verdadeira ou falsa em uma interpretação. A segunda afirma que existe uma sequência de passos dedutivos que vai de \\(P\\) até \\(Q\\).\nConvenção: Quando o sistema é claro pelo contexto, omitimos o subscrito. Assim, \\(\\vdash A\\) geralmente significa \\(\\vdash_{\\mathfrak{L}} A\\) quando estamos trabalhando no sistema \\(\\mathfrak{L}\\).\nCom esta notação estabelecida, podemos agora formalizar o conceito de teorema: uma fórmula \\(A\\) é um teorema do sistema \\(\\mathfrak{L}\\) se, e somente se, \\(\\vdash_{\\mathfrak{L}} A\\).\nNos resta apenas destacar a última linha de uma prova. No sistema \\(\\mathfrak{L}\\), a última fórmula será chamada de teorema. Representaremos como \\(\\vdash A\\) se \\(A\\) for um teorema. Escrevemos \\(B_1, B_2, ..., B_n \\vdash_L A\\) se, e somente se, \\(A\\) puder ser provado em \\(\\mathfrak{L}\\) a partir das fórmulas dadas \\(B_1, B_2, ..., B_n\\). Nesse caso:\n\n\\(A\\): Fórmula que é um teorema;\n\\(g_1, ..., g_n\\): Fórmulas que servem como premissas;\n\\(\\vdash_L\\): Símbolo para indicar demonstrável em \\(\\mathfrak{L}\\);\nescrevemos \\(\\mathfrak{L} A\\) para indicar que \\(A\\) é demonstrável no sistema \\(\\mathfrak{L}\\).\n\n\n5.7.1 Notação para Substituição em Provas\nAntes de iniciarmos nossas provas no sistema \\(\\mathfrak{L}\\), é importante esclarecer uma notação que usaremos por conveniência. Ao trabalhar com axiomas e teoremas, frequentemente precisamos indicar que estamos substituindo variáveis proposicionais por fórmulas específicas.\nNotação de Substituição: Usaremos o símbolo \\(:=\\) para indicar substituição. Este símbolo não faz parte do alfabeto da lógica proposicional - é apenas uma ferramenta metalinguística (uma notação sobre a linguagem, não dentro dela) que nos ajuda a explicar como estamos aplicando axiomas.\nQuando escrevemos \\(A := P\\), estamos dizendo: “onde aparece a variável \\(A\\) no axioma, substitua por \\(P\\)”.\nExemplo de uso: Considere o Axioma 1: \\(A \\rightarrow (B \\rightarrow A)\\)\nSe quisermos usar este axioma com proposições específicas, podemos escrever: - Com \\(A := P\\) e \\(B := Q\\), obtemos: \\(P \\rightarrow (Q \\rightarrow P)\\) - Com \\(A := (P \\land Q)\\) e \\(B := R\\), obtemos: \\((P \\land Q) \\rightarrow (R \\rightarrow (P \\land Q))\\)\nImportante: Esta é uma convenção notacional para facilitar a leitura. Formalmente, estamos criando uma instância do axioma - aplicando o esquema axiomático a fórmulas específicas. O símbolo \\(:=\\) é nossa forma concisa de indicar essa instanciação.\nAlternativamente, poderíamos dizer “substituindo \\(A\\) por…” ou “com \\(A\\) sendo…”, mas \\(:=\\) torna as provas mais claras e concisas. É uma licença pedagógica que tomamos para melhorar a legibilidade, similar a quando dizemos “seja \\(x\\) um número” em vez de usar quantificadores formais em textos introdutórios.\nAgora que temos uma notação adequada, podemos prosseguir com nossas provas, usando esta notação quando necessário.\nProva 1: nosso teorema é \\(A \\rightarrow A\\)\n\n\\(A \\rightarrow ((A \\rightarrow A) \\rightarrow A)\\) (Axioma 1 com \\(A := A\\) e \\(B := (A \\rightarrow A)\\))\nAqui usamos o primeiro axioma de \\(\\mathfrak{L}\\), que tem a forma \\((A \\rightarrow (B \\rightarrow A))\\). Para tanto usamos \\(A := A\\) e \\(B := (A \\rightarrow A)\\) para fazer a correspondência com o axioma, obtendo a fórmula na linha. Observe que usamos o símbolo \\(:=\\), um símbolo que não faz parte do nosso alfabeto e aqui está sendo usado com o sentido substituído por. Até na matemática usamos licenças poéticas.\n\\((A \\rightarrow ((A \\rightarrow A) \\rightarrow A)) \\rightarrow ((A \\rightarrow (A \\rightarrow A)) \\rightarrow (A \\rightarrow A))\\) (Axioma 2 com \\(A := A\\), \\(B := (A \\rightarrow A)\\) e $ c := A$)\nA segunda linha usa o segundo axioma de \\(\\mathfrak{L}\\), que é \\((A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\rightarrow B) \\rightarrow (A \\rightarrow C))\\). O autor substituiu \\(A := A\\), \\(B := (A \\rightarrow A)\\) e $ c := A$ para obter a fórmula na linha.\n\\(((A \\rightarrow (A \\rightarrow A)) \\rightarrow (A \\rightarrow A))\\) (Modus Ponens aplicado às linhas 1 e 2)\nFinalmente aplicamos a regra de Modus Ponens, que diz que se temos \\(A\\) e também temos \\(A \\rightarrow B\\), então podemos deduzir \\(B\\). As linhas 1 e 2 correspondem a \\(A\\) e \\(A \\rightarrow B\\), respectivamente, e ao aplicar Modus Ponens, obtemos \\(B\\), que é a fórmula na linha 3.\n\\((A \\rightarrow (A \\rightarrow A))\\) (Axioma 1 com \\(A := A\\) e \\(B := A\\))\nDe forma similar à primeira linha, a quarta linha usa o primeiro axioma com \\(A := A\\) e \\(B := A\\).\n\\((A \\rightarrow A)\\)(Modus Ponens aplicado às linhas 3 e 4)\nFinalmente, aplicamos o Modus Ponens às linhas 3 e 4 para obter a fórmula na última linha, que é o teorema que tentamos provar.\nEntão, o primeiro teorema está correto e podemos escrever \\(\\vdash \\mathfrak{L} A\\).\n\nProva 2: Vamos provar \\(\\vdash (\\lnot B \\rightarrow B) \\rightarrow B\\)\nPara esta prova, utilizaremos o Teorema 1 (\\(\\vdash A \\rightarrow A\\)) como um lema e o Axioma 3.\nRecordando o Axioma 3: \\((\\lnot X \\rightarrow \\lnot Y) \\rightarrow ((\\lnot X \\rightarrow Y) \\rightarrow X)\\)\nDemonstração:\n\n\\(\\lnot B \\rightarrow \\lnot B\\)\n(Lema: Teorema 1 com \\(A := \\lnot B\\))\nJustificativa: Como já provamos que \\(A \\rightarrow A\\) é um teorema, podemos usá-lo substituindo \\(A\\) por \\(\\lnot B\\).\n\\((\\lnot B \\rightarrow \\lnot B) \\rightarrow ((\\lnot B \\rightarrow B) \\rightarrow B)\\)\n(Instância do Axioma 3 com \\(X := B\\) e \\(Y := B\\))\nJustificativa: Substituindo no Axioma 3:\n\nOnde temos \\(\\lnot X\\), colocamos \\(\\lnot B\\)\nOnde temos \\(\\lnot Y\\), colocamos \\(\\lnot B\\)\n\nOnde temos \\(Y\\), colocamos \\(B\\)\nOnde temos \\(X\\), colocamos \\(B\\)\n\nAssim: \\((\\lnot B \\rightarrow \\lnot B) \\rightarrow ((\\lnot B \\rightarrow B) \\rightarrow B)\\)\n\\(((\\lnot B \\rightarrow B) \\rightarrow B)\\)\n(Modus Ponens aplicado às linhas 1 e 2)\nJustificativa: A linha 1 nos dá \\(\\lnot B \\rightarrow \\lnot B\\), que é exatamente o antecedente da implicação na linha 2. Aplicando Modus Ponens, obtemos o consequente.\n\nPortanto, provamos \\(\\vdash (\\lnot B \\rightarrow B) \\rightarrow B\\).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#explorando-as-limitações-do-sistema-mathfrakl",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#explorando-as-limitações-do-sistema-mathfrakl",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.8 Explorando as Limitações do Sistema \\(\\mathfrak{L}\\)",
    "text": "5.8 Explorando as Limitações do Sistema \\(\\mathfrak{L}\\)\nVamos tentar uma terceira prova, um pouco mais complexa e com mais nuances.\nObjetivo: Examinar por que NÃO podemos provar \\(\\vdash ((A \\land B) \\rightarrow C)\\) no sistema \\(\\mathfrak{L}\\).\nEsta seção é fundamental para entender as limitações de sistemas formais. Vamos analisar uma tentativa de prova que falha, e explicar por que isso ocorre.\n\n5.8.1 Tentativa (INVÁLIDA) de Demonstração\nAlguém poderia tentar provar \\(((A \\land B) \\rightarrow C)\\) assim:\n\n\\((A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\land B) \\rightarrow C)\\) ❌ [ERRO: Isto NÃO é um axioma de \\(\\mathfrak{L}\\)]\n\\(A \\rightarrow (B \\rightarrow C)\\) (Hipótese)\n\\((A \\land B) \\rightarrow C\\) (Tentativa de aplicar Modus Ponens às linhas 1 e 2) ❌ [INVÁLIDO]\n\n\n\n5.8.2 Por Que Esta Prova Falha?\n1. Limitação Fundamental: O sistema \\(\\mathfrak{L}\\) trabalha apenas com os conectivos \\(\\rightarrow\\) (implicação) e \\(\\lnot\\) (negação). O conectivo \\(\\land\\) (conjunção) não é primitivo neste sistema.\n2. Ausência de Axiomas para Conjunção: Os três axiomas de \\(\\mathfrak{L}\\) não fornecem nenhuma regra para manipular o conectivo \\(\\land\\). Observe:\n\nAxioma 1: Lida apenas com implicações;\nAxioma 2: Distribui implicações sobre implicações;\nAxioma 3: Relaciona negação e implicação.\n\nNenhum deles menciona ou permite derivar propriedades da conjunção.\n3. Problema da Linha 2: Mesmo que a linha 1 fosse válida (não é), a linha 2 introduz uma hipótese que não pode ser descartada adequadamente no sistema \\(\\mathfrak{L}\\) básico. Para trabalhar com hipóteses temporárias, precisaríamos do Teorema da Dedução, que não está disponível na versão básica do sistema.\n\n\n5.8.3 Verificação pela Tabela Verdade\nVamos verificar se \\((A \\land B) \\rightarrow C\\) é sequer uma tautologia:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nA & B & C & A \\land B & (A \\land B) \\rightarrow C \\\\\n\\hline\nT & T & T & T & T \\\\\nT & T & F & T & F \\\\\nT & F & T & F & T \\\\\nT & F & F & F & T \\\\\nF & T & T & F & T \\\\\nF & T & F & F & T \\\\\nF & F & T & F & T \\\\\nF & F & F & F & T \\\\\n\\hline\n\\end{array}\n\\]\nComo vemos, \\((A \\land B) \\rightarrow C\\) não é uma tautologia - é falsa quando \\(A\\) e \\(B\\) são verdadeiros mas \\(C\\) é falso. Portanto, não deveria ser demonstrável em nenhum sistema correto.\n\n\n5.8.4 Como Sistemas Mais Ricos Resolvem Isso\n1. Adicionando Axiomas para Conjunção: Sistemas como o cálculo proposicional clássico incluem axiomas específicos para \\(\\land\\):\n\n\\((A \\land B) \\rightarrow A\\) (eliminação da conjunção, esquerda);\n\\((A \\land B) \\rightarrow B\\) (eliminação da conjunção, direita);\n\\(A \\rightarrow (B \\rightarrow (A \\land B))\\) (introdução da conjunção).\n\n2. Definindo Conjunção via Outros Conectivos: Em alguns sistemas, podemos definir:\n\n\\(A \\land B \\equiv \\lnot(\\lnot A \\lor \\lnot B)\\) (Lei de De Morgan);\nMas isso requer também axiomas para disjunção (\\(\\lor\\)).\n\n3. Sistemas de Dedução Natural: Incluem regras específicas de introdução e eliminação para cada conectivo, tornando as provas mais intuitivas.\n\n\n5.8.5 Incompletude vs. Incorreção\nÉ importante que a curiosa leitora entenda a diferença:\nIncompletude: O sistema \\(\\mathfrak{L}\\) é incompleto para a lógica proposicional com todos os conectivos. Existem tautologias (como \\((P \\lor \\lnot P)\\)) que não podem ser provadas nele porque o sistema não tem ferramentas para lidar com disjunção.\nIncorreção: Se o sistema permitisse provar fórmulas que não são tautologias (como \\((A \\land B) \\rightarrow C\\)), ele seria incorreto. Felizmente, \\(\\mathfrak{L}\\) é correto - tudo que pode ser provado nele é de fato uma tautologia.\nCompletude Relativa: O sistema \\(\\mathfrak{L}\\) é completo para o fragmento implicacional da lógica proposicional - toda tautologia que usa apenas \\(\\rightarrow\\) e \\(\\lnot\\) pode ser provada nele.\n\n\n5.8.6 Lição Importante\nEsta tentativa falha de prova ilustra que:\n\nNem toda fórmula bem formada pode ser provada em um sistema formal;\nA escolha de axiomas e conectivos primitivos determina o poder expressivo do sistema;\nUm sistema pode ser correto mas incompleto;\nPara trabalhar com todos os conectivos lógicos, precisamos de sistemas mais ricos.\n\nO sistema \\(\\mathfrak{L}\\), apesar de suas limitações, é valioso pedagogicamente porque demonstra conceitos fundamentais de sistemas formais de forma simples e elegante. Esta última tentativa de prova é interessante. Para o teorema \\((A \\wedge B) \\rightarrow C\\), não é possível provar diretamente no sistema \\(\\mathfrak{L}\\) sem a presença de axiomas adicionais ou a introdução de hipóteses adicionais. Que não fazem parte do sistema \\(\\mathfrak{L}\\).\nO sistema \\(\\mathfrak{L}\\) é baseado em axiomas específicos (que utilizam os conectivos \\(\\rightarrow\\) e \\(\\lnot\\)) e em uma única regra de inferência (Modus Ponens), como vimos. O teorema \\(((A \\wedge B) \\rightarrow C)\\) não pode ser derivado diretamente apenas a partir dos axiomas do sistema \\(\\mathfrak{L}\\) porque o conectivo de conjunção (\\(\\wedge\\)) não é primitivo no sistema \\(\\mathfrak{L}\\) e não pode ser definido ou introduzido usando apenas os axiomas fornecidos e o Modus Ponens sem regras adicionais ou definições para \\(\\wedge\\). Os axiomas de \\(\\mathfrak{L}\\) focam na implicação e na negação.\nSe tivéssemos acesso a axiomas ou regras de inferência adicionais que lidam com a conjunção, ou se você tem permissão para introduzir hipóteses adicionais (por exemplo, você pode introduzir \\(A \\wedge B \\rightarrow C\\) como uma hipótese), então a prova pode ser possível. Em alguns sistemas de lógica, a conjunção pode ser definida em termos de negação e disjunção, e neste caso, o teorema pode ser provável.\nCom as ferramentas que vimos até agora, podemos tentar provar o teorema \\(((A \\wedge B) \\rightarrow C)\\) usando uma Tabela Verdade:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\nA & B & C & A \\wedge B & (A \\wedge B) \\rightarrow C \\\\\n\\hline\nT & T & T & T & T \\\\\nT & T & F & T & F \\\\\nT & F & T & F & T \\\\\nT & F & F & F & T \\\\\nF & T & T & F & T \\\\\nF & T & F & F & T \\\\\nF & F & T & F & T \\\\\nF & F & F & F & T \\\\\n\\hline\n\\end{array}\n\\]\nComo podemos ver, a coluna final, que representa o teorema \\((A \\wedge B) \\rightarrow C\\), não é sempre verdadeira. Isso significa que a proposição \\((A \\wedge B) \\rightarrow C\\) não é uma tautologia, existe uma situação, quando \\(A\\) e \\(B\\) são verdadeiros, mas \\(C\\) é falso, em que a proposição inteira é falsa. Basta isso para que a proposição não seja uma tautologia e, portanto, não possa ser provada como um teorema.\nA nossa terceira prova mostra os limites do sistema \\(\\mathfrak{L}\\), o que pode dar uma falsa impressão sobre o a capacidade deste sistema de prova. Vamos tentar melhorar isso.\n\n\n5.8.7 Lema\nVamos lembrar a primeira prova, provamos \\(A \\rightarrow A\\) e, a partir deste momento, \\(A \\rightarrow A\\) se tornou um Lema. Um lema é uma afirmação que é provada não como um fim em si mesma, mas como um passo útil para a prova de outros teoremas.\nEm outras palavras, um lema é um resultado menor que serve de base para um resultado maior. Uma vez que um lema é provado, ele pode ser usado em provas subsequentes de teoremas mais complexos. Em geral, um lema é menos geral e menos notável do que um teorema.\nConsidere o seguinte Teorema: \\(\\vdash_L (\\lnot B \\rightarrow B) \\rightarrow B\\), podemos prová-lo da seguinte forma:\n\n\\(\\lnot B \\rightarrow \\lnot B\\) - Lembrando que \\(A := \\lnot B\\) do Teorema 1\n\\((\\lnot B \\rightarrow \\lnot B) \\rightarrow ((\\lnot B \\rightarrow B) \\rightarrow B)\\) - Decorrente do Axioma 3, em que \\(A := \\lnot B\\) e \\(B := B\\)\n\\(((\\lnot B \\rightarrow B) \\rightarrow B)\\)- Através do Modus Ponens Justificativa: Linhas 1 e 2\n\nA adoção de lemas é, na verdade, um mecanismo útil para economizar tempo e esforço. Ao invés de replicar o Teorema 1 na primeira linha dessa prova, nós poderíamos, alternativamente, copiar as 5 linhas da prova original do Teorema 1, substituindo todos os casos de \\(A\\) Por \\(\\lnot B\\). As justificativas seriam mantidas iguais às da prova original do Teorema 1. A prova resultante, então, consistiria exclusivamente de axiomas e aplicações do Modus Ponens. No entanto, uma vez que a prova do Teorema 1 já foi formalmente documentada, parece redundante replicá-la aqui. E eis o motivo da existência e uso dos lemas.\n\n\n5.8.8 Hipóteses\nHipóteses são suposições ou proposições feitas como base para o raciocínio, sem a suposição de sua veracidade. Elas são usadas como pontos de partida para investigações ou pesquisas científicas. Essencialmente uma hipótese é uma teoria ou ideia que você pode testar de alguma forma. Isso significa que, através de experimentação e observação, uma hipótese pode ser provada verdadeira ou falsa.\nPor exemplo, se você observar que uma planta está morrendo, pode formar a hipótese de que ela não está recebendo água suficiente. Para testar essa hipótese, você pode dar mais água à planta e observar se ela melhora. Se melhorar, isso suporta sua hipótese. Se não houver mudança, isso sugere que sua hipótese pode estar errada, e você pode então formular uma nova hipótese para testar.\nNa Lógica Proposicional, uma hipótese é uma proposição (ou afirmação) que é assumida como verdadeira para o propósito de argumentação ou investigação. Obviamente, pode ser uma fórmula atômica, ou complexa, desde que seja uma Fórmula Bem Formada.\nEm um sistema formal de provas, como o sistema \\(\\mathfrak{L}\\) uma hipótese é um ponto de partida para um processo de dedução. O objetivo é usar as regras do sistema para deduzir novas proposições a partir das hipóteses. Se uma proposição puder ser deduzida a partir das hipóteses usando as regras do sistema, dizemos que essa proposição é uma consequência lógica das hipóteses. Se temos as hipóteses \\(P\\) e \\(P\\rightarrow Q\\), podemos deduzir \\(Q\\) usando o Modus Ponens. Nesse caso, \\(Q\\) seria uma consequência lógica das hipóteses.\nNo contexto do sistema de provas \\(\\mathfrak{L}\\) e considerando apenas a Lógica Proposicional, uma hipótese é uma proposição ou conjunto de proposições assumidas como verdadeiras, a partir das quais outras proposições podem ser logicamente deduzidas.\nExemplo 1: considere o seguinte argumento:\n\\[\n\\begin{align*}\nA \\rightarrow (B \\rightarrow C) \\\\\nA \\rightarrow B \\\\\n\\hline\nA \\rightarrow C\n\\end{align*}\n\\]\nAplicando o processo de dedução do Sistema \\(\\mathfrak{L}\\), teremos:\n\\[\n\\begin{align*}\n& A \\rightarrow (B \\rightarrow C) &\\text{Hipótese} \\\\\n& A \\rightarrow B &\\text{Hipótese}\\\\\n& (A \\rightarrow (B \\rightarrow C)) \\rightarrow ((A \\rightarrow B) \\rightarrow (A \\rightarrow C)) &\\text{Axioma 2}\\\\\n& (A \\rightarrow B) \\rightarrow (A \\rightarrow C) & \\text{Modus Ponens, linhas 1 e 3} \\\\\n& A \\rightarrow C & \\text{Modus Ponens, linhas 2 e 4}\\\\\n\\end{align*}\n\\]\nNeste exemplo, vemos o uso das Hipóteses. No processo de dedução, as hipóteses devem ser usadas na forma como são declaradas. O que as torna diferentes dos lemas.\nNeste ponto, podemos voltar um pouco e destacar um constructor importante na programação imperativa: se…então representando por \\(P\\rightarrow Q\\), uma implicação. Que pode ser lido como hipótese \\(P\\) e conclusão \\(Q\\).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#análise-de-argumentos-lógicos-em-textos-do-cotidiano",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.9 Análise de Argumentos Lógicos em Textos do Cotidiano",
    "text": "5.9 Análise de Argumentos Lógicos em Textos do Cotidiano\nUma das coisas mais importantes que a amável leitora irá aprender neste documento é que a lógica não é apenas uma disciplina acadêmica, mas uma ferramenta poderosa para analisar e compreender argumentos em textos do cotidiano. A lógica nos ajuda a identificar premissas e conclusões, avaliar a validade de argumentos e entender como as ideias estão interconectadas. A lógica é útil e pode ser a diferença entre um argumento persuasivo e um argumento falacioso. Além disso, o uso da lógica para entender textos do cotidiano criará as estruturas cognitivas necessários para a construção de soluções computacionais para os problemas mais complexos da atualidade.\nA análise de argumentos lógicos em textos do cotidiano envolve a identificação de premissas e conclusões, bem como a formalização dessas relações em Lógica Proposicional ou lógica de predicados.\nDeste ponto tem diante, caberá a esforçada leitora, aplicar os conceitos aprendidos neste documento para analisar textos de livros, notícias, especificações de sistemas e outros documentos. Comece vendo os textos de exemplo a seguir.\n\n5.9.1 Exemplo 1: Avanço Científico na Medicina (2022)\n“Em 2022, pesquisadores descobriram que a vacina contra a malária aprovada pela Organização Mundial da Saúde pode ajudar a salvar centenas de milhares de vidas por ano. É também a primeira vacina do mundo para uma infecção parasitária. A malária mata mais de 600.000 pessoas anualmente, a maioria crianças menores de cinco anos.”\n\n5.9.1.1 Premissas e Conclusão\nPremissas:\n\nA malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\nA vacina contra a malária foi aprovada pela Organização Mundial da Saúde;\nA vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária.\n\nConclusão:\n\nA vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\n\n\n5.9.1.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A malária mata mais de 600.000 pessoas anualmente, majoritariamente crianças menores de cinco anos;\n\\(Q\\): A vacina contra a malária foi aprovada pela OMS;\n\\(R\\): A vacina contra a malária é a primeira vacina do mundo para uma infecção parasitária;\n\\(S\\): A vacina contra a malária pode ajudar a salvar centenas de milhares de vidas por ano.\n\nEstrutura do argumento: \\((P \\wedge Q \\wedge R) \\rightarrow S\\)\nLógica de Predicados:\n\n\\(m\\): malária;\n\\(v\\): vacina contra a malária;\n\\(Mata(x, y)\\): x mata y pessoas anualmente;\n\\(MajoriaCriancas(x)\\): a maioria das vítimas de x são crianças menores de cinco anos;\n\\(Aprovada(x)\\): x foi aprovada pela OMS;\n\\(Primeira(x)\\): x é a primeira vacina para infecção parasitária;\n\\(PodeSalvar(x, y)\\): x pode salvar y vidas por ano.\n\nFormalização:\n\n\\(Mata(m, 600000) \\wedge MajoriaCriancas(m)\\);\n\\(Aprovada(v)\\);\n\\(Primeira(v)\\);\n\\([Mata(m, 600000) \\wedge MajoriaCriancas(m) \\wedge Aprovada(v) \\wedge Primeira(v)] \\rightarrow PodeSalvar(v, \\text{\"centenas de milhares\"})\\).\n\n\n\n5.9.1.3 Análise da Validade\nEste argumento não segue uma forma lógica estritamente válida. A relação entre as premissas e a conclusão depende de conhecimentos médicos implícitos.\nEstrutura implícita:\n\nSe uma doença mata muitas pessoas e existe uma vacina aprovada contra essa doença, então essa vacina pode salvar muitas vidas;\nA malária mata muitas pessoas;\nExiste uma vacina aprovada contra a malária;\nLogo, a vacina contra a malária pode salvar muitas vidas.\n\nEsta estrutura se aproxima de um modus ponens, mas depende de uma premissa implícita.\n\n\n5.9.1.4 Análise da Solidez\nAs premissas são verificáveis e consideradas verdadeiras:\n\nA mortalidade por malária é confirmada por dados epidemiológicos da OMS;\nA aprovação da vacina pela OMS é um fato verificável;\nSer a primeira vacina para infecção parasitária é historicamente verificável.\n\nA conclusão é razoável no contexto médico, mas sua solidez completa dependeria de dados específicos sobre a eficácia da vacina.\n\n\n\n5.9.2 Exemplo 2: Inovação Tecnológica Nuclear (2023)\n“O campo da fusão nuclear teve um grande avanço em 2023. A fusão nuclear é uma reação nuclear que produz uma grande quantidade de calor que pode ser usada para gerar energia. É o mesmo processo que alimenta o sol. A reação nuclear é produzida por dois núcleos atômicos leves que se combinam e formam um único núcleo atômico leve mais pesado. Isso produz uma grande quantidade de energia.”\n\n5.9.2.1 Premissas e Conclusão\nPremissas:\n\nA fusão nuclear é uma reação que ocorre quando dois núcleos atômicos leves se combinam formando um único núcleo mais pesado.\nEsta reação produz grande quantidade de calor.\nO calor pode ser usado para gerar energia.\nA fusão nuclear é o mesmo processo que alimenta o sol.\n\nConclusão:\n\nO campo da fusão nuclear teve um grande avanço em 2023.\n\n\n\n5.9.2.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): A fusão nuclear é uma reação em que núcleos leves se combinam formando um núcleo mais pesado.\n\\(Q\\): A fusão nuclear produz grande quantidade de calor.\n\\(R\\): O calor pode ser usado para gerar energia.\n\\(S\\): A fusão nuclear é o mesmo processo que alimenta o sol.\n\\(T\\): O campo da fusão nuclear teve um grande avanço em 2023.\n\nEstrutura do argumento: \\((P \\wedge Q \\wedge R \\wedge S) \\rightarrow T\\)\nLógica de Predicados:\n\n\\(FusaoNuclear(x)\\): \\(x\\) é um processo de fusão nuclear.\n\\(Reacao(x, y, z)\\): \\(x\\) é uma reação em que \\(y\\) se combina formando \\(z\\).\n\\(Produz(x, y)\\): \\(x\\) produz \\(y\\).\n\\(PodeGerarEnergia(x)\\): \\(x\\) pode ser usado para gerar energia.\n\\(AlimentaSol(x)\\): \\(x\\) é o processo que alimenta o sol.\n\\(TeveAvanco(x, y, z)\\): o campo \\(x\\) teve um avanço de grau \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Reacao(x, \\text{\"núcleos leves\"}, \\text{\"núcleo mais pesado\"})]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow Produz(x, \\text{\"grande quantidade de calor\"})]\\);\n\\(\\forall x [Produz(x, \\text{\"grande quantidade de calor\"}) \\rightarrow PodeGerarEnergia(x)]\\);\n\\(\\forall x [FusaoNuclear(x) \\rightarrow AlimentaSol(x)]\\);\n\\(TeveAvanco(\\text{\"campo da fusão nuclear\"}, \\text{\"grande\"}, 2023)\\).\n\n\n\n5.9.2.3 Análise da Validade\nEste argumento apresenta uma estrutura incomum, pois a conclusão não é derivada logicamente das premissas apresentadas. As premissas descrevem o que é a fusão nuclear e suas características, mas não estabelecem uma relação lógica com o avanço mencionado.\nSob análise de dedução natural, o argumento não é válido, pois a conclusão não é uma consequência lógica das premissas fornecidas.\n\n\n5.9.2.4 Análise da Solidez\nComo o argumento não é formalmente válido, não pode ser considerado sólido. Entretanto, suas premissas descritivas são majoritariamente verdadeiras:\n\nA definição de fusão nuclear como combinação de núcleos leves é cientificamente precisa.\nA produção de calor e seu potencial energético são verdadeiros.\nA fusão nuclear realmente alimenta o sol.\n\n\n\n\n5.9.3 Exemplo 3: Economia Global (2023)\n“As economias avançadas devem desacelerar de 2,6% em 2022 para 1,5% em 2023 e 1,4% em 2024, à medida que o aperto da política começa a surtir efeito. A inflação global deverá diminuir constantemente, de 8,7% em 2022 para 6,9% em 2023 e 5,8% em 2024, devido a uma política monetária mais rígida auxiliada por preços mais baixos das commodities internacionais.”\n\n5.9.3.1 Premissas e Conclusão\nPremissas:\n\nO aperto da política (monetária) está começando a surtir efeito;\nEstá sendo implementada uma política monetária mais rígida;\nOs preços das commodities internacionais estão mais baixos.\n\nConclusões:\n\nAs economias avançadas devem desacelerar de \\(2,6\\%\\) em 2022 para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\nA inflação global deverá diminuir constantemente, de \\(8,7\\%\\) em 2022 para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\n\n\n5.9.3.2 Formalização Lógica\nLógica Proposicional:\n\n\\(P\\): O aperto da política monetária está surtindo efeito;\n\\(Q\\): Está sendo implementada uma política monetária mais rígida;\n\\(R\\): Os preços das commodities internacionais estão mais baixos;\n\\(S\\): As economias avançadas desacelerarão para \\(1,5\\%\\) em 2023 e \\(1,4\\%\\) em 2024;\n\\(T\\): A inflação global diminuirá para \\(6,9\\%\\) em 2023 e \\(5,8\\%\\) em 2024.\n\nEstrutura do argumento: \\((P \\wedge Q \\wedge R) \\rightarrow (S \\wedge T)\\)\nLógica de Predicados:\n\n\\(ApertoSurteEfeito(x)\\): o aperto da política monetária \\(x\\) está surtindo efeito;\n\\(PoliticaRigida(x)\\): \\(x\\) é uma política monetária rígida;\n\\(PrecosBaixos(x)\\): os preços de \\(x\\) estão baixos;\n\\(Desacelerar(x, y, z)\\): a economia \\(x\\) desacelerará para taxa \\(y\\) no ano \\(z\\);\n\\(DiminuirInflacao(x, y, z)\\): a inflação \\(x\\) diminuirá para taxa \\(y\\) no ano \\(z\\).\n\nFormalização:\n\n\\(ApertoSurteEfeito(\\text{\"política monetária\"})\\);\n\\(PoliticaRigida(\\text{\"política monetária atual\"})\\);\n\\(PrecosBaixos(\\text{\"commodities internacionais\"})\\);\n\\([ApertoSurteEfeito(\\text{\"política monetária\"}) \\wedge PoliticaRigida(\\text{\"política monetária atual\"})] \\rightarrow Desacelerar(\\text{\"economias avançadas\"}, 1.5\\%, 2023) \\wedge Desacelerar(\\text{\"economias avançadas\"}, 1.4\\%, 2024)\\);\n\\([PoliticaRigida(\\text{\"política monetária atual\"}) \\wedge PrecosBaixos(\\text{\"commodities internacionais\"})] \\rightarrow DiminuirInflacao(\\text{\"global\"}, 6.9\\%, 2023) \\wedge DiminuirInflacao(\\text{\"global\"}, 5.8\\%, 2024)\\).\n\n\n\n5.9.3.3 Análise da Validade\nEste argumento segue uma estrutura causal que pode ser analisada pela forma lógica:\n\nSe \\(X\\) causa \\(Y\\), e \\(X\\) está ocorrendo, então \\(Y\\) ocorrerá;\n\\(X\\) está ocorrendo;\nPortanto, \\(Y\\) ocorrerá.\n\nEsta estrutura segue o padrão de modus ponens, que é uma forma de argumento válida.\n\n\n5.9.3.4 Análise da Solidez\nA validade lógica do argumento foi estabelecida, mas sua solidez depende da veracidade das premissas:\n\nA eficácia do aperto monetário é uma afirmação empírica que requer verificação com dados econômicos;\nA implementação de política monetária mais rígida era geralmente verdadeira no contexto de 2023;\nA afirmação sobre preços mais baixos de commodities depende do período específico e das commodities consideradas.\n\nAs conclusões são previsões específicas cuja solidez dependeria da veracidade das premissas, da robustez dos modelos econômicos e da ausência de fatores externos imprevistos.\nEm economia, relações causais são geralmente probabilísticas, tornando a solidez do argumento contingente a condições específicas.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "03-arte-da-prova-e-analise-de-argumentos.html#exercícios-de-análise-de-argumentos-lógicos",
    "href": "03-arte-da-prova-e-analise-de-argumentos.html#exercícios-de-análise-de-argumentos-lógicos",
    "title": "5  A Arte da Prova e Análise de Argumentos",
    "section": "5.10 Exercícios de Análise de Argumentos Lógicos",
    "text": "5.10 Exercícios de Análise de Argumentos Lógicos\nObjetivo: aplicar técnicas de Lógica Proposicional e de predicados para analisar descrições e especificações de sistemas computacionais, traduzindo-as para a linguagem formal e avaliando sua consistência lógica como base para decisões de implementação.\nDescrição: na engenharia de software, especificações e requisitos de sistemas são frequentemente descritos em linguagem natural, o que pode levar a ambiguidades, inconsistências e interpretações equivocadas. A análise lógica formal dessas descrições pode ajudar a identificar tais problemas e proporcionar uma base sólida para o desenvolvimento de soluções computacionais. Nesta tarefa, você atuará como “Arquiteto Lógico de Sistemas” para traduzir especificações em linguagem natural para modelos lógicos formais.\n\n5.10.1 Exercício 1: Sistema de Autenticação Biométrica\nFragmento de Texto Original: O sistema de autenticação biométrica deve permitir o acesso a usuários autorizados por meio de reconhecimento facial ou impressão digital. Se um usuário não conseguir autenticar por nenhum dos métodos biométricos, o sistema deve oferecer como alternativa a autenticação por senha. Caso ocorram três tentativas falhas consecutivas por qualquer método, o acesso do usuário deve ser temporariamente bloqueado por 30 minutos por motivos de segurança.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nUsuários autorizados podem se autenticar por reconhecimento facial;\nUsuários autorizados podem se autenticar por impressão digital;\nSe a autenticação biométrica falhar, o usuário pode usar senha;\nTrês tentativas falhas consecutivas levam ao bloqueio temporário;\nO bloqueio temporário dura 30 minutos.\n\nConclusões:\n\nO sistema deve bloquear o acesso após três tentativas falhas consecutivas;\nO sistema deve permitir múltiplos métodos de autenticação.\n\n\n5.10.1.1 Formalização Lógica\nLógica Proposicional:\n\n\\(A\\): O usuário está autorizado;\n\\(F\\): O usuário autentica com reconhecimento facial;\n\\(D\\): O usuário autentica com impressão digital;\n\\(S\\): O usuário autentica com senha;\n\\(T\\): Ocorreram três tentativas falhas consecutivas;\n\\(B\\): O acesso do usuário está bloqueado temporariamente.\n\nEstrutura do argumento:\n\n\\(A \\rightarrow (F \\vee D \\vee S)\\);\n\\(\\neg(F \\vee D) \\rightarrow S\\);\n\\(T \\rightarrow B\\).\n\nLógica de Predicados:\n\n\\(Usuario(x)\\): \\(x\\) é um usuário;\n\\(Autorizado(x)\\): \\(x\\) é autorizado;\n\\(AutenticaFacial(x)\\): \\(x\\) autentica por reconhecimento facial;\n\\(AutenticaDigital(x)\\): \\(x\\) autentica por impressão digital;\n\\(AutenticaSenha(x)\\): \\(x\\) autentica por senha;\n\\(TentativasFalhas(x, n)\\): \\(x\\) teve \\(n\\) tentativas falhas consecutivas;\n\\(Bloqueado(x, t)\\): \\(x\\) está bloqueado por \\(t\\) minutos.\n\nFormalização:\n\n\\(\\forall x [Autorizado(x) \\rightarrow (AutenticaFacial(x) \\vee AutenticaDigital(x) \\vee AutenticaSenha(x))]\\);\n\\(\\forall x [(Usuario(x) \\wedge \\neg(AutenticaFacial(x) \\vee AutenticaDigital(x))) \\rightarrow AutenticaSenha(x)]\\);\n\\(\\forall x [TentativasFalhas(x, 3) \\rightarrow Bloqueado(x, 30)]\\).\n\nAnálise da Validade: o argumento é válido em termos de Lógica Proposicional e de predicados. A estrutura segue formas lógicas válidas:\n\nA primeira relação estabelece uma disjunção inclusiva (OR) de métodos de autenticação disponíveis para usuários autorizados;\nA segunda relação segue a forma \\((P \\wedge \\neg Q) \\rightarrow R\\), que é válida: se um usuário não consegue autenticar pelos métodos biométricos, então deve poder usar senha;\nA terceira relação segue a forma \\(P \\rightarrow Q\\), um modus ponens: se ocorrerem três tentativas falhas, então o bloqueio é implementado.\n\nAnálise da Solidez:\nAs premissas são razoáveis no contexto de sistemas de autenticação modernos:\n\nA disponibilidade de múltiplos métodos de autenticação aumenta a usabilidade;\nA provisão de métodos alternativos quando os biométricos falham é uma prática comum;\nO bloqueio após múltiplas tentativas falhas é um mecanismo de segurança padrão.\n\nAs conclusões derivadas são sólidas no contexto de sistemas de autenticação e seguem práticas recomendadas de segurança digital.\n\n\n\n5.10.2 Exercício 2: Processamento de Pagamentos Online\nFragmento de Texto Original: O sistema de pagamentos online deve processar transações com cartões de crédito, cartões de débito e carteiras digitais. Quando uma transação é iniciada, o sistema verifica primeiro se há fundos suficientes. Se houver fundos suficientes, o sistema realiza a verificação de segurança. Uma transação só é aprovada se ambas as verificações forem bem-sucedidas. Caso contrário, a transação é rejeitada e o cliente recebe uma notificação com o motivo da falha.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema processa transações com cartões de crédito, cartões de débito e carteiras digitais;\nQuando uma transação é iniciada, o sistema verifica a disponibilidade de fundos;\nSe há fundos suficientes, o sistema realiza verificação de segurança;\nUma transação é aprovada apenas se as verificações de fundos e segurança forem bem-sucedidas;\nTransações rejeitadas geram notificações com o motivo da falha.\n\nConclusão:\n\nSe uma verificação de fundos ou segurança falhar, a transação será rejeitada.\n\n\n5.10.2.1 Formalização Lógica\nLógica Proposicional:\n\n\\(C\\): A transação é com cartão de crédito;\n\\(D\\): A transação é com cartão de débito;\n\\(W\\): A transação é com carteira digital;\n\\(F\\): Há fundos suficientes;\n\\(S\\): A verificação de segurança é bem-sucedida;\n\\(A\\): A transação é aprovada;\n\\(R\\): A transação é rejeitada;\n\\(N\\): O cliente recebe notificação.\n\nEstrutura do argumento:\n\n\\((C \\vee D \\vee W)\\) (A transação é feita por um dos métodos aceitos);\n\\(F \\rightarrow S\\) (Se há fundos, realiza-se verificação de segurança);\n\\((F \\wedge S) \\rightarrow A\\) (Se há fundos e a verificação de segurança é bem-sucedida, a transação é aprovada);\n\\(\\neg(F \\wedge S) \\rightarrow (R \\wedge N)\\) (Se não há fundos ou a verificação falha, a transação é rejeitada e há notificação).\n\nLógica de Predicados:\n\n\\(Transacao(x)\\): \\(x\\) é uma transação;\n\\(Metodo(x, y)\\): a transação \\(x\\) utiliza o método de pagamento \\(y\\);\n\\(TemFundos(x)\\): a transação \\(x\\) tem fundos suficientes;\n\\(VerificacaoSeguranca(x)\\): a transação \\(x\\) passa na verificação de segurança;\n\\(Aprovada(x)\\): a transação \\(x\\) é aprovada;\n\\(Rejeitada(x)\\): a transação \\(x\\) é rejeitada;\n\\(Notifica(x, y)\\): o sistema notifica o cliente sobre \\(y\\) relacionado à transação \\(x\\).\n\nFormalização:\n\n\\(\\forall x [Transacao(x) \\rightarrow (Metodo(x, \\text{\"crédito\"}) \\vee Metodo(x, \\text{\"débito\"}) \\vee Metodo(x, \\text{\"carteira digital\"}))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (TemFundos(x) \\rightarrow VerificacaoSeguranca(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow ((TemFundos(x) \\wedge VerificacaoSeguranca(x)) \\rightarrow Aprovada(x))]\\);\n\\(\\forall x [Transacao(x) \\rightarrow (\\neg(TemFundos(x) \\wedge VerificacaoSeguranca(x)) \\rightarrow (Rejeitada(x) \\wedge \\exists y Notifica(x, y)))]\\).\n\nAnálise da Validade:\nO argumento é válido logicamente. As relações causais seguem formas lógicas consistentes:\n\nA primeira premissa estabelece os métodos de pagamento aceitos, formando uma disjunção inclusiva;\nA relação entre verificação de fundos e verificação de segurança segue um fluxo condicional válido;\nA aprovação da transação requer a conjunção (AND) de condições, seguindo o padrão \\((P \\wedge Q) \\rightarrow R\\);\nA rejeição da transação ocorre pela negação da conjunção, usando a lei de De Morgan: \\(\\neg(P \\wedge Q) \\equiv \\neg P \\vee \\neg Q\\);\n\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de processamento de pagamentos:\n\nOs métodos de pagamento mencionados são comuns em sistemas reais;\nA verificação de fundos antes de processamento é uma prática padrão;\nAs verificações de segurança são essenciais em transações financeiras;\nA notificação em caso de falha é uma boa prática para experiência do usuário.\n\nA conclusão derivada é sólida e consistente com o funcionamento esperado de um sistema de pagamentos seguro e funcional.\n\n\n\n5.10.3 Exercício 3: Sistema de Gerenciamento de Estoque\nFragmento de Texto Original: “O sistema de gerenciamento de estoque deve monitorar continuamente os níveis de produtos. Quando o estoque de um produto cai abaixo do limite mínimo configurado, o sistema deve gerar automaticamente uma ordem de reabastecimento. Se o produto estiver marcado como ‘crítico’, a ordem deve ser enviada com prioridade alta. Caso contrário, a ordem segue o fluxo padrão. Qualquer produto que não tenha movimento de venda por mais de 90 dias deve ser marcado para revisão de demanda.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema monitora continuamente os níveis de estoque dos produtos;\nExiste um limite mínimo configurado para cada produto;\nOrdens de reabastecimento são geradas quando o estoque cai abaixo do limite mínimo;\nProdutos podem ser marcados como ‘críticos’;\nProdutos críticos recebem prioridade alta no reabastecimento;\nProdutos sem movimento de venda por mais de 90 dias são marcados para revisão.\n\nConclusões:\n\nSe o estoque de um produto cai abaixo do limite e o produto é crítico, uma ordem de reabastecimento com prioridade alta é gerada;\nSe o estoque de um produto cai abaixo do limite e o produto não é crítico, uma ordem de reabastecimento padrão é gerada;\nSe um produto não tem vendas por mais de 90 dias, ele deve ser revisado.\n\n\n5.10.3.1 Formalização Lógica\nLógica Proposicional:\n\n\\(M\\): O sistema monitora os níveis de estoque;\n\\(B\\): O estoque está abaixo do limite mínimo;\n\\(O\\): Uma ordem de reabastecimento é gerada;\n\\(C\\): O produto é marcado como crítico;\n\\(P\\): A ordem é enviada com prioridade alta;\n\\(F\\): A ordem segue fluxo padrão;\n\\(N\\): O produto não tem movimento de venda por mais de 90 dias;\n\\(R\\): O produto é marcado para revisão de demanda.\n\nEstrutura do argumento:\n\n\\(M\\);\n\\(B \\rightarrow O\\);\n\\((B \\wedge C) \\rightarrow (O \\wedge P)\\);\n\\((B \\wedge \\neg C) \\rightarrow (O \\wedge F)\\);\n\\(N \\rightarrow R\\).\n\nLógica de Predicados:\n\n\\(Produto(x)\\): \\(x\\) é um produto;\n\\(Monitora(x)\\): o sistema monitora o estoque de \\(x\\);\n\\(AbaixoLimite(x)\\): o estoque de \\(x\\) está abaixo do limite mínimo;\n\\(Critico(x)\\): \\(x\\) é marcado como crítico;\n\\(GeraOrdem(x, y)\\): o sistema gera uma ordem de reabastecimento para \\(x\\) com prioridade \\(y\\);\n\\(SemVendas(x, d)\\): \\(x\\) não tem vendas por \\(d\\) dias;\n\\(MarcarRevisao(x)\\): \\(x\\) é marcado para revisão de demanda.\n\nFormalização:\n\n\\(\\forall x [Produto(x) \\rightarrow Monitora(x)]\\);\n\\(\\forall x [Produto(x) \\wedge AbaixoLimite(x) \\rightarrow \\exists y \\, GeraOrdem(x, y)]\\);\n\\(\\forall x [Produto(x) \\wedge AbaixoLimite(x) \\wedge Critico(x) \\rightarrow GeraOrdem(x, \\text{\"alta\"})]\\);\n\\(\\forall x [Produto(x) \\wedge AbaixoLimite(x) \\wedge \\neg Critico(x) \\rightarrow GeraOrdem(x, \\text{\"normal\"})]\\);\n\\(\\forall x [Produto(x) \\wedge SemVendas(x, 90) \\rightarrow MarcarRevisao(x)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura segue padrões lógicos consistentes:\n\nA relação entre níveis de estoque e geração de ordens segue um modus ponens;\nA distinção entre produtos críticos e não críticos usa corretamente a conjunção e a negação;\nA condição para revisão de demanda segue uma implicação simples.\n\nAs regras de negócio são representadas por condicionais bem formados, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de gerenciamento de estoque:\n\nO monitoramento contínuo de estoque é uma funcionalidade essencial desses sistemas;\nO conceito de limite mínimo para reabastecimento é uma prática comum;\nA priorização de produtos críticos é uma estratégia logística válida;\nA revisão de produtos sem movimentação é uma prática de otimização de estoque reconhecida.\n\nAs conclusões derivadas são sólidas e refletem procedimentos operacionais padrão em gerenciamento de estoque e logística.\n\n\n\n5.10.4 Exercício 4: Sistema de Recomendação de Conteúdo\n“O sistema de recomendação deve analisar o histórico de visualizações, preferências explícitas e comportamento de navegação de cada usuário. Com base nesses dados, o sistema calcula um score de relevância para cada item de conteúdo disponível. Itens com score acima de 0,7 são recomendados ao usuário. No entanto, se o usuário já visualizou um item nos últimos 30 dias, este não deve ser recomendado novamente, independentemente do score. Adicionalmente, se o usuário deu um feedback negativo a um conteúdo similar, o score desse tipo de conteúdo deve ser reduzido em 0,3 pontos.”\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas: 1. O sistema analisa o histórico de visualizações, preferências explícitas e comportamento de navegação. 2. Um score de relevância é calculado para cada item de conteúdo. 3. Itens com score acima de 0,7 são recomendados. 4. Itens visualizados nos últimos 30 dias não são recomendados, independentemente do score. 5. Feedback negativo a conteúdo similar reduz o score em 0,3 pontos.\nConclusões: - Um item será recomendado se seu score for maior que 0,7 E não tiver sido visualizado nos últimos 30 dias. - O feedback negativo do usuário influencia o cálculo do score para itens similares.\n\n5.10.4.1 Formalização Lógica\nLógica Proposicional:\n\n\\(A\\): O sistema analisa dados do usuário.\n\\(C\\): O sistema calcula scores de relevância.\n\\(S\\): O item tem score acima de 0,7.\n\\(V\\): O item foi visualizado nos últimos 30 dias.\n\\(R\\): O item é recomendado ao usuário.\n\\(F\\): O usuário deu feedback negativo a conteúdo similar.\n\\(D\\): O score é reduzido em 0,3 pontos.\n\nEstrutura do argumento:\n\n\\(A \\rightarrow C\\)\n\\((S \\wedge \\neg V) \\rightarrow R\\)\n\\(V \\rightarrow \\neg R\\)\n\\(F \\rightarrow D\\)\n\nLógica de Predicados:\n\n\\(Usuario(u)\\): u é um usuário;\n\\(Item(i)\\): i é um item de conteúdo;\n\\(AnalisaDados(u)\\): o sistema analisa dados do usuário u;\n\\(Score(i, s)\\): o item i tem score s;\n\\(Visualizado(u, i, d)\\): o usuário u visualizou o item i nos últimos d dias;\n\\(Recomendado(u, i)\\): o item i é recomendado ao usuário u;\n\\(FeedbackNegativo(u, t)\\): o usuário u deu feedback negativo ao tipo de conteúdo t;\n\\(Similar(i, t)\\): o item i é similar ao tipo de conteúdo t;\n\\(ReducaoScore(i, v)\\): o score do item i é reduzido em v pontos.\n\nFormalização:\n\n\\(\\forall u [Usuario(u) \\rightarrow AnalisaDados(u)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\wedge Item(i) \\wedge Score(i, s) \\wedge s &gt; 0.7 \\wedge \\neg Visualizado(u, i, 30) \\rightarrow Recomendado(u, i)]\\);\n\\(\\forall u \\forall i [Usuario(u) \\wedge Item(i) \\wedge Visualizado(u, i, 30) \\rightarrow \\neg Recomendado(u, i)]\\);\n\\(\\forall u \\forall i \\forall t [Usuario(u) \\wedge Item(i) \\wedge Similar(i, t) \\wedge FeedbackNegativo(u, t) \\rightarrow ReducaoScore(i, 0.3)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. As regras de recomendação seguem formas lógicas bem definidas:\n\nA relação entre análise de dados e cálculo de scores é uma implicação simples;\nA condição para recomendação usa corretamente a conjunção entre score alto e não visualização recente;\nA exclusão de itens já visualizados é uma implicação direta;\nA redução de score baseada em feedback é uma relação causal válida.\n\nA estrutura lógica representa adequadamente as regras condicionais do sistema de recomendação.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de recomendação modernos:\n\nA utilização de histórico, preferências e comportamento de navegação é uma prática padrão;\nO uso de scores de relevância é uma abordagem quantitativa comum;\nA prevenção de recomendações repetitivas é uma boa prática de experiência do usuário;\nA consideração de feedback negativo reflete sistemas adaptativos reais.\n\nAs conclusões derivadas são sólidas e representam um sistema de recomendação funcional que equilibra relevância, novidade e preferências do usuário.\n\n\n\n5.10.5 Exercício 5: Sistema de Detecção de Fraudes\nFragmento Texto Original: “O sistema de detecção de fraudes deve analisar cada transação em tempo real. Uma transação é marcada como suspeita se atender a pelo menos um dos seguintes critérios: valor acima do padrão histórico do cliente, localização geográfica incomum, ou múltiplas tentativas em curto período de tempo. Se dois ou mais critérios forem atendidos simultaneamente, a transação é automaticamente bloqueada e enviada para revisão manual. Caso contrário, se apenas um critério for atendido, o cliente recebe uma notificação de confirmação. Se o cliente não confirmar em 5 minutos, a transação é bloqueada preventivamente”.\nSolução: A tarefa é analisar o fragmento de texto e formalizá-lo em Lógica Proposicional e lógica de predicados, identificando premissas, conclusões e avaliando a validade e solidez do argumento.\nPremissas:\n\nO sistema analisa cada transação em tempo real;\nCritérios de suspeita: valor acima do padrão, localização incomum, múltiplas tentativas;\nUma transação é suspeita se atende a pelo menos um dos critérios;\nUma transação é automaticamente bloqueada se atende a dois ou mais critérios;\nSe apenas um critério for atendido, o cliente recebe notificação para confirmação;\nSe não houver confirmação em 5 minutos, a transação é bloqueada.\n\nConclusões:\n\nSe múltiplos critérios de suspeita são atendidos, a transação é bloqueada sem intervenção do cliente;\nSe um único critério é atendido, a transação depende de confirmação do cliente;\nToda transação suspeita é ou bloqueada automaticamente ou requer confirmação.\n\n\n5.10.5.1 Formalização Lógica\nLógica Proposicional:\n\n\\(R\\): O sistema analisa transações em tempo real;\n\\(V\\): A transação tem valor acima do padrão histórico;\n\\(L\\): A transação ocorre em localização geográfica incomum;\n\\(M\\): Há múltiplas tentativas em curto período;\n\\(S\\): A transação é marcada como suspeita;\n\\(B\\): A transação é bloqueada automaticamente;\n\\(N\\): O cliente recebe notificação de confirmação;\n\\(C\\): O cliente confirma a transação em 5 minutos;\n\\(P\\): A transação é bloqueada preventivamente.\n\nEstrutura do argumento:\n\n\\((V \\vee L \\vee M) \\rightarrow S\\);\n\\([(V \\wedge L) \\vee (V \\wedge M) \\vee (L \\wedge M)] \\rightarrow B\\);\n\\([S \\wedge \\neg((V \\wedge L) \\vee (V \\wedge M) \\vee (L \\wedge M))] \\rightarrow N\\);\n\\((N \\wedge \\neg C) \\rightarrow P\\).\n\nLógica de Predicados:\n\n\\(Transacao(t)\\): \\(t\\) é uma transação;\n\\(AnalisaTempoReal(t)\\): a transação \\(t\\) é analisada em tempo real;\n\\(ValorAlto(t)\\): a transação \\(t\\) tem valor acima do padrão histórico;\n\\(LocalizacaoIncomum(t)\\): a transação \\(t\\) ocorre em localização incomum;\n\\(MultiplasTentativas(t)\\): há múltiplas tentativas para a transação \\(t\\);\n\\(Suspeita(t)\\): a transação \\(t\\) é marcada como suspeita;\n\\(Bloqueada(t)\\): a transação \\(t\\) é bloqueada automaticamente;\n\\(EnviaNotificacao(t)\\): uma notificação é enviada para confirmar \\(t\\);\n\\(Confirma(t, m)\\): a transação \\(t\\) é confirmada dentro de m minutos;\n\\(BloqueioPreventivo(t)\\): a transação \\(t\\) recebe bloqueio preventivo.\n\nFormalização:\n\n\\(\\forall t [Transacao(t) \\rightarrow AnalisaTempoReal(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge (ValorAlto(t) \\vee LocalizacaoIncomum(t) \\vee MultiplasTentativas(t)) \\rightarrow Suspeita(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge ((ValorAlto(t) \\wedge LocalizacaoIncomum(t)) \\vee (ValorAlto(t) \\wedge MultiplasTentativas(t)) \\vee (LocalizacaoIncomum(t) \\wedge MultiplasTentativas(t))) \\rightarrow Bloqueada(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge Suspeita(t) \\wedge \\neg((ValorAlto(t) \\wedge LocalizacaoIncomum(t)) \\vee (ValorAlto(t) \\wedge MultiplasTentativas(t)) \\vee (LocalizacaoIncomum(t) \\wedge MultiplasTentativas(t))) \\rightarrow EnviaNotificacao(t)]\\);\n\\(\\forall t [Transacao(t) \\wedge EnviaNotificacao(t) \\wedge \\neg Confirma(t, 5) \\rightarrow BloqueioPreventivo(t)]\\).\n\nAnálise da Validade:\nO argumento é logicamente válido. A estrutura representa corretamente o processo de decisão do sistema:\n\nA definição de transação suspeita usa uma disjunção (\\(OR\\)) adequada;\nA condição para bloqueio automático usa corretamente conjunções (\\(AND\\)) para representar a combinação de critérios;\nA notificação em caso de suspeita única é representada por uma conjunção com uma negação de múltiplos critérios;\nO bloqueio preventivo após falta de confirmação segue uma implicação lógica válida.\n\nO sistema de regras é coerente, sem contradições ou ambiguidades lógicas.\nAnálise da Solidez:\nAs premissas são sólidas no contexto de sistemas de detecção de fraudes:\n\nA análise em tempo real é essencial para sistemas antifraude eficazes;\nOs critérios mencionados são indicadores comuns de atividades potencialmente fraudulentas;\nA escalação baseada na quantidade de indicadores segue práticas reais de segurança;\nO envolvimento do cliente para confirmação é uma prática que equilibra segurança e usabilidade;\nO tempo limite para confirmação é uma medida preventiva razoável.\n\nAs conclusões derivadas são sólidas e representam um sistema de detecção de fraudes que equilibra detecção automática, envolvimento do cliente e proteção preventiva.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Arte da Prova e Análise de Argumentos</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html",
    "href": "04-logica-predicativa-e-quantificadores.html",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "",
    "text": "6.1 Introdução aos Predicados\nUm predicado é como uma luneta que nos permite observar as propriedades de uma entidade. Um conjunto de lentes por meio do qual podemos ver se uma entidade particular possui ou não uma característica específica. A palavra predicado foi importada do campo da linguística e tem o mesmo significado: qualidade; característica. Por exemplo, ao observar o universo das letras por meio do telescópio do predicado ser uma vogal, percebemos que algumas entidades deste conjunto, como \\(a\\) e \\(e\\), possuem essa propriedade, enquanto outras, como \\(b\\) e \\(c\\), não.\nUm predicado não é uma afirmação absoluta de verdade ou falsidade. Divergindo das proposições, os predicados não são declarações completas. Pense neles como aquelas sentenças com espaços em branco, aguardando para serem preenchidos, que só têm sentido completo quando preenchidas:\nPreencha as lacunas, como quiser desde que faça sentido, e perceba que, em cada caso, ao preencher estamos atribuindo uma qualidade a um objeto. Esses são exemplos de predicados do nosso cotidiano, que sinteticamente o conceito que queremos abordar. Na lógica, os predicados são artefatos que possibilitam examinar o mundo ao nosso redor de forma organizada e exata.\nUm predicado pode ser entendido como uma função que recebe um objeto (ou um conjunto de objetos) e retorna um valor de verdade, \\(\\{\\text{TRUE, FALSE}\\}\\). Esta função descreve uma propriedade que o objeto pode possuir. Isto é, se \\(P\\) é uma função \\(P: u \\rightarrow \\{\\text{TRUE, FALSE}\\}\\) para um determinado conjunto $ u$ qualquer. Esse conjunto $ u$ é chamado de universo ou domínio do discurso, e dizemos que \\(P\\) é um predicado sobre $ u$.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#introdução-aos-predicados",
    "href": "04-logica-predicativa-e-quantificadores.html#introdução-aos-predicados",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "",
    "text": "O _______ está saboroso;\nO _______ é vermelho;\n_______ é alto.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#universo-do-discurso",
    "href": "04-logica-predicativa-e-quantificadores.html#universo-do-discurso",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.2 Universo do Discurso",
    "text": "6.2 Universo do Discurso\nO universo do discurso, \\(u\\), também chamado de universo, ou domínio, é o conjunto de objetos de interesse em um determinado cenário lógico para uma análise específica. O universo do discurso é importante porque as proposições na Lógica de Predicados serão declarações sobre objetos de um universo.\nO universo, \\(u\\), é o domínio das variáveis das nossas Fórmulas Bem Formadas. O universo do discurso pode ser o conjunto dos números reais, \\(\\mathbb{R}\\), o conjunto dos inteiros, \\(\\mathbb{Z}\\), o conjunto de todos os alunos em uma sala de aula que usam camisa amarela, ou qualquer outro conjunto que definamos. Na prática, o universo costuma ser deixado implícito e deveria ser óbvio a partir do contexto. Se não for o caso, precisa ser explicitado.\nSe estamos interessados em proposições sobre números naturais, \\(\\mathbb{N}\\), o universo do discurso é o conjunto \\(\\mathbb{N} = \\{0, 1, 2, 3,...\\}\\), um conjunto infinito. Já se estamos interessados em proposições sobre alunos de uma sala de aula, o universo do discurso poderia ser o conjunto $ u = {, , …}$, um conjunto finito.\nPara que este conceito fique mais claro, suponha que temos um conjunto de números \\(u = \\{1, 2, 3, 4, 5\\}\\) e um predicado \\(P(x)\\), que dizemos unário por ter um, e somente um, argumento, que afirma x é par. Ao aplicarmos este predicado a cada elemento do universo \\(u\\), obtemos um conjunto de valores verdade:\n\\[\n\\begin{align}\n&P(1) = \\text{FALSE};\\\\\n&P(2) = \\text{TRUE};\\\\\n&P(3) = \\text{FALSE};\\\\\n&P(4) = \\text{TRUE};\\\\\n&P(5) = \\text{FALSE}.\n\\end{align}\n\\]\nVemos que o predicado \\(P(u)\\) dado por u é par é uma propriedade que alguns números do conjunto $ u$ Possuem, e outros não. Vale notar que na Lógica Predicativa, a função que define um predicado pode ter múltiplos argumentos. Por exemplo, podemos ter um predicado \\(Q(x, y)\\) que afirma x é maior que y. Neste caso, o predicado \\(Q\\) é uma função de dois argumentos que retorna um valor de verdade. Dizemos que \\(Q(x, y)\\) é um predicado binário. Exemplos nos conduzem ao caminho do entendimento:\n\nExemplo 1:\n\nUniverso do discurso: \\(u = \\text{conjunto de todas as pessoas}\\).\nPredicado: \\(P(x) = \\{ x : x \\text{ é um matemático} \\}\\);\nItens para os quais \\(P(x)\\) é verdadeiro: Carl Gauss, Leonhard Euler, John Von Neumann.\n\nExemplo 2:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{Z} : x \\text{ é par}\\}\\)\nPredicado: \\(Q(x) = (x &gt; 5)\\);\nItens para os quais \\(Q(x)\\) é verdadeiro: $6 $, $8 $, \\(10 ...\\).\n\nExemplo 3:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{R} : x &gt; 0 \\text{ e } x &lt; 10\\}\\)\nPredicado: \\(R(x) = (x^2 - 4 = 0)\\);\nItens para os quais \\(R(x)\\) é verdadeiro: \\(2\\) (note que \\(-2\\) não pertence ao universo do discurso definido).\n\nExemplo 4:\n\nUniverso do discurso: \\(u = \\{x \\in \\mathbb{N} : x \\text{ é um múltiplo de } 3\\}\\)\nPredicado: \\(S(x) = (\\text{mod}(x, 2) = 0)\\);\nItens para os quais \\(S(x)\\) é verdadeiro: \\(6\\), \\(12\\), $18 $.\n\nExemplo 5:\n\nUniverso do discurso: \\(u = \\{(x, y) \\in \\mathbb{R}^2 : x \\neq y\\}\\)\nPredicado: \\(P(x, y) = (x &lt; y)\\);\nItens para os quais \\(P(x, y)\\) é verdadeiro: \\((1, 2)\\), \\((3, 4)\\), \\((5, 6)\\).",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#entendendo-predicados",
    "href": "04-logica-predicativa-e-quantificadores.html#entendendo-predicados",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.3 Entendendo Predicados",
    "text": "6.3 Entendendo Predicados\nA aridade do predicado, número de argumentos, é limitado pela análise lógica que estamos fazendo. Considere um predicado ternário, \\(R\\), dado por x está entre y e z. Quando substituímos \\(x\\), \\(y\\) e \\(z\\) por números específicos podemos validar a verdade do predicado \\(R\\). Vamos considerar alguns exemplos adicionais de predicados baseados na aritmética e defini-los com menos formalidade e mais legibilidade:\n\n\\(Primo(x)\\): o número inteiro positivo \\(x\\) é um número primo.\n\\(PotênciaDe(x, y)\\): o número inteiro \\(x\\) é uma potência exata de \\(y : x = y^z\\) para algum \\(z \\in \\mathbb{Z}, z \\geq 0\\).\n\\(somaDeDoisPrimos(x)\\): o número inteiro positivo \\(x\\) é igual à soma de dois números primos.\n\nEm 1, 2 e 3 os predicados estão definidos com mnemônicos aumentando a legibilidade e melhorando nossa capacidade de manter o universo implícito. O uso de predicados, e da Lógica Proposicional, permite a escrita de sentenças menos ambíguas para a definição de conceitos lógicos em formato matemático. Por exemplo: se \\(x\\) é um ancestral de \\(y\\) e \\(y\\) é um ancestral de \\(z\\) então \\(x\\) é um ancestral de \\(z\\); que, se consideramos o predicado \\(ancestralDe\\) Pode ser escrito como \\(ancestralDe (x,y) \\wedge ancestralDe(y,z) \\rightarrow ancestralDe(x,z)\\). Ainda assim, falta alguma coisa. Algo que permita aplicar os predicados a um conjunto de elementos dentro do universo do discurso. É aqui que entram os quantificadores.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.4 Quantificadores",
    "text": "6.4 Quantificadores\nEmbora a Lógica Proposicional seja um bom ponto de partida, a maioria das afirmações interessantes em matemática contêm variáveis definidas em domínios maiores do que apenas \\(\\{\\text{TRUE, FALSE}\\}\\). Por exemplo, a afirmação \\(x \\text{é uma potência de } 2\\) não é uma proposição. Não temos como definir a verdade dessa afirmação até conhecermos o valor de \\(x\\). Se \\(P(x)\\) é definido como a afirmação \\(x \\text{é uma potência de } 2\\), então \\(P(8)\\) é verdadeiro e \\(P(7)\\) é falso.\nPara termos uma linguagem lógica que seja suficientemente flexível para representar os problemas que encontramos no Universo real, o Universo em que vivemos, precisaremos ser capazes de dizer quando o predicado \\(P\\) ou \\(Q\\) é verdadeiro para valores diferentes em seus argumentos. Para tanto, vincularemos as variáveis aos predicados usando operadores para indicar quantidade, chamados de quantificadores.\nOs quantificadores indicam se a sentença que estamos criando se aplica a todos os valores possíveis do argumento, quantificação universal, ou se esta sentença se aplica a um valor específico, quantificação existencial. Usaremos esses quantificadores para fazer declarações sobre todos os elementos de um universo de discurso específico, ou para afirmar que existe pelo menos um elemento do universo do discurso que satisfaz uma determinada qualidade.\nVamos remover o véu da dúvida usando como recurso metafórico uma experiência humana, social, comum e popular: imaginemos estar em uma festa e o anfitrião lhe pede para verificar se todos os convidados têm algo para beber. Você, prestativo e simpático, começa a percorrer a sala, verificando cada pessoa. Se você encontrar pelo menos uma pessoa sem bebida, você pode imediatamente dizer nem todos têm bebidas. mas, se você verificar cada convidado e todos eles tiverem algo para beber, você pode dizer com confiança todos têm bebidas. Este é o conceito do quantificador universal, matematicamente representado por \\(\\forall\\), que lemos como para todo.\nA festa continua e o anfitrião quer saber se alguém na festa está bebendo champanhe. Desta vez, assim que você encontrar uma pessoa com champanhe, você pode responder imediatamente sim, alguém está bebendo champanhe. Você não precisa verificar todo mundo para ter a resposta correta. Este é o conceito do quantificador existencial, denotado por \\(\\exists\\), que lemos existe algum.\nOs quantificadores nos permitem fazer declarações gerais, ou específicas, sobre os membros de um universo de discurso, de uma forma que seria difícil, ou impossível, sem estes operadores especiais.\n\n6.4.1 Quantificador Universal\nO quantificador universal \\(\\forall\\), lê-se para todo, indica que uma afirmação deve ser verdadeira para todos os valores de uma variável dentro de um universo de discurso definido para a criação de uma sentença contendo um predicado qualquer. Por exemplo, a proposição clássica todos os humanos são mortais pode ser escrita como \\(\\forall x Humano(x) \\rightarrow Mortal(x)\\). Ou recorrendo a um exemplo com mais de rigor matemático, teríamos o predicado se \\(x\\) é positivo então \\(x + 1\\) é positivo, que pode ser escrito \\(\\forall x (x &gt; 0 \\rightarrow x + 1 &gt; 0)\\). Neste último exemplo temos Quantificadores, Lógica Predicativa, Lógica Proposicional e Teoria dos Conjuntos em uma sentença.\nO quantificador universal pode ser representado usando apenas a Lógica Proposicional, com uma pequena trapaça. A afirmação \\(\\forall x P(x)\\) é, de certa forma, a operação \\(\\wedge\\), AND aplicada a todos os elementos do universo do discurso. Ou seja, o predicado:\n\\[\\forall x (x \\in \\mathbb{N} \\rightarrow P(x))\\]\nPode ser escrito como:\n\\[P(0) \\wedge P(1) \\wedge P(2) \\wedge P(3) \\wedge \\ldots\\]\nAssim, \\(P(0), P(1), P(2), P(3) \\ldots\\) representam a aplicação do predicado \\(P\\) a todos os elementos \\(x\\) do conjunto \\(\\mathbb{N}\\). A trapaça fica por conta de que, em Lógica Proposicional, não podemos escrever expressões com um número infinito de termos. Portanto, a expansão em conjunções de um predicado \\(P\\) em um Universo de Discurso, \\(u\\), não é uma Fórmula Bem Formada se a cardinalidade de \\(u\\) for infinita. De qualquer forma, podemos usar esta interpretação informal para entender o significado de \\(\\forall x P(x)\\).\nA representação do Quantificador Universal como uma conjunção não é uma Fórmula Bem Formada** a não ser que o Universo do Discurso seja não infinito. Neste caso, teremos uma conjunção que chamaremos de Conjunção Universal:\n\\[\\forall x (P(x) \\wedge Q(x))\\]\nIsso significa que para todo \\(x\\) no domínio, as propriedades \\(P\\), \\(Q\\), e outras listadas são todas verdadeiras. É uma forma de expressar que todas as condições listadas são verdadeiras para cada elemento no domínio. Esta fórmula será usada para simplificar sentenças, ou para criar formas normais.\nVamos voltar um pouco. O quantificador universal \\(\\forall x P(x)\\) afirma que a proposição \\(P(x)\\) é verdadeira para todo, e qualquer, valor possível de \\(x\\) como elemento de um conjunto, \\(u\\). Uma forma de interpretar isso é pensar em \\(x\\) como uma variável que pode ter qualquer valor dentro do universo do discurso.\nPara validar \\(\\forall x P(x)\\) escolhemos o pior caso possível para \\(x\\), todos os valores que suspeitamos possa fazer \\(P(x)\\) falso. Se conseguirmos provar que \\(P(x)\\) é verdadeira nestes casos específicos, então \\(\\forall x P(x)\\) deve ser verdadeira. Novamente, vamos recorrer a exemplos na esperança de explicitar este conceito.\nExemplo 1: todos os números reais são maiores que 0. (Universo do discurso: \\(\\{x \\in \\mathbb{R}\\}\\))\n\\[\\forall x (x \\in \\mathbb{R} \\rightarrow x &gt; 0)\\]\n\nObserve que este predicado, apesar de estar corretamente representado, é \\(Falso\\).\n\nExemplo 2: todos os triângulos em um plano euclidiano têm a soma dos ângulos internos igual a 180 graus. (Universo do discurso: \\(x\\) é um triângulo em um plano euclidiano)\n\\[\\forall x (Triângulo(x) \\rightarrow \\Sigma_{i=1}^3 ÂnguloInterno_i(x) = 180^\\circ)\\]\nExemplo 3: todas as pessoas com mais de 18 anos podem tirar carteira de motorista._ (Universo do discurso: \\(x\\) é uma pessoa no Brasil)\n\\[\\forall x (Pessoa(x) \\wedge Idade (x) \\geq 18 \\rightarrow PodeTirarCarteira(x))\\]\nExemplo 4: todo número par maior que 2 pode ser escrito como a soma de dois números primos. (Universo do discurso: \\(\\{x \\in \\mathbb{Z}\\}\\)\n\\[\\forall x\\,(Par(x) \\wedge x &gt; 2 \\rightarrow \\exists u\\exists v\\, (Primo(u) \\wedge Primo(v) \\wedge x = u + v))\\]\nExemplo 5: para todo número natural, se ele é múltiplo de 4 e múltiplo de 6, então ele também é múltiplo de 12. (Universo do discurso: \\(\\{x \\in \\mathbb{N}\\}\\))\n\\[\\forall x\\,((\\exists u\\in\\Bbb N\\,(x = 4u) \\wedge \\exists v\\in\\Bbb N\\,(x = 6v)) \\rightarrow \\exists w\\in\\Bbb N\\,(x = 12w))\\]\nO quantificador universal nos permite definir uma Fórmula Bem Formada representando todos os elementos de um conjunto, um universo do discurso, em relação a uma qualidade específica, um predicado. Esta é um artefato lógico interessante, mas não suficiente.\nUsamos, preferencialmente, a implicação, \\(\\to\\), com o quantificador universal, \\(\\forall\\), para indicar que uma propriedade vale para todos os elementos de um domínio, Porque permite afirmar que para todo \\(x\\), se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. Isso permite que \\(P(x)\\) seja falsa para alguns \\(x\\), mas a implicação como um todo permanece verdadeira. Ou, em outras palavras, quando usamos uma implicação, como \\(P(x) \\rightarrow Q(x)\\), estamos dizendo que se \\(P(x)\\) for verdadeira, então \\(Q(x)\\) também será verdadeira. A implicação é uma forma lógica que permite conectar duas proposições, em que a veracidade de \\(Q(x)\\) depende da veracidade de \\(P(x)\\).\nImportante: A implicação \\(P(x) \\rightarrow Q(x)\\) é considerada verdadeira em qualquer dos seguintes casos:\n\\(P(x)\\) é verdadeira e \\(Q(x)\\) é verdadeira. \\(P(x)\\) é falsa, independentemente de \\(Q(x)\\). O ponto-chave é o segundo caso: se \\(P(x)\\) for falsa, a implicação \\(P(x) \\rightarrow Q(x)\\) ainda é verdadeira, não importa o valor de \\(Q(x)\\).\nEssa preferência não é arbitrária, mas baseada nas limitações que os outros conectivos apresentam quando combinados com o quantificador universal. Porém, uma análise de todos os operadores pode ser interessante para sedimentar os conceitos.\nComecemos com a conjunção. Quando usamos \\(\\forall x(P(x) ∧ Q(x))\\), estamos afirmando que para todo \\(x\\), tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiros. Isso é extremamente restritivo e raramente reflete situações do mundo real. Por exemplo, se disséssemos Todos os animais são mamíferos e podem voar, estaríamos fazendo uma afirmação falsa, pois nem todos os animais são mamíferos e nem todos podem voar. Outro exemplo seria Todos os números são pares e primos, o que é claramente falso, pois nenhum número (exceto 2) satisfaz ambas as condições simultaneamente.\nA disjunção, por outro lado, é muito fraca quando combinada com o quantificador universal. \\(\\forall x(P(x) ∨ Q(x))\\) afirma que para todo \\(x\\), ou \\(P(x)\\) ou \\(Q(x)\\) (ou ambos) são verdadeiros. Isso geralmente não captura relações condicionais úteis. Por exemplo, Todo número é par ou ímpar é uma afirmação verdadeira, mas não nos diz muito sobre a relação entre paridade e números. Da mesma forma, Toda pessoa é alta ou baixa é uma afirmação de tal amplitude que se torna quase sem sentido, pois não fornece informações úteis sobre a altura das pessoas.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador universal também apresenta problemas. \\(\\forall x(P(x) \\leftrightarrow Q(x))\\) afirma que para todo \\(x\\), \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso é uma condição muito forte e raramente é satisfeita em situações reais. Por exemplo, Um número é par se e somente se é divisível por 4 é falso, pois há números pares que não são divisíveis por \\(4\\) (como \\(2\\) e \\(6\\)). Outro exemplo seria Uma pessoa é feliz se e somente se é rica, o que claramente não reflete a realidade complexa da felicidade e riqueza.\nPor outro lado, a implicação (\\(\\to\\)) oferece várias vantagens quando usada com o quantificador universal. \\(\\forall x(P(x) \\to Q(x))\\) nos permite expressar relações condicionais de forma mais flexível e precisa. Por exemplo, Para todo número, se é par, então não é primo (exceto 2) é uma afirmação verdadeira e informativa. Outro exemplo seria Para toda pessoa, se é médico, então tem formação universitária. Esta formulação permite exceções (pode haver pessoas com formação universitária que não são médicos) e captura uma regra geral de forma precisa.\nA implicação também tem a vantagem de ser verdadeira quando o antecedente (\\(P(x)\\)) é falso, o que é útil para expressar regras gerais. Por exemplo, em Para todo \\(x\\), se \\(x\\) é um quadrado perfeito, então \\(x\\) é positivo, a implicação é verdadeira mesmo para números negativos (que não são quadrados perfeitos), mantendo a regra geral válida.\nEspero que tenha ficado claro. A implicação, quando combinada com o quantificador universal, oferece um equilíbrio entre flexibilidade e precisão que os outros conectivos lógicos não conseguem alcançar. Ela permite expressar relações condicionais, acomoda exceções e captura regras gerais de forma mais eficaz, tornando-a a escolha preferida em muitas situações da lógica formal e da matemática.\n\n\n6.4.2 Quantificador Existencial\nO quantificador existencial, \\(\\exists\\) nos permite fazer afirmações sobre a existência de objetos com certas propriedades, sem precisarmos especificar exatamente quais objetos são esses. Vamos tentar remover os véus da dúvida com um exemplo simples.\nConsideremos a sentença: existem humanos mortais. Com um pouco mais de detalhe e matemática, podemos escrever isso como: existe pelo menos um \\(x\\) tal que \\(x\\) é humano e mortal. Para escrever a mesma sentença com precisão matemática teremos:\n\\[\\exists x \\text{Humano}(x) \\wedge \\text{Mortal}(x)\\]\nLendo por partes: existe um \\(x\\), tal que \\(x\\) é humano AND \\(x\\) é mortal. Em outras palavras, existe pelo menos um humano que é mortal.\nNote duas coisas importantes:\n\nNós não precisamos dizer exatamente quem é esse humano mortal. Só afirmamos que existe um. O operador \\(\\exists\\) captura essa ideia.\nUsamos AND (\\(\\wedge\\)), não implicação (\\(\\rightarrow\\)). Se usássemos \\(\\rightarrow\\), a afirmação ficaria muito mais fraca. Veja:\n\n\\[\\exists x \\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\]\nQue pode ser lido como: existe um \\(x\\) tal que, SE \\(x\\) é humano, ENTÃO \\(x\\) é mortal. Essa afirmação é verdadeira em qualquer universo que contenha um unicórnio de bolinhas roxas imortal. Porque o unicórnio não é humano. neste caso, o predicado \\(\\text{Humano}(\\text{unicórnio})\\) é falso, e a implicação \\(\\text{Humano}(x) \\rightarrow \\text{Mortal}(x)\\) é verdadeira.\nPortanto, é importante usar o operador \\(\\wedge\\), e não \\(\\rightarrow\\) quando trabalhamos com quantificadores existenciais. O \\(\\wedge\\) garante que a propriedade se aplica ao objeto existente definido pelo \\(\\exists\\). Contudo, podemos melhorar um pouco isso:\nA conjunção, \\(\\wedge\\), é frequentemente empregada com o quantificador existencial, \\(\\exists\\), para expressar a presença de ao menos um elemento em determinado conjunto que possui múltiplas características simultaneamente. Isso nos possibilita declarar que há no mínimo um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são válidas. Tal afirmação confirma a existência de pelo menos um elemento que atende a ambos os critérios. Dito de outra forma, ao utilizarmos uma conjunção, como em \\(P(x) \\wedge Q(x)\\), estamos afirmando que existe ao menos um \\(x\\) em que \\(P(x)\\) é verdadeiro e, ao mesmo tempo, \\(Q(x)\\) também o é. A conjunção funciona como um operador lógico que une duas proposições, em que a validade da asserção existencial depende da ocorrência simultânea de \\(P(x)\\) e \\(Q(x)\\) para, no mínimo, um \\(x\\).\nNo contexto do quantificador existencial \\(\\exists x\\), a conjunção \\(P(x) \\wedge Q(x)\\) é tida como verdadeira se, e apenas se houver ao menos um \\(x\\) para o qual tanto \\(P(x)\\) quanto \\(Q(x)\\) são verdadeiras. Caso não exista tal \\(x\\), a afirmação existencial é considerada falsa.\nObserve que basta a existência de um único elemento satisfazendo ambas as condições para validar a afirmação existencial.\nEsta predileção não é fortuita, mas fundamentada na aptidão da conjunção em expressar com exatidão a existência de elementos dotados de múltiplos atributos concomitantes. No entanto, uma avaliação dos demais operadores pode ser proveitosa para consolidar esses conceitos.\nIniciemos com a implicação. Ao empregarmos \\(\\exists x(P(x) \\to Q(x))\\), declaramos a existência de ao menos um \\(x\\) tal que, se \\(P(x)\\) for verdadeiro, então \\(Q(x)\\) também o será. Esta formulação é menos elucidativa que a conjunção no âmbito existencial, pois seria verdadeira mesmo se \\(P(x)\\) fosse falso para todo \\(x\\). Ilustrando: Há um número que, se for ímpar, é múltiplo de 2 é verdadeiro (pois é válido para números pares), mas não esclarece se realmente existe um número ímpar que é múltiplo de 2.\nA disjunção aliada ao quantificador existencial, \\(\\exists x(P(x) \\vee Q(x))\\), assevera a existência de pelo menos um \\(x\\) que satisfaz \\(P(x)\\) ou \\(Q(x)\\) (ou ambos). Embora útil em certos contextos, geralmente é menos robusta que a conjunção para afirmar a existência de elementos com múltiplas propriedades. Por exemplo: Existe um número que é negativo ou racional é verdadeiro, mas não nos informa se há um número que é ambos.\nA equivalência (\\(\\leftrightarrow\\)) com o quantificador existencial também pode ser problemática. \\(\\exists x(P(x) \\leftrightarrow Q(x))\\) afirma a existência de ao menos um \\(x\\) para o qual \\(P(x)\\) é verdadeiro se e somente se \\(Q(x)\\) for verdadeiro. Isso pode ser útil em alguns casos, mas frequentemente é mais restritivo do que o necessário. Por exemplo: Existe um número que é positivo se e somente se é inteiro é verdadeiro (o número 1 satisfaz isso), mas não captura a existência de números que são apenas positivos ou apenas inteiros.\nEm contrapartida, a conjunção (\\(\\wedge\\)) apresenta diversas vantagens quando utilizada com o quantificador existencial. \\(\\exists x(P(x) \\wedge Q(x))\\) nos permite afirmar a existência de elementos que possuem múltiplas propriedades simultaneamente. Por exemplo: Existe um número que é positivo e par é uma afirmação verdadeira e informativa (o número 2 satisfaz ambas as condições). Outro exemplo seria Existe uma substância que é líquida e condutora de eletricidade. Esta formulação afirma claramente a existência de substâncias com ambas as características.\nA conjunção também tem a vantagem de ser falsa quando não há elementos que satisfaçam ambas as condições, o que é útil para expressar a inexistência de certos tipos de elementos. Por exemplo: Existe um número que é natural e negativo simultaneamente é falso, indicando corretamente que não há tais números.\nEm suma, a conjunção, quando associada ao quantificador existencial, proporciona um meio preciso e informativo de expressar a existência de elementos com múltiplos atributos. Ela permite afirmar a presença de elementos que atendem a condições simultâneas, tornando-se a opção preferencial em diversas situações da lógica formal e da matemática quando se trata de asserções existenciais.\nAssim como o quantificador universal, \\(\\forall\\), o quantificador existencial, \\(\\exists\\) , também pode ser restrito a um universo específico, usando a notação de pertencimento:\n\\[\\exists x (x \\in \\mathbb{Z} \\wedge x = x^2)\\]\nEsta sentença afirma a existência de pelo menos um inteiro \\(x\\) tal que \\(x\\) é igual ao seu quadrado. Novamente, não precisamos dizer qual é esse inteiro, apenas que ele existe dentro do conjunto dos inteiros. A resposta é sim: tanto \\(x = 0\\) quanto \\(x = 1\\) satisfazem a equação \\(x = x^2\\).\nDe forma geral, o quantificador existencial serve para fazer afirmações elegantes sobre a existência de objetos com certas qualidades, sem necessariamente conhecermos ou elencarmos todos esses objetos. Isso agrega mais qualidade a representação do mundo real que podemos fazer com a Lógica de Primeira Ordem.\nTalvez, alguns exemplos possam ajudar no seu entendimento:\nExemplo 1: existe um animal que é vertebrado e não é mamífero.\n\\[\\exists x (Vertebrado(x) \\wedge \\neg Mamífero(x))\\]\nExemplo 2: existe uma equação do segundo grau com exatamente uma raiz real.\n\\[\\exists x (\\text{Eq2Grau}(x) \\wedge |\\text{RaízesReais}(x)| = 1)\\]\nExemplo 3: existe um número primo que é par.\n\\[\\exists x (Primo(x) \\wedge Par(x))\\]\nExemplo 4: existe um quadrado perfeito que pode ser escrito como o quadrado de um número racional.\n\\[\\exists x (QuadPerfeito(x) \\wedge \\exists u \\in \\mathbb{Q} \\ (x = u^2))\\]\nExemplo 5: existe um polígono convexo em que a soma dos ângulos internos não é igual a \\((n-2) \\cdot 180°\\), de tal forma que \\(n\\) é o número de lados desse polígono.\nPara expressar isso corretamente em lógica de primeira ordem, precisamos relacionar o número de lados com o polígono específico:\n\\[\\exists x (PolígonoConvexo(x) \\land \\exists n (NumLados(x, n) \\land SomaÂngulosInternos(x) \\neq (n-2) \\cdot 180°))\\]\nAlternativamente, podemos usar uma notação mais explícita:\n\\[\\exists x (PolígonoConvexo(x) \\land \\exists n (NumLados(x, n) \\land \\sum_{i=1}^{n} ÂnguloInterno_i(x) \\neq (n-2) \\cdot 180°))\\]\nA atenta leitora deve notar que este predicado é falso. Existe um teorema da geometria euclidiana que afirma que todos os polígonos convexos com \\(n\\) lados têm a soma dos ângulos internos exatamente igual a \\((n-2) \\cdot 180°\\).\nA atenta leitora deve observar também que a variável \\(n\\) está apropriadamente quantificada, com \\(\\exists n\\), e explicitamente relacionada ao polígono \\(x\\) por meio do predicado \\(NumLados(x, n)\\).\nExemplo de instanciação:\n\nPara um triângulo (\\(n = 3\\)): soma = \\((3-2) \\cdot 180° = 180°\\);\nPara um quadrilátero (\\(n = 4\\)): soma = \\((4-2) \\cdot 180° = 360°\\);\nPara um pentágono (\\(n = 5\\)): soma = \\((5-2) \\cdot 180° = 540°\\).\n\nEm todos os casos, a fórmula da soma é satisfeita, tornando nossa afirmação existencial falsa.\n\n\n6.4.3 Clarificação sobre o Uso de Operadores com Quantificadores\nEmbora seja verdade que frequentemente usamos implicação (\\(\\rightarrow\\)) com o quantificador universal (\\(\\forall\\)) e conjunção (\\(\\wedge\\)) com o quantificador existencial (\\(\\exists\\)), é importante esclarecer que estas são preferências contextuais, não regras absolutas. Há situações específicas nas quasi outras combinações são não apenas apropriadas, mas necessárias para expressar corretamente o significado desejado. A curiosa leitora deve considerar as seguintes situações:\n\n6.4.3.1 1. Quantificador Universal com Conjunção (\\(\\forall\\) com \\(\\wedge\\))\nUso apropriado: Quando queremos afirmar que todos os elementos de um conjunto possuem múltiplas propriedades simultaneamente.\nExemplo: Todos os números primos maiores que 2 são ímpares e indivisíveis por 4 \\[\\forall x ((Primo(x) \\wedge x &gt; 2) \\rightarrow (Impar(x) \\wedge \\neg DivisívelPor4(x)))\\]\nNote que aqui usamos \\(\\wedge\\) tanto no antecedente quanto no consequente da implicação com \\(\\forall\\).\n\n\n6.4.3.2 2. Quantificador Existencial com Implicação (\\(\\exists\\) com \\(\\rightarrow\\))\nUso apropriado: Quando queremos afirmar a existência de elementos que satisfazem uma relação condicional.\nExemplo: Existe um número tal que, se ele é par, então é maior que 10 \\[\\exists x (Par(x) \\rightarrow x &gt; 10)\\]\nEsta fórmula é verdadeira (por exemplo, \\(x = 12\\) ou qualquer número ímpar satisfaz a condição).\n\n\n6.4.3.3 3. Quantificador Universal com Disjunção (\\(\\forall\\) com \\(\\vee\\))\nUso apropriado: Para expressar propriedades alternativas que todos os elementos devem satisfazer.\nExemplo: Todo número inteiro é positivo, negativo ou zero \\[\\forall x (x \\in \\mathbb{Z} \\rightarrow (Positivo(x) \\vee Negativo(x) \\vee Zero(x)))\\]\n\n\n6.4.3.4 4. Quantificador Existencial com Bicondicional (\\(\\exists\\) com \\(\\leftrightarrow\\))\nUso apropriado: Para afirmar a existência de elementos que satisfazem uma equivalência.\nExemplo: Existe um número que é primo se e somente se é ímpar \\[\\exists x (Primo(x) \\leftrightarrow Impar(x))\\]\n(Verdadeiro para \\(x = 3\\), \\(5\\), \\(7\\), etc., mas falso para \\(x = 2\\) ou \\(x = 9\\))\n\n\n6.4.3.5 Diretrizes Práticas\nRegra geral para escolher o operador correto:\n\nCom \\(\\forall\\):\n\nUse \\(\\rightarrow\\) quando estiver restringindo o domínio (para todos os \\(X\\) que satisfazem \\(P...\\));\nUse \\(\\wedge\\) quando estiver afirmando múltiplas propriedades sobre todo o domínio;\nUse \\(\\vee\\) quando todo elemento deve satisfazer pelo menos uma de várias condições.\n\nCom \\(\\exists\\):\n\nUse \\(\\wedge\\) quando procurar elementos que satisfazem todas as propriedades listadas;\nUse \\(\\vee\\) quando procurar elementos que satisfazem pelo menos uma propriedade;\nUse \\(\\rightarrow\\) quando a existência envolver uma condição condicional.\n\n\n\n6.4.3.5.1 Exemplo Comparativo\nConsidere a diferença entre estas duas afirmações sobre um sistema de banco de dados:\nAfirmação A: Todos os usuários ativos têm senha \\[\\forall x (UsuarioAtivo(x) \\rightarrow TemSenha(x))\\]\nAfirmação B: Todos os usuários são ativos e têm senha \\[\\forall x (Usuario(x) \\rightarrow (UsuarioAtivo(x) \\wedge TemSenha(x)))\\]\nA Afirmação A permite usuários inativos sem senha, enquanto a Afirmação B exige que todos os usuários sejam ativos e tenham senha - uma restrição muito mais forte.\nA escolha do operador lógico deve ser guiada pelo significado preciso que queremos expressar, não por uma regra mecânica. As preferências mencionadas (implicação com \\(\\forall\\) e conjunção com \\(\\exists\\)) são padrões comuns que funcionam bem em muitos contextos, mas a lógica de primeira ordem é rica o suficiente para requerer todas as combinações possíveis em diferentes situações.\nExiste uma regra de segurança que a esforçada leitora deve seguir: sempre traduza a fórmula de volta para linguagem natural para verificar se ela captura exatamente o significado pretendido. Se houver discrepância, reconsidere a escolha dos operadores.\n\n\n\n\n6.4.4 Equivalências Interessantes\nEstudando o quantificador universal encontramos duas equivalências interessantes:\n\\[\\lnot \\forall x P(x) \\leftrightarrow \\exists x \\lnot P(x)\\]\n\\[\\lnot \\exists x P(x) \\leftrightarrow \\forall x \\lnot P(x)\\]\nEssas equivalências são essencialmente as versões quantificadas das Leis de De Morgan. A primeira diz que nem todos os humanos são mortais, isso é equivalente a encontrar algum humano que não é mortal. A segunda diz que para mostrar que nenhum humano é mortal, temos que mostrar que todos os humanos não são mortais.\nPodemos representar uma declaração \\(\\exists x P(x)\\) como uma expressão OU. Por exemplo, \\(\\exists x (x \\in \\mathbb{N} \\wedge P(x))\\) poderia ser reescrito como:\n\\[P(0) \\vee P(1) \\vee P(2) \\vee P(3) \\vee \\ldots \\]\nLembrando do problema que encontramos quando fizemos isso com o quantificador $$: não podemos representar fórmulas sem fim em Lógica de Primeira Ordem. mas, novamente esta notação, ainda que inválida, nos permite entender melhor o quantificador existencial. Caso o Universo do Discurso seja finito, limitado e contável, teremos a Disjunção Existencial uma expressão na Lógica de Primeira Ordem que afirma que existe pelo menos um elemento em um domínio que satisfaz uma ou mais propriedades. A forma geral de uma disjunção existencial é:\n\\[\\exists x (P(x) \\vee Q(x))\\]\nIsso significa que existe pelo menos um \\(x\\) no domínio que satisfaz a propriedade \\(P\\), ou a propriedade \\(Q\\), ou ambas, ou outras propriedades listadas. É uma forma de expressar que pelo menos uma das condições listadas é verdadeira para algum elemento no domínio.\nA expansão de $$ usando $$ destaca que a proposição \\(P(x)\\) é verdadeira se pelo menos um valor de \\(x\\) dentro do universo do discurso atender ao predicado \\(P\\). O que a expansão de exemplo está dizendo é que existe pelo menos um número natural \\(x\\) tal que \\(P(x)\\) é verdadeiro. Não precisamos saber exatamente qual é esse \\(x\\). Apenas que existe um elemento dentro de \\(\\mathbb{N}\\) que atende o predicado.\nO quantificador existencial não especifica o objeto dentro do universo determinado. Esse operador permite fazer afirmações elegantes sobre a existência de objetos com certas características, certas qualidades, ou ainda, certos predicados, sem necessariamente conhecermos exatamente quais são esses objetos.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#dos-predicados-à-linguagem-natural",
    "href": "04-logica-predicativa-e-quantificadores.html#dos-predicados-à-linguagem-natural",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.5 Dos Predicados à Linguagem Natural",
    "text": "6.5 Dos Predicados à Linguagem Natural\nAo ler uma Fórmula Bem Formada contendo quantificadores, a ordem da leitura é geralmente da esquerda para a direita. A interpretação precisa, no entanto, depende diretamente da ordem e do tipo dos quantificadores.\nPor exemplo, \\(\\forall x\\) pode ser lido como para todo objeto \\(x\\) no universo do discurso (em que este objeto está implícito), o seguinte se mantém. Já o quantificador \\(\\exists x\\) pode ser lido como existe um objeto \\(x\\) no universo que satisfaz o seguinte ou para algum objeto \\(x\\) no universo, o seguinte se mantém.\nConverter uma Fórmula Bem Formada em uma sentença fluida em linguagem natural nem sempre é direto, mas é um passo valioso para a compreensão. Vamos considerar \\(U\\) como o universo do discurso (o conjunto de todos os aviões já fabricados) e \\(F(x,y)\\) como o predicado que denota \\(x\\) voa mais rápido que \\(y\\). Analisemos algumas combinações de quantificadores:\n\n\\(\\forall x \\forall y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), e para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação é muito forte. Ela diz que cada avião no universo é mais rápido que todos os aviões no universo (incluindo ele mesmo, a menos que \\(F(x,x)\\) seja definido como falso ou que se adicione \\(x \\neq y\\)). Se o universo tiver mais de um avião, esta afirmação provavelmente será falsa, pois implicaria, por exemplo, que \\(A\\) é mais rápido que \\(B\\) e \\(B\\) é mais rápido que \\(A\\) simultaneamente.\n\n\\(\\exists x \\forall y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) tal que, para todo avião \\(y\\), \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que existe pelo menos um avião que é mais rápido que todos os outros (e, novamente, dependendo da definição de \\(F(x,x)\\), mais rápido que ele mesmo). Em outras palavras, existe um avião mais rápido absoluto.\n\n\\(\\forall x \\exists y F(x,y)\\)\n\nLeitura literal: Para todo avião \\(x\\), existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta afirmação diz que para qualquer avião que escolhermos, podemos encontrar algum avião \\(y\\) que é mais lento que \\(x\\). Se \\(y\\) pode ser igual a \\(x\\), a afirmação é trivialmente verdadeira se \\(F(x,x)\\) for verdadeiro para algum \\(x\\). Se \\(y\\) deve ser diferente de \\(x\\), isso significaria que não existe um avião mais lento absoluto (a menos que o universo seja finito e ordenado de forma cíclica, ou que \\(F(x,y)\\) permita que \\(x\\) seja mais rápido que nada se \\(y\\) for o mais lento). Uma interpretação comum é que, para cada avião, há outro que ele supera em velocidade.\n\n\\(\\exists x \\exists y F(x,y)\\)\n\nLeitura literal: Existe um avião \\(x\\) e existe um avião \\(y\\) tal que \\(x\\) voa mais rápido que \\(y\\).\nSignificado: Esta é a afirmação mais fraca entre as quatro. Ela simplesmente diz que a relação voa mais rápido que não é vazia; ou seja, há pelo menos um par de aviões \\((x,y)\\) em que \\(x\\) é mais rápido que \\(y\\).\n\n\nÉ fundamental perceber que estas quatro sentenças têm significados lógicos distintos e geralmente não expressam o mesmo contexto. A ordem dos quantificadores, especialmente quando misturamos \\(\\forall\\) e \\(\\exists\\), altera drasticamente o significado da afirmação. Por exemplo, \\(\\exists x \\forall y F(x,y)\\) (existe um avião mais rápido que todos) é uma afirmação muito mais forte e diferente de \\(\\forall x \\exists y F(x,y)\\) (para cada avião, existe um mais lento).\nAo traduzir da lógica para a linguagem natural ou vice-versa, a precisão na interpretação da ordem e do tipo dos quantificadores é essencial. A prática leva a uma maior fluidez nesse processo de tradução e compreensão.\n\n6.5.1 Exercícios Resolvidos de Conversão de Linguagem Natural em Expressões Predicativas\nSentença 1: Todo matemático que é professor tem alunos que são brilhantes e interessados.\n\\[\n\\forall x ((\\text{Matemático}(x) \\wedge \\text{Professor}(x)) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Matemático}(x) \\rightarrow (\\text{Professor}(x) \\rightarrow \\exists y (\\text{Aluno}(y) \\wedge \\text{Brilhante}(y) \\wedge \\text{Interessado}(y) \\wedge \\text{Ensina}(x, y))))\n\\]\nSentença 2: Alguns engenheiros não são nem ricos nem felizes.\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg (\\text{Rico}(x) \\vee \\text{Feliz}(x)))\\]\n\\[\\exists x (\\text{Engenheiro}(x) \\wedge \\neg\\text{Rico}(x) \\wedge \\neg\\text{Feliz}(x))\\]\nSentença 3: Todos os planetas que têm água possuem vida ou têm potencial para vida.\n\\[\n\\forall x (\\text{Planeta}(x) \\wedge \\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x)))\n\\]\n\\[\n\\forall x (\\text{Planeta}(x) \\rightarrow (\\text{TemÁgua}(x) \\rightarrow (\\text{TemVida}(x) \\vee \\text{TemPotencialParaVida}(x))))\n\\]\nSentença 4: Nenhum cientista que é cético acredita em todos os mitos.\n\\[\n\\neg \\exists x (Cientista(x) \\wedge Cético(x) \\wedge \\forall y (Mito(y) \\rightarrow Acredita(x,y)))\n\\]\n\\[\n\\forall x ((\\text{Cientista}(x) \\wedge \\text{Cético}(x)) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y)))\n\\]\n\\[\n\\forall x (\\text{Cientista}(x) \\rightarrow (\\text{Cético}(x) \\rightarrow \\exists y (\\text{Mito}(y) \\wedge \\neg \\text{Acredita}(x, y))))\n\\]\nSentença 5: Alguns filósofos que escrevem sobre ética também leem ou estudam psicologia.\n\\[\n\\exists x (\\text{Filósofo}(x) \\wedge \\text{EscreveSobreÉtica}(x) \\wedge (\\text{LêPsicologia}(x) \\vee \\text{EstudaPsicologia}(x)))\n\\]\nSentença 6: Para todo escritor, existe pelo menos um livro que ele escreveu e que é tanto criticado quanto admirado.\n\\[\n\\forall x (\\text{Escritor}(x) \\rightarrow \\exists y (\\text{Livro}(y) \\wedge \\text{Escreveu}(x, y) \\wedge \\text{Criticado}(y) \\wedge \\text{Admirado}(y)))\n\\]\nSentença 7: Todos os pássaros voam e todos os peixes nadam.\n\\[\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\wedge \\forall y (Peixe(y) \\rightarrow Nada(y))\\]\nSentença 8: Todos os estudantes estudam ou todos os professores ensinam.\n\\[\\forall x (Estudante(x) \\rightarrow Estuda(x)) \\vee \\forall y (Professor(y) \\rightarrow Ensina(y))\\]\nSentença 9: Todos os cães latem e todos os gatos miam, mas nem todos os animais fazem barulho.\n\\[\\forall x (Cão(x) \\rightarrow Late(x)) \\wedge \\forall y (Gato(y) \\rightarrow Mia(y)) \\wedge \\neg \\forall z (Animal(z) \\rightarrow FazBarulho(z))\\]\nSentença 10: Se todos os carros são vermelhos, então todos os caminhões são azuis.\n\\[\\forall x (Carro(x) \\rightarrow Vermelho(x)) \\rightarrow \\forall y (Caminhão(y) \\rightarrow Azul(y))\\]\nSentença 11: Todos os planetas orbitam uma estrela e todos os asteroides orbitam o sol.\n\\[\\forall x (Planeta(x) \\rightarrow OrbitaEstrela(x)) \\wedge \\forall y (Asteroide(y) \\rightarrow OrbitaSol(y))\\]\nSentença 12: Alguns pássaros não voam.\n\\[\\exists x (Pássaro(x) \\wedge \\neg Voa(x))\\]\nSentença 13: Existe pelo menos um estudante que não estuda.\n\\[\\exists x (Estudante(x) \\wedge \\neg Estuda(x))\\]\n\\[\\exists x (Estudante(x) \\wedge \\neg Estuda(x))\\]\nSentença 14: Há algum animal que não faz barulho.\n\\[\\exists x (Animal(x) \\wedge \\neg FazBarulho(x))\\]\nSentença 15: Existe um carro que não é vermelho.\n\\[\\exists x (Carro(x) \\wedge \\neg Vermelho(x))\\]\n\\[\\exists x (Carro(x) \\wedge \\neg Vermelho(x))\\]\nSentença 16: Há um planeta que não orbita uma estrela.\n$$\\exists x (Planeta(x) \\wedge \\neg \\exists y (Estrela(y) \\wedge Orbita(x, y)))$$\n\nOu \n\n$$\\exists x (Planeta(x) \\wedge \\forall y (Estrela(y) \\rightarrow \\neg Orbita(x, y)))$$ (Existe um planeta $x$ tal que, para toda estrela $y$, $x$ não a orbita).\nSentença 17: _Todos os pássaros voam, mas existe um animal que não voa.\n$$\\forall x (Pássaro(x) \\rightarrow Voa(x)) \\wedge \\exists y (Animal(y) \\wedge \\neg Voa(y))$$\nSentença 18: Para cada estudante, existe um professor que o ensina.\n$$\\forall x (Estudante(x) \\rightarrow \\exists y (Professor(y) \\wedge Ensina(y, x)))$$\nSentença 19: Existe um cão que late para todos os gatos.\n$$\\exists x (Cão(x) \\wedge \\forall y (Gato(y) \\rightarrow Late(x, y)))$$\nSentença 20: Para cada carro vermelho, existe um caminhão azul.\n$$\\forall x (Carro(x) \\wedge Vermelho(x) \\rightarrow \\exists y (Caminhão(y) \\wedge Azul(y)))$$\nSentença 21: Todos os planetas orbitam uma estrela, e existe um asteroide que orbita o sol.\n$$(\\forall x (Planeta(x) \\rightarrow \\exists y (Estrela(y) \\wedge Orbita(x, y)))) \\wedge (\\exists z (Asteroide(z) \\wedge Orbita(z, Sol)))$$\n\n\n6.5.2 Exercícios Resolvidos de Conversão de Expressões Predicativas em Linguagem Natural\n1. Fórmula Lógica: \\(\\forall x (\\text{Humano}(x) \\rightarrow (\\text{Mortal}(x) \\wedge \\text{Racional}(x)))\\)\n\nPredicados:\n\n\\(Humano(x)\\): \\(x\\) é um humano.\n\\(Mortal(x)\\): \\(x\\) é mortal.\n\\(Racional(x)\\): \\(x\\) é racional.\n\nSentença em Português: Todo humano é mortal e racional.\n\n2. Fórmula Lógica:\\(\\exists y (\\text{Livro}(y) \\wedge (\\text{Interessante}(y) \\vee \\text{Complicado}(y)))\\)\n\nPredicados:\n\n\\(Livro(y)\\): y é um livro.\n\\(Interessante(y)\\): y é interessante.\n\\(Complicado(y)\\): y é complicado.\n\nSentença em Português: Existe pelo menos um livro que é interessante ou complicado.\n\n3. Fórmula Lógica:\\(\\forall x \\forall y (\\text{Amigos}(x, y) \\rightarrow (\\text{Confiável}(x) \\wedge \\text{Honra}(x, y)))\\)\n\nPredicados:\n\n\\(Amigos(x, y)\\): x é amigo de y.\n\\(Confiável(x)\\): x é confiável.\n\\(Honra(x, y)\\): x honra y.\n\nSentença em Português: Todo amigo de alguém é confiável e honra o amigo.\n\n4. Fórmula Lógica:\\(\\exists x \\exists y (\\text{Animal}(x) \\wedge \\text{Planta}(y) \\wedge \\text{Convive}(x, y))\\)\n\nPredicados:\n\n\\(Animal(x)\\): x é um animal.\n\\(Planta(y)\\): y é uma planta.\n\\(Convive(x, y)\\): x e y convivem.\n\nSentença em Português: Existe pelo menos um animal e uma planta que convivem no mesmo ambiente.\n\n5. Fórmula Lógica:\\(\\forall x \\exists y (\\text{Professor}(x) \\rightarrow (\\text{Disciplina}(y) \\wedge \\text{Leciona}(x, y)))\\)\n\nPredicados:\n\n\\(Professor(x)\\): x é um professor.\n\\(Disciplina(y)\\): y é uma disciplina.\n\\(Leciona(x, y)\\): x leciona y.\n\nSentença em Português: Para todo professor, existe pelo menos uma disciplina que ele leciona.\n\n6. Fórmula Lógica:$ x ((x) y ((y) (x, y))) $\n\nPredicados:\n\n\\(Músico(x)\\): x é um músico;\n\\(Instrumento(y)\\): y é um instrumento;\n\\(Toca(x, y)\\): x toca y.\n\nSentença em Português: Existe pelo menos um músico que, se algo é um instrumento, então ele toca esse instrumento. Ou, Existe um músico que toca todos os instrumentos.\n\n7. Fórmula Lógica: \\(\\forall x (Gato(x) \\rightarrow (Peludo(x) \\wedge Dorminhoco(x)))\\)\n\\[\\text{Todo gato é peludo e dorminhoco.}\\]\n8. Fórmula Lógica:\\(\\forall y (Árvore(y) \\rightarrow (Verde(y) \\wedge Grande(y)))\\)\n\\[\\text{Toda árvore é verde e grande.}\\]\n9. Fórmula Lógica: \\((\\forall x (Cidade(x) \\rightarrow Populosa(x))) \\rightarrow (\\forall y (País(y) \\rightarrow Populoso(y)))\\)\n\\[\\text{Se toda cidade é populosa, então todo país é populoso.}\\]\n10. Fórmula Lógica: \\(\\forall x (Criança(x) \\rightarrow (Inocente(x) \\wedge Curiosa(x))) \\wedge \\neg \\exists y (Adulto(y) \\wedge (Inocente(y) \\wedge Curioso(y)))\\)\n\\[\\text{Toda criança é inocente e curiosa, e não existe um adulto que seja inocente e curioso.}\\]\n11. Fórmula Lógica: \\(\\forall x (Ave(x) \\rightarrow Voa(x)) \\wedge \\forall y (Peixe(y) \\rightarrow Nada(y))\\)\n\\[\\text{Toda ave voa e todo peixe nada.}\\]\n12. Fórmula Lógica: \\(\\exists x (Pessoa(x) \\wedge Feliz(x))\\)\n\\[\\text{Existe uma pessoa que é feliz.}\\]\n13. Fórmula Lógica: \\(\\exists y (Livro(y) \\wedge Interessante(y) \\wedge \\neg Longo(y))\\)\n\\[\\text{Há um livro que é interessante e não é longo.}\\]\n14. Fórmula Lógica: \\(\\exists x (Estudante(x) \\wedge (\\forall y (Disciplina(y) \\rightarrow Gosta(x, y))))\\)\n\\[\\text{Existe um estudante que gosta de todas as disciplinas.}\\]\n15. Fórmula Lógica: \\(\\exists x (Carro(x) \\wedge Rápido(x)) \\wedge \\exists y (Carro(y) \\wedge \\neg Rápido(y))\\)\n\\[\\text{Existe um carro que é rápido, e existe um carro que não é rápido.}\\]\n16. Fórmula Lógica: \\(\\neg \\exists x (Político(x) \\wedge Honesto(x))\\)\n$$\\text{Não existe um político que seja honesto.}$$\n17. Fórmula Lógica: \\(\\forall x (Cachorro(x) \\rightarrow (\\exists y (Pessoa(y) \\wedge Dono(y, x))))\\)\n$$\\text{Todo cachorro tem uma pessoa que é seu dono.}$$\n18. Fórmula Lógica: \\(\\exists x (Música(x) \\wedge (\\forall y (Pessoa(y) \\rightarrow Gosta(y, x))))\\)\n$$\\text{Existe uma música que todas as pessoas gostam.}$$\n19. Fórmula Lógica: \\(\\forall x (Estudante(x) \\rightarrow (\\exists y (Professor(y) \\wedge Ensina(y, x))))\\)\n$$\\text{Para todo estudante, existe um professor que o ensina.}$$\n20. Fórmula Lógica: \\((\\exists x (Médico(x) \\wedge Competente(x))) \\wedge (\\forall y (Médico(y) \\rightarrow Ocupado(y)))\\)\n$$\\text{Existe um médico que é competente, e todo médico é ocupado.}$$\n21. Fórmula Lógica: \\[(\\forall x (Artista(x) \\rightarrow Criativo(x))) \\rightarrow (\\exists y (Pintor(y) \\wedge Criativo(y)))\\]\n$$\\text{Se todo artista é criativo, então existe um pintor que é criativo.}$$",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#ordem-de-aplicação-dos-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#ordem-de-aplicação-dos-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.6 Ordem de Aplicação dos Quantificadores",
    "text": "6.6 Ordem de Aplicação dos Quantificadores\nQuando mais de uma variável é quantificada em uma Fórmula Bem Formada como \\(\\forall y\\forall x P(x,y)\\), elas são aplicadas da esquerda para a direita. Assim, \\(\\forall y\\forall x P(x,y)\\) se lê para todo \\(y\\), para todo \\(x\\), \\(P(x,y)\\) se mantém.\nAs posições dos mesmos tipos de quantificadores podem ser trocadas sem afetar o valor lógico, desde que não haja quantificadores do outro tipo entre os que serão trocados.\nPor exemplo, \\(\\forall x\\forall y\\forall z P(x,y,z)\\) é equivalente a \\(\\forall y\\forall x\\forall z P(x,y,z)\\), \\(\\forall z\\forall y\\forall x P(x,y,z)\\). O mesmo vale para o quantificador existencial.\nNo entanto, as posições de quantificadores de tipos diferentes não podem ser trocadas. Por exemplo, \\(\\forall x\\exists y P(x,y)\\) não é equivalente A\\(\\exists y\\forall x P(x,y)\\). Por exemplo, seja \\(P(x,y)\\) representando \\(x &lt; y\\) Para o conjunto dos números como universo. Então, \\(\\forall x\\exists y P(x,y)\\) se lê para todo número \\(x\\), existe um número \\(y\\) que é maior que \\(x\\), o que é verdadeiro, enquanto \\(\\exists y\\forall x P(x,y)\\) se lê existe um número que é maior que todo (qualquer) número, o que não é verdadeiro.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#negação-dos-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#negação-dos-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.7 Negação dos Quantificadores",
    "text": "6.7 Negação dos Quantificadores\nExiste uma equivalência entre as negações dos quantificadores. De tal forma que:\n\nNegação do Quantificador Universal ($$): A negação de uma afirmação universal significa que existe pelo menos um caso no Universo do Discurso em que a afirmação não é verdadeira. Isso pode ser expresso pela seguinte equivalência:\n\\[\\neg \\forall x \\, P(x) \\equiv \\exists x \\, \\neg P(x)\\]\nEm linguagem natural podemos entender como: negar que para todos os \\(x\\), \\(P(x)\\) é verdadeiro é equivalente a afirmar que existe algum \\(x\\) tal que \\(P(x)\\) não é verdadeiro.\nNegação do Quantificador Existencial ( $$ ): A negação de uma afirmação existencial significa que a afirmação não é verdadeira para nenhum caso no Universo do Discurso. Isso pode ser expresso pela seguinte equivalência:\n\n\\[\\neg \\exists x \\, P(x) \\equiv \\forall x \\, \\neg P(x)\\]\nOu seja, negar que existe algum \\(x\\) tal que \\(P(x)\\) é verdadeiro é equivalente a afirmar que para todos os \\(x\\), \\(P(x)\\) não é verdadeiro.\nVamos tentar entender estas negações. Considere as expressões \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Essas fórmulas se aplicam a qualquer predicado \\(P\\), e possuem o mesmo valor de verdade para qualquer \\(P\\).\nNa Lógica Proposicional, poderíamos simplesmente verificar isso com uma tabela verdade, mas aqui, não podemos. Não existem proposições, conectadas por $$, $$, para construir uma tabela e não é possível determinar o valor verdade de forma genérica para uma determinada variável.\nVamos tentar entender isso com linguagem natural: afirmar que \\(\\neg (\\forall x P(x))\\) é verdadeiro significa que não é verdade que \\(P(x)\\) se aplica a todas as possíveis entidades \\(x\\). Deve haver alguma entidade \\(A\\) Para a qual\\(P(a)\\) é falso. Como \\(P(a)\\) é falso, \\(\\neg P(a)\\) é verdadeiro. Isso significa que \\(\\exists x (\\neg P(x))\\) é verdadeiro. Portanto, a verdade de \\(\\neg (\\forall x P(x))\\)implica a verdade de \\(\\exists x (\\neg P(x))\\).\nSe \\(\\neg (\\forall x P(x))\\) é falso, então \\(\\forall x P(x)\\) é verdadeiro. Como \\(P(x)\\) é verdadeiro para todos os \\(x\\), \\(\\neg P(x)\\) é falso para todos os \\(x\\). Logo, \\(\\exists x (\\neg P(x))\\) é falso.\nOs valores de verdade de \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\) são os mesmos. Como isso é verdadeiro para qualquer predicado \\(P\\), essas duas fórmulas são logicamente equivalentes, e podemos escrever \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\).\nMuita lógica? Que tal se tentarmos novamente, usando um pouco mais de linguagem natural. Considere as expressões lógicas \\(\\neg (\\forall x P(x))\\) e \\(\\exists x (\\neg P(x))\\). Para ilustrar essas fórmulas, vamos usar um exemplo com um predicado \\(P(x)\\) que se aplica a uma entidade \\(x\\) se \\(x\\) é feliz.\nA expressão \\(\\forall x P(x)\\) significa que todos são felizes. A negação dessa afirmação, \\(\\neg (\\forall x P(x))\\), equivale logicamente a \\(\\exists x (\\neg P(x))\\), ou seja, existe pelo menos um indivíduo que não é feliz.\nA expressão \\(\\exists x (\\neg P(x))\\) significa que existe alguém que não está feliz. Você pode ver que isso é apenas outra forma de expressar a ideia contida em \\(\\neg (\\forall x P(x))\\).\nA afirmação de que não é verdade que todos estão felizes implica que deve haver alguém que não está feliz. Se a primeira afirmação é falsa (ou seja, todos estão felizes), então a segunda afirmação também deve ser falsa.\nPortanto, as duas fórmulas têm o mesmo valor verdade. Elas são logicamente equivalentes e podem ser representadas como \\(\\neg (\\forall x P(x)) \\equiv \\exists x (\\neg P(x))\\). Esta equivalência reflete uma relação profunda e intuitiva em nosso entendimento de declarações sobre entidades em nosso mundo.\n\n\n\nExpressão\nEquivalência\n\n\n\n\n\\(\\forall x P(x)\\)\n\\(\\neg \\exists x \\neg P(x)\\)\n\n\n\\(\\exists x \\, P(x)\\)\n\\(\\neg \\forall x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\forall x \\, P(x)\\)\n\\(\\exists x \\, \\neg P(x)\\)\n\n\n\\(\\neg \\exists x \\, P(x)\\)\n\\(\\forall x \\, \\neg P(x)\\)\n\n\n\nTabela 5 - Equivalências entre Quantificadores.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#regras-de-inferência-usando-quantificadores",
    "href": "04-logica-predicativa-e-quantificadores.html#regras-de-inferência-usando-quantificadores",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.8 Regras de Inferência usando Quantificadores",
    "text": "6.8 Regras de Inferência usando Quantificadores\nAs regras de inferência com quantificadores lidam especificamente com as proposições que envolvem quantificadores. Estas regras nos permitem fazer generalizações ou especificações, transformando proposições universais em existenciais, e vice-versa. Compreender essas regras é essencial para aprofundar o entendimento da estrutura da lógica, o que nos permite analisar e construir argumentos mais complexos de forma precisa e coerente.\nNos próximos tópicos, exploraremos essas regras em detalhes, observando como elas interagem com os quantificadores universal e existencial.\n\n6.8.1 Repetição\nA regra de Repetição permite repetir uma afirmação. Esta regra é útil para propagar premissas em uma prova formal.\n\\[F\\]\n\\[\n\\begin{aligned}\n&F\\\\\n\\hline\n&F\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: o céu está azul.\nConclusão: logo, o céu está azul.\n\nAlgumas aplicações da Repetição:\n\nReafirmar premissas em provas longas. Por exemplo:\n\nProposição: todos os homens, \\(H(x)\\), são mortais, \\(M(x)\\).\nConclusão: logo, todos os homens são mortais.\n\n\n\\[\n\\begin{aligned}\n&\\forall x(H(x) \\rightarrow M(x))\\\\\n\\hline\n&\\forall x(H(x) \\rightarrow M(x))\n\\end{aligned}\n\\]\n\nIntroduzir suposições em provas indiretas. Por exemplo:\n\nProposição: suponha que \\((2 + 2 = 5)\\).\nConclusão: logo, (2 + 2 = 5)$.\n\n\n\\[\n\\begin{aligned}\n&2 + 2 = 5\\\\\n\\hline\n&2 + 2 = 5\n\\end{aligned}\n\\]\n\nReafirmar fórmulas quantificadas. Por exemplo:\n\nProposição: para todo \\(x\\), \\(x + 0 = x\\).\nConclusão: logo, para todo \\(x\\), \\(x + 0 = x\\).\n\n\n\\[\n\\begin{aligned}\n&\\forall x(x + 0 = x)\\\\\n\\hline\n&\\forall x(x + 0 = x)\n\\end{aligned}\n\\]\n\n\n6.8.2 Instanciação Universal\nA regra de Instanciação Universal permite substituir a variável em uma afirmação universalmente quantificada por um termo concreto. Esta regra nos permite derivar casos particulares a partir de afirmações gerais.\n\\[\\forall x P(x)\\]\n\\[\\begin{aligned}\n&\\forall x P(x)\\\\\n\\hline\n&P(a)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: todos os humanos são mortais.\nConclusão: logo, Sócrates é mortal. Assumindo que Sócrates é humano.\n\nExemplo completo de aplicação:\n\nPremissa 1: todos os mamíferos respiram ar: \\(\\forall x(M(x) \\rightarrow R(x))\\);\nPremissa 2: a baleia é um mamífero: \\(M(b)\\);\nAplicação da Instanciação Universal à Premissa 1: \\(M(b) \\rightarrow R(b)\\);\nAplicação de Modus Ponens:\n\n\\[\\begin{aligned}\n&M(b) \\rightarrow R(b)\\\\\n&M(b)\\\\\n\\hline\n&R(b)\n\\end{aligned}\n\\]\n\nConclusão: logo, a baleia respira ar: \\(R(b)\\)\n\nAlgumas aplicações da Instanciação Universal:\n\nAplicar regras e princípios gerais. Por exemplo:\n\nProposição: todos os triângulos têm 180 graus internos: \\(\\forall t(T(t) \\rightarrow 180^\\circ(t))\\);\nPremissa adicional: ABC é um triângulo: \\(T(\\text{Triângulo }ABC)\\);\nAplicação da Instanciação Universal: \\(T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\);\nAplicação de Modus Ponens:\n\n\n\\[\\begin{aligned}\n&T(\\text{Triângulo }ABC) \\rightarrow 180^\\circ(\\text{Triângulo }ABC)\\\\\n&T(\\text{Triângulo }ABC)\\\\\n\\hline\n&180^\\circ(\\text{Triângulo }ABC)\n\\end{aligned}\n\\]\n\nConclusão: logo, o triângulo \\(ABC\\) tem 180 graus.\nTestar propriedades em membros de conjuntos. Por exemplo:\n\nProposição: todo inteiro é maior que seu antecessor: \\(\\forall x (\\mathbb{Z}(x) \\rightarrow (x &gt; x-1))\\);\nPremissa adicional: 5 é um inteiro: \\(\\mathbb{Z}(5)\\);\nAplicação da Instanciação Universal: \\(\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\);\nAplicação de Modus Ponens:\n\n\n\\[\\begin{aligned}\n&\\mathbb{Z}(5) \\rightarrow (5 &gt; 5-1)\\\\\n&\\mathbb{Z}(5)\\\\\n\\hline\n&5 &gt; 4\n\\end{aligned}\n\\]\n\nConclusão: logo, \\(5\\) é maior que \\(4\\).\n\n\n\n6.8.3 Generalização Existencial\nA regra de Generalização Existencial permite inferir que algo existe a partir de uma afirmação concreta. Esta regra nos permite generalizar de exemplos específicos para a existência geral.\n\\[P(a)\\]\n\\[\n\\begin{aligned}\nP(a)\\\\\n\\hline\n\\exists x P(x)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: Rex é um cachorro.\nConclusão: logo, existe pelo menos um cachorro.\n\nAlgumas aplicações da Generalização Existencial:\n\nInferir existência a partir de exemplos concretos. Por exemplo:\n\nProposição: o urânio-235 é radioativo.\nConclusão: logo, existe pelo menos um elemento químico radioativo.\n\n\n\\[\n\\begin{aligned}\n&R(u_{235})\\\\\n\\hline\n&\\exists x R(x)\n\\end{aligned}\n\\]\n\nConcluir que uma propriedade não é vazia. Por exemplo:\n\nProposição: $7 $ é um número primo.\nConclusão: logo, existe pelo menos um número primo.\n\n\n\\[\n\\begin{aligned}\n&P(7)\\\\\n\\hline\n&\\exists x P(x)\n\\end{aligned}\n\\]\n\nInferir a existência de soluções para problemas. Por exemplo:\n\nProposição: $x = 2 $ satisfaz a equação $x + 3 = 5 $.\nConclusão: logo, existe pelo menos uma solução para essa equação.\n\n\n\\[\n\\begin{aligned}\n&S(2)\\\\\n\\hline\n&\\exists x S(x)\n\\end{aligned}\n\\]\n\n\n6.8.4 Instanciação Existencial\nA regra de Instanciação Existencial permite introduzir um novo termo como instância de uma variável existencialmente quantificada. Esta regra nos permite derivar exemplos de afirmações existenciais.\n\\[\\exists x P(x)\\]\n\\[\n\\begin{aligned}\n&\\exists x P(x)\\\\\n\\hline\n&P(b)\\\\\n\\end{aligned}\n\\]\nEm linguagem natural:\n\nProposição: existe um cachorro com rabo curto.\nConclusão: logo, algum cachorro específico (que podemos chamar de \\(c\\)) tem rabo curto.\n\nAlgumas aplicações da Instanciação Existencial:\n\nDerivar exemplos de existência previamente estabelecida. Por exemplo:\n\nProposição: existem estrelas, $ e $, maiores, $M $, que o Sol, $s $.\nConclusão: logo, existe uma estrela específica, \\(c\\), que é maior que o Sol.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (e (x) \\wedge M(x, s))\\\\\n\\hline\n&e(c) \\wedge M(c, s)\n\\end{aligned}\n\\]\n\nConstruir modelos satisfatíveis para predicados existenciais. Por exemplo:\n\nProposição: existem pessoas mais velhas que \\(25\\) Anos.\nConclusão: logo, John tem 30 anos.\n\n\n\\[\n\\begin{aligned}\n&\\exists x (P(x) \\wedge \\text{Idade}(x) &gt; 25)\\\\\n\\hline\n&P(c) \\wedge \\text{Idade}(c) &gt; 25 \\quad (\\text{para uma nova constante } c)\n\\end{aligned}\n\\]\n\nProvar que conjuntos não estão vazios. Por exemplo:\n\nProposição: existem números reais maiores que \\(2\\).\nConclusão: logo, \\(5\\) é um número real maior que \\(2\\).\n\n\n\\[\n\\begin{aligned}\n&\\exists x (R(x) \\wedge x &gt; 2)\\\\\n\\hline\n&R(d) \\wedge d &gt; 2 \\quad (\\text{para uma nova constante } d)\n\\end{aligned}\n\\]",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#exercícios-de-conexão-com-o-prolog",
    "href": "04-logica-predicativa-e-quantificadores.html#exercícios-de-conexão-com-o-prolog",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.9 Exercícios de Conexão com o Prolog",
    "text": "6.9 Exercícios de Conexão com o Prolog\nEstas questões de Lógica Predicativa estabelecem os fundamentos conceituais essenciais para Prolog:\n\nPredicados se tornam fatos e cabeças de regras\nQuantificadores universais correspondem a variáveis em regras\n\nQuantificadores existenciais correspondem a consultas e instanciações\nImplicações se tornam regras (:-)\nConjunções se tornam múltiplas condições nas regras\nNegação se torna negação por falha (\\+)\n\nA modelagem em Lógica de Predicados fornece a base teórica que o Prolog implementa por meio de seu mecanismo de resolução e unificação.\nQuestão 1: Relações em um Sistema Acadêmico\nConsidere um mundo acadêmico com alunos e cursos. Use os seguintes predicados:\n\n\\(A(x)\\): x é um aluno\n\\(C(x)\\): x é um curso\n\n\\(M(x,y)\\): o aluno x está matriculado no curso y\n\nTraduza as seguintes sentenças para fórmulas da lógica de predicados:\n\nExiste pelo menos um aluno\nNem todo aluno está matriculado em algum curso\nTodo aluno está matriculado em pelo menos um curso\nExiste um curso no qual nenhum aluno está matriculado\nExiste um aluno que está matriculado em todos os cursos\n\nQuestão 2: O Escopo dos Quantificadores\nA ordem dos quantificadores altera drasticamente o significado de uma sentença. Usando os predicados \\(Pessoa(x)\\) e \\(Ama(x,y)\\) (x ama y), traduza e explique a diferença semântica entre as duas sentenças abaixo:\n\n\\(\\forall x \\exists y (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\\(\\exists y \\forall x (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\nQual das duas sentenças descreve melhor o conceito de amor fraternal universal e qual descreve a existência de uma figura universalmente amada por todos?\nQuestão 3: O Paradoxo do Barbeiro\nEm uma cidade, há um único barbeiro. A regra que define seu trabalho é: O barbeiro barbeia todos os homens da cidade que não se barbeiam a si mesmos, e apenas esses.\nUse o predicado \\(Barbeia(x,y)\\) para representar x barbeia y. Seja \\(b\\) a constante que representa o barbeiro.\n\nTraduza a regra para uma fórmula da lógica de predicados\nMostre, por meio de dedução lógica, que essa regra leva a uma contradição ao se perguntar: Quem barbeia o barbeiro? (ou seja, ao analisar a proposição \\(Barbeia(b,b)\\))\n\nQuestão 4: Especificação de um Sistema de Arquivos\nModele as permissões de um sistema de arquivos com os predicados:\n\n\\(Admin(x)\\): x é um administrador\n\\(Arquivo(y)\\): y é um arquivo\n\\(PodeAcessar(x,y)\\): x pode acessar y\n\nA política de segurança do sistema é: Qualquer administrador pode acessar todos os arquivos. Ninguém que não seja administrador pode acessar algum arquivo.\n\nTraduza a política para um conjunto de fórmulas lógicas\nSuponha os seguintes fatos: \\(Admin(ana)\\) e \\(\\neg Admin(beto)\\). O que podemos concluir sobre \\(PodeAcessar(ana, relatorio.doc)\\) e \\(PodeAcessar(beto, relatorio.doc)\\)?\n\nQuestão 5: Negando Afirmações Universais\nNegar sentenças com quantificadores é uma habilidade fundamental para entender a falha em Prolog (negação por falha). Forneça a negação formal das seguintes sentenças, movendo o símbolo de negação (\\(\\neg\\)) o mais para dentro possível da fórmula.\n\nTodos os programas de computador têm pelo menos um bug\n\nUse: \\(Programa(x)\\), \\(Bug(y)\\), \\(Tem(x,y)\\)\n\nExiste um político que é honesto com todos os seus eleitores\n\nUse: \\(Politico(x)\\), \\(Eleitor(y,x)\\) (y é eleitor de x), \\(HonestoCom(x,y)\\)\n\n\nQuestão 6: Mundo dos Blocos (Planejamento em Inteligência Artificial)\nConsidere um cenário simples de Inteligência Artificial com os predicados: * \\(Bloco(x)\\): \\(x\\) é um bloco * \\(EmCima(x,y)\\): o bloco \\(x\\) está em cima do bloco \\(y\\) * \\(Azul(x)\\): o bloco \\(x\\) é azul * \\(Verde(x)\\): o bloco \\(x\\) é verde * \\(NaMesa(x)\\): o bloco \\(x\\) está diretamente sobre a mesa\nDados os seguintes axiomas sobre o estado do mundo:\n\nAxioma 1: Existe um bloco verde em cima de um bloco azul \\[\\exists x \\exists y (Bloco(x) \\wedge Bloco(y) \\wedge Verde(x) \\wedge Azul(y) \\wedge EmCima(x,y))\\]\nAxioma 2: Todo bloco que está diretamente sobre a mesa é azul \\[\\forall x ((Bloco(x) \\wedge NaMesa(x)) \\rightarrow Azul(x))\\]\nAxioma 3: Nenhum bloco pode estar simultaneamente em cima de outro bloco e sobre a mesa \\[\\forall x (Bloco(x) \\rightarrow \\neg(\\exists y (Bloco(y) \\wedge EmCima(x,y)) \\wedge NaMesa(x)))\\]\nAxioma 4: Nenhum bloco pode ser verde e azul simultaneamente \\[\\forall x (Bloco(x) \\rightarrow \\neg(Verde(x) \\wedge Azul(x)))\\]\n\nProve formalmente que: Existe um bloco que não é verde \\[\\exists x (Bloco(x) \\wedge \\neg Verde(x))\\]\nDica para a prova: Use o Axioma 1 para estabelecer a existência de um bloco azul, depois aplique o Axioma 4 para mostrar que esse bloco não pode ser verde.\nQuestão 7: Propriedades dos Números Inteiros\nSeja o domínio de discurso o conjunto dos números inteiros (\\(\\mathbb{Z}\\)). Use os predicados \\(Par(x)\\), \\(Impar(x)\\) e os símbolos usuais da matemática. Traduza as seguintes sentenças para a lógica de predicados:\n\nTodo número par é maior que algum número ímpar\nNão existe um número inteiro que seja o maior de todos\n\nA soma de quaisquer dois números pares é par\n\nQuestão 8: Dedução Lógica com Instanciação\nConsidere as seguintes premissas:\n\nTodos os leões são mamíferos: \\(\\forall x (Leao(x) \\to Mamifero(x))\\)\nAlguns leões vivem na savana: \\(\\exists x (Leao(x) \\wedge ViveNaSavana(x))\\)\n\nUsando as regras de dedução da lógica de predicados (Instanciação Universal, Instanciação Existencial, Modus Ponens, etc.), prove formalmente que Alguns mamíferos vivem na savana: \\(\\exists x (Mamifero(x) \\wedge ViveNaSavana(x))\\).\nQuestão 9: Consulta a uma Base de Dados Relacional\nImagine uma base de dados com as tabelas Funcionario(ID, Nome, DeptoID) e Departamento(ID, NomeDepto). Modele este esquema com os predicados:\n\n\\(Func(x,n,d)\\): o funcionário com ID x tem nome n e trabalha no departamento d\n\\(Depto(d,m)\\): o departamento com ID d tem nome m\n\nFormule a seguinte consulta em lógica de predicados: Encontre os nomes de todos os funcionários que trabalham no departamento de ‘Vendas’.\nQuestão 10: Hierarquia Organizacional\nModele a estrutura de uma empresa com os predicados:\n\n\\(Funcionario(x)\\): x é um funcionário\n\\(Gerente(x,y)\\): x é gerente de y\n\n\\(Salario(x,s)\\): o salário de x é s\n\nTraduza as seguintes regras de negócio para a lógica de predicados:\n\nTodo funcionário tem exatamente um gerente\nNenhum funcionário pode ser gerente de si mesmo\nTodo gerente é também um funcionário\nExiste um funcionário que não é gerente de ninguém\n\nQuestão 11: Sistema Bancário:\nCenário: Banco com clientes e contas Entidades: Clientes, contas bancárias, transações Regras de Negócio:\n\nTodo cliente possui pelo menos uma conta;\nToda conta pertence a exatamente um cliente;\nContas podem ter saldo positivo ou negativo;\nExistem clientes VIP que têm mais de uma conta;\nNem todas as contas têm saldo positivo.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 12: Sistema de Saúde:\nCenário: Hospital com médicos, pacientes e tratamentos. Entidades: Médicos, pacientes, tratamentos, especialidades. Regras de Negócio:\n\nTodo paciente é atendido por pelo menos um médico;\nTodo médico tem uma especialidade;\nAlguns tratamentos requerem médicos especialistas;\nExistem pacientes internados e ambulatoriais;\nTodo tratamento é prescrito por algum médico.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 13: Rede Social:\nCenário: Plataforma social como Facebook Entidades: Usuários, postagens, curtidas, amizades Regras de Negócio:\n\nAmizade é uma relação simétrica;\nTodo usuário pode publicar postagens;\nUsuários podem curtir postagens de amigos;\nExistem usuários influenciadores;\nNem toda postagem recebe curtidas.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 14: Sistema de Biblioteca:\nCenário: Biblioteca universitária. Entidades: Livros, usuários, empréstimos, reservas. Regras de Negócio:\n\nUm usuário pode pegar vários livros;\nUm livro só pode estar com um usuário por vez;\nNem todos os livros estão emprestados;\nExistem livros que nunca foram emprestados;\nTodo empréstimo tem data de devolução.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 15: Sistema de E-commerce:\nCenário: Loja online como Amazon. Entidades: Produtos, clientes, pedidos, categorias, avaliações. Regras de Negócio:\n\nTodo produto pertence a pelo menos uma categoria;\nTodo pedido é feito por exatamente um cliente;\nNem todo produto tem avaliações;\nExistem produtos em promoção;\nClientes podem fazer múltiplos pedidos.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 16: Sistema de Transporte:\nCenário: App de transporte como Uber. Entidades: Motoristas, passageiros, viagens, veículos, avaliações.\nRegras de Negócio:\n\nTodo motorista possui exatamente um veículo;\nToda viagem conecta um passageiro a um motorista;\nNem toda viagem recebe avaliação;\nExistem motoristas premium (alta avaliação);\nPassageiros podem avaliar motoristas.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.\n\nQuestão 17: Sistema Universitário:\nCenário: Gestão acadêmica completa. Entidades: Estudantes, professores, disciplinas, cursos, notas.\nRegras de Negócio:\n\nTodo estudante está matriculado em um curso;\nToda disciplina é ministrada por pelo menos um professor;\nNem todo estudante tem nota em todas as disciplinas;\nExistem disciplinas obrigatórias e optativas;\nTodo professor ensina disciplinas da sua área.\n\nSua tarefa:\n\nDefina os predicados necessários;\nFormalize as regras usando quantificadores;\nCrie 3 consultas úteis para o sistema.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "04-logica-predicativa-e-quantificadores.html#para-além-de-todos-e-alguns-uma-introdução-aos-quantificadores-generalizados",
    "href": "04-logica-predicativa-e-quantificadores.html#para-além-de-todos-e-alguns-uma-introdução-aos-quantificadores-generalizados",
    "title": "6  Lógica de Primeira Ordem: Lógica Predicativa",
    "section": "6.10 Para Além de Todos e Alguns – Uma Introdução aos Quantificadores Generalizados",
    "text": "6.10 Para Além de Todos e Alguns – Uma Introdução aos Quantificadores Generalizados\nNos capítulos anteriores, exploramos o poder dos dois pilares da Lógica de Primeira Ordem: o quantificador universal (\\(\\forall\\)) e o quantificador existencial (\\(\\exists\\)). Com eles, fomos capazes de traduzir uma vasta gama de afirmações sobre todos os elementos de um domínio ou sobre a existência de pelo menos um elemento com certas propriedades. Contudo, a linguagem humana e o raciocínio complexo frequentemente empregam noções de quantidade que estes dois operadores não conseguem capturar.\nComo poderíamos formalizar sentenças como:\n\nExistem exatamente três servidores offline.;\nA maioria dos estudantes foi aprovada.;\nPoucos políticos são universalmente admirados.;\nExiste um número infinito de números primos..\n\nA Lógica de Primeira Ordem padrão é insuficiente para expressar essas ideias de forma direta e natural. Para preencher essa lacuna, lógicos e linguistas desenvolveram a Teoria dos Quantificadores Generalizados, uma extensão poderosa e elegante que enriquece imensamente a expressividade dos sistemas formais.\n\n6.10.0.1 1. A Origem: De Frege a Mostowski e Lindström\nA visão moderna dos quantificadores começou com Gottlob Frege, que os concebeu como conceitos de segunda ordem, ou seja, propriedades de propriedades. Por exemplo, \\(\\exists x: P(x)\\) expressa que a propriedade \\(P\\) tem a propriedade de não ser vazia.\nEsta ideia foi a semente para uma revolução conceitual formalizada décadas depois:\n\nAndrzej Mostowski (1957): Este lógico polonês foi o primeiro a propor formalmente a generalização dos quantificadores. Sua percepção foi de que um quantificador pode ser visto como uma relação que expressa a cardinalidade (o tamanho) de um conjunto. Por exemplo:\n\n\n\\(\\forall x: P(x)\\) é verdadeiro se o conjunto de elementos que não têm a propriedade \\(P\\) tiver cardinalidade 0. * \\(\\exists x: P(x)\\) é verdadeiro se o conjunto de elementos que têm a propriedade \\(P\\) tiver cardinalidade maior que 0.\n\nA partir daí, Mostowski sugeriu que poderíamos criar novos quantificadores para outras cardinalidades, como existe um número finito de… ou existe um número par de….\n\nPer Lindström (1966): O lógico sueco levou a generalização a um nível de abstração ainda maior. Ele demonstrou que um quantificador pode ser entendido como uma classe de estruturas, ou, de forma mais intuitiva, como uma relação entre múltiplos conjuntos definidos sobre o domínio. O trabalho de Lindström foi tão profundo que culminou no famoso Teorema de Lindström, que caracteriza a Lógica de Primeira Ordem precisamente em termos de suas propriedades (como a Compacidade e a propriedade de Löwenheim-Skolem) e mostra que nenhuma extensão com quantificadores mais fortes pode reter todas essas propriedades simultaneamente.\n\n\n\n6.10.0.2 2. Explorando a Variedade de Quantificadores\nOs quantificadores generalizados nos oferecem um verdadeiro zoológico de novas ferramentas lógicas. Vamos explorar as categorias mais importantes com exemplos.\n\n6.10.0.2.1 2.1. Quantificadores de Contagem (Numéricos)\nEstes são os mais intuitivos. Eles nos permitem especificar o número de elementos que satisfazem uma propriedade.\n\nExistência de pelo menos n: \\(\\exists_{\\ge n}x: P(x)\\)\nExistência de no máximo n: \\(\\exists_{\\le n}x: P(x)\\)\nExistência de exatamente n: \\(\\exists_{=n}x: P(x)\\)\n\nO quantificador de unicidade existencial (\\(\\exists!\\)) que já estudamos é simplesmente o caso especial \\(\\exists_{=1}\\).\nExemplo Prático: Gerenciamento de Redes\nImagine um sistema que monitora o status de servidores em um data center.\n\nDomínio \\(D\\): O conjunto de todos os servidores \\(\\{s_1, s_2, s_3, \\dots, s_{50}\\}\\).\nPredicado: \\(Offline(x)\\), que é verdadeiro se o servidor \\(x\\) está offline.\n\nUma regra de alerta crítico poderia ser: Se pelo menos 5 servidores estiverem offline, acione o alarme geral.\n\nFormalização:\n\\[(\\exists_{\\ge 5}x: Offline(x)) \\rightarrow AlarmeGeral()\\]\n\nOutra regra poderia ser: O sistema está operando em modo de contingência se existirem exatamente 2 servidores de backup ativos. * Formalização:\n\\[\\exists_{=2}y: (ServidorBackup(y) \\land Ativo(y)) \\rightarrow ModoContingencia()\\]\nEscrever \\(\\exists_{\\ge 5}\\) em LPO padrão exigiria uma fórmula gigantesca com 5 variáveis diferentes, tornando-se impraticável rapidamente.\n\n\n6.10.0.2.2 2.2. Quantificadores Proporcionais\nEstes quantificadores são cruciais para a linguística e a inteligência artificial, pois capturam noções de proporção e maioria, que são ubíquas no raciocínio humano.\nO mais famoso é o quantificador A maioria (Most). A semântica formal de A maioria dos A’s são B’s é:\n\\[\n\\text{Most } x (A(x), B(x)) \\iff |\\{x \\mid A(x) \\land B(x)\\}| &gt; |\\{x \\mid A(x) \\land \\neg B(x)\\}|\n\\]\nEm outras palavras, o número de A’s que são B’s é estritamente maior que o número de A’s que não são B’s.\nExemplo Prático: Análise Social\nVamos modelar uma afirmação de uma pesquisa de opinião. * Domínio \\(D\\): O conjunto de todos os cidadãos de um país. * Predicados: \\(Eleitor(x)\\) e \\(AprovaGestao(x)\\).\nA afirmação A maioria dos eleitores aprova a gestão atual é formalizada como: * Formalização: \\[\\text{Most } x (Eleitor(x), AprovaGestao(x))\\]\nOutros quantificadores como Poucos (Few) e Muitos (Many) também pertencem a esta categoria, mas sua semântica é frequentemente dependente do contexto, o que os torna um tópico de estudo em lógicas fuzzy e outras áreas da Inteligência Artificial.\n\n\n6.10.0.2.3 2.3. Quantificadores de Cardinalidade Infinita\nEm matemática e teoria dos conjuntos, é fundamental distinguir entre conjuntos finitos e infinitos.\n\nExiste uma infinidade de…: \\(\\exists^{\\infty}x: P(x)\\)\nExiste um número finito de…: \\(\\exists^{&lt;\\infty}x: P(x)\\)\n\nExemplo Clássico: Teoria dos Números\nUm dos teoremas mais belos da matemática, provado por Euclides, é que existem infinitos números primos.\n\nDomínio \\(D\\): O conjunto dos números naturais \\(\\mathbb{N}\\).\nPredicado: \\(Primo(x)\\).\n\nA afirmação pode ser elegantemente formalizada como:\n\nFormalização:\n\\[\\exists^{\\infty}x: Primo(x)\\]\n\nEsta é uma afirmação impossível de ser feita na Lógica de Primeira Ordem padrão sobre a aritmética (devido a propriedades como a Compacidade), o que demonstra o salto de expressividade que os quantificadores generalizados fornecem.\n\n\n\n6.10.0.3 3. Aplicações Modernas\nA teoria dos quantificadores generalizados não é apenas um exercício de abstração lógica. Ela tem aplicações concretas e profundas em diversas áreas:\n\nLinguística Computacional e Semântica Formal: É a principal ferramenta para analisar a estrutura lógica de sentenças em linguagem natural. Quase todos os determinantes (três, vários, muitos, a maioria, nenhum) são modelados como quantificadores generalizados.\nCiência da Computação e Bancos de Dados: Linguagens de consulta (como SQL) utilizam esses conceitos o tempo todo. Uma consulta como SELECT COUNT(*) FROM Usuarios WHERE Pais='Brasil' seguida de uma verificação HAVING COUNT(*) &gt; 1000 é, na essência, uma implementação do quantificador de contagem \\(\\exists_{&gt;1000}\\).\nInteligência Artificial: O raciocínio de senso comum é repleto de generalizações que não são estritamente universais. A afirmação Pássaros voam não significa que todos os pássaros voam (pinguins não voam). É melhor interpretada como A maioria dos pássaros voa, um conceito de Lógica Não-Monotônica que se baseia na quantificação proporcional.\n\nAo ir além de \\(\\forall\\) e \\(\\exists\\), descobrimos que o conceito de quantificação é muito mais rico e variado. Os quantificadores generalizados nos fornecem um framework matemático rigoroso para explorar essa riqueza, construindo uma ponte essencial entre a lógica formal e a complexidade do pensamento, da linguagem e da computação. Eles nos permitem não apenas criar mundos, mas descrevê-los com uma granularidade e uma precisão que a Lógica de Primeira Ordem padrão jamais poderia alcançar sozinha.",
    "crumbs": [
      "Fundamentos da Lógica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lógica de Primeira Ordem: Lógica Predicativa</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html",
    "href": "05-formas-normais-e-skolemizacao.html",
    "title": "7  Formas Normais: Estruturas de Solução",
    "section": "",
    "text": "7.1 Formas Normais, Lógica Proposicional\nExistem várias formas normais na Lógica Proposicional, cada uma com suas próprias regras e aplicações. A seguir, a esforçada leitora encontrará uma descrição resumida das formas normais, destacando algumas das principais:\n\\[\\forall x \\exists y (P(x,y))\\]\nSua forma após a Skolemização, que preserva a satisfatibilidade, será:\n\\[\\forall x (P(x, \\mathbf{\\mathbf{f}}(x)))\\]\nNosso objetivo, neste livro, é rever a matemática que suporta a Programação Lógica, entre as principais formas normais, para este objetivo, precisamos destacar duas formas:\nPara entender como conseguimos resolver problemas complexos de lógica, teremos que explorar essas formas normais em detalhes. Começando com a mais simples de todas, a Forma Normal Negativa.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais: Estruturas de Solução</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#formas-normais-lógica-proposicional",
    "href": "05-formas-normais-e-skolemizacao.html#formas-normais-lógica-proposicional",
    "title": "7  Formas Normais: Estruturas de Solução",
    "section": "",
    "text": "Forma Normal Negativa: Uma proposição está na Forma Normal Negativa se as operações de negação \\(\\neg\\) aparecerem apenas imediatamente antes das variáveis. Isso é conseguido aplicando as leis de De Morgan e eliminando as duplas negações.\n\\[\\neg (A \\wedge B) \\equiv (\\neg A \\vee \\neg B)\\]\nForma Normal Conjuntiva: uma proposição está na Forma Normal Conjuntiva se for uma conjunção, operação E, \\(\\wedge\\), de uma ou mais cláusulas, nas quais, cada cláusula é uma disjunção, operação OU, \\(\\vee\\), de literais. Em outras palavras, é uma série de cláusulas conectadas por Es, nas quais, cada cláusula é composta de variáveis conectadas por OUs. Uma forma normal conjuntiva é uma conjunção de disjunções.\n\\[(A \\vee B) \\wedge (C \\vee D) \\wedge (B \\vee D) \\wedge (A \\vee C)\\]\nForma Normal Disjuntiva: uma proposição está na Forma Normal Disjuntiva se for uma disjunção de uma ou mais cláusulas, na qual cada cláusula é uma conjunção de literais. Ou seja, é uma série de cláusulas conectadas por OUs, nas quais cada cláusula é composta de variáveis conectadas por Es, conjunções. A forma normal disjuntiva é uma disjunção de conjunções.\n\\[(A \\wedge B) \\vee (C \\wedge D) \\vee (A \\wedge C) \\vee (B \\wedge D)\\]\nForma Normal Prenex: uma proposição está na Forma Normal Prenex se todos os quantificadores, para a Lógica de Primeira Ordem, estiverem à esquerda, precedendo uma matriz quantificadora livre. Esta forma é útil na Lógica de Primeira Ordem e na teoria da prova.\n\\[\\forall x \\exists y \\forall z (P(x,y) \\wedge \\neg Q(z))\\]\nForma Normal Skolem: na Lógica de Primeira Ordem, uma fórmula está na Forma Normal de Skolem se estiver na Forma Normal Prenex e se todos os quantificadores existenciais forem eliminados. Isto é realizado através de um processo conhecido como Skolemização. Por exemplo, dada a fórmula:\n\n\n\n\n\n\nForma Normal Conjuntiva: a Forma Normal Conjuntiva é importante na Programação Lógica porque muitos sistemas de inferência, como a resolução, funcionam em fórmulas que estão na Forma Normal Conjuntiva. Além disso, os programas em Prolog, a linguagem de Programação Lógica que escolhemos, são formados por Cláusulas de Horn, que são um tipo específico de cláusula na Forma Normal Conjuntiva, cláusulas que possuem, no máximo, um literal positivo.\nForma Normal de Skolem: a Forma Normal de Skolem é útil na Programação Lógica porque a Skolemização, o processo de remover quantificadores existenciais transformando-os em funções de quantificadores universais, permite uma forma mais eficiente de representação e processamento de fórmulas lógicas. Essa forma normal é frequentemente usada em Lógica de Primeira Ordem e teoria da prova, ambas fundamentais para a Programação Lógica.\n\n\n\n7.1.1 Forma Normal Negativa\nA Forma Normal Negativa é como um capitão experiente que ajusta as velas de seu navio. Assim como o capitão remove o excesso de pano e reorganiza as velas para que cada uma capture o vento diretamente, a Forma Normal Negativa move cada negação para o mais próximo possível de seu alvo, os átomos da fórmula._\nÉ como o processo de desenrolar as linhas de pesca emaranhadas: pegamos cada fio de negação e o seguimos até sua extremidade natural, eliminando as voltas e os nós desnecessários que encontramos no caminho.\nUma fórmula está na Forma Normal Negativa se:\n\ntodos os operadores de negação \\(\\neg\\) são aplicados diretamente aos átomos, variáveis ou constantes.\nusaremos apenas a negação \\(\\neg\\), a conjunção \\(\\wedge\\), e a disjunção \\(\\vee\\).\n\nConverter uma fórmula para a Forma Normal Negativa envolve os seguintes passos:\n\nEliminar os Bicondicionais: substitua todas as ocorrências de \\(A\\leftrightarrow B\\) Por \\(A\\rightarrow B \\wedge B\\rightarrow A\\).\nEliminar Implicações: substitua todas as ocorrências de implicação \\(A \\rightarrow B\\) Por \\(\\neg A \\vee B\\).\nAplicar as Leis de De Morgan: Use as leis de De Morgan para mover as negações para dentro, aplicando:\n\n\n\\(\\neg (A \\wedge  B) \\equiv \\neg A \\vee \\neg B\\);\n\\(\\neg (A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\).\n\n\nEliminar Dupla Negação: Substitua qualquer dupla negação \\(\\neg \\neg A\\) Por \\(A\\).\n\n\n7.1.1.1 Exemplo 1\nConverta a fórmula \\(\\neg (A \\wedge  (B \\rightarrow C))\\) Para Forma Normal Negativa\nPara converter a fórmula, seguimos o processo passo a passo para mover as negações para o interior da expressão até que elas se apliquem apenas aos átomos.\n\nEliminar Implicações: Primeiro, substituímos a implicação \\(B \\rightarrow C\\) por sua equivalência \\(\\neg B \\vee C\\).\n\\[\\neg (A \\wedge  (\\neg B \\vee C))\\]\nAplicar Lei de De Morgan (na Conjunção): em seguida, aplicamos a lei de De Morgan \\(\\neg(P \\wedge  Q) \\equiv \\neg P \\vee \\neg Q\\) na conjunção principal.\n\\[\\neg A \\vee \\neg(\\neg B \\vee C)\\]\nAplicar Lei de De Morgan (na Disjunção): agora, aplicamos a lei de De Morgan \\(\\neg(P \\vee Q) \\equiv \\neg P \\wedge  \\neg Q\\) na parte direita da expressão.\n\\[\\neg A \\vee (\\neg\\neg B \\wedge  \\neg C)\\]\nEliminar Dupla Negação: finalmente, removemos a dupla negação \\(\\neg\\neg B\\), que é equivalente a \\(B\\).\n\\[\\neg A \\vee (B \\wedge  \\neg C)\\]\nA fórmula resultante está na Forma Normal Negativa. os operadores de negação (\\(\\neg\\)) aplicam-se diretamente aos átomos \\(A\\) e \\(C\\).\n\n\n\n7.1.1.2 Exemplo 2\nConverta a fórmula \\((A \\rightarrow B) \\wedge  \\neg (C \\vee D)\\) Para Forma Normal Negativa\nNeste exemplo, ambos os lados da conjunção principal (\\(\\wedge\\)) são tratados para se adequarem à Forma Normal Negativa.\n\nEliminar Implicações: O primeiro passo é converter a implicação \\(A \\rightarrow B\\) em sua equivalência, \\(\\neg A \\vee B\\). A segunda parte da fórmula não possui implicações.\n\\[(\\neg A \\vee B) \\wedge  \\neg (C \\vee D)\\]\nAplicar Lei de De Morgan: A seguir, aplicamos a lei de De Morgan na expressão \\(\\neg (C \\vee D)\\) para mover a negação para o interior dos parênteses.\n\\[(\\neg A \\vee B) \\wedge (\\neg C \\wedge \\neg D)\\]\n\nA fórmula já se encontra na Forma Normal Negativa. Todos os operadores de negação estão aplicados diretamente aos átomos (\\(A\\), \\(C\\) e \\(D\\)). Não há duplas negações que precisem ser eliminadas neste caso.\n\n\n\n7.1.2 Forma Normal Disjuntiva\nA Forma Normal Disjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma disjunção de conjunções. Trata-se de uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico.\nUma fórmula está na Forma Normal Disjuntiva se puder ser escrita como:\n\\[(C_1 \\wedge  C_2 \\wedge  \\ldots) \\vee (D_1 \\wedge  D_2 \\wedge  \\ldots) \\vee \\ldots\\]\nNa qual, cada \\(C_i\\) e \\(D_i\\) representam literais. Ou seja, ou representam uma variável ou sua negação. Com um pouco mais de formalidade matemática podemos afirmar que uma Fórmula Bem Formada está na Forma Normal Disjuntiva quando está na forma:\n\\[\\bigvee_{i=1}^{m} \\left( \\bigwedge_{j=1}^{n} L_{ij} \\right)\\]\nConverter uma fórmula para Forma Normal Disjuntiva é como identificar todas as combinações de ventos e correntes que levam o navio ao porto desejado. A fórmula original é a rota complexa, a disjunção de todas as opções de rotas. Cada termo da Forma Normal Disjuntiva que encontramos é como um cenário único e completo, uma conjunção de condições marítimas, que, por si só, garante que o navio chegue ao destino.\nPara esta conversão, a intrépida leitora deve seguir os seguintes passos:\n\nEliminar os Bicondicionais: substitua todas as ocorrências de \\(A\\leftrightarrow B\\) Por \\(A\\rightarrow B \\wedge B\\rightarrow A\\).\nEliminar Implicações: substitua todas as ocorrências de implicação \\(A \\rightarrow B\\) Por \\(\\neg A \\vee B\\).\nAplicar as Leis de De Morgan: use as leis de De Morgan para mover as negações para dentro, aplicando:\n\n\\(\\neg (A \\wedge  B) \\equiv \\neg A \\vee \\neg B\\)\n\\(\\neg (A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\)\n\nEliminar Dupla Negação: Substitua qualquer dupla negação \\(\\neg \\neg A\\) Por \\(A\\).\nAplicar a Lei Distributiva: Use a lei distributiva para expandir a fórmula, transformando-a em uma disjunção de conjunções.\n\n\n7.1.2.1 Exemplo 1\nConsidere a fórmula:\n\\[(A \\rightarrow B) \\wedge  (C \\vee \\neg (D \\wedge  E))\\]\nO objetivo é convertê-la para uma disjunção de conjunções.\n\nConverter para a Forma Normal Negativa\nPrimeiro, realizamos os passos iniciais para eliminar implicações e mover as negações para o interior da fórmula, o que nos dará uma forma intermediária.\n\nEliminar Implicações (\\(A \\rightarrow B \\equiv \\neg A \\vee B\\)):\n\\[(\\neg A \\vee B) \\wedge  (C \\vee \\neg (D \\wedge  E))\\]\nAplicar a Lei de De Morgan (\\(\\neg (D \\wedge  E) \\equiv \\neg D \\vee \\neg E\\)):\n\\[(\\neg A \\vee B) \\wedge  (C \\vee \\neg D \\vee \\neg E)\\]\n\nNeste ponto, a fórmula encontra-se na Forma Normal Conjuntiva . O passo seguinte é aplicar a distributividade para alcançar a Forma Normal Disjuntiva.\nAplicar a Lei Distributiva (Parte 1)\nUsamos a lei distributiva \\(P \\wedge  (Q \\vee R) \\equiv (P \\wedge  Q) \\vee (P \\wedge  R)\\). Vamos tratar o termo \\((\\neg A \\vee B)\\) como uma única unidade, \\(X\\), e distribuí-lo sobre \\((C \\vee \\neg D \\vee \\neg E)\\).\n\\[\\underbrace{(\\neg A \\vee B)}_{X} \\wedge  (C \\vee \\neg D \\vee \\neg E) \\equiv (X \\wedge  C) \\vee (X \\wedge  \\neg D) \\vee (X \\wedge  \\neg E)\\]\nSubstituindo \\(X\\) de volta, obtemos:\n\\[\n  ((\\neg A \\vee B) \\wedge  C) \\vee ((\\neg A \\vee B) \\wedge  \\neg D) \\vee ((\\neg A \\vee B) \\wedge  \\neg E)\n\\]\nAplicar a Lei Distributiva (Parte 2)\nAgora, aplicamos a lei distributiva \\((P \\vee Q) \\wedge  R \\equiv (P \\wedge  R) \\vee (Q \\wedge  R)\\) em cada uma das três cláusulas da expressão acima.\n\nPrimeiro termo: \\((\\neg A \\wedge  C) \\vee (B \\wedge  C)\\);\nSegundo termo: \\((\\neg A \\wedge  \\neg D) \\vee (B \\wedge  \\neg D)\\);\nTerceiro termo: \\((\\neg A \\wedge  \\neg E) \\vee (B \\wedge  \\neg E)\\).\n\nForma Normal Disjuntiva\nUnindo todos os termos expandidos com o operador \\(\\vee\\), chegamos à Forma Normal Disjuntiva final.\n\\[\n(\\neg A \\wedge  C) \\vee (B \\wedge  C) \\vee (\\neg A \\wedge  \\neg D) \\vee (B \\wedge  \\neg D) \\vee (\\neg A \\wedge  \\neg E) \\vee (B \\wedge  \\neg E)\n\\]\nA expressão agora é uma disjunção de múltiplas conjunções, que é a definição da Forma Normal Disjuntiva.\n\n\n\n7.1.2.2 Exemplo 2\nConsidere:\n\\[(\\neg A \\wedge  (B \\rightarrow C)) \\vee (D \\wedge  \\neg (E \\rightarrow F))\\]\n\nEliminar Implicações\n\\[(\\neg A \\wedge  (\\neg B \\vee C)) \\vee (D \\wedge  \\neg (\\neg E \\vee F)) \\equiv (\\neg A \\wedge  (\\neg B \\vee C)) \\vee (D \\wedge  (E \\wedge  \\neg F))\\]\nDistribuir a Disjunção\n\\[(\\neg A \\wedge  \\neg B \\vee \\neg A \\wedge  C) \\vee (D \\wedge  E \\wedge  \\neg F)\\]\nDistribuir a Disjunção Novamente\n\\[\\neg A \\wedge  \\neg B \\vee \\neg A \\wedge  C \\vee D \\wedge  E \\wedge  \\neg F\\]\n\n\n\n7.1.2.3 Exemplo 3\nConsidere a fórmula:\n\\[(P \\rightarrow Q) \\rightarrow (R \\vee S)\\]\n\nRemover as implicações (\\(\\rightarrow\\)):\n\\[P \\rightarrow Q \\equiv \\neg P \\vee Q\\]\nSubstituir a expressão original com a equivalência encontrada no passo 1:\n\\[(\\neg P \\vee Q) \\rightarrow (R \\vee S)\\]\nAplicar novamente a equivalência para remover a implicação:\n\\[\\neg (\\neg P \\vee Q) \\vee (R \\vee S)\\]\nAplicar a lei de De Morgan para expandir a negação:\n\\[(P \\wedge \\neg Q) \\vee (R \\vee S)\\]\n\n\n\n7.1.2.4 Exemplo 4\nConsidere a fórmula que representa a negação de uma bicondicional, que é logicamente equivalente a uma operação de ou exclusivo (XOR):\n\\[\n\\neg(P \\leftrightarrow Q)\n\\]\nVamos convertê-la para a Forma Normal Disjuntiva.\n\nEliminar a Bicondicional\nO primeiro passo é substituir o operador de bicondicional (\\(A \\leftrightarrow B\\)) por sua definição equivalente: \\((A \\rightarrow B) \\wedge  (B \\rightarrow A)\\).\n\\[\n\\neg((P \\rightarrow Q) \\wedge  (Q \\rightarrow P))\n\\]\nEliminar as Implicações\nAgora, convertemos as duas implicações internas em suas formas disjuntivas, usando a regra \\(A \\rightarrow B \\equiv \\neg A \\vee B\\).\n\\[\n\\neg((\\neg P \\vee Q) \\wedge  (\\neg Q \\vee P))\n\\]\nAplicar a Lei de De Morgan\nAplicamos a lei de De Morgan na negação que cobre toda a expressão, transformando a conjunção (\\(\\wedge\\)) em disjunção (\\(\\vee\\)) e movendo a negação para os termos internos.\n\\[\n\\neg(\\neg P \\vee Q) \\vee \\neg(\\neg Q \\vee P)\n\\]\nAplicar a Lei de De Morgan Novamente e Simplificar\nPara finalizar, aplicamos a lei de De Morgan em cada um dos termos e removemos as duplas negações (\\(\\neg\\neg A \\equiv A\\)) que surgem no processo.\n\\[\n(\\neg\\neg P \\wedge  \\neg Q) \\vee (\\neg\\neg Q \\wedge  \\neg P)\n\\]\nSimplificando, obtemos a Forma Normal Disjuntiva final:\n\\[\n(P \\wedge  \\neg Q) \\vee (\\neg P \\wedge  Q)\n\\]\nA expressão resultante é uma disjunção de duas conjunções, o que corresponde perfeitamente à definição da Forma Normal Disjuntiva.\n\n\n\n7.1.2.5 Exemplo 5\nConsidere a seguinte fórmula com uma implicação principal e uma bicondicional aninhada:\n\\[\\neg(P \\wedge  Q) \\rightarrow (R \\leftrightarrow S)\\]\nNosso objetivo é convertê-la para a Forma Normal Disjuntiva.\n\nEliminar a Implicação Principal\nUtilizando a equivalência \\(A \\rightarrow B \\equiv \\neg A \\vee B\\), removemos o operador de implicação principal da fórmula.\n\\[\n\\neg(\\neg(P \\wedge  Q)) \\vee (R \\leftrightarrow S)\n\\]\nEliminar a Dupla Negação\nA expressão \\(\\neg(\\neg(P \\wedge  Q))\\) simplifica-se diretamente para \\((P \\wedge  Q)\\), resultando em:\n\\[\n(P \\wedge  Q) \\vee (R \\leftrightarrow S)\n\\]\nEliminar a Bicondicional\nSubstituímos a bicondicional \\(R \\leftrightarrow S\\) por sua definição equivalente: \\((R \\rightarrow S) \\wedge  (S \\rightarrow R)\\).\n\\[\n(P \\wedge  Q) \\vee ((R \\rightarrow S) \\wedge  (S \\rightarrow R))\n\\]\nEm seguida, eliminamos as implicações restantes:\n\\[\n(P \\wedge  Q) \\vee ((\\neg R \\vee S) \\wedge  (\\neg S \\vee R))\n\\]\nNote que a expressão ainda não está em Forma Normal Disjuntiva. A parte direita é uma conjunção.\nAplicar a Lei Distributiva\nPara que toda a expressão se torne uma disjunção de conjunções, precisamos converter a parte \\((\\neg R \\vee S) \\wedge  (\\neg S \\vee R)\\) para Forma Normal Disjuntiva. Fazemos isso aplicando a distributividade:\n\\[\n(\\neg R \\vee S) \\wedge  (\\neg S \\vee R) \\equiv (\\neg R \\wedge  \\neg S) \\vee (\\neg R \\wedge  R) \\vee (S \\wedge  \\neg S) \\vee (S \\wedge  R)\n\\]\nAs cláusulas \\((\\neg R \\wedge  R)\\) e \\((S \\wedge  \\neg S)\\) são contradições (sempre falsas), então podem ser removidas, simplificando a expressão para:\n\\[\n(\\neg R \\wedge  \\neg S) \\vee (S \\wedge  R)\n\\]\nForma Normal Disjuntiva\nAgora, substituímos a Forma Normal Disjuntiva que acabamos de derivar de volta na fórmula principal:\n\\[\n(P \\wedge  Q) \\vee ((\\neg R \\wedge  \\neg S) \\vee (S \\wedge  R))\n\\]\nComo o operador \\(\\vee\\) é associativo, podemos remover os parênteses extras, chegando à Forma Normal Disjuntiva final:\n\\[\n(P \\wedge  Q) \\vee (\\neg R \\wedge  \\neg S) \\vee (S \\wedge  R)\n\\]\nA fórmula final está corretamente expressa como uma disjunção de três conjunções de literais.\n\nA Forma Normal Disjuntiva é útil porque qualquer fórmula lógica pode ser representada desta forma. Além disso, essa representação é única, com exceção da ordem dos literais e das cláusulas.\n\n\n7.1.2.6 Exercícios de Conversão para Forma Normal Disjuntiva\n1. Converta a seguinte fórmula para Forma Normal Disjuntiva:\n\\[\n((P \\leftrightarrow Q) \\rightarrow R) \\wedge \\neg(R \\rightarrow (P \\vee Q))\n\\]\n2. Converta para Forma Normal Disjuntiva a fórmula que representa a negação de uma tautologia clássica:\n\\[\n\\neg((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R)))\n\\]\n3. Dada a fórmula com múltiplas bicondicionais aninhadas, obtenha sua Forma Normal Disjuntiva:\n\\[\n(P \\leftrightarrow (Q \\leftrightarrow R)) \\vee \\neg(P \\wedge Q \\wedge R)\n\\]\n4. Converta a seguinte fórmula complexa para Forma Normal Disjuntiva:\n\\[\n\\neg((P \\vee Q) \\rightarrow (R \\wedge S)) \\leftrightarrow (P \\rightarrow \\neg Q)\n\\]\n5. Transforme em Forma Normal Disjuntiva a fórmula:\n\\[\n((P \\wedge Q) \\rightarrow (R \\vee S)) \\wedge ((R \\rightarrow P) \\vee (S \\rightarrow Q))\n\\]\n6. Obtenha a Forma Normal Disjuntiva para:\n\\[\n\\neg(P \\leftrightarrow \\neg Q) \\rightarrow ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\n7. Converta para Forma Normal Disjuntiva a fórmula que combina negação de implicação com bicondicional:\n\\[\n\\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow R)) \\leftrightarrow (P \\wedge \\neg R)\n\\]\n\n\n\n7.1.3 Forma Normal Conjuntiva\nA Forma Normal Conjuntiva é uma representação canônica de fórmulas lógicas em que a fórmula é escrita como uma conjunção de disjunções. Em outras palavras, é uma expressão lógica na forma de uma conjunção de disjunções. É uma forma canônica útil para a análise e manipulação de fórmulas lógicas e é comumente usada em algoritmos de raciocínio lógico e simplificação de fórmulas.\nA diferença entre Forma Normal Conjuntiva e Forma Normal Disjuntiva é como a diferença entre dois estilos de organização de uma biblioteca:\nA Forma Normal Conjuntiva é como uma esquadra naval na qual cada embarcação, conjunção, deve ter pelo menos um tripulante qualificado, disjunção. Você só fica satisfeito se TODAS as embarcações tiverem alguém capacitado a bordo.\nDizemos que uma fórmula está na Forma Normal Conjuntiva se puder ser expressa na forma:\n\\[(D_1 \\vee D_2 \\vee \\ldots \\vee D_n) \\wedge  (E_1 \\vee E_2 \\vee \\ldots \\vee E_m) \\wedge  \\ldots\\]\nNa qual, \\(D_1, \\ldots , D_n\\) e \\(E_1, \\ldots ,E_m\\) representam literais. Podemos dizer que a Forma Normal Conjuntiva acontece quando a Fórmula Bem Formada está na forma:\n\\[\\bigwedge_{i=1}^{m} \\left( \\bigvee_{j=1}^{n} L_{ij} \\right)\\]\nConverter uma fórmula proposicional para a Forma Normal Conjuntiva é um processo algorítmico que garante que a expressão final seja uma conjunção de disjunções. Os passos são os seguintes:\n\nEliminar Bicondicionais: Substitua todas as ocorrências da bicondicional pela sua definição baseada em implicações.\n\\[\nA \\leftrightarrow B \\equiv (A \\rightarrow B) \\wedge  (B \\rightarrow A)\n\\]\nEliminar Implicações: Em seguida, remova todas as implicações, trocando-as por sua equivalência com o uso de disjunção e negação.\n\\[\nA \\rightarrow B \\equiv \\neg A \\vee B\n\\]\nMover Negações para o Interior (Converter para Forma Normal Negativa): Use as Leis de De Morgan e a Lei da Dupla Negação para mover todos os operadores de negação (\\(\\neg\\)) para dentro da expressão, até que eles se apliquem apenas diretamente às variáveis atômicas. As regras principais são:\n\n\\(\\neg(A \\wedge  B) \\equiv \\neg A \\vee \\neg B\\)\n\\(\\neg(A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\)\n\\(\\neg\\neg A \\equiv A\\)\n\nAo final deste passo, a fórmula estará em Forma Normal Negativa .\nAplicar a Lei Distributiva: Para finalizar, aplique a lei distributiva para garantir que nenhuma conjunção (\\(\\wedge\\)) esteja aninhada dentro de uma disjunção (\\(\\vee\\)). A regra chave é distribuir o \\(\\vee\\) sobre o \\(\\wedge\\).\n\\[\nA \\vee (B \\wedge  C) \\equiv (A \\vee B) \\wedge  (A \\vee C)\n\\]\nEste passo deve ser repetido até que a fórmula inteira seja uma conjunção de cláusulas, nas quais cada cláusula é uma disjunção de literais, satisfazendo a definição da Forma Normal Conjuntiva.\n\n\n7.1.3.1 Exemplo 1\nConsidere a fórmula:\n\\[(A \\wedge  B) \\rightarrow (C \\vee D)\\]\n\nEliminar Implicações:\n\\[\\neg (A \\wedge  B) \\vee (C \\vee D) \\equiv (\\neg A \\vee \\neg B) \\vee (C \\vee D)\\]\n\nNeste ponto temos \\((\\neg A \\vee \\neg B) \\vee (C \\vee D)\\) e podemos remover os parênteses obtendo:\n\\[\\neg A \\vee \\neg B \\vee C \\vee D\\]\nAqui a atenta leitora deve observar que temos uma única cláusula, ou seja, uma Forma Normal Conjuntiva com apenas uma cláusula. Nenhuma outra simplificação é necessária.\n\n\n7.1.3.2 Exemplo 2\nConsidere a fórmula:\n\\[(A \\wedge  \\neg B) \\vee (\\neg C \\wedge  D) \\rightarrow (E \\vee F)\\]\n\nEliminar Implicações (usando a equivalência \\(P \\rightarrow Q \\equiv \\neg P \\vee Q\\)):\n\n\\[\\neg ((A \\wedge  \\neg B) \\vee (\\neg C \\wedge  D)) \\vee (E \\vee F)\\]\n\nMover a Negação para Dentro (usando Leis de De Morgan):\n\n\\[((\\neg A \\vee B) \\wedge (C \\vee \\neg D)) \\vee (E \\vee F)\\]\n\nDistribuir a Disjunção sobre a Conjunção (usando a equivalência \\((P \\wedge Q) \\vee R \\equiv (P \\vee R) \\wedge (Q \\vee R)\\)):\n\n\\[(\\neg A \\vee B \\vee E \\vee F) \\wedge (C \\vee \\neg D \\vee E \\vee F)\\]\n\n\n7.1.3.3 Exemplo 3\nConsidere a fórmula:\n\\[\n(P \\wedge (Q \\vee R)) \\vee (\\neg P \\wedge \\neg Q)\n\\]\nConversão para Forma Normal Conjuntiva:\n\nAplicar a lei distributiva no primeiro termo: expandir \\((P \\wedge (Q \\vee R))\\) usando \\(A \\wedge (B \\vee C) \\equiv (A \\wedge B) \\vee (A \\wedge C)\\)\n\\[(P \\wedge Q) \\vee (P \\wedge R) \\vee (\\neg P \\wedge \\neg Q)\\]\nNeste ponto, temos uma Forma Normal Disjuntiva .\nConstruir a tabela-verdade para determinar a Forma Normal Conjuntiva:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(P \\wedge Q\\)\n\\(P \\wedge R\\)\n\\(\\neg P \\wedge \\neg Q\\)\nResultado\n\n\n\n\n\\(T\\)\n\\(T\\)\n\\(T\\)\n\\(T\\)\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\n\n\\(T\\)\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\\(F\\)\n\\(F\\)\n\\(T\\)\n\n\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\\(F\\)\n\\(T\\)\n\n\n\\(T\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\n\n\\(F\\)\n\\(T\\)\n\\(T\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\n\n\\(F\\)\n\\(T\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\n\n\\(F\\)\n\\(F\\)\n\\(T\\)\n\\(F\\)\n\\(F\\)\n\\(T\\)\n\\(T\\)\n\n\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(F\\)\n\\(T\\)\n\\(T\\)\n\n\n\n\nIdentificar as linhas falsas: as linhas 4, 5 e 6 têm resultado falso.\nConstruir cláusulas excludentes: para cada linha falsa, criamos uma cláusula que a proíbe:\n\nLinha 4 (P=T, Q=F, R=F): Para excluir esta combinação, criamos \\((\\neg P \\vee Q \\vee R)\\)\nLinha 5 (P=F, Q=T, R=T): Para excluir esta combinação, criamos \\((P \\vee \\neg Q \\vee \\neg R)\\)\n\nLinha 6 (P=F, Q=T, R=F): Para excluir esta combinação, criamos \\((P \\vee \\neg Q \\vee R)\\)\n\nFormar a Forma Normal Conjuntiva: a conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:\n\\[(\\neg P \\vee Q \\vee R) \\wedge (P \\vee \\neg Q \\vee \\neg R) \\wedge (P \\vee \\neg Q \\vee R)\\]\nSimplificação: podemos aplicar a lei da resolução nas duas últimas cláusulas:\nDe \\((P \\vee \\neg Q \\vee \\neg R) \\wedge (P \\vee \\neg Q \\vee R)\\), obtemos \\((P \\vee \\neg Q)\\)(eliminando \\(R\\) e \\(\\neg R\\)).\nForma Normal Conjuntiva simplificada:\n\\[(\\neg P \\vee Q \\vee R) \\wedge (P \\vee \\neg Q)\\]\n\n\n\n\n\n\n\nImportant\n\n\n\nObservação importante - Por que a conversão direta não funciona:\nA conversão direta de Forma Normal Disjuntiva para Forma Normal Conjuntiva através de distributividade simples frequentemente resulta em uma explosão exponencial de termos. Vamos ver por que:\nPara converter \\((P \\wedge Q) \\vee (P \\wedge R) \\vee (\\neg P \\wedge \\neg Q)\\) diretamente para Forma Normal Conjuntiva, precisaríamos aplicar a distributividade do \\(\\wedge\\) sobre \\(\\vee\\), usando a regra \\((A \\vee B) \\wedge (C \\vee D) \\equiv (A \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge C) \\vee (B \\wedge D)\\).\nSe tentássemos aplicar isso sistematicamente:\n\nPrimeiro, agruparíamos: \\(((P \\wedge Q) \\vee (P \\wedge R)) \\vee (\\neg P \\wedge \\neg Q)\\);\nCada aplicação de distributividade duplicaria o número de termos;\nCom 3 termos conjuntivos originais, cada um com 2 literais, a expansão completa geraria \\(2^3 = 8\\) combinações possíveis;\nMuitas dessas combinações seriam tautológicas ou contraditórias, requerendo simplificação adicional.\n\nExemplo da complexidade: Aplicando distributividade apenas ao primeiro passo:\n\n\\((P \\wedge Q) \\vee (P \\wedge R)\\) precisa ser convertido para Forma Normal Conjuntiva\nIsso exigiria criar pseudo-literais para cada conjunção\nA expressão resultante seria muito mais complexa que a Forma Normal Conjuntiva obtida pela tabela-verdade\n\nPor isso, métodos alternativos são preferíveis:\n\nTabela-verdade: Identifica diretamente as condições falsas, gerando a Forma Normal Conjuntiva mínima\nAlgoritmo de Tseitin: Introduz variáveis auxiliares para evitar explosão exponencial\nResolução reversa: Constrói cláusulas incrementalmente\n\nA abordagem pela tabela-verdade, embora limitada a fórmulas proposicionais pequenas, é mais sistemática e garante uma Forma Normal Conjuntiva correta sem a complexidade da distributividade direta.\n\n\n\n\n7.1.3.4 Exemplo 4\nConsidere a fórmula:\n\\[\\neg ((P \\wedge Q) \\vee \\neg (R \\wedge S))\\]\n\nAplicando a Lei de De Morgan na expressão inteira:\n\\[\n\\begin{align*}\n\\neg ((P \\wedge Q) \\vee \\neg (R \\wedge S)) &\\equiv \\neg (P \\wedge Q) \\wedge (R \\wedge S) \\quad \\text{(Lei de De Morgan)}\n\\end{align*}\n\\]\naplicando a Lei de De Morgan nos termos internos:\n\\[\n\\begin{align*}\n\\neg (P \\wedge Q) \\wedge (R \\wedge S) &\\equiv (\\neg P \\vee \\neg Q) \\wedge (R \\wedge S) \\quad \\text{(Lei de De Morgan)}\n\\end{align*}\n\\]\n\n\n\n7.1.3.5 Exemplo 5\nConsidere a seguinte fórmula, que é a negação da Lei de Peirce (uma conhecida tautologia na lógica clássica):\n\\[\\neg (((P \\rightarrow Q) \\rightarrow P) \\rightarrow P)\\]\nNosso objetivo é converter esta fórmula para a Forma Normal Conjuntiva para determinar sua natureza.\n\nEliminar a Implicação Mais Externa\nAplicamos a regra \\(A \\rightarrow B \\equiv \\neg A \\vee B\\) na implicação principal.\n\\[\\neg (\\neg((P \\rightarrow Q) \\rightarrow P) \\vee P)\\]\nAplicar a Lei de De Morgan\nAgora, aplicamos a lei \\(\\neg(A \\vee B) \\equiv \\neg A \\wedge  \\neg B\\) na fórmula.\n\\[\\neg\\neg((P \\rightarrow Q) \\rightarrow P) \\wedge  \\neg P\\]\nEliminar a Dupla Negação\nA dupla negação é removida, simplificando a expressão.\n\\[((P \\rightarrow Q) \\rightarrow P) \\wedge  \\neg P\\]\nEliminar as Implicações Restantes\nContinuamos eliminando as implicações de dentro para fora.\n\\[(\\neg(P \\rightarrow Q) \\vee P) \\wedge  \\neg P\\]\n\\[(\\neg(\\neg P \\vee Q) \\vee P) \\wedge  \\neg P\\]\nMover a Negação para o Interior\nAplicamos a Lei de De Morgan no primeiro termo aninhado.\n\\[((P \\wedge  \\neg Q) \\vee P) \\wedge  \\neg P\\]\nNeste ponto, a expressão \\(((P \\wedge  \\neg Q) \\vee P) \\wedge  \\neg P\\) está em Forma Normal Disjuntiva. Para prosseguir com a conversão para Forma Normal Conjuntiva, precisamos aplicar a lei distributiva nela.\nAplicar a Lei Distributiva\nDistribuímos \\(\\vee P\\) sobre \\((P \\wedge  \\neg Q)\\) usando a regra \\((A \\wedge  B) \\vee C \\equiv (A \\vee C) \\wedge  (B \\vee C)\\).\n\\[((P \\vee P) \\wedge  (\\neg Q \\vee P)) \\wedge  \\neg P\\]\nSimplificar e Reassociar\nSimplificamos \\((P \\vee P)\\) para \\(P\\)(Idempotência) e reassociamos os termos para agrupar \\(P\\) e \\(\\neg P\\).\n\\[(P \\wedge  (\\neg Q \\vee P)) \\wedge  \\neg P\\]\n\\[(P \\wedge  \\neg P) \\wedge  (\\neg Q \\vee P)\\]\nResultado\nA expressão \\((P \\wedge  \\neg P)\\) é uma contradição, equivalente a \\(Falso\\)(\\(F\\)). Qualquer conjunção com \\(F\\) resulta em \\(F\\).\n\\[F \\wedge  (\\neg Q \\vee P)\\]\n\\[F\\]\nA fórmula original é uma contradição. A Forma Normal Conjuntiva de uma contradição pode ser representada simplesmente como \\(F\\), ou por qualquer conjunção contraditória, como \\((P \\wedge  \\neg P)\\).\n\n\nNegação da Lei de Peirce\nA Lei de Peirce é uma tautologia fundamental da lógica clássica, formulada como:\n\\[((P \\rightarrow Q) \\rightarrow P) \\rightarrow P\\]\nA negação da Lei de Peirce é expressa por:\n\\[\\neg(((P \\rightarrow Q) \\rightarrow P) \\rightarrow P)\\]\nEsta negação representa uma fórmula que é:\n\nSempre falsa na lógica clássica (sendo a negação de uma tautologia);\nSatisfazível em alguns sistemas de lógica intuicionista;\nUm exemplo importante de fórmula que distingue lógica clássica de lógica intuicionista.\n\nPara entender melhor, considere que a a lógica clássica é baseada em princípios fundamentais como:\n\nPrincípio do Terceiro Excluído: para qualquer proposição \\(P\\), ou \\(P\\) é verdadeira ou \\(\\neg P\\) é verdadeira: \\(P \\vee \\neg P\\);\nPrincípio da Não-Contradição: uma proposição não pode ser simultaneamente verdadeira e falsa: \\(\\neg(P \\wedge \\neg P)\\);\nReductio ad Absurdum: se assumir \\(\\neg P\\) leva a uma contradição, então \\(P\\) deve ser verdadeira.\n\nPor outro lado, a lógica intuicionista, desenvolvida por Brouwer e formalizada por Heyting, rejeita o princípio do terceiro excluído. Principais características:\n\nUma proposição só é considerada verdadeira se existe uma prova construtiva de sua verdade;\nA negação de uma proposição \\(\\neg P\\) significa que assumir \\(P\\) leva a uma contradição;\n\\(P \\vee \\neg P\\) não é universalmente válida - requer demonstração específica para cada \\(P\\).\n\nDiferenças Fundamentais entre a Lógica Clássica e a Intuicionista\n\nInterpretação da Implicação: Na lógica clássica, \\(P \\rightarrow Q\\) é falsa apenas quando \\(P\\) é verdadeira e \\(Q\\) é falsa. Na lógica intuicionista, \\(P \\rightarrow Q\\) requer uma construção que transforme qualquer prova de \\(P\\) em uma prova de \\(Q\\)\nExistência: Na lógica clássica, provar \\(\\exists x \\, P(x)\\) pode ser feito mostrando que \\(\\neg \\forall x \\, \\neg P(x)\\). Na lógica intuicionista, é necessário fornecer um exemplo específico\nDupla Negação: \\(\\neg \\neg P \\rightarrow P\\) é válida na lógica clássica, mas não na intuicionista\n\nNa lógica intuicionista, a negação da Lei de Peirce não é uma contradição. O princípio do terceiro excluído não é universalmente válido. Isso significa que existem modelos intuicionistas nos quais:\n\\[\\neg(((P \\rightarrow Q) \\rightarrow P) \\rightarrow P)\\]\npode ser verdadeira, demonstrando uma diferença fundamental entre os sistemas lógicos clássico e intuicionista.\nA fórmula original \\((((P \\rightarrow Q) \\rightarrow P) \\rightarrow P)\\) é equivalente ao reductio ad absurdum e ao princípio do terceiro excluído na lógica clássica.\n\n\n\n7.1.3.6 Exemplo 6\nConsidere a fórmula:\n\\[(P \\rightarrow Q) \\leftrightarrow (P \\rightarrow R)\\]\n\nComeçamos pela definição de equivalência e implicação:\n\\[(P \\rightarrow Q) \\leftrightarrow (P \\rightarrow R)\\]\nAplicamos as definições de implicação:\n\\[(\\neg P \\vee Q) \\leftrightarrow (\\neg P \\vee R)\\]\nAgora, aplicamos a definição de equivalência, transformando-a em uma conjunção de duas implicações:\n\\[((\\neg P \\vee Q) \\rightarrow (\\neg P \\vee R)) \\wedge  ((\\neg P \\vee R) \\rightarrow (\\neg P \\vee Q))\\]\nEm seguida, aplicamos a definição de implicação novamente para cada uma das implicações internas:\n\\[(\\neg (\\neg P \\vee Q) \\vee (\\neg P \\vee R)) \\wedge  (\\neg (\\neg P \\vee R) \\vee (\\neg P \\vee Q))\\]\nVamos aplicar a lei de De Morgan e a lei da dupla negação para simplificar a expressão:\n\\[((P \\wedge  \\neg Q) \\vee (\\neg P \\vee R)) \\wedge  ((P \\wedge  \\neg R) \\vee (\\neg P \\vee Q))\\]\nAplicando a lei distributiva para desenvolver cada conjunção interna em disjunções:\n\\[((P \\vee (\\neg P \\vee R)) \\wedge  (\\neg Q \\vee (\\neg P \\vee R))) \\wedge  ((P \\vee (\\neg P \\vee Q)) \\wedge  (\\neg R \\vee (\\neg P \\vee Q)))\\]\n\nA aplicação das equivalências não é, nem de longe, a única forma de percorrer a rota da conversão de uma Fórmula Bem Formada em Forma Normal Conjuntiva.\n\n\n7.1.3.7 Exercícios de Conversão para Forma Normal Conjuntiva\n1. Converta a seguinte fórmula para Forma Normal Conjuntiva:\n\\[(P \\leftrightarrow Q) \\rightarrow ((P \\wedge R) \\vee (Q \\wedge \\neg R))\\]\n\\[(P \\leftrightarrow Q) \\rightarrow ((P \\wedge R) \\vee (Q \\wedge \\neg R))\\]\n2. Transforme em Forma Normal Conjuntiva a fórmula: \\[\\neg((P \\rightarrow Q) \\vee (Q \\rightarrow P)) \\wedge (P \\vee Q)\\]\n3. Converta para Forma Normal Conjuntiva a negação de uma tautologia distributiva:\n\\[\\neg((P \\wedge (Q \\vee R)) \\leftrightarrow ((P \\wedge Q) \\vee (P \\wedge R)))\\]\n4. Obtenha a Forma Normal Conjuntiva para:\n\\[((P \\vee Q) \\rightarrow R) \\leftrightarrow (P \\rightarrow R) \\wedge (Q \\rightarrow R)\\]\n5. Converta a seguinte fórmula complexa para Forma Normal Conjuntiva:\n\\[(P \\rightarrow (Q \\rightarrow R)) \\wedge \\neg((P \\wedge Q) \\rightarrow R)\\]\n6. Transforme em Forma Normal Conjuntiva:\n\\[((P \\leftrightarrow Q) \\vee (Q \\leftrightarrow R)) \\wedge \\neg(P \\leftrightarrow R)\\]\n7. Converta para Forma Normal Conjuntiva a fórmula:\n\\[\\neg(P \\rightarrow (Q \\vee R)) \\vee ((P \\wedge \\neg Q) \\rightarrow R)\\]\n\n\n\n7.1.4 Usando a Tabela-Verdade para Gerar Formas Normais\nA tabela-verdade é nosso navegador experiente que mapeia todas as rotas possíveis em águas desconhecidas das possibilidades lógicas. Como um cartógrafo naval que registra cada banco de areia e recife em uma nova rota marítima, a tabela-verdade cataloga cada combinação possível de verdades e falsidades, criando uma carta náutica completa do oceano lógico que a leitora deverá percorrer em busca da verdade.\nPara entender este conceito com um pouco mais de formalidade, considere a Fórmula Bem Formada dada por: \\((A \\vee B) \\rightarrow (C \\wedge  \\neg A)\\), se encontrarmos sua Tabela Verdade, poderemos encontrar, tanto a Forma Normal Conjuntiva quanto a Forma Normal Disjuntiva. Basta fixar nosso olhar nas linhas da verdade, ou da falsidade.\n\n7.1.4.1 Gerando a Forma Normal Disjuntiva\nPara transformar \\((A \\vee B) \\rightarrow (C \\wedge \\neg A)\\) na sua Forma Normal Conjuntiva, como um timoneiro disciplinado seguindo o roteiro de navegação, devemos seguir rigidamente, os seguintes passos:\n\nCriar a Tabela-Verdade\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(A\\)\n\\(B\\)\n\\(C\\)\n\\(\\neg A\\)\n\\(A \\vee B\\)\n\\(C \\wedge \\neg A\\)\n\\((A \\vee B) \\rightarrow (C \\wedge \\neg A)\\)\n\n\n\n\nT\nT\nT\nF\nT\nF\nF\n\n\nT\nT\nF\nF\nT\nF\nF\n\n\nT\nF\nT\nF\nT\nF\nF\n\n\nT\nF\nF\nF\nT\nF\nF\n\n\nF\nT\nT\nT\nT\nT\nT\n\n\nF\nT\nF\nT\nT\nF\nF\n\n\nF\nF\nT\nT\nF\nT\nT\n\n\nF\nF\nF\nT\nF\nF\nF\n\n\n\n\nIdentificar as Linhas com Resultado Verdadeiro\nAs linhas 5, 7 e 8 têm resultado verdadeiro.\nConstruir a Forma Normal Disjuntiva usando as linhas com resultados verdadeiros:\n\nNeste passo, nosso objetivo é construir uma expressão que seja verdadeira nas linhas 5, 7 e 8 (as linhas nas quais o resultado é verdadeiro), e falsa em todos os outros casos. Para fazer isso, criamos uma disjunção (uma expressão OR) para cada linha verdadeira que reflete as condições das variáveis nesta linha, e então unimos essas disjunções com uma conjunção (uma operação AND) para criar a Forma Normal Disjuntiva desejada:\n\nPrimeiro Termo Correspondente a Linha 5: \\((\\neg A \\wedge  B \\wedge  C)\\) Este termo é verdadeiro quando \\(A\\) é falso, \\(B\\) é verdadeiro e \\(C\\) é verdadeiro, o que corresponde à linha 5 da tabela.\nSegundo Termo Correspondente a Linha 7: \\((\\neg A \\wedge  \\neg B \\wedge  C)\\) Este termo é verdadeiro quando \\(A\\) é falso, \\(B\\) é falso e \\(C\\) é verdadeiro, o que corresponde à linha 7 da tabela.\nTerceiro Correspondente a Linha 8: \\((\\neg A \\wedge  \\neg B \\wedge  \\neg C)\\) Este termo é verdadeiro quando \\(A\\) é falso, \\(B\\) é falso e \\(C\\) é falso, o que corresponde à linha 8 da tabela.\n\nFinalmente, unimos estes termos com operações OR (\\(\\vee\\)) para criar a expressão Forma Normal Disjuntiva completa:\n\\[(A \\vee B) \\rightarrow (C \\wedge  \\neg A) = (\\neg A \\wedge  B \\wedge  C) \\vee (\\neg A \\wedge  \\neg B \\wedge  C) \\vee (\\neg A \\wedge  \\neg B \\wedge  \\neg C)\\]\nA expressão acima será verdadeira se qualquer um dos termos (ou seja, qualquer uma das linhas 5, 7 ou 8 da tabela) for verdadeiro, garantindo que a expressão capture exatamente as condições em que \\((A \\vee B) \\rightarrow (C \\wedge  \\neg A)\\) é verdadeira de acordo com a tabela-verdade.\n\n\n7.1.4.2 Gerando a Forma Normal Conjuntiva\nPara transformar \\((A \\vee B) \\rightarrow (C \\wedge  \\neg A)\\) em sua Forma Normal Conjuntiva usando a tabela-verdade, devemos nos concentrar nas linhas nas quais a fórmula é falsa e criar cláusulas que proíbam essas combinações de valores.\nPrincípio fundamental: Para cada linha falsa, criamos uma cláusula que será verdadeira exceto naquela linha específica.\n\nIdentificar as Linhas com Resultado Falso\nAs linhas 1, 2, 3, 4 e 6 têm resultado falso.\nConstruir Cláusulas Excludentes: para cada linha falsa, criamos uma cláusula que proíbe aquela combinação específica de valores de verdade:\nRegra de construção: Para cada linha falsa, se uma variável tem valor V (verdadeiro), colocamos sua negação na cláusula; se tem valor F (falso), colocamos a variável sem negação.\n\nLinha 1 (A=V, B=V, C=V): Para excluir esta combinação, criamos \\((\\neg A \\vee \\neg B \\vee \\neg C)\\);\nLinha 2 (A=V, B=V, C=F): Para excluir esta combinação, criamos \\((\\neg A \\vee \\neg B \\vee C)\\);\nLinha 3 (A=V, B=F, C=V): Para excluir esta combinação, criamos \\((\\neg A \\vee B \\vee \\neg C)\\);\nLinha 4 (A=V, B=F, C=F): Para excluir esta combinação, criamos \\((\\neg A \\vee B \\vee C)\\);\nLinha 6 (A=F, B=V, C=F): Para excluir esta combinação, criamos \\((A \\vee \\neg B \\vee C)\\).\n\nFormar a Forma Normal Conjuntiva: A conjunção de todas essas cláusulas nos dá a Forma Normal Conjuntiva:\n\\[\n\\begin{align*}\n(A \\vee B) \\rightarrow (C \\wedge  \\neg A) &\\equiv (\\neg A \\vee \\neg B \\vee \\neg C) \\\\\n&\\wedge (\\neg A \\vee \\neg B \\vee C) \\\\\n&\\wedge (\\neg A \\vee B \\vee \\neg C) \\\\\n&\\wedge (\\neg A \\vee B \\vee C) \\\\\n&\\wedge (A \\vee \\neg B \\vee C)\n\\end{align*}\n\\]\n\nVerificação: Cada cláusula é falsa apenas na linha correspondente da tabela-verdade. A conjunção de todas as cláusulas será verdadeira exceto quando pelo menos uma cláusula for falsa, o que acontece exatamente nas linhas na quais a fórmula original é falsa.\nA atenta leitora deve perceber que cada cláusula funciona como uma boia de sinalização que impede navegação em águas perigosas. Cada cláusula exclui uma rota específica (linha falsa) do mapa lógico, garantindo que a expressão final seja verdadeira em todas as outras rotas (linhas verdadeiras).",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais: Estruturas de Solução</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#formas-normais-lógica-predicativa-e-quantificadores",
    "href": "05-formas-normais-e-skolemizacao.html#formas-normais-lógica-predicativa-e-quantificadores",
    "title": "7  Formas Normais: Estruturas de Solução",
    "section": "7.2 Formas Normais, Lógica Predicativa e Quantificadores",
    "text": "7.2 Formas Normais, Lógica Predicativa e Quantificadores\n\n7.2.1 Forma Normal Prenex\nA Forma Normal Prenex é como um almirante experiente organizando a cadeia de comando antes de uma operação naval complexa.\nA criativa leitora pode imaginar uma esquadra na qual as ordens estão sendo transmitidas de forma caótica, alguns capitães recebem instruções diretas, outros recebem ordens através de subordinados, e as responsabilidades estão misturadas com as tarefas operacionais. A Forma Normal Prenex é como este almirante que, antes de qualquer manobra, convoca todos os comandantes para a ponte principal, estabelecendo claramente a hierarquia completa, quem comanda o quê e em que ordem, antes de transmitir as instruções operacionais.\nAssim como o almirante separa completamente a estrutura de comando (todos os quantificadores universais \\(\\forall\\) e existenciais \\(\\exists\\) movidos para frente) das ordens de execução (a matriz livre de quantificadores), a Forma Normal Prenex cria uma divisão clara entre quem decide e o que fazer.\nCom um pouco de formalidade a atenta leitora verá que a Forma Normal Prenex é uma padronização para fórmulas da lógica de primeira ordem. Nela, todos os quantificadores são deslocados para a frente da fórmula, deixando a matriz da fórmula livre de quantificadores. A Forma Normal Prenex apresenta três características principais:\n\nFacilitação da Manipulação Lógica: ao separar os quantificadores da matriz, a Forma Normal Prenex simplifica a análise e manipulação da estrutura lógica da fórmula;\nPreparação para Outras Formas Normais: serve como uma etapa intermediária na conversão para outras formas normais, como as Forma Normal Conjuntiva e Forma Normal Disjuntiva;\nUso em Provas Automáticas: é amplamente empregada em métodos de prova automática, tornando o raciocínio sobre quantificadores mais acessível.\n\nExemplo de conversão para Forma Normal Prenex:\nConsidere a fórmula original que não está em Forma Normal Prenex:\n\\[\n\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists z R(z)\n\\]\nPara convertê-la para Forma Normal Prenex, seguimos os passos:\n\nPadronizar variáveis: renomear variáveis para evitar conflitos\n\n\\[\n\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists w R(w)\n\\]\n\nEliminar implicações: substituir \\(P(x) \\rightarrow Q(x,y)\\) por \\(\\neg P(x) \\vee Q(x,y)\\)\n\n\\[\n\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge \\exists w R(w)\n\\]\n\nMover quantificadores para fora: extrair \\(\\exists y\\) e \\(\\exists w\\) para a frente, preservando a ordem relativa\n\n\\[\n\\exists w \\forall x \\exists y (R(w) \\wedge (\\neg P(x) \\vee Q(x,y)))\n\\]\nExemplo de fórmula já em Forma Normal Prenex:\nA fórmula a seguir já está em Forma Normal Prenex e não precisa de conversão:\n\\[\n\\exists x \\forall y (P(x,y) \\wedge Q(y))\n\\]\n\n\n\n\n\n\nWarning\n\n\n\nOrdem Crítica dos Quantificadores\nA ordem relativa entre quantificadores de tipos diferentes não pode ser alterada sem modificar o significado lógico:\n\n\\(\\exists x \\forall y \\, P(x,y)\\): Existe um x específico que funciona para todos os y;\n\\(\\forall y \\exists x \\, P(x,y)\\): Para cada y, pode existir um x diferente.\n\nExemplo prático:\n\n\\(\\exists x \\forall y \\, \\text{AmaX}(x,y)\\): Existe uma pessoa que ama todo mundo;\n\\(\\forall y \\exists x \\, \\text{AmaX}(x,y)\\): Todo mundo é amado por alguém.\n\nApenas quantificadores do mesmo tipo podem ser reordenados sem alterar o significado:\n\n\\(\\forall x \\forall y \\, P(x,y) \\equiv \\forall y \\forall x \\, P(x,y)\\);\n\\(\\exists x \\exists y \\, P(x,y) \\equiv \\exists y \\exists x \\, P(x,y)\\).\n\n\n\nIMPORTANTE: Quantificadores de tipos diferentes não podem ser trocados de ordem sem alterar o significado lógico. As fórmulas \\(\\exists x \\forall y \\phi(x,y)\\) e \\(\\forall y \\exists x \\phi(x,y)\\) não são equivalentes. A primeira é logicamente mais forte (existe um \\(x\\) específico que funciona para todos os \\(y\\)), enquanto a segunda é mais fraca (para cada \\(y\\), pode existir um \\(x\\) diferente).\nUma fórmula na Forma Normal Prenex segue uma estrutura específica definida por:\n\\[\nQ_1 x_1 \\, Q_2 x_2 \\, \\ldots \\, Q_n x_n \\, M(x_1, x_2, \\ldots, x_n)\n\\]\nNessa estrutura:\n\n\\(Q_i\\) são quantificadores, podendo ser universais \\(\\forall\\) ou existenciais \\(\\exists\\);\n\\(x_i\\) são as variáveis vinculadas pelos quantificadores;\n\\(M(x_1, x_2, \\ldots, x_n)\\) representa a matriz da fórmula, uma expressão lógica sem quantificadores.\n\nConverter uma fórmula para a Forma Normal Prenex envolve os seguintes passos:\n\nEliminar Implicações: substitua todas as ocorrências de implicação por disjunções e negações;\nMover Negações para Dentro: use as leis de De Morgan para mover as negações para dentro dos quantificadores e proposições;\nPadronizar Variáveis: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas;\nMover Quantificadores para Fora: mova todos os quantificadores para a esquerda da expressão, mantendo a ordem relativa quando necessário para preservar o significado.\n\nA Forma Normal Prenex é uma representação canônica de fórmulas da lógica de primeira ordem que separa claramente os quantificadores da matriz da fórmula. Ela é uma ferramenta amplamente utilizada na lógica e na teoria da prova, e sua compreensão é essencial para trabalhar com lógica de primeira ordem, especialmente na Lógica de Primeira Ordem e teoria da prova, ambas aplicadas na Programação Lógica.\n\n7.2.1.1 Regras de Equivalência Prenex\nA Forma Prenex de uma fórmula lógica com quantificadores contém todos os quantificadores para o início da fórmula. Existem algumas regras de equivalência que preservam a Forma Prenex quando aplicadas a uma fórmula:\n1. Comutatividade de quantificadores do mesmo tipo: a ordem dos quantificadores do mesmo tipo pode ser trocada em uma fórmula na Forma Prenex. Por exemplo:\n\\[\n\\forall x \\forall y \\ P(x,y) \\Leftrightarrow \\forall y \\forall x \\ P(x,y)\n\\]\nIsso ocorre porque a ordem dos quantificadores universais \\(\\forall x\\) e \\(\\forall y\\) não altera o significado lógico da fórmula. Essa propriedade é conhecida como comutatividade dos quantificadores.\n2. Associatividade de quantificadores do mesmo tipo: quantificadores do mesmo tipo podem ser agrupados de forma associativa em uma Forma Prenex. Por exemplo:\n\\[\n\\forall x \\forall y \\forall z \\ P(x,y,z) \\Leftrightarrow \\forall x (\\forall y \\forall z \\ P(x,y,z))\n\\]\nNovamente, o agrupamento dos quantificadores universais não muda o significado da fórmula. Essa é a propriedade associativa.\n3. Distributividade de quantificadores sobre operadores lógicos: existem regras específicas para a distribuição de quantificadores:\n\nO quantificador universal distribui sobre conjunção:\n\n\\[\n\\forall x (P(x) \\wedge Q(x)) \\Leftrightarrow (\\forall x \\ P(x)) \\wedge (\\forall x \\ Q(x))\n\\]\n\nO quantificador existencial distribui sobre disjunção:\n\n\\[\n\\exists x (P(x) \\vee Q(x)) \\Leftrightarrow (\\exists x \\ P(x)) \\vee (\\exists x \\ Q(x))\n\\]\nNote que \\(\\forall\\) não distribui sobre \\(\\vee\\) e \\(\\exists\\) não distribui sobre \\(\\wedge\\).\n\n\n7.2.1.2 Conversão para Formas Normais Conjuntiva e Disjuntiva\nA conversão para formas clausais (CNF/DNF) em lógica de primeira ordem segue estes passos:\n1. Eliminar Implicações: substitua todas as ocorrências de implicação da forma \\(A \\rightarrow B\\) por \\(\\neg A \\vee B\\).\n2. Mover a Negação para Dentro: use as leis de De Morgan para mover a negação para dentro dos quantificadores e das proposições:\n\n\\(\\neg \\forall x P(x) \\Leftrightarrow \\exists x \\neg P(x)\\)\n\\(\\neg \\exists x P(x) \\Leftrightarrow \\forall x \\neg P(x)\\)\n\n3. Padronizar Variáveis: certifique-se de que as variáveis ligadas a diferentes quantificadores sejam distintas, renomeando-as se necessário.\n4. Converter para Forma Normal Prenex: mova todos os quantificadores para o prefixo, preservando a ordem relativa.\n5. Eliminar os Quantificadores Existenciais (Skolemização): substitua cada quantificador existencial \\(\\exists x\\) por um novo termo constante ou Função Skolem, dependendo das variáveis quantificadas universalmente à esquerda no prefixo Prenex:\n\nSe o quantificador existencial não tem quantificadores universais à sua esquerda: Substitua \\(\\exists x P(x)\\) por \\(P(c)\\), sendo que \\(c\\) é uma nova constante.\nSe o quantificador existencial tem quantificadores universais à sua esquerda: Substitua \\(\\exists x P(x)\\) por \\(P(\\mathbf{\\mathbf{f}}(y_1, y_2, \\ldots, y_n))\\), sendo que \\(\\mathbf{\\mathbf{f}}\\) é uma nova função Skolem, e \\(y_1, y_2, \\ldots, y_n\\) são as variáveis universais à esquerda do quantificador existencial.\n\n6. Eliminar os Quantificadores Universais: remova os quantificadores universais, deixando apenas a matriz da fórmula. As variáveis que eram ligadas pelo quantificador universal agora são tratadas como variáveis livres na matriz da fórmula.\n7. Conversão para Forma Normal Conjuntiva ou Forma Normal Disjuntiva:\n\nPara Forma Normal Conjuntiva: use as leis distributivas para converter a matriz em uma conjunção de disjunções (cláusulas)\nPara Forma Normal Disjuntiva: use as leis distributivas para converter a matriz em uma disjunção de conjunções\n\n\n\n7.2.1.3 Exemplo 1 - Duas fórmulas logicamente equivalentes\nVamos considerar duas fórmulas logicamente equivalentes, uma na Forma Prenex e outra não. Considere a fórmula original:\n\\[\n\\forall x \\exists y (P(x) \\rightarrow Q(y))\n\\]\nSe convertida para a Forma Prenex teremos:\n\\[\n\\exists y \\forall x (P(x) \\rightarrow Q(y))\n\\]\nA equivalência pode ser demonstrada por meio do seguinte raciocínio: seja \\(I\\) uma interpretação (estrutura) para os predicados \\(P\\) e \\(Q\\) em um domínio não vazio.\nSuponha \\(I\\) satisfaz \\(\\forall x \\exists y (P(x) \\rightarrow Q(y))\\). Existem dois casos a considerar:\n\nSe não existe nenhum \\(x\\) tal que \\(P(x)\\) seja verdadeiro, então a implicação é vacuamente verdadeira para todos os \\(x\\), e qualquer \\(y\\) satisfará \\(\\exists y \\forall x (P(x) \\rightarrow Q(y))\\)\nSe existe pelo menos um \\(x\\) tal que \\(P(x)\\) é verdadeiro, então deve existir um \\(y\\) correspondente tal que \\(Q(y)\\) é verdadeiro. Este mesmo \\(y\\) funcionará para todos os \\(x\\), satisfazendo \\(\\exists y \\forall x (P(x) \\rightarrow Q(y))\\)\n\nAssim, existe um \\(y\\) fixo que satisfaz a condição para todo \\(x\\), preservando a equivalência. O raciocínio inverso também se aplica. Portanto, as fórmulas são logicamente equivalentes.\n\n\n7.2.1.4 Exemplo 2 - Conversão para Forma Prenex\nA fórmula:\n\\[\n\\forall x (P(x) \\rightarrow \\exists y Q(x,y))\n\\]\nPode ser convertida para Forma Normal Prenex seguindo os passos:\n\nEliminar implicação: substituir \\(P(x) \\rightarrow \\exists y Q(x,y)\\) por \\(\\neg P(x) \\vee \\exists y Q(x,y)\\)\n\n\\[\n\\forall x (\\neg P(x) \\vee \\exists y Q(x,y))\n\\]\n\nMover quantificadores para fora: extrair \\(\\exists y\\) para a frente, preservando a ordem (\\(\\forall\\) antes de \\(\\exists\\))\n\n\\[\n\\forall x \\exists y (\\neg P(x) \\vee Q(x,y))\n\\]\nA ordem dos quantificadores deve ser preservada para manter o significado original da fórmula.\n\n\n7.2.1.5 Exemplo 3: Fórmula Complexa com Estrutura Mista\nA fórmula original é:\n\\[\\forall x(P(x) \\leftrightarrow \\exists yQ(x, y)) \\vee \\forall zR(z)\\]\nO objetivo da Forma Normal Prenex é mover todos os quantificadores (∀, ∃) para o início da fórmula.\nPasso 1: Eliminar a Bicondicional (\\(\\leftrightarrow\\))\nPrimeiro, removemos o operador de bicondicional (\\(\\leftrightarrow\\)) usando a equivalência: \\(A \\leftrightarrow B \\equiv (A \\rightarrow B) \\wedge (B \\rightarrow A)\\)\nAplicando isso à nossa fórmula, a parte \\(P(x) \\leftrightarrow \\exists yQ(x, y)\\) se torna: \\((P(x) \\rightarrow \\exists yQ(x, y)) \\wedge (\\exists yQ(x, y) \\rightarrow P(x))\\)\nA fórmula completa agora é:\n\\[\\forall x((P(x) \\rightarrow \\exists yQ(x, y)) \\wedge (\\exists yQ(x, y) \\rightarrow P(x))) \\vee \\forall zR(z)\\]\nPasso 2: Eliminar as Implicações (\\(\\rightarrow\\))\nAgora, removemos as implicações (\\(\\rightarrow\\)) usando a equivalência: \\(A \\rightarrow B \\equiv \\neg A \\vee B\\)\nAplicamos isso às duas implicações da fórmula:\n\n\\(P(x) \\rightarrow \\exists yQ(x, y)\\) se torna \\(\\neg P(x) \\vee \\exists yQ(x, y)\\)\n\\(\\exists yQ(x, y) \\rightarrow P(x)\\) se torna \\(\\neg(\\exists yQ(x, y)) \\vee P(x)\\)\n\nSubstituindo de volta, a fórmula fica:\n\\[\\forall x((\\neg P(x) \\vee \\exists yQ(x, y)) \\wedge (\\neg (\\exists yQ(x, y)) \\vee P(x))) \\vee \\forall zR(z)\\]\nPasso 3: Mover as Negações para Dentro (\\(\\neg\\))\nA negação precisa ser aplicada diretamente aos predicados. Temos um termo \\(\\neg(\\exists yQ(x, y))\\). Usamos a regra de negação de quantificadores: \\(¬(∃v \\phi) \\equiv ∀v(¬\\phi)\\)\nEntão, \\(\\neg(\\exists yQ(x, y))\\) se torna \\(\\forall y(\\neg Q(x, y))\\).\nA fórmula atualizada é:\n\\[\\forall x((\\neg P(x) \\vee \\exists yQ(x, y)) \\wedge (\\forall y(\\neg Q(x, y)) \\vee P(x))) \\vee \\forall zR(z)\\]\nPasso 4: Renomear Variáveis (se necessário)\nPara evitar conflitos quando movermos os quantificadores, é uma boa prática garantir que cada quantificador use uma variável única. Na subfórmula dentro de \\(\\forall x\\), temos \\(\\exists y\\) e \\(\\forall y\\). Embora estejam em escopos diferentes (separados por um \\(\\wedge\\)), quando os movermos para fora, eles podem capturar a variável errada.\nPara evitar isso, vamos renomear uma das variáveis \\(y\\) para uma nova, como \\(w\\). Vamos renomear o \\(y\\) em \\(\\forall y(\\neg Q(x, y))\\).\nA fórmula fica:\n\\[\\forall x((\\neg P(x) \\vee \\exists yQ(x, y)) \\wedge (\\forall w(\\neg Q(x, w)) \\vee P(x))) \\vee \\forall zR(z)\\]\nPasso 5: Mover os Quantificadores para o Exterior\nAgora, movemos todos os quantificadores para a esquerda da fórmula, um de cada vez, de fora para dentro.\n5.1. Temos \\(\\forall x(...) \\vee \\forall zR(z)\\). Como \\(x\\) não aparece como variável livre em \\(\\forall zR(z)\\) e \\(z\\) não aparece como variável livre em \\(\\forall x(...)\\), podemos mover ambos os quantificadores para fora. A ordem entre eles não altera o resultado.\n\\[\\forall x \\forall z ( ((\\neg P(x) \\vee \\exists yQ(x, y)) \\wedge (\\forall w(\\neg Q(x, w)) \\vee P(x))) \\vee R(z) )\\]\n5.2. Agora vamos mover os quantificadores internos, \\(\\exists y\\) e \\(\\forall w\\), para fora do escopo de \\(\\forall x\\) e \\(\\forall z\\).\nPrimeiro, vamos tirá-los de suas cláusulas imediatas. * \\(\\neg P(x) \\vee \\exists yQ(x, y)\\) se torna \\(\\exists y(\\neg P(x) \\vee Q(x, y))\\)(pois \\(y\\) não é livre em \\(\\neg P(x)\\)). * \\(\\forall w(\\neg Q(x, w)) \\vee P(x)\\) se torna \\(\\forall w(\\neg Q(x, w) \\vee P(x))\\)(pois \\(w\\) não é livre em \\(P(x)\\)).\nA fórmula fica:\n\\[\\forall x \\forall z ( (\\exists y(\\neg P(x) \\vee Q(x, y)) \\wedge \\forall w(\\neg Q(x, w) \\vee P(x))) \\vee R(z) )\\]\n5.3. Agora, movemos \\(\\exists y\\) e \\(\\forall w\\) para fora do \\(\\wedge\\). Como \\(y\\) e \\(w\\) são variáveis distintas e não aparecem na outra cláusula, podemos movê-las para fora.\n\\[\\forall x \\forall z ( \\exists y \\forall w ((\\neg P(x) \\vee Q(x, y)) \\wedge (\\neg Q(x, w) \\vee P(x))) \\vee R(z) )\\]\n5.4. Finalmente, movemos \\(\\exists y\\) e \\(\\forall w\\) para fora do \\(\\vee\\). Como as variáveis \\(y\\) e \\(w\\) não são livres em \\(R(z)\\), podemos movê-las para o início da fórmula.\n\\[\\forall x \\forall z \\exists y \\forall w (((\\neg P(x) \\vee Q(x, y)) \\wedge (\\neg Q(x, w) \\vee P(x))) \\vee R(z))\\]\nResultado: a Forma Normal Prenex da fórmula é:\n\\[\\forall x \\forall z \\exists y \\forall w (((\\neg P(x) \\vee Q(x, y)) \\wedge (\\neg Q(x, w) \\vee P(x))) \\vee R(z))\\]\nA parte \\((((\\neg P(x) \\vee Q(x, y)) \\wedge (\\neg Q(x, w) \\vee P(x))) \\vee R(z))\\) é chamada de matriz e não contém nenhum quantificador.\n\n\n7.2.1.6 Exemplo 4: Fórmula Complexa com Estrutura Mista\nFórmula Original:\n\\[\n\\forall x (\\exists y \\, P(x,y) \\rightarrow \\forall z \\exists w \\, R(x,z,w))\n\\]\nConversão para Forma Normal Prenex:\nPrecisamos mover todos os quantificadores para o início da fórmula, seguindo as regras de equivalência lógica.\nPasso 1: Renomear variáveis ligadas para evitar conflitos. Como não há variáveis com mesmo nome em escopos diferentes, podemos prosseguir.\nPasso 2: Eliminar a implicação usando \\(A \\rightarrow B \\equiv \\neg A \\vee B\\):\n\\[\n\\forall x (\\neg \\exists y \\, P(x,y) \\vee \\forall z \\exists w \\, R(x,z,w))\n\\]\nPasso 3: Aplicar a negação ao quantificador existencial usando \\(\\neg \\exists y \\, P(x,y) \\equiv \\forall y \\neg P(x,y)\\):\n\\[\n\\forall x (\\forall y \\neg P(x,y) \\vee \\forall z \\exists w \\, R(x,z,w))\n\\]\nPasso 4: Mover os quantificadores internos para fora. Para mover quantificadores através de disjunção, precisamos garantir que as variáveis não ocorrem livres no outro disjunto:\n\n\\(\\forall y\\) pode sair já que \\(y\\) não ocorre em \\(R(x,z,w)\\);\n\\(\\forall z\\) e \\(\\exists w\\) podem sair, isso porque \\(z\\) e \\(w\\) não ocorrem em \\(P(x,y)\\).\n\n\\[\n\\forall x \\forall y \\forall z \\exists w (\\neg P(x,y) \\vee R(x,z,w))\n\\]\nNota: Quando movemos \\(\\forall\\) através de \\(\\vee\\), usamos a equivalência: \\((\\forall y \\, A(y)) \\vee B \\equiv \\forall y \\, (A(y) \\vee B)\\) quando \\(y\\) não ocorre livre em \\(B\\).\nPasso 5: Reordenar quantificadores (opcional para clareza). Como quantificadores universais consecutivos podem ser permutados, podemos manter a ordem atual:\n\\[\n\\forall x \\exists y \\forall z \\exists w (\\neg P(x,y) \\vee R(x,z,w))\n\\]\nNote que reordenamos para \\(\\exists y\\) antes de \\(\\forall z\\) para manter uma apresentação mais natural, mas isso não afeta a skolemização.\nAplicação da Skolemização:\nAgora identificamos as variáveis existenciais e suas dependências:\n\n\\(\\exists y\\): Precedido por \\(\\forall x\\)Função Skolem \\(\\mathbf{f}(x)\\)\n\\(\\exists w\\): Precedido por \\(\\forall x\\) e \\(\\forall z\\)Função Skolem \\(\\mathbf{f}(x,z)\\)\n\nResultado após Skolemização:\n\\[\n\\forall x \\forall z (\\neg P(x, \\mathbf{f}(x)) \\vee R(x, z, \\mathbf{f}(x,z)))\n\\]\nForma com Quantificadores Implícitos:\n\\[\n\\neg P(x, \\mathbf{f}(x)) \\vee R(x, z, \\mathbf{f}(x,z))\n\\]\nObservação: Esta última fórmula representa uma cláusula na Forma Normal Conjuntiva, pronta para uso em métodos de inferência como a resolução. A função \\(\\mathbf{f}(x)\\) captura a dependência de \\(y\\) em relação a \\(x\\), enquanto \\(\\mathbf{f}(x,z)\\) captura a dependência de \\(w\\) em relação tanto a \\(x\\) quanto a \\(z\\).\n\n\n7.2.1.7 Exemplo 5 - Conversão para Forma Normal Conjuntiva\nConsidere a fórmula original em Forma Normal Prenex:\n\\[\n\\exists x \\forall y (P(x) \\vee Q(y))\n\\]\nSiga os passos para conversão para Forma Normal Conjuntiva:\n\nEliminar os Quantificadores Existenciais (Skolemização): O quantificador existencial \\(\\exists x\\) não tem quantificadores universais à sua esquerda, então substitua por uma constante Skolem \\(c\\):\n\n\\[\n\\forall y (P(c) \\vee Q(y))\n\\]\n\nEliminar os Quantificadores Universais: Remova \\(\\forall y\\):\n\n\\[\nP(c) \\vee Q(y)\n\\]\n\nConversão para Forma Normal Conjuntiva: A matriz é uma disjunção, resultando em uma cláusula única:\n\n\\[\nP(c) \\vee Q(y)\n\\]\nIsso equivale à cláusula: \\(\\{P(c), Q(y)\\}\\).\n\n\n\n\n\n\nWarning\n\n\n\nPreservação vs. Equivalência na Skolemização\nA Skolemização é um processo que preserva a satisfatibilidade mas não preserva a equivalência lógica. Isso significa:\n\nSe a fórmula original é satisfatível, a fórmula skolemizada também será;\nSe a fórmula original é insatisfatível, a fórmula skolemizada também será;\nPorém, a fórmula skolemizada pode ser verdadeira em modelos onde a original é falsa.\n\nEsta distinção é fundamental em:\n\nProvas por refutação: nas quais buscamos inconsistência (adequado para Skolemização);\nVerificação de modelos: na qual precisamos preservar verdade (Skolemização inadequada);\nSistemas como Prolog: que utilizam formas clausais skolemizadas para inferência.\n\nPor isso a Skolemização é apropriada para métodos de prova automática como resolução, mas não para verificação direta de satisfação de fórmulas.\nA esforçada leitora deve entender a diferença entre preservar satisfatibilidade e preservar equivalência lógica:\n\nPreservação de Satisfatibilidade: Se existe um modelo \\(\\mathcal{M}\\) que satisfaz a fórmula original \\(\\phi\\), então existe um modelo \\(\\mathcal{M}'\\)(possivelmente expandido) que satisfaz \\(\\text{Skolem}(\\phi)\\). Reciprocamente, se \\(\\text{Skolem}(\\phi)\\) é satisfatível, então \\(\\phi\\) também é satisfatível.\nNão-Preservação de Equivalência: As fórmulas \\(\\phi\\) e \\(\\text{Skolem}(\\phi)\\) não são logicamente equivalentes porque:\n\nAs funções Skolem introduzem novos símbolos funcionais que não existiam no vocabulário original\nA interpretação destes novos símbolos é fixada de forma específica\nA fórmula skolemizada é mais específica que a original\n\n\nExemplo Ilustrativo: Considere a fórmula \\(\\exists x \\, P(x)\\). Após skolemização, obtemos \\(P(c)\\), onde \\(c\\) é uma constante Skolem.\n\nA fórmula original afirma: existe algum elemento com propriedade \\(P\\)\nA fórmula skolemizada afirma: o elemento específico \\(c\\) tem propriedade \\(P\\)\n\nEmbora ambas sejam satisfatíveis nos mesmos casos (quando há pelo menos um elemento com propriedade \\(P\\)), elas não são equivalentes. A segunda faz uma afirmação mais forte sobre um elemento específico.\nEsta distinção é fundamental para entender por que a Skolemização é adequada para provar teoremas (onde só precisamos preservar satisfatibilidade) mas não para transformações que exigem equivalência lógica exata.\n\n\n\nA conversão para Forma Normal Conjuntiva, forma clausal, é amplamente utilizada em métodos de prova automática como resolução. A conversão para Forma Normal Disjuntiva é menos comum, mas pode ser aplicada em alguns contextos de análise lógica. OBSERVAÇÃO: a Skolemização, eliminação dos quantificadores existenciais, pode alterar a interpretação da fórmula em alguns modelos, mas preserva a satisfatibilidade, sendo apropriada para provas automáticas.\n\n\n\n7.2.1.8 Exercícios de Conversão para Forma Normal Prenex\n1. Converta a seguinte fórmula para Forma Normal Prenex:\n\\[\nP(x) \\wedge \\forall y Q(y)\n\\]\n2. Converta a fórmula abaixo para Forma Normal Prenex:\n\\[\n\\forall x (P(x) \\rightarrow Q(x)) \\wedge \\exists y R(y)\n\\]\n3. Transforme a seguinte fórmula em Forma Normal Prenex:\n\\[\n\\neg \\forall x P(x) \\vee \\exists y Q(y)\n\\]\n4. Converta para Forma Normal Prenex:\n\\[\n\\forall x \\exists y P(x,y) \\rightarrow \\exists z \\forall w Q(z,w)\n\\]\n5. Transforme a fórmula em Forma Normal Prenex:\n\\[\n\\forall x (P(x) \\leftrightarrow \\exists y Q(x,y)) \\vee \\forall z R(z)\n\\]\n6. Converta para Forma Normal Prenex:\n\\[\n\\neg(\\forall x (P(x) \\rightarrow \\exists y Q(x,y))) \\wedge \\exists z (\\forall w R(z,w) \\vee S(z))\n\\]\n7. Transforme a seguinte fórmula em Forma Normal Prenex:\n$(x y P(x,y)) (z (Q(z) w R(z,w)) u S(u)) $\n\n\n\n7.2.2 Skolemização\nA Skolemização é como um pescador veterano que transforma indicações vagas de cardumes em coordenadas precisas de pesca. Quando encontramos uma afirmação do tipo ‘há peixes por aqui’, a Skolemização nos permite dizer ’muito bem, vamos marcar este ponto específico no GPS_.\nA criativa leitora pode se imaginar como um mestre de porto organizando o registro de embarcações: em vez de deixar referências vagas como ‘existe um navio cargueiro’, o mestre de porto cria um sistema de registro que permite localizar exatamente qual embarcação estamos procurando, baseados nas necessidades que definem nossos critérios de busca.\nFormalmente a Skolemização é um procedimento algorítmico que elimina quantificadores existenciais de fórmulas lógicas de primeira ordem, substituindo variáveis existencialmente quantificadas por termos funcionais específicos. Este processo preserva a satisfatibilidade da fórmula original, mas não preserva a equivalência lógica. Matematicamente dizemos:\nDada uma fórmula \\(\\phi\\) em Forma Normal Prenex:\n\\[\nQ_1 x_1 \\, Q_2 x_2 \\, \\ldots \\, Q_n x_n \\, M(x_1, x_2, \\ldots, x_n)\n\\]\nNa qual \\(Q_i \\in \\{\\forall, \\exists\\}\\) e \\(M\\) é a matriz livre de quantificadores, a Skolemização procede da seguinte forma:\nPara cada quantificador existencial \\(\\exists x_i\\) na sequência de quantificadores:\n\nSe não há quantificadores universais precedentes: substitua \\(x_i\\) por uma Constante Skolem \\(c_i\\). A Constante Skolem é como batizar um navio com nome fixo, Santa Maria sempre será Santa Maria, independente da rota ou tripulação.\nSe há quantificadores universais \\(\\forall y_1, \\forall y_2, \\ldots, \\forall y_k\\) precedentes: substitua \\(x_i\\) por uma Função Skolem \\(\\mathbf{f}_i(y_1, y_2, \\ldots, y_k)\\). A Função Skolem é como designar um papel dinâmico, o navio de apoio da embarcação principal, no qual a identidade específica muda dependendo de qual é a embarcação principal, mas a relação permanece consistente.\n\nPara entender a skolemização vamos usar a seguinte notação:\n\nConstantes Skolem: \\(c, c_1, c_2, \\ldots\\);\nFunções Skolem: \\(\\mathbf{f}(x), \\mathbf{f}(x,y), \\mathbf{h}(x,y,z), \\ldots\\);\nResultado da Skolemização de \\(\\phi\\): \\(Skolem(\\phi)\\).\n\nAntes de vermos os exemplos, é importante entender o que a Skolemização de fato realiza. Ela transforma uma fórmula, mas não de qualquer maneira. O processo garante alguns resultados importantes, enquanto altera outros. Pense nisso como as regras de navegação do nosso mestre de porto:\n\nA possibilidade de sucesso é mantida. Se a afirmação original há peixes por aqui (\\(\\phi\\)) era verdadeira (ou seja, era satisfatível), então a nova afirmação vamos pescar neste ponto específico \\(c\\) (\\(Skolem(\\phi)\\)) também pode ser verdadeira. A Skolemização não inventa uma solução que não existia, ela apenas dá um nome concreto a uma possibilidade que já era válida. Por isso, dizemos que ela preserva a satisfatibilidade.\n\nA nova fórmula é mais específica que a original. Este é um ponto-chave. A afirmação existe um navio cargueiro não tem o mesmo significado lógico que o navio em questão é o Pérola Negra. A segunda é uma versão muito mais comprometida da primeira, pois faz uma escolha existencial específica via constantes ou funções Skolem. Formalmente, a fórmula skolemizada \\(Skolem(\\phi)\\) implica logicamente a fórmula original \\(\\phi\\)(ou seja, \\(Skolem(\\phi) \\models \\phi\\)), mas o inverso não é verdadeiro, já que \\(\\phi\\) permite múltiplas escolhas existenciais, enquanto \\(Skolem(\\phi)\\) se compromete com uma específica. Por isso, a fórmula skolemizada não é logicamente equivalente à original.\n\nAs ambiguidades existe um… são eliminadas. Este é o objetivo central do processo. Ao final, não teremos mais quantificadores existenciais. Todas as referências vagas são substituídas por coordenadas no GPS (constantes) ou por funções de apoio (funções Skolem).\nAs dependências são mapeadas de forma clara. Quando a identidade de um elemento depende de outro (o navio de apoio que depende da embarcação principal \\(\\forall x\\)), a função Skolem \\(\\mathbf{f}(x)\\) garante que essa relação seja consistente e determinística. Para cada \\(x\\), a escolha de \\(y\\) será sempre a mesma.\n\nCom estas regras em mente, vamos ver como o processo funciona na prática, começando com um exemplo simples que envolve um quantificador universal e um existencial.\nConsidere a fórmula:\n\\[\\forall x \\exists y P(x,y)\\]\nAo aplicar a Skolemização, a variável existencial \\(y\\) é substituída por uma Função de Skolem \\(\\mathbf{f}(x)\\):\n\\[P(x,\\mathbf{f}(x))\\]\nPara uma fórmula com dois quantificadores universais e dois existenciais:\n\\[\\forall x \\forall z \\exists y \\exists w R(x,y,z,w)\\]\nA Skolemização resultará em:\n\\[\\forall x \\forall z R(x,\\mathbf{f}(x),z,\\mathbf{g}(x,z))\\]\n\\(\\mathbf{f}(x)\\) e $(x,z)$ são Funções Skolem introduzidas para substituir as variáveis existenciais \\(y\\) e $w $ respectivamente. A escolha entre Constante e Função Skolem é como decidir entre definir valores definitivos ou sua ação e aplicação:\nSe nossa expedição marítima já tem os tripulantes estabelecidos, as variáveis universais, então nosso novo tripulante existencial precisa se adaptar a eles através de uma função. Isso pode ser feito com as fórmulas lógicas seguindo os seguintes passos:\nPasso 1: Identificar os Quantificadores Existenciais: comece identificando os quantificadores existenciais na fórmula.\nPasso 2: Determinar se a Variável Existencial Depende de Variáveis Universais: para cada variável ligada a um quantificador existencial, determinamos se ela depende ou não de alguma variável universal. Isso significa verificar se existem quantificadores universais que precedem (ou dominam) a variável existencial na sequência de quantificadores da forma prenex.\n\nUm quantificador universal \\(\\forall x\\) precede ou domina um quantificador existencial \\(\\exists y\\) quando \\(\\forall x\\) aparece à esquerda de \\(\\exists y\\) na forma prenex;\nA variável existencial depende de todas as variáveis universais que a precedem;\nSe a variável existencial não é precedida por nenhum quantificador universal, usamos uma Constante de Skolem;\nSe a variável existencial é precedida por variáveis universais \\(x_1, x_2, \\ldots, x_k\\), usamos uma Função de Skolem \\(\\mathbf{f}(x_1, x_2, \\ldots, x_k)\\) que recebe como parâmetros exatamente essas variáveis.\n\nExemplo de precedência: Na fórmula \\(\\forall x \\exists y \\forall z \\exists w \\, P(x,y,z,w)\\):\n\n\\(\\exists y\\) é precedido apenas por \\(\\forall x\\), logo usamos \\(\\mathbf{f}(x)\\);\n\\(\\exists w\\) é precedido por \\(\\forall x\\) e \\(\\forall z\\), logo usamos \\(\\mathbf{g}(x,z)\\).\n\nPasso 3: Substituir as Variáveis Existenciais: agora, substituímos todas as variáveis existenciais na fórmula original de acordo com as decisões tomadas no Passo 2. Se usarmos Constantes de Skolem, substituímos as variáveis existenciais diretamente pelas constantes. Se usarmos Funções de Skolem, substituímos as variáveis existenciais pelas funções de Skolem aplicadas às variáveis universais apropriadas.\n\n7.2.2.1 Exemplo 1: Quantificador Existencial Simples\nFórmula Original:\n\\[\n\\exists x \\, P(x)\n\\]\nAplicação da Skolemização:\n\nO quantificador existencial \\(\\exists x\\) não possui quantificadores universais precedentes;\nSubstituímos \\(x\\) por uma Constante Skolem \\(c\\).\n\nResultado:\n\\[\nP(c)\n\\]\n\n\n7.2.2.2 Exemplo 2: Universal Seguido de Existencial\nFórmula Original:\n\\[\n\\forall x \\exists y \\, R(x,y)\n\\]\nAplicação da Skolemização:\n\nO quantificador existencial \\(\\exists y\\) é precedido pelo quantificador universal \\(\\forall x\\)\nSubstituímos \\(y\\) por uma Função Skolem \\(\\mathbf{f}(x)\\) que depende de \\(x\\)\n\nResultado:\n\\[\n\\forall x \\, R(x, \\mathbf{f}(x))\n\\]\nForma com Quantificadores Implícitos:\n\\[\nR(x, \\mathbf{f}(x))\n\\]\n\n\n7.2.2.3 Exemplo 3: Múltiplos Quantificadores com Dependências\nFórmula Original:\n\\[\n\\exists u \\forall x \\exists y \\forall z \\exists w \\, Q(u,x,y,z,w)\n\\]\nAplicação da Skolemização:\n\n\\(\\exists u\\): Não há universais precedentes Constante Skolem \\(c_1\\)\n\\(\\exists y\\): Precedido por \\(\\forall x\\)Função Skolem \\(\\mathbf{f}(x)\\)\n\n\\(\\exists w\\): Precedido por \\(\\forall x\\) e \\(\\forall z\\)Função Skolem \\(\\mathbf{g}(x,z)\\)\n\nResultado:\n\\[\n\\forall x \\forall z \\, Q(c_1, x, \\mathbf{f}(x), z, \\mathbf{g}(x,z))\n\\]\nForma com Quantificadores Implícitos:\n\\[\nQ(c_1, x, \\mathbf{f}(x), z, \\mathbf{g}(x,z))\n\\]\n\n\n7.2.2.4 Exemplo 4: Fórmula Complexa com Estrutura Mista (Versão Corrigida)\nFórmula Original:\n\\[\n\\forall x (\\exists y , P(x,y) \\rightarrow \\forall z \\exists w , R(x,z,w))\n\\]\nConversão para Forma Normal Prenex:\nPrecisamos mover todos os quantificadores para o início da fórmula, seguindo as regras de equivalência lógica.\nPasso 1: Renomear variáveis ligadas para evitar conflitos. Como não há variáveis com mesmo nome em escopos diferentes, podemos prosseguir.\nPasso 2: Eliminar a implicação usando \\(A \\rightarrow B \\equiv \\neg A \\vee B\\):\n\\[\n\\forall x (\\neg \\exists y , P(x,y) \\vee \\forall z \\exists w , R(x,z,w))\n\\]\nPasso 3: Aplicar a negação ao quantificador existencial usando \\(\\neg \\exists y \\, \\phi \\equiv \\forall y \\neg \\phi\\):\n\\[\n\\forall x (\\forall y \\neg P(x,y) \\vee \\forall z \\exists w , R(x,z,w))\n\\]\nPasso 4: Mover os quantificadores internos para fora. Como as variáveis dos disjuntos são distintas, podemos mover os quantificadores para o início da fórmula.\n\\[\n\\forall x \\forall y \\forall z \\exists w (\\neg P(x,y) \\vee R(x,z,w))\n\\]\nEsta é a Forma Normal Prenex correta da fórmula original.\nAplicação da Skolemização:\nAgora, identificamos a única variável existencial e suas dependências universais:\n\n\\(\\exists w\\): É precedido pelos quantificadores universais \\(\\forall x\\), \\(\\forall y\\) e \\(\\forall z\\). Portanto, substituímos \\(w\\) por uma Função Skolem \\(\\mathbf{g}(x,y,z)\\) que depende dessas três variáveis.\n\nResultado após Skolemização:\n\\[\n\\forall x \\forall y \\forall z (\\neg P(x,y) \\vee R(x, z, \\mathbf{g}(x,y,z)))\n\\]\nApós tornar os quantificadores universais implícitos:\n\\[\n\\neg P(x,y) \\vee R(x, z, \\mathbf{g}(x,y,z))\n\\]\nObservação: Esta última fórmula representa uma cláusula pronta para uso em métodos de inferência como a resolução. A função Skolem \\(\\mathbf{g}(x,y,z)\\) captura corretamente a dependência da escolha de \\(w\\) em relação a todas as variáveis universais que a precediam no escopo: \\(x\\), \\(y\\) e \\(z\\).\n\n\n7.2.2.5 Exemplo 5: Conversão em Formas Normais, Conjuntiva e Disjuntiva\nConsidere a sentença: Todos os alunos estudam ou alguns professores ensinam matemática, que em lógica de primeira ordem pode ser representada por:\n\\[\n\\forall x(\\text{Aluno}(x) \\rightarrow \\text{Estuda}(x)) \\vee \\exists y(\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nConversão para Forma Normal Conjuntiva:\n\nEliminar implicações: converter \\(A \\rightarrow B\\) em \\(\\neg A \\vee B\\).\n\\[\n\\forall x(\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee \\exists y(\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nPadronizar variáveis: as variáveis \\(x\\) e \\(y\\) já são distintas e não há conflito de escopo. Nenhuma alteração é necessária.\nConverter para Forma Normal Prenex: mover todos os quantificadores para a frente da fórmula.\n\\[\n\\forall x \\exists y ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y)))\n\\]\nSkolemização: eliminar o quantificador existencial \\(\\exists y\\). Como \\(y\\) está no escopo de \\(\\forall x\\), ele é substituído por uma função Skolem \\(\\mathbf{f}(x)\\).\n\\[\n\\forall x ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(\\mathbf{f}(x)) \\wedge \\text{EnsinaMatemática}(\\mathbf{f}(x))))\n\\]\nAplicar distributividade: distribuir \\(\\vee\\) sobre \\(\\wedge\\) usando a regra \\((P \\vee (Q \\wedge R)) \\equiv ((P \\vee Q) \\wedge (P \\vee R))\\).\n\\[\n\\forall x ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{Professor}(\\mathbf{f}(x))) \\wedge (\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{EnsinaMatemática}(\\mathbf{f}(x))))\n\\]\nRemover quantificadores universais: na forma clausal, os quantificadores universais são implícitos.\n\\[\n(\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{Professor}(\\mathbf{f}(x))) \\wedge (\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee \\text{EnsinaMatemática}(\\mathbf{f}(x)))\n\\]\n\nResultado em Forma Normal Conjuntiva: a fórmula está na Forma Normal Conjuntiva, representada como uma conjunção de duas cláusulas.\nConversão para Forma Normal Disjuntiva: a conversão para Forma Normal Disjuntiva segue um caminho diferente e não utiliza Skolemização. O ponto de partida correto é a Forma Normal Prenex (passo 3 da conversão anterior).\n\nPonto de Partida (Forma Normal Prenex):\n\\[\n\\forall x \\exists y ((\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y)))\n\\]\nAnalisar a Matriz da Fórmula: A matriz é a parte da fórmula sem os quantificadores. Vamos analisá-la:\n\\[\n(\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x)) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nUma fórmula está em Forma Normal Disjuntiva se for uma disjunção de conjunções de literais. Simplificando a expressão acima (removendo parênteses por associatividade), obtemos:\n\\[\n\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\n\\]\nEsta estrutura já corresponde a uma Forma Normal Disjuntiva. Ela é uma disjunção (termos ligados por \\(\\vee\\)) de três termos: \\(\\neg \\text{Aluno}(x)\\), \\(\\text{Estuda}(x)\\) e a conjunção \\((\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y))\\). Nenhum passo de distribuição é necessário.\n\nResultado em Forma Normal Disjuntiva: a Forma Normal Disjuntiva da fórmula, mantendo os quantificadores, é:\n\\[\n\\forall x \\exists y (\\neg \\text{Aluno}(x) \\vee \\text{Estuda}(x) \\vee (\\text{Professor}(y) \\wedge \\text{EnsinaMatemática}(y)))\n\\]\nObservação: a estrutura da fórmula original, uma grande disjunção (\\(P \\vee Q\\)), faz com que ela seja naturalmente próxima da Forma Normal Disjuntiva, exigindo poucos ou nenhum passo de conversão. Em contraste, para chegar à Forma Normal Conjuntiva, foi necessário aplicar a lei da distributividade, resultando em uma expressão mais complexa.\n\nNota: a forma resultante após Skolemização e conversão para FNC, quando todos os quantificadores universais são removidos (ficam implícitos), resulta em um conjunto de cláusulas - exatamente o formato necessário para o método de resolução e para identificar cláusulas de Horn, como veremos no próximo capítulo.\n\n\n\n\n7.2.3 Expansão do Vocabulário e Conexão com Programação Lógica\nAo introduzir constantes e funções Skolem, a Skolemização adiciona novos identificadores ao alfabeto que definimos para a Lógica de Primeira Ordem. Pense nisso como registrar novos navios ou rotas no sistema do mestre de porto: uma constante Skolem \\(c\\) é como um navio recém-batizado, e uma função Skolem \\(\\mathbf{f}(x)\\) é como uma regra para nomear navios de apoio com base na embarcação principal \\(x\\). Esses novos símbolos são essenciais quando transformamos fórmulas em cláusulas, que são as unidades básicas usadas em sistemas de programação lógica, como o Prolog.\nEssa expansão do vocabulário também nos conecta ao teorema de Herbrand, uma ideia fundamental em programação lógica. O teorema garante que, após a Skolemização, podemos verificar se uma fórmula é satisfatível testando combinações finitas de termos. Isso é especialmente importante para cláusulas de Horn, um tipo especial de cláusula com no máximo um literal positivo, que forma a base de programas em Prolog. Assim, a Skolemização não apenas elimina ambiguidades existenciais, mas também prepara o terreno para sistemas automatizados que navegam por essas cláusulas em busca de respostas lógicas.\n\n\n7.2.4 Exercícios de Skolemização\n1. Aplique a Skolemização na seguinte fórmula simples:\n\\[\\exists x \\, P(x)\\]\n2. Converta a fórmula abaixo aplicando a Skolemização:\n\\[\\forall x \\exists y \\, Q(x,y)\\]\n3. Aplique a Skolemização na fórmula com múltiplos quantificadores:\n\\[\\exists a \\forall x \\exists y \\forall z \\exists w \\, R(a,x,y,z,w)\\]\n4. Dada a fórmula com implicação, primeiro converta para Forma Normal Prenex e depois aplique a Skolemização:\n\\[\\forall x (P(x) \\rightarrow \\exists y \\, Q(x,y)) \\wedge \\exists z \\, R(z)\\]\n5. Converta a seguinte fórmula complexa para Forma Normal Prenex e depois aplique a Skolemização:\n\\[\\neg(\\exists x \\forall y \\, P(x,y)) \\vee (\\forall z \\exists w \\, S(z,w) \\wedge \\exists u \\, T(u))\\]\n6. Para a fórmula que representa Todo estudante tem um professor que ensina uma disciplina que o estudante estuda:\n\\[\\forall x (\\text{Estudante}(x) \\rightarrow \\exists y (\\text{Professor}(y) \\wedge \\exists z (\\text{Disciplina}(z) \\wedge \\text{Ensina}(y,z) \\wedge \\text{Estuda}(x,z))))\\]\nConverta para Forma Normal Prenex e aplique a Skolemização.\n7. Dada a fórmula que combina quantificadores universais e existenciais em uma estrutura condicional complexa:\n\\[(\\forall x \\exists y \\, P(x,y)) \\rightarrow (\\exists u \\forall v \\exists w \\, Q(u,v,w) \\wedge \\forall s \\, R(s))\\]\nRealize a conversão completa: elimine implicações, converta para Forma Normal Prenex e aplique a Skolemização.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais: Estruturas de Solução</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#formas-normais-prenex",
    "href": "05-formas-normais-e-skolemizacao.html#formas-normais-prenex",
    "title": "7  Formas Normais: Estruturas de Solução",
    "section": "7.3 Formas Normais Prenex",
    "text": "7.3 Formas Normais Prenex\nAgora que já conhecemos as Formas Normais Prenex e a Skolemização, podemos explorar as formas normais considerando a existência de quantificadores. Neste caso, podemos definir um algoritmo para converter fórmulas lógicas em suas respectivas Formas Normais Prenex. Começando com a própria Forma Normal Prenex.\n\n7.3.1 Algoritmo para Conversão na Forma Normal Prenex\nA Forma Normal Prenex (FNP) é uma representação de fórmulas lógicas onde todos os quantificadores estão no início da fórmula, seguidos por uma parte livre de quantificadores. Essa estrutura é útil para a aplicação de técnicas de resolução em lógica de primeira ordem.\nEntrada: Fórmula \\(A\\). Saída: Fórmula \\(B\\) em FNP tal que \\(A \\equiv B\\).\n\nrepita\n\npara todas as subfórmulas \\(X, Y, Z \\in A\\) faça\n\nse \\((X \\rightarrow Y)\\) redefina como \\((\\neg X \\vee Y)\\)\nse \\((X \\leftrightarrow Y)\\) redefina como \\((X \\wedge Y) \\vee (\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\vee Y)\\) redefina como \\((\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\wedge Y)\\) redefina como \\((\\neg X \\vee \\neg Y)\\)\nse \\(\\neg\\neg X\\) redefina como \\(X\\)\nse \\(\\neg\\forall x P(x)\\) redefina como \\(\\exists x \\neg P(x)\\)\nse \\(\\neg\\exists x P(x)\\) redefina como \\(\\forall x \\neg P(x)\\)\nse \\((\\forall x P(x)) \\vee Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (P(x) \\vee Y)\\)\nse \\((\\exists x P(x)) \\vee Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (P(x) \\vee Y)\\)\nse \\(Y \\vee (\\forall x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (Y \\vee P(x))\\)\nse \\(Y \\vee (\\exists x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (Y \\vee P(x))\\)\nse \\((\\forall x P(x)) \\wedge Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (P(x) \\wedge Y)\\)\nse \\((\\exists x P(x)) \\wedge Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (P(x) \\wedge Y)\\)\nse \\(Y \\wedge (\\forall x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (Y \\wedge P(x))\\)\nse \\(Y \\wedge (\\exists x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (Y \\wedge P(x))\\)\nse \\((\\forall x P(x)) \\wedge (\\forall y Q(y))\\) redefina como \\(\\forall x \\forall y (P(x) \\wedge Q(y))\\)\nse \\((\\exists x P(x)) \\vee (\\exists y Q(y))\\) redefina como \\(\\exists x \\exists y (P(x) \\vee Q(y))\\)\nse \\((\\forall x P(x)) \\vee (\\forall y Q(y))\\) redefina como \\(\\forall x \\forall y (P(x) \\vee Q(y))\\)\nse \\((\\exists x P(x)) \\wedge (\\exists y Q(y))\\) redefina como \\(\\exists x \\exists y (P(x) \\wedge Q(y))\\)\nse \\((\\forall x P(x)) \\vee (\\exists y Q(y))\\) redefina como \\(\\forall x \\exists y (P(x) \\vee Q(y))\\)\nse \\((\\exists x P(x)) \\wedge (\\forall y Q(y))\\) redefina como \\(\\exists x \\forall y (P(x) \\wedge Q(y))\\)\n\nfim\n\naté não ocorrerem substituições\nRenomeie variáveis ligadas para evitar conflitos de escopo\nMova todos os quantificadores restantes para o início da fórmula (prenexação final)\n\n\n7.3.1.1 Exemplo 1\nFórmula inicial: \\(\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\neg(\\exists z R(z))\\)\nSolução:\nPasso 1: Eliminar Implicações\nPrimeiro, removemos a implicação \\(P(x) \\rightarrow \\exists y Q(x,y)\\), aplicando a regra \\(A \\rightarrow B \\equiv \\neg A \\vee B\\):\n\\[\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge \\neg(\\exists z R(z))\\]\nPasso 2: Mover Negações para Dentro (FNN)\nEm seguida, aplicamos a regra de negação do quantificador existencial, \\(\\neg\\exists z \\equiv \\forall z \\neg\\), na segunda parte da fórmula:\n\\[\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge \\forall z \\neg R(z)\\]\nPasso 3: Mover Quantificadores para o Início (Prenexação)\nAgora, movemos todos os quantificadores para o início da fórmula. É fundamental observar a ordem correta:\n\nO quantificador \\(\\exists y\\) está no escopo de \\(\\forall x\\). Isso significa que a escolha de \\(y\\) pode depender de \\(x\\). Para preservar essa dependência, \\(\\forall x\\) deve vir antes de \\(\\exists y\\) na forma prenex.\nO quantificador \\(\\forall z\\) vem de uma conjunção independente e pode ser movido para o início junto com os outros.\n\nSeguindo essa lógica, a ordem correta dos quantificadores é \\(\\forall x \\exists y \\forall z\\).\n\\[\\forall x \\exists y \\forall z ((\\neg P(x) \\vee Q(x,y)) \\wedge \\neg R(z))\\]\nResultado: A fórmula final em FNP, com a ordem dos quantificadores justificada para manter o sentido lógico original, é:\n\\[\\forall x \\exists y \\forall z ((\\neg P(x) \\vee Q(x,y)) \\wedge \\neg R(z))\\]\n\n\n7.3.1.2 Exemplo 2\nFórmula inicial: \\(\\neg(\\forall x P(x) \\leftrightarrow \\exists y Q(y))\\)\nSolução:\n\nEliminar equivalências (passo 1.1.2): Primeiro, substituímos o operador de equivalência \\(A \\leftrightarrow B\\) por \\((A \\wedge B) \\vee (\\neg A \\wedge \\neg B)\\).\n\\[\\neg((\\forall x P(x) \\wedge \\exists y Q(y)) \\vee (\\neg \\forall x P(x) \\wedge \\neg \\exists y Q(y)))\\]\nAplicar a lei de De Morgan para a negação de disjunção (passo 1.1.3): Movemos a negação principal para dentro, trocando \\(\\vee\\) por \\(\\wedge\\).\n\\[\\neg(\\forall x P(x) \\wedge \\exists y Q(y)) \\wedge \\neg(\\neg \\forall x P(x) \\wedge \\neg \\exists y Q(y))\\]\nAplicar a lei de De Morgan para a negação de conjunção (passo 1.1.4): Continuamos a mover as negações para dentro das duas cláusulas.\n\\[(\\neg \\forall x P(x) \\vee \\neg \\exists y Q(y)) \\wedge (\\neg\\neg \\forall x P(x) \\vee \\neg\\neg \\exists y Q(y))\\]\nEliminar duplas negações (passo 1.1.5): Removemos as duplas negações na segunda parte da fórmula.\n\\[(\\neg \\forall x P(x) \\vee \\neg \\exists y Q(y)) \\wedge (\\forall x P(x) \\vee \\exists y Q(y))\\]\nAplicar regras de negação de quantificadores (passos 1.1.6 e 1.1.7): Esta é a conversão para a Forma Normal Negativa (FNN), o passo onde o erro original ocorreu.\n\\[(\\exists x \\neg P(x) \\vee \\forall y \\neg Q(y)) \\wedge (\\forall x P(x) \\vee \\exists y Q(y))\\]\nRenomear variáveis ligadas (passo 3): Para evitar conflitos ao mover os quantificadores, renomeamos as variáveis \\(x\\) e \\(y\\) na segunda cláusula para \\(z\\) e \\(w\\).\n\\[(\\exists x \\neg P(x) \\vee \\forall y \\neg Q(y)) \\wedge (\\forall z P(z) \\vee \\exists w Q(w))\\]\nMover quantificadores para a esquerda (prenexação, passo 4): Movemos todos os quantificadores para o início da fórmula para obter a Forma Normal Prenex.\n\\[\\exists x \\forall y \\forall z \\exists w ((\\neg P(x) \\vee \\neg Q(y)) \\wedge (P(z) \\vee Q(w)))\\]\n\nResultado: \\(\\exists x \\forall y \\forall z \\exists w ((\\neg P(x) \\vee \\neg Q(y)) \\wedge (P(z) \\vee Q(w)))\\)\n\n\n7.3.1.3 Exemplo 3\nFórmula inicial: \\((\\exists x P(x) \\vee \\forall y Q(y)) \\rightarrow \\forall z R(z)\\)\nSolução:\n\nEliminar implicações (passo 1.1.1): \\[\\neg(\\exists x P(x) \\vee \\forall y Q(y)) \\vee \\forall z R(z)\\]\nAplicar as leis de De Morgan para mover negações para dentro (passo 1.1.2, 1.1.7 e 1.1.8): \\[(\\forall x \\neg P(x) \\wedge \\exists y \\neg Q(y)) \\vee \\forall z R(z)\\]\nRenomear variáveis: (não necessário neste caso).\nMover quantificadores para a esquerda (prenexação, passo 4): \\[\\forall x \\exists y \\forall z ((\\neg P(x) \\wedge \\neg Q(y)) \\vee R(z))\\]\n\nResultado:\n\\[\\forall x \\exists y \\forall z ((\\neg P(x) \\wedge \\neg Q(y)) \\vee R(z))\\]\n\n\n7.3.1.4 Exemplo 4\nFórmula inicial: \\(\\neg(\\forall x \\exists y P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\)\nSolução:\n\nAplicar as leis de De Morgan para mover negações para dentro (passo 1.1.7 e 1.1.8):\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\]\nRenomear variáveis (passo 3):\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall v R(v))\\]\nMover quantificadores para a esquerda (prenexação, passo 4): \\[\\exists x \\forall y \\exists z \\forall w \\forall v ((\\neg P(x,y)) \\vee (Q(z,w) \\wedge R(v)))\\]\n\nResultado:\n\\[\\exists x \\forall y \\exists z \\forall w \\forall v ((\\neg P(x,y)) \\vee (Q(z,w) \\wedge R(v)))\\]\n\n\n7.3.1.5 Exemplo 5\nFórmula inicial: \\(\\forall x (\\exists y P(x,y) \\rightarrow \\forall z Q(x,z)) \\wedge \\neg(\\exists w R(w))\\)\nSolução:\n\nEliminar implicações (passo 1.1.1):\n\\[\\forall x (\\neg \\exists y P(x,y) \\vee \\forall z Q(x,z)) \\wedge \\neg(\\exists w R(w))\\]\nAplicar as leis de De Morgan para mover negações para dentro (passo 1.1.7 e 1.1.8):\n\\[\\forall x (\\forall y \\neg P(x,y) \\vee \\forall z Q(x,z)) \\wedge \\forall w \\neg R(w)\\]\nRenomear variáveis (passo 3):\n\\[\\forall x (\\forall y \\neg P(x,y) \\vee \\forall z Q(x,z)) \\wedge \\forall v \\neg R(v)\\]\nMover quantificadores para a esquerda (prenexação, passo 4):\n\\[\\forall x \\forall y \\forall z \\forall v ((\\neg P(x,y) \\vee Q(x,z)) \\wedge \\neg R(v))\\]\n\nResultado:\n\\[\\forall x \\forall y \\forall z \\forall v ((\\neg P(x,y) \\vee Q(x,z)) \\wedge \\neg R(v))\\]\n\n\n\n7.3.2 Forma Normal Negativa Prenex\nA Forma Normal Negativa Prenex (FNNP) é uma variação da Forma Normal Prenex que se concentra em manter as negações no nível mais externo possível, enquanto ainda obedece à estrutura prenex. Isso é útil em contextos onde a preservação da negação é crítica para a interpretação da fórmula.\n\n7.3.2.1 Algoritmo para Forma Normal Negativa (FNN)\nEntrada: Fórmula \\(A\\). Saída: Fórmula \\(B\\) em FNN tal que \\(A \\equiv B\\).\n\nrepita\npara todas as subfórmulas \\(X, Y \\in A\\) faça\n\nse \\((X \\rightarrow Y)\\) redefina como \\((\\neg X \\vee Y)\\)\nse \\((X \\leftrightarrow Y)\\) redefina como \\((X \\wedge Y) \\vee (\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\vee Y)\\) redefina como \\((\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\wedge Y)\\) redefina como \\((\\neg X \\vee \\neg Y)\\)\nse \\(\\neg\\neg X\\) redefina como \\(X\\)\nse \\(\\neg\\forall x P(x)\\) redefina como \\(\\exists x \\neg P(x)\\)\nse \\(\\neg\\exists x P(x)\\) redefina como \\(\\forall x \\neg P(x)\\)\n\nfim\naté não ocorrerem substituições\n\n\n\n7.3.2.2 Exemplo 1\nFórmula inicial: \\(\\neg(P \\rightarrow (Q \\vee R))\\)\nSolução: 1. Eliminar implicações (passo 1.1.1): \\(\\neg(\\neg P \\vee (Q \\vee R))\\); 2. Aplicar lei de De Morgan para negação de disjunção (passo 1.1.3): \\(P \\wedge \\neg(Q \\vee R)\\); 3. Aplicar novamente lei de De Morgan para negação de disjunção (passo 1.1.3): \\(P \\wedge (\\neg Q \\wedge \\neg R)\\).\nResultado final: \\(P \\wedge (\\neg Q \\wedge \\neg R)\\)\n\n\n7.3.2.3 Exemplo 2\nFórmula inicial: \\(\\neg(\\forall x P(x) \\leftrightarrow \\exists y Q(y))\\)\nSolução: 1. Eliminar equivalências (passo 1.1.2):\n\\[\\neg((\\forall x P(x) \\wedge \\exists y Q(y)) \\vee (\\neg \\forall x P(x) \\wedge \\neg \\exists y Q(y)))\\]\n\nAplicar lei de De Morgan para negação de disjunção (passo 1.1.3):\n\n\\[(\\neg(\\forall x P(x) \\wedge \\exists y Q(y))) \\wedge (\\neg(\\neg \\forall x P(x) \\wedge \\neg \\exists y Q(y)))\\]\n\nAplicar lei de De Morgan para negação de conjunção (passo 1.1.4):\n\n\\[(\\neg \\forall x P(x) \\vee \\neg \\exists y Q(y)) \\wedge (\\forall x P(x) \\vee \\exists y Q(y))\\]\n\nAplicar lei de De Morgan para negação de quantificadores (passos 1.1.6 e 1.1.7):\n\n\\[(\\exists x \\neg P(x) \\vee \\forall y \\neg Q(y)) \\wedge (\\forall x P(x) \\vee \\exists y Q(y))\\]\nResultado:\n\\[(\\exists x \\neg P(x) \\vee \\forall y \\neg Q(y)) \\wedge (\\forall x P(x) \\vee \\exists y Q(y))\\]\n\n\n7.3.2.4 Exemplo 2\nFórmula inicial: \\(\\neg(\\forall x (P(x) \\rightarrow \\exists y Q(x,y)))\\)\nSolução:\n\nEliminar implicações (passo 1.1.1):\n\n\\[\\neg(\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)))\\]\n\nAplicar lei de De Morgan para negação de quantificador universal (passo 1.1.6):\n\n\\[\\exists x \\neg(\\neg P(x) \\vee \\exists y Q(x,y))\\]\n\nAplicar lei de De Morgan para negação de disjunção (passo 1.1.3):\n\n\\[\\exists x (P(x) \\wedge \\neg(\\exists y Q(x,y)))\\]\n\nAplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.7):\n\n\\[\\exists x (P(x) \\wedge \\forall y \\neg Q(x,y))\\]\nResultado:\n\\[\\exists x (P(x) \\wedge \\forall y \\neg Q(x,y))\\]\n\n\n7.3.2.5 Exemplo 4\nFórmula inicial: \\(\\neg(\\forall x (P(x) \\vee Q(x)) \\rightarrow \\exists y R(y))\\)\nSolução: 1. Eliminar implicações (passo 1.1.1):\n\\[\\neg(\\neg(\\forall x (P(x) \\vee Q(x))) \\vee \\exists y R(y))\\]\n\nAplicar lei de De Morgan para negação de disjunção (passo 1.1.3):\n\n\\[\\neg\\neg(\\forall x (P(x) \\vee Q(x))) \\wedge \\neg(\\exists y R(y))\\]\n\nEliminar dupla negação (passo 1.1.5):\n\n\\[(\\forall x (P(x) \\vee Q(x))) \\wedge \\neg(\\exists y R(y))\\]\n\nAplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.7):\n\n\\[(\\forall x (P(x) \\vee Q(x))) \\wedge (\\forall y \\neg R(y))\\]\nResultado:\n\\[(\\forall x (P(x) \\vee Q(x))) \\wedge (\\forall y \\neg R(y))\\]\n\n\n\n7.3.3 Algoritmo para Forma Normal Disjuntiva Prenex (FND Prenex)\nEntrada: Fórmula \\(A\\). Saída: Fórmula \\(B\\) em FND Prenex tal que \\(A \\equiv B\\).\n\nrepita\n\npara todas as subfórmulas \\(X, Y, Z \\in A\\) faça\n\nse \\((X \\rightarrow Y)\\) redefina como \\((\\neg X \\vee Y)\\)\nse \\((X \\leftrightarrow Y)\\) redefina como \\((X \\wedge Y) \\vee (\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\vee Y)\\) redefina como \\((\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\wedge Y)\\) redefina como \\((\\neg X \\vee \\neg Y)\\)\nse \\(\\neg\\neg X\\) redefina como \\(X\\)\nse \\(X \\wedge (Y \\vee Z)\\) redefina como \\((X \\wedge Y) \\vee (X \\wedge Z)\\)\nse \\((X \\vee Y) \\wedge Z\\) redefina como \\((X \\wedge Z) \\vee (Y \\wedge Z)\\)\nse \\(\\neg\\forall x P(x)\\) redefina como \\(\\exists x \\neg P(x)\\)\nse \\(\\neg\\exists x P(x)\\) redefina como \\(\\forall x \\neg P(x)\\)\nse \\(\\forall x P(x)\\) onde \\(x\\) não ocorre livre em \\(P\\), redefina como \\(P\\)\nse \\(\\exists x P(x)\\) onde \\(x\\) não ocorre livre em \\(P\\), redefina como \\(P\\)\nse \\((\\forall x P(x)) \\vee Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (P(x) \\vee Y)\\)\nse \\((\\exists x P(x)) \\vee Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (P(x) \\vee Y)\\)\nse \\(Y \\vee (\\forall x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (Y \\vee P(x))\\)\nse \\(Y \\vee (\\exists x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (Y \\vee P(x))\\)\nse \\((\\forall x P(x)) \\wedge Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (P(x) \\wedge Y)\\)\nse \\((\\exists x P(x)) \\wedge Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (P(x) \\wedge Y)\\)\nse \\(Y \\wedge (\\forall x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (Y \\wedge P(x))\\)\nse \\(Y \\wedge (\\exists x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (Y \\wedge P(x))\\)\nse \\((\\forall x P(x)) \\wedge (\\forall y Q(y))\\) redefina como \\(\\forall x \\forall y (P(x) \\wedge Q(y))\\)\nse \\((\\exists x P(x)) \\vee (\\exists y Q(y))\\) redefina como \\(\\exists x \\exists y (P(x) \\vee Q(y))\\)\nse \\((\\forall x P(x)) \\vee (\\forall y Q(y))\\) redefina como \\(\\forall x \\forall y (P(x) \\vee Q(y))\\)\nse \\((\\exists x P(x)) \\wedge (\\exists y Q(y))\\) redefina como \\(\\exists x \\exists y (P(x) \\wedge Q(y))\\)\nse \\((\\forall x P(x)) \\vee (\\exists y Q(y))\\) redefina como \\(\\forall x \\exists y (P(x) \\vee Q(y))\\)\nse \\((\\exists x P(x)) \\wedge (\\forall y Q(y))\\) redefina como \\(\\exists x \\forall y (P(x) \\wedge Q(y))\\)\n\nfim\n\naté não ocorrerem substituições\nRenomeie variáveis ligadas para evitar conflitos\nMova todos os quantificadores para o início da fórmula (prenexação)\n\n\n7.3.3.1 Exemplo 1\nFórmula inicial: \\(\\forall x \\exists y (P(x) \\rightarrow Q(y)) \\wedge \\neg(\\forall z R(z))\\)\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(P(x) \\rightarrow Q(y)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[\\forall x \\exists y (\\neg P(x) \\vee Q(y)) \\wedge \\neg(\\forall z R(z))\\]\nPasso 2: Mover Negações para Dentro (FNN): aplicamos a regra de negação do quantificador universal na segunda parte da fórmula:\n\\[\\forall x \\exists y (\\neg P(x) \\vee Q(y)) \\wedge \\exists z \\neg R(z)\\]\nPasso 3: Mover Quantificadores para o Início (Prenexação): renomeamos a variável \\(z\\) para \\(w\\) para evitar conflitos e movemos todos os quantificadores para o início:\n\\[\\forall x \\exists y \\exists w ((\\neg P(x) \\vee Q(y)) \\wedge \\neg R(w))\\]\nPasso 4: Distribuir \\(\\land\\) sobre \\(\\lor\\): a matriz \\((\\neg P(x) \\vee Q(y)) \\wedge \\neg R(w)\\) ainda não está em FND. Para convertê-la, aplicamos a lei distributiva da conjunção sobre a disjunção. A expressão tem a forma \\((X \\vee Y) \\land Z\\), que é equivalente a \\((X \\land Z) \\lor (Y \\land Z)\\):\n\\[\\forall x \\exists y \\exists w ((\\neg P(x) \\wedge \\neg R(w)) \\lor (Q(y) \\wedge \\neg R(w)))\\]\nResultado: a fórmula final está em FND Prenex, pois sua matriz é uma disjunção de duas cláusulas conjuntivas:\n\\[\\forall x \\exists y \\exists w ((\\neg P(x) \\wedge \\neg R(w)) \\lor (Q(y) \\wedge \\neg R(w)))\\]\n\n\n7.3.3.2 Exemplo 2\nFórmula inicial: \\(\\neg(\\forall x P(x) \\rightarrow \\exists y Q(y))\\)\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(\\forall x P(x) \\rightarrow \\exists y Q(y)\\):\n\\[\\neg(\\neg(\\forall x P(x)) \\vee \\exists y Q(y))\\]\nPasso 2: Mover Negações para Dentro (FNN): aplicamos a lei de De Morgan, eliminamos a dupla negação e aplicamos a regra de negação do quantificador existencial:\n\\[\\neg\\neg(\\forall x P(x)) \\wedge \\neg(\\exists y Q(y))\\]\n\\[(\\forall x P(x)) \\wedge (\\forall y \\neg Q(y))\\]\nPasso 3: Mover Quantificadores para o Início (Prenexação): renomeamos a variável \\(y\\) para \\(z\\) e movemos os quantificadores para o início da fórmula:\n\\[\\forall x \\forall z (P(x) \\wedge \\neg Q(z))\\]\nPasso 4: Analisar a Matriz para FND: a matriz da fórmula é \\(P(x) \\wedge \\neg Q(z)\\). Uma fórmula em FND é uma disjunção de uma ou mais conjunções de literais. Uma única conjunção de literais, como neste caso, é considerada uma forma válida de FND. Portanto, a matriz já está na forma desejada e nenhuma distribuição é necessária.\nResultado: a fórmula final em FND é:\n\\[\\forall x \\forall z (P(x) \\wedge \\neg Q(z))\\]\n\n\n7.3.3.3 Exemplo 3\nFórmula inicial: \\((\\exists x P(x) \\vee \\forall y Q(y)) \\rightarrow \\forall z R(z)\\)\nSolução:\nPasso 1: Eliminar Implicações: primeiro, removemos a implicação principal, aplicando a regra \\(A \\rightarrow B \\equiv \\neg A \\vee B\\):\n\\[\\neg(\\exists x P(x) \\vee \\forall y Q(y)) \\vee \\forall z R(z)\\]\nPasso 2: Aplicar a Lei de De Morgan na Disjunção: em seguida, aplicamos a lei de De Morgan à parte negada da fórmula, transformando \\(\\neg(A \\vee B)\\) em \\((\\neg A \\wedge \\neg B)\\):\n\\[(\\neg\\exists x P(x) \\wedge \\neg\\forall y Q(y)) \\vee \\forall z R(z)\\]\nPasso 3: Mover Negações para Dentro dos Quantificadores (FNN): agora, movemos as negações para dentro dos quantificadores, aplicando as regras \\(\\neg\\exists x \\equiv \\forall x \\neg\\) e \\(\\neg\\forall y \\equiv \\exists y \\neg\\):\n\\[(\\forall x \\neg P(x) \\wedge \\exists y \\neg Q(y)) \\vee \\forall z R(z)\\]\nPasso 4: Mover Quantificadores para o Início (Prenexação): finalmente, movemos todos os quantificadores para o início da fórmula para obter a Forma Normal Prenex:\n\\[\\forall x \\exists y \\forall z ((\\neg P(x) \\wedge \\neg Q(y)) \\vee R(z))\\]\nResultado: a fórmula final em FNP, com todos os passos detalhados, é:\n\\[\\forall x \\exists y \\forall z ((\\neg P(x) \\wedge \\neg Q(y)) \\vee R(z))\\]\n\n\n7.3.3.4 Exemplo 4\nFórmula inicial: \\(\\neg(\\forall x \\exists y P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\)\nSolução:\n\nAplicar a lei de De Morgan para negação de quantificador universal (passo 1.1.8):\n\\[(\\exists x \\neg(\\exists y P(x,y))) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\]\nAplicar a lei de De Morgan para negação de quantificador existencial (passo 1.1.9):\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\]\nRenomear variáveis ligadas (passo 3): para garantir que cada quantificador tenha uma variável única, renomeamos \\(u\\) para \\(v\\).\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall v R(v))\\]\nMover quantificadores para o início (prenexação, passo 4):\n\\[\\exists x \\forall y \\exists z \\forall w \\forall v ((\\neg P(x,y)) \\vee (Q(z,w) \\wedge R(v)))\\]\nAnalisar a matriz para FND: a matriz da fórmula é \\((\\neg P(x,y)) \\vee (Q(z,w) \\wedge R(v))\\). Esta expressão já está na Forma Normal Disjuntiva, pois consiste em uma disjunção (∨) onde os operandos são um literal (¬P(x,y)) e uma conjunção de literais (Q(z,w) \\wedge R(v)). Nenhuma aplicação da lei distributiva é necessária.\n\nResultado:\n\\[\\exists x \\forall y \\exists z \\forall w \\forall v ((\\neg P(x,y)) \\vee (Q(z,w) \\wedge R(v)))\\]\n\n\n7.3.3.5 Exemplo 5\nFórmula inicial: \\(\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\neg(\\exists z \\forall w R(z,w))\\)\nPasso 1: Remover Implicações: primeiro, removemos a implicação $ P(x) y Q(x,y)$:\n\\[\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge \\neg(\\exists z \\forall w R(z,w))\\]\nPasso 2: Mover Negações para Dentro (FNN): aplicamos as leis de De Morgan para quantificadores na segunda parte da fórmula para mover a negação para dentro:\n\\[\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge (\\forall z \\exists w \\neg R(z,w))\\]\nPasso 3: Mover Quantificadores para o Início (Prenexação): renomeamos as variáveis \\(z\\) e \\(w\\) para \\(u\\) e \\(v\\) para evitar conflitos e movemos todos os quantificadores para o início:\n\\[\\forall x \\exists y \\forall u \\exists v ((\\neg P(x) \\vee Q(x,y)) \\wedge \\neg R(u,v))\\]\nPasso 4: Distribuir \\(\\land\\) sobre \\(\\lor\\): a matriz \\((\\neg P(x) \\vee Q(x,y)) \\wedge \\neg R(u,v)\\) ainda não está em FND. Para convertê-la, aplicamos a lei distributiva da conjunção sobre a disjunção. A expressão tem a forma \\((X \\vee Y) \\land Z\\), que é equivalente a \\((X \\land Z) \\lor (Y \\land Z)\\):\n\\[\\forall x \\exists y \\forall u \\exists v ((\\neg P(x) \\wedge \\neg R(u,v)) \\lor (Q(x,y) \\wedge \\neg R(u,v)))\\]\nResultado: a fórmula final está em FND, pois sua matriz é uma disjunção de duas cláusulas conjuntivas:\n\\[\\forall x \\exists y \\forall u \\exists v ((\\neg P(x) \\wedge \\neg R(u,v)) \\lor (Q(x,y) \\wedge \\neg R(u,v)))\\]\n\n\n\n7.3.4 Algoritmo para Forma Normal Conjuntiva Prenex (FNC Prenex)\nEntrada: Fórmula \\(A\\). Saída: Fórmula \\(B\\) em FNC Prenex tal que \\(A \\equiv B\\).\n\nrepita\n\npara todas as subfórmulas \\(X, Y, Z \\in A\\) faça\n\nse \\((X \\rightarrow Y)\\) redefina como \\((\\neg X \\vee Y)\\)\nse \\((X \\leftrightarrow Y)\\) redefina como \\((X \\wedge Y) \\vee (\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\vee Y)\\) redefina como \\((\\neg X \\wedge \\neg Y)\\)\nse \\(\\neg(X \\wedge Y)\\) redefina como \\((\\neg X \\vee \\neg Y)\\)\nse \\(\\neg\\neg X\\) redefina como \\(X\\)\nse \\((X \\wedge Y) \\vee Z\\) redefina como \\((X \\vee Z) \\wedge (Y \\vee Z)\\)\nse \\(X \\vee (Y \\wedge Z)\\) redefina como \\((X \\vee Y) \\wedge (X \\vee Z)\\)\nse \\(\\neg\\forall x P(x)\\) redefina como \\(\\exists x \\neg P(x)\\)\nse \\(\\neg\\exists x P(x)\\) redefina como \\(\\forall x \\neg P(x)\\)\nse \\(\\forall x P(x)\\) onde \\(x\\) não ocorre livre em \\(P\\), redefina como \\(P\\)\nse \\(\\exists x P(x)\\) onde \\(x\\) não ocorre livre em \\(P\\), redefina como \\(P\\)\nse \\((\\forall x P(x)) \\vee Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (P(x) \\vee Y)\\)\nse \\((\\exists x P(x)) \\vee Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (P(x) \\vee Y)\\)\nse \\(Y \\vee (\\forall x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (Y \\vee P(x))\\)\nse \\(Y \\vee (\\exists x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (Y \\vee P(x))\\)\nse \\((\\forall x P(x)) \\wedge Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (P(x) \\wedge Y)\\)\nse \\((\\exists x P(x)) \\wedge Y\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (P(x) \\wedge Y)\\)\nse \\(Y \\wedge (\\forall x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\forall x (Y \\wedge P(x))\\)\nse \\(Y \\wedge (\\exists x P(x))\\) onde \\(x\\) não ocorre livre em \\(Y\\), redefina como \\(\\exists x (Y \\wedge P(x))\\)\nse \\((\\forall x P(x)) \\wedge (\\forall y Q(y))\\) redefina como \\(\\forall x \\forall y (P(x) \\wedge Q(y))\\)\nse \\((\\exists x P(x)) \\vee (\\exists y Q(y))\\) redefina como \\(\\exists x \\exists y (P(x) \\vee Q(y))\\)\nse \\((\\forall x P(x)) \\vee (\\forall y Q(y))\\) redefina como \\(\\forall x \\forall y (P(x) \\vee Q(y))\\)\nse \\((\\exists x P(x)) \\wedge (\\exists y Q(y))\\) redefina como \\(\\exists x \\exists y (P(x) \\wedge Q(y))\\)\nse \\((\\forall x P(x)) \\vee (\\exists y Q(y))\\) redefina como \\(\\forall x \\exists y (P(x) \\vee Q(y))\\)\nse \\((\\exists x P(x)) \\wedge (\\forall y Q(y))\\) redefina como \\(\\exists x \\forall y (P(x) \\wedge Q(y))\\)\n\nfim\n\naté não ocorrerem substituições\nRenomeie variáveis ligadas para evitar conflitos\nMova todos os quantificadores para o início da fórmula (prenexação)\n\n\n7.3.4.1 Exemplo 1\nFórmula inicial: \\(\\forall x (P(x) \\rightarrow Q(x)) \\wedge \\neg(\\exists y R(y))\\)\nSolução: 1. Eliminar implicações (passo 1.1.1):\n\\[\\forall x (\\neg P(x) \\vee Q(x)) \\wedge \\neg(\\exists y R(y))\\]\n\nAplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8):\n\n\\[\\forall x (\\neg P(x) \\vee Q(x)) \\wedge \\forall y \\neg R(y)\\]\n\nNão há mais substituições a serem feitas.\nMover quantificadores para o início (prenexação, passo 4):\n\n\\[\\forall x \\forall z ((\\neg P(x) \\vee Q(x)) \\wedge \\neg R(z))\\]\nResultado:\n\\[\\forall x \\forall z ((\\neg P(x) \\vee Q(x)) \\wedge \\neg R(z))\\]\n\n\n7.3.4.2 Exemplo 2\nFórmula inicial: \\(\\neg(\\forall x P(x) \\rightarrow \\exists y Q(y))\\)\nSolução:\n\nEliminar implicações (passo 1.1.1):\n\n\\[\\neg(\\neg(\\forall x P(x)) \\vee \\exists y Q(y))\\]\n\nAplicar lei de De Morgan para negação de disjunção (passo 1.1.2):\n\n\\[\\neg\\neg(\\forall x P(x)) \\wedge \\neg(\\exists y Q(y))\\]\n\nEliminar dupla negação (passo 1.1.4):\n\n\\[(\\forall x P(x)) \\wedge \\neg(\\exists y Q(y))\\]\n\nAplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8):\n\n\\[(\\forall x P(x)) \\wedge (\\forall y \\neg Q(y))\\]\n\nNão há mais substituições a serem feitas.\nRenomear variáveis ligadas (passo 3): não é necessário neste caso.\nMover quantificadores para o início (prenexação, passo 4):\n\n\\[\\forall x \\forall y (P(x) \\wedge \\neg Q(y))\\]\nResultado: \\(\\forall x \\forall y (P(x) \\wedge \\neg Q(y))\\)\n\n\n7.3.4.3 Exemplo 3\nFórmula inicial: \\((P \\vee Q) \\wedge (R \\rightarrow (S \\wedge T))\\)\nSolução:\nPasso 1: Eliminar Implicações: primeiro, removemos a implicação \\(R \\rightarrow (S \\wedge T)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[(P \\vee Q) \\wedge (\\neg R \\vee (S \\wedge T))\\]\nPasso 2: Analisar a Matriz para FNC: a matriz da fórmula precisa ser uma conjunção de disjunções de literais. A primeira cláusula, \\((P \\vee Q)\\), já está nesse formato. No entanto, a segunda cláusula, \\((\\neg R \\vee (S \\wedge T))\\), contém uma conjunção dentro de uma disjunção, o que impede que a fórmula esteja em FNC. Portanto, precisamos aplicar a distributividade.\nPasso 3: Distribuir \\(\\lor\\) sobre \\(\\land\\): aplicamos a lei distributiva da disjunção sobre a conjunção na cláusula \\((\\neg R \\vee (S \\wedge T))\\). A regra é \\(X \\vee (Y \\wedge Z) \\equiv (X \\vee Y) \\wedge (X \\vee Z)\\):\n\\[(P \\vee Q) \\wedge ((\\neg R \\vee S) \\wedge (\\neg R \\vee T))\\]\nPasso 4: Simplificar a Fórmula: pela propriedade associativa da conjunção, podemos remover os parênteses extras para obter a forma final.\n\\[(P \\vee Q) \\wedge (\\neg R \\vee S) \\wedge (\\neg R \\vee T)\\]\nResultado: a fórmula final está em FNC, pois é uma conjunção de três cláusulas, onde cada uma é uma disjunção de literais:\n\\[(P \\vee Q) \\wedge (\\neg R \\vee S) \\wedge (\\neg R \\vee T)\\]\n\n\n7.3.4.4 Exemplo 4\nFórmula inicial: \\(\\neg(\\forall x \\exists y P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\)\nSolução:\n\nAplicar lei de De Morgan para negação de quantificador universal (passo 1.1.7):\n\n\\[(\\exists x \\neg(\\exists y P(x,y))) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\]\n\nAplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8):\n\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall u R(u))\\]\n\nNão há mais substituições a serem feitas.\nRenomear variáveis ligadas (passo 3):\n\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists z \\forall w Q(z,w) \\wedge \\forall v R(v))\\]\n\nMover quantificadores para o início (prenexação, passo 4):\n\n\\[\\exists x \\forall y \\exists z \\forall w \\forall v ((\\neg P(x,y)) \\vee (Q(z,w) \\wedge R(v)))\\]\n\nDistribuir \\(\\vee\\) sobre \\(\\wedge\\)(passo 1.1.6):\n\n\\[\\exists x \\forall y \\exists z \\forall w \\forall v ((\\neg P(x,y) \\vee Q(z,w)) \\wedge (\\neg P(x,y) \\vee R(v)))\\]\nResultado final:\n\\[\\exists x \\forall y \\exists z \\forall w \\forall v ((\\neg P(x,y) \\vee Q(z,w)) \\wedge (\\neg P(x,y) \\vee R(v)))\\]\n\n\n7.3.4.5 Exemplo 5\nFórmula inicial: \\(\\forall x (P(x) \\vee (Q(x) \\wedge R(x))) \\wedge \\neg(\\exists y S(y))\\)\nSolução:\n\nAplicar distribuição (passo 1.1.6):\n\n\\[\\forall x ((P(x) \\vee Q(x)) \\wedge (P(x) \\vee R(x))) \\wedge \\neg(\\exists y S(y))\\]\n\nAplicar lei de De Morgan para negação de quantificador existencial (passo 1.1.8):\n\n\\[\\forall x ((P(x) \\vee Q(x)) \\wedge (P(x) \\vee R(x))) \\wedge \\forall y \\neg S(y)\\]\n\nNão há mais substituições a serem feitas.\nRenomear variáveis ligadas (passo 3):\n\n\\[\\forall x ((P(x) \\vee Q(x)) \\wedge (P(x) \\vee R(x))) \\wedge \\forall z \\neg S(z)\\]\n\nMover quantificadores para o início (prenexação, passo 4):\n\n\\[\\forall x \\forall z (((P(x) \\vee Q(x)) \\wedge (P(x) \\vee R(x))) \\wedge \\neg S(z))\\]\nResultado:\n\\[\\forall x \\forall z (((P(x) \\vee Q(x)) \\wedge (P(x) \\vee R(x))) \\wedge \\neg S(z))\\]\n\n\n\n7.3.5 Exercícios Formas Normais Prenex\nVou resolver cada um desses exercícios utilizando os algoritmos que definimos para FNC e FND. Começaremos com a fórmula em Lógica de Primeiro Grau e aplicaremos os algoritmos passo a passo.\n\n7.3.5.1 Exercício 1:\nTransforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: Todos os alunos estudam ou alguns professores ensinam matemática.\nSolução\nExpressando a sentença em Lógica de Primeiro Grau, teremos:\n\\[(\\forall x (A(x) \\rightarrow E(x))) \\lor (\\exists y (P(y) \\land M(y)))\\]\n\n7.3.5.1.1 Solução para FNC:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(A(x) \\rightarrow E(x)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[(\\forall x (\\neg A(x) \\vee E(x))) \\lor (\\exists y (P(y) \\land M(y)))\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex. Como as variáveis \\(x\\) e \\(y\\) são independentes, a ordem entre \\(\\forall x\\) e \\(\\exists y\\) pode ser escolhida livremente.\n\\[\\forall x \\exists y ((\\neg A(x) \\vee E(x)) \\lor (P(y) \\land M(y)))\\]\nPasso 3: Distribuir \\(\\lor\\) sobre \\(\\land\\): agora, para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma \\(Z \\lor (X \\land Y)\\), que é equivalente a \\((Z \\lor X) \\land (Z \\lor Y)\\):\n\\[\\forall x \\exists y ((\\neg A(x) \\vee E(x) \\vee P(y)) \\land (\\neg A(x) \\vee E(x) \\vee M(y)))\\]\nResultado: a fórmula final em FNC é:\n\\[\\forall x \\exists y ((\\neg A(x) \\vee E(x) \\vee P(y)) \\land (\\neg A(x) \\vee E(x) \\vee M(y)))\\]\n\n\n7.3.5.1.2 Solução para FND:\nPasso 1: Remover Implicações e Realizar a Prenexação: os passos iniciais são idênticos aos da conversão para FNC. Removemos as implicações e movemos os quantificadores para obter a forma prenex.\n\\[\\forall x \\exists y ((\\neg A(x) \\vee E(x)) \\lor (P(y) \\land M(y)))\\]\nPasso 2: Analisar a Matriz: o algoritmo para FND exige que a matriz da fórmula seja uma disjunção de conjunções de literais. Analisando a matriz \\((\\neg A(x) \\vee E(x)) \\lor (P(y) \\land M(y))\\), notamos que ela já satisfaz essa condição. Ela é uma disjunção entre os literais \\(\\neg A(x)\\), \\(E(x)\\) e a conjunção \\((P(y) \\land M(y))\\). Assim, nenhuma etapa adicional de distribuição é necessária.\nResultado: a fórmula final em FND é:\n\\[\\forall x \\exists y (\\neg A(x) \\vee E(x) \\vee (P(y) \\land M(y)))\\]\n\n\n\n7.3.5.2 Exercício 2\nTransforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: Algum aluno estuda e todo professor ensina.\nSolução: Representando a sentença em Lógica de Primeiro Grau, teremos:\n\\[(\\exists x (A(x) \\land E(x))) \\land (\\forall y (P(y) \\rightarrow N(y)))\\]\n\n7.3.5.2.1 Solução para FND:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(P(y) \\rightarrow N(y)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[(\\exists x (A(x) \\land E(x))) \\land (\\forall y (\\neg P(y) \\lor N(y)))\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula. A fórmula resultante está na Forma Normal Prenex.\n\\[\\exists x \\forall y ((A(x) \\land E(x)) \\land (\\neg P(y) \\lor N(y)))\\]\nPasso 3: Distribuir \\(\\land\\) sobre \\(\\lor\\): a matriz da fórmula, \\((A(x) \\land E(x)) \\land (\\neg P(y) \\lor N(y))\\), ainda não está em FND. Para convertê-la, aplicamos a lei distributiva da conjunção sobre a disjunção. A expressão tem a forma \\(Z \\land (X \\lor Y)\\), que é equivalente a \\((Z \\land X) \\lor (Z \\land Y)\\):\n\\[\\exists x \\forall y (((A(x) \\land E(x)) \\land \\neg P(y)) \\lor ((A(x) \\land E(x)) \\land N(y)))\\]\nPasso 4: Simplificar a Matriz: podemos remover os parênteses internos nas cláusulas conjuntivas para obter a forma final.\n\\[\\exists x \\forall y ((A(x) \\land E(x) \\land \\neg P(y)) \\lor (A(x) \\land E(x) \\land N(y)))\\]\nResultado: a fórmula final está em FND, pois sua matriz é uma disjunção de duas cláusulas conjuntivas:\n\\[\\exists x \\forall y ((A(x) \\land E(x) \\land \\neg P(y)) \\lor (A(x) \\land E(x) \\land N(y)))\\]\n\n\n\n7.3.5.3 Exercício 3\nTransforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: Todo estudante é inteligente ou algum professor é sábio.\nTransformando a sentença em Lógica de Primeiro Grau, teremos:\n\\[(\\forall x (E(x) \\rightarrow I(x))) \\lor (\\exists y (P(y) \\land S(y)))\\]\n\n7.3.5.3.1 Solução para FNC:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(E(x) \\rightarrow I(x)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[(\\forall x (\\neg E(x) \\vee I(x))) \\lor (\\exists y (P(y) \\land S(y)))\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex.\n\\[\\forall x \\exists y ((\\neg E(x) \\vee I(x)) \\lor (P(y) \\land S(y)))\\]\nPasso 3: Distribuir \\(\\lor\\) sobre \\(\\land\\): para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma \\(Z \\lor (X \\land Y)\\), que é equivalente a \\((Z \\lor X) \\land (Z \\lor Y)\\):\n\\[\\forall x \\exists y ((\\neg E(x) \\vee I(x) \\vee P(y)) \\land (\\neg E(x) \\vee I(x) \\vee S(y)))\\]\nResultado: a fórmula final em FNC é:\n\\[\\forall x \\exists y ((\\neg E(x) \\vee I(x) \\vee P(y)) \\land (\\neg E(x) \\vee I(x) \\vee S(y)))\\]\n\n\n7.3.5.3.2 Solução para FND:\nPasso 1: Remover Implicações e Realizar a Prenexação: os passos iniciais são os mesmos da conversão para FNC, resultando na forma prenex:\n\\[\\forall x \\exists y ((\\neg E(x) \\vee I(x)) \\lor (P(y) \\land S(y)))\\]\nPasso 2: Analisar a Matriz: o algoritmo para FND exige que a matriz seja uma disjunção de conjunções. Analisando a matriz \\((\\neg E(x) \\vee I(x)) \\lor (P(y) \\land S(y))\\), notamos que ela já satisfaz essa condição. É uma disjunção de literais (\\(\\neg E(x)\\), \\(I(x)\\)) e uma conjunção (\\((P(y) \\land S(y))\\)). Nenhuma etapa de distribuição é necessária.\nResultado: a fórmula final em FND é:\n\\[\\forall x \\exists y (\\neg E(x) \\vee I(x) \\vee (P(y) \\land S(y)))\\]\n\n\n\n7.3.5.4 Exercício 4\nTransforme a sentença a seguir em Forma Normal Conjuntiva e Disjuntiva, prenex se possível: Todo animal corre ou algum pássaro voa.\nEm Lógica de Primeiro Grau, teremos:\n\\[(\\forall x (A(x) \\rightarrow C(x))) \\lor (\\exists y (P(y) \\land V(y)))\\]\n\n7.3.5.4.1 Solução para FNC:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(A(x) \\rightarrow C(x)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[(\\forall x (\\neg A(x) \\vee C(x))) \\lor (\\exists y (P(y) \\land V(y)))\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex.\n\\[\\forall x \\exists y ((\\neg A(x) \\vee C(x)) \\lor (P(y) \\land V(y)))\\]\nPasso 3: Distribuir \\(\\lor\\) sobre \\(\\land\\): para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma \\(Z \\lor (X \\land Y)\\), que é equivalente a \\((Z \\lor X) \\land (Z \\lor Y)\\):\n\\[\\forall x \\exists y ((\\neg A(x) \\vee C(x) \\vee P(y)) \\land (\\neg A(x) \\vee C(x) \\vee V(y)))\\]\nResultado: a fórmula final em FNC é:\n\\[\\forall x \\exists y ((\\neg A(x) \\vee C(x) \\vee P(y)) \\land (\\neg A(x) \\vee C(x) \\vee V(y)))\\]\n\n\n7.3.5.4.2 Solução para FND:\nPasso 1: Remover Implicações e Realizar a Prenexação: os passos iniciais são os mesmos da conversão para FNC, resultando na forma prenex:\n\\[\\forall x \\exists y ((\\neg A(x) \\vee C(x)) \\lor (P(y) \\land V(y)))\\]\nPasso 2: Analisar a Matriz: o algoritmo para FND exige que a matriz seja uma disjunção de conjunções. Analisando a matriz \\((\\neg A(x) \\vee C(x)) \\lor (P(y) \\land V(y))\\), notamos que ela já satisfaz essa condição. É uma disjunção de literais (\\(\\neg A(x)\\), \\(C(x)\\)) e uma conjunção (\\((P(y) \\land V(y))\\)). Nenhuma etapa de distribuição é necessária.\nResultado: a fórmula final em FND é:\n\\[\\forall x \\exists y (\\neg A(x) \\vee C(x) \\vee (P(y) \\land V(y)))\\]\n\n\n\n7.3.5.5 Exercício 5\nConverta a seguinte fórmula para a Forma Normal Conjuntiva Prenex (FNCP).\nFórmula inicial: \\(\\neg (\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\leftrightarrow \\exists z R(z))\\)\nSolução\n\n7.3.5.5.1 Solução para FNC:\nPasso 1: Eliminar a Equivalência (\\(\\leftrightarrow\\)): A fórmula tem a estrutura \\(\\neg(A \\leftrightarrow B)\\). Primeiro, expandimos a bicondicional usando a regra \\(A \\leftrightarrow B \\equiv (A \\wedge B) \\vee (\\neg A \\wedge \\neg B)\\), e aplicamos a negação externa.\n\\[\\neg ((\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists z R(z)) \\vee (\\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\neg \\exists z R(z)))\\]\nAplicando a lei de De Morgan na disjunção principal, obtemos:\n\\[\\neg (\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists z R(z)) \\wedge \\neg (\\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\neg \\exists z R(z))\\]\nAplicando a lei de De Morgan novamente em ambas as conjunções:\n\\[(\\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\neg \\exists z R(z)) \\wedge (\\neg \\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\neg \\neg \\exists z R(z))\\]\nPasso 2: Eliminar Implicações e Duplas Negações: Agora, eliminamos as implicações e as duplas negações, e movemos as negações para dentro (conversão para FNN).\n\\[(\\exists x \\neg (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\forall z \\neg R(z)) \\wedge (\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\exists z R(z))\\]\n\\[(\\exists x \\neg (\\neg P(x) \\vee \\exists y Q(x,y)) \\vee \\forall z \\neg R(z)) \\wedge (\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\vee \\exists z R(z))\\]\n\\[(\\exists x (P(x) \\wedge \\forall y \\neg Q(x,y)) \\vee \\forall z \\neg R(z)) \\wedge (\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\vee \\exists z R(z))\\]\nPasso 3: Renomear Variáveis e Prenexação: Renomeamos as variáveis para evitar conflitos de escopo (\\(x \\rightarrow u, y \\rightarrow v, z \\rightarrow w\\)) e movemos todos os quantificadores para o início. A ordem dos quantificadores é \\(\\exists x \\forall y \\forall z\\) da primeira parte, e \\(\\forall u \\exists v \\exists w\\) da segunda.\n\\[\\exists x \\forall y \\forall z \\forall u \\exists v \\exists w [( (P(x) \\wedge \\neg Q(x,y)) \\vee \\neg R(z) ) \\wedge ( (\\neg P(u) \\vee Q(u,v)) \\vee R(w) )]\\]\nPasso 4: Converter a Matriz para FNC: A matriz precisa ser uma conjunção de disjunções. A primeira parte, \\((P(x) \\wedge \\neg Q(x,y)) \\vee \\neg R(z)\\), precisa ser distribuída: \\((P(x) \\vee \\neg R(z)) \\wedge (\\neg Q(x,y) \\vee \\neg R(z))\\). A segunda parte, \\((\\neg P(u) \\vee Q(u,v)) \\vee R(w)\\), já está na forma disjuntiva.\n\\[\\exists x \\forall y \\forall z \\forall u \\exists v \\exists w [(P(x) \\vee \\neg R(z)) \\wedge (\\neg Q(x,y) \\vee \\neg R(z)) \\wedge (\\neg P(u) \\vee Q(u,v) \\vee R(w))]\\]\nResultado: a fórmula final em FNCP é:\n\\[\\exists x \\forall y \\forall z \\forall u \\exists v \\exists w [(P(x) \\vee \\neg R(z)) \\wedge (\\neg Q(x,y) \\vee \\neg R(z)) \\wedge (\\neg P(u) \\vee Q(u,v) \\vee R(w))]\\]\n\n\n\n7.3.5.6 Exercício 6\nConverta a seguinte fórmula para a Forma Normal Disjuntiva Prenex (FNDP).\nFórmula inicial: \\((\\exists x P(x) \\rightarrow \\forall y Q(y)) \\wedge (\\exists z R(z) \\rightarrow \\forall w S(w))\\)\nSolução\n\n7.3.5.6.1 Solução para FND:\nPasso 1: Eliminar Implicações: Removemos as implicações em ambas as cláusulas da conjunção.\n\\[(\\neg \\exists x P(x) \\vee \\forall y Q(y)) \\wedge (\\neg \\exists z R(z) \\vee \\forall w S(w))\\]\nPasso 2: Mover Negações para Dentro (FNN): Aplicamos as regras de negação dos quantificadores.\n\\[(\\forall x \\neg P(x) \\vee \\forall y Q(y)) \\wedge (\\forall z \\neg R(z) \\vee \\forall w S(w))\\]\nPasso 3: Prenexação: Renomeamos as variáveis na segunda cláusula para evitar conflitos (\\(z \\rightarrow u, w \\rightarrow v\\)) e movemos todos os quantificadores para o início da fórmula.\n\\[\\forall x \\forall y \\forall u \\forall v [(\\neg P(x) \\vee Q(y)) \\wedge (\\neg R(u) \\vee S(v))]\\]\nPasso 4: Converter a Matriz para FND: A matriz atual, \\((\\neg P(x) \\vee Q(y)) \\wedge (\\neg R(u) \\vee S(v))\\), tem a forma \\((A \\vee B) \\wedge (C \\vee D)\\), que não está em FND. Precisamos aplicar a lei distributiva para convertê-la em uma disjunção de conjunções. Distribuindo \\((A \\vee B)\\) sobre \\((C \\vee D)\\), obtemos: \\(((A \\vee B) \\wedge C) \\vee ((A \\vee B) \\wedge D)\\). Isso expande para: \\((A \\wedge C) \\vee (B \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge D)\\).\nAplicando aos nossos literais:\n\\[(\\neg P(x) \\wedge \\neg R(u)) \\vee (Q(y) \\wedge \\neg R(u)) \\vee (\\neg P(x) \\wedge S(v)) \\vee (Q(y) \\wedge S(v))\\]\nResultado: a fórmula final em FNDP, com a matriz distribuída, é:\n\\[\\forall x \\forall y \\forall u \\forall v [(\\neg P(x) \\wedge \\neg R(u)) \\vee (Q(y) \\wedge \\neg R(u)) \\vee (\\neg P(x) \\wedge S(v)) \\vee (Q(y) \\wedge S(v))]\\]\n\n\n\n7.3.5.7 Exercício 7\nTransforme a sentença a seguir em Forma Normal Conjuntiva Prenex (FNCP) e Forma Normal Disjuntiva Prenex (FNDP): Se para todo problema existe uma solução, então não é verdade que todos os problemas são difíceis.\nSolução\nPrimeiro, formalizamos a sentença:\n\n\\(P(x)\\): \\(x\\) é um problema\n\\(S(x,y)\\): \\(y\\) é uma solução para \\(x\\);\n\\(D(x)\\): \\(x\\) é difícil.\n\nA fórmula em lógica de primeira ordem é:\n\\[\n(\\forall x (P(x) \\rightarrow \\exists y S(x,y))) \\rightarrow (\\neg \\forall z (P(z) \\rightarrow D(z)))\n\\]\nPasso 1: Eliminar Implicações e Mover Negações (FNN): Começamos eliminando a implicação principal e, em seguida, as internas.\n\\[\n\\neg (\\forall x (\\neg P(x) \\vee \\exists y S(x,y))) \\vee (\\neg \\forall z (\\neg P(z) \\vee D(z)))\n\\]\nAgora, movemos as negações para dentro dos quantificadores.\n\\[\n(\\exists x \\neg (\\neg P(x) \\vee \\exists y S(x,y))) \\vee (\\exists z \\neg (\\neg P(z) \\vee D(z)))\n\\]\nAplicamos a lei de De Morgan nas disjunções.\n\\[\n(\\exists x (P(x) \\wedge \\neg \\exists y S(x,y))) \\vee (\\exists z (P(z) \\wedge \\neg D(z)))\n\\]\nFinalizamos a conversão para FNN.\n\\[\n(\\exists x (P(x) \\wedge \\forall y \\neg S(x,y))) \\vee (\\exists z (P(z) \\wedge \\neg D(z)))\n\\]\nPasso 2: Prenexação: Renomeamos a variável \\(z\\) para \\(w\\) para evitar conflito e movemos os quantificadores para o início.\n\\[\n\\exists x \\forall y \\exists w [ (P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w)) ]\n\\]\nEsta é a Forma Normal Prenex. Agora, vamos converter a matriz para FNC e FND. A matriz é \\((P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w))\\).\n\n7.3.5.7.1 Solução para FND:\nA matriz \\((P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w))\\) já está na Forma Normal Disjuntiva, pois é uma disjunção de duas conjunções de literais. Portanto, nenhum passo adicional de distribuição é necessário.\nResultado (FNDP):\n\\[\n\\exists x \\forall y \\exists w [ (P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w)) ]\n\\]\n\n\n7.3.5.7.2 Solução para FNC:\nPara converter a matriz para FNC, precisamos distribuir a disjunção sobre a conjunção. A matriz tem a forma \\((A \\wedge B) \\vee (C \\wedge D)\\). Aplicando a distributividade, obtemos \\(( (A \\wedge B) \\vee C ) \\wedge ( (A \\wedge B) \\vee D )\\). Expandindo novamente, resulta em \\((A \\vee C) \\wedge (B \\vee C) \\wedge (A \\vee D) \\wedge (B \\vee D)\\).\nAplicando aos nossos literais, a matriz se torna:\n\\[\n(P(x) \\vee P(w)) \\wedge (\\neg S(x,y) \\vee P(w)) \\wedge (P(x) \\vee \\neg D(w)) \\wedge (\\neg S(x,y) \\vee \\neg D(w))\n\\]\nResultado (FNCP):\n\\[\n\\exists x \\forall y \\exists w [ (P(x) \\vee P(w)) \\wedge (\\neg S(x,y) \\vee P(w)) \\wedge (P(x) \\vee \\neg D(w)) \\wedge (\\neg S(x,y) \\vee \\neg D(w)) ]\n\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais: Estruturas de Solução</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#sec-predicativa-conexao-prolog",
    "href": "05-formas-normais-e-skolemizacao.html#sec-predicativa-conexao-prolog",
    "title": "7  Formas Normais: Estruturas de Solução",
    "section": "7.4 Exercícios de Conexão com Prolog",
    "text": "7.4 Exercícios de Conexão com Prolog\nA conversão de fórmulas para uma Forma Normal (seja Conjuntiva - Forma Normal Conjuntiva, ou Disjuntiva - Forma Normal Disjuntiva) é um processo algorítmico que permite a padronização e a manipulação de expressões lógicas por computadores. Este conjunto de questões foca nesta habilidade, que é a base para o funcionamento de provadores de teoremas e do mecanismo de resolução do Prolog.\nQuestão 1: Conversão Básica: dada a seguinte fórmula lógica, que representa uma regra de negócio simples: Se o pedido (\\(P\\)) foi aprovado, então a nota fiscal (\\(N\\)) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (\\(E\\)). Fórmula:\n\\[(P \\to N) \\wedge \\neg (N \\wedge \\neg E)\\]\nConverta esta fórmula para:\n\nA Forma Normal Conjuntiva.\n\nA Forma Normal Disjuntiva.\n\nQuestão 2: Cenários de Ativação de Sistema: um sistema de irrigação automática (\\(I\\)) é ativado se o sensor de umidade do solo indicar que está seco (\\(S\\)) ou se não choveu nas últimas 24 horas (\\(\\neg C\\)) e a temperatura está alta (\\(T\\)).\n\nModele a condição de ativação (\\(I\\)) como uma fórmula lógica.\n\nConverta a fórmula para a Forma Normal Disjuntiva. O que cada termo da Forma Normal Disjuntiva representa em termos de cenários práticos de ativação?\n\nQuestão 3: Verificação de Consistência de Regras: as regras de configuração de um firewall são:\n\nSe uma conexão é da rede interna (\\(I\\)), ela é permitida (\\(P\\)).\n\nSe uma conexão não é da rede interna, ela só é permitida se for uma conexão segura (\\(S\\)).\n\nUma conexão segura nunca vem da rede interna.\n\nModele as três regras como uma única fórmula. Converta-a para a Forma Normal Conjuntiva. A Forma Normal Conjuntiva resultante indica se as regras são consistentes? O que aconteceria se uma conexão fosse segura e viesse da rede interna?\nQuestão 4: Equivalência de Políticas de Segurança: dois administradores de sistemas escreveram políticas de acesso a um servidor de desenvolvimento.\n\nPolítica de Alice: Um desenvolvedor (\\(D\\)) pode acessar o servidor se tiver uma chave de acesso (\\(C\\)), ou se não tiver uma chave de acesso mas estiver trabalhando em um projeto crítico (\\(P\\)).\nPolítica de Beto: Um desenvolvedor (\\(D\\)) pode acessar o servidor se estiver trabalhando em um projeto crítico (\\(P\\)), ou se tiver uma chave de acesso (\\(C\\)).\n\nModele as duas políticas como fórmulas lógicas e converta ambas para a Forma Normal Disjuntiva Mínima. Elas são logicamente equivalentes?\nQuestão 5: Eliminando a Bicondicional: uma regra de um e-commerce afirma: Um cliente recebe frete grátis (\\(F\\)) se, e somente se, ele for um membro Prime (\\(P\\)) ou o valor do seu pedido for superior a R$100 (\\(V\\)).\nFórmula:\n\\[F \\leftrightarrow (P \\vee V)\\]\nConverta esta fórmula para a Forma Normal Conjuntiva. Cada cláusula da Forma Normal Conjuntiva representa que tipo de restrição no sistema?\nQuestão 6: Simplificação de Circuito Lógico: a saída de um circuito lógico com três entradas (\\(A\\), \\(B\\), \\(C\\)) é descrita pela seguinte tabela verdade:\n\n\n\n\\(A\\)\n\\(B\\)\n\\(C\\)\nSaída\n\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n0\n1\n\n\n1\n0\n1\n1\n\n\n1\n1\n0\n0\n\n\n1\n1\n1\n0\n\n\n\n\nEscreva a Forma Normal Disjuntiva canônica a partir da tabela.\nUse um Mapa de Karnaugh ou álgebra booleana para encontrar a Forma Normal Disjuntiva mínima.\n\nQuestão 7: Validando uma Inferência (Tautologia): considere que Todos os leões são mamíferos e Simba é um leão, podemos concluir Simba é um mamífero. Prove que a estrutura lógica desta inferência é uma tautologia:\n\\[((\\forall x(L(x) \\to M(x))) \\wedge L(S)) \\to M(S)\\]\nQuestão 8: Problema de Satisfatibilidade (SAT): três programadores (Ana, Beto, Carla) precisam ser alocados para um projeto. As restrições são:\n\nPelo menos um dos três deve ser alocado;\n\nAna e Beto não podem trabalhar juntos;\nSe Carla for alocada, então Ana também deve ser.\n\nSejam \\(A\\), \\(B\\), \\(C\\) as proposições Ana foi alocada, Beto foi alocado e Carla foi alocada. Modele as três restrições e converta-as para um conjunto de cláusulas em Forma Normal Conjuntiva. O conjunto de restrições é satisfatível? Se sim, apresente uma alocação válida.\nQuestão 9: Forma Normal Prenex: a conversão para Forma Normal Clausal, que veremos no próximo capítulo, muitas vezes começa com a conversão para a Forma Normal Prenex, na qual todos os quantificadores são movidos para o início da fórmula.\nConverta a seguinte fórmula para a Forma Normal Prenex:\n\\[\\forall x (P(x) \\to (\\exists y (Q(y) \\wedge R(x,y)))) \\vee \\exists z S(z)\\]\nQuestão 10: O Princípio da Resolução: o Princípio da Resolução é um método de inferência que opera sobre cláusulas em Forma Normal Conjuntiva. Dadas duas cláusulas \\((\\neg P \\vee Q)\\) e \\((P \\vee R)\\), podemos inferir a cláusula resolvente \\((Q \\vee R)\\).\nUse o Princípio da Resolução para provar que o seguinte conjunto de cláusulas é inconsistente (leva à cláusula vazia, \\(\\square\\)):\n\n\\(\\neg P \\vee \\neg Q \\vee R\\);\n\\(P \\vee R\\);\n\\(Q\\);\n\\(\\neg R\\).",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais: Estruturas de Solução</span>"
    ]
  },
  {
    "objectID": "05-formas-normais-e-skolemizacao.html#quantificadores-generalizados-na-forma-normal-prenex-e-skolemização",
    "href": "05-formas-normais-e-skolemizacao.html#quantificadores-generalizados-na-forma-normal-prenex-e-skolemização",
    "title": "7  Formas Normais: Estruturas de Solução",
    "section": "7.5 Quantificadores Generalizados na Forma Normal Prenex e Skolemização",
    "text": "7.5 Quantificadores Generalizados na Forma Normal Prenex e Skolemização\nNos capítulos anteriores, estudamos como toda fórmula da Lógica de Primeira Ordem pode ser transformada em uma Forma Normal Prenex, onde todos os quantificadores aparecem no início da fórmula, e como o processo de Skolemização elimina quantificadores existenciais, facilitando a automatização de provas. Mas o que acontece quando introduzimos quantificadores generalizados neste contexto? Este capítulo explora as complexidades fascinantes e os desafios técnicos que emergem quando tentamos aplicar estas transformações clássicas aos quantificadores que vão além de \\(\\forall\\) e \\(\\exists\\).\n\n7.5.1 1. O Problema Fundamental: Interdependências Complexas\nNa Lógica de Primeira Ordem clássica, a ordem dos quantificadores na forma prenex é crucial. Considere a diferença entre:\n\n\\(\\forall x \\exists y: P(x,y)\\) – Para todo x, existe um y tal que P(x,y)\n\\(\\exists y \\forall x: P(x,y)\\) – Existe um y tal que, para todo x, P(x,y)\n\nCom quantificadores generalizados, as interdependências tornam-se ainda mais sutis. Por exemplo, como interpretar:\n\\[\\exists_{=3} x \\exists_{=2} y: R(x,y)\\]\nEsta fórmula significa existem exatamente 3 x’s tais que, para cada um deles, existem exatamente 2 y’s relacionados? Ou significa algo diferente? A semântica precisa depende do escopo e da interpretação escolhida.\n\n\n7.5.2 2. Forma Normal Prenex para Quantificadores de Contagem\n\n7.5.2.1 2.1. Transformações Básicas\nPara quantificadores numéricos simples, podemos estabelecer regras de transformação análogas às da Lógica de Primeira Ordem clássica. Considere as seguintes equivalências:\nNegação:\n\\[\\neg(\\exists_{=n} x: P(x)) \\equiv (\\exists_{&lt;n} x: P(x)) \\lor (\\exists_{&gt;n} x: P(x))\\]\nConjunção com Quantificadores Independentes:\n\\[(\\exists_{=m} x: P(x)) \\land (\\exists_{=n} y: Q(y)) \\equiv \\exists_{=m} x \\exists_{=n} y: (P(x) \\land Q(y))\\]\nquando \\(x\\) e \\(y\\) não compartilham variáveis livres.\nExemplo Prático: Sistema de Alocação de Recursos\nConsidere um sistema de cloud computing que precisa verificar: Existem exatamente 3 servidores disponíveis e cada um tem exatamente 4 núcleos livres\n// Formalização inicial (não-prenex)\n(∃=3 s: Disponivel(s)) ∧ (∀s: Disponivel(s) → ∃=4 c: NucleoLivre(s,c))\n\n// Transformação para forma prenex\n∃=3 s ∀s' ∃=4 c: (Disponivel(s) ∧ (Disponivel(s') → NucleoLivre(s',c)))\nNote que precisamos introduzir uma nova variável \\(s'\\) para evitar captura de variável, similar ao processo na Lógica de Primeira Ordem clássica.\n\n\n7.5.2.2 2.2. Limitações na Mobilidade\nDiferente dos quantificadores clássicos, os quantificadores numéricos têm mobilidade restrita. Nem sempre podemos movê-los livremente através de conectivos lógicos:\n\\[(\\exists_{=2} x: P(x)) \\lor (\\exists_{=3} x: P(x)) \\not\\equiv \\exists_{=?} x: P(x)\\]\nNão existe um único quantificador numérico que capture 2 ou 3. Isto força a criação de formas normais prenex disjuntivas:\n\\[\\bigvee_{i \\in I} \\left( Q_1^i x_1 Q_2^i x_2 \\ldots Q_n^i x_n : \\phi_i \\right)\\]\nonde cada disjunto tem seu próprio prefixo de quantificadores.\n\n\n\n7.5.3 3. Skolemização Generalizada\n\n7.5.3.1 3.1. Funções de Skolem para Quantificadores Numéricos\nA skolemização clássica substitui \\(\\exists x\\) por uma função de Skolem. Com quantificadores numéricos, precisamos de múltiplas funções de Skolem:\nTransformação de \\(\\exists_{=n}\\): \\[\\forall y \\exists_{=n} x: P(y,x) \\Rightarrow \\forall y: P(y,f_1(y)) \\land P(y,f_2(y)) \\land \\ldots \\land P(y,f_n(y)) \\land \\text{Distinct}(f_1(y), \\ldots, f_n(y))\\]\nonde \\(\\text{Distinct}\\) garante que todas as funções de Skolem retornam valores diferentes: \\[\\text{Distinct}(f_1(y), \\ldots, f_n(y)) \\equiv \\bigwedge_{1 \\le i &lt; j \\le n} f_i(y) \\ne f_j(y)\\]\nExemplo: Alocação de Tarefas\nConsidere a especificação: Todo projeto tem exatamente 2 desenvolvedores designados\n// Forma original\n∀p ∃=2 d: Designado(p,d)\n\n// Após skolemização\n∀p: Designado(p, dev₁(p)) ∧ \n    Designado(p, dev₂(p)) ∧ \n    dev₁(p) ≠ dev₂(p) ∧\n    ∀d: (Designado(p,d) → (d = dev₁(p) ∨ d = dev₂(p)))\nNote a cláusula adicional que garante que são exatamente 2, não apenas pelo menos 2.\n\n\n7.5.3.2 3.2. O Problema da Explosão Combinatória\nQuantificadores de contagem grandes levam a uma explosão no número de funções de Skolem:\n\\[\\exists_{=100} x: P(x) \\text{ requer 100 funções de Skolem!}\\]\nIsto motiva o desenvolvimento de técnicas de skolemização compacta:\n// Representação indexada\n∀i ∈ {1,...,n}: P(sk(i)) ∧ ∀i,j ∈ {1,...,n}: i ≠ j → sk(i) ≠ sk(j)\n\n\n\n7.5.4 4. Quantificadores Proporcionais e o Desafio da Prenexação\n\n7.5.4.1 4.1. Não-Composicionalidade\nO quantificador Most apresenta desafios únicos. Considere:\n\\[\\text{Most } x (P(x), Q(x)) \\land \\text{Most } x (P(x), R(x))\\]\nNão podemos simplesmente combinar isso em: \\[\\text{Most } x (P(x), Q(x) \\land R(x))\\]\npois a semântica é diferente! A primeira diz que a maioria dos P’s são Q’s e a maioria dos P’s são R’s. A segunda diz que a maioria dos P’s são tanto Q’s quanto R’s.\n\n\n7.5.4.2 4.2. Aproximações por Limites\nUma estratégia é aproximar quantificadores proporcionais usando sequências de quantificadores numéricos:\n\\[\\text{Most } x (P(x), Q(x)) \\approx \\exists_{&gt;n/2} x: (P(x) \\land Q(x)) \\land \\exists_{=n} x: P(x)\\]\npara algum \\(n\\) suficientemente grande. Isto permite usar as técnicas de prenexação numérica, mas perde a generalidade.\n\n\n\n7.5.5 5. Quantificadores Infinitários e a Impossibilidade de Skolemização Clássica\n\n7.5.5.1 5.1. O Teorema de Limitação\nTeorema: Não existe skolemização finitária para \\(\\exists^{\\infty} x: P(x)\\).\nProva (esboço): Qualquer número finito de funções de Skolem produziria apenas um número finito de testemunhas, contradizendo a infinitude requerida.\n\n\n7.5.5.2 5.2. Skolemização de Segunda Ordem\nPara quantificadores infinitários, precisamos recorrer a símbolos funcionais de segunda ordem:\n\\[\\exists^{\\infty} x: P(x) \\Rightarrow \\exists F: \\text{Injective}(F) \\land \\forall n \\in \\mathbb{N}: P(F(n))\\]\nonde \\(F: \\mathbb{N} \\to D\\) é uma função injetiva que enumera infinitos elementos satisfazendo \\(P\\).\nExemplo: Teoria dos Conjuntos\nPara formalizar Existe uma infinidade de conjuntos contendo o elemento \\(a\\):\n// Forma original\n∃^∞ S: a ∈ S\n\n// Após skolemização de segunda ordem\n∃F: Injective(F) ∧ ∀n ∈ ℕ: a ∈ F(n)\n// onde F mapeia números naturais para conjuntos\n\n\n\n7.5.6 6. Estratégias Computacionais e Aplicações\n\n7.5.6.1 6.1. Fragmentos Decidíveis\nAlguns fragmentos com quantificadores generalizados mantêm decidibilidade:\nFragmento Monádico com Contagem: Fórmulas da forma \\[Q_1 x_1 \\ldots Q_n x_n: \\phi\\] onde cada \\(Q_i \\in \\{\\forall, \\exists, \\exists_{=k}, \\exists_{\\le k}, \\exists_{\\ge k}\\}\\) e \\(\\phi\\) usa apenas predicados unários.\nEste fragmento tem procedimento de decisão via autômatos de árvore com contadores.\n\n\n7.5.6.2 6.2. Aplicação: Verificação de Software\nConsidere a verificação de um pool de threads:\n// Invariante: _Sempre há entre 2 e 5 threads ativas_\n□(∃≥2 t: Ativa(t) ∧ ∃≤5 t: Ativa(t))\n\n// Transformação para verificação\n□(∀s: Estado(s) → \n    (∃t₁,t₂: t₁≠t₂ ∧ Ativa(s,t₁) ∧ Ativa(s,t₂)) ∧\n    (∀t₁,...,t₆: ¬(Distinct₆(t₁,...,t₆) ∧ ⋀ᵢ Ativa(s,tᵢ))))\nA forma prenex facilita o uso de SMT solvers modernos que suportam cardinalidade.\n\n\n\n7.5.7 7. Direções Futuras e Questões Abertas\n\n7.5.7.1 7.1. Quantificadores Dependentes\nA teoria de quantificadores dependentes de Henkin generaliza ainda mais: \\[\\exists_{f(x)} y: P(x,y)\\] onde o número de y’s depende funcionalmente de x.\n\n\n7.5.7.2 7.2. Quantificadores Fuzzy\nPara Muitos ou Poucos, precisamos de lógicas com valores de verdade contínuos, levando a: - Formas normais prenex fuzzy - Skolemização probabilística\n\n\n\n7.5.8 Conclusão: Um Novo Paradigma de Normalização\nA introdução de quantificadores generalizados não apenas estende a expressividade lógica, mas fundamentalmente desafia e enriquece nossos métodos de normalização e transformação de fórmulas. A forma normal prenex e a skolemização, conceitos centrais na automatização da lógica clássica, precisam ser repensadas e generalizadas.\nEste campo continua ativo na pesquisa, com aplicações diretas em:\n\nVerificação formal de sistemas com requisitos de cardinalidade;\nProcessamento de linguagem natural onde quantificadores proporcionais são ubíquos;\nBancos de dados dedutivos com consultas agregadas complexas;\nRaciocínio automatizado em domínios com restrições numéricas.\n\nO estudo destes métodos não é meramente teórico – é a ponte necessária entre a riqueza expressiva dos quantificadores generalizados e sua aplicação prática em sistemas computacionais modernos.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Formas Normais: Estruturas de Solução</span>"
    ]
  },
  {
    "objectID": "06-clausulas-de-horn-e-prolog.html",
    "href": "06-clausulas-de-horn-e-prolog.html",
    "title": "8  Formas Clausais e A Cláusula de Horn",
    "section": "",
    "text": "8.0.1 Exemplos Resolvidos de Conversão para Forma Clausal\nA seguir, vamos aplicar o algoritmo de 7 passos para converter duas fórmulas da Lógica de Primeira Ordem em sua Forma Clausal, que é a base para a programação em Prolog.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Formas Clausais e A Cláusula de Horn</span>"
    ]
  },
  {
    "objectID": "06-clausulas-de-horn-e-prolog.html#a-cláusula-de-horn",
    "href": "06-clausulas-de-horn-e-prolog.html#a-cláusula-de-horn",
    "title": "8  Formas Clausais e A Cláusula de Horn",
    "section": "8.1 A Cláusula de Horn",
    "text": "8.1 A Cláusula de Horn\nA Cláusula de Horn foi nomeada em homenagem ao matemático e lógico americano Alfred Horn, que a introduziu em um artigo publicado em 1951. O contexto histórico e a motivação para a introdução da Cláusula de Horn são profundamente enraizados na solução do Problema da Decidibilidade. Na primeira metade do século XX, a lógica matemática estava focada na questão da decidibilidade: determinar se uma afirmação lógica é verdadeira ou falsa de forma algorítmica.\nNão demorou muito para os matemáticos perceberem que a Lógica de Primeira Ordem é poderosa, mas pode ser ineficientes para resolver os problemas relacionados ao Problema da Decidibilidade. A busca por formas mais eficientes de resolução levou ao estudo de subconjuntos restritos da Lógica de Primeira Ordem, onde a decidibilidade poderia ser alcançada de forma mais eficiente. Aqui, eficiência significa o menor custo computacional, no menor tempo.\nAlfred Horn identificou um desses subconjuntos em seu artigo de 1951, introduzindo o que agora é conhecido como Cláusula de Horn. Ele mostrou que esse subconjunto particular tem propriedades interessantes que permitem a resolução em tempo polinomial, tornando-o atraente para aplicações práticas.\nSe prepare vamos ver porque \\(P \\vee \\neg Q \\vee \\neg R\\) é uma Cláusula de Horn e \\(P \\vee Q \\vee \\neg R\\) não é.\n\n8.1.1 Definição da Cláusula de Horn\nA Cláusula de Horn é uma disjunção de literais que contém, no máximo, um literal positivo. Existem algumas formas equivalentes de representar Cláusulas de Horn:\n\nForma Disjuntiva: \\(\\neg A_1 \\vee \\neg A_2 \\vee \\ldots \\vee \\neg A_k \\vee B\\) Aqui, \\(A_1, \\ldots, A_k, B\\) são proposições atômicas (átomos). Os literais \\(\\neg A_i\\) são negativos, e \\(B\\) é o único literal positivo (se presente). Se não houver literal positivo, a cláusula é uma meta ou consulta. Se não houver literais negativos, é um fato.\nForma Implicativa (mais comum em programação lógica): \\((A_1 \\wedge A_2 \\wedge \\ldots \\wedge A_k) \\rightarrow B\\) Esta forma é equivalente à disjuntiva acima.\n\n\n\\(A_1, \\ldots, A_k\\) são os átomos no corpo (antecedente) da implicação.\n\\(B\\) é o átomo na cabeça (consequente) da implicação.\n\nTipos de Cláusulas de Horn (baseado na forma disjuntiva \\(\\neg A_1 \\vee \\ldots \\vee \\neg A_k \\vee B\\)):\n\nFatos (Cláusulas Unitárias Positivas): Têm exatamente um literal positivo e nenhum literal negativo (\\(k=0\\)).\nForma disjuntiva: \\(B\\)\nForma implicativa: \\(\\top \\rightarrow B\\) (ou simplesmente \\(B.\\) em Prolog)\nExemplo: \\(Mortal(socrates)\\).\nRegras (Cláusulas Definidas): Têm exatamente um literal positivo (\\(B\\)) e um ou mais literais negativos (\\(\\neg A_i\\), com \\(k \\ge 1\\)).\nForma disjuntiva: \\(\\neg A_1 \\vee \\ldots \\vee \\neg A_k \\vee B\\)\nForma implicativa: \\((A_1 \\wedge \\ldots \\wedge A_k) \\rightarrow B\\) (ou \\(B \\leftarrow A_1, \\ldots, A_k.\\) em Prolog)\nExemplo: \\(Homem(x) \\rightarrow Mortal(x)\\) (Cláusula: \\(\\neg Homem(x) \\vee Mortal(x)\\)).\nMetas ou Consultas (Cláusulas Negativas): Não têm nenhum literal positivo (a parte \\(B\\) está ausente, ou é \\(\\bot\\) - falso), e um ou mais literais negativos (\\(k \\ge 1\\)).\nForma disjuntiva: \\(\\neg A_1 \\vee \\ldots \\vee \\neg A_k\\)\nForma implicativa: \\((A_1 \\wedge \\ldots \\wedge A_k) \\rightarrow \\bot\\) (ou \\(\\leftarrow A_1, \\ldots, A_k.\\) em Prolog)\nExemplo: \\(\\leftarrow Mortal(socrates)\\) (Cláusula: \\(\\neg Mortal(socrates)\\)).\nCláusula Nula (ou Vazia): Representa uma contradição. Não possui literais. Surge quando uma consulta é refutada.\nForma disjuntiva: \\(\\Box\\) ou \\(\\bot\\)\n\nPara entender melhor, imagine que estamos construindo um cenário mental fundamentado na lógica para construir o entendimento de um problema, uma espécie de paisagem mental onde as coisas fazem sentido. Nesse cenário, as Cláusulas de Horn serão os tijolos fundamentais que usaremos para construir estruturas lógicas.\n1. Fatos: os fatos são como pedras fundamentais desse cenário. Eles são afirmações simples e diretas que dizem como as coisas são. Considere, por exemplo: O céu é azul, \\(P\\) e A grama é verde\\(Q\\). Essas são verdades que não precisam de justificativa. Elas simplesmente são. os Fatos são axiomas.\n2. Regras: as regras são um pouco mais intrigantes. Elas são como as regras de um jogo que definem como as coisas se relacionam umas com as outras. Se chover, a grama ficará molhada. Essa é uma regra. Ela nos diz o que esperar se certas condições forem atendidas. As regras são como os conectores em nosso mundo lógico, ligando fatos e permitindo que façamos inferências. Elas são o motor que nos permite raciocinar e descobrir novas verdades a partir das que já conhecemos. Por exemplo:\n\n\\(P \\wedge Q \\rightarrow R\\): Se chover, \\(P\\) e ventar, \\(Q\\), então não faremos um piquenique, \\(R\\).\n\\(A \\wedge B \\wedge C \\rightarrow D\\): Se \\(A\\), \\(B\\) e \\(C\\) forem verdadeiros, então \\(D\\) é verdadeiro.\n\n\nNota sobre Negação: Em Cláusulas de Horn puras, os antecedentes das regras contêm apenas literais positivos. Quando queremos expressar condições negativas como “não está chovendo”, precisamos modelá-las de forma diferente:\n\nUsando predicados positivos que representam a negação: tempo_seco ao invés de \\neg chovendo;\nOu aceitando que nem toda lógica pode ser expressa diretamente em Cláusulas de Horn;\nLinguagens como Prolog estendem Cláusulas de Horn com “negação por falha” (\\+) para contornar essa limitação.\n\nEssa restrição é importante porque mantém a eficiência computacional das Cláusulas de Horn, permitindo algoritmos de resolução em tempo polinomial.\n\n3. Metas ou Consultas: finalmente, temos as metas ou consultas. Essas são as perguntas que fazemos ao nosso mundo lógico. Está chovendo?, A grama está molhada? São os caminhos que usaremos para explorar o cenário criado, olhando ao redor e tentando entender o que está acontecendo. As consultas são a forma de interagir com nosso mundo lógico, usando os fatos e regras que estabelecemos para encontrar respostas e alcançar objetivos. Por exemplo:\n\n\\(\\neg P \\wedge \\neg Q\\): É verdade que hoje não está chovendo e não está ventando?\n\\(\\neg X \\wedge \\neg Y \\wedge \\neg Z\\): \\(x\\), \\(Y\\) e $Z $ são falsos?\n\nPodemos tentar avaliar alguns exemplos de uso de Fatos, Regras e Consultas:\n\n8.1.1.1 Exemplo 1 - Sistema de Recomendação de Roupas\nImagine que estamos construindo um sistema lógico para recomendar o tipo de roupa que uma pessoa deve vestir com base no clima. Vamos usar Cláusulas de Horn para representar o conhecimento e a lógica do sistema.\n1. Fatos: primeiro, estabelecemos os fatos, as verdades básicas do cenário que descreve nosso problema. Neste exemplo, os fatos poderiam ser informações sobre o clima atual.\n\nFato 1: Está ensolarado. (Representado como \\(S\\));\nFato 2: A temperatura está acima de 20°C. (Representado como \\(T\\)).\n\nVocê pode criar todos os fatos necessários a descrição do seu problema.\n2. Regras: em seguida, definimos as regras que descrevem como as coisas se relacionam. Essas regras nos dizem o tipo de roupa apropriada com base no clima.\n\nRegra 1: Se está ensolarado e a temperatura está acima de 20°C, use óculos de sol. (\\(S \\wedge T \\rightarrow O\\));\nRegra 2: Se está ensolarado, use chapéu. (\\(S \\rightarrow C\\));\nRegra 3: Se a temperatura está acima de 20°C, use camiseta. (\\(T \\rightarrow A\\)).\n\nVocê pode criar todas as regras que achar importante para definir o comportamento no cenário que descreve o problema.\n3. Consultas (Metas): agora, podemos fazer consultas ao nosso sistema para obter recomendações de roupas.\n\nConsulta 1: Está ensolarado e a temperatura está acima de 20°C. O que devo vestir? (\\(S \\wedge T\\));\n\nAs consultas representam todas as consultas que podem ser feitas neste cenário. A esforçada leitora deve criar quantas consultas achar necessário para entender o problema.\n4. Resolução: usando os fatos e regras, podemos resolver a consulta:\n\nEstá ensolarado e a temperatura está acima de 20°C (Fato);\nPortanto, use óculos de sol (Regra 1);\nPortanto, use chapéu (Regra 2);\nPortanto, use camiseta (Regra 3).\n\nNeste exemplo, as Cláusulas de Horn nos permitiram representar o conhecimento sobre o clima e as regras para escolher roupas. Os fatos forneceram a base de conhecimento, as regras permitiram inferências lógicas, e a consulta nos permitiu explorar o sistema para obter recomendações práticas.\n\n\n8.1.1.2 Exemplo 2 - Sistema de Diagnóstico Médico\nImagine que estamos construindo um sistema lógico para diagnosticar doenças com base em sintomas, histórico médico e outros fatores relevantes. Vamos usar Cláusulas de Horn para representar o conhecimento e a lógica do sistema.\n1. Fatos: começamos estabelecendo os fatos, que são as informações conhecidas sobre o paciente. Para lidar com a ausência de uma condição (como não ter sido vacinado) dentro das restrições das Cláusulas de Horn, definimos predicados positivos para ambas as possibilidades.\n\nFato 1: O paciente tem febre. (Representado como \\(F\\));\nFato 2: O paciente tem tosse. (Representado como \\(T\\));\nFato 3: O paciente viajou recentemente para uma área endêmica. (Representado como \\(V\\));\nFato 4: A situação vacinal do paciente. A base de conhecimento conteria ou vacinado_gripe ou nao_vacinado_gripe.\n\nG: O paciente foi vacinado contra a gripe.\nNG: O paciente não foi vacinado contra a gripe.\n\n\n2. Regras: em seguida, definimos as regras que descrevem as relações entre sintomas, histórico médico e possíveis doenças. Agora, todas as regras são Cláusulas de Horn válidas.\n\nRegra 1: Se o paciente tem febre e tosse, e foi vacinado contra a gripe, então pode ter resfriado comum. (\\(F \\wedge T \\wedge G \\rightarrow R\\));\nRegra 2: Se o paciente tem febre, tosse e viajou para uma área endêmica, então pode ter malária. (\\(F \\wedge T \\wedge V \\rightarrow M\\));\nRegra 3: Se o paciente tem febre e tosse, e não foi vacinado contra a gripe, então pode ter gripe. (\\(F \\wedge T \\wedge NG \\rightarrow I\\)).\n\n3. Consultas: agora, podemos fazer consultas ao nosso sistema. Suponha que temos os seguintes fatos para um paciente específico: F, T, V, G.\n\nConsulta 1: O paciente tem febre, tosse, viajou para uma área endêmica e foi vacinado contra a gripe. Qual é o diagnóstico? (\\(F \\wedge T \\wedge V \\wedge G\\));\n\n4. Resolução: usando os fatos e regras, podemos resolver a consulta:\n\nO paciente tem febre, tosse, viajou para uma área endêmica e foi vacinado contra a gripe (Fatos);\nPortanto, o paciente pode ter resfriado comum (Regra 1 é ativada pelos fatos F, T e G);\nPortanto, o paciente pode ter malária (Regra 2 é ativada pelos fatos F, T e V).\nA Regra 3 (diagnóstico de gripe) não é ativada, pois o fato NG não está na base de conhecimento.\n\n5. Conclusão: esta abordagem, utilizando predicados positivos para representar condições mutuamente exclusivas, mantém o sistema dentro da lógica de Cláusulas de Horn puras. Ela ilustra como modelar conhecimento de forma compatível com as restrições e a eficiência computacional que tornam as Cláusulas de Horn tão úteis.\n\n\n8.1.1.3 Exemplo 3 - Mundo Núcleo Familiar (Lógica de Primeira Ordem)\nO exemplo a seguir apresenta um mundo que representa uma família e suas relações, apresentado usando a sintaxe da Lógica de Primeira Ordem (FOL).\nFatos: os fatos são representados como predicados aplicados a constantes em FOL.\n\n\\(Homem(joão)\\);\n\\(Homem(pedro)\\);\n\\(Mulher(maria)\\);\n\\(Mulher(ana)\\);\n\\(Progenitor(joão, pedro)\\);\n\\(Progenitor(maria, pedro)\\);\n\\(Progenitor(joão, ana)\\);\n\\(Progenitor(maria, ana)\\).\n\nRegras:\n1. Pai:\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y (Homem(X) \\wedge Progenitor(X, Y) \\rightarrow Pai(X, Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y (\\neg Homem(X) \\vee \\neg Progenitor(X, Y) \\vee Pai(X, Y))\n\\]\n2. Mãe:\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y (Mulher(X) \\wedge Progenitor(X, Y) \\rightarrow Mae(X, Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y (\\neg Mulher(X) \\vee \\neg Progenitor(X, Y) \\vee Mae(X, Y))\n\\]\n3. Meio-Irmão: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y \\forall Z (Homem(X) \\wedge Progenitor(Z, X) \\wedge Progenitor(Z, Y) \\wedge X \\neq Y \\rightarrow MeioIrmao(X, Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\vee \\neg Progenitor(Z, X) \\vee \\neg Progenitor(Z, Y) \\vee X = Y \\vee MeioIrmao(X, Y))\n\\]\nNota: Esta não é uma Cláusula de Horn, pois a sua forma disjuntiva contém dois literais positivos: X = Y e MeioIrmao(X, Y). Uma Cláusula de Horn pode ter no máximo um literal positivo.\n4. Meio-Irmã: com pelo menos um progenitor em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y \\forall Z (Mulher(X) \\wedge Progenitor(Z, X) \\wedge Progenitor(Z, Y) \\wedge X \\neq Y \\rightarrow MeioIrma(X, Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\vee \\neg Progenitor(Z, X) \\vee \\neg Progenitor(Z, Y) \\vee X = Y \\vee MeioIrma(X, Y))\n\\]\nNota: Esta também não é uma Cláusula de Horn, pois contém os literais positivos X = Y e MeioIrma(X, Y). \n5. Irmão: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y \\forall P \\forall M (Homem(X) \\wedge Pai(P,X) \\wedge Pai(P,Y) \\wedge Mae(M,X) \\wedge Mae(M,Y) \\wedge X \\neq Y \\rightarrow Irmao(X,Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y \\forall P \\forall M (\\neg Homem(X) \\vee \\neg Pai(P,X) \\vee \\neg Pai(P,Y) \\vee \\neg Mae(M,X) \\vee \\neg Mae(M,Y) \\vee X = Y \\vee Irmao(X,Y))\n\\]\nNota: Esta cláusula também não é de Horn devido aos dois literais positivos X = Y e Irmao(X,Y). \n6. Irmã: com ambos os pais em comum e não sendo a mesma pessoa.\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y \\forall P \\forall M (Mulher(X) \\wedge Pai(P,X) \\wedge Pai(P,Y) \\wedge Mae(M,X) \\wedge Mae(M,Y) \\wedge X \\neq Y \\rightarrow Irma(X,Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y \\forall P \\forall M (\\neg Mulher(X) \\vee \\neg Pai(P,X) \\vee \\neg Pai(P,Y) \\vee \\neg Mae(M,X) \\vee \\neg Mae(M,Y) \\vee X = Y \\vee Irma(X,Y))\n\\]\nNota: Novamente, a presença de X = Y e Irma(X,Y) impede que esta seja uma Cláusula de Horn.\n7. Avô:\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y \\forall Z (Homem(X) \\wedge Progenitor(X, Z) \\wedge Progenitor(Z, Y) \\rightarrow Avo(X, Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y \\forall Z (\\neg Homem(X) \\vee \\neg Progenitor(X, Z) \\vee \\neg Progenitor(Z, Y) \\vee Avo(X, Y))\n\\]\n8. Avó:\n\nForma Implicativa:\n\n\\[\n\\forall X \\forall Y \\forall Z (Mulher(X) \\wedge Progenitor(X, Z) \\wedge Progenitor(Z, Y) \\rightarrow Avo(X, Y))\n\\]\n\nForma Clausal:\n\n\\[\n\\forall X \\forall Y \\forall Z (\\neg Mulher(X) \\vee \\neg Progenitor(X, Z) \\vee \\neg Progenitor(Z, Y) \\vee Avo(X, Y))\n\\]\nConsultas (Metas):\n\npai(joão, pedro)\n\nPara verificar se \\(Pai(joão, pedro)\\) é uma consequência lógica da base de conhecimento, tenta-se provar que a base de conhecimento junto com \\(\\neg Pai(joão, pedro)\\) leva a uma contradição (\\(\\bot\\)). A meta é, portanto: \\[\n\\neg Pai(joão, pedro)\n\\]\n\nirmão(pedro, ana)\n\nPara verificar se \\(Irmao(pedro, ana)\\) é verdadeiro: \\[\n\\neg Irmao(pedro, ana)\n\\]\n\navó(X, ana)\n\nPara perguntar se Existe uma avó X para Ana?, a consulta seria \\(\\exists X (Avo(X, ana) \\wedge Mulher(X))\\). A forma de meta para refutação seria tentar provar que a base de conhecimento junto com \\(\\forall X (\\neg Avo(X, ana) \\vee \\neg Mulher(X))\\) leva a uma contradição. Em um sistema de prova por refutação, adicionamos a negação da consulta à base de conhecimento e tentamos derivar uma contradição (\\(\\bot\\)). As representações das metas como negações em FOL estão corretas nesse contexto.\n\n\n8.1.1.4 Exemplo 4 - Torre de Hanói\nA Torre de Hanói é um quebra-cabeça matemático que consiste em três postes e um número de discos de diferentes tamanhos que podem deslizar sobre qualquer poste. O quebra-cabeça começa com os discos empilhados em ordem decrescente de tamanho no primeiro poste, o menor disco no topo. O objetivo é mover toda a pilha para o último poste, obedecendo às seguintes regras:\nPredicados:\n\n\\(Disco(x)\\): \\(x\\) é um disco;\n\\(Poste(x)\\): \\(x\\) é um poste;\n\\(Menor(x)\\): \\(x\\) é o disco menor;\n\\(Maior(x, y)\\): o disco \\(x\\) é maior que o disco \\(y\\);\n\\(Em(x, y)\\): o disco \\(x\\) está no poste \\(y\\);\n\\(Sobre(x, y)\\): o disco \\(x\\) está sobre o disco \\(y\\).\n\nFatos (Cláusulas de Horn Unitárias):\n\n\\(Disco(d_1)\\);\n\\(Disco(d_2)\\);\n\\(Disco(d_3)\\);\n\\(Poste(p_1)\\);\n\\(Poste(p_2)\\);\n\\(Poste(p_3)\\);\n\\(Menor(d_1)\\);\n\\(Maior(d_2, d_1)\\);\n\\(Maior(d_3, d_2)\\).\n\nRegras (Cláusulas de Horn Não-Unitárias):\n\nMovimento válido:\n\n\\[\n\\neg Disco(x) \\vee \\neg Poste(y) \\vee \\neg Poste(z) \\vee \\neg Em(x, y) \\vee \\neg DiscoNoTopo(x, y) \\vee \\neg DiscoNoTopo(u, z) \\vee \\neg Maior(x, u) \\vee MovimentoValido(x, y, z)\n\\]\n\nCondição de vitória:\n\n\\[\n\\neg Disco(x) \\vee \\neg Disco(y) \\vee \\neg Disco(z) \\vee \\neg Em(x, p_3) \\vee \\neg Em(y, p_3) \\vee \\neg Em(z, p_3) \\vee Vitoria()\n\\]\n\nDisco válido (nenhum disco maior sobre um menor):\n\n\\[\n\\neg Sobre(x, y) \\vee \\neg Maior(x, y) \\vee DiscoValido(x, y)\n\\]\n\nMovimento único:\n\n\\[\n\\neg Disco(x) \\vee \\neg Disco(y) \\vee \\neg Poste(z) \\vee \\neg Poste(w) \\vee \\neg MovimentoValido(y, z, w) \\vee x = y \\vee MovimentoUnico(x)\n\\]\nNota: Esta cláusula não é de Horn, pois contém dois literais positivos: x = y e MovimentoUnico(x). A lógica visa garantir que, se um movimento válido com o disco y está ocorrendo, qualquer outra verificação para MovimentoUnico(x) só pode ser verdadeira se x for o mesmo disco y.\n\nEstado inicial:\n\n\\[\n\\neg Em(d_1, p_1) \\vee \\neg Em(d_2, p_1) \\vee \\neg Em(d_3, p_1) \\vee \\neg Sobre(d_3, d_2) \\vee \\neg Sobre(d_2, d_1) \\vee EstadoInicial()\n\\]\n\nDisco no topo:\n\n\\[\n\\neg Disco(x) \\vee \\neg Poste(y) \\vee \\neg Em(x, y) \\vee \\neg Disco(z) \\vee \\neg Em(z, y) \\vee \\neg Sobre(z, x) \\vee DiscoNoTopo(x, y)\n\\]\nConsultas (Metas):\n\nVerificar se um movimento é válido:\n\n\\[\n\\neg MovimentoValido(x, y, z)\n\\]\n\nVerificar se o jogo foi vencido:\n\n\\[\n\\neg Vitoria()\n\\]\n\nVerificar se um disco pode estar sobre outro:\n\n\\[\n\\neg DiscoValido(x, y)\n\\]\n\nVerificar se apenas um disco está sendo movido:\n\n\\[\n\\neg MovimentoUnico(x)\n\\]\n\nVerificar o estado inicial:\n\n\\[\n\\neg EstadoInicial()\n\\]\n\nVerificar se um disco está no topo de um poste:\n\n\\[\n\\neg DiscoNoTopo(x, y)\n\\]\n\n\n\n8.1.2 Quantificadores em Cláusulas de Horn\nOs quantificadores podem ser incluídos nas Cláusulas de Horn. Contudo, é importante notar que a forma padrão de Cláusulas de Horn em programação lógica geralmente lida com quantificação de forma implícita. A quantificação universal é comum e é geralmente assumida em regras, enquanto a quantificação existencial é muitas vezes tratada através de fatos específicos ou construção de termos.\nPrecisamos tomar cuidado porque a inclusão explícita de quantificadores pode levar a uma Lógica de Primeira Ordem mais rica, permitindo expressões mais complexas e poderosas. No entanto, isso também pode aumentar a complexidade do raciocínio e da resolução.\nO quantificador universal (representado por $$) afirma que uma propriedade é verdadeira para todos os membros de um domínio. Em Cláusulas de Horn, isso é geralmente representado implicitamente através de regras gerais que se aplicam a todos os membros de um conjunto. Por exemplo, considere a regra: Todos os pássaros podem voar. Em uma Cláusula de Horn, isso pode ser representado como:\nEm programação lógica e Cláusulas de Horn, a quantificação é frequentemente tratada implicitamente.\nQuantificador Universal em Regras: considere a afirmação: __Para todo x, se x é um pássaro, então x pode voar_._\n\nFórmula em Lógica de Primeira Ordem** (LPO)**: \\(\\forall x (\\text{Pássaro}(x) \\rightarrow \\text{Voa}(x))\\)\nForma clausal (Cláusula de Horn equivalente): \\(\\neg \\text{Pássaro}(x) \\vee \\text{Voa}(x)\\) (Aqui, \\(x\\) é implicitamente quantificado universalmente.)\nRepresentação em Prolog: voa(X) :- passaro(X). (A variável X é implicitamente quantificada universalmente.)\n\nQuantificador Existencial e Fatos: considere a afirmação: __Existe um pássaro que não pode voar_._ * Fórmula em LPO: \\(\\exists x (\\text{Pássaro}(x) \\wedge \\neg \\text{Voa}(x))\\) * Tratamento em sistemas de Cláusulas de Horn: Afirmações existenciais puras como \\(\\exists x \\Phi(x)\\) não são diretamente representadas como regras de Cláusula de Horn. Para incorporar tal conhecimento, se o indivíduo específico for conhecido, ele é afirmado como um conjunto de fatos. Por exemplo, se sabemos que Pengu é um pássaro e não voa: * Fatos em Prolog: passaro(pengu). nao_voa(pengu). (ou voa(pengu) :- fail.)\n\nSe a existência é conhecida mas o indivíduo não é nomeado, em processos de prova teórica (como resolução), a Skolemização substituiria \\(x\\) por uma nova constante (constante de Skolem), resultando em: \\(\\text{Pássaro}(c) \\wedge \\neg \\text{Voa}(c)\\). Estes seriam então fatos no sistema: \\(\\text{Pássaro}(c).\\) e \\(\\neg \\text{Voa}(c).\\) (ou um predicado para a negação).\n\n\n\n8.1.3 Conversão de Fórmulas para Cláusulas de Horn\nA conversão de uma fórmula arbitrária para um conjunto de Cláusulas de Horn nem sempre é possível, pois as Cláusulas de Horn são um subconjunto restrito da lógica clausal. Uma fórmula só pode ser representada por Cláusulas de Horn se seu significado lógico for compatível com a restrição de ter no máximo um literal positivo por cláusula.\nO procedimento correto para verificar se uma fórmula pode ser representada como um conjunto de Cláusulas de Horn é o seguinte:\n\nConverter para Forma Normal Conjuntiva (FNC): O primeiro passo, e o mais importante, é transformar a fórmula original em sua FNC equivalente. A FNC é uma conjunção (E) de cláusulas, onde cada cláusula é uma disjunção (OU) de literais.\nAnalisar Cada Cláusula Individualmente: Após obter a FNC, examine cada cláusula (cada conjunto de literais unidos por ∨) separadamente.\nVerificar a Definição de Cláusula de Horn: Para cada cláusula, conte o número de literais positivos (átomos não negados).\n\n\nSe todas as cláusulas na FNC contiverem no máximo um literal positivo, a fórmula original é equivalente a um conjunto de Cláusulas de Horn.\nSe pelo menos uma cláusula contiver dois ou mais literais positivos, a fórmula não pode ser representada como um conjunto de Cláusulas de Horn, pois não há uma equivalência lógica direta.\n\n\n8.1.3.1 Exemplo 1: Conversão Bem-Sucedida\nConsidere a fórmula:\n\\[(P \\rightarrow Q) \\wedge P\\]\nSolução:\n\nConverter para FNC:\n\n\nPrimeiro, eliminamos a implicação: \\((\\neg P \\vee Q) \\wedge P\\);\nA fórmula já está em FNC.\n\n\nAnalisar as Cláusulas: A FNC nos dá duas cláusulas:\n\n\nCláusula 1: \\((\\neg P \\vee Q)\\). Esta cláusula tem um literal positivo (\\(Q\\)). É uma Cláusula de Horn;\nCláusula 2: \\(P\\). Esta cláusula tem um literal positivo (\\(P\\)). É uma Cláusula de Horn (um fato).\n\nResultado: Como todas as cláusulas resultantes são Cláusulas de Horn, a fórmula original pode ser representada pelo conjunto de cláusulas:\n\n\\(\\neg P \\vee Q\\);\n\\(P\\).\n\n\n\n8.1.3.2 Exemplo 2: Conversão Impossível\nConsidere a fórmula:\n\\[P \\vee Q\\]\nSolução:\n\nConverter para FNC:\n\n\nA fórmula já está em FNC. Ela consiste em uma única cláusula.\n\n\nAnalisar a Cláusula:\n\n\nA única cláusula é \\((P \\vee Q)\\).\nEsta cláusula contém dois literais positivos (\\(P\\) e \\(Q\\)).\n\nResultado: Como a cláusula contém mais de um literal positivo, ela não é uma Cláusula de Horn. Portanto, a fórmula original \\(P \\vee Q\\) não pode ser representada como uma Cláusula de Horn ou um conjunto delas.\n\n\n\n8.1.4 Limitações das Cláusulas de Horn\nEmbora as Cláusulas de Horn sejam computacionalmente eficientes e formem a base de linguagens de programação lógica como Prolog, elas possuem limitações expressivas importantes que devem ser compreendidas. Essas limitações não são defeitos, mas consequências diretas da restrição que garante sua eficiência: ter no máximo um literal positivo por cláusula.\n1. Impossibilidade de Expressar Disjunções Positivas\nA limitação mais fundamental é a incapacidade de expressar disjunções entre conclusões. Considere a afirmação: “Todo número é positivo ou negativo ou zero”. Em lógica de primeira ordem:\n\\[\\forall x (\\text{Numero}(x) \\rightarrow (\\text{Positivo}(x) \\vee \\text{Negativo}(x) \\vee \\text{Zero}(x)))\\]\nApós a conversão para forma clausal, obtemos:\n\\[\\neg \\text{Numero}(x) \\vee \\text{Positivo}(x) \\vee \\text{Negativo}(x) \\vee \\text{Zero}(x)\\]\nEsta cláusula possui três literais positivos, violando a definição de Cláusula de Horn. Não há forma equivalente de expressar esta lógica usando apenas Cláusulas de Horn sem perder informação ou alterar a semântica.\n2. Dificuldade com Negação no Antecedente\nCláusulas de Horn puras não podem expressar diretamente condições negativas no antecedente de regras. Por exemplo, a regra “Se alguém não está doente, então pode trabalhar” seria naturalmente expressa como:\n\\[\\forall x (\\neg \\text{Doente}(x) \\rightarrow \\text{PodeTrabalhar}(x))\\]\nMas isso não pode ser diretamente representado em Cláusulas de Horn. As alternativas incluem:\n\nPredicados Complementares: Criar um predicado saudavel(x) que represente explicitamente o estado de não estar doente.\nNegação por Falha: Linguagens como Prolog estendem Cláusulas de Horn com o operador \\+ (not provable), permitindo pode_trabalhar(X) :- \\+ doente(X). Porém, isso vai além das Cláusulas de Horn puras e introduz complexidades semânticas (hipótese do mundo fechado).\nAxiomatização Completa: Enumerar todos os casos positivos, o que pode ser impraticável ou impossível em domínios infinitos.\n\n3. Incapacidade de Expressar Equivalências Diretas\nBicondicionais ou definições por casos múltiplos muitas vezes geram cláusulas não-Horn. Por exemplo, a definição “X é primo se e somente se X &gt; 1 e X só é divisível por 1 e por si mesmo” resulta em cláusulas com múltiplos literais positivos quando completamente formalizada.\n4. Limitações em Raciocínio por Casos\nProblemas que requerem análise de casos disjuntivos são difíceis de modelar. Considere: “Se a porta A ou a porta B está aberta, então há uma saída”. A formalização natural:\n\\[(\\text{AbertaA} \\vee \\text{AbertaB}) \\rightarrow \\text{HaSaida}\\]\nResulta na cláusula:\n\\[\\neg \\text{AbertaA} \\vee \\neg \\text{AbertaB} \\vee \\text{HaSaida}\\]\nEsta tem apenas um literal positivo e é uma Cláusula de Horn. Porém, o problema inverso — “Se há uma saída, então a porta A ou a porta B está aberta” — não pode ser expresso:\n\\[\\text{HaSaida} \\rightarrow (\\text{AbertaA} \\vee \\text{AbertaB})\\]\nGera: \\(\\neg \\text{HaSaida} \\vee \\text{AbertaA} \\vee \\text{AbertaB}\\) (dois literais positivos).\n5. Questões de Completude\nEmbora o procedimento de resolução SLD (usado em Prolog) seja completo para Cláusulas de Horn, essa completude é relativa à semântica de Herbrand. Algumas propriedades que são consequências lógicas em semântica clássica podem não ser deriváveis usando apenas Cláusulas de Horn, especialmente aquelas que dependem de raciocínio por contradição ou casos disjuntivos.\nImpacto Prático e Soluções\nEssas limitações não tornam as Cláusulas de Horn inúteis — pelo contrário, a restrição que as define é precisamente o que permite:\n\nAlgoritmos de resolução eficientes (tempo polinomial para Cláusulas de Horn proposicionais)\nSemântica operacional clara em linguagens de programação lógica\nEstratégias de busca bem definidas e previsíveis\n\nNa prática, sistemas baseados em Cláusulas de Horn como Prolog contornam essas limitações através de:\n\nExtensões à lógica pura: negação por falha, cut (!), assert/retract\nModelagem criativa: reformulação de problemas para se adequarem ao paradigma\nHíbridos: combinação com outros paradigmas de programação quando necessário\n\nCompreender essas limitações é essencial para modelar problemas efetivamente em programação lógica e reconhecer quando outras abordagens podem ser mais apropriadas.\n\n\n8.1.5 Problemas interessantes resolvidos com a Cláusula de Horn\n\n8.1.5.0.1 Problema 1 - O Agricultor, a Raposa, o Ganso e o Grão\nEnunciado: um agricultor quer atravessar um rio e levar consigo uma raposa, um ganso e um saco de grãos. O barco só lhe permite levar um item além dele mesmo. Se a raposa e o ganso ficarem sozinhos, a raposa comerá o ganso. Se o ganso e o grão ficarem sozinhos, o ganso comerá o grão. Como o agricultor pode levar tudo para o outro lado do rio?\nEste é um problema de busca de estados. A lógica pode ser usada para definir os estados “inseguros” que devem ser evitados.\nEstado: Podemos representar um estado com o predicado estado(Agricultor, Raposa, Ganso, Grao), onde cada variável contém a sua localização (margem_esq ou margem_dir).\nFatos:\n\nO estado inicial: estado(margem_esq, margem_esq, margem_esq, margem_esq).\nPredicado auxiliar para definir margens opostas:\n\n\noposta(margem_esq, margem_dir).\noposta(margem_dir, margem_esq).\n\nRegras (Condições Inseguras): As regras definem um estado inseguro. Elas são Cláusulas de Horn com a cabeça inseguro, indicando uma condição a ser evitada.\n\nA raposa come o ganso se estiverem sozinhos na mesma margem:\n\n\\[\n\\forall M, Ag (\\text{estado}(Ag, M, M, \\_) \\wedge \\text{oposta}(Ag, M) \\rightarrow \\text{inseguro})\n\\]\nEm forma clausal: \\(\\neg \\text{estado}(Ag, M, M, \\_) \\vee \\neg \\text{oposta}(Ag, M) \\vee \\text{inseguro}\\).\n\nO ganso come o grão se estiverem sozinhos na mesma margem:\n\n\\[\n\\forall M, Ag (\\text{estado}(Ag, \\_, M, M) \\wedge \\text{oposta}(Ag, M) \\rightarrow \\text{inseguro})\n\\]\nEm forma clausal: \\(\\neg \\text{estado}(Ag, \\_, M, M) \\vee \\neg \\text{oposta}(Ag, M) \\vee \\text{inseguro}\\).\nConsulta (Meta):\nA resolução do problema envolve encontrar uma sequência de movimentos (mudanças de estado) que leve do estado inicial ao estado final (estado(margem_dir, margem_dir, margem_dir, margem_dir)) sem nunca passar por um estado que satisfaça a consulta inseguro.\n\\[\n\\neg \\text{inseguro}\n\\]\nA consulta representa a restrição a ser mantida em cada passo da solução: o estado atual não pode ser inseguro.\n\n\n8.1.5.0.2 Problema 2 - A Ponte e a Tocha\nEnunciado: quatro pessoas (A, B, C, D) precisam atravessar uma ponte à noite com uma única tocha. A ponte só suporta duas pessoas por vez. A pessoa A leva 1 minuto para atravessar, B leva 2, C leva 5 e D leva 8. Quando duas pessoas atravessam juntas, movem-se na velocidade da mais lenta. Qual o tempo mínimo para todos atravessarem?\nA modelagem completa é um problema de otimização, mas suas regras básicas podem ser representadas como Cláusulas de Horn.\nFatos (Tempos de travessia individuais):\n\ntempo(a, 1).\ntempo(b, 2).\ntempo(c, 5).\ntempo(d, 8).\n\nRegras:\n\nRegra para calcular o tempo de travessia de um par de pessoas. O tempo é o máximo dos tempos individuais.\n\n\\[\n\\forall P1, P2, T1, T2, Tmax (\\text{tempo}(P1, T1) \\wedge \\text{tempo}(P2, T2) \\wedge \\text{max}(T1, T2, Tmax) \\rightarrow \\text{tempoTravessia}(P1, P2, Tmax))\n\\]\nEm forma clausal: \\(\\neg \\text{tempo}(P1, T1) \\vee \\neg \\text{tempo}(P2, T2) \\vee \\neg \\text{max}(T1, T2, Tmax) \\vee \\text{tempoTravessia}(P1, P2, Tmax)\\).\n(Nota: max(T1, T2, Tmax) seria um predicado que é verdadeiro se Tmax for o maior entre T1 e T2).\nConsulta:\nA consulta a um sistema lógico seria sobre os blocos de construção da solução, como “Qual o tempo de travessia de C e D juntos?”.\n\\[\n\\neg \\text{tempoTravessia}(c, d, T)\n\\]\nA resposta para T seria 8. A solução completa do problema requer um algoritmo de busca que utilize essas regras para explorar diferentes sequências de travessia e encontrar a que possui a menor soma de tempos.\n\n\n8.1.5.0.3 Problema 3 - Coloração de Mapas\nEnunciado: o objetivo é colorir um mapa com um número limitado de cores, de forma que duas regiões adjacentes nunca tenham a mesma cor.\nFatos:\n\nDefinem as cores disponíveis e as adjacências entre as regiões.\n\n\ncor(vermelho).\ncor(verde).\ncor(azul).\nadjacente(regiaoA, regiaoB).\nadjacente(regiaoB, regiaoC).\nadjacente(regiaoA, regiaoC).\n\nRegra (Restrição):\nA regra principal define uma violação ou contradição. Uma violação ocorre se duas regiões adjacentes recebem a mesma cor. Esta é uma cláusula negativa (ou meta), um tipo de Cláusula de Horn.\n\\[\n\\forall R1, R2, C (\\text{corDe}(R1, C) \\wedge \\text{corDe}(R2, C) \\wedge \\text{adjacente}(R1, R2) \\rightarrow \\text{violacao})\n\\]\nEm forma clausal: \\(\\neg \\text{corDe}(R1, C) \\vee \\neg \\text{corDe}(R2, C) \\vee \\neg \\text{adjacente}(R1, R2) \\vee \\text{violacao}\\).\nConsulta:\nO objetivo é encontrar uma atribuição de cores para todas as regiões (ex: corDe(regiaoA, C1), corDe(regiaoB, C2), etc.) de modo que a consulta violacao seja falsa.\n\\[\\neg \\text{violacao}\\]\nEste tipo de problema é um exemplo clássico de “Programação com Restrições”, uma área onde a programação em lógica e as Cláusulas de Horn são amplamente utilizadas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Formas Clausais e A Cláusula de Horn</span>"
    ]
  },
  {
    "objectID": "06-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "href": "06-clausulas-de-horn-e-prolog.html#o-prolog-entra-em-cena",
    "title": "8  Formas Clausais e A Cláusula de Horn",
    "section": "8.2 O Prolog Entra em Cena",
    "text": "8.2 O Prolog Entra em Cena\nO Prolog é uma linguagem de programação lógica que utiliza Cláusulas de Horn para representar e manipular conhecimento. A sintaxe e a semântica do Prolog são diretamente mapeadas para Cláusulas de Horn:\n\nFatos: Em Prolog, fatos são representados como cláusulas sem antecedentes. Por exemplo, o fato John é humano pode ser representado como humano(john).\nRegras: As regras em Prolog são representadas como implicações, onde os antecedentes são literais negativos e o consequente é o literal positivo. Por exemplo, a regra Se X é humano, então X é mortal pode ser representada como mortal(X) :- humano(X).\nConsultas: As consultas em Prolog são feitas ao sistema para inferir informações com base nos fatos e regras definidos. Por exemplo, a consulta Quem é mortal? pode ser representada como ?- mortal(X).\n\nO Prolog utiliza um mecanismo de resolução baseado em Cláusulas de Horn para responder a consultas. Ele aplica uma técnica de busca em profundidade para encontrar uma substituição de variáveis que satisfaça a consulta.\n\n8.2.0.1 Exemplo 1: O mais simples possível\nFatos:\nhomem(joão).\nmulher(maria).\nOs fatos indicam que João é homem e maria é mulher.\nRegra:\nmortal(X) :- homem(X).\nA regra estabelece que Se \\(X\\) é homem, então \\(X\\) é mortal. O símbolo \\(:-\\) representa implicação.\nConsulta:\nmortal(joão).\nA consulta verifica se João é mortal, aplicando a regra definida anteriormente. O Prolog responderá True (verdadeiro ou \\(\\top\\)) pois a regra se aplica dado o fato de que João é homem.\n\n\n8.2.0.2 Exemplo 2: Sistema de Recomendação de Roupas em Prolog\nImagine que estamos construindo um sistema lógico simples em Prolog para recomendar o tipo de roupa que uma pessoa deve vestir com base no clima. Vamos usar Cláusulas de Horn para representar o conhecimento e a lógica do sistema.\nFatos: primeiro, estabelecemos os fatos, que são as verdades básicas sobre o mundo. Neste caso, os fatos podem ser informações sobre o clima atual.\n\nFato 1: está ensolarado.\n\n ensolarado.\n\nFato 2: a temperatura está acima de 20°C.\n\n temperatura_acima_de_20.\nRegras: em seguida, definimos as regras que descrevem como as coisas se relacionam. Essas regras nos dizem o tipo de roupa apropriada com base no clima.\n\nRegra 1: se está ensolarado e a temperatura está acima de 20°C, use óculos de sol.\n\n óculos_de_sol :- ensolarado, temperatura_acima_de_20.\n\nRegra 2: se está ensolarado, use chapéu.\n\n chapéu :- ensolarado.\n\nRegra 3: se a temperatura está acima de 20°C, use camiseta.\n\n camiseta :- temperatura_acima_de_20.\nAgora, podemos fazer consultas ao nosso sistema para obter recomendações de roupas.\n\nConsulta 1: está ensolarado e a temperatura está acima de 20°C. O que devo vestir?\n\n ?- óculos_de_sol, chapéu, camiseta.\n\n\n8.2.0.3 Exemplo 3: Torre de Hanói\nA Torre de Hanói é um quebra-cabeça matemático que consiste em três postes (vamos chamá-los de origem, destino e auxiliar) e um número N de discos de tamanhos variados.\nEstado Inicial: O quebra-cabeça começa com todos os N discos empilhados no poste de origem, em ordem decrescente de tamanho, com o maior disco na base e o menor no topo, formando uma estrutura cônica. Os postes de destino e auxiliar começam vazios.\nObjetivo: Mover a pilha inteira de discos do poste de origem para o poste de destino, seguindo um conjunto de regras simples.\nRegras: 1. Apenas um disco pode ser movido por vez. 2. Um movimento consiste em retirar o disco superior de um dos postes e colocá-lo no topo de outra pilha em outro poste. 3. Regra Fundamental: Um disco maior nunca pode ser colocado sobre um disco menor.\nO Desafio: Qual é a sequência de movimentos, e o número mínimo de passos, para transferir todos os discos do poste de origem para o de destino, obedecendo a todas as regras?\n% --- Solução Corrigida para a Torre de Hanói em Prolog ---\n\n% Este código resolve o problema da Torre de Hanói para N discos,\n% gerando a sequência de movimentos necessários.\n% Ele utiliza a clássica solução recursiva, que é um exemplo\n% canônico de programação em lógica e muito mais adequada que a\n% versão anterior, que tentava verificar estaticamente as regras.\n\n% -----------------------------------------------------------------\n% Predicado principal: hanoi/1\n%\n% Como usar:\n% hanoi(N). Onde N é o número de discos.\n% Exemplo: hanoi(3).\n%\n% Este predicado inicia o processo, definindo os postes de\n% origem (p1), destino (p3) e auxiliar (p2).\n% -----------------------------------------------------------------\n\nhanoi(N) :-\n    format('--- Solução para a Torre de Hanói com ~w discos ---~n', [N]),\n    mover(N, p1, p3, p2).\n\n% -----------------------------------------------------------------\n% Predicado recursivo: mover/4\n%\n% mover(NumDiscos, Origem, Destino, Auxiliar)\n%\n% Descreve como mover uma pilha de 'NumDiscos' de um poste de\n% 'Origem' para um poste de 'Destino', usando um poste 'Auxiliar'.\n% -----------------------------------------------------------------\n\n% --- Caso Base ---\n% Se há apenas 1 disco para mover, a solução é trivial:\n% mova o disco 1 da Origem para o Destino.\nmover(1, Origem, Destino, _) :-\n    format('Mova o disco 1 de ~w para ~w.~n', [Origem, Destino]).\n\n% --- Passo Recursivo ---\n% Para mover N discos (onde N &gt; 1):\n% 1. Mova N-1 discos da Origem para o poste Auxiliar.\n% 2. Mova o disco N (o maior, que sobrou na base) da Origem para o Destino.\n% 3. Mova os N-1 discos do poste Auxiliar para o Destino.\nmover(N, Origem, Destino, Auxiliar) :-\n    N &gt; 1,\n    M is N - 1,\n    mover(M, Origem, Auxiliar, Destino),\n    format('Mova o disco ~w de ~w para ~w.~n', [N, Origem, Destino]),\n    mover(M, Auxiliar, Destino, Origem).\n\n% --- Como Executar ---\n%\n% Para encontrar a solução para 3 discos, faça a seguinte consulta:\n%\n% ?- hanoi(3).\n%\n% --- Saída Esperada ---\n%\n% --- Solução para a Torre de Hanói com 3 discos ---\n% Mova o disco 1 de p1 para p3.\n% Mova o disco 2 de p1 para p2.\n% Mova o disco 1 de p3 para p2.\n% Mova o disco 3 de p1 para p3.\n% Mova o disco 1 de p2 para p1.\n% Mova o disco 2 de p2 para p3.\n% Mova o disco 1 de p1 para p3.\n% true.\n\n\n8.2.0.4 Exemplo 4: O Narrador é seu próprio avô\nO problema do narrador que é seu próprio avô é um exemplo clássico de raciocínio lógico e relações familiares. O problema envolve a construção de uma base de conhecimento que representa as relações familiares e a aplicação de regras lógicas para determinar se o narrador realmente é seu próprio avô. Este exemplo foi publicado por Niklaus Wirth em seu livro Algorithms + Data Structures = Programs 1 fazendo referência a um problema que havia sido publicado em um jornal de Zürich em 1922, que cito em tradução livre a seguir:\nCasei com uma viúva (vamos chamá-la de W) que tem uma filha adulta (chame-a de D). Meu pai (F), que nos visitava com bastante frequência, apaixonou-se pela minha enteada e casou-se com ela. Por isso, meu pai se tornou meu genro e minha enteada se tornou minha madrasta. Alguns meses depois, minha esposa deu à luz um filho (S1), que se tornou cunhado do meu pai, e meu tio. A esposa do meu pai, ou seja, minha enteada, também teve um filho (S2). Em outras palavras, para todos os efeitos, eu sou meu próprio avo.\nUsando este relato, podemos criar uma base de conhecimento em Prolog. A versão a seguir corrige a lógica do código original para modelar as relações com precisão e demonstrar os paradoxos descritos.\n% --- Fatos ---\n% Descrevem as pessoas, seus gêneros, casamentos e filhos diretos.\n\n% Gênero das pessoas\nhomem(narrador).\nhomem(pai_narrador).\nhomem(filho_narrador_s1).\nhomem(filho_pai_s2).\n\nmulher(esposa_w).\nmulher(enteada_d).\n\n% Casamentos\ncasado(narrador, esposa_w).\ncasado(pai_narrador, enteada_d).\n\n% Relações de parentesco (progenitor, filho)\nprogenitor(pai_narrador, narrador).\nprogenitor(esposa_w, enteada_d).\nprogenitor(narrador, filho_narrador_s1).\nprogenitor(esposa_w, filho_narrador_s1).\nprogenitor(pai_narrador, filho_pai_s2).\nprogenitor(enteada_d, filho_pai_s2).\n\n% --- Regras ---\n% Definem relações familiares complexas com base nos fatos.\n\n% Definições básicas\npai(Pai, Filho) :- homem(Pai), progenitor(Pai, Filho).\nmae(Mae, Filho) :- mulher(Mae), progenitor(Mae, Filho).\nesposa(Esposa, Marido) :- mulher(Esposa), casado(Marido, Esposa).\n\n% Regra para Madrasta: A esposa do seu pai.\nmadrasta(M, Pessoa) :-\n pai(Pai, Pessoa),\n esposa(M, Pai).\n\n% Regra para Enteada: A filha da sua esposa.\nenteada(E, Pessoa) :-\n esposa(Esposa, Pessoa),\n mae(Esposa, E).\n\n% Regra para Avô: O pai de um dos seus pais.\navo(Avo, Neto) :-\n pai(Avo, P),\n (pai(P, Neto) ; mae(P, Neto)).\n\n% Regra para Neto: O filho do seu filho/filha.\nneto(Neto, Avo) :-\n (pai(Avo, F) ; mae(Avo, F)),\n (pai(F, Neto) ; mae(F, Neto)).\n\n% Regra para Irmão (neste caso, meio-irmão): Compartilham o mesmo pai.\nirmao(Pessoa1, Pessoa2) :-\n pai(P, Pessoa1),\n pai(P, Pessoa2),\n Pessoa1 \\= Pessoa2.\n\n% Regra para Tio: O irmão de um dos seus pais (ou padrastos/madrastas).\ntio(Tio, Sobrinho) :-\n irmao(Tio, P),\n (pai(P, Sobrinho) ; mae(P, Sobrinho) ; madrasta(P, Sobrinho)).\n\n% --- Consultas Paradoxais ---\n% Agora podemos verificar as afirmações da história.\n\n% ?- enteada(enteada_d, narrador), madrasta(enteada_d, narrador).\n% Resposta: true.\n% (Minha enteada é minha madrasta?)\n\n% ?- irmao(filho_pai_s2, narrador).\n% Resposta: true.\n% (S2 é meu irmão?)\n\n% ?- neto(filho_pai_s2, narrador).\n% Resposta: true.\n% (S2 é meu neto? Sim, pois ele é filho da minha enteada).\n\n% ?- tio(filho_narrador_s1, narrador).\n% Resposta: true.\n% (Meu filho S1 é meu tio? Sim, pois ele é irmão da minha madrasta).\n\n% A consulta final \"avo(narrador, narrador)\" não pode ser provada com\n% definições lógicas padrão. O paradoxo reside no fato de que o narrador\n% ocupa múltiplos papéis conflitantes na estrutura familiar, como ser o\n% avô de seu próprio irmão (avo(narrador, filho_pai_s2)) e o pai de\n% seu próprio tio (pai(narrador, filho_narrador_s1)).",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Formas Clausais e A Cláusula de Horn</span>"
    ]
  },
  {
    "objectID": "06-clausulas-de-horn-e-prolog.html#footnotes",
    "href": "06-clausulas-de-horn-e-prolog.html#footnotes",
    "title": "8  Formas Clausais e A Cláusula de Horn",
    "section": "",
    "text": "WIRTH, Niklaus. Algorithms and Data Structures. [S.l.]: [s.n.], [s.d.]. Disponível em: https://cdn.preterhuman.net/texts/math/Data_StructureANDAlgorithms/Algorithms%20and%20Data%20Structures%20-%20Niklaus%20Wirth.pdf.↩︎",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Formas Clausais e A Cláusula de Horn</span>"
    ]
  },
  {
    "objectID": "07-construcao-de-mundos-logicos.html",
    "href": "07-construcao-de-mundos-logicos.html",
    "title": "9  Raciocínio Algorítmico: Criando Mundos",
    "section": "",
    "text": "9.0.1 Definição Formal de um Mundo\nNa Lógica de Primeira Ordem, um mundo ou modelo é uma estrutura que consiste em:\nUm modelo \\(M\\) para uma linguagem \\(L\\) é então definido como \\(M = (D, I)\\), sendo que \\(D\\) é o domínio e \\(I\\) é a interpretação.\nNeste exemplo, temos um modelo \\(M\\) no qual:\n\\[M = (\\{1, 2, 3, 4, 5\\}, I)\\]\ncom \\(I\\) definido como acima. Este modelo representa um mundo no qual podemos fazer afirmações sobre números inteiros de 1 a 5, suas relações de ordem e paridade.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Raciocínio Algorítmico: Criando Mundos</span>"
    ]
  },
  {
    "objectID": "07-construcao-de-mundos-logicos.html#footnotes",
    "href": "07-construcao-de-mundos-logicos.html#footnotes",
    "title": "9  Raciocínio Algorítmico: Criando Mundos",
    "section": "",
    "text": "GHIDINI, C., & Serafini, L. (2013-2014). Mathematical Logic Exercises. Disponível em: https://disi.unitn.it/~ldkr/ml2014/ExercisesBooklet.pdf.↩︎",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Raciocínio Algorítmico: Criando Mundos</span>"
    ]
  },
  {
    "objectID": "07a-criando-mundos-praticas.html",
    "href": "07a-criando-mundos-praticas.html",
    "title": "10  Criando Mundos: Raciocínio Lógico",
    "section": "",
    "text": "10.1 Problema 1: Sistema Inteligente de Recomendação de Roupas\nVocê foi contratado para desenvolver um sistema inteligente que recomenda roupas adequadas baseado nas condições climáticas e ocasiões especiais. O sistema deve ser capaz de sugerir peças de vestuário considerando múltiplos fatores ambientais e sociais.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Criando Mundos: Raciocínio Lógico</span>"
    ]
  },
  {
    "objectID": "07a-criando-mundos-praticas.html#problema-1-sistema-inteligente-de-recomendação-de-roupas",
    "href": "07a-criando-mundos-praticas.html#problema-1-sistema-inteligente-de-recomendação-de-roupas",
    "title": "10  Criando Mundos: Raciocínio Lógico",
    "section": "",
    "text": "10.1.1 Especificação do Domínio\n\n10.1.1.1 Predicados Base (Fatos)\nCondições Climáticas:\n\ntemperatura_alta - Temperatura acima de 25°C;\ntemperatura_media - Temperatura entre 15-25°C;\ntemperatura_baixa - Temperatura abaixo de 15°C;\nensolarado - Dia ensolarado;\nnublado - Dia nublado;\nchuvoso - Está chovendo;\nventoso - Vento forte;\numidade_alta - Umidade acima de 70%.\n\nOcasiões Especiais:\n\ntrabalho - Ambiente profissional;\ncasual - Situação informal;\nfesta - Evento social;\nexercicio - Atividade física;\npraia - Ambiente de praia.\n\n\n\n\n10.1.2 Tarefas a Implementar\n\n10.1.2.1 Parte A: Modelagem\n\nDeclare todos os fatos necessários para representar uma situação específica;\nImplemente todas as 15 regras como cláusulas de Horn em Prolog;\nAdicione pelo menos 3 regras criativas próprias.\n\n\n\n10.1.2.2 Parte B: Cenários de Teste\n\nCenário 1: Dia ensolarado, temperatura alta, ocasião casual;\nCenário 2: Dia chuvoso, temperatura baixa, trabalho;\nCenário 3: Dia nublado, temperatura média, festa;\nCenário 4: Dia ensolarado, temperatura alta, praia;\nCenário 5: Dia ventoso, temperatura baixa, exercício.\n\n\n\n10.1.2.3 Parte C: Consultas Avançadas\n\n“Que roupas devo usar hoje?” (listar todas as recomendações);\n“Preciso levar proteção?” (guarda-chuva, casaco, etc.);\n“Esta roupa é apropriada para a ocasião X?” (validação).\n\n\n\n\n10.1.3 Solução: Problema 1\n\n10.1.3.1 Solução em Lógica de Primeira Ordem\n\n10.1.3.1.1 Definição do Mundo (Universo de Discurso)\n\nConstantes de condições climáticas:\n\\[temperatura\\_alta, temperatura\\_media, temperatura\\_baixa, ensolarado, nublado, chuvoso, ventoso, umidade\\_alta\\]\nConstantes de ocasiões:\n\\[trabalho, casual, festa, exercicio, praia\\]\nConstantes de itens de vestuário:\n\\[oculos\\_sol, chapeu, guarda\\_chuva, capa\\_chuva, roupa\\_respiravel, camiseta, shorts, casaco, calca\\_longa, jaqueta\\_leve, casaco\\_pesado, roupa\\_formal, roupa\\_elegante, roupa\\_esportiva, biquini\\_sunga, protetor\\_solar, casaco\\_social, jeans, blusa\\]\nPredicados:\n\n\\(Clima(condicao)\\): A condição climática está ativa;\n\\(Ocasiao(tipo)\\): A ocasião atual é do tipo especificado;\n\\(Recomendar(item)\\): O item de vestuário é recomendado.\n\n\n\n\n\n10.1.3.2 Regras em Lógica de Primeira Ordem\nRegras de Proteção:\n\n\\(Clima(ensolarado) \\wedge Clima(temperatura\\_alta) \\rightarrow Recomendar(oculos\\_sol)\\);\n\\(Clima(ensolarado) \\rightarrow Recomendar(chapeu)\\);\n\\(Clima(chuvoso) \\rightarrow Recomendar(guarda\\_chuva) \\wedge Recomendar(capa\\_chuva)\\);\n\\(Clima(umidade\\_alta) \\wedge Clima(temperatura\\_alta) \\rightarrow Recomendar(roupa\\_respiravel)\\).\n\nRegras de Conforto Térmico:\n\n\\(Clima(temperatura\\_alta) \\rightarrow Recomendar(camiseta) \\wedge Recomendar(shorts)\\);\n\\(Clima(temperatura\\_baixa) \\rightarrow Recomendar(casaco) \\wedge Recomendar(calca\\_longa)\\);\n\\(Clima(temperatura\\_media) \\wedge Clima(ventoso) \\rightarrow Recomendar(jaqueta\\_leve)\\);\n\\(Clima(temperatura\\_baixa) \\wedge Clima(ventoso) \\rightarrow Recomendar(casaco\\_pesado)\\).\n\nRegras de Ocasião:\n\n\\(Ocasiao(trabalho) \\rightarrow Recomendar(roupa\\_formal)\\);\n\\(Ocasiao(festa) \\rightarrow Recomendar(roupa\\_elegante)\\);\n\\(Ocasiao(exercicio) \\rightarrow Recomendar(roupa\\_esportiva)\\);\n\\(Ocasiao(praia) \\wedge Clima(ensolarado) \\rightarrow Recomendar(biquini\\_sunga) \\wedge Recomendar(protetor\\_solar)\\).\n\nRegras Condicionais Complexas:\n\n\\(Ocasiao(trabalho) \\wedge Clima(chuvoso) \\rightarrow Recomendar(roupa\\_formal) \\wedge Recomendar(guarda\\_chuva)\\);\n\\(Ocasiao(festa) \\wedge Clima(temperatura\\_baixa) \\rightarrow Recomendar(roupa\\_elegante) \\wedge Recomendar(casaco\\_social)\\);\n\\(Ocasiao(casual) \\wedge Clima(temperatura\\_media) \\wedge Clima(nublado) \\rightarrow Recomendar(jeans) \\wedge Recomendar(blusa)\\).\n\n\n\n\n10.1.4 Regras Adicionais\n\n\\(Clima(umidade\\_alta) \\wedge Ocasiao(exercicio) \\rightarrow Recomendar(toalha) \\wedge Recomendar(garrafa\\_agua)\\);\n\\(Clima(temperatura\\_baixa) \\wedge Clima(chuvoso) \\rightarrow Recomendar(bota\\_impermeavel)\\);\n\\(Ocasiao(festa) \\wedge Clima(ensolarado) \\wedge Clima(temperatura\\_alta) \\rightarrow Recomendar(roupa\\_leve\\_elegante)\\).\n\n\n\n10.1.5 Solução em Prolog\n% --- FATOS (Condições do Dia) ---\n% Para testar diferentes cenários, ative/desative os fatos apropriados\n\n% Cenário 1: Dia ensolarado, temperatura alta, ocasião casual\n% clima(ensolarado).\n% clima(temperatura_alta).\n% ocasiao(casual).\n\n% --- REGRAS DE RECOMENDAÇÃO ---\n\n% Regras de Proteção\nrecomendar(oculos_sol) :- \n    clima(ensolarado), \n    clima(temperatura_alta).\n\nrecomendar(chapeu) :- \n    clima(ensolarado).\n\nrecomendar(guarda_chuva) :- \n    clima(chuvoso).\n\nrecomendar(capa_chuva) :- \n    clima(chuvoso).\n\nrecomendar(roupa_respiravel) :- \n    clima(umidade_alta), \n    clima(temperatura_alta).\n\n% Regras de Conforto Térmico\nrecomendar(camiseta) :- \n    clima(temperatura_alta).\n\nrecomendar(shorts) :- \n    clima(temperatura_alta).\n\nrecomendar(casaco) :- \n    clima(temperatura_baixa).\n\nrecomendar(calca_longa) :- \n    clima(temperatura_baixa).\n\nrecomendar(jaqueta_leve) :- \n    clima(temperatura_media), \n    clima(ventoso).\n\nrecomendar(casaco_pesado) :- \n    clima(temperatura_baixa), \n    clima(ventoso).\n\n% Regras de Ocasião\nrecomendar(roupa_formal) :- \n    ocasiao(trabalho).\n\nrecomendar(roupa_elegante) :- \n    ocasiao(festa).\n\nrecomendar(roupa_esportiva) :- \n    ocasiao(exercicio).\n\nrecomendar(biquini_sunga) :- \n    ocasiao(praia), \n    clima(ensolarado).\n\nrecomendar(protetor_solar) :- \n    ocasiao(praia), \n    clima(ensolarado).\n\n% Regras Condicionais Complexas\nrecomendar(roupa_formal) :- \n    ocasiao(trabalho), \n    clima(chuvoso).\n\nrecomendar(guarda_chuva) :- \n    ocasiao(trabalho), \n    clima(chuvoso).\n\nrecomendar(roupa_elegante) :- \n    ocasiao(festa), \n    clima(temperatura_baixa).\n\nrecomendar(casaco_social) :- \n    ocasiao(festa), \n    clima(temperatura_baixa).\n\nrecomendar(jeans) :- \n    ocasiao(casual), \n    clima(temperatura_media), \n    clima(nublado).\n\nrecomendar(blusa) :- \n    ocasiao(casual), \n    clima(temperatura_media), \n    clima(nublado).\n\n% Regras Criativas Adicionais\nrecomendar(toalha) :- \n    clima(umidade_alta), \n    ocasiao(exercicio).\n\nrecomendar(garrafa_agua) :- \n    clima(umidade_alta), \n    ocasiao(exercicio).\n\nrecomendar(bota_impermeavel) :- \n    clima(temperatura_baixa), \n    clima(chuvoso).\n\nrecomendar(roupa_leve_elegante) :- \n    ocasiao(festa), \n    clima(ensolarado), \n    clima(temperatura_alta).\n\n% --- PREDICADOS DE CONSULTA ---\n\n% Listar todas as recomendações\ntodas_recomendacoes(Lista) :- \n    findall(Item, recomendar(Item), ListaDup),\n    list_to_set(ListaDup, Lista).\n\n% Verificar se precisa de proteção\nprecisa_protecao :- \n    (recomendar(guarda_chuva); \n     recomendar(casaco); \n     recomendar(casaco_pesado); \n     recomendar(capa_chuva); \n     recomendar(chapeu); \n     recomendar(oculos_sol)).\n\n% Validar se uma roupa é apropriada\nroupa_apropriada(Roupa) :- \n    recomendar(Roupa).\n\n% Categorizar tipo de proteção necessária\ntipo_protecao(chuva) :- \n    recomendar(guarda_chuva).\n\ntipo_protecao(frio) :- \n    recomendar(casaco).\n\ntipo_protecao(sol) :- \n    recomendar(chapeu).\n\n% Cenários de Teste\n\n% --- CENÁRIO 1: Dia ensolarado, temperatura alta, ocasião casual ---\n% Fatos:\n%clima(ensolarado).\n%clima(temperatura_alta).\n%ocasiao(casual).\n\n% Consulta:\n%?- todas_recomendacoes(Lista).\n% Resposta esperada: Lista = [oculos_sol, chapeu, camiseta, shorts]\n\n% --- CENÁRIO 2: Dia chuvoso, temperatura baixa, trabalho ---\n% Fatos:\n%clima(chuvoso).\n%clima(temperatura_baixa).\n%ocasiao(trabalho).\n\n% Consulta:\n%?- todas_recomendacoes(Lista).\n% Resposta esperada: Lista = [guarda_chuva, capa_chuva, casaco, calca_longa, roupa_formal, bota_impermeavel]\n\n% --- CENÁRIO 3: Dia nublado, temperatura média, festa ---\n% Fatos:\n%clima(nublado).\n%clima(temperatura_media).\n%ocasiao(festa).\n\n% Consulta:\n%?- todas_recomendacoes(Lista).\n% Resposta esperada: Lista = [roupa_elegante]\n\n% --- CENÁRIO 4: Dia ensolarado, temperatura alta, praia ---\n% Fatos:\n%clima(ensolarado).\n%clima(temperatura_alta).\n%ocasiao(praia).\n\n% Consulta:\n%?- todas_recomendacoes(Lista).\n% Resposta esperada: Lista = [oculos_sol, chapeu, camiseta, shorts, biquini_sunga, protetor_solar]\n\n% --- CENÁRIO 5: Dia ventoso, temperatura baixa, exercício ---\n% Fatos:\n%clima(ventoso).\n%clima(temperatura_baixa).\n%ocasiao(exercicio).\n\n% Consulta:\n%?- todas_recomendacoes(Lista).\n% Resposta esperada: Lista = [casaco, calca_longa, casaco_pesado, roupa_esportiva]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Criando Mundos: Raciocínio Lógico</span>"
    ]
  },
  {
    "objectID": "07a-criando-mundos-praticas.html#problema-2-sistema-de-triagem-médica-automatizada",
    "href": "07a-criando-mundos-praticas.html#problema-2-sistema-de-triagem-médica-automatizada",
    "title": "10  Criando Mundos: Raciocínio Lógico",
    "section": "10.2 Problema 2: Sistema de Triagem Médica Automatizada",
    "text": "10.2 Problema 2: Sistema de Triagem Médica Automatizada\nUm posto de saúde precisa de um sistema de triagem automática que classifique a urgência dos pacientes baseado em sintomas, histórico e fatores de risco. O sistema deve seguir protocolos médicos simplificados para determinar prioridades de atendimento.\n\n10.2.1 Especificação do Domínio\n\n10.2.1.1 Predicados Base (Sintomas e Condições)\nSintomas Básicos:\n\nfebre(Paciente) - Temperatura corporal elevada;\ntosse(Paciente) - Tosse presente;\ndor_cabeca(Paciente) - Dor de cabeça;\ndor_peito(Paciente) - Dor no peito;\nfalta_ar(Paciente) - Dificuldade respiratória;\nnausea(Paciente) - Náusea ou vômito;\ndor_abdominal(Paciente) - Dor abdominal;\ntontura(Paciente) - Tontura ou vertigem.\n\nHistórico e Fatores de Risco:\n\nidade_avancada(Paciente) - Acima de 65 anos;\ndiabetico(Paciente) - Possui diabetes;\nhipertenso(Paciente) - Possui hipertensão;\ncardiopata(Paciente) - Problemas cardíacos;\nviagem_recente(Paciente) - Viajou nos últimos 14 dias;\ncontato_doente(Paciente) - Contato com pessoa doente;\nvacinado_gripe(Paciente) - Vacinado contra gripe;\ngravidez(Paciente) - Mulher grávida.\n\n\n\n\n10.2.2 Tarefas a Implementar\n\n10.2.2.1 Parte A: Base de Conhecimento\n\nCrie uma base de dados com pelo menos \\(8\\) pacientes fictícios;\nImplemente todas as \\(17\\) regras como cláusulas de Horn;\nAdicione \\(5\\) regras próprias baseadas em conhecimento médico básico.\n\n\n\n10.2.2.2 Parte B: Casos de Teste\n\nCaso 1: João, 70 anos, diabético, com febre, tosse e falta de ar;\nCaso 2: Maria, 30 anos, grávida, com dor de cabeça e náusea;\nCaso 3: Pedro, 45 anos, cardiopata, com dor no peito e tontura;\nCaso 4: Ana, 25 anos, saudável, viajou recentemente, com febre e tosse;\nCaso 5: Carlos, 60 anos, hipertenso, apenas com dor de cabeça leve.\n\n\n\n10.2.2.3 Parte C: Sistema de Consultas\n\n“Qual a prioridade do paciente X?”;\n“Quais pacientes precisam de atendimento urgente?”;\n“Que cuidados especiais o paciente X requer?”;\n“Quantos pacientes estão em cada categoria de prioridade?”.\n\n\n\n\n10.2.3 Solução: Problema 2\n\n10.2.3.1 Solução em Lógica de Primeira Ordem\n\n10.2.3.1.1 Definição do Mundo (Universo de Discurso)\n\nConstantes de pacientes:\n\\[joao, maria, pedro, ana, carlos, beatriz, diego, fernanda\\]\nConstantes de prioridades:\n\\[urgente, prioridade\\_alta, prioridade\\_media, prioridade\\_baixa\\]\nConstantes de ações:\n\\[emergencia, monitorar\\_pressao, verificar\\_glicemia, isolamento\\_preventivo\\]\nPredicados:\n\nSintomas: \\(Febre(p)\\), \\(Tosse(p)\\), \\(DorCabeca(p)\\), \\(DorPeito(p)\\), \\(FaltaAr(p)\\), \\(Nausea(p)\\), \\(DorAbdominal(p)\\), \\(Tontura(p)\\);\nFatores: \\(IdadeAvancada(p)\\), \\(Diabetico(p)\\), \\(Hipertenso(p)\\), \\(Cardiopata(p)\\), \\(ViagemRecente(p)\\), \\(ContatoDoente(p)\\), \\(VacinadoGripe(p)\\), \\(Gravidez(p)\\);\nClassificação: \\(Prioridade(p, nivel)\\);\nAções: \\(Encaminhar(p, destino)\\), \\(CuidadoEspecial(p, tipo)\\).\n\n\n\n\n10.2.3.1.2 Regras em Lógica de Primeira Ordem\nPrioridade URGENTE:\n\n\\(DorPeito(p) \\wedge FaltaAr(p) \\rightarrow Prioridade(p, urgente)\\);\n\\(Febre(p) \\wedge FaltaAr(p) \\wedge IdadeAvancada(p) \\rightarrow Prioridade(p, urgente)\\);\n\\(DorAbdominal(p) \\wedge Nausea(p) \\rightarrow Prioridade(p, urgente)\\);\n\\(Tontura(p) \\wedge DorPeito(p) \\wedge Cardiopata(p) \\rightarrow Prioridade(p, urgente)\\).\n\nPrioridade ALTA:\n\n\\(Febre(p) \\wedge Tosse(p) \\wedge ViagemRecente(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(Febre(p) \\wedge DorCabeca(p) \\wedge ContatoDoente(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(FaltaAr(p) \\wedge Diabetico(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(\\exists s(Sintoma(p, s)) \\wedge Gravidez(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\).\n\nPrioridade MÉDIA:\n\n\\(Febre(p) \\wedge Tosse(p) \\wedge VacinadoGripe(p) \\rightarrow Prioridade(p, prioridade\\_media)\\);\n\\(DorCabeca(p) \\wedge Nausea(p) \\wedge \\neg (\\exists s(OutroSintoma(p, s))) \\rightarrow Prioridade(p, prioridade\\_media)\\);\n\\(Tosse(p) \\wedge \\neg Febre(p) \\wedge IdadeAvancada(p) \\rightarrow Prioridade(p, prioridade\\_media)\\).\n\nPrioridade BAIXA:\n\n\\(DorCabeca(p) \\wedge \\neg (\\exists f(FatorRisco(p, f))) \\rightarrow Prioridade(p, prioridade\\_baixa)\\);\n\\(Tosse(p) \\wedge \\neg IdadeAvancada(p) \\wedge \\neg (\\exists f(FatorRisco(p, f))) \\rightarrow Prioridade(p, prioridade\\_baixa)\\).\n\nRegras de Recomendação:\n\n\\(Prioridade(p, urgente) \\rightarrow Encaminhar(p, emergencia)\\);\n\\(Prioridade(p, prioridade\\_alta) \\wedge Hipertenso(p) \\rightarrow CuidadoEspecial(p, monitorar\\_pressao)\\);\n\\(∀nivel(Prioridade(p, nivel) \\wedge Diabetico(p) \\rightarrow CuidadoEspecial(p, verificar\\_glicemia))\\);\n\\((Tosse(p) ∨ FaltaAr(p) ∨ Febre(p)) \\rightarrow CuidadoEspecial(p, isolamento\\_preventivo)\\).\n\n\n\n\n10.2.3.2 Regras Adicionais\n\n\\(Febre(p) \\wedge Tosse(p) \\wedge FaltaAr(p) \\rightarrow Prioridade(p, urgente) \\wedge CuidadoEspecial(p, oxigenio)\\);\n\\(DorAbdominal(p) \\wedge Gravidez(p) \\rightarrow Prioridade(p, urgente) \\wedge Encaminhar(p, obstetricia)\\);\n\\(Tontura(p) \\wedge Hipertenso(p) \\rightarrow CuidadoEspecial(p, monitorar\\_pressao\\_imediato)\\);\n\\(IdadeAvancada(p) \\wedge Cardiopata(p) \\wedge \\exists s(Sintoma(p, s)) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(ViagemRecente(p) \\wedge Febre(p) \\rightarrow CuidadoEspecial(p, exame\\_covid)\\).\n\n\n\n\n10.2.4 Solução em Prolog\n% ========================================\n% FATOS (Base de Dados de Pacientes)\n% ========================================\n\n% Caso 1: João, 70 anos, diabético, com febre, tosse e falta de ar\nidade_avancada(joao).\ndiabetico(joao).\nfebre(joao).\ntosse(joao).\nfalta_ar(joao).\n\n% Caso 2: Maria, 30 anos, grávida, com dor de cabeça e náusea\ngravidez(maria).\ndor_cabeca(maria).\nnausea(maria).\n\n% Caso 3: Pedro, 45 anos, cardiopata, com dor no peito e tontura\ncardiopata(pedro).\ndor_peito(pedro).\ntontura(pedro).\n\n% Caso 4: Ana, 25 anos, saudável, viajou recentemente, com febre e tosse\nviagem_recente(ana).\nfebre(ana).\ntosse(ana).\n\n% Caso 5: Carlos, 60 anos, hipertenso, apenas com dor de cabeça leve\nhipertenso(carlos).\ndor_cabeca(carlos).\n\n% Pacientes adicionais para completar a base\n% Caso 6: Beatriz, 35 anos, com tosse leve, vacinada contra gripe\nvacinado_gripe(beatriz).\ntosse(beatriz).\n\n% Caso 7: Diego, 72 anos, diabético e hipertenso, com tontura\nidade_avancada(diego).\ndiabetico(diego).\nhipertenso(diego).\ntontura(diego).\n\n% Caso 8: Fernanda, 28 anos, teve contato com pessoa doente, febre e dor de cabeça\ncontato_doente(fernanda).\nfebre(fernanda).\ndor_cabeca(fernanda).\n\n% ========================================\n% REGRAS DE TRIAGEM\n% ========================================\n\n% Prioridade URGENTE\nprioridade(Paciente, urgente) :-\n    dor_peito(Paciente),\n    falta_ar(Paciente).\n\nprioridade(Paciente, urgente) :-\n    febre(Paciente),\n    falta_ar(Paciente),\n    idade_avancada(Paciente).\n\nprioridade(Paciente, urgente) :-\n    dor_abdominal(Paciente),\n    nausea(Paciente).\n\nprioridade(Paciente, urgente) :-\n    tontura(Paciente),\n    dor_peito(Paciente),\n    cardiopata(Paciente).\n\n% Prioridade ALTA\nprioridade(Paciente, prioridade_alta) :-\n    febre(Paciente),\n    tosse(Paciente),\n    viagem_recente(Paciente),\n    \\+ prioridade(Paciente, urgente).\n\nprioridade(Paciente, prioridade_alta) :-\n    febre(Paciente),\n    dor_cabeca(Paciente),\n    contato_doente(Paciente),\n    \\+ prioridade(Paciente, urgente).\n\nprioridade(Paciente, prioridade_alta) :-\n    falta_ar(Paciente),\n    diabetico(Paciente),\n    \\+ prioridade(Paciente, urgente).\n\nprioridade(Paciente, prioridade_alta) :-\n    tem_sintoma(Paciente),\n    gravidez(Paciente),\n    \\+ prioridade(Paciente, urgente).\n\n% Prioridade MÉDIA\nprioridade(Paciente, prioridade_media) :-\n    febre(Paciente),\n    tosse(Paciente),\n    vacinado_gripe(Paciente),\n    \\+ prioridade(Paciente, urgente),\n    \\+ prioridade(Paciente, prioridade_alta).\n\nprioridade(Paciente, prioridade_media) :-\n    dor_cabeca(Paciente),\n    nausea(Paciente),\n    \\+ tem_outros_sintomas_graves(Paciente),\n    \\+ prioridade(Paciente, urgente),\n    \\+ prioridade(Paciente, prioridade_alta).\n\nprioridade(Paciente, prioridade_media) :-\n    tosse(Paciente),\n    \\+ febre(Paciente),\n    idade_avancada(Paciente),\n    \\+ prioridade(Paciente, urgente),\n    \\+ prioridade(Paciente, prioridade_alta).\n\n% Prioridade BAIXA\nprioridade(Paciente, prioridade_baixa) :-\n    dor_cabeca(Paciente),\n    \\+ tem_fator_risco(Paciente),\n    \\+ prioridade(Paciente, urgente),\n    \\+ prioridade(Paciente, prioridade_alta),\n    \\+ prioridade(Paciente, prioridade_media).\n\nprioridade(Paciente, prioridade_baixa) :-\n    tosse(Paciente),\n    \\+ idade_avancada(Paciente),\n    \\+ tem_fator_risco(Paciente),\n    \\+ prioridade(Paciente, urgente),\n    \\+ prioridade(Paciente, prioridade_alta),\n    \\+ prioridade(Paciente, prioridade_media).\n\n% Regras de Recomendação\nencaminhar(Paciente, emergencia) :-\n    prioridade(Paciente, urgente).\n\ncuidado_especial(Paciente, monitorar_pressao) :-\n    prioridade(Paciente, prioridade_alta),\n    hipertenso(Paciente).\n\ncuidado_especial(Paciente, verificar_glicemia) :-\n    diabetico(Paciente).\n\ncuidado_especial(Paciente, isolamento_preventivo) :-\n    tem_sintomas_respiratorios(Paciente).\n\n% Regras Adicionais Criadas\nprioridade(Paciente, urgente) :-\n    febre(Paciente),\n    tosse(Paciente),\n    falta_ar(Paciente).\n\ncuidado_especial(Paciente, oxigenio) :-\n    febre(Paciente),\n    tosse(Paciente),\n    falta_ar(Paciente).\n\nprioridade(Paciente, urgente) :-\n    dor_abdominal(Paciente),\n    gravidez(Paciente).\n\nencaminhar(Paciente, obstetricia) :-\n    dor_abdominal(Paciente),\n    gravidez(Paciente).\n\ncuidado_especial(Paciente, monitorar_pressao_imediato) :-\n    tontura(Paciente),\n    hipertenso(Paciente).\n\nprioridade(Paciente, prioridade_alta) :-\n    idade_avancada(Paciente),\n    cardiopata(Paciente),\n    tem_sintoma(Paciente),\n    \\+ prioridade(Paciente, urgente).\n\ncuidado_especial(Paciente, exame_covid) :-\n    viagem_recente(Paciente),\n    febre(Paciente).\n\n% ========================================\n% PREDICADOS AUXILIARES\n% ========================================\n\n% Verifica se paciente tem algum sintoma\ntem_sintoma(Paciente) :-\n    (febre(Paciente); tosse(Paciente); dor_cabeca(Paciente); \n     dor_peito(Paciente); falta_ar(Paciente); nausea(Paciente); \n     dor_abdominal(Paciente); tontura(Paciente)).\n\n% Verifica se tem fatores de risco\ntem_fator_risco(Paciente) :-\n    (idade_avancada(Paciente); diabetico(Paciente); hipertenso(Paciente); \n     cardiopata(Paciente); gravidez(Paciente)).\n\n% Verifica sintomas respiratórios\ntem_sintomas_respiratorios(Paciente) :-\n    (tosse(Paciente); falta_ar(Paciente); febre(Paciente)).\n\n% Verifica outros sintomas graves além de dor de cabeça e náusea\ntem_outros_sintomas_graves(Paciente) :-\n    (dor_peito(Paciente); falta_ar(Paciente); dor_abdominal(Paciente); \n     tontura(Paciente); febre(Paciente); tosse(Paciente)).\n\n% ========================================\n% CONSULTAS E TESTES\n% ========================================\n\n% Consulta 1: Qual a prioridade do paciente X?\nconsultar_prioridade(Paciente, Prioridade) :-\n    prioridade(Paciente, Prioridade).\n\n% Consulta 2: Quais pacientes precisam de atendimento urgente?\npacientes_urgentes(ListaPacientes) :-\n    findall(Paciente, prioridade(Paciente, urgente), ListaPacientes).\n\n% Consulta 3: Que cuidados especiais o paciente X requer?\ncuidados_necessarios(Paciente, ListaCuidados) :-\n    findall(Cuidado, cuidado_especial(Paciente, Cuidado), ListaCuidados).\n\n% Consulta 4: Quantos pacientes estão em cada categoria de prioridade?\ncontar_prioridades(urgente, Quantidade) :-\n    findall(P, prioridade(P, urgente), Lista),\n    length(Lista, Quantidade).\n\ncontar_prioridades(prioridade_alta, Quantidade) :-\n    findall(P, prioridade(P, prioridade_alta), Lista),\n    length(Lista, Quantidade).\n\ncontar_prioridades(prioridade_media, Quantidade) :-\n    findall(P, prioridade(P, prioridade_media), Lista),\n    length(Lista, Quantidade).\n\ncontar_prioridades(prioridade_baixa, Quantidade) :-\n    findall(P, prioridade(P, prioridade_baixa), Lista),\n    length(Lista, Quantidade).\n\n% Relatório completo de um paciente\nrelatorio_paciente(Paciente) :-\n    write('=== RELATÓRIO DO PACIENTE: '), write(Paciente), write(' ==='), nl,\n    (prioridade(Paciente, P) -&gt; \n        write('Prioridade: '), write(P), nl\n    ; \n        write('Prioridade: não classificada'), nl),\n    write('Cuidados especiais necessários:'), nl,\n    forall(cuidado_especial(Paciente, C), \n           (write('  - '), write(C), nl)),\n    (encaminhar(Paciente, Destino) -&gt; \n        write('Encaminhamento: '), write(Destino), nl\n    ; \n        true),\n    nl.\n\n% --- TESTES DOS CASOS ---\n\n% Caso 1: João\n% ?- consultar_prioridade(joao, Prioridade).\n% Resposta esperada: Prioridade = urgente (febre + falta_ar + idade_avançada)\n\n% ?- cuidados_necessarios(joao, Cuidados).\n% Resposta esperada: Cuidados = [verificar_glicemia, isolamento_preventivo, oxigenio]\n\n% Caso 2: Maria\n% ?- consultar_prioridade(maria, Prioridade).\n% Resposta esperada: Prioridade = prioridade_alta (gravidez + sintomas)\n\n% ?- cuidados_necessarios(maria, Cuidados).\n% Resposta esperada: Cuidados = []\n\n% Caso 3: Pedro\n% ?- consultar_prioridade(pedro, Prioridade).\n% Resposta esperada: Prioridade = urgente (tontura + dor_peito + cardiopata)\n\n% ?- encaminhar(pedro, Destino).\n% Resposta esperada: Destino = emergencia\n\n% Caso 4: Ana\n% ?- consultar_prioridade(ana, Prioridade).\n% Resposta esperada: Prioridade = prioridade_alta (febre + tosse + viagem_recente)\n\n% ?- cuidados_necessarios(ana, Cuidados).\n% Resposta esperada: Cuidados = [isolamento_preventivo, exame_covid]\n\n% Caso 5: Carlos\n% ?- consultar_prioridade(carlos, Prioridade).\n% Resposta esperada: Prioridade = prioridade_baixa (apenas dor de cabeça, hipertenso não ativado)\n\n% Consultas Gerais\n% ?- pacientes_urgentes(Lista).\n% Resposta esperada: Lista = [joao, pedro]\n\n% ?- contar_prioridades(urgente, N).\n% Resposta esperada: N = 2\n\n?- relatorio_paciente(joao).\n% Saída esperada: Relatório completo com prioridade urgente, \n% cuidados especiais e encaminhamento para emergência",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Criando Mundos: Raciocínio Lógico</span>"
    ]
  },
  {
    "objectID": "07a-criando-mundos-praticas.html#problema-2-melhor-sistema-de-triagem-médica-automatizada",
    "href": "07a-criando-mundos-praticas.html#problema-2-melhor-sistema-de-triagem-médica-automatizada",
    "title": "10  Criando Mundos: Raciocínio Lógico",
    "section": "10.3 Problema 2 Melhor: Sistema de Triagem Médica Automatizada",
    "text": "10.3 Problema 2 Melhor: Sistema de Triagem Médica Automatizada\nUm posto de saúde precisa de um sistema de triagem automática que classifique a urgência dos pacientes baseado em sintomas, histórico e fatores de risco. O sistema deve seguir protocolos médicos simplificados para determinar prioridades de atendimento.\n\n10.3.1 Especificação do Domínio\n\n10.3.1.1 Predicados Base (Sintomas e Condições)\nSintomas Básicos:\n\nfebre(Paciente) - Temperatura corporal elevada;\ntosse(Paciente) - Tosse presente;\ndor_cabeca(Paciente) - Dor de cabeça;\ndor_peito(Paciente) - Dor no peito;\nfalta_ar(Paciente) - Dificuldade respiratória;\nnausea(Paciente) - Náusea ou vômito;\ndor_abdominal(Paciente) - Dor abdominal;\ntontura(Paciente) - Tontura ou vertigem.\n\nHistórico e Fatores de Risco:\n\nidade_avancada(Paciente) - Acima de 65 anos;\ndiabetico(Paciente) - Possui diabetes;\nhipertenso(Paciente) - Possui hipertensão;\ncardiopata(Paciente) - Problemas cardíacos;\nviagem_recente(Paciente) - Viajou nos últimos 14 dias;\ncontato_doente(Paciente) - Contato com pessoa doente;\nvacinado_gripe(Paciente) - Vacinado contra gripe;\ngravidez(Paciente) - Mulher grávida.\n\n\n\n\n10.3.2 Tarefas a Implementar\n\n10.3.2.1 Parte A: Base de Conhecimento\n\nCrie uma base de dados com pelo menos \\(8\\) pacientes fictícios;\nImplemente todas as \\(17\\) regras como cláusulas de Horn;\nAdicione \\(5\\) regras próprias baseadas em conhecimento médico básico.\n\n\n\n10.3.2.2 Parte B: Casos de Teste\n\nCaso 1: João, 70 anos, diabético, com febre, tosse e falta de ar;\nCaso 2: Maria, 30 anos, grávida, com dor de cabeça e náusea;\nCaso 3: Pedro, 45 anos, cardiopata, com dor no peito e tontura;\nCaso 4: Ana, 25 anos, saudável, viajou recentemente, com febre e tosse;\nCaso 5: Carlos, 60 anos, hipertenso, apenas com dor de cabeça leve.\n\n\n\n10.3.2.3 Parte C: Sistema de Consultas\n\n“Qual a prioridade do paciente X?”;\n“Quais pacientes precisam de atendimento urgente?”;\n“Que cuidados especiais o paciente X requer?”;\n“Quantos pacientes estão em cada categoria de prioridade?”.\n\n\n\n\n10.3.3 Resolução do Problema 2 Melhor: Sistema de Triagem Médica\nEsta solução demonstra que é possível implementar sistemas complexos de regras em Prolog sem recorrer a negações explícitas, mantendo a expressividade e melhorando a clareza do código. A abordagem resulta em um sistema mais robusto e eficiente para triagem médica automatizada.\n\n10.3.3.1 Solução em Lógica de Primeira Ordem\n\n10.3.3.1.1 Definição do Mundo (Universo de Discurso)\n\nConstantes de pacientes: \\[joao, maria, pedro, ana, carlos, beatriz, diego, fernanda\\]\nConstantes de prioridades: \\[urgente, prioridade\\_alta, prioridade\\_media, prioridade\\_baixa\\]\nConstantes de ações: \\[emergencia, monitorar\\_pressao, verificar\\_glicemia, isolamento\\_preventivo, oxigenio, obstetricia, monitorar\\_pressao\\_imediato, exame\\_covid\\]\nPredicados:\n\nSintomas: \\(Febre(p)\\), \\(Tosse(p)\\), \\(DorCabeca(p)\\), \\(DorPeito(p)\\), \\(FaltaAr(p)\\), \\(Nausea(p)\\), \\(DorAbdominal(p)\\), \\(Tontura(p)\\);\nFatores: \\(IdadeAvancada(p)\\), \\(Diabetico(p)\\), \\(Hipertenso(p)\\), \\(Cardiopata(p)\\), \\(ViagemRecente(p)\\), \\(ContatoDoente(p)\\), \\(VacinadoGripe(p)\\), \\(Gravidez(p)\\);\nClassificação: \\(Prioridade(p, nivel)\\);\nAções: \\(Encaminhar(p, destino)\\), \\(CuidadoEspecial(p, tipo)\\);\nAuxiliares: \\(SemFebre(p)\\), \\(SemFatorRisco(p)\\), \\(Jovem(p)\\), \\(ApenasSintomasLeves(p)\\).\n\n\n\n\n10.3.3.1.2 Regras em Lógica de Primeira Ordem\nPrioridade URGENTE:\n\n\\(DorPeito(p) \\wedge FaltaAr(p) \\rightarrow Prioridade(p, urgente)\\);\n\\(Febre(p) \\wedge FaltaAr(p) \\wedge IdadeAvancada(p) \\rightarrow Prioridade(p, urgente)\\);\n\\(DorAbdominal(p) \\wedge Nausea(p) \\rightarrow Prioridade(p, urgente)\\);\n\\(Tontura(p) \\wedge DorPeito(p) \\wedge Cardiopata(p) \\rightarrow Prioridade(p, urgente)\\).\n\nPrioridade ALTA:\n\n\\(Febre(p) \\wedge Tosse(p) \\wedge ViagemRecente(p) \\wedge SemUrgencia(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(Febre(p) \\wedge DorCabeca(p) \\wedge ContatoDoente(p) \\wedge SemUrgencia(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(FaltaAr(p) \\wedge Diabetico(p) \\wedge SemUrgencia(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(TemSintoma(p) \\wedge Gravidez(p) \\wedge SemUrgencia(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\).\n\nPrioridade MÉDIA:\n\n\\(Febre(p) \\wedge Tosse(p) \\wedge VacinadoGripe(p) \\wedge SemPrioridadeSuper(p) \\rightarrow Prioridade(p, prioridade\\_media)\\);\n\\(DorCabeca(p) \\wedge Nausea(p) \\wedge ApenasSintomasLeves(p) \\wedge SemPrioridadeSuper(p) \\rightarrow Prioridade(p, prioridade\\_media)\\);\n\\(Tosse(p) \\wedge SemFebre(p) \\wedge IdadeAvancada(p) \\wedge SemPrioridadeSuper(p) \\rightarrow Prioridade(p, prioridade\\_media)\\).\n\nPrioridade BAIXA:\n\n\\(DorCabeca(p) \\wedge SemFatorRisco(p) \\wedge SemPrioridadeElevada(p) \\rightarrow Prioridade(p, prioridade\\_baixa)\\);\n\\(Tosse(p) \\wedge Jovem(p) \\wedge SemFatorRisco(p) \\wedge SemPrioridadeElevada(p) \\rightarrow Prioridade(p, prioridade\\_baixa)\\).\n\nRegras de Recomendação:\n\n\\(Prioridade(p, urgente) \\rightarrow Encaminhar(p, emergencia)\\);\n\\(Prioridade(p, prioridade\\_alta) \\wedge Hipertenso(p) \\rightarrow CuidadoEspecial(p, monitorar\\_pressao)\\);\n\\(\\forall nivel(Prioridade(p, nivel) \\wedge Diabetico(p) \\rightarrow CuidadoEspecial(p, verificar\\_glicemia))\\);\n\\((Tosse(p) \\vee FaltaAr(p) \\vee Febre(p)) \\rightarrow CuidadoEspecial(p, isolamento\\_preventivo)\\).\n\n\n\n10.3.3.1.3 Regras Adicionais\n\n\\(Febre(p) \\wedge Tosse(p) \\wedge FaltaAr(p) \\rightarrow Prioridade(p, urgente) \\wedge CuidadoEspecial(p, oxigenio)\\);\n\\(DorAbdominal(p) \\wedge Gravidez(p) \\rightarrow Prioridade(p, urgente) \\wedge Encaminhar(p, obstetricia)\\);\n\\(Tontura(p) \\wedge Hipertenso(p) \\rightarrow CuidadoEspecial(p, monitorar\\_pressao\\_imediato)\\);\n\\(IdadeAvancada(p) \\wedge Cardiopata(p) \\wedge TemSintoma(p) \\wedge SemUrgencia(p) \\rightarrow Prioridade(p, prioridade\\_alta)\\);\n\\(ViagemRecente(p) \\wedge Febre(p) \\rightarrow CuidadoEspecial(p, exame\\_covid)\\).\n\n\n\n\n\n10.3.4 Solução em Prolog\n% ========================================\n% FATOS (Base de Dados de Pacientes)\n% ========================================\n\n% Caso 1: João, 70 anos, diabético, com febre, tosse e falta de ar\nidade_avancada(joao).\ndiabetico(joao).\nfebre(joao).\ntosse(joao).\nfalta_ar(joao).\n\n% Caso 2: Maria, 30 anos, grávida, com dor de cabeça e náusea\ngravidez(maria).\ndor_cabeca(maria).\nnausea(maria).\n\n% Caso 3: Pedro, 45 anos, cardiopata, com dor no peito e tontura\ncardiopata(pedro).\ndor_peito(pedro).\ntontura(pedro).\n\n% Caso 4: Ana, 25 anos, saudável, viajou recentemente, com febre e tosse\nviagem_recente(ana).\nfebre(ana).\ntosse(ana).\n\n% Caso 5: Carlos, 60 anos, hipertenso, apenas com dor de cabeça leve\nhipertenso(carlos).\ndor_cabeca(carlos).\n\n% Pacientes adicionais para completar a base\n% Caso 6: Beatriz, 35 anos, com tosse leve, vacinada contra gripe\nvacinado_gripe(beatriz).\ntosse(beatriz).\nfebre(beatriz).  % Adicionado para testar prioridade média\n\n% Caso 7: Diego, 72 anos, diabético e hipertenso, com tontura\nidade_avancada(diego).\ndiabetico(diego).\nhipertenso(diego).\ntontura(diego).\n\n% Caso 8: Fernanda, 28 anos, teve contato com pessoa doente, febre e dor de cabeça\ncontato_doente(fernanda).\nfebre(fernanda).\ndor_cabeca(fernanda).\n\n% ========================================\n% PREDICADOS AUXILIARES POSITIVOS\n% ========================================\n\n% Define pacientes sem febre (todos que não têm febre listados explicitamente)\nsem_febre(pedro).\nsem_febre(carlos).\nsem_febre(diego).\nsem_febre(maria).\n\n% Define pacientes jovens (não idosos)\njovem(maria).\njovem(ana).\njovem(beatriz).\njovem(fernanda).\n\n% Pacientes sem fatores de risco\nsem_fator_risco(ana).\nsem_fator_risco(beatriz).\nsem_fator_risco(fernanda).\n\n% Verifica se paciente tem algum sintoma\ntem_sintoma(Paciente) :-\n    febre(Paciente).\ntem_sintoma(Paciente) :-\n    tosse(Paciente).\ntem_sintoma(Paciente) :-\n    dor_cabeca(Paciente).\ntem_sintoma(Paciente) :-\n    dor_peito(Paciente).\ntem_sintoma(Paciente) :-\n    falta_ar(Paciente).\ntem_sintoma(Paciente) :-\n    nausea(Paciente).\ntem_sintoma(Paciente) :-\n    dor_abdominal(Paciente).\ntem_sintoma(Paciente) :-\n    tontura(Paciente).\n\n% Verifica se tem fatores de risco\ntem_fator_risco(Paciente) :-\n    idade_avancada(Paciente).\ntem_fator_risco(Paciente) :-\n    diabetico(Paciente).\ntem_fator_risco(Paciente) :-\n    hipertenso(Paciente).\ntem_fator_risco(Paciente) :-\n    cardiopata(Paciente).\ntem_fator_risco(Paciente) :-\n    gravidez(Paciente).\n\n% Verifica sintomas respiratórios\ntem_sintomas_respiratorios(Paciente) :-\n    tosse(Paciente).\ntem_sintomas_respiratorios(Paciente) :-\n    falta_ar(Paciente).\ntem_sintomas_respiratorios(Paciente) :-\n    febre(Paciente).\n\n% Verifica se tem apenas sintomas leves (sem sintomas graves)\napenas_sintomas_leves(Paciente) :-\n    tem_sintoma(Paciente),\n    sem_sintomas_graves(Paciente).\n\n% Define pacientes sem sintomas graves\nsem_sintomas_graves(Paciente) :-\n    sem_dor_peito(Paciente),\n    sem_falta_ar(Paciente),\n    sem_dor_abdominal(Paciente).\n\n% Predicados para ausência de sintomas específicos\nsem_dor_peito(joao).\nsem_dor_peito(maria).\nsem_dor_peito(ana).\nsem_dor_peito(carlos).\nsem_dor_peito(beatriz).\nsem_dor_peito(diego).\nsem_dor_peito(fernanda).\n\nsem_falta_ar(maria).\nsem_falta_ar(pedro).\nsem_falta_ar(ana).\nsem_falta_ar(carlos).\nsem_falta_ar(beatriz).\nsem_falta_ar(diego).\nsem_falta_ar(fernanda).\n\nsem_dor_abdominal(joao).\nsem_dor_abdominal(maria).\nsem_dor_abdominal(pedro).\nsem_dor_abdominal(ana).\nsem_dor_abdominal(carlos).\nsem_dor_abdominal(beatriz).\nsem_dor_abdominal(diego).\nsem_dor_abdominal(fernanda).\n\n% ========================================\n% REGRAS DE TRIAGEM - PRIORIDADE URGENTE\n% ========================================\n\n% Regra 1: Dor no peito + falta de ar\nprioridade_urgente(Paciente) :-\n    dor_peito(Paciente),\n    falta_ar(Paciente).\n\n% Regra 2: Febre + falta de ar + idade avançada\nprioridade_urgente(Paciente) :-\n    febre(Paciente),\n    falta_ar(Paciente),\n    idade_avancada(Paciente).\n\n% Regra 3: Dor abdominal + náusea\nprioridade_urgente(Paciente) :-\n    dor_abdominal(Paciente),\n    nausea(Paciente).\n\n% Regra 4: Tontura + dor no peito + cardiopata\nprioridade_urgente(Paciente) :-\n    tontura(Paciente),\n    dor_peito(Paciente),\n    cardiopata(Paciente).\n\n% Regra adicional 1: Febre + tosse + falta de ar (tríade respiratória grave)\nprioridade_urgente(Paciente) :-\n    febre(Paciente),\n    tosse(Paciente),\n    falta_ar(Paciente).\n\n% Regra adicional 2: Dor abdominal + gravidez\nprioridade_urgente(Paciente) :-\n    dor_abdominal(Paciente),\n    gravidez(Paciente).\n\n% ========================================\n% REGRAS DE TRIAGEM - PRIORIDADE ALTA\n% ========================================\n\n% Define pacientes sem urgência\nsem_urgencia(Paciente) :-\n    paciente_conhecido(Paciente),\n    nao_urgente(Paciente).\n\n% Lista de pacientes não urgentes (calculado manualmente ou por outro predicado)\nnao_urgente(maria).\nnao_urgente(ana).\nnao_urgente(carlos).\nnao_urgente(beatriz).\nnao_urgente(diego).\nnao_urgente(fernanda).\n\n% Regra 5: Febre + tosse + viagem recente\nprioridade_alta(Paciente) :-\n    febre(Paciente),\n    tosse(Paciente),\n    viagem_recente(Paciente),\n    sem_urgencia(Paciente).\n\n% Regra 6: Febre + dor de cabeça + contato com doente\nprioridade_alta(Paciente) :-\n    febre(Paciente),\n    dor_cabeca(Paciente),\n    contato_doente(Paciente),\n    sem_urgencia(Paciente).\n\n% Regra 7: Falta de ar + diabético\nprioridade_alta(Paciente) :-\n    falta_ar(Paciente),\n    diabetico(Paciente),\n    sem_urgencia(Paciente).\n\n% Regra 8: Qualquer sintoma + gravidez\nprioridade_alta(Paciente) :-\n    tem_sintoma(Paciente),\n    gravidez(Paciente),\n    sem_urgencia(Paciente).\n\n% Regra adicional 4: Idade avançada + cardiopata + sintomas\nprioridade_alta(Paciente) :-\n    idade_avancada(Paciente),\n    cardiopata(Paciente),\n    tem_sintoma(Paciente),\n    sem_urgencia(Paciente).\n\n% ========================================\n% REGRAS DE TRIAGEM - PRIORIDADE MÉDIA\n% ========================================\n\n% Define pacientes sem prioridade superior (urgente ou alta)\nsem_prioridade_superior(Paciente) :-\n    paciente_conhecido(Paciente),\n    sem_urgencia(Paciente),\n    sem_alta_prioridade(Paciente).\n\n% Lista de pacientes sem alta prioridade\nsem_alta_prioridade(carlos).\nsem_alta_prioridade(beatriz).\nsem_alta_prioridade(diego).\n\n% Regra 9: Febre + tosse + vacinado gripe\nprioridade_media(Paciente) :-\n    febre(Paciente),\n    tosse(Paciente),\n    vacinado_gripe(Paciente),\n    sem_prioridade_superior(Paciente).\n\n% Regra 10: Dor de cabeça + náusea (apenas sintomas leves)\nprioridade_media(Paciente) :-\n    dor_cabeca(Paciente),\n    nausea(Paciente),\n    apenas_sintomas_leves(Paciente),\n    sem_prioridade_superior(Paciente).\n\n% Regra 11: Tosse sem febre + idade avançada\nprioridade_media(Paciente) :-\n    tosse(Paciente),\n    sem_febre(Paciente),\n    idade_avancada(Paciente),\n    sem_prioridade_superior(Paciente).\n\n% ========================================\n% REGRAS DE TRIAGEM - PRIORIDADE BAIXA\n% ========================================\n\n% Define pacientes sem prioridade elevada\nsem_prioridade_elevada(Paciente) :-\n    paciente_conhecido(Paciente),\n    sem_prioridade_superior(Paciente),\n    sem_media_prioridade(Paciente).\n\n% Lista de pacientes sem média prioridade\nsem_media_prioridade(carlos).\n\n% Regra 12: Apenas dor de cabeça sem fatores de risco\nprioridade_baixa(Paciente) :-\n    dor_cabeca(Paciente),\n    sem_fator_risco(Paciente),\n    sem_prioridade_elevada(Paciente).\n\n% Regra 13: Tosse leve (jovem, sem fatores de risco)\nprioridade_baixa(Paciente) :-\n    tosse(Paciente),\n    jovem(Paciente),\n    sem_fator_risco(Paciente),\n    sem_prioridade_elevada(Paciente).\n\n% ========================================\n% PREDICADO UNIFICADO DE PRIORIDADE\n% ========================================\n\nprioridade(Paciente, urgente) :-\n    prioridade_urgente(Paciente).\n\nprioridade(Paciente, prioridade_alta) :-\n    prioridade_alta(Paciente).\n\nprioridade(Paciente, prioridade_media) :-\n    prioridade_media(Paciente).\n\nprioridade(Paciente, prioridade_baixa) :-\n    prioridade_baixa(Paciente).\n\n% ========================================\n% REGRAS DE RECOMENDAÇÃO\n% ========================================\n\n% Regra 14: Urgente → emergência\nencaminhar(Paciente, emergencia) :-\n    prioridade(Paciente, urgente).\n\n% Regra 15: Prioridade alta + hipertenso → monitorar pressão\ncuidado_especial(Paciente, monitorar_pressao) :-\n    prioridade(Paciente, prioridade_alta),\n    hipertenso(Paciente).\n\n% Regra 16: Diabético → verificar glicemia\ncuidado_especial(Paciente, verificar_glicemia) :-\n    diabetico(Paciente).\n\n% Regra 17: Sintomas respiratórios → isolamento\ncuidado_especial(Paciente, isolamento_preventivo) :-\n    tem_sintomas_respiratorios(Paciente).\n\n% Regras adicionais de cuidados especiais\ncuidado_especial(Paciente, oxigenio) :-\n    febre(Paciente),\n    tosse(Paciente),\n    falta_ar(Paciente).\n\nencaminhar(Paciente, obstetricia) :-\n    dor_abdominal(Paciente),\n    gravidez(Paciente).\n\ncuidado_especial(Paciente, monitorar_pressao_imediato) :-\n    tontura(Paciente),\n    hipertenso(Paciente).\n\ncuidado_especial(Paciente, exame_covid) :-\n    viagem_recente(Paciente),\n    febre(Paciente).\n\n% ========================================\n% PREDICADOS AUXILIARES PARA CONSULTAS\n% ========================================\n\n% Lista todos os pacientes conhecidos no sistema\npaciente_conhecido(joao).\npaciente_conhecido(maria).\npaciente_conhecido(pedro).\npaciente_conhecido(ana).\npaciente_conhecido(carlos).\npaciente_conhecido(beatriz).\npaciente_conhecido(diego).\npaciente_conhecido(fernanda).\n\n% ========================================\n% CONSULTAS E TESTES\n% ========================================\n\n% Consulta 1: Qual a prioridade do paciente X?\nconsultar_prioridade(Paciente, Prioridade) :-\n    prioridade(Paciente, Prioridade).\n\n% Consulta 2: Quais pacientes precisam de atendimento urgente?\npacientes_urgentes(ListaPacientes) :-\n    findall(Paciente, prioridade(Paciente, urgente), ListaPacientes).\n\n% Consulta 3: Que cuidados especiais o paciente X requer?\ncuidados_necessarios(Paciente, ListaCuidados) :-\n    findall(Cuidado, cuidado_especial(Paciente, Cuidado), ListaCuidadosDup),\n    list_to_set(ListaCuidadosDup, ListaCuidados).\n\n% Consulta 4: Quantos pacientes estão em cada categoria de prioridade?\ncontar_prioridades(urgente, Quantidade) :-\n    findall(P, prioridade(P, urgente), Lista),\n    length(Lista, Quantidade).\n\ncontar_prioridades(prioridade_alta, Quantidade) :-\n    findall(P, prioridade(P, prioridade_alta), Lista),\n    length(Lista, Quantidade).\n\ncontar_prioridades(prioridade_media, Quantidade) :-\n    findall(P, prioridade(P, prioridade_media), Lista),\n    length(Lista, Quantidade).\n\ncontar_prioridades(prioridade_baixa, Quantidade) :-\n    findall(P, prioridade(P, prioridade_baixa), Lista),\n    length(Lista, Quantidade).\n\n% Relatório completo de um paciente\nrelatorio_paciente(Paciente) :-\n    write('=== RELATÓRIO DO PACIENTE: '), write(Paciente), write(' ==='), nl,\n    (prioridade(Paciente, P) -&gt; \n        write('Prioridade: '), write(P), nl\n    ; \n        write('Prioridade: não classificada'), nl),\n    write('Cuidados especiais necessários:'), nl,\n    forall(cuidado_especial(Paciente, C), \n           (write('  - '), write(C), nl)),\n    (encaminhar(Paciente, Destino) -&gt; \n        write('Encaminhamento: '), write(Destino), nl\n    ; \n        true),\n    nl.\n\n% Resumo geral do sistema\nresumo_sistema :-\n    write('=== RESUMO DO SISTEMA DE TRIAGEM ==='), nl,\n    contar_prioridades(urgente, U),\n    contar_prioridades(prioridade_alta, A),\n    contar_prioridades(prioridade_media, M),\n    contar_prioridades(prioridade_baixa, B),\n    write('Pacientes URGENTES: '), write(U), nl,\n    write('Pacientes PRIORIDADE ALTA: '), write(A), nl,\n    write('Pacientes PRIORIDADE MÉDIA: '), write(M), nl,\n    write('Pacientes PRIORIDADE BAIXA: '), write(B), nl,\n    pacientes_urgentes(ListaUrgentes),\n    write('Pacientes que precisam atendimento urgente: '), write(ListaUrgentes), nl.\n\n% Execução dos Casos de Teste\n\n\n% --- TESTES DOS CASOS ---\n\n% Caso 1: João\n% ?- consultar_prioridade(joao, Prioridade).\n% Resposta esperada: Prioridade = urgente \n% Justificativa: febre + falta_ar + idade_avançada (Regra 2)\n\n% ?- cuidados_necessarios(joao, Cuidados).\n% Resposta esperada: Cuidados = [verificar_glicemia, isolamento_preventivo, oxigenio]\n% Justificativa: diabético + sintomas respiratórios + tríade grave\n\n% Caso 2: Maria\n% ?- consultar_prioridade(maria, Prioridade).\n% Resposta esperada: Prioridade = prioridade_alta \n% Justificativa: gravidez + sintomas (Regra 8)\n\n% ?- cuidados_necessarios(maria, Cuidados).\n% Resposta esperada: Cuidados = []\n% Justificativa: sem condições especiais além da gravidez\n\n% Caso 3: Pedro\n% ?- consultar_prioridade(pedro, Prioridade).\n% Resposta esperada: Prioridade = urgente \n% Justificativa: tontura + dor_peito + cardiopata (Regra 4)\n\n% ?- encaminhar(pedro, Destino).\n% Resposta esperada: Destino = emergencia\n% Justificativa: prioridade urgente\n\n% Caso 4: Ana\n% ?- consultar_prioridade(ana, Prioridade).\n% Resposta esperada: Prioridade = prioridade_alta \n% Justificativa: febre + tosse + viagem_recente (Regra 5)\n\n% ?- cuidados_necessarios(ana, Cuidados).\n% Resposta esperada: Cuidados = [isolamento_preventivo, exame_covid]\n% Justificativa: sintomas respiratórios + viagem recente\n\n% Caso 5: Carlos\n% ?- consultar_prioridade(carlos, Prioridade).\n% Resposta esperada: Prioridade = prioridade_baixa \n% Justificativa: apenas dor de cabeça, sem outros fatores graves\n\n% ?- cuidados_necessarios(carlos, Cuidados).\n% Resposta esperada: Cuidados = []\n% Justificativa: hipertenso mas sem sintomas que exijam monitoramento\n\n% Consultas Gerais\n% ?- pacientes_urgentes(Lista).\n% Resposta esperada: Lista = [joao, pedro]\n\n% ?- contar_prioridades(urgente, N).\n% Resposta esperada: N = 2\n\n% ?- resumo_sistema.\n% Saída esperada: \n% === RESUMO DO SISTEMA DE TRIAGEM ===\n% Pacientes URGENTES: 2\n% Pacientes PRIORIDADE ALTA: 3\n% Pacientes PRIORIDADE MÉDIA: 1\n% Pacientes PRIORIDADE BAIXA: 1\n% Pacientes que precisam atendimento urgente: [joao, pedro]\n\n% ?- relatorio_paciente(joao).\n% Saída esperada: \n% === RELATÓRIO DO PACIENTE: joao ===\n% Prioridade: urgente\n% Cuidados especiais necessários:\n%   - verificar_glicemia\n%   - isolamento_preventivo\n%   - oxigenio\n% Encaminhamento: emergencia\n\n\n10.3.5 Vantagens da Abordagem Positiva\nA eliminação de negações explícitas (\\+) trouxe várias melhorias:\n\nMaior Clareza Declarativa: Predicados como sem_febre, jovem e sem_fator_risco expressam condições de forma positiva e clara.\nMelhor Performance: Evitamos backtracking desnecessário causado por negações, tornando as consultas mais eficientes.\nManutenibilidade: Adicionar novos pacientes requer apenas declarar seus atributos positivos, sem precisar raciocinar sobre negações.\nCompletude da Base: Todos os fatos relevantes são explicitamente declarados, facilitando a compreensão do estado completo do sistema.\n\n\n10.3.5.1 Estratégias Utilizadas\n\nPredicados Complementares: Para cada condição que antes seria negada, criamos um predicado positivo correspondente (sem_febre, sem_urgencia, etc.).\nHierarquia de Prioridades: Estabelecemos predicados auxiliares que determinam explicitamente quando um paciente não está em determinada categoria.\nListas Explícitas: Mantemos listas de pacientes em cada categoria auxiliar, tornando o raciocínio mais transparente.\nPredicados de Estado: Criamos predicados que descrevem estados completos (apenas_sintomas_leves, sem_sintomas_graves), em vez de negar condições individuais.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Criando Mundos: Raciocínio Lógico</span>"
    ]
  },
  {
    "objectID": "07a-criando-mundos-praticas.html#problema-3-sistema-especialista-astroguia",
    "href": "07a-criando-mundos-praticas.html#problema-3-sistema-especialista-astroguia",
    "title": "10  Criando Mundos: Raciocínio Lógico",
    "section": "10.4 Problema 3: Sistema Especialista “AstroGuia”",
    "text": "10.4 Problema 3: Sistema Especialista “AstroGuia”\nA Agência Espacial Internacional precisa de um novo sistema de consulta inteligente, o “AstroGuia”, para ajudar astrônomos a rapidamente classificarem e entenderem relações entre objetos celestes. Você foi encarregado de construir o protótipo deste sistema usando Prolog.\nO sistema deve ser alimentado com uma lista de dados primários e, a partir deles, deve ser capaz de responder a perguntas complexas que exigem raciocínio. Cabe a você determinar quais são as perguntas complexas e quão complexas elas serão.\nSua única fonte de informação é a lista a seguir:\n\nO Sol é uma estrela;\nA Terra, Marte, Vênus, Júpiter, Netuno, Saturno e Mercúrio são planetas que orbitam o Sol;\nA Lua é um satélite da Terra, Fobos e Deimos são satélites de Marte, Ganimedes e Io são satélites de Júpiter. Cada satélite orbita o seu planeta;\nA Terra, Marte, Mercúrio e Venus são planetas rochosas;\nJúpiter, Saturno e Netuno são planetas gasosos.\n\nVocê deve implementar a lógica (as regras) que permita ao AstroGuia realizar as seguintes tarefas:\n\nClassificação Rápida: O sistema precisa de uma maneira eficiente de confirmar se um objeto é um planeta. Crie o predicado planeta/1.\nFiltragem por Composição: Astrônomos frequentemente buscam por planetas com características específicas. Implemente o predicado planeta_rochoso/1 para encontrar todos os planetas que são rochosos.\nAnálise de Sistemas Lua-Planeta: Uma consulta comum é verificar hierarquias. O sistema precisa de um predicado satelite_de/2 para confirmar se um corpo celeste é um satélite de outro corpo que seja, de fato, um planeta.\nMapeamento do Sistema Solar: Para estudos locais, os cientistas precisam listar todos os corpos que orbitam diretamente nossa estrela. Implemente o predicado sistema_solar/1.\n\n\n10.4.1 Resolução do Problema: Sistema Especialista “AstroGuia”\nEsta solução aborda o problema proposto em duas etapas: primeiro, a modelagem do conhecimento usando a sintaxe formal da Lógica de Primeira Ordem (LPO) e, em segundo lugar, a implementação prática dessa lógica em uma base de conhecimento Prolog.\n\n10.4.1.1 Solução em Lógica de Primeira Ordem\nDefinição do Mundo:\n\nConstantes: \\(sol, terra, marte, venus, jupiter, netuno, saturno, mercurio, lua, fobos, deimos, ganimedes, io, estrela, planeta, satelite, rochoso, gasoso\\).\nPredicados:\n\n\\(Tipo(objeto, categoria)\\): O objeto pertence à categoria.\n\\(Orbita(orbitante, orbitado)\\): O objeto orbitante gira em torno do orbitado.\n\\(Composicao(objeto, tipo)\\): O objeto possui uma composição física.\n\n\nA seguir, a tradução da fonte de informação para axiomas lógicos.\nFatos sobre \\(Tipo\\):\n\\[\nTipo(sol, estrela) \\\\\nTipo(terra, planeta) \\\\\nTipo(marte, planeta) \\\\\nTipo(venus, planeta) \\\\\nTipo(jupiter, planeta) \\\\\nTipo(netuno, planeta) \\\\\nTipo(saturno, planeta) \\\\\nTipo(mercurio, planeta) \\\\\nTipo(lua, satelite) \\\\\nTipo(fobos, satelite) \\\\\nTipo(deimos, satelite) \\\\\nTipo(ganimedes, satelite) \\\\\nTipo(io, satelite)\n\\]\nFatos sobre \\(Orbita\\):\n\\[\nOrbita(terra, sol) \\\\\nOrbita(marte, sol) \\\\\nOrbita(venus, sol) \\\\\nOrbita(jupiter, sol) \\\\\nOrbita(netuno, sol) \\\\\nOrbita(saturno, sol) \\\\\nOrbita(mercurio, sol) \\\\\nOrbita(lua, terra) \\\\\nOrbita(fobos, marte) \\\\\nOrbita(deimos, marte) \\\\\nOrbita(ganimedes, jupiter) \\\\\nOrbita(io, jupiter)\n\\]\nFatos sobre \\(Composicao\\):\n\\[\nComposicao(terra, rochoso) \\\\\nComposicao(marte, rochoso) \\\\\nComposicao(mercurio, rochoso) \\\\\nComposicao(venus, rochoso) \\\\\nComposicao(jupiter, gasoso) \\\\\nComposicao(saturno, gasoso) \\\\\nComposicao(netuno, gasoso)\n\\]\nRegras:\nAs regras dedutivas correspondem aos requisitos do sistema.\n\nRegra planeta: Para todo \\(x\\), \\(x\\) é um planeta se seu tipo for planeta.\n\\[\\forall x (Tipo(x, planeta) \\rightarrow Planeta(x))\\]\nRegra planeta_rochoso: Para todo \\(x\\), \\(x\\) é um planeta rochoso se \\(x\\) é um planeta E (\\(\\wedge\\)) sua composição é rochosa.\n\\[\\forall x (Planeta(x) \\wedge Composicao(x, rochoso) \\rightarrow PlanetaRochoso(x))\\]\nRegra satelite_de: Para todos \\(x\\) e \\(y\\), \\(x\\) é um satélite de \\(y\\) se \\(x\\) orbita \\(y\\) E \\(y\\) é um planeta.\n\\[\\forall x \\forall y (Orbita(x, y) \\wedge Planeta(y) \\rightarrow SateliteDe(x, y))\\]\nRegra sistema_solar: Para todo \\(x\\), \\(x\\) pertence ao sistema solar se \\(x\\) orbita o sol.\n\\[\\forall x (Orbita(x, sol) \\rightarrow SistemaSolar(x))\\]\n\nDefinição das Consultas:\nAqui definimos as perguntas complexas que nosso sistema deve ser capaz de responder.\n\nConsulta 1: Quais planetas rochosos possuem satélites? “Existe um \\(x\\) e existe um \\(y\\) tal que \\(x\\) é um planeta rochoso E \\(y\\) é um satélite de \\(x\\)?”\n\\[\\exists x \\exists y (PlanetaRochoso(x) \\wedge SateliteDe(y, x))\\]\nConsulta 2: Quais corpos orbitam um planeta gasoso? “Existe um \\(x\\) e existe um \\(y\\) tal que \\(x\\) orbita \\(y\\) E a composição de \\(y\\) é gasosa?”\n\\[\\exists x \\exists y (Orbita(x, y) \\wedge Composicao(y, gasoso))\\]\nConsulta 3: Quais satélites estão em um sistema “neto-avô” com o Sol? (i.e., orbitam um planeta que orbita o Sol) “Existe um \\(x\\) e um \\(y\\) tal que \\(x\\) é um satélite de \\(y\\) E \\(y\\) orbita o Sol?”\n\\[\\exists x \\exists y (SateliteDe(x, y) \\wedge Orbita(y, sol))\\]\n\n\n\n\n10.4.2 2. Solução em Prolog\nA seguir, a implementação da lógica formal em uma base de conhecimento Prolog.\n% --- FATOS ---\n\n% tipo(Corpo, Categoria)\ntipo(sol, estrela).\ntipo(terra, planeta).\ntipo(marte, planeta).\ntipo(venus, planeta).\ntipo(jupiter, planeta).\ntipo(netuno, planeta).\ntipo(saturno, planeta).\ntipo(mercurio, planeta).\ntipo(lua, satelite).\ntipo(fobos, satelite).\ntipo(deimos, satelite).\ntipo(ganimedes, satelite).\ntipo(io, satelite).\n\n% orbita(Orbitante, Orbitado)\norbita(terra, sol).\norbita(marte, sol).\norbita(venus, sol).\norbita(jupiter, sol).\norbita(netuno, sol).\norbita(saturno, sol).\norbita(mercurio, sol).\norbita(lua, terra).\norbita(fobos, marte).\norbita(deimos, marte).\norbita(ganimedes, jupiter).\norbita(io, jupiter).\n\n% composicao(Corpo, Tipo)\ncomposicao(terra, rochoso).\ncomposicao(marte, rochoso).\ncomposicao(mercurio, rochoso).\ncomposicao(venus, rochoso).\ncomposicao(jupiter, gasoso).\ncomposicao(saturno, gasoso).\ncomposicao(netuno, gasoso).\n\n% --- REGRAS (Requisitos do Sistema) ---\n\n% 1. Classificação Rápida: Um corpo é um planeta se seu tipo for planeta.\nplaneta(X) :- \n    tipo(X, planeta).\n\n% 2. Filtragem por Composição: Um corpo é um planeta rochoso se for um planeta\n%    e sua composição for rochosa.\nplaneta_rochoso(X) :-\n    planeta(X),\n    composicao(X, rochoso).\n\n% 3. Análise de Sistemas: S é satélite de P se S orbita P e P é um planeta.\nsatelite_de(S, P) :-\n    orbita(S, P),\n    planeta(P).\n\n% 4. Mapeamento do Sistema Solar: Um corpo está no sistema solar se orbita o sol.\nsistema_solar(X) :-\n    orbita(X, sol).\n\n% Aqui estão as consultas em Prolog e suas respostas esperadas, demonstrando a capacidade de raciocínio da base de conhecimento.\n\n% Consulta 1: Quais planetas rochosos possuem satélites?\n% (Encontra um planeta P e um satélite S que satisfazem ambas as condições)\n% ?- planeta_rochoso(Planeta), satelite_de(Satelite, Planeta).\n\n% Resposta Esperada:\n% Planeta = terra, Satelite = lua ;\n% Planeta = marte, Satelite = fobos ;\n% Planeta = marte, Satelite = deimos.\n\n%------------------------------------------------------------------\n\n% Consulta 2: Quais corpos (satélites) orbitam um planeta gasoso?\n% (Encontra um Corpo e um Planeta tal que o corpo orbite o planeta e este seja gasoso)\n% ?- orbita(Corpo, Planeta), composicao(Planeta, gasoso).\n\n% Resposta Esperada:\n% Corpo = ganimedes, Planeta = jupiter ;\n% Corpo = io, Planeta = jupiter.\n\n%------------------------------------------------------------------\n\n% Consulta 3: Quais satélites estão em um sistema \"neto-avô\" com o Sol?\n% (Encontra satélites que orbitam planetas que, por sua vez, orbitam o sol)\n% ?- satelite_de(Satelite, Planeta), sistema_solar(Planeta).\n\n% Resposta Esperada:\n% Satelite = lua, Planeta = terra ;\n% Satelite = fobos, Planeta = marte ;\n% Satelite = deimos, Planeta = marte ;\n% Satelite = ganimedes, Planeta = jupiter ;\n% Satelite = io, Planeta = jupiter.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Criando Mundos: Raciocínio Lógico</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html",
    "href": "08-verificacao-formal-de-programas.html",
    "title": "11  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "",
    "text": "11.0.1 Princípios fundamentais e triplas de Hoare\nA lógica de Hoare, desenvolvida por Tony Hoare em 1969, revolucionou a verificação formal ao estabelecer uma base axiomática para provar a correção de programas. O conceito central reside nas triplas de Hoare, que têm a forma {P} C {Q}, em que P representa a pré-condição (propriedade verdadeira antes da execução), C o comando ou programa, e Q a pós-condição (propriedade verdadeira após a execução).\nEsta notação expressa uma relação fundamental: “se P é verdadeiro antes da execução de C, e se C termina, então Q será verdadeiro após a execução de C”. Esta interpretação estabelece a base para correção parcial, distinguindo-se da correção total que também garante terminação.\nOs axiomas fundamentais da lógica de Hoare incluem o axioma da atribuição {Q[E/V]} V := E {Q}, que estabelece que para provar Q após a atribuição V := E, devemos provar Q com E substituído por V antes da atribuição. A regra de sequência {P} C1 {R}, {R} C2 {Q} / {P} C1; C2 {Q} permite compor provas de comandos sequenciais através de condições intermediárias.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "href": "08-verificacao-formal-de-programas.html#indução-estrutural-verificação-de-programas-recursivos",
    "title": "11  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "11.1 Indução Estrutural: Verificação de Programas Recursivos",
    "text": "11.1 Indução Estrutural: Verificação de Programas Recursivos\n\n11.1.1 Princípios fundamentais e diferenças com indução matemática\nA indução estrutural estende a indução matemática tradicional para estruturas de dados definidas recursivamente. Enquanto a indução matemática opera sobre números naturais com estrutura linear, a indução estrutural aplica-se a estruturas como listas, árvores, e fórmulas lógicas que possuem múltiplas formas de construção.\nA indução matemática tradicional prova propriedades P(n) para números naturais através de um caso base P(0) e um caso indutivo P(k) → P(k+1). A indução estrutural generaliza este princípio para estruturas recursivamente definidas, em que múltiplos construtores podem criar novas instâncias a partir de instâncias existentes.\nPara estruturas de dados indutivos, a indução estrutural baseia-se em uma ordenação bem-fundada. Por exemplo, para listas, a relação “ser sublista de” é bem-fundada, e para árvores, “ser subárvore de” estabelece a ordem necessária. Esta fundamentação garante que toda sequência decrescente é finita, permitindo provas por indução.\n\n\n11.1.2 Aplicação para verificação de programas recursivos\nA indução estrutural é especialmente poderosa na verificação de programas funcionais que operam sobre tipos de dados algébricos. Considere a verificação da propriedade de associatividade para concatenação de listas:\n\nTheorem 11.1 (Associatividade da Concatenação) Para quaisquer listas xs, ys, e zs, a seguinte propriedade é válida: \\[\nxs \\oplus (ys \\oplus zs) = (xs \\oplus ys) \\oplus zs\n\\]\n\n\nProof. A prova é por indução estrutural em xs.\nCaso base: xs = [] \\[\n[] \\oplus (ys \\oplus zs) = ys \\oplus zs = ([] \\oplus ys) \\oplus zs\n\\]\nCaso indutivo: xs = h::t\nAssumimos a hipótese indutiva (H.I.): \\(t \\oplus (ys \\oplus zs) = (t \\oplus ys) \\oplus zs\\). \\[\n\\begin{aligned}\n  (h::t) \\oplus (ys \\oplus zs) &= h :: (t \\oplus (ys \\oplus zs)) \\\\\n                              &= h :: ((t \\oplus ys) \\oplus zs) \\quad \\text{[por H.I.]} \\\\\n                              &= (h :: (t \\oplus ys)) \\oplus zs \\\\\n                              &= ((h::t) \\oplus ys) \\oplus zs\n\\end{aligned}\n\\]\n\nEsta prova demonstra como a estrutura recursiva dos dados guia naturalmente a estrutura da prova, com cada constructor da estrutura correspondendo a um caso na indução.\n\n\n11.1.3 Provas de correção de algoritmos funcionais\nA indução estrutural permite provar correção de algoritmos complexos sobre estruturas recursivas. Para funções sobre árvores, consideremos a verificação de que a reflexão é uma involução:\n\nTheorem 11.2 (Reflexão como Involução) Para qualquer árvore t, a reflexão da reflexão de t é igual a t. \\[\n\\text{reflect}(\\text{reflect}(t)) = t\n\\]\n\n\nProof. A prova é por indução estrutural em t.\nCaso base: t = Leaf \\[\n\\text{reflect}(\\text{reflect}(\\text{Leaf})) = \\text{reflect}(\\text{Leaf}) = \\text{Leaf}\n\\]\nCaso indutivo: t = Node(l, v, r)\nAssumimos a H.I.: \\(\\text{reflect}(\\text{reflect}(l)) = l \\land \\text{reflect}(\\text{reflect}(r)) = r\\). \\[\n\\begin{aligned}\n  &\\text{reflect}(\\text{reflect}(\\text{Node}(l, v, r))) \\\\\n  &= \\text{reflect}(\\text{Node}(\\text{reflect}(r), v, \\text{reflect}(l))) \\\\\n  &= \\text{Node}(\\text{reflect}(\\text{reflect}(l)), v, \\text{reflect}(\\text{reflect}(r))) \\\\\n  &= \\text{Node}(l, v, r) \\quad \\text{[por H.I.]}\n\\end{aligned}\n\\]\n\nEsta prova ilustra como hipóteses indutivas múltiplas (para subárvores esquerda e direita) são necessárias para construtores com múltiplos argumentos recursivos.\n\n\n11.1.4 Exemplos práticos com funções recursivas\nA verificação de algoritmos de ordenação por inserção demonstra a aplicação prática da indução estrutural:\n\nTheorem 11.3 (Correção do Insertion Sort) Para qualquer lista lst, o algoritmo insertion_sort produz uma lista ordenada que contém os mesmos elementos da lista original. \\[\n\\forall \\text{lst}, \\text{sorted}(\\text{insertion\\_sort}(\\text{lst})) \\land \\text{same\\_elements}(\\text{lst}, \\text{insertion\\_sort}(\\text{lst}))\n\\]\n\n\nProof. A prova é por indução estrutural em lst.\nCaso base: lst = [] O resultado de insertion_sort([]) é []. A lista vazia é ordenada e contém os mesmos elementos que a original.\nCaso indutivo: lst = h::t Assumimos a H.I.: \\(\\text{sorted}(\\text{insertion\\_sort}(t)) \\land \\text{same\\_elements}(t, \\text{insertion\\_sort}(t))\\).\nSabemos que insertion_sort(h::t) é insert(h, insertion_sort(t)). A prova depende de um lema auxiliar que afirma que a função insert preserva tanto a ordenação quanto a coleção de elementos. Assumir a validade do lema nos permite concluir que a propriedade do teorema é mantida.\n\nO uso de lemmas auxiliares é frequentemente necessário para provas complexas, permitindo decomposição modular das verificações.\n\n\n11.1.5 Relação com tipos de dados indutivos e coinductivos\nA indução estrutural aplica-se naturalmente a tipos de dados indutivos, que são construídos através de construtores finitos. Tipos indutivos como listas e árvores são definidos através de casos base (lista vazia, folha) e casos recursivos (cons, nó interno).\nPor contraste, tipos coinductivos são definidos através de destrutores/observadores e podem representar estruturas potencialmente infinitas como streams. A coindução é o dual matemático da indução, apropriada para provar propriedades sobre estruturas infinitas através de consistência de observações.\nEm assistentes de prova como Coq, esta dualidade é expressa através da distinção entre tipos Inductive e CoInductive:\n(* Tipo indutivo - lista *)\nInductive list (A : Type) : Type :=\n| nil : list A\n| cons : A -&gt; list A -&gt; list A.\n\n(* Tipo coinductivo - stream *)\nCoInductive stream (A : Type) : Type :=\n| Cons : A -&gt; stream A -&gt; stream A.\nEsta distinção fundamental orienta a escolha entre técnicas de prova indutivas e coindutivas, dependendo da natureza finita ou infinita das estruturas sendo verificadas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "href": "08-verificacao-formal-de-programas.html#integração-com-lógica-de-primeira-ordem",
    "title": "11  Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural",
    "section": "11.2 Integração com Lógica de Primeira Ordem",
    "text": "11.2 Integração com Lógica de Primeira Ordem\n\n11.2.1 Especificação de propriedades de programas com FOL\nA Lógica de Primeira Ordem (FOL) fornece a base teórica fundamental para especificação de propriedades de programas. FOL permite expressar propriedades complexas através de quantificadores (∀ - para todo, ∃ - existe) e predicados, oferecendo expressividade suficiente para a maioria das especificações práticas.\nA especificação de contratos de programas utiliza FOL para definir pré-condições, pós-condições e invariantes. Por exemplo, uma função de ordenação pode ter especificação:\n\\[\n\\forall \\text{array} \\in \\text{int}[], \\text{sorted}(\\text{array}) \\iff \\forall i,j: (0 \\le i &lt; j &lt; \\text{array.length}) \\implies \\text{array}[i] \\le \\text{array}[j]\n\\]\nEsta especificação captura precisamente o conceito de array ordenado usando quantificadores universais sobre índices e uma implicação que define a relação de ordem.\nPara estruturas de dados mais complexas, FOL permite especificar invariantes estruturais:\n\\[\n\\forall \\text{tree} \\in \\text{BinaryTree}, \\text{balanced}(\\text{tree}) \\iff \\forall \\text{node} \\in \\text{tree}, |\\text{height}(\\text{left}(\\text{node})) - \\text{height}(\\text{right}(\\text{node}))| \\le 1\n\\]\n\n\n11.2.2 Relação entre lógica e correção de programas\nA relação entre FOL e correção de programas manifesta-se através da interpretação semântica das especificações. A lógica de Hoare utiliza FOL como metalinguagem para expressar a semântica de correção parcial e total, sendo que triplas de Hoare são interpretadas como fórmulas FOL.\nA verificação de correção transforma programas anotados em condições de verificação (VCs) expressas em FOL. Estas VCs são então enviadas para provadores automáticos de teoremas (SAT/SMT solvers) que determinam sua validade. Este processo automatiza significativamente a verificação, reduzindo o esforço manual necessário para provas de correção.\nA correção parcial especifica que se a pré-condição é verdadeira e o programa termina, então a pós-condição é verdadeira. A correção total adiciona a garantia de terminação, frequentemente expressa através de variantes que diminuem em relações bem-fundamentadas.\n\n\n11.2.3 Métodos formais em engenharia de software\nA integração de FOL com engenharia de software ocorre através de diversos métodos formais. Model checking explora exaustivamente o espaço de estados de sistemas finitos, verificando propriedades temporais expressas em lógicas como LTL (Linear Temporal Logic) e CTL (Computation Tree Logic).\nTheorem proving oferece verificação interativa ou semi-automática baseada em FOL e lógicas de ordem superior. Ferramentas como Coq, Isabelle/HOL e Lean permitem construção incremental de provas complexas, com verificação automática de correção.\nA abstract interpretation utiliza FOL para especificar domínios abstratos que aproximam o comportamento de programas, permitindo análise estática eficiente para detecção de erros como buffer overflows, null pointer dereferences, e violações de invariantes.\n\n\n11.2.4 Ferramentas modernas e aplicações práticas\nAs ferramentas modernas de verificação formal implementam integração sofisticada entre FOL e verificação de programas. Dafny utiliza Church’s Simple Type Theory, uma extensão de FOL, para especificação e verificação automática através do provador Z3.\nSPARK, baseado em Ada, expressa contratos como predicados FOL e utiliza múltiplos provadores SMT para verificação automática. Esta abordagem demonstra aplicabilidade industrial da verificação formal, com uso em sistemas críticos da aviação e automotivos.\nCoq/Rocq oferece ambiente de prova interativa onde FOL pode ser codificada dentro do sistema de tipos, permitindo formalização matemática rigorosa e extração automática de programas certificados. Projetos como CompCert (compilador C formalmente verificado) demonstram a viabilidade da verificação formal em larga escala.\n\n\n11.2.5 Aplicações em sistemas críticos\nA verificação formal com FOL encontra aplicações cruciais em sistemas críticos. Na aviação, padrões como DO-178C/ED-12C reconhecem métodos formais como meio aceitável para certificação de software aviônico. Projetos como o Airbus A380 utilizaram verificação formal para componentes críticos de controle.\nSistemas automotivos seguem a ISO 26262 para segurança funcional, onde verificação formal contribui para atendimento aos níveis mais altos de integridade de segurança (ASIL D). A verificação de ECUs (Electronic Control Units) utiliza especificações FOL para garantir ausência de erros críticos.\nNa segurança cibernética, a verificação formal de protocolos criptográficos utiliza FOL para especificar propriedades de segurança como confidencialidade, integridade e autenticidade. Projetos como a verificação do microkernel seL4 demonstram correção funcional completa usando Isabelle/HOL.\n\n\n11.2.6 Desafios e direções futuras\nA integração entre FOL e verificação formal enfrenta desafios significativos. A complexidade computacional da verificação cresce exponencialmente com o tamanho dos programas, exigindo técnicas de abstração e decomposição para escalabilidade.\nA usabilidade permanece um obstáculo para adoção ampla, requerendo conhecimento matemático especializado e ferramentas com interfaces ainda em evolução. Desenvolvimentos em automação inteligente, incluindo uso de aprendizado de máquina para geração de especificações e invariantes, prometem reduzir esta barreira.\nTendências emergentes incluem verificação contínua integrada a pipelines DevOps, synthesis automática de código a partir de especificações FOL, e aplicação a novos domínios como blockchain e sistemas de inteligência artificial.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html",
    "href": "09-desafios-logicos-enigmas-e-misterios.html",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "",
    "text": "12.1 O Mentiroso e o Verdadeiro\nVocê encontra dois habitantes: \\(A\\) e \\(B\\). Você sabe que um sempre diz a verdade e o outro sempre mente, mas você não sabe quem é quem. Você pergunta a \\(A\\): Você é o verdadeiro?. \\(A\\) responde, mas você não consegue ouvir a resposta dele. \\(B\\) então te diz: A disse que ele é o mentiroso.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html#o-mentiroso-e-o-verdadeiro",
    "href": "09-desafios-logicos-enigmas-e-misterios.html#o-mentiroso-e-o-verdadeiro",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "",
    "text": "12.1.1 Solução Intuitiva\n\\(B\\) deve ser o mentiroso e \\(A\\) deve ser o verdadeiro.\nRaciocínio: Se \\(A\\) fosse o verdadeiro, ele responderia Sim à pergunta. Se \\(A\\) fosse o mentiroso, ele mentiria e também responderia Sim. Logo, \\(A\\) sempre responde Sim à pergunta Você é o verdadeiro?.\nComo \\(B\\) diz que \\(A\\) disse que ele é o mentiroso, e sabemos que \\(A\\) respondeu Sim (não Sou mentiroso), então \\(B\\) está mentindo. Portanto, \\(B\\) é o mentiroso e \\(A\\) é o verdadeiro.\n\n\n12.1.2 Solução usando Lógica Proposicional\n\n12.1.2.1 Definições:\n\n\\(V_A\\): \\(A\\) é o verdadeiro;\n\\(M_A\\): \\(A\\) é o mentiroso;\n\n\\(V_B\\): \\(B\\) é o verdadeiro;\n\\(M_B\\): \\(B\\) é o mentiroso;\n\\(R_A\\): \\(A\\) respondeu Sim à pergunta Você é o verdadeiro?.\n\n\n\n12.1.2.2 Axiomas\n\n\\(V_A \\lor M_A\\) (A é verdadeiro ou mentiroso);\n\\(\\neg(V_A \\land M_A)\\) (A não é ambos);\n\\(V_B \\lor M_B\\) (B é verdadeiro ou mentiroso);\n\\(\\neg(V_B \\land M_B)\\) (B não é ambos);\n\\(V_A \\leftrightarrow \\neg V_B\\) (Exatamente um é verdadeiro);\n\\(V_A \\to R_A\\) (Se A é verdadeiro, ele responde Sim);\n\\(M_A \\to R_A\\) (Se A é mentiroso, ele também responde Sim, pois mente);\n\\(V_B \\to \\text{B reporta corretamente}\\) (Se B é verdadeiro, ele relata a verdade);\n\\(M_B \\to \\text{B reporta falsamente}\\) (Se B é mentiroso, ele mente).\n\n\n\n12.1.2.3 Fato Observado\n\\(B\\) diz: A disse que ele é o mentiroso (ou seja, \\(B\\) afirma que \\(A\\) disse Não).\n\n\n12.1.2.4 Prova\n\nPor (6) e (7): \\(R_A\\) é sempre verdadeiro (\\(A\\) sempre responde Sim);\n\\(B\\) afirma que \\(\\neg R_A\\) (\\(B\\) diz que \\(A\\) responde Não/Sou mentiroso);\nComo \\(R_A\\) é verdadeiro e \\(B\\) afirma \\(\\neg R_A\\), então \\(B\\) está mentindo;\nPortanto, \\(M_B\\) (\\(B\\) é o mentiroso);\nPor (5) e (4): \\(V_A\\) (\\(A\\) é o verdadeiro).\n\n\n\n12.1.2.5 Conclusão:\n\\[V_A \\land M_B\\]\n\\(A\\) é o verdadeiro e \\(B\\) é o mentiroso.\n\n\n\n12.1.3 Solução usando Lógica de Primeira Ordem\n\n12.1.3.1 Definições\n\n\\(V(x)\\): \\(x\\) é o verdadeiro;\n\\(M(x)\\): \\(x\\) é o mentiroso;\n\\(R(x, p)\\): \\(x\\) responde \\(p\\) à pergunta;\n\\(D(x, p)\\): \\(x\\) diz que \\(p\\).\n\n\n\n12.1.3.2 Axiomas\n\n\\(\\forall x (V(x) \\lor M(x))\\) (Todo indivíduo é verdadeiro ou mentiroso);\n\\(\\forall x \\neg(V(x) \\land M(x))\\) (Ninguém é ambos);\n\\((V(A) \\land M(B)) \\lor (M(A) \\land V(B))\\) (Exatamente um de cada tipo);\n\\(V(A) \\to R(A, \\text{_Sim_})\\) (Se A é verdadeiro, responde Sim);\n\\(M(A) \\to R(A, \\text{_Sim_})\\) (Se A é mentiroso, também responde Sim);\n\\(\\forall x \\forall p (V(x) \\to (D(x, p) \\leftrightarrow p))\\) (Verdadeiros dizem a verdade);\n\\(\\forall x \\forall p (M(x) \\to (D(x, p) \\leftrightarrow \\neg p))\\) (Mentirosos mentem).\n\n\n\n12.1.3.3 Fato Observado\n\\[D(B, R(A, \\text{_Não_}))\\]\n\\(B\\) afirma que \\(A\\) respondeu Não (disse ser mentiroso)\n\n\n12.1.3.4 Prova\n\nPor axiomas (4) e (5): \\(R(A, \\text{_Sim_})\\) é necessariamente verdadeiro;\nFato observado: \\(D(B, R(A, \\text{_Não_}))\\);\nComo \\(R(A, \\text{_Sim_})\\) é verdadeiro, então \\(R(A, \\text{_Não_})\\) é falso;\nB afirma algo falso: \\(D(B, \\text{falso})\\);\nPor axioma (6): Se \\(V(B)\\), então \\(D(B, p) \\leftrightarrow p\\);\n\nIsso implicaria \\(D(B, \\text{falso}) \\leftrightarrow \\text{falso}\\);\nLogo, \\(\\neg D(B, \\text{falso})\\);\nContradição com (4).\n\nPortanto, \\(\\neg V(B)\\), logo \\(M(B)\\) por axioma (1);\nPor axioma (3) e \\(M(B)\\): temos \\(V(A)\\);\n\n\n\n12.1.3.5 Conclusão\n\\[V(A) \\land M(B)\\]\n\\(A\\) é o verdadeiro e \\(B\\) é o mentiroso.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html#as-três-lâmpadas",
    "href": "09-desafios-logicos-enigmas-e-misterios.html#as-três-lâmpadas",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "12.2 As Três Lâmpadas",
    "text": "12.2 As Três Lâmpadas\nExistem três lâmpadas incandescentes em uma sala, e existem três interruptores fora da sala. Você pode manipular os interruptores o quanto quiser, mas só pode entrar na sala uma vez. Como você pode determinar qual interruptor opera qual lâmpada?\n\n12.2.1 Solução Intuitiva\nLigue o primeiro interruptor e espere 10 minutos. Depois desligue-o e ligue o segundo interruptor. Entre na sala imediatamente.\n\nA lâmpada que está acesa corresponde ao segundo interruptor;\nA lâmpada que está apagada e quente corresponde ao primeiro interruptor;\nA lâmpada que está apagada e fria corresponde ao terceiro interruptor.\n\n\n\n12.2.2 Formalização usando Lógica de Primeira Ordem\nDefinições:\n\n\\(S = \\{s_1, s_2, s_3\\}\\): conjunto de interruptores;\n\\(L = \\{l_1, l_2, l_3\\}\\): conjunto de lâmpadas;\n\\(\\text{Controla}(s, l)\\): interruptor \\(s\\) controla lâmpada \\(l\\);\n\\(\\text{Ligado}(s, t)\\): interruptor \\(s\\) está ligado no tempo \\(t\\);\n\\(\\text{Acesa}(l, t)\\): lâmpada \\(l\\) está acesa no tempo \\(t\\);\n\\(\\text{Quente}(l, t)\\): lâmpada \\(l\\) está quente no tempo \\(t\\).\n\nAxiomas:\n\n\\(\\forall s \\in S \\, \\exists! l \\in L \\, (\\text{Controla}(s, l))\\) (cada interruptor controla exatamente uma lâmpada);\n\\(\\forall l \\in L \\, \\exists! s \\in S \\, (\\text{Controla}(s, l))\\) (cada lâmpada é controlada por exatamente um interruptor)\n\\(\\forall s, l, t \\, (\\text{Controla}(s, l) \\land \\text{Ligado}(s, t) \\to \\text{Acesa}(l, t))\\);\n\\(\\forall s, l, t \\, (\\text{Controla}(s, l) \\land \\neg\\text{Ligado}(s, t) \\to \\neg\\text{Acesa}(l, t))\\);\n\\(\\forall l, t_1, t_2 \\, (\\text{Acesa}(l, t_1) \\land (t_2 - t_1 &lt; \\delta) \\land \\neg\\text{Acesa}(l, t_2) \\to \\text{Quente}(l, t_2))\\).\n\nna qual \\(\\delta\\) é o tempo de resfriamento.\nProcedimento:\n\n\\(t_0\\): Liga \\(s_1\\);\n\\(t_1 = t_0 + 10\\text{min}\\): Desliga \\(s_1\\), liga \\(s_2\\);\n\\(t_2 = t_1 + \\epsilon\\): Observa o estado das lâmpadas.\n\nDedução:\n\\[\\text{Controla}(s_2, l) \\leftrightarrow \\text{Acesa}(l, t_2)\\]\n\\[\\text{Controla}(s_1, l) \\leftrightarrow (\\neg\\text{Acesa}(l, t_2) \\land \\text{Quente}(l, t_2))\\]\n\\[\\text{Controla}(s_3, l) \\leftrightarrow (\\neg\\text{Acesa}(l, t_2) \\land \\neg\\text{Quente}(l, t_2))\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html#o-agricultor-a-raposa-o-ganso-e-o-grão",
    "href": "09-desafios-logicos-enigmas-e-misterios.html#o-agricultor-a-raposa-o-ganso-e-o-grão",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "12.3 O Agricultor, a Raposa, o Ganso e o Grão",
    "text": "12.3 O Agricultor, a Raposa, o Ganso e o Grão\nUm agricultor precisa atravessar um rio com uma raposa, um ganso e um saco de grãos. Seu barco só comporta ele mesmo e mais um item. Se deixados sozinhos: a raposa come o ganso, o ganso come o grão. Como transportar todos em segurança?\n\n12.3.1 Solução Intuitiva\n\nLeva o ganso para o outro lado;\nVolta sozinho;\nLeva a raposa para o outro lado;\nTraz o ganso de volta;\nLeva o grão para o outro lado;\nVolta sozinho;\nLeva o ganso para o outro lado.\n\n\n\n12.3.2 Formalização usando Lógica de Primeira Ordem\nDefinições:\n\n\\(E = \\{F, R, G, S\\}\\): Fazendeiro, Raposa, Ganso, Saco de grãos;\n\\(\\text{Margem}(x, t) \\in \\{0, 1\\}\\): margem onde \\(x\\) está no tempo \\(t\\);\n\\(\\text{Seguro}(t)\\): configuração é segura no tempo \\(t\\);\n\\(\\text{Viagem}(x, y, t)\\): \\(F\\) viaja com \\(y\\) (ou sozinho se \\(y = \\emptyset\\)) no tempo \\(t\\).\n\nAxiomas:\n\n\\(\\forall t \\, \\forall x, y \\in E \\setminus \\{F\\} \\, (\\text{Margem}(x, t) = \\text{Margem}(y, t) \\land x \\neq y \\to \\text{Margem}(F, t) = \\text{Margem}(x, t) \\lor \\neg\\text{Perigoso}(x, y))\\);\n\\(\\text{Perigoso}(R, G) = \\text{verdadeiro}\\) (raposa come ganso);\n\\(\\text{Perigoso}(G, S) = \\text{verdadeiro}\\) (ganso come grão);\n\\(\\forall t \\, (\\text{Seguro}(t) \\leftrightarrow \\neg\\exists x, y (\\text{Perigoso}(x, y) \\land \\text{Margem}(x, t) = \\text{Margem}(y, t) \\land \\text{Margem}(F, t) \\neq \\text{Margem}(x, t)))\\).\n\nEstado Inicial:\n\\[\\forall x \\in E \\, (\\text{Margem}(x, 0) = 0)\\]\nEstado Final Desejado:\n\\[\\forall x \\in E \\, (\\text{Margem}(x, t_{\\text{final}}) = 1)\\]\nSequência de Transições:\n\\[\n\\begin{align}\nt_0 &: \\text{Viagem}(F, G, t_0) \\to \\text{Margem}(F, t_1) = \\text{Margem}(G, t_1) = 1 \\\\\nt_1 &: \\text{Viagem}(F, \\emptyset, t_1) \\to \\text{Margem}(F, t_2) = 0 \\\\\nt_2 &: \\text{Viagem}(F, R, t_2) \\to \\text{Margem}(F, t_3) = \\text{Margem}(R, t_3) = 1 \\\\\nt_3 &: \\text{Viagem}(F, G, t_3) \\to \\text{Margem}(F, t_4) = \\text{Margem}(G, t_4) = 0 \\\\\nt_4 &: \\text{Viagem}(F, S, t_4) \\to \\text{Margem}(F, t_5) = \\text{Margem}(S, t_5) = 1 \\\\\nt_5 &: \\text{Viagem}(F, \\emptyset, t_5) \\to \\text{Margem}(F, t_6) = 0 \\\\\nt_6 &: \\text{Viagem}(F, G, t_6) \\to \\text{Margem}(F, t_7) = \\text{Margem}(G, t_7) = 1\n\\end{align}\n\\]\nVerificação:\n\\[\\forall t \\in \\{t_0, ..., t_7\\} \\, (\\text{Seguro}(t))\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html#o-problema-da-ponte-e-da-tocha",
    "href": "09-desafios-logicos-enigmas-e-misterios.html#o-problema-da-ponte-e-da-tocha",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "12.4 O Problema da Ponte e da Tocha",
    "text": "12.4 O Problema da Ponte e da Tocha\nQuatro pessoas (\\(A\\), \\(B\\), \\(C\\), \\(D\\)) precisam atravessar uma ponte à noite. A ponte suporta no máximo duas pessoas. Há apenas uma tocha, necessária para atravessar. Tempos de travessia: \\(A\\) = 1 min, \\(B\\) = 2 min, \\(C\\) = 5 min, \\(D\\) = 8 min. Quando duas pessoas atravessam juntas, movem-se na velocidade da mais lenta. Qual o tempo mínimo?\n\n12.4.1 Solução Intuitiva\n\n\\(A\\) e \\(B\\) atravessam (2 min);\n\\(A\\) volta com a tocha (1 min);\n\n\\(C\\) e \\(D\\) atravessam (8 min);\n\\(B\\) volta com a tocha (2 min);\n\\(A\\) e \\(B\\) atravessam (2 min).\n\nTempo total: \\(2 + 1 + 8 + 2 + 2 = 15\\) minutos\n\n\n12.4.2 Formalização usando Lógica de Primeira Ordem\nDefinições:\n\n\\(P = \\{A, B, C, D\\}\\): conjunto de pessoas;\n\\(\\text{Tempo}(x) = \\{1, 2, 5, 8\\}\\): tempo individual de travessia;\n\\(\\text{Lado}(x, t) \\in \\{0, 1\\}\\): lado da ponte onde \\(x\\) está no tempo \\(t\\);\n\\(\\text{Tocha}(t) \\in \\{0, 1\\}\\): lado onde a tocha está no tempo \\(t\\);\n\\(\\text{Atravessa}(X, t, \\Delta t)\\): conjunto \\(X \\subseteq P\\) atravessa no intervalo \\([t, t+\\Delta t]\\).\n\nAxiomas:\n\n\\(|X| \\leq 2\\) para qualquer travessia;\n\\(\\forall X, t \\, (\\text{Atravessa}(X, t, \\Delta t) \\to \\text{Tocha}(t) = \\text{Lado}(x, t) \\, \\forall x \\in X)\\);\n\\(\\Delta t = \\max_{x \\in X} \\text{Tempo}(x)\\) para travessia do conjunto \\(X\\);\n\\(\\forall t \\, (\\text{Tocha}(t+\\Delta t) = 1 - \\text{Tocha}(t))\\) após travessia.\n\nEstado Inicial:\n\\[\\forall x \\in P \\, (\\text{Lado}(x, 0) = 0) \\land \\text{Tocha}(0) = 0\\]\nEstado Final:\n\\[\\forall x \\in P \\, (\\text{Lado}(x, T) = 1)\\]\nSequência Ótima:\n\\[\n\\begin{align}\n&\\text{Atravessa}(\\{A, B\\}, 0, 2) \\\\\n&\\text{Atravessa}(\\{A\\}, 2, 1) \\\\\n&\\text{Atravessa}(\\{C, D\\}, 3, 8) \\\\\n&\\text{Atravessa}(\\{B\\}, 11, 2) \\\\\n&\\text{Atravessa}(\\{A, B\\}, 13, 2)\n\\end{align}\n\\]\nFunção Objetivo:\n\\[\\text{Minimizar } T = \\sum_{i} \\Delta t_i = 15\\]",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html#o-problema-de-monty-hall",
    "href": "09-desafios-logicos-enigmas-e-misterios.html#o-problema-de-monty-hall",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "12.5 O Problema de Monty Hall",
    "text": "12.5 O Problema de Monty Hall\nEm um game show, há três portas. Atrás de uma está um prêmio, atrás das outras duas estão cabras. Você escolhe uma porta. O apresentador (que sabe onde está o prêmio) abre uma das portas não escolhidas, revelando uma cabra. Ele pergunta se você quer trocar para a outra porta fechada. Você deve trocar?\n\n12.5.1 Solução Intuitiva\nSim, sempre trocar! A probabilidade de ganhar trocando é \\(2/3\\), enquanto mantendo é \\(1/3\\).\nRaciocínio: Inicialmente, a chance do prêmio estar na porta escolhida é \\(1/3\\) e nas outras duas é \\(2/3\\). Quando o apresentador revela uma cabra, ele fornece informação sobre as portas não escolhidas, mas não sobre a escolhida. A probabilidade \\(2/3\\) se concentra na porta restante não escolhida.\n\n\n12.5.2 Formalização usando Lógica de Primeira Ordem e Probabilidades\nDefinições:\n\n\\(D = \\{d_1, d_2, d_3\\}\\): conjunto de portas;\n\\(\\text{Prêmio}(d)\\): o prêmio está atrás da porta \\(d\\);\n\\(\\text{Escolha}_1 = d_i\\): escolha inicial do jogador;\n\\(\\text{Abre}(d_j)\\): apresentador abre porta \\(d_j\\);\n\\(\\text{Escolha}_2 \\in \\{\\text{Manter}, \\text{Trocar}\\}\\): decisão final.\n\nAxiomas:\n\n\\(\\exists! d \\in D \\, (\\text{Prêmio}(d))\\) (exatamente uma porta tem o prêmio);\n\\(P(\\text{Prêmio}(d_i)) = 1/3\\) para todo \\(i \\in \\{1, 2, 3\\}\\) (distribuição uniforme inicial);\n\\(\\text{Abre}(d_j) \\to \\neg\\text{Prêmio}(d_j) \\land d_j \\neq \\text{Escolha}_1\\);\nSe \\(\\text{Prêmio}(\\text{Escolha}_1)\\), então \\(P(\\text{Abre}(d_j) | \\text{Prêmio}(\\text{Escolha}_1)) = 1/2\\) para cada porta \\(d_j\\) com cabra;\nSe \\(\\neg\\text{Prêmio}(\\text{Escolha}_1)\\), então o apresentador deve abrir a única outra porta com cabra.\n\nAnálise Probabilística:\nSem perda de generalidade, assuma \\(\\text{Escolha}_1 = d_1\\) e \\(\\text{Abre}(d_2)\\).\n\\[P(\\text{Prêmio}(d_1) | \\text{Abre}(d_2)) = \\frac{P(\\text{Abre}(d_2) | \\text{Prêmio}(d_1)) \\cdot P(\\text{Prêmio}(d_1))}{P(\\text{Abre}(d_2))}\\]\n\\[= \\frac{(1/2) \\cdot (1/3)}{1/2} = \\frac{1}{3}\\]\n\\[P(\\text{Prêmio}(d_3) | \\text{Abre}(d_2)) = \\frac{P(\\text{Abre}(d_2) | \\text{Prêmio}(d_3)) \\cdot P(\\text{Prêmio}(d_3))}{P(\\text{Abre}(d_2))}\\]\n\\[= \\frac{1 \\cdot (1/3)}{1/2} = \\frac{2}{3}\\]\nConclusão:\n\\[P(\\text{Ganhar} | \\text{Trocar}) = \\frac{2}{3} &gt; P(\\text{Ganhar} | \\text{Manter}) = \\frac{1}{3}\\]\nPortanto, a estratégia ótima é sempre trocar.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html#o-mistério-da-mansão-hollow-um-desafio-para-detetives-lógicos",
    "href": "09-desafios-logicos-enigmas-e-misterios.html#o-mistério-da-mansão-hollow-um-desafio-para-detetives-lógicos",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "12.6 O Mistério da Mansão Hollow – Um Desafio para Detetives Lógicos",
    "text": "12.6 O Mistério da Mansão Hollow – Um Desafio para Detetives Lógicos\n:::  :::\nObjetivo: aplicar os princípios da Lógica Proposicional e de predicados para analisar um conjunto complexo de informações, identificar contradições, realizar deduções formais e solucionar um enigma.\nDescrição: a esforçada leitora foi convidada a investigar um intrigante mistério ocorrido na antiga Mansão Hollow. O renomado inventor, Sir Arthur Blackwood, desapareceu em circunstâncias suspeitas, deixando para trás uma série de pistas, depoimentos de funcionários e familiares, e alguns bilhetes enigmáticos. A polícia local está confusa com a quantidade de informações, algumas aparentemente contraditórias. Você deve montar uma equipe de detetives e superar o famoso detetive Hercule Poirot. Para isso deverá:\n\nAnalisar cuidadosamente todo o material fornecido (descrições de personagens, mapa da mansão, horários, depoimentos, bilhetes).\nFormalizar as informações relevantes utilizando sentenças da Lógica Proposicional e, quando aplicável, da lógica de predicados.\nConstruir tabelas-verdade e/ou aplicar regras de inferência para verificar a consistência das informações e deduzir novos fatos.\nIdentificar o(s) responsável(is) pelo desaparecimento do Sr. Blackwood (ou determinar o que de fato aconteceu), justificando cada passo da sua conclusão com base nas deduções lógicas realizadas.\n\nA seguir a descrição do caso, o mapa da mansão e os depoimentos dos envolvidos.\n\n12.6.1 O Mistério da Mansão Hollow: O Desaparecimento de Sir Arthur Blackwood\nData do Incidente: segunda-feira, 18 de Maio de 1935. Local: Mansão Hollow, uma propriedade rural isolada. Vítima (Desaparecido): Sir Arthur Blackwood, renomado inventor, 58 anos.\n1. Descrições dos Personagens:\n\nSir Arthur Blackwood: O inventor desaparecido. Gênio excêntrico e recluso, conhecido por sua mente brilhante e comportamento imprevisível. Estava trabalhando febrilmente em um novo projeto secreto chamado Quimera.\nSra. Eleanor Blackwood (50 anos): Esposa de Arthur. Uma mulher elegante e ambiciosa, visivelmente preocupada com a reputação e fortuna da família. Ela teme que o comportamento errático de Arthur possa arruiná-los.\nDr. Alistair Finch (45 anos): Um cientista brilhante, antigo protegido de Arthur, mas que se tornou seu principal rival acadêmico e comercial. Chegou à mansão no dia do desaparecimento, alegando buscar uma reconciliação e possível colaboração.\nMiss Clara Evans (28 anos): A jovem e inteligente assistente pessoal de Arthur. Dedicada e leal, trabalhava em estreita colaboração com ele no projeto Quimera e conhecia muitos de seus segredos.\nSr. Reginald Reggie Croft (65 anos): O mordomo, trabalha para a família Blackwood há mais de trinta anos. É um homem discreto, observador e extremamente leal à memória do falecido pai de Arthur, mas demonstra certa reserva em relação ao próprio Arthur.\nSra. Beatrice Croft (62 anos): Esposa de Reggie, a cozinheira da mansão. Conhece todos os cantos da casa e os hábitos de seus ocupantes. É prática e não se deixa levar por fantasias.\n\nNossos personagens podem ser vistos na imagem abaixo:\n:::  :::\n2. Mapa da Mansão Hollow (Descrição Textual): A Mansão Hollow é uma construção vitoriana de dois andares, com um vasto terreno.\n\nTérreo:\n\nHall de Entrada: Amplo, com piso de mármore, uma imponente escadaria de carvalho que leva ao andar superior. Portas levam à biblioteca (esquerda), sala de estar (direita) e, ao fundo, um corredor para a sala de jantar e a ala de serviço/cozinha.\nBiblioteca: Paredes forradas de estantes com livros antigos e científicos. Uma grande escrivaninha de mogno, poltronas de couro e uma lareira. Duas janelas altas com vista para o jardim da frente.\nSala de Estar: Mobiliário luxuoso, mas um pouco antiquado. Um piano de cauda, lareira e janelas com vista para o jardim lateral e o gazebo.\nSala de Jantar: Uma longa mesa de jantar polida, prataria reluzente. Acesso direto à cozinha.\nCozinha: Grande e funcional, com uma mesa rústica ao centro. Portas para a despensa, os aposentos dos Croft e uma saída para o jardim dos fundos/horta.\nLaboratório do Sr. Blackwood: Localizado no final de um corredor isolado, partindo do hall, perto da escada de serviço. A porta possui uma fechadura especial de alta segurança projetada pelo próprio Arthur. O interior é um caos organizado de equipamentos eletrônicos, protótipos mecânicos, quadros com equações e ferramentas. Possui uma única janela reforçada que dá para o jardim dos fundos. Este é o local principal da investigação inicial.\nEscritório do Sr. Blackwood: Uma sala menor, anexa ao laboratório, acessível apenas por uma porta dentro do laboratório. Mais organizada, com arquivos, patentes, um cofre e um computador.\n\nAndar Superior:\n\nQuarto Principal (Sr. e Sra. Blackwood): Espaçoso, com uma grande cama de dossel, penteadeira, armários embutidos e um banheiro privativo. Uma varanda com vista para o jardim da frente.\nQuarto de Hóspedes: Onde Dr. Finch deixou seus pertences (embora não tenha passado a noite). Confortável, com uma cama de solteiro, escrivaninha e janela para o jardim lateral.\nQuarto de Clara Evans: Menor e mais simples, localizado perto da escada de serviço, com vista para os fundos.\nAposentos do Mordomo e da Cozinheira (Sr. e Sra. Croft): Localizados na ala de serviço, acima da cozinha.\n\nExterior:\n\nJardim da Frente: Um gramado bem cuidado com um caminho circular de cascalho que leva à porta principal. Ladeado por sebes altas.\nJardim Lateral: Menos formal, com um gazebo antigo coberto de hera e canteiros de rosas.\nJardim dos Fundos: Uma área mais extensa e um pouco mais selvagem, com árvores antigas, uma pequena horta cultivada pela Sra. Croft e, nos limites da propriedade, uma velha estufa de vidro abandonada e parcialmente coberta por vegetação.\n\n\nAlguns ambientes da Mansão Hollow podem ser vistos na imagem abaixo:\n:::  :::\n3. Linha do Tempo (Segunda-feira, 18 de Maio de 1935)\n\n08:00: Café da manhã servido na sala de jantar. Sra. Blackwood preside. Sr. Blackwood não comparece, o que, segundo Sra. Blackwood, era comum quando ele estava imerso em trabalho.\n09:00: Clara Evans leva uma bandeja com café e torradas para o laboratório do Sr. Blackwood.\n10:00: Dr. Alistair Finch chega pontualmente à Mansão Hollow. É recebido pelo mordomo, Sr. Croft, e anunciado à Sra. Blackwood.\n10:15 - 11:00 (aprox.): Dr. Finch e Sra. Blackwood conversam na sala de estar.\n11:00: Sra. Blackwood acompanha Dr. Finch até a porta do laboratório do Sr. Blackwood. Ela bate. Uma voz abafada, identificada por ela como sendo de Arthur, diz: Estou no meio de algo crítico! Não me perturbem agora!. Dr. Finch parece contrariado.\n11:05 - 13:00: Período decisivo com movimentações diversas e álibis a serem verificados.\n13:00: O almoço é servido. Sr. Blackwood novamente não aparece.\n14:00: Sra. Blackwood, demonstrando crescente preocupação, pede a Sr. Croft que vá verificar pessoalmente o Sr. Blackwood em seu laboratório.\n14:05: Sr. Croft dirige-se ao laboratório. Encontra a porta especial entreaberta. A fechadura de alta segurança parece ter sido arranhada (marcas de tentativa de arrombamento), mas está destrancada (possivelmente aberta corretamente após a tentativa de arrombamento). O interior do laboratório está em grande desordem: papéis e diagramas espalhados pelo chão, algumas ferramentas fora do lugar, uma cadeira virada. Sr. Blackwood não está em lugar nenhum. A janela dos fundos do laboratório está destrancada e aberta. Não há sinais óbvios de luta violenta (ex: sangue).\n14:15: Sra. Blackwood, após ser informada por Sr. Croft, instrui-o a chamar a polícia local.\n17:00: A notícia do desaparecimento e a natureza peculiar do caso chegam aos ouvidos de Hercule Poirot, que está concluindo um caso em uma cidade vizinha. Ele informa que só poderá dedicar-se ao mistério da Mansão Hollow na manhã seguinte. (Vocês têm até lá para resolver!)\n\n4. Depoimentos Iniciais (Coletados apressadamente pelo Sargento Davis, da polícia local):\n\nSra. Eleanor Blackwood:\n\nArthur estava impossível nas últimas semanas, totalmente absorvido pelo tal projeto ‘Quimera’. Falava coisas sem sentido sobre revolucionar o mundo, mas também sobre pessoas que queriam roubá-lo. Ele sempre foi um pouco… dramático.;\nQuando bati à porta do laboratório às 11:00, ouvi claramente Arthur dizer para não ser perturbado. Sim, a voz parecia um pouco abafada, mas era ele. Dr. Finch estava ao meu lado.;\nDepois disso, subi para meus aposentos para descansar e escrever algumas cartas. Não vi mais o Dr. Finch até a hora do almoço.;\nA fechadura do laboratório é uma invenção do próprio Arthur. Apenas ele possuía a chave mestra. Ouvi dizer que Clara talvez soubesse algum truque para abri-la, mas forçá-la… faria um barulho terrível, não acha?;\nDesaparecer assim… não é do feitio de Arthur, a menos que seja parte de algum plano mirabolante dele. Ou então algo terrível aconteceu..\n\nDr. Alistair Finch:\n\nEu vim em uma missão de paz, acreditem. Nossas divergências passadas foram puramente intelectuais. Eu esperava que pudéssemos colaborar. A ideia de roubar o trabalho de Arthur é um insulto.\nSim, a Sra. Blackwood me acompanhou até a porta do laboratório. Ouvi uma voz masculina dizer para não sermos inoportunos. Não posso jurar que era Arthur, a voz estava abafada, como disse a Sra. Blackwood.\nApós a recusa, senti-me um pouco desconfortável. Decidi caminhar pelos jardins para espairecer, entre aproximadamente 11:05 e 12:45. Andei pela frente da casa e também pelo jardim lateral, perto do gazebo. O tempo estava agradável.\nNão vi ninguém suspeito. Vi o mordomo, Sr. Croft, por um instante, perto da entrada lateral da casa, por volta das 11:20. Ele parecia estar carregando uma caixa ou algo similar em direção à parte de trás da casa ou à adega.\nEu nunca tocaria na fechadura do laboratório de Arthur sem permissão. Seria uma violação imperdoável da ética científica.\n\nMiss Clara Evans:\n\nSr. Blackwood estava muito pressionado, mas também excitado com o ‘Quimera’. Ele dizia que mudaria tudo. Ele confiava em mim implicitamente.\nSim, ele temia que o Dr. Finch, ou outros, pudessem tentar se apropriar de suas descobertas. Ele tomava muitas precauções.\nQuando levei seu café às 09:00, ele estava um pouco agitado, mas lúcido. Disse-me: ‘Clara, hoje é um dia de grandes decisões. Lembre-se dos nossos protocolos.’\nEntre 11:00 e 13:00, estive principalmente no escritório anexo ao laboratório, compilando dados. A porta entre o escritório e o laboratório estava fechada na maior parte do tempo para que ele tivesse silêncio. Saí brevemente, por volta das 11:30, para ir à biblioteca buscar o ‘Compêndio de Ligas Metálicas Raras’. Fiquei lá uns 15, talvez 20 minutos. Não cruzei com ninguém no corredor ou na biblioteca.\nO laboratório tem um bom isolamento acústico, especialmente com a porta do escritório fechada. Não ouvi nenhum barulho de arrombamento. A fechadura especial é complexa; apenas Sr. Blackwood tinha a chave. Eu conheço o procedimento de abertura manual de emergência, mas é uma sequência demorada e específica.\n\nSr. Reginald Reggie Croft (Mordomo):\n\nDr. Finch chegou às 10:00. Parecia um pouco nervoso, na minha opinião. Ele e a patroa conversaram na sala de estar por um bom tempo.\nPor volta das 11:00, eu estava no hall polindo a prata, e ouvi as vozes da Sra. Blackwood e do Dr. Finch perto do corredor do laboratório. Não prestei muita atenção ao que foi dito. Logo depois, vi a Sra. Blackwood subir a escadaria principal.\nDe fato, por volta das 11:15, eu estava transportando uma caixa de garrafas de vinho da entrada de serviço lateral para a adega no porão. Nesse momento, vi o Dr. Finch caminhando pelo jardim da frente, perto do portão principal. Ele olhava muito para o relógio.\nQuando fui chamado pela Sra. Blackwood às 14:00, encontrei a porta do laboratório como descrito: entreaberta, com arranhões na fechadura, mas destrancada. O Sr. Blackwood era metódico. Se ele não queria ser perturbado, ele trancava a porta de uma forma que ninguém entraria.\n\nSra. Beatrice Croft (Cozinheira):\n\nDa cozinha, não se ouve muito do resto da casa, a menos que seja uma gritaria. Estive ocupada com o almoço toda a manhã.\nSr. Blackwood não aparecer para as refeições não era novidade quando estava às voltas com suas invenções malucas.\nUma coisa estranha: Miss Evans passou rapidamente pela cozinha por volta das 12:50. Parecia muito pálida e apressada. Perguntei se estava tudo bem, e ela murmurou algo sobre ir verificar se o Sr. Blackwood queria que o almoço fosse servido no laboratório. Ela voltou alguns minutos depois, ainda mais pálida, e disse que ele não tinha respondido aos chamados dela na porta do laboratório e que era melhor não insistir. Achei estranho ela não ter comentado isso com a Sra. Blackwood imediatamente, antes do alarme oficial.\nA janela do laboratório? Sim, dá para uma parte mais isolada do jardim dos fundos, perto da minha horta. Se alguém pulou por ali, e se esgueirou pelas árvores, poderia sumir sem ser visto da casa principal.\n\n\n5. Pistas e Bilhetes Enigmáticos:\n\nPista 1: Papel Amassado na Lixeira do Laboratório: Um pequeno pedaço de papel de anotações, claramente arrancado de um bloco maior, contém a seguinte mensagem escrita à mão por Sr. Blackwood (caligrafia confirmada):\n\nSe A implica B, e o Corvo visita o Ninho, então a Hipótese se confirma. A negação do consequente é o único caminho seguro. Sigma Ativado.\n\nPista 2: Objeto Encontrado no Chão do Laboratório, Perto da Mesa Principal: Um pequeno e incomum botão de metal fosco, com um desenho de uma engrenagem estilizada. Não parece pertencer a nenhuma roupa do Sr. Blackwood, nem faz parte do vestuário usual dos funcionários.\nPista 3: Anotação na Margem de um Livro na Biblioteca: No livro Compêndio de Ligas Metálicas Raras (o mesmo que Clara Evans mencionou ter pego), na página sobre o Bismuto, há uma pequena anotação a lápis, quase imperceptível:\n\nOnde o passado encontra o futuro, a reflexão é a chave. \\((\\neg P \\vee Q)\\) é equivalente a ? A caligrafia parece ser de Sr. Blackwood.\n\nPista 4: Marca Estranha no Batente da Janela Aberta do Laboratório: Do lado de fora do batente da janela do laboratório, há uma leve marca de fuligem ou graxa escura, como se algo metálico e sujo tivesse sido apoiado ali brevemente.\nPista 5: Na Estufa Abandonada (Jardim dos Fundos): Dentro da estufa, sobre uma bancada empoeirada, alguém desenhou com o dedo na poeira um símbolo: um triângulo equilátero com um pequeno círculo no centro. Ao lado do desenho, um único fósforo queimado. Não há outras pegadas recentes visíveis devido ao solo irregular e coberto de folhas secas.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "09-desafios-logicos-enigmas-e-misterios.html#solução-do-mistério-da-mansão-hollow-1935",
    "href": "09-desafios-logicos-enigmas-e-misterios.html#solução-do-mistério-da-mansão-hollow-1935",
    "title": "12  Desafios, Problemas e Mistérios",
    "section": "12.7 Solução do Mistério da Mansão Hollow (1935)",
    "text": "12.7 Solução do Mistério da Mansão Hollow (1935)\n\n12.7.1 Análise Intuitiva\n\n12.7.1.1 Avaliação das Evidências Físicas\nA cena do crime apresenta uma combinação peculiar de elementos que sugerem tanto violência quanto planejamento meticuloso:\n\nFechadura arranhada mas destrancada: Indica tentativa inicial de arrombamento seguida de abertura correta. Apenas duas pessoas conheciam o mecanismo: Sir Arthur e Clara (procedimento de emergência).\nLaboratório em desordem controlada: Papéis espalhados e cadeira virada sugerem encenação - uma luta real deixaria mais vestígios (sangue, objetos quebrados).\nJanela aberta com marca de graxa: A marca indica que algo mecânico foi apoiado ali - possivelmente equipamento do projeto Quimera sendo removido.\nBotão com engrenagem: Design industrial não corresponde a roupas vitorianas. Provavelmente de um uniforme de trabalho ou equipamento técnico.\n\n\n\n12.7.1.2 Análise Comportamental\nClara Evans - Padrão Suspeito:\n\n09:00: Recebe mensagem críptica sobre protocolos;\n11:30-11:50: Vai à biblioteca buscar livro específico onde há pista;\n12:50: Passa pálida e apressada pela cozinha;\n12:55: Verifica laboratório mas não alerta ninguém;\nConhece procedimento de emergência da fechadura.\n\nDr. Finch - Bode Expiatório Perfeito:\n\nMotivo claro (rivalidade);\nOportunidade (presente na mansão);\nVisto pelo mordomo às 11:20 nos jardins;\nNega veementemente qualquer envolvimento.\n\n\n\n12.7.1.3 Interpretação das Pistas Enigmáticas\nPista 1: A negação do consequente é o único caminho seguro. Sigma Ativado.\n\nReferência a modus tollens em lógica: se \\(P\\rightarrow Q\\) e \\(\\neg Q\\), então \\(\\neg P\\);\nSigma pode ser código para protocolo de evacuação;\nMensagem: Se ameaçado, negue tudo através do desaparecimento.\n\nPista 3: \\((\\neg P \\lor Q)\\) é equivalente a?\n\nEquivalente a \\((P \\to Q)\\) (implicação material);\nLocalização no livro que Clara pegou não é coincidência;\nConfirmação de que ela deveria seguir o plano.\n\nPista 5: Triângulo com círculo na estufa\n\nSímbolo alquímico/científico;\nLocal de encontro pré-combinado;\nFósforo queimado: sinal foi deixado recentemente.\n\n\n\n\n12.7.2 Solução Formal com Lógica (Versão Detalhada)\n\n12.7.2.1 Definições\nConstantes:\n\n\\(a\\): Sir Arthur Blackwood;\n\\(c\\): Clara Evans;\n\\(f\\): Dr. Finch;\n\\(L\\): Laboratório;\n\\(P_1, P_3, P_5\\): As pistas 1, 3 e 5;\n\\(Plano_\\Sigma\\): O plano de desaparecimento.\n\nPredicados:\n\n\\(\\text{ConheceSegredo}(x, s)\\): pessoa \\(x\\) conhece segredo \\(s\\);\n\\(\\text{ExecutouAção}(x, a)\\): pessoa \\(x\\) executou ação \\(a\\);\n\\(\\text{É_Instrução}(p, de, para)\\): \\(p\\) é uma instrução de \\(de\\) para \\(para\\);\n\\(\\text{CooperaCom}(x, y)\\): \\(x\\) coopera com \\(y\\);\n\\(\\text{FoiSequestrado}(x)\\): \\(x\\) foi sequestrado;\n\\(\\text{EncenouFuga}(x)\\): \\(x\\) encenou a própria fuga.\n\n\n\n12.7.2.2 Axiomas e Observações\nA1: \\(\\text{ConheceSegredo}(a, \\text{fechadura}) \\land \\text{ConheceSegredo}(c, \\text{fechadura})\\);\nA2: \\(\\forall x \\, (\\text{ExecutouAção}(x, \\text{abrir\\_corretamente}) \\to \\text{ConheceSegredo}(x, \\text{fechadura}))\\);\nA3: \\(\\forall x \\, (\\text{Inocente}(x) \\land \\text{DescobreCrime}(x) \\to \\text{ExecutouAção}(x, \\text{alertar}))\\);\nO1: \\(\\text{Porta\\_arranhada} \\land \\text{Porta\\_destrancada}\\);\nO2: \\(\\neg\\text{SinaisDeLutaReal}(L)\\);\nO3: \\(\\text{Observou}(c, \\text{situação\\_no\\_lab}) \\land \\neg \\text{ExecutouAção}(c, \\text{alertar})\\);\nO4: A pista \\(P_1\\) (Sigma Ativado) e \\(P_3\\) (lógica) são mensagens complexas. A pista \\(P_5\\) é um sinal. A ação de \\(c\\) de buscar o livro com \\(P_3\\) conecta-a ao plano.\n\n\n12.7.2.3 Dedução\nPasso 1: Análise da Fechadura\nA observação \\(O_1\\) implica duas ações distintas:\n\\[\\text{Porta\\_arranhada} \\land \\text{Porta\\_destrancada} \\to \\exists x, y \\, (\\text{ExecutouAção}(x, \\text{tentar\\_forçar}) \\land \\text{ExecutouAção}(y, \\text{abrir\\_corretamente}))\\]\nDe \\(A_1\\) e \\(A_2\\), concluímos que o agente \\(y\\) que abriu corretamente a porta pertence ao conjunto \\(\\{a, c\\}\\). Isso limita os atores com acesso legítimo.\nPasso 2: Análise do Comportamento de Clara (Modus Tollens)\nTemos a observação \\(O_3\\): Clara viu a situação e não alertou ninguém. Formalmente: \\(\\neg \\text{ExecutouAção}(c, \\text{alertar})\\). Usando a contrapositiva do Axioma A3 ($ B A $):\n\\[\\neg \\text{ExecutouAção}(c, \\text{alertar}) \\to \\neg(\\text{Inocente}(c) \\land \\text{DescobreCrime}(c))\\]\nPela Lei de De Morgan, isso é equivalente a:\n\\[\\neg \\text{Inocente}(c) \\lor \\neg \\text{DescobreCrime}(c)\\]\nEsta disjunção é fundamental: ou Clara não é inocente (é cúmplice) ou ela não descobriu um crime (porque já sabia o que estava a acontecer). Ambas as vias apontam para o seu envolvimento.\nPasso 3: Estabelecimento da Cooperação (Análise das Pistas)\nEste passo conecta o plano (pistas) a Arthur e Clara.\n3.1. As pistas \\(P_1\\), \\(P_3\\), \\(P_5\\), devido à sua natureza lógica e coordenada, não são aleatórias. Elas constituem um plano intencional: \\(\\text{FormamPlano}(P_1, P_3, P_5, Plano_\\Sigma)\\).\n3.2. A ação de Clara de ir diretamente ao local da Pista 3 (o livro), após receber a mensagem sobre protocolos, não é coincidência. Isso estabelece que ela é a destinatária do plano: \\(\\text{É\\_Instrução}(Plano_\\Sigma, a, c)\\).\n3.3. A partir da conclusão do Passo 2 (\\(\\neg \\text{Inocente}(c) \\lor \\neg \\text{DescobreCrime}(c)\\)) e do facto de que ela era a destinatária do plano (3.2), podemos inferir que ela agiu de acordo com o plano.\n\\[\n\\text{É\\_Instrução}(Plano_\\Sigma, a, c) \\land \\text{AçõesConsistentesComPlano}(c) \\to \\text{CooperaCom}(c, a)\n\\]\nPasso 4: Exclusão da Hipótese de Sequestro (Silogismo Disjuntivo)\nO mistério central pode ser expresso como uma disjunção: \\(\\text{FoiSequestrado}(a) \\lor \\text{EncenouFuga}(a)\\).\n4.1. Um sequestro real (\\(\\text{FoiSequestrado}(a)\\)) implicaria evidências de violência real ou uma ameaça externa.\n4.2. Temos a observação \\(O_2\\), \\(\\neg\\text{SinaisDeLutaReal}(L)\\). A voz abafada (explicada pela tecnologia de 1935) e a cooperação de Clara (Passo 3) são evidências de um plano interno, não de um ataque externo.\n4.3. Portanto, a premissa para um sequestro é falsa. Podemos concluir com alta confiança: \\(\\neg\\text{FoiSequestrado}(a)\\).\n4.4. Aplicando a regra do silogismo disjuntivo: Se temos \\((P \\lor Q)\\) e sabemos \\((\\neg P)\\), podemos concluir \\(Q\\).\n\\[\n(\\text{FoiSequestrado}(a) \\lor \\text{EncenouFuga}(a)) \\land \\neg\\text{FoiSequestrado}(a) \\to \\text{EncenouFuga}(a)\n\\]\n\n\n12.7.2.4 Conclusão\nA dedução formal, decomposta em passos rigorosos, leva à seguinte conclusão inevitável:\n\\[\n\\boxed{\\text{EncenouFuga}(a) \\land \\text{CooperaCom}(c, a) \\land \\text{ExecutouAção}(f, \\text{tentar\\_forçar})}\n\\]\n\n\n\n12.7.3 Teoria Final\nSir Arthur Blackwood orquestrou sua própria fuga para proteger o projeto Quimera da espionagem industrial. Ele:\n\nPreparou um gravador de fio para responder às 11:00;\nDeixou pistas codificadas para Clara;\nEscapou pela janela com equipamento essencial (marca de graxa);\nFoi para a estufa (ponto de encontro).\n\nClara Evans foi cúmplice essencial:\n\nRecebeu instruções pela manhã;\nConfirmou o plano via livro;\nAbriu a porta após as tentativas de Finch;\nVerificou se tudo estava pronto;\nManteve a farsa.\n\nDr. Finch tentou roubar o projeto:\n\nArranhões provam tentativa de invasão;\nMas chegou tarde demais;\nTornou-se o suspeito perfeito.",
    "crumbs": [
      "Aplicações Avançadas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Desafios, Problemas e Mistérios</span>"
    ]
  },
  {
    "objectID": "01-Sol-Proposicional.html",
    "href": "01-Sol-Proposicional.html",
    "title": "13  Lógica Proposicional Chapter 4",
    "section": "",
    "text": "13.1 Exercícios: Sintaxe e Fórmulas Bem Formadas\nJustificativa: \\(a\\), \\(f(b)\\) e \\(c\\) são termos. \\(P\\) é um símbolo de predicado de aridade 3, aplicado a 3 termos, formando a fórmula atômica \\(P(a, f(b), c)\\). O operador de negação \\(\\neg\\) é aplicado a esta fórmula atômica, o que é uma regra de formação válida.\nJustificativa: Falta um conectivo lógico (como \\(\\wedge\\), \\(\\vee\\), \\(\\rightarrow\\)) entre as fórmulas \\(\\forall x P(x)\\) e \\(Q(a)\\). Duas fórmulas devem ser unidas por um conectivo para formar uma nova fórmula.\nJustificativa: \\(f(x)\\) é um termo, não uma fórmula. Conectivos lógicos como \\(\\rightarrow\\) devem conectar fórmulas. Um termo não pode ser um dos lados de uma implicação.\nJustificativa: \\(P(x)\\) é uma fórmula atômica e \\(\\forall y Q(y)\\) também é uma fórmula. Elas estão corretamente unidas pelo conectivo \\(\\vee\\).\nNão, ela não é uma sentença. Uma sentença é uma FBF que não possui variáveis livres. Nesta fórmula, a variável \\(x\\) no predicado \\(P(x)\\) é uma variável livre, pois não está no escopo de nenhum quantificador (\\(\\forall x\\) ou \\(\\exists x\\)).\nJustificativa: Os argumentos de um predicado devem ser termos (variáveis, constantes ou funções). Um quantificador como \\(\\forall x\\) não é um termo e não pode aparecer dentro dos parênteses de um predicado.\nJustificativa: A estrutura segue todas as regras. \\(\\exists x P(f(z), x)\\) é uma FBF, sua negação também é. \\(R(z)\\) é uma FBF. As duas estão corretamente conectadas pelo bicondicional \\(\\leftrightarrow\\), e toda a expressão está corretamente no escopo do quantificador \\(\\forall z\\).\nJustificativa: A expressão dentro dos parênteses, \\((P(x) \\wedge )\\), está sintaticamente incorreta. O conectivo de conjunção \\(\\wedge\\) é binário e requer uma fórmula em ambos os lados. Ele não pode ser seguido por um parêntese de fechamento.",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Lógica Proposicional @sec-logica-proposicional</span>"
    ]
  },
  {
    "objectID": "01-Sol-Proposicional.html#exercícios-sintaxe-e-fórmulas-bem-formadas",
    "href": "01-Sol-Proposicional.html#exercícios-sintaxe-e-fórmulas-bem-formadas",
    "title": "13  Lógica Proposicional Chapter 4",
    "section": "",
    "text": "Solução:\n\n\nVariáveis: \\(x\\);\nConstantes: \\(a\\);\nPredicados: \\(P\\), \\(Q\\);\nConectivos: \\(\\rightarrow\\);\nQuantificadores: \\(\\forall\\).\n\n\nSolução:\n\n\nVariáveis: \\(y\\);\nConstantes: \\(c\\);\nSímbolos de função: \\(f\\);\nPredicados: \\(R\\);\nQuantificadores: \\(\\exists\\).\n\n\nSolução:\n\n\nVariáveis: \\(x\\), \\(y\\);\nConstantes: \\(b\\);\nSímbolos de função: \\(f\\);\nPredicados: \\(P\\), \\(S\\), \\(R\\);\nConectivos: \\(\\wedge\\), \\(\\rightarrow\\);\nQuantificadores: \\(\\forall\\), \\(\\exists\\).\n\n\nSim, é uma Fórmula Bem Formada (FBF).\n\n\n\nNão, não é uma Fórmula Bem Formada (FBF).\n\n\n\nNão, não é uma Fórmula Bem Formada (FBF).\n\n\n\nSim, é uma Fórmula Bem Formada (FBF).\n\n\n\n\nNão, não é uma Fórmula Bem Formada (FBF).\n\n\n\nSim, é uma Fórmula Bem Formada (FBF).\n\n\n\nNão, não é uma Fórmula Bem Formada (FBF).",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Lógica Proposicional @sec-logica-proposicional</span>"
    ]
  },
  {
    "objectID": "01-Sol-Proposicional.html#exercícios-tabelas-verdade-e-conectivos-lógicos",
    "href": "01-Sol-Proposicional.html#exercícios-tabelas-verdade-e-conectivos-lógicos",
    "title": "13  Lógica Proposicional Chapter 4",
    "section": "13.2 Exercícios: Tabelas-Verdade e Conectivos Lógicos",
    "text": "13.2 Exercícios: Tabelas-Verdade e Conectivos Lógicos\n(Nota: Usaremos T para Verdadeiro e F para Falso nas tabelas.)\n\nSolução para: \\(P \\rightarrow \\neg Q\\)\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(\\neg Q\\)\n\\(P \\rightarrow \\neg Q\\)\n\n\n\n\nT\nT\nF\nF\n\n\nT\nF\nT\nT\n\n\nF\nT\nF\nT\n\n\nF\nF\nT\nT\n\n\n\n\nSolução para: \\((P \\vee Q) \\wedge R\\)\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(R\\)\n\\(P \\vee Q\\)\n\\((P \\vee Q) \\wedge R\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nT\nF\nT\nF\n\n\nT\nF\nT\nT\nT\n\n\nT\nF\nF\nT\nF\n\n\nF\nT\nT\nT\nT\n\n\nF\nT\nF\nT\nF\n\n\nF\nF\nT\nF\nF\n\n\nF\nF\nF\nF\nF\n\n\n\n\nSolução para: \\(P \\leftrightarrow (P \\wedge Q)\\)\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\wedge Q\\)\n\\(P \\leftrightarrow (P \\wedge Q)\\)\n\n\n\n\nT\nT\nT\nT\n\n\nT\nF\nF\nF\n\n\nF\nT\nF\nT\n\n\nF\nF\nF\nT\n\n\n\n\nSolução para: \\((P \\wedge (P \\rightarrow Q)) \\rightarrow Q\\): (Esta é a forma lógica do Modus Ponens)\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(P \\wedge (P \\rightarrow Q)\\)\n\\((P \\wedge (P \\rightarrow Q)) \\rightarrow Q\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\n\n\nF\nF\nT\nF\nT\n\n\n\nConclusão: A fórmula é uma tautologia, pois a coluna final contém apenas T.\n\nSolução para: \\((P \\rightarrow Q) \\wedge (P \\wedge \\neg Q)\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(\\neg Q\\)\n\\(P \\wedge \\neg Q\\)\n\\((P \\rightarrow Q) \\wedge (P \\wedge \\neg Q)\\)\n\n\n\n\nT\nT\nT\nF\nF\nF\n\n\nT\nF\nF\nT\nT\nF\n\n\nF\nT\nT\nF\nF\nF\n\n\nF\nF\nT\nT\nF\nF\n\n\n\nConclusão: A fórmula é uma contradição, pois a coluna final contém apenas F.\n\nSolução para: \\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\) (Esta é a Lei da Contrapositiva)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(\\neg Q\\)\n\\(\\neg P\\)\n\\(\\neg Q \\rightarrow \\neg P\\)\n\\((P \\rightarrow Q) \\leftrightarrow (\\neg Q \\rightarrow \\neg P)\\)\n\n\n\n\nT\nT\nT\nF\nF\nT\nT\n\n\nT\nF\nF\nT\nF\nF\nT\n\n\nF\nT\nT\nF\nT\nT\nT\n\n\nF\nF\nT\nT\nT\nT\nT\n\n\n\nConclusão: A fórmula é uma tautologia, mostrando que uma implicação e sua contrapositiva são logicamente equivalentes.\n\nSolução para: \\((A \\rightarrow B) \\vee (B \\rightarrow C)\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\\(A\\)\n\\(B\\)\n\\(C\\)\n\\(A \\rightarrow B\\)\n\\(B \\rightarrow C\\)\n\\((A \\rightarrow B) \\vee (B \\rightarrow C)\\)\n\n\n\n\nT\nT\nT\nT\nT\nT\n\n\nT\nT\nF\nT\nF\nT\n\n\nT\nF\nT\nF\nT\nT\n\n\nT\nF\nF\nF\nT\nT\n\n\nF\nT\nT\nT\nT\nT\n\n\nF\nT\nF\nT\nF\nT\n\n\nF\nF\nT\nT\nT\nT\n\n\nF\nF\nF\nT\nT\nT\n\n\n\nConclusão: Esta fórmula é uma tautologia.\n\nSolução para: \\(\\neg(P \\wedge Q) \\leftrightarrow (\\neg P \\vee \\neg Q)\\) (Esta é uma das Leis de De Morgan)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\wedge Q\\)\n\\(\\neg(P \\wedge Q)\\)\n\\(\\neg P\\)\n\\(\\neg Q\\)\n\\(\\neg P \\vee \\neg Q\\)\n\\(\\neg(P \\wedge Q) \\leftrightarrow (\\neg P \\vee \\neg Q)\\)\n\n\n\n\nT\nT\nT\nF\nF\nF\nF\nT\n\n\nT\nF\nF\nT\nF\nT\nT\nT\n\n\nF\nT\nF\nT\nT\nF\nT\nT\n\n\nF\nF\nF\nT\nT\nT\nT\nT\n\n\n\nConclusão: A fórmula é uma tautologia, confirmando a validade da Lei de De Morgan.\n\nSolução para o argumento:\n\nPremissa 1: Se o programa é eficiente, o custo é baixo (\\(P \\rightarrow Q\\)).\nPremissa 2: O programa é eficiente (\\(P\\)).\nConclusão: O custo é baixo (\\(Q\\)).\nFórmula a ser testada: \\(((P \\rightarrow Q) \\wedge P) \\rightarrow Q\\). Esta é a mesma fórmula do exercício 4.\n\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\((P \\rightarrow Q) \\wedge P\\)\n\\(((P \\rightarrow Q) \\wedge P) \\rightarrow Q\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\n\n\nF\nF\nT\nF\nT\n\n\n\nConclusão: Como a fórmula que representa o argumento é uma\ntautologia, o argumento é válido.\n\nSolução para: \\((P \\vee Q) \\rightarrow (P \\wedge Q)\\)\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\vee Q\\)\n\\(P \\wedge Q\\)\n\\((P \\vee Q) \\rightarrow (P \\wedge Q)\\)\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nT\nF\nF\n\n\nF\nT\nT\nF\nF\n\n\nF\nF\nF\nF\nT\n\n\n\nConclusão: A fórmula é contingente (satisfatível e falsificável).",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Lógica Proposicional @sec-logica-proposicional</span>"
    ]
  },
  {
    "objectID": "01-Sol-Proposicional.html#exercícios-simplificação-com-equivalências-lógicas",
    "href": "01-Sol-Proposicional.html#exercícios-simplificação-com-equivalências-lógicas",
    "title": "13  Lógica Proposicional Chapter 4",
    "section": "13.3 Exercícios: Simplificação com Equivalências Lógicas",
    "text": "13.3 Exercícios: Simplificação com Equivalências Lógicas\n\nSolução para: $ (P Q) $**:\n\n\\[\n\\begin{align*}\n\\neg(P \\vee \\neg Q) &\\equiv \\neg P \\wedge \\neg(\\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv \\neg P \\wedge Q && \\text{Lei da Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para: \\(P \\vee (P \\wedge Q)\\): (Esta é a Lei da Absorção)\n\n\\[\n\\begin{align*}\nP \\vee (P \\wedge Q) &\\equiv (P \\wedge TRUE) \\vee (P \\wedge Q) && \\text{Lei da Identidade} \\\\\n&\\equiv P \\wedge (TRUE \\vee Q) && \\text{Lei da Distributividade} \\\\\n&\\equiv P \\wedge TRUE && \\text{Lei do Domínio} \\\\\n&\\equiv P && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para: \\(\\neg(P \\rightarrow \\neg Q)\\)\n\n\\[\n\\begin{align*}\n\\neg(P \\rightarrow \\neg Q) &\\equiv \\neg(\\neg P \\vee \\neg Q) && \\text{Definição de Implicação} \\\\\n&\\equiv \\neg(\\neg P) \\wedge \\neg(\\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv P \\wedge Q && \\text{Lei da Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para: \\((P \\vee Q) \\wedge (\\neg P \\vee Q)\\):\n\n\\[\n\\begin{align*}\n(P \\vee Q) \\wedge (\\neg P \\vee Q) &\\equiv (Q \\vee P) \\wedge (Q \\vee \\neg P) && \\text{Lei da Comutatividade} \\\\\n&\\equiv Q \\vee (P \\wedge \\neg P) && \\text{Lei da Distributividade} \\\\\n&\\equiv Q \\vee FALSE && \\text{Lei da Contradição} \\\\\n&\\equiv Q && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para: \\((P \\rightarrow Q) \\vee (Q \\rightarrow P)\\)\n\n\\[\n\\begin{align*}\n(P \\rightarrow Q) \\vee (Q \\rightarrow P) &\\equiv (\\neg P \\vee Q) \\vee (\\neg Q \\vee P) && \\text{Definição de Implicação} \\\\\n&\\equiv (\\neg P \\vee P) \\vee (Q \\vee \\neg Q) && \\text{Leis da Associatividade e Comutatividade} \\\\\n&\\equiv TRUE \\vee TRUE && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Idempotência da Disjunção}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\nSolução para: \\(\\neg(P \\leftrightarrow Q)\\) (Esta é a definição de “ou exclusivo”, XOR)\n\n\\[\n\\begin{align*}\n\\neg(P \\leftrightarrow Q) &\\equiv \\neg((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) && \\text{Definição de Equivalência} \\\\\n&\\equiv \\neg(P \\rightarrow Q) \\vee \\neg(Q \\rightarrow P) && \\text{Lei de De Morgan} \\\\\n&\\equiv \\neg(\\neg P \\vee Q) \\vee \\neg(\\neg Q \\vee P) && \\text{Definição de Implicação} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P) && \\text{Lei de De Morgan e Dupla Negação}\n\\end{align*}\n\\]\n\nSolução para: \\((P \\wedge Q) \\rightarrow (P \\vee Q)\\)\n\n\\[\n\\begin{align*}\n(P \\wedge Q) \\rightarrow (P \\vee Q) &\\equiv \\neg(P \\wedge Q) \\vee (P \\vee Q) && \\text{Definição de Implicação} \\\\\n&\\equiv (\\neg P \\vee \\neg Q) \\vee (P \\vee Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv (\\neg P \\vee P) \\vee (\\neg Q \\vee Q) && \\text{Leis da Associatividade e Comutatividade} \\\\\n&\\equiv TRUE \\vee TRUE && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Idempotência da Disjunção}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.\n\nSolução para: \\((P \\vee Q) \\wedge \\neg(\\neg P \\wedge Q)\\)\n\n\\[\n\\begin{align*}\n(P \\vee Q) \\wedge \\neg(\\neg P \\wedge Q) &\\equiv (P \\vee Q) \\wedge (\\neg(\\neg P) \\vee \\neg Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv (P \\vee Q) \\wedge (P \\vee \\neg Q) && \\text{Lei da Dupla Negação} \\\\\n&\\equiv P \\vee (Q \\wedge \\neg Q) && \\text{Lei da Distributividade} \\\\\n&\\equiv P \\vee FALSE && \\text{Lei da Contradição} \\\\\n&\\equiv P && \\text{Lei da Identidade}\n\\end{align*}\n\\]\n\nSolução para: \\((A \\wedge \\neg B) \\vee (A \\vee \\neg B)\\):\n\n\\[\n\\begin{align*}\n(A \\wedge \\neg B) \\vee (A \\vee \\neg B) &\\equiv (A \\vee (A \\vee \\neg B)) \\wedge (\\neg B \\vee (A \\vee \\neg B)) && \\text{Lei da Distributividade} \\\\\n&\\equiv (A \\vee A \\vee \\neg B) \\wedge (\\neg B \\vee \\neg B \\vee A) && \\text{Lei da Associatividade (e Comutatividade)} \\\\\n&\\equiv (A \\vee \\neg B) \\wedge (\\neg B \\vee A) && \\text{Lei da Idempotência} \\\\\n&\\equiv (A \\vee \\neg B) \\wedge (A \\vee \\neg B) && \\text{Lei da Comutatividade} \\\\\n&\\equiv A \\vee \\neg B && \\text{Lei da Idempotência}\n\\end{align*}\n\\]\nObservação: apesar de a aplicação da distributividade ser válida, o passo inicial pode parecer confuso. Um método mais direto é reconhecer que $ (A B) (A B) $ é equivalente a $ A B $, pois $ A B $ já cobre todas as possibilidades onde $ A B $ é verdadeiro.\nResultado final: $ A B $\n\nSolução para: $ ((P Q) (Q R)) (P R) $:\n\n\\[\n\\begin{align*}\n&((P \\rightarrow Q) \\wedge (Q \\rightarrow R)) \\rightarrow (P \\rightarrow R) \\\\\n&\\equiv \\neg ((\\neg P \\vee Q) \\wedge (\\neg Q \\vee R)) \\vee (\\neg P \\vee R) && \\text{Definição de Implicação (3x)} \\\\\n&\\equiv (\\neg(\\neg P \\vee Q) \\vee \\neg(\\neg Q \\vee R)) \\vee (\\neg P \\vee R) && \\text{Lei de De Morgan} \\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg R)) \\vee (\\neg P \\vee R) && \\text{De Morgan e Dupla Negação} \\\\\n&\\equiv (P \\wedge \\neg Q) \\vee (Q \\wedge \\neg R) \\vee \\neg P \\vee R && \\text{Lei da Associatividade} \\\\\n&\\equiv ((P \\wedge \\neg Q) \\vee \\neg P) \\vee ((Q \\wedge \\neg R) \\vee R) && \\text{Comutatividade e Associatividade} \\\\\n&\\equiv ((P \\vee \\neg P) \\wedge (\\neg Q \\vee \\neg P)) \\vee ((Q \\vee R) \\wedge (\\neg R \\vee R)) && \\text{Lei da Distributividade (2x)} \\\\\n&\\equiv (TRUE \\wedge (\\neg Q \\vee \\neg P)) \\vee ((Q \\vee R) \\wedge TRUE) && \\text{Lei do Terceiro Excluído (2x)} \\\\\n&\\equiv (\\neg Q \\vee \\neg P) \\vee (Q \\vee R) && \\text{Lei da Identidade (2x)} \\\\\n&\\equiv (\\neg Q \\vee Q) \\vee (\\neg P \\vee R) && \\text{Comutatividade e Associatividade} \\\\\n&\\equiv TRUE \\vee (\\neg P \\vee R) && \\text{Lei do Terceiro Excluído} \\\\\n&\\equiv TRUE && \\text{Lei do Domínio}\n\\end{align*}\n\\]\nComo a fórmula simplifica para \\(TRUE\\), ela é uma tautologia.",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Lógica Proposicional @sec-logica-proposicional</span>"
    ]
  },
  {
    "objectID": "01-Sol-Proposicional.html#exercícios-provas-com-regras-de-inferência",
    "href": "01-Sol-Proposicional.html#exercícios-provas-com-regras-de-inferência",
    "title": "13  Lógica Proposicional Chapter 4",
    "section": "13.4 Exercícios: Provas com Regras de Inferência",
    "text": "13.4 Exercícios: Provas com Regras de Inferência\n\nSolução:\n\n\\(P \\rightarrow Q\\) (Premissa 1)\n\\(P\\) (Premissa 2)\n\\(Q\\) (1, 2, Modus Ponens)\n\nSolução:\n\n\\(A \\rightarrow B\\) (Premissa 1)\n\\(\\neg B\\) (Premissa 2)\n\\(\\neg A\\) (1, 2, Modus Tollens)\n\nSolução:\n\n\\(P \\wedge Q\\) (Premissa 1)\n\\(P \\rightarrow R\\) (Premissa 2)\n\\(P\\) (1, Simplificação)\n\\(R\\) (2, 3, Modus Ponens)\n\nSolução:\n\n\\(S \\rightarrow \\neg T\\) (Premissa 1)\n\\(T\\) (Premissa 2)\n\\(S \\vee U\\) (Premissa 3)\n\\(\\neg\\neg T\\) (2, Dupla Negação)\n\\(\\neg S\\) (1, 4, Modus Tollens)\n\\(U\\) (3, 5, Silogismo Disjuntivo / Modus Tollendo Ponens)\n\nSolução:\n\n\\(A\\) (Premissa 1)\n\\(B\\) (Premissa 2)\n\\((A \\wedge B) \\rightarrow C\\) (Premissa 3)\n\\(A \\wedge B\\) (1, 2, Adjunção)\n\\(C\\) (3, 4, Modus Ponens)\n\nSolução:\n\n\\(P \\rightarrow Q\\) (Premissa 1)\n\\(Q \\rightarrow R\\) (Premissa 2)\n\\(P \\rightarrow R\\) (1, 2, Silogismo Hipotético)\n\n(Nota: Esta é uma aplicação direta da regra de inferência Silogismo Hipotético.)\nSolução:\n\n\\(A \\rightarrow B\\) (Premissa 1)\n\\(C \\rightarrow D\\) (Premissa 2)\n\\(A \\vee C\\) (Premissa 3)\n\\(B \\vee D\\) (1, 2, 3, Dilema Construtivo)\n\n(Nota: Esta é uma aplicação direta da regra de inferência Dilema Construtivo.)\nSolução:\n\n\\(\\neg A \\vee B\\) (Premissa 1)\n\\(C \\rightarrow A\\) (Premissa 2)\n\\(C\\) (Premissa 3)\n\\(A\\) (2, 3, Modus Ponens)\n\\(B\\) (1, 4, Silogismo Disjuntivo / Modus Tollendo Ponens)\n\n(Justificativa do passo 5: Como temos \\(\\neg A \\vee B\\) e provamos \\(A\\), a primeira parte da disjunção, \\(\\neg A\\), é falsa. Logo, a segunda parte, \\(B\\), deve ser verdadeira.)\nSolução:\n\nPremissas:\n\n\n\\(S \\rightarrow D\\)\n\\(D \\rightarrow R\\)\n\\(S\\)\n\n\nConclusão: \\(R\\)\nProva:\n\n\n\\(S \\rightarrow D\\) (Premissa 1)\n\\(D \\rightarrow R\\) (Premissa 2)\n\\(S\\) (Premissa 3)\n\\(S \\rightarrow R\\) (1, 2, Silogismo Hipotético)\n\\(R\\) (3, 4, Modus Ponens)\n\nSolução:\n\n\\((P \\wedge Q) \\rightarrow R\\) (Premissa 1)\n\\(\\neg R \\vee S\\) (Premissa 2)\n\\(P\\) (Premissa 3)\n\\(Q \\wedge T\\) (Premissa 4)\n\\(Q\\) (4, Simplificação)\n\\(P \\wedge Q\\) (3, 5, Adjunção)\n\\(R\\) (1, 6, Modus Ponens)\n\\(R \\rightarrow S\\) (2, Definição de Implicação)\n\\(S\\) (7, 8, Modus Ponens)",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Lógica Proposicional @sec-logica-proposicional</span>"
    ]
  },
  {
    "objectID": "01-Sol-Proposicional.html#exercícios-análise-semântica-de-fórmulas",
    "href": "01-Sol-Proposicional.html#exercícios-análise-semântica-de-fórmulas",
    "title": "13  Lógica Proposicional Chapter 4",
    "section": "13.5 Exercícios: Análise Semântica de Fórmulas",
    "text": "13.5 Exercícios: Análise Semântica de Fórmulas\n\nSolução para \\(P \\rightarrow (P \\wedge Q)\\):\nClassificação: Contingência.\nJustificativa (Tabela-Verdade):\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\wedge Q\\)\n\\(P \\rightarrow (P \\wedge Q)\\)\n\n\n\n\nT\nT\nT\nT\n\n\nT\nF\nF\nF\n\n\nF\nT\nF\nT\n\n\nF\nF\nF\nT\n\n\n\nA coluna final possui tanto T quanto F.\nSolução para \\((P \\vee Q) \\vee (\\neg P \\wedge \\neg Q)\\):\nClassificação: Tautologia.\nJustificativa (Simplificação):\n\\[\n\\begin{align*}\n(P \\vee Q) \\vee (\\neg P \\wedge \\neg Q) &\\equiv (P \\vee Q) \\vee \\neg(P \\vee Q) && \\text{Lei de De Morgan} \\\\\n&\\equiv TRUE && \\text{Lei do Terceiro Excluído (na forma } X \\vee \\neg X)\n\\end{align*}\n\\]\nSolução para \\((P \\leftrightarrow Q) \\wedge (P \\wedge \\neg Q)\\):\nClassificação: Contradição.\nJustificativa (Análise Lógica): para a fórmula ser verdadeira, ambas as partes da conjunção precisam ser verdadeiras.\n\nA segunda parte, \\((P \\wedge \\neg Q)\\), só é verdadeira se \\(P=T\\) e \\(Q=F\\).\nVamos testar essa valoração na primeira parte: \\((P \\leftrightarrow Q)\\) se torna \\((T \\leftrightarrow F)\\), que é \\(FALSO\\).\nPortanto, a conjunção inteira se torna \\((FALSO \\wedge VERDADEIRO)\\), que é \\(FALSO\\).\n\nComo não existe nenhuma valoração que torne a fórmula verdadeira, ela é uma contradição.\nSolução (Valoração Verdadeira):\n\nUma implicação \\(X \\rightarrow Y\\) é verdadeira se o antecedente \\(X\\) for falso, ou se o consequente \\(Y\\) for verdadeiro.\n- **Método 1 (Consequente Verdadeiro)**: Vamos tornar $(C \\rightarrow A)$ verdadeiro. Isso acontece se $A=T$.\n\n- **Valoração**: $A=T, B=T, C=T$.\n\n- **Verificação**: $(\\neg T \\vee T) \\rightarrow (T \\rightarrow T) \\equiv (F \\vee T) \\rightarrow T \\equiv T \\rightarrow T \\equiv T$. A valoração funciona.\n\nSolução (Valoração Falsa):\nUma implicação \\(X \\rightarrow Y\\) só é falsa se o antecedente \\(X\\) for verdadeiro e o consequente \\(Y\\) for falso.\n\nTornar o consequente \\((C \\rightarrow A)\\) falso: Para isso, precisamos de \\(C=T\\) e \\(A=F\\).\nVerificar se o antecedente \\((\\neg A \\vee B)\\) é verdadeiro com \\(A=F\\): \\((\\neg F \\vee B) \\equiv (T \\vee B)\\), que é sempre \\(T\\), não importa o valor de \\(B\\).\n\n\nValoração: \\(A=F, B=F, C=T\\).\nVerificação: \\((\\neg F \\vee F) \\rightarrow (T \\rightarrow F) \\equiv (T \\vee F) \\rightarrow F \\equiv T \\rightarrow F \\equiv F\\). A valoração funciona.\n\nSolução para: \\((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\\)\nClassificação: Tautologia.\nJustificativa: Esta é uma das fórmulas axiomáticas da Lógica Proposicional, conhecida como Axioma de Frege. Provar por simplificação é longo, e por tabela-verdade requer 8 linhas. Todas as valorações possíveis resultam em Verdadeiro. É um princípio fundamental que permite a distribuição da implicação.\nSolução para \\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\wedge Q))\\):\nClassificação: Tautologia:\nJustificativa (Tabela-Verdade):\n\n\n\n\n\n\n\n\n\n\n\n\\(P\\)\n\\(Q\\)\n\\(P \\rightarrow Q\\)\n\\(P \\wedge Q\\)\n\\(P \\leftrightarrow (P \\wedge Q)\\)\n\\((P \\rightarrow Q) \\leftrightarrow (P \\leftrightarrow (P \\wedge Q))\\)\n\n\n\n\nT\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\nT\n\n\nF\nF\nT\nF\nT\nT\n\n\n\nComo a coluna final só contém T, a fórmula é uma tautologia.\nSolução para \\(\\neg(((P \\vee Q) \\rightarrow P) \\vee Q)\\):\nClassificação: Contradição.:\nJustificativa (Simplificação):\n\\[\n\\begin{align*}\n\\neg(((P \\vee Q) \\rightarrow P) \\vee Q) &\\equiv \\neg((\\neg(P \\vee Q) \\vee P) \\vee Q) && \\text{Def. Implicação} \\\\\n&\\equiv \\neg(((\\neg P \\wedge \\neg Q) \\vee P) \\vee Q) && \\text{De Morgan} \\\\\n&\\equiv \\neg(((\\neg P \\vee P) \\wedge (\\neg Q \\vee P)) \\vee Q) && \\text{Distributividade} \\\\\n&\\equiv \\neg((TRUE \\wedge (\\neg Q \\vee P)) \\vee Q) && \\text{Terceiro Excluído} \\\\\n&\\equiv \\neg((\\neg Q \\vee P) \\vee Q) && \\text{Identidade} \\\\\n&\\equiv \\neg(\\neg Q \\vee Q \\vee P) && \\text{Associatividade} \\\\\n&\\equiv \\neg(TRUE \\vee P) && \\text{Terceiro Excluído} \\\\\n&\\equiv \\neg(TRUE) && \\text{Domínio} \\\\\n&\\equiv FALSE && \\text{Negação}\n\\end{align*}\n\\]\nSolução para o argumento:\nNão, não é logicamente consistente.\nJustificativa:\n\nA regra é: \\(D \\leftrightarrow (C \\wedge \\neg E)\\).\nA situação a ser testada é: \\(D \\wedge \\neg C\\). Para que isso seja verdade, \\(D=T\\) e \\(C=F\\).\nVamos substituir esses valores na regra: \\(T \\leftrightarrow (F \\wedge \\neg E)\\).\nA expressão \\((F \\wedge \\neg E)\\) será sempre \\(FALSO\\), não importa o valor de \\(E\\).\nEntão, a regra se torna \\(T \\leftrightarrow FALSO\\), o que é uma contradição (\\(FALSO\\)).\nComo a situação (\\(D \\wedge \\neg C\\)) leva a uma contradição da regra, ela não é consistente com a regra. É impossível satisfazer ambas as fórmulas ao mesmo tempo.\n\nSolução para \\((A \\leftrightarrow B) \\vee (B \\leftrightarrow C)\\):\nClassificação: Contingência.\nJustificativa (Análise de Casos):\n\nPode ser Verdadeiro: Se \\(A=T, B=T, C=T\\), a fórmula se torna \\((T \\leftrightarrow T) \\vee (T \\leftrightarrow T) \\equiv T \\vee T \\equiv T\\).\nPode ser Falso: Se \\(A=T, B=F, C=T\\), a fórmula se torna \\((T \\leftrightarrow F) \\vee (F \\leftrightarrow T) \\equiv F \\vee F \\equiv F\\). Como a fórmula pode ser tanto verdadeira quanto falsa dependendo da valoração, ela é uma contingência.",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Lógica Proposicional @sec-logica-proposicional</span>"
    ]
  },
  {
    "objectID": "01-Sol-Proposicional.html#exercícios-conexão-com-o-prolog",
    "href": "01-Sol-Proposicional.html#exercícios-conexão-com-o-prolog",
    "title": "13  Lógica Proposicional Chapter 4",
    "section": "13.6 Exercícios: Conexão com o Prolog",
    "text": "13.6 Exercícios: Conexão com o Prolog\nQuestão 1: Diagnóstico de Sistema\n\nModelagem (Base de Conhecimento):\n\nS: O servidor está sobrecarregado.\n\nL: A latência da rede aumenta.\n\nN: O sistema de alerta envia uma notificação.\n\nRegras:\n\n\\(P_1: S \\to L\\)\n\n\\(P_2: L \\to N\\)\n\nFato:\n\n\\(P_3: \\neg N\\)\n\nConsulta: Prove \\(\\neg S\\).\nDedução Lógica (usando Modus Tollens):\n\nA partir de \\(P_2 (L \\to N)\\) e \\(P_3 (\\neg N)\\), podemos inferir \\(\\neg L\\) pela regra de Modus Tollens.\n\nAgora, usando \\(P_1 (S \\to L)\\) e nossa nova inferência \\(\\neg L\\), aplicamos Modus Tollens novamente para concluir \\(\\neg S\\).\n\nAlternativamente, podemos primeiro combinar \\(P_1\\) e \\(P_2\\) usando o Silogismo Hipotético: de \\((S \\to L)\\) e \\((L \\to N)\\), inferimos \\((S \\to N)\\). Com \\((S \\to N)\\) e \\(P_3 (\\neg N)\\), aplicamos Modus Tollens para obter \\(\\neg S\\).\n\nConexão com Prolog: Este exemplo mostra como fatos e regras interagem para produzir novas conclusões. Em Prolog, teríamos:\n\nlatencia_aumenta(X) :- servidor_sobrecarregado(X).\nalerta_enviado(X) :- latencia_aumenta(X).\n% Fato observado: não há alerta\n% Consulta: ?- servidor_sobrecarregado(servidor1).\n% Resposta: false (devido à cadeia de inferências)\nQuestão 2: Validação de Circuito Lógico (Half-Adder)\n\nTradução para Fórmulas:\n\n\nA condição para a saída S (“exatamente uma das entradas”) é um “ou exclusivo” (XOR):\n\\[S \\leftrightarrow (A \\wedge \\neg B) \\vee (\\neg A \\wedge B)\\]\nEm muitos contextos, isso é escrito como \\(A \\oplus B\\).\n\nA condição para a saída C (“ambas as entradas”):\n\\[C \\leftrightarrow A \\wedge B\\]\n\n\nTabela Verdade para Equivalência:\n\nVamos comparar a fórmula de S com a fórmula proposta \\(F \\equiv (A \\vee B) \\wedge \\neg(A \\wedge B)\\).\n\n\n\n\n\n\n\n\n\n\n\n\nA\nB\n\\(A \\oplus B\\) (Saída S)\n\\(A \\vee B\\)\n\\(A \\wedge B\\)\n\\(\\neg(A \\wedge B)\\)\n\\((A \\vee B) \\wedge \\neg(A \\wedge B)\\) (Fórmula F)\n\n\n\n\nT\nT\nF\nT\nT\nF\nF\n\n\nT\nF\nT\nT\nF\nT\nT\n\n\nF\nT\nT\nT\nF\nT\nT\n\n\nF\nF\nF\nF\nF\nT\nF\n\n\n\n\nConclusão: A coluna para a saída S e a coluna para a fórmula F são idênticas. Portanto, as duas fórmulas são logicamente equivalentes.\nConexão com Prolog: Em Prolog, poderíamos modelar o half-adder como:\n\nhalf_adder_sum(A, B, S) :- (A, \\+ B); (\\+ A, B).\nhalf_adder_carry(A, B, C) :- A, B.\nQuestão 3: Análise de Contrato de Serviço \n\nModelagem:\n\n\nU: Uptime &lt; 99%\n\nC: Cliente recebe crédito\n\nT: Cliente abre ticket\n\nD: Cliente recebe desconto\n\nRegras:\n\n\\(P_1: U \\to C\\)\n\n\\(P_2: C \\to T\\)\n\n\\(P_3: \\neg(C \\wedge D)\\) (não pode ter ambos)\n\nFatos:\n\n\\(F_1: U\\) (uptime foi 98%)\n\n\\(F_2: \\neg T\\) (cliente não abriu ticket)\n\n\nAnálise da Contradição:\n\n\nDe \\(P_1 (U \\to C)\\) e \\(F_1 (U)\\), por Modus Ponens, concluímos \\(C\\).\n\nDe \\(P_2 (C \\to T)\\) e nossa conclusão \\(C\\), por Modus Ponens, deveríamos concluir \\(T\\).\n\nMas temos o fato \\(F_2 (\\neg T)\\).\n\nIsso cria uma contradição: \\(T \\wedge \\neg T\\).\n\n\nConclusão: As regras do contrato são inconsistentes. Quando o uptime é baixo mas o cliente não abre um ticket, o sistema de regras gera uma contradição. O contrato precisa ser reformulado para ser logicamente consistente.\nReformulação Sugerida: Modificar a regra 1 para: “Se o uptime for menor que 99% E o cliente abrir um ticket, então receberá um crédito”: \\((U \\wedge T) \\to C\\).\nConexão com Prolog: Este tipo de inconsistência poderia ser detectada automaticamente em Prolog:\n\n% Regras inconsistentes\ncredito(Cliente) :- uptime_baixo(Cliente).\ncredito(Cliente) :- ticket_aberto(Cliente).\n\n% Fatos\nuptime_baixo(cliente1).\n\\+ ticket_aberto(cliente1).\n\n% Consulta que revelaria a inconsistência\n?- credito(cliente1), \\+ ticket_aberto(cliente1).\n% A inconsistência seria revelada pela análise lógica\nQuestão 4: Dependências de Compilação\n\nModelagem Correta:\n“Para compilar X, Y deve estar compilado” traduz-se em “Y deve estar compilado antes de X poder ser compilado”, ou seja: a capacidade de compilar X depende de Y estar compilado.\n\nRegras de Dependência:\n* \\(R_1: C \\to U\\) (para C ser compilado, U deve estar compilado)\n* \\(R_2: A \\to C\\) (para A ser compilado, C deve estar compilado)\n* \\(R_3: G \\to (A \\wedge L)\\) (para G ser compilado, A e L devem estar compilados)\nFato:\n* \\(F_1: U\\) (utils já compilado)\n\nAnálise de Viabilidade:\nPara compilar G, precisamos de A e L. A cadeia de dependências é: \\[G \\to (A \\wedge L) \\to (C \\wedge L) \\to (U \\wedge C \\wedge L)\\]\n\nA condição completa para compilar G é: \\(G \\to (U \\wedge C \\wedge A \\wedge L)\\).\n\nConclusão:\n\n\n\nTemos U compilado\n\nPodemos compilar C (pois U está disponível)\n\nPodemos compilar A (pois C pode ser compilado)\n\nNÃO podemos compilar G pois não sabemos o estado de L\n\nÉ necessário que a biblioteca assets (L) também seja compilada.\n\nConexão com Prolog:\n\npode_compilar(utils).\npode_compilar(core) :- pode_compilar(utils).\npode_compilar(api) :- pode_compilar(core).\npode_compilar(gui) :- pode_compilar(api), pode_compilar(assets).\n\n% Consulta: ?- pode_compilar(gui).\n% Resposta: false (pois assets não está definido)\nQuestão 5: Regras de um Jogo\n\nSimplificação da Condição de Vitória:\n\nSubstituindo a suposição F = verdadeiro e o fato \\(\\neg E\\) = verdadeiro:\n\n\\(T \\leftrightarrow (T \\wedge A) \\implies T \\leftrightarrow A\\) (já que F é verdadeiro)\n\n\\(A \\leftrightarrow (D \\vee F) \\implies A \\leftrightarrow D\\) (já que E é falso)\n\nPortanto: \\(T \\leftrightarrow D\\)\n\nAnálise da Condição para Derrotar o Dragão:\n\n\nA regra \\(D \\to S\\) estabelece que ter a espada é necessário para derrotar o dragão.\n\nO fato S nos diz que essa condição necessária é satisfeita.\n\nContudo, \\(D \\to S\\) não nos permite concluir D a partir de S (isso seria a falácia de afirmar o consequente).\n\n\nConclusão: Supondo que o jogador chegue à casa final, ele vencerá o jogo se, e somente se, derrotar o dragão (D). A posse da espada é uma pré-condição satisfeita, mas a derrota do dragão ainda deve ocorrer no mundo do jogo.\nConexão com Prolog: Este cenário de jogo poderia ser modelado em Prolog como:\n\n% Fatos\npossui(heroi, espada_prata).\nchegou_casa_final(heroi).\n\\+ resolveu_enigma(heroi).\n\n% Regras\nvence(X) :- chegou_casa_final(X), possui_amuleto(X).\npossui_amuleto(X) :- derrotou_dragao(X).\npossui_amuleto(X) :- resolveu_enigma(X).\npode_enfrentar_dragao(X) :- possui(X, espada_prata).\n\n% Consulta\n?- vence(heroi).\n% Dependeria de derrotou_dragao(heroi) ser provado\nQuestão 6: Decisão de um Robô Autônomo\n\nDedução da Contradição:\n\n\nDe O e \\(P_1 (O \\to (P \\wedge G))\\), por Modus Ponens: \\((P \\wedge G)\\), logo P e G.\n\nDe B e \\(P_2 (B \\to (P \\wedge R))\\), por Modus Ponens: \\((P \\wedge R)\\), logo P e R.\n\nDas inferências: G é verdadeiro e R é verdadeiro, portanto \\((G \\wedge R)\\) é verdadeiro.\n\nMas \\(P_3\\) afirma \\(\\neg(G \\wedge R)\\).\n\nContradição: \\((G \\wedge R) \\wedge \\neg(G \\wedge R)\\).\n\n\nResolução do Conflito:\n\nIntroduzir hierarquia de prioridades. Sugestão:\nRegra 1 Modificada: \\((O \\wedge \\neg B) \\to (P \\wedge G)\\)\nCom esta modificação, quando O e B são ambos verdadeiros, apenas a Regra 2 é acionada, e o robô para e retorna à base, eliminando a contradição.\n\nConexão com Prolog: Este exemplo ilustra a importância da ordem das regras em Prolog e como conflitos podem ser resolvidos através de condições mais específicas:\n\n% Versão com conflito\nacao_robo(parar_girar) :- obstaculo_detectado.\nacao_robo(parar_retornar) :- bateria_baixa.\n\n% Versão corrigida com prioridades\nacao_robo(parar_retornar) :- bateria_baixa.\nacao_robo(parar_girar) :- obstaculo_detectado, \\+ bateria_baixa.\n\n% Fatos\nobstaculo_detectado.\nbateria_baixa.\n\n% Consulta\n?- acao_robo(X).\n% X = parar_retornar (prioridade para bateria baixa)\nQuestão 7: Simplificação de Query de Banco de Dados \n\nTabela Verdade Completa:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA\nS\nC\n\\(S \\vee C\\)\n\\(A \\wedge (S \\vee C)\\)\n\\(S \\wedge C\\)\n\\(\\neg A \\wedge (S \\wedge C)\\)\nFórmula Original\n\n\n\n\nT\nT\nT\nT\nT\nT\nF\nT\n\n\nT\nT\nF\nT\nT\nF\nF\nT\n\n\nT\nF\nT\nT\nT\nF\nF\nT\n\n\nT\nF\nF\nF\nF\nF\nF\nF\n\n\nF\nT\nT\nT\nF\nT\nT\nT\n\n\nF\nT\nF\nT\nF\nF\nF\nF\n\n\nF\nF\nT\nT\nF\nF\nF\nF\n\n\nF\nF\nF\nF\nF\nF\nF\nF\n\n\n\n\nForma Normal Disjuntiva Mínima:\n\nA fórmula é verdadeira para os seguintes mintermos:\n\n\\(A \\wedge S \\wedge C\\) (linha 1);\n\n\\(A \\wedge S \\wedge \\neg C\\) (linha 2);\n\n\\(A \\wedge \\neg S \\wedge C\\) (linha 3);\n\n\\(\\neg A \\wedge S \\wedge C\\) (linha 5).\n\nAgrupamento dos mintermos:\n\nAgrupando (1) e (2): \\((A \\wedge S \\wedge C) \\vee (A \\wedge S \\wedge \\neg C) \\equiv A \\wedge S\\);\n\nAgrupando (1) e (3): \\((A \\wedge S \\wedge C) \\vee (A \\wedge \\neg S \\wedge C) \\equiv A \\wedge C\\);\n\nAgrupando (1) e (4): \\((A \\wedge S \\wedge C) \\vee (\\neg A \\wedge S \\wedge C) \\equiv S \\wedge C\\).\n\nForma Normal Disjuntiva Mínima:\n\\((A \\wedge S) \\vee (A \\wedge C) \\vee (S \\wedge C)\\)\n\nVerificação: Esta forma não pode ser simplificada ainda mais sem perder informação, pois cada termo cobre casos distintos que não podem ser agrupados.\nEficiência: A forma simplificada \\((A \\wedge S) \\vee (A \\wedge C) \\vee (S \\wedge C)\\) é mais eficiente que a original pois:\n\n\nEstrutura “plana” de ORs de ANDs (Forma Normal Disjuntiva);\n\nPermite que o otimizador do banco use índices nas colunas A, S e C de forma mais eficaz;\n\nReduz operações lógicas aninhadas, diminuindo o custo computacional da consulta.\n\n\nConexão com Prolog: A simplificação lógica é fundamental em Prolog para otimização de consultas:\n\n% Consulta original (mais complexa)\nusuario_selecionado(U) :- \n (ativo(U), (sao_paulo(U) ; compras_altas(U))) ;\n (\\+ ativo(U), sao_paulo(U), compras_altas(U)).\n\n% Versão simplificada (mais eficiente)\nusuario_selecionado(U) :- ativo(U), sao_paulo(U).\nusuario_selecionado(U) :- ativo(U), compras_altas(U).\nusuario_selecionado(U) :- sao_paulo(U), compras_altas(U).\nQuestão 8: O Paradoxo do Mentiroso (Versão Proposicional)\n\nTabela Verdade:\nA fórmula \\(P \\leftrightarrow \\neg P\\) é equivalente a \\((P \\to \\neg P) \\wedge (\\neg P \\to P)\\).\n\n\n\n\nP\n\\(\\neg P\\)\n\\(P \\leftrightarrow \\neg P\\)\n\n\n\n\nT\nF\nF\n\n\nF\nT\nF\n\n\n\n\nAnálise: A tabela verdade mostra que a fórmula é sempre falsa, sendo portanto uma contradição.\nExplicação do Paradoxo: O paradoxo surge da autorreferência:\n\n\nSe a sentença é verdadeira, então deve ser o que afirma (falsa) → contradição\n\nSe a sentença é falsa, então sua afirmação é incorreta, logo deve ser verdadeira → contradição\n\n\nLimitações da Lógica Clássica: A lógica proposicional clássica não foi projetada para autorreferência. Lógicas paraconsistentes ou de múltiplos valores foram desenvolvidas para lidar com tais paradoxos.\nConexão com Prolog: O Prolog evita este tipo de paradoxo através de sua semântica operacional e da negação por falha:\n\n% Em Prolog, não podemos expressar diretamente:\n% P :- \\+ P.  % Isso causaria um loop infinito\n\n% O Prolog usa \"negação por falha\" que é diferente da negação lógica\n% Se algo não pode ser provado, é assumido como falso\nfalso_se_nao_provavel(X) :- \\+ provavel(X).\n\n% Isso evita contradições autorreferentes\nQuestão 9: Política de Firewall\n\nDedução Lógica:\n\n\nTemos \\(\\neg P\\) (verdadeiro).\n\nA premissa da Regra 2 é \\((\\neg I \\vee \\neg P)\\).\n\nComo \\(\\neg P\\) é verdadeiro, a disjunção \\((\\neg I \\vee \\neg P)\\) é verdadeira.\n\nPor Modus Ponens na Regra 2: A é verdadeiro.\n\n\nAnálise de Redundância:\nA condição total para A é: \\(((I \\wedge P) \\vee (\\neg I \\vee \\neg P))\\).\n\nPor De Morgan: \\((\\neg I \\vee \\neg P) \\equiv \\neg(I \\wedge P)\\).\nLogo: \\(A \\leftrightarrow ((I \\wedge P) \\vee \\neg(I \\wedge P))\\).\nSeja \\(X = (I \\wedge P)\\). A condição torna-se \\(X \\vee \\neg X\\), que é uma tautologia.\n\nConclusão: A política permite todas as requisições. É completamente ineficaz e altamente redundante, não bloqueando nada.\nConexão com Prolog: Este tipo de problema pode ser detectado analisando as regras em Prolog:\n\n% Política de firewall redundante\npermitida(Req) :- rede_interna(Req), porta_443(Req).\npermitida(Req) :- \\+ rede_interna(Req).\npermitida(Req) :- \\+ porta_443(Req).\n\n% Teste que mostra que tudo é permitido\n?- permitida(qualquer_requisicao).\n% true (sempre, devido à redundância)\n\n% Versão corrigida seria mais restritiva\npermitida(Req) :- rede_interna(Req).\npermitida(Req) :- \\+ rede_interna(Req), conexao_segura(Req).\nQuestão 10: Tautologia, Contradição ou Contingência?\n\nAnálise de Cenário Crítico:\nConsidere o caso onde T = verdadeiro e T = falso (fez treinamento, não bateu meta):\n\n\nPrimeira parte: \\((T \\vee T) \\to B\\)\nPremissa: \\((F \\vee T) = T\\) → Conclusão: B deve ser verdadeiro\nSegunda parte: \\((T \\wedge \\neg T) \\to \\neg B\\)\nPremissa: \\((T \\wedge T) = T\\) → Conclusão: B deve ser falso\nResultado: B deve ser simultaneamente verdadeiro e falso → contradição.\n\n\nDemonstração Formal:\nPara o caso \\((T \\wedge \\neg T)\\):\n\\[F \\equiv (T \\to B) \\wedge (T \\to \\neg B) \\equiv T \\wedge B \\wedge \\neg B\\]\n\nComo \\(B \\wedge \\neg B\\) é sempre falso, a fórmula é falsa para este caso específico.\n\nClassificação: A fórmula é uma contingência (pode ser verdadeira ou falsa dependendo dos valores), mas é logicamente inconsistente para o caso \\((T \\wedge \\neg T)\\).\nImplicação para a Empresa: A política de bônus é inaplicável - cria uma situação onde as regras simultaneamente concedem e negam o bônus para funcionários que fizeram treinamento mas não bateram a meta. A empresa precisa redefinir suas regras para serem consistentes.\nConexão com Prolog: Em Prolog, esta inconsistência seria revelada imediatamente:\n\n% Política inconsistente\nbonus(Func) :- meta_atingida(Func).\nbonus(Func) :- treinamento(Func).\n\\+ bonus(Func) :- treinamento(Func), \\+ meta_atingida(Func).\n\n% Fatos\ntreinamento(joao).\n\\+ meta_atingida(joao).\n\n% Consulta reveladoria\n?- bonus(joao).\n% Resultado inconsistente: true e false simultaneamente\n\n% Política corrigida\nbonus(Func) :- meta_atingida(Func).\nbonus(Func) :- treinamento(Func), meta_atingida(Func).",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Lógica Proposicional @sec-logica-proposicional</span>"
    ]
  },
  {
    "objectID": "02-Sol-Predicativa.html",
    "href": "02-Sol-Predicativa.html",
    "title": "14  Lógica Predicativa Chapter 6",
    "section": "",
    "text": "14.1 Exercícios de Conexão com Prolog Section 7.4\nQuestão 1: Relações em um Sistema Acadêmico\nResoluções:\nConexão com Prolog: Em Prolog, estes predicados se tornariam fatos e regras:\nQuestão 2: O Escopo dos Quantificadores\nAnálise das Fórmulas:\nConexão com Prolog: A ordem dos quantificadores afeta diretamente como o Prolog resolve consultas e unifica variáveis.\nQuestão 3: O Paradoxo do Barbeiro\nResolução: 1. Tradução da Regra: A regra diz que o barbeiro (b) barbeia uma pessoa \\(x\\) se, e somente se, \\(x\\) não se barbeia a si mesmo: \\[\\forall x (Barbeia(b,x) \\leftrightarrow \\neg Barbeia(x,x))\\]\nConexão com Prolog: Este paradoxo ilustra por que o Prolog usa “negação por falha” em vez de negação clássica, evitando contradições deste tipo.\nQuestão 4: Especificação de um Sistema de Arquivos\nResolução:\n\\[\\forall x \\forall y ((Admin(x) \\wedge Arquivo(y)) \\to PodeAcessar(x,y))\\]\n\\[\\forall x \\forall y ((\\neg Admin(x) \\wedge Arquivo(y)) \\to \\neg PodeAcessar(x,y))\\]\nConexão com Prolog:\nQuestão 5: Negando Afirmações Universais\nResoluções:\n\\[\\neg [\\forall x (Programa(x) \\to \\exists y (Bug(y) \\wedge Tem(x,y)))]\\]\n\\[\\equiv \\exists x \\neg [Programa(x) \\to \\exists y (Bug(y) \\wedge Tem(x,y))]\\]\n\\[\\equiv \\exists x [\\Programa(x) \\wedge \\neg \\exists y (Bug(y) \\wedge Tem(x,y))]\\]\n\\[\\equiv \\exists x [Programa(x) \\wedge \\forall y \\neg (Bug(y) \\wedge Tem(x,y))]\\]\n\\[\\equiv \\exists x [Programa(x) \\wedge \\forall y (Bug(y) \\to \\neg Tem(x,y))]\\]\nTradução: “Existe um programa de computador que não tem nenhum bug”\nNegação: \\[\\neg [\\exists x (Politico(x) \\wedge \\forall y (Eleitor(y,x) \\to HonestoCom(x,y)))]\\]\n\\[\\equiv \\forall x \\neg [Politico(x) \\wedge \\forall y (Eleitor(y,x) \\to HonestoCom(x,y))]\\]\n\\[\\equiv \\forall x [Politico(x) \\to \\neg \\forall y (Eleitor(y,x) \\to HonestoCom(x,y))]\\]\n\\[\\equiv \\forall x [Politico(x) \\to \\exists y \\neg (Eleitor(y,x) \\to HonestoCom(x,y))]\\]\n\\[\\equiv \\forall x [Politico(x) \\to \\exists y (Eleitor(y,x) \\wedge \\neg HonestoCom(x,y))]\\]\nTradução: “Todo político é desonesto com pelo menos um de seus eleitores”\nConexão com Prolog: A negação por falha em Prolog (\\+) aproxima-se dessas transformações lógicas.\nQuestão 6: Mundo dos Blocos (Planejamento em Inteligência Artificial) - Corrigida\nConexão com Prolog:\nQuestão 7: Propriedades dos Números Inteiros\nResoluções: 1. Todo número par é maior que algum número ímpar: \\[\\forall x (Par(x) \\to \\exists y (Impar(y) \\wedge x &gt; y))\\]\nConexão com Prolog:\nQuestão 8: Dedução Lógica com Instanciação\nResolução: 1. Premissas: * \\(P_1: \\forall x (Leao(x) \\to Mamifero(x))\\) * \\(P_2: \\exists x (Leao(x) \\wedge ViveNaSavana(x))\\)\nConexão com Prolog:\nQuestão 9: Consulta a uma Base de Dados Relacional\nResolução: A consulta pede os nomes (\\(n\\)) dos funcionários que trabalham no departamento de ‘Vendas’. A fórmula correta deve especificar que estamos procurando por nomes:\n\\[\\{n \\mid \\exists x \\exists d (Func(x,n,d) \\wedge Depto(d,'Vendas'))\\}\\]\nAlternativamente, como uma fórmula lógica que define a condição: \\[\\exists x \\exists d (Func(x,n,d) \\wedge Depto(d,'Vendas'))\\]\nonde \\(n\\) é uma variável livre que representa o nome que estamos buscando.\nConexão com Prolog:\nEm SQL seria:\nQuestão 10: Hierarquia Organizacional\nResoluções:\nConexão com Prolog:\nQuestão 11 - Sistema Bancário\n1. Predicados definidos:\n2. Regras formalizadas: - Todo cliente possui pelo menos uma conta:\n\\[∀x (Cliente(x) → ∃y (Conta(y) ∧ Possui(x, y)))\\]\n3. Consultas úteis: - Encontrar todos os clientes VIP:\n\\[∃x (Cliente(x) ∧ VIP(x))\\]\nEm Prolog\nQuestão 12 - Sistema de Saúde\n1. Predicados definidos:\n2. Regras formalizadas: - Todo paciente é atendido por pelo menos um médico:\n\\[∀y (Paciente(y) → ∃x (Medico(x) ∧ Atende(x, y)))\\]\n3. Consultas úteis: - Encontrar médicos que atendem pacientes internados:\n\\[∃x ∃y (Medico(x) ∧ Paciente(y) ∧ Internado(y) ∧ Atende(x, y))\\]\nEm Prolog\nQuestão 13 - Rede Social\n1. Predicados definidos:\n2. Regras formalizadas: - Amizade é uma relação simétrica:\n\\[∀x ∀y (Amigo(x, y) → Amigo(y, x))\\]\n3. Consultas úteis: - Encontrar postagens mais populares (com curtidas):\n\\[\n  ∃y ∃x₁ ∃x₂ (Postagem(y) ∧ Usuario(x₁) ∧ Usuario(x₂) ∧ x₁ ≠ x₂ ∧ Curtiu(x₁, y) ∧ Curtiu(x₂, y))\n  \\]\nEm Prolog\nQuestão 14 - Sistema de Biblioteca\n1. Predicados definidos:\n2. Regras formalizadas: - Um usuário pode pegar vários livros:\n\\[∃y ∃x₁ ∃x₂ (Usuario(y) ∧ Livro(x₁) ∧ Livro(x₂) ∧ x₁ ≠ x₂ ∧ Emprestado(x₁, y) ∧ Emprestado(x₂, y))\\]\n3. Consultas úteis: - Encontrar livros disponíveis: \\[∃x (Livro(x) ∧ Disponivel(x))\\]\nEm Prolog\nQuestão 15 - Sistema de E-commerce\n1. Predicados definidos:\n2. Regras formalizadas: - Todo produto pertence a pelo menos uma categoria:\n\\[∀x (Produto(x) → ∃c (Categoria(c) ∧ PertenceCategoria(x, c)))\\]\n3. Consultas úteis: - Encontrar produtos populares (com muitas avaliações):\n\\[∃x ∃y₁ ∃y₂ (Produto(x) ∧ Cliente(y₁) ∧ Cliente(y₂) ∧ y₁ ≠ y₂ ∧ ∃n₁ ∃n₂ (Avaliou(y₁, x, n₁) ∧ Avaliou(y₂, x, n₂)))\\]\nEm Prolog\nQuestão 16 - Sistema de Transporte\n1. Predicados definidos:\n2. Regras formalizadas:\n3. Consultas úteis:\nQuestão 17 - Sistema Universitário\n1. Predicados definidos:\n2. Regras formalizadas: - Todo estudante está matriculado em um curso:\n\\[∀x (Estudante(x) → ∃c (Curso(c) ∧ Matriculado(x, c)))\\]\n3. Consultas úteis: - Encontrar estudantes com notas em todas as disciplinas obrigatórias:\n\\[∃x (Estudante(x) ∧ ∀d ((Disciplina(d) ∧ Obrigatoria(d)) → ∃n TemNota(x, d, n)))\\]\nEm Prolog",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Lógica Predicativa @sec-logica-predicativa</span>"
    ]
  },
  {
    "objectID": "02-Sol-Predicativa.html#exercícios-de-conexão-com-prolog-sec-predicativa-conexao-prolog",
    "href": "02-Sol-Predicativa.html#exercícios-de-conexão-com-prolog-sec-predicativa-conexao-prolog",
    "title": "14  Lógica Predicativa Chapter 6",
    "section": "",
    "text": "Existe pelo menos um aluno: \\(\\exists x A(x)\\);\nNem todo aluno está matriculado em algum curso: \\(\\neg \\forall x (A(x) \\to \\exists y (C(y) \\wedge M(x,y)))\\);\nTodo aluno está matriculado em pelo menos um curso: \\(\\forall x (A(x) \\to \\exists y (C(y) \\wedge M(x,y)))\\);\nExiste um curso no qual nenhum aluno está matriculado: \\(\\exists y (C(y) \\wedge \\neg \\exists x (A(x) \\wedge M(x,y)))\\);\nExiste um aluno que está matriculado em todos os cursos: \\(\\exists x (A(x) \\wedge \\forall y (C(y) \\to M(x,y)))\\).\n\n\naluno(joao).\ncurso(matematica).\nmatriculado(joao, matematica).\n\n% Consulta: ?- aluno(X).\n% Resposta: X = joao\n\n\n\nFórmula 1: \\(\\forall x \\exists y (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\nTradução: “Para toda pessoa x, existe uma pessoa y tal que x ama y”\nSignificado: Todo mundo ama alguém. A pessoa y que é amada pode ser diferente para cada x. Isso descreve o amor fraternal universal, onde o ato de amar é universal, mas o objeto do amor é individual.\n\nFórmula 2: \\(\\exists y \\forall x (Pessoa(x) \\to (Pessoa(y) \\wedge Ama(x,y)))\\)\n\nTradução: “Existe uma pessoa y tal que, para toda pessoa x, x ama y”\nSignificado: Existe um indivíduo específico (y) que é amado por todas as outras pessoas. Isso descreve a existência de uma figura universalmente amada.\n\n\n\n\n\n\nDedução da Contradição: Vamos usar a Instanciação Universal, substituindo a variável universal \\(x\\) pela constante \\(b\\) (o próprio barbeiro): \\[Barbeia(b,b) \\leftrightarrow \\neg Barbeia(b,b)\\]\nSeja \\(P\\) a proposição \\(Barbeia(b,b)\\). A fórmula se torna \\(P \\leftrightarrow \\neg P\\). Como vimos na Lógica Proposicional, esta fórmula é uma contradição. Ela afirma que o barbeiro se barbeia se, e somente se, ele não se barbeia. Isso é impossível.\n\n\n\n\n\nTradução da Política:\n\n\n“Qualquer administrador pode acessar todos os arquivos”:\n\n\n\n“Ninguém que não seja administrador pode acessar algum arquivo”:\n\n\n\nConclusões:\n\n\nPara \\(PodeAcessar(ana, relatorio.doc)\\): Dado \\(Admin(ana)\\), a primeira regra se aplica. Por Instanciação Universal com \\(x = ana\\) e \\(y = relatorio.doc\\), concluímos que \\(PodeAcessar(ana, relatorio.doc)\\) é verdadeiro.\nPara \\(PodeAcessar(beto, relatorio.doc)\\): Dado \\(\\neg Admin(beto)\\), a segunda regra se aplica. Por Instanciação Universal, concluímos que \\(\\neg PodeAcessar(beto, relatorio.doc)\\) é verdadeiro.\n\n\nadmin(ana).\narquivo(relatorio_doc).\n\npode_acessar(X, Y) :- admin(X), arquivo(Y).\n\n% Consulta: ?- pode_acessar(ana, relatorio_doc).\n% Resposta: true\n\n\n\nSentença Original: \\(\\forall x (Programa(x) \\to \\exists y (Bug(y) \\wedge Tem(x,y)))\\)\nNegação:\n\n\n\n\n\n\n\n\nSentença Original: \\(\\exists x (Politico(x) \\wedge \\forall y (Eleitor(y,x) \\to HonestoCom(x,y)))\\)\n\n\n\n\n\n\n\n\n\n\nModelagem Formal dos Axiomas:\n\nAxioma 1: Existe um bloco verde em cima de um bloco azul \\[\\exists x \\exists y (Bloco(x) \\wedge Bloco(y) \\wedge Verde(x) \\wedge Azul(y) \\wedge EmCima(x,y))\\]\nAxioma 2: Todo bloco que está diretamente sobre a mesa é azul \\[\\forall x ((Bloco(x) \\wedge NaMesa(x)) \\rightarrow Azul(x))\\]\nAxioma 3: Nenhum bloco pode estar simultaneamente em cima de outro bloco e sobre a mesa \\[\\forall x (Bloco(x) \\rightarrow \\neg(\\exists y (Bloco(y) \\wedge EmCima(x,y)) \\wedge NaMesa(x)))\\]\nAxioma 4: Nenhum bloco pode ser verde e azul simultaneamente \\[\\forall x (Bloco(x) \\rightarrow \\neg(Verde(x) \\wedge Azul(x)))\\]\n\nObjetivo: Provar que “Existe um bloco que não é verde” \\[\\exists x (Bloco(x) \\wedge \\neg Verde(x))\\]\nProva Formal:\n\nPasso 1: Do Axioma 1, por Instanciação Existencial, obtemos constantes \\(a\\) e \\(b\\) tais que: \\[Bloco(a) \\wedge Bloco(b) \\wedge Verde(a) \\wedge Azul(b) \\wedge EmCima(a,b)\\]\nPasso 2: Por Simplificação, podemos separar as propriedades:\n\n\n\\(Bloco(a)\\) é verdadeiro\n\\(Bloco(b)\\) é verdadeiro\n\n\\(Verde(a)\\) é verdadeiro\n\\(Azul(b)\\) é verdadeiro\n\\(EmCima(a,b)\\) é verdadeiro\n\n\nPasso 3: Do Axioma 4, por Instanciação Universal com \\(x = b\\): \\[Bloco(b) \\rightarrow \\neg(Verde(b) \\wedge Azul(b))\\]\nPasso 4: Como sabemos que \\(Bloco(b)\\) é verdadeiro (do Passo 2), por Modus Ponens: \\[\\neg(Verde(b) \\wedge Azul(b))\\]\nPasso 5: Aplicando De Morgan: \\[\\neg Verde(b) \\vee \\neg Azul(b)\\]\nPasso 6: Como sabemos que \\(Azul(b)\\) é verdadeiro (do Passo 2), e temos \\(\\neg Verde(b) \\vee \\neg Azul(b)\\), por Silogismo Disjuntivo: \\[\\neg Verde(b)\\]\nPasso 7: Combinando com \\(Bloco(b)\\) (do Passo 2) usando Adjunção: \\[Bloco(b) \\wedge \\neg Verde(b)\\]\nPasso 8: Por Generalização Existencial: \\[\\exists x (Bloco(x) \\wedge \\neg Verde(x))\\]\n\nC.Q.D. - Provamos que existe um bloco (especificamente o bloco \\(b\\)) que não é verde.\nAnálise Adicional:\nNote que o bloco \\(a\\) (verde) não pode estar na mesa devido ao Axioma 3, pois está em cima de \\(b\\). O bloco \\(b\\) (azul) poderia estar na mesa (consistente com o Axioma 2), mas isso não é necessário para a prova. O importante é que \\(b\\) é azul e, pelo Axioma 4, não pode ser simultaneamente verde.\n\n\n% Definição dos fatos base do mundo dos blocos\nbloco(bloco_a).\nbloco(bloco_b).\nbloco(bloco_c).  % Podemos ter outros blocos no mundo\n\n% Axioma 1: Existe um bloco verde em cima de um bloco azul\nverde(bloco_a).\nazul(bloco_b).\nem_cima(bloco_a, bloco_b).\n\n% Axioma 2: Todo bloco que está sobre a mesa é azul\n% Implementado como regra\nazul(X) :- bloco(X), na_mesa(X).\n\n% Axioma 3: Nenhum bloco pode estar em cima de outro E na mesa\n% Implementado como restrição\nvalido(X) :- \n    bloco(X),\n    \\+ (em_cima(X, _), na_mesa(X)).\n\n% Axioma 4: Nenhum bloco pode ser verde e azul simultaneamente\n% Implementado como restrição\ncor_valida(X) :- \n    bloco(X),\n    \\+ (verde(X), azul(X)).\n\n% Regra derivada: Um bloco não é verde se é azul\nnao_verde(X) :- \n    bloco(X),\n    azul(X),\n    cor_valida(X).\n\n% Consulta principal: Existe um bloco que não é verde?\nexiste_bloco_nao_verde :- \n    bloco(X),\n    \\+ verde(X).\n\n% Testes\ntest_mundo_blocos :-\n    % Verificar que bloco_b não é verde\n    (nao_verde(bloco_b) -&gt;\n        write('Bloco b não é verde (correto)'), nl\n    ;   write('Erro: Bloco b deveria não ser verde'), nl),\n    \n    % Verificar que existe pelo menos um bloco não verde\n    (existe_bloco_nao_verde -&gt;\n        write('Existe um bloco que não é verde (teorema provado)'), nl\n    ;   write('Erro: Deveria existir um bloco não verde'), nl),\n    \n    % Verificar consistência das cores\n    (cor_valida(bloco_a), cor_valida(bloco_b) -&gt;\n        write('Cores são consistentes com Axioma 4'), nl\n    ;   write('Erro: Violação do Axioma 4'), nl).\n\n% Consulta\n% ?- existe_bloco_nao_verde.\n% true.\n\n% ?- nao_verde(X).\n% X = bloco_b.\n\n\n\nNão existe um número inteiro que seja o maior de todos: \\[\\neg \\exists x \\forall y (y \\leq x)\\] ou, de forma equivalente: \\[\\forall x \\exists y (y &gt; x)\\]\nA soma de quaisquer dois números pares é par: \\[\\forall x \\forall y ((Par(x) \\wedge Par(y)) \\to Par(x + y))\\]\n\n\npar(X) :- 0 is X mod 2.\nimpar(X) :- 1 is X mod 2.\n\nmaior_que_impar(X) :- par(X), impar(Y), X &gt; Y.\n\n\n\nProva Formal:\n\nDa premissa \\(P_2\\), por Instanciação Existencial, podemos afirmar que existe uma constante \\(c\\) (vamos chamá-lo de Simba) para a qual a afirmação é verdadeira: \\(Leao(c) \\wedge ViveNaSavana(c)\\).\nDesta conjunção, podemos separar os dois fatos: \\(Leao(c)\\) e \\(ViveNaSavana(c)\\).\nDa premissa \\(P_1\\), por Instanciação Universal, podemos aplicar a regra a qualquer objeto, incluindo nossa constante \\(c\\): \\(Leao(c) \\to Mamifero(c)\\).\nAgora temos a implicação \\(Leao(c) \\to Mamifero(c)\\) e o fato \\(Leao(c)\\). Por Modus Ponens, podemos concluir \\(Mamifero(c)\\).\nNeste ponto, sabemos duas coisas sobre \\(c\\): \\(Mamifero(c)\\) e \\(ViveNaSavana(c)\\). Podemos juntá-las em uma conjunção: \\(Mamifero(c) \\wedge ViveNaSavana(c)\\).\nFinalmente, como encontramos um exemplo específico (\\(c\\)) que satisfaz a condição, podemos usar a Generalização Existencial para concluir: \\(\\exists x (Mamifero(x) \\wedge ViveNaSavana(x))\\). Q.E.D.\n\n\n\nleao(simba).\nvive_na_savana(simba).\n\nmamifero(X) :- leao(X).\n\n% Consulta: ?- mamifero(X), vive_na_savana(X).\n% Resposta: X = simba\n\n\n\n\n\n\nfunc(1, joao, vendas).\nfunc(2, maria, ti).\ndepto(vendas, 'Vendas').\ndepto(ti, 'TI').\n\nfuncionario_vendas(Nome) :- \n    func(_, Nome, Depto), \n    depto(Depto, 'Vendas').\n\n% Consulta: ?- funcionario_vendas(X).\n% Resposta: X = joao\n\nSELECT F.Nome FROM Funcionario F \n  JOIN Departamento D ON F.DeptoID = D.ID \n  WHERE D.NomeDepto = 'Vendas'.\n\n\n\nTodo funcionário tem exatamente um gerente: Isso se divide em duas partes: “pelo menos um” e “no máximo um”:\n\n\\(\\forall x (Funcionario(x) \\to \\exists y Gerente(y,x))\\);\n\\(\\forall x \\forall y \\forall z ((Gerente(y,x) \\wedge Gerente(z,x)) \\to y = z)\\).\n\nNenhum funcionário pode ser gerente de si mesmo:\n\n\\(\\forall x \\neg Gerente(x,x)\\)\n\nTodo gerente é também um funcionário: **\n\n\\(\\forall x (\\exists y Gerente(x,y) \\to Funcionario(x))\\)\n\nExiste um funcionário que não é gerente de ninguém:\n\n\\(\\exists x (Funcionario(x) \\wedge \\neg \\exists y Gerente(x,y))\\)\n\n\n\nfuncionario(joao).\nfuncionario(maria).\nfuncionario(pedro).\n\ngerente(maria, joao).\ngerente(pedro, maria).\n\n% Regra: todo gerente é funcionário\nfuncionario(X) :- gerente(X, _).\n\n% Consulta: funcionário que não é gerente de ninguém\nnao_gerente(X) :- funcionario(X), \\+ gerente(X, _).\n\n% Consulta: ?- nao_gerente(X).\n% Resposta: X = joao\n\n\n\n\\(Cliente(x)\\): x é um cliente\n\\(Conta(y)\\): y é uma conta bancária\n\\(Possui(x, y)\\): cliente x possui conta y\n\\(SaldoPositivo(y)\\): conta y tem saldo positivo\n\\(SaldoNegativo(y)\\): conta y tem saldo negativo\n\\(VIP(x)\\): cliente x é VIP\n\\(Transacao(z)\\): z é uma transação\n\\(RealizouTransacao(x, z)\\): cliente x realizou transação z\n\n\n\n\nToda conta pertence a exatamente um cliente:\n\\[∀y (Conta(y) → ∃x (Cliente(x) ∧ Possui(x, y) ∧ ∀z ((Cliente(z) ∧ Possui(z, y)) → z = x)))\\]\nContas podem ter saldo positivo ou negativo:\n\\[∀y (Conta(y) → (SaldoPositivo(y) ∨ SaldoNegativo(y)))\\]\nExistem clientes VIP que têm mais de uma conta:\n\\[∃x (Cliente(x) ∧ VIP(x) ∧ ∃y ∃z (Conta(y) ∧ Conta(z) ∧ y ≠ z ∧ Possui(x, y) ∧ Possui(x, z)))\\]\nNem todas as contas têm saldo positivo:\n\\[¬∀y (Conta(y) → SaldoPositivo(y))\\]\n\n\n\n\nVerificar se existe alguma conta com saldo negativo:\n\\[∃y (Conta(y) ∧ SaldoNegativo(y))\\]\nEncontrar clientes com múltiplas contas: \\[∃x ∃y ∃z (Cliente(x) ∧ Conta(y) ∧ Conta(z) ∧ y ≠ z ∧ Possui(x, y) ∧ Possui(x, z))\\]\n\n\n% ====================================================================\n% EXERCÍCIO 1 - SISTEMA BANCÁRIO\n% ====================================================================\n\n% Fatos base (dados de exemplo)\ncliente(joao).\ncliente(maria).\ncliente(pedro).\ncliente(ana).\n\nconta(conta1).\nconta(conta2).\nconta(conta3).\nconta(conta4).\nconta(conta5).\n\n% Relação de posse de contas\npossui(joao, conta1).\npossui(maria, conta2).\npossui(maria, conta3).  % Maria tem duas contas (VIP)\npossui(pedro, conta4).\npossui(ana, conta5).\n\n% Status de saldo das contas\nsaldo_positivo(conta1).\nsaldo_positivo(conta2).\nsaldo_positivo(conta4).\n\nsaldo_negativo(conta3).\nsaldo_negativo(conta5).\n\n% Clientes VIP\nvip(maria).\n\n% Transações\ntransacao(trans1).\ntransacao(trans2).\nrealizou_transacao(joao, trans1).\nrealizou_transacao(maria, trans2).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo cliente possui pelo menos uma conta\ncliente_tem_conta(X) :- \n    cliente(X), \n    conta(Y), \n    possui(X, Y).\n\n% Regra 2: Toda conta pertence a exatamente um cliente\nconta_tem_dono_unico(Y) :- \n    conta(Y),\n    possui(X, Y),\n    \\+ (possui(Z, Y), X \\= Z).\n\n% Regra 3: Contas podem ter saldo positivo ou negativo\nconta_tem_saldo(Y) :- \n    conta(Y),\n    (saldo_positivo(Y) ; saldo_negativo(Y)).\n\n% Regra 4: Existem clientes VIP que têm mais de uma conta\ncliente_vip_multiplas_contas(X) :- \n    cliente(X),\n    vip(X),\n    possui(X, Y1),\n    possui(X, Y2),\n    Y1 \\= Y2.\n\n% Regra 5: Nem todas as contas têm saldo positivo (verificação)\nexiste_conta_saldo_negativo :- \n    conta(Y),\n    saldo_negativo(Y).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar todos os clientes VIP\n% ?- vip(X).\n\n% Consulta 2: Verificar se existe alguma conta com saldo negativo\n% ?- existe_conta_saldo_negativo.\n\n% Consulta 3: Encontrar clientes com múltiplas contas\ncliente_multiplas_contas(X) :- \n    cliente(X),\n    possui(X, Y1),\n    possui(X, Y2),\n    Y1 \\= Y2.\n% ?- cliente_multiplas_contas(X).\n\n\n\n\\(Medico(x)\\): x é um médico\n\\(Paciente(y)\\): y é um paciente\n\\(Tratamento(z)\\): z é um tratamento\n\\(Especialidade(w)\\): w é uma especialidade\n\\(Atende(x, y)\\): médico x atende paciente y\n\\(TemEspecialidade(x, w)\\): médico x tem especialidade w\n\\(RequerEspecialista(z)\\): tratamento z requer especialista\n\\(Internado(y)\\): paciente y está internado\n\\(Ambulatorial(y)\\): paciente y é ambulatorial\n\\(Prescreveu(x, z)\\): médico x prescreveu tratamento z\n\n\n\n\nTodo médico tem uma especialidade:\n\\[∀x (Medico(x) → ∃w (Especialidade(w) ∧ TemEspecialidade(x, w)))\\]\nAlguns tratamentos requerem médicos especialistas:\n\\[∃z (Tratamento(z) ∧ RequerEspecialista(z))\\]\nExistem pacientes internados e ambulatoriais:\n\\[∃y (Paciente(y) ∧ Internado(y)) ∧ ∃y (Paciente(y) ∧ Ambulatorial(y))\\]\nTodo tratamento é prescrito por algum médico:\n\\[∀z (Tratamento(z) → ∃x (Medico(x) ∧ Prescreveu(x, z)))\\]\n\n\n\n\nVerificar se há tratamentos sem médico responsável:\n\\[∃z (Tratamento(z) ∧ ¬∃x (Medico(x) ∧ Prescreveu(x, z)))\\]\nListar pacientes atendidos por múltiplos médicos:\n\\[∃y ∃x₁ ∃x₂ (Paciente(y) ∧ Medico(x₁) ∧ Medico(x₂) ∧ x₁ ≠ x₂ ∧ Atende(x₁, y) ∧ Atende(x₂, y))\\]\n\n\n% ====================================================================\n% EXERCÍCIO 2 - SISTEMA DE SAÚDE\n% ====================================================================\n\n% Fatos base\nmedico(dr_silva).\nmedico(dra_santos).\nmedico(dr_costa).\n\npaciente(carlos).\npaciente(lucia).\npaciente(roberto).\npaciente(amanda).\n\ntratamento(trat1).\ntratamento(trat2).\ntratamento(trat3).\n\nespecialidade(cardiologia).\nespecialidade(neurologia).\nespecialidade(pediatria).\n\n% Relações\natende(dr_silva, carlos).\natende(dr_silva, lucia).\natende(dra_santos, roberto).\natende(dr_costa, amanda).\n\ntem_especialidade(dr_silva, cardiologia).\ntem_especialidade(dra_santos, neurologia).\ntem_especialidade(dr_costa, pediatria).\n\nrequer_especialista(trat2).\n\ninternado(carlos).\nambulatorial(lucia).\nambulatorial(roberto).\ninternado(amanda).\n\nprescreveu(dr_silva, trat1).\nprescreveu(dra_santos, trat2).\nprescreveu(dr_costa, trat3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo paciente é atendido por pelo menos um médico\npaciente_tem_medico(Y) :- \n    paciente(Y),\n    medico(X),\n    atende(X, Y).\n\n% Regra 2: Todo médico tem uma especialidade\nmedico_tem_especialidade(X) :- \n    medico(X),\n    especialidade(W),\n    tem_especialidade(X, W).\n\n% Regra 3: Alguns tratamentos requerem médicos especialistas\ntratamento_especialista(Z) :- \n    tratamento(Z),\n    requer_especialista(Z).\n\n% Regra 4: Existem pacientes internados e ambulatoriais\nexiste_internado :- paciente(Y), internado(Y).\nexiste_ambulatorial :- paciente(Y), ambulatorial(Y).\n\n% Regra 5: Todo tratamento é prescrito por algum médico\ntratamento_tem_medico(Z) :- \n    tratamento(Z),\n    medico(X),\n    prescreveu(X, Z).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar médicos que atendem pacientes internados\nmedico_atende_internado(X) :- \n    medico(X),\n    paciente(Y),\n    internado(Y),\n    atende(X, Y).\n% ?- medico_atende_internado(X).\n\n% Consulta 2: Verificar se há tratamentos sem médico responsável\ntratamento_sem_medico(Z) :- \n    tratamento(Z),\n    \\+ prescreveu(_, Z).\n% ?- tratamento_sem_medico(Z).\n\n% Consulta 3: Listar pacientes atendidos por múltiplos médicos\npaciente_multiplos_medicos(Y) :- \n    paciente(Y),\n    atende(X1, Y),\n    atende(X2, Y),\n    X1 \\= X2.\n% ?- paciente_multiplos_medicos(Y).\n\n\n\n\\(Usuario(x)\\): x é um usuário\n\\(Postagem(y)\\): y é uma postagem\n\\(Curtida(z)\\): z é uma curtida\n\\(Amigo(x, y)\\): usuário x é amigo de usuário y\n\\(Publicou(x, y)\\): usuário x publicou postagem y\n\\(Curtiu(x, y)\\): usuário x curtiu postagem y\n\\(Influenciador(x)\\): usuário x é influenciador\n\\(Segue(x, y)\\): usuário x segue usuário y\n\n\n\n\nTodo usuário pode publicar postagens:\n\\[∀x (Usuario(x) → ∃y (Postagem(y) ∧ Publicou(x, y)))\\]\nUsuários podem curtir postagens de amigos:\n\\[\n∀x ∀y ∀z ((Usuario(x) ∧ Usuario(y) ∧ Postagem(z) ∧ Amigo(x, y) ∧ Publicou(y, z)) → Curtiu(x, z))\n\\]\nExistem usuários influenciadores:\n\\[\n∃x (Usuario(x) ∧ Influenciador(x) ∧ ∀y ((Usuario(y) ∧ y ≠ x) → Segue(y, x)))\n\\]\nNem toda postagem recebe curtidas:\n\\[\n¬∀y (Postagem(y) → ∃x (Usuario(x) ∧ Curtiu(x, y)))\n\\]\n\n\n\n\nVerificar usuários sem amigos:\n\\[\n∃x (Usuario(x) ∧ ¬∃y (Usuario(y) ∧ Amigo(x, y)))\n\\]\nListar influenciadores:\n\\[\n∃x (Usuario(x) ∧ Influenciador(x))\n\\]\n\n\n% ====================================================================\n% EXERCÍCIO 3 - REDE SOCIAL\n% ====================================================================\n\n% Fatos base\nusuario(alice).\nusuario(bob).\nusuario(carol).\nusuario(david).\nusuario(eva).\n\npostagem(post1).\npostagem(post2).\npostagem(post3).\npostagem(post4).\n\n% Amizades (relação simétrica)\namigo(alice, bob).\namigo(bob, alice).\namigo(bob, carol).\namigo(carol, bob).\namigo(carol, david).\namigo(david, carol).\n\npublicou(alice, post1).\npublicou(bob, post2).\npublicou(carol, post3).\npublicou(eva, post4).\n\ncurtiu(bob, post1).\ncurtiu(alice, post2).\ncurtiu(carol, post2).\ncurtiu(david, post3).\n% post4 não tem curtidas\n\ninfluenciador(eva).\n\nsegue(alice, eva).\nsegue(bob, eva).\nsegue(carol, eva).\nsegue(david, eva).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Amizade é uma relação simétrica (já implementada nos fatos)\namizade_simetrica(X, Y) :- \n    amigo(X, Y),\n    amigo(Y, X).\n\n% Regra 2: Todo usuário pode publicar postagens\nusuario_pode_publicar(X) :- \n    usuario(X),\n    postagem(Y),\n    publicou(X, Y).\n\n% Regra 3: Usuários podem curtir postagens de amigos\npode_curtir_de_amigo(X, Z) :- \n    usuario(X),\n    usuario(Y),\n    postagem(Z),\n    amigo(X, Y),\n    publicou(Y, Z).\n\n% Regra 4: Existem usuários influenciadores\nusuario_influenciador(X) :- \n    usuario(X),\n    influenciador(X),\n    findall(Y, (usuario(Y), Y \\= X, segue(Y, X)), Seguidores),\n    length(Seguidores, N),\n    N &gt; 3.  % Tem mais de 3 seguidores\n\n% Regra 5: Nem toda postagem recebe curtidas\npostagem_sem_curtida(Y) :- \n    postagem(Y),\n    \\+ curtiu(_, Y).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar postagens populares (com múltiplas curtidas)\npostagem_popular(Y) :- \n    postagem(Y),\n    curtiu(X1, Y),\n    curtiu(X2, Y),\n    X1 \\= X2.\n% ?- postagem_popular(Y).\n\n% Consulta 2: Verificar usuários sem amigos\nusuario_sem_amigos(X) :- \n    usuario(X),\n    \\+ amigo(X, _).\n% ?- usuario_sem_amigos(X).\n\n% Consulta 3: Listar influenciadores\n% ?- influenciador(X).\n\n\n\n\\(Livro(x)\\): x é um livro\n\\(Usuario(y)\\): y é um usuário\n\\(Emprestado(x, y)\\): livro x está emprestado para usuário y\n\\(Disponivel(x)\\): livro x está disponível\n\\(Reservado(x, y)\\): livro x está reservado por usuário y\n\\(DataDevolucao(x, d)\\): empréstimo do livro x tem data de devolução d\n\\(JaFoiEmprestado(x)\\): livro x já foi emprestado alguma vez\n\n\n\n\nUm livro só pode estar com um usuário por vez:\n\\[∀x ∀y₁ ∀y₂ ((Livro(x) ∧ Emprestado(x, y₁) ∧ Emprestado(x, y₂)) → y₁ = y₂)\\]\nNem todos os livros estão emprestados:\n\\[¬∀x (Livro(x) → ∃y Emprestado(x, y))\\]\nExistem livros que nunca foram emprestados: \\[∃x (Livro(x) ∧ ¬JaFoiEmprestado(x))\\]\nTodo empréstimo tem data de devolução: \\[∀x ∀y (Emprestado(x, y) → ∃d DataDevolucao(x, d))\\]\n\n\n\nVerificar usuários com empréstimos ativos: \\[∃y ∃x (Usuario(y) ∧ Livro(x) ∧ Emprestado(x, y))\\]\nListar livros nunca emprestados: \\[∃x (Livro(x) ∧ ¬JaFoiEmprestado(x))\\]\n\n\n% ====================================================================\n% EXERCÍCIO 4 - SISTEMA DE BIBLIOTECA\n% ====================================================================\n\n% Fatos base\nlivro(livro1).\nlivro(livro2).\nlivro(livro3).\nlivro(livro4).\nlivro(livro5).\n\nusuario_bib(user1).\nusuario_bib(user2).\nusuario_bib(user3).\n\nemprestado(livro1, user1).\nemprestado(livro2, user1).  % user1 tem 2 livros\nemprestado(livro3, user2).\n\ndisponivel(livro4).\ndisponivel(livro5).\n\ndata_devolucao(livro1, '2025-02-15').\ndata_devolucao(livro2, '2025-02-20').\ndata_devolucao(livro3, '2025-02-18').\n\nja_foi_emprestado(livro1).\nja_foi_emprestado(livro2).\nja_foi_emprestado(livro3).\n% livro4 e livro5 nunca foram emprestados\n\nreservado(livro4, user3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Um usuário pode pegar vários livros\nusuario_multiplos_livros(Y) :- \n    usuario_bib(Y),\n    emprestado(X1, Y),\n    emprestado(X2, Y),\n    X1 \\= X2.\n\n% Regra 2: Um livro só pode estar com um usuário por vez\nlivro_usuario_unico(X) :- \n    livro(X),\n    emprestado(X, Y),\n    \\+ (emprestado(X, Z), Y \\= Z).\n\n% Regra 3: Nem todos os livros estão emprestados\nexiste_livro_disponivel :- \n    livro(X),\n    \\+ emprestado(X, _).\n\n% Regra 4: Existem livros que nunca foram emprestados\nlivro_nunca_emprestado(X) :- \n    livro(X),\n    \\+ ja_foi_emprestado(X).\n\n% Regra 5: Todo empréstimo tem data de devolução\nemprestimo_tem_data(X, Y) :- \n    emprestado(X, Y),\n    data_devolucao(X, _).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar livros disponíveis\n% ?- disponivel(X).\n\n% Consulta 2: Verificar usuários com empréstimos ativos\nusuario_com_emprestimo(Y) :- \n    usuario_bib(Y),\n    emprestado(_, Y).\n% ?- usuario_com_emprestimo(Y).\n\n% Consulta 3: Listar livros nunca emprestados\n% ?- livro_nunca_emprestado(X).\n\n\n\n\\(Produto(x)\\): x é um produto\n\\(Cliente(y)\\): y é um cliente\n\\(Pedido(z)\\): z é um pedido\n\\(Categoria(c)\\): c é uma categoria\n\\(PertenceCategoria(x, c)\\): produto x pertence à categoria c\n\\(FezPedido(y, z)\\): cliente y fez pedido z\n\\(ContemProduto(z, x)\\): pedido z contém produto x\n\\(TemAvaliacao(x)\\): produto x tem avaliação\n\\(EmPromocao(x)\\): produto x está em promoção\n\\(Avaliou(y, x, nota)\\): cliente y avaliou produto x com nota\n\n\n\n\nTodo pedido é feito por exatamente um cliente:\n\\[∀z (Pedido(z) → ∃y (Cliente(y) ∧ FezPedido(y, z) ∧ ∀w ((Cliente(w) ∧ FezPedido(w, z)) → w = y)))\\]\nNem todo produto tem avaliações:\n\\[¬∀x (Produto(x) → TemAvaliacao(x))\\]\nExistem produtos em promoção:\n\\[∃x (Produto(x) ∧ EmPromocao(x))\\]\nClientes podem fazer múltiplos pedidos: \\[∃y ∃z₁ ∃z₂ (Cliente(y) ∧ Pedido(z₁) ∧ Pedido(z₂) ∧ z₁ ≠ z₂ ∧ FezPedido(y, z₁) ∧ FezPedido(y, z₂))\\]\n\n\n\n\nListar produtos em promoção sem avaliações:\n∃x (Produto(x) ∧ EmPromocao(x) ∧ ¬TemAvaliacao(x))\nVerificar clientes frequentes:\n\\[∃y ∃z₁ ∃z₂ ∃z₃ (Cliente(y) ∧ Pedido(z₁) ∧ Pedido(z₂) ∧ Pedido(z₃) ∧ z₁ ≠ z₂ ∧ z₂ ≠ z₃ ∧ z₁ ≠ z₃ ∧ FezPedido(y, z₁) ∧ FezPedido(y, z₂) ∧ FezPedido(y, z₃))\\]\n\n\n% ====================================================================\n% EXERCÍCIO 5 - SISTEMA DE E-COMMERCE\n% ====================================================================\n\n% Fatos base\nproduto(prod1).\nproduto(prod2).\nproduto(prod3).\nproduto(prod4).\n\ncliente_ec(cliente1).\ncliente_ec(cliente2).\ncliente_ec(cliente3).\n\npedido(pedido1).\npedido(pedido2).\npedido(pedido3).\npedido(pedido4).\n\ncategoria(eletronicos).\ncategoria(livros).\ncategoria(roupas).\n\npertence_categoria(prod1, eletronicos).\npertence_categoria(prod2, livros).\npertence_categoria(prod3, roupas).\npertence_categoria(prod4, eletronicos).\npertence_categoria(prod4, roupas).  % prod4 em duas categorias\n\nfez_pedido(cliente1, pedido1).\nfez_pedido(cliente1, pedido2).  % cliente1 fez múltiplos pedidos\nfez_pedido(cliente2, pedido3).\nfez_pedido(cliente3, pedido4).\n\ncontem_produto(pedido1, prod1).\ncontem_produto(pedido2, prod2).\ncontem_produto(pedido3, prod3).\ncontem_produto(pedido4, prod4).\n\ntem_avaliacao(prod1).\ntem_avaliacao(prod2).\n% prod3 e prod4 não têm avaliação\n\nem_promocao(prod3).\nem_promocao(prod4).\n\navaliou(cliente1, prod1, 5).\navaliou(cliente2, prod1, 4).\navaliou(cliente1, prod2, 3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo produto pertence a pelo menos uma categoria\nproduto_tem_categoria(X) :- \n    produto(X),\n    categoria(C),\n    pertence_categoria(X, C).\n\n% Regra 2: Todo pedido é feito por exatamente um cliente\npedido_cliente_unico(Z) :- \n    pedido(Z),\n    fez_pedido(Y, Z),\n    \\+ (fez_pedido(W, Z), Y \\= W).\n\n% Regra 3: Nem todo produto tem avaliações\nproduto_sem_avaliacao(X) :- \n    produto(X),\n    \\+ tem_avaliacao(X).\n\n% Regra 4: Existem produtos em promoção\nexiste_promocao :- \n    produto(X),\n    em_promocao(X).\n\n% Regra 5: Clientes podem fazer múltiplos pedidos\ncliente_multiplos_pedidos(Y) :- \n    cliente_ec(Y),\n    fez_pedido(Y, Z1),\n    fez_pedido(Y, Z2),\n    Z1 \\= Z2.\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar produtos populares (com múltiplas avaliações)\nproduto_popular(X) :- \n    produto(X),\n    avaliou(Y1, X, _),\n    avaliou(Y2, X, _),\n    Y1 \\= Y2.\n% ?- produto_popular(X).\n\n% Consulta 2: Listar produtos em promoção sem avaliações\npromocao_sem_avaliacao(X) :- \n    produto(X),\n    em_promocao(X),\n    \\+ tem_avaliacao(X).\n% ?- promocao_sem_avaliacao(X).\n\n% Consulta 3: Verificar clientes frequentes (3+ pedidos)\ncliente_frequente(Y) :- \n    cliente_ec(Y),\n    findall(Z, fez_pedido(Y, Z), Pedidos),\n    length(Pedidos, N),\n    N &gt;= 2.  % Ajustado para o exemplo\n% ?- cliente_frequente(Y).\n\n\n\n\\(Motorista(x)\\): x é um motorista\n\\(Passageiro(y)\\): y é um passageiro\n\\(Viagem(v)\\): v é uma viagem\n\\(Veiculo(c)\\): c é um veículo\n\\(Possui(x, c)\\): motorista x possui veículo c\n\\(RealizouViagem(x, y, v)\\): motorista x realizou viagem v com passageiro y\n\\(RecebeuAvaliacao(v, nota)\\): viagem v recebeu avaliação com nota\n\\(Premium(x)\\): motorista x é premium\n\\(AvaliacaoAlta(x)\\): motorista x tem avaliação alta\n\n\n\nTodo motorista possui exatamente um veículo:\n$$∀x (Motorista(x) → ∃c (Veiculo(c) ∧ Possui(x, c) ∧ ∀d ((Veiculo(d) ∧ Possui(x, d)) → d = c)))`\nToda viagem conecta um passageiro a um motorista:\n\\[∀v (Viagem(v) → ∃x ∃y (Motorista(x) ∧ Passageiro(y) ∧ RealizouViagem(x, y, v)))\\]\nNem toda viagem recebe avaliação:\n\\[¬∀v (Viagem(v) → ∃nota RecebeuAvaliacao(v, nota))\\]\nExistem motoristas premium (alta avaliação):\n\\[∃x (Motorista(x) ∧ Premium(x) ∧ AvaliacaoAlta(x))\\]\nPassageiros podem avaliar motoristas:\n\\[∀y ∀x ∀v ((Passageiro(y) ∧ Motorista(x) ∧ Viagem(v) ∧ RealizouViagem(x, y, v)) → ∃nota RecebeuAvaliacao(v, nota))\\]\n\n\n\nEncontrar motoristas premium:\n\\[∃x (Motorista(x) ∧ Premium(x))\\]\nVerificar viagens sem avaliação:\n\\[∃v (Viagem(v) ∧ ¬∃nota RecebeuAvaliacao(v, nota))\\]\nListar passageiros frequentes:\n\\[∃y ∃v₁ ∃v₂ (Passageiro(y) ∧ Viagem(v₁) ∧ Viagem(v₂) ∧ v₁ ≠ v₂ ∧ ∃x₁ ∃x₂ (RealizouViagem(x₁, y, v₁) ∧ RealizouViagem(x₂, y, v₂)))\\]\n\n% ====================================================================\n% EXERCÍCIO 6 - SISTEMA DE TRANSPORTE\n% ====================================================================\n\n% Fatos base\nmotorista(mot1).\nmotorista(mot2).\nmotorista(mot3).\n\npassageiro(pass1).\npassageiro(pass2).\npassageiro(pass3).\n\nviagem(viagem1).\nviagem(viagem2).\nviagem(viagem3).\nviagem(viagem4).\n\nveiculo(carro1).\nveiculo(carro2).\nveiculo(carro3).\n\npossui_veiculo(mot1, carro1).\npossui_veiculo(mot2, carro2).\npossui_veiculo(mot3, carro3).\n\nrealizou_viagem(mot1, pass1, viagem1).\nrealizou_viagem(mot1, pass2, viagem2).\nrealizou_viagem(mot2, pass3, viagem3).\nrealizou_viagem(mot3, pass1, viagem4).\n\nrecebeu_avaliacao(viagem1, 5).\nrecebeu_avaliacao(viagem2, 4).\nrecebeu_avaliacao(viagem4, 5).\n% viagem3 não recebeu avaliação\n\npremium(mot1).\npremium(mot3).\n\navaliacao_alta(mot1).\navaliacao_alta(mot3).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo motorista possui exatamente um veículo\nmotorista_veiculo_unico(X) :- \n    motorista(X),\n    possui_veiculo(X, C),\n    \\+ (possui_veiculo(X, D), C \\= D).\n\n% Regra 2: Toda viagem conecta um passageiro a um motorista\nviagem_conecta(T) :- \n    viagem(T),\n    motorista(X),\n    passageiro(Y),\n    realizou_viagem(X, Y, T).\n\n% Regra 3: Nem toda viagem recebe avaliação\nviagem_sem_avaliacao(T) :- \n    viagem(T),\n    \\+ recebeu_avaliacao(T, _).\n\n% Regra 4: Existem motoristas premium (alta avaliação)\nmotorista_premium(X) :- \n    motorista(X),\n    premium(X),\n    avaliacao_alta(X).\n\n% Regra 5: Passageiros podem avaliar motoristas (através das viagens)\npassageiro_pode_avaliar(Y, X) :- \n    passageiro(Y),\n    motorista(X),\n    viagem(T),\n    realizou_viagem(X, Y, T),\n    recebeu_avaliacao(T, _).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar motoristas premium\n% ?- premium(X).\n\n% Consulta 2: Verificar viagens sem avaliação\n% ?- viagem_sem_avaliacao(T).\n\n% Consulta 3: Listar passageiros frequentes\npassageiro_frequente(Y) :- \n    passageiro(Y),\n    realizou_viagem(_, Y, V1),\n    realizou_viagem(_, Y, V2),\n    V1 \\= V2.\n% ?- passageiro_frequente(Y).\n\n\n\n\\(Estudante(x)\\): x é um estudante\n\\(Professor(y)\\): y é um professor\n\\(Disciplina(d)\\): d é uma disciplina\n\\(Curso(c)\\): c é um curso\n\\(Matriculado(x, c)\\): estudante x está matriculado no curso c\n\\(Ministra(y, d)\\): professor y ministra disciplina d\n\\(TemNota(x, d, n)\\): estudante x tem nota n na disciplina d\n\\(Obrigatoria(d)\\): disciplina d é obrigatória\n\\(Optativa(d)\\): disciplina d é optativa\n\\(AreaProfessor(y, a)\\): professor y é da área a\n\\(AreaDisciplina(d, a)\\): disciplina d é da área a\n\n\n\n\nToda disciplina é ministrada por pelo menos um professor:\n\\[∀d (Disciplina(d) → ∃y (Professor(y) ∧ Ministra(y, d)))\\]\nNem todo estudante tem nota em todas as disciplinas:\n\\[¬∀x ∀d ((Estudante(x) ∧ Disciplina(d)) → ∃n TemNota(x, d, n))\\]\nExistem disciplinas obrigatórias e optativas:\n\\[∃d (Disciplina(d) ∧ Obrigatoria(d)) ∧ ∃d (Disciplina(d) ∧ Optativa(d))\\]\nTodo professor ensina disciplinas da sua área:\n\\[∀y ∀d ∀a ((Professor(y) ∧ Disciplina(d) ∧ AreaProfessor(y, a) ∧ Ministra(y, d)) → AreaDisciplina(d, a))\\]\n\n\n\n\nVerificar disciplinas sem professor:\n\\[∃d (Disciplina(d) ∧ ¬∃y (Professor(y) ∧ Ministra(y, d)))\\]\nListar professores que ministram múltiplas disciplinas:\n\\[∃y ∃d₁ ∃d₂ (Professor(y) ∧ Disciplina(d₁) ∧ Disciplina(d₂) ∧ d₁ ≠ d₂ ∧ Ministra(y, d₁) ∧ Ministra(y, d₂))\\]\n\n\n% ====================================================================\n% EXERCÍCIO 7 - SISTEMA UNIVERSITÁRIO\n% ====================================================================\n\n% Fatos base\nestudante(est1).\nestudante(est2).\nestudante(est3).\n\nprofessor(prof1).\nprofessor(prof2).\n\ndisciplina(disc1).\ndisciplina(disc2).\ndisciplina(disc3).\ndisciplina(disc4).\n\ncurso(computacao).\ncurso(matematica).\n\nmatriculado(est1, computacao).\nmatriculado(est2, computacao).\nmatriculado(est3, matematica).\n\nministra(prof1, disc1).\nministra(prof1, disc2).\nministra(prof2, disc3).\nministra(prof2, disc4).\n\ntem_nota(est1, disc1, 8).\ntem_nota(est1, disc2, 9).\ntem_nota(est2, disc1, 7).\ntem_nota(est3, disc3, 10).\n% nem todos têm nota em todas as disciplinas\n\nobrigatoria(disc1).\nobrigatoria(disc2).\noptativa(disc3).\noptativa(disc4).\n\narea_professor(prof1, exatas).\narea_professor(prof2, exatas).\n\narea_disciplina(disc1, exatas).\narea_disciplina(disc2, exatas).\narea_disciplina(disc3, exatas).\narea_disciplina(disc4, exatas).\n\n% REGRAS DE NEGÓCIO\n\n% Regra 1: Todo estudante está matriculado em um curso\nestudante_tem_curso(X) :- \n    estudante(X),\n    curso(C),\n    matriculado(X, C).\n\n% Regra 2: Toda disciplina é ministrada por pelo menos um professor\ndisciplina_tem_professor(D) :- \n    disciplina(D),\n    professor(Y),\n    ministra(Y, D).\n\n% Regra 3: Nem todo estudante tem nota em todas as disciplinas\nestudante_sem_nota_completa(X) :- \n    estudante(X),\n    disciplina(D),\n    \\+ tem_nota(X, D, _).\n\n% Regra 4: Existem disciplinas obrigatórias e optativas\nexiste_obrigatoria :- disciplina(D), obrigatoria(D).\nexiste_optativa :- disciplina(D), optativa(D).\n\n% Regra 5: Todo professor ensina disciplinas da sua área\nprofessor_ensina_sua_area(Y) :- \n    professor(Y),\n    area_professor(Y, A),\n    ministra(Y, D),\n    area_disciplina(D, A).\n\n% CONSULTAS ÚTEIS\n\n% Consulta 1: Encontrar estudantes com notas em todas as disciplinas obrigatórias\nestudante_completo_obrigatorias(X) :- \n    estudante(X),\n    \\+ (disciplina(D), obrigatoria(D), \\+ tem_nota(X, D, _)).\n% ?- estudante_completo_obrigatorias(X).\n\n% Consulta 2: Verificar disciplinas sem professor\ndisciplina_sem_professor(D) :- \n    disciplina(D),\n    \\+ ministra(_, D).\n% ?- disciplina_sem_professor(D).\n\n% Consulta 3: Listar professores que ministram múltiplas disciplinas\nprofessor_multiplas_disciplinas(Y) :- \n    professor(Y),\n    ministra(Y, D1),\n    ministra(Y, D2),\n    D1 \\= D2.\n% ?- professor_multiplas_disciplinas(Y).",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Lógica Predicativa @sec-logica-predicativa</span>"
    ]
  },
  {
    "objectID": "03-Sol-Normais.html",
    "href": "03-Sol-Normais.html",
    "title": "15  Formas Normais Proposicionais Chapter 7",
    "section": "",
    "text": "15.1 Exercícios Conversão Forma Normal Disjuntiva Section 7.1.2.6",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Formas Normais Proposicionais @sec-formas-normais</span>"
    ]
  },
  {
    "objectID": "03-Sol-Normais.html#exercícios-conversão-forma-normal-disjuntiva-sec-exercicios-conversao-fnd",
    "href": "03-Sol-Normais.html#exercícios-conversão-forma-normal-disjuntiva-sec-exercicios-conversao-fnd",
    "title": "15  Formas Normais Proposicionais Chapter 7",
    "section": "",
    "text": "15.1.1 Solução do Exercício 1\nConverter \\(((P \\leftrightarrow Q) \\rightarrow R) \\wedge \\neg(R \\rightarrow (P \\vee Q))\\) para Forma Normal Disjuntiva.\nPasso 1: Eliminar a bicondicional\n\\[\n((P \\leftrightarrow Q) \\rightarrow R) \\equiv (((P \\rightarrow Q) \\wedge (Q \\rightarrow P)) \\rightarrow R)\n\\]\nPasso 2: Eliminar as implicações internas\n\\[\n(((\\neg P \\vee Q) \\wedge (\\neg Q \\vee P)) \\rightarrow R)\n\\]\nPasso 3: Eliminar a implicação principal do primeiro termo\n\\[\n(\\neg((\\neg P \\vee Q) \\wedge (\\neg Q \\vee P)) \\vee R)\n\\]\nPasso 4: Aplicar De Morgan no primeiro termo\n\\[\n((\\neg(\\neg P \\vee Q) \\vee \\neg(\\neg Q \\vee P)) \\vee R)\n\\]\n\\[\n(((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee R)\n\\]\nPasso 5: Trabalhar o segundo termo da conjunção original\n\\[\n\\neg(R \\rightarrow (P \\vee Q)) \\equiv \\neg(\\neg R \\vee (P \\vee Q)) \\equiv R \\wedge \\neg(P \\vee Q) \\equiv R \\wedge \\neg P \\wedge \\neg Q\n\\]\nPasso 6: Formar a conjunção completa\n\\[\n(((P \\wedge \\neg Q) \\vee (Q \\wedge \\neg P)) \\vee R) \\wedge (R \\wedge \\neg P \\wedge \\neg Q)\n\\]\nPasso 7: Aplicar distributividade\n\\[\n((P \\wedge \\neg Q) \\wedge R \\wedge \\neg P \\wedge \\neg Q) \\vee ((Q \\wedge \\neg P) \\wedge R \\wedge \\neg P \\wedge \\neg Q) \\vee (R \\wedge R \\wedge \\neg P \\wedge \\neg Q)\n\\]\nPasso 8: Simplificar\nO primeiro termo contém \\(P \\wedge \\neg P\\) (contradição), o segundo termo se reduz a \\((Q \\wedge \\neg P \\wedge R \\wedge \\neg Q)\\) que contém \\(Q \\wedge \\neg Q\\) (contradição).\nResultado:\n\\[\nR \\wedge \\neg P \\wedge \\neg Q\n\\]\n\n\n15.1.2 Solução do Exercício 2\nConverter \\(\\neg((P \\rightarrow (Q \\rightarrow R)) \\rightarrow ((P \\rightarrow Q) \\rightarrow (P \\rightarrow R)))\\) para Forma Normal Disjuntiva.\nPasso 1: Aplicar a negação da implicação principal\n\\[\n(P \\rightarrow (Q \\rightarrow R)) \\wedge \\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\n\\]\nPasso 2: Eliminar implicações no primeiro termo\n\\[\n(\\neg P \\vee (\\neg Q \\vee R)) \\wedge \\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\n\\]\n\\[\n(\\neg P \\vee \\neg Q \\vee R) \\wedge \\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R))\n\\]\nPasso 3: Trabalhar o segundo termo\n\\[\n\\neg((P \\rightarrow Q) \\rightarrow (P \\rightarrow R)) \\equiv (P \\rightarrow Q) \\wedge \\neg(P \\rightarrow R)\n\\]\n\\[\n(\\neg P \\vee Q) \\wedge \\neg(\\neg P \\vee R) \\equiv (\\neg P \\vee Q) \\wedge (P \\wedge \\neg R)\n\\]\nPasso 4: Formar a conjunção completa\n\\[\n(\\neg P \\vee \\neg Q \\vee R) \\wedge (\\neg P \\vee Q) \\wedge P \\wedge \\neg R\n\\]\nPasso 5: Aplicar distributividade\n\\[\n((\\neg P \\wedge \\neg P \\wedge P \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge P \\wedge \\neg R) \\vee (\\neg Q \\wedge \\neg P \\wedge P \\wedge \\neg R) \\vee (\\neg Q \\wedge Q \\wedge P \\wedge \\neg R) \\vee (R \\wedge \\neg P \\wedge P \\wedge \\neg R) \\vee (R \\wedge Q \\wedge P \\wedge \\neg R))\n\\]\nPasso 6: Simplificar removendo contradições\nTodos os termos contêm contradições (\\(P \\wedge \\neg P\\), \\(Q \\wedge \\neg Q\\) ou \\(R \\wedge \\neg R\\)).\nResultado:\n\\[\nF \\text{ (fórmula insatisfatível)}\n\\]\n\n\n15.1.3 Solução do Exercício 3\nConverter \\((P \\leftrightarrow (Q \\leftrightarrow R)) \\vee \\neg(P \\wedge Q \\wedge R)\\) para Forma Normal Disjuntiva.\nPasso 1: Analisar as duas partes da disjunção\nA fórmula é uma disjunção \\(A \\vee B\\), onde \\(A = (P \\leftrightarrow (Q \\leftrightarrow R))\\) e \\(B = \\neg(P \\wedge Q \\wedge R)\\). Para obter a FND, podemos encontrar a FND de cada parte e uni-las.\nPasso 2: Converter a primeira parte (\\(A\\)) para FND\nA expressão \\(A = (P \\leftrightarrow (Q \\leftrightarrow R))\\) é verdadeira quando um número par de proposições atômicas é falso (zero ou duas). Isso corresponde aos casos \\((T, T, T)\\), \\((T, F, F)\\), \\((F, T, F)\\) e \\((F, F, T)\\). A FND equivalente é:\n\\[A \\equiv (P \\wedge Q \\wedge R) \\vee (P \\wedge \\neg Q \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge \\neg R) \\vee (\\neg P \\wedge \\neg Q \\wedge R)\\]\nPasso 3: Converter a segunda parte (\\(B\\)) para FND\nAplicando a Lei de De Morgan em \\(B\\):\n\\[B \\equiv \\neg(P \\wedge Q \\wedge R) \\equiv \\neg P \\vee \\neg Q \\vee \\neg R\\]\nPasso 4: Unir as duas partes\nAgora, unimos as FNDs de \\(A\\) e \\(B\\) com a disjunção original da fórmula:\n\\[((P \\wedge Q \\wedge R) \\vee (P \\wedge \\neg Q \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge \\neg R) \\vee (\\neg P \\wedge \\neg Q \\wedge R) ) \\vee (\\neg P \\vee \\neg Q \\vee \\neg R)\\]\nPasso 5: Simplificar usando a Lei da Absorção\nA Lei da Absorção, \\(X \\vee (X \\wedge Y) \\equiv X\\), permite simplificar a expressão. Os literais \\(\\neg P\\), \\(\\neg Q\\) e \\(\\neg R\\) absorverão qualquer conjunção que os contenha.\n\n\\(\\neg P\\) absorve \\((\\neg P \\wedge Q \\wedge \\neg R)\\) e \\((\\neg P \\wedge \\neg Q \\wedge R)\\).\n\\(\\neg Q\\) absorve \\((P \\wedge \\neg Q \\wedge \\neg R)\\).\n\\(\\neg R\\) também absorve \\((P \\wedge \\neg Q \\wedge \\neg R)\\).\n\nApós a absorção, a expressão se torna muito mais simples.\nResultado:\n\\[(P \\wedge Q \\wedge R) \\vee \\neg P \\vee \\neg Q \\vee \\neg R\\]\n\n\n15.1.4 Solução do Exercício 4\nConverter \\(\\neg((P \\vee Q) \\rightarrow (R \\wedge S)) \\leftrightarrow (P \\rightarrow \\neg Q)\\) para Forma Normal Disjuntiva.\nPasso 1: Trabalhar o lado esquerdo da bicondicional\n\\[\n\\neg((P \\vee Q) \\rightarrow (R \\wedge S)) \\equiv (P \\vee Q) \\wedge \\neg(R \\wedge S) \\equiv (P \\vee Q) \\wedge (\\neg R \\vee \\neg S)\n\\]\nPasso 2: Aplicar distributividade no lado esquerdo\n\\[\n(P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)\n\\]\nPasso 3: Trabalhar o lado direito\n\\[\nP \\rightarrow \\neg Q \\equiv \\neg P \\vee \\neg Q\n\\]\nPasso 4: Eliminar a bicondicional\n\\[\n((P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)) \\leftrightarrow (\\neg P \\vee \\neg Q)\n\\]\nPasso 5: Aplicar definição de bicondicional\nSeja \\(A = (P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)\\) e \\(B = \\neg P \\vee \\neg Q\\)\n\\[\n(A \\wedge B) \\vee (\\neg A \\wedge \\neg B)\n\\]\nPasso 6: Expandir \\(\\neg B\\)\n\\[\n\\neg B = \\neg(\\neg P \\vee \\neg Q) = P \\wedge Q\n\\]\nPasso 7: Formar a expressão final\n\\[\n(((P \\wedge \\neg R) \\vee (P \\wedge \\neg S) \\vee (Q \\wedge \\neg R) \\vee (Q \\wedge \\neg S)) \\wedge (\\neg P \\vee \\neg Q)) \\vee (\\neg A \\wedge P \\wedge Q)\n\\]\nPasso 8: Aplicar distributividade e simplificar\nApós aplicar distributividade e eliminar contradições:\nResultado:\n\\[\n(P \\wedge \\neg Q \\wedge \\neg R) \\vee (P \\wedge \\neg Q \\wedge \\neg S) \\vee (\\neg P \\wedge Q \\wedge \\neg R) \\vee (\\neg P \\wedge Q \\wedge \\neg S) \\vee (P \\wedge Q \\wedge R \\wedge S)\n\\]\n\n\n15.1.5 Solução do Exercício 5\nConverter \\(((P \\wedge Q) \\rightarrow (R \\vee S)) \\wedge ((R \\rightarrow P) \\vee (S \\rightarrow Q))\\) para Forma Normal Disjuntiva.\nPasso 1: Eliminar implicações no primeiro termo\n\\[\n(\\neg(P \\wedge Q) \\vee (R \\vee S)) \\equiv (\\neg P \\vee \\neg Q \\vee R \\vee S)\n\\]\nPasso 2: Eliminar implicações no segundo termo\n\\[\n((\\neg R \\vee P) \\vee (\\neg S \\vee Q)) \\equiv (\\neg R \\vee P \\vee \\neg S \\vee Q)\n\\]\nPasso 3: Formar a conjunção\n\\[\n(\\neg P \\vee \\neg Q \\vee R \\vee S) \\wedge (\\neg R \\vee P \\vee \\neg S \\vee Q)\n\\]\nPasso 4: Aplicar distributividade\nDistribuindo o primeiro termo sobre o segundo:\n\\[\n(\\neg P \\wedge \\neg R) \\vee (\\neg P \\wedge P) \\vee (\\neg P \\wedge \\neg S) \\vee (\\neg P \\wedge Q) \\vee\n\\]\n\\[\n(\\neg Q \\wedge \\neg R) \\vee (\\neg Q \\wedge P) \\vee (\\neg Q \\wedge \\neg S) \\vee (\\neg Q \\wedge Q) \\vee\n\\]\n\\[\n(R \\wedge \\neg R) \\vee (R \\wedge P) \\vee (R \\wedge \\neg S) \\vee (R \\wedge Q) \\vee\n\\]\n\\[\n(S \\wedge \\neg R) \\vee (S \\wedge P) \\vee (S \\wedge \\neg S) \\vee (S \\wedge Q)\n\\]\nPasso 5: Eliminar contradições\nRemovendo termos com contradições (\\(P \\wedge \\neg P\\), \\(Q \\wedge \\neg Q\\), \\(R \\wedge \\neg R\\), \\(S \\wedge \\neg S\\)):\nResultado:\n\\[\n(\\neg P \\wedge \\neg R) \\vee (\\neg P \\wedge \\neg S) \\vee (\\neg P \\wedge Q) \\vee (\\neg Q \\wedge \\neg R) \\vee (\\neg Q \\wedge P) \\vee (\\neg Q \\wedge \\neg S) \\vee (R \\wedge P) \\vee (R \\wedge \\neg S) \\vee (R \\wedge Q) \\vee (S \\wedge \\neg R) \\vee (S \\wedge P) \\vee (S \\wedge Q)\n\\]\n\n\n15.1.6 Solução do Exercício 6\nConverter \\(\\neg(P \\leftrightarrow \\neg Q) \\rightarrow ((P \\wedge R) \\vee (Q \\wedge \\neg R))\\) para Forma Normal Disjuntiva.\nPasso 1: Trabalhar a negação da bicondicional\n\\[\n\\neg(P \\leftrightarrow \\neg Q) \\equiv (P \\wedge Q) \\vee (\\neg P \\wedge \\neg Q)\n\\]\nPasso 2: Eliminar a implicação principal\n\\[\n\\neg((P \\wedge Q) \\vee (\\neg P \\wedge \\neg Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nPasso 3: Aplicar De Morgan\n\\[\n(\\neg(P \\wedge Q) \\wedge \\neg(\\neg P \\wedge \\neg Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\n\\[\n((\\neg P \\vee \\neg Q) \\wedge (P \\vee Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nPasso 4: Expandir o primeiro termo\n\\[\n((\\neg P \\wedge P) \\vee (\\neg P \\wedge Q) \\vee (\\neg Q \\wedge P) \\vee (\\neg Q \\wedge Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nPasso 5: Simplificar removendo contradições\n\\[\n((\\neg P \\wedge Q) \\vee (P \\wedge \\neg Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nResultado:\n\\[\n(\\neg P \\wedge Q) \\vee (P \\wedge \\neg Q) \\vee (P \\wedge R) \\vee (Q \\wedge \\neg R)\n\\]\n\n\n15.1.7 Solução do Exercício 7",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Formas Normais Proposicionais @sec-formas-normais</span>"
    ]
  },
  {
    "objectID": "03-Sol-Normais.html#exercícios-conversão-forma-normal-conjuntiva-sec-exercicios-conversao-fnc",
    "href": "03-Sol-Normais.html#exercícios-conversão-forma-normal-conjuntiva-sec-exercicios-conversao-fnc",
    "title": "15  Formas Normais Proposicionais Chapter 7",
    "section": "15.2 Exercícios Conversão Forma Normal Conjuntiva Section 7.1.3.7",
    "text": "15.2 Exercícios Conversão Forma Normal Conjuntiva Section 7.1.3.7\n\n15.2.1 Solução do Exercício 1\nConverter \\((P \\leftrightarrow Q) \\rightarrow ((P \\wedge R) \\vee (Q \\wedge \\neg R))\\) para Forma Normal Conjuntiva.\nOs passos 1 a 3 da solução original estão corretos. O erro ocorreu na conversão da forma intermediária para a FNC. Vamos retomar do final do passo 3.\nPasso 3: Expressão intermediária\nA fórmula é equivalente a:\n\\[\n((\\neg P \\vee \\neg Q) \\wedge (P \\vee Q)) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))\n\\]\nPasso 4: Aplicar a distributividade de \\(\\vee\\) sobre \\(\\wedge\\)\nUsando a regra \\((A \\wedge B) \\vee C \\equiv (A \\vee C) \\wedge (B \\vee C)\\), obtemos:\n\\[\n((\\neg P \\vee \\neg Q) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R))) \\wedge ((P \\vee Q) \\vee ((P \\wedge R) \\vee (Q \\wedge \\neg R)))\n\\]\nPasso 5: Simplificar a primeira grande cláusula\n\\[\n\\neg P \\vee \\neg Q \\vee (P \\wedge R) \\vee (Q \\wedge \\neg R)\n\\]\nAplicando distributividade e absorção: \\[(\\neg P \\vee (P \\wedge R)) \\equiv (\\neg P \\vee P) \\wedge (\\neg P \\vee R) \\equiv T \\wedge (\\neg P \\vee R) \\equiv (\\neg P \\vee R)\\]\nE\n\\[(\\neg Q \\vee (Q \\wedge \\neg R)) \\equiv (\\neg Q \\vee Q) \\wedge (\\neg Q \\vee \\neg R) \\equiv T \\wedge (\\neg Q \\vee \\neg R) \\equiv (\\neg Q \\vee \\neg R)\\]\nA cláusula se torna \\((\\neg P \\vee R) \\vee (\\neg Q \\vee \\neg R) \\equiv \\neg P \\vee \\neg Q \\vee R \\vee \\neg R\\), que é uma tautologia (\\(T\\)).\nPasso 6: Simplificar a segunda grande cláusula\n\\[\nP \\vee Q \\vee (P \\wedge R) \\vee (Q \\wedge \\neg R)\n\\]\nPela lei de absorção, \\((P \\vee (P \\wedge R)) \\equiv P\\) e \\((Q \\vee (Q \\wedge \\neg R)) \\equiv Q\\). A cláusula se torna \\(P \\vee Q\\).\nPasso 7: Combinar os resultados\nA fórmula completa é \\(T \\wedge (P \\vee Q)\\).\nResultado:\n\\[\nP \\vee Q\n\\]\n\n\n15.2.2 Solução do Exercício 2\nConverter \\(\\neg((P \\rightarrow Q) \\vee (Q \\rightarrow P)) \\wedge (P \\vee Q)\\) para Forma Normal Conjuntiva.\nPasso 1: Aplicar De Morgan no primeiro termo\n\\[\n\\neg(P \\rightarrow Q) \\wedge \\neg(Q \\rightarrow P) \\wedge (P \\vee Q)\n\\]\nPasso 2: Eliminar implicações\n\\[\n\\neg(\\neg P \\vee Q) \\wedge \\neg(\\neg Q \\vee P) \\wedge (P \\vee Q)\n\\]\nPasso 3: Aplicar De Morgan\n\\[\n(P \\wedge \\neg Q) \\wedge (Q \\wedge \\neg P) \\wedge (P \\vee Q)\n\\]\nPasso 4: Expandir a conjunção\n\\[\nP \\wedge \\neg Q \\wedge Q \\wedge \\neg P \\wedge (P \\vee Q)\n\\]\nPasso 5: Identificar contradição\nA expressão contém \\(P \\wedge \\neg P\\) e \\(Q \\wedge \\neg Q\\), que são contradições.\nResultado:\n\\[\nF \\text{ (fórmula insatisfatível)}\n\\]\n\n\n15.2.3 Solução do Exercício 3\nConverter \\(\\neg((P \\wedge (Q \\vee R)) \\leftrightarrow ((P \\wedge Q) \\vee (P \\wedge R)))\\) para Forma Normal Conjuntiva.\nPasso 1: Observar que é a negação de uma tautologia\nA bicondicional \\((P \\wedge (Q \\vee R)) \\leftrightarrow ((P \\wedge Q) \\vee (P \\wedge R))\\) é a lei distributiva, que é uma tautologia. Sua negação é uma contradição.\nPasso 2: Verificar por expansão\nLado esquerdo: \\(P \\wedge (Q \\vee R)\\)\nLado direito: \\((P \\wedge Q) \\vee (P \\wedge R)\\)\nAplicando distributividade no lado esquerdo:\n\\[\nP \\wedge (Q \\vee R) \\equiv (P \\wedge Q) \\vee (P \\wedge R)\n\\]\nOs dois lados são idênticos, confirmando que a bicondicional é uma tautologia.\nResultado:\n\\[F \\text{ (fórmula insatisfatível)}\\]\n\n\n15.2.4 Solução do Exercício 4\nConverter \\(((P \\vee Q) \\rightarrow R) \\leftrightarrow (P \\rightarrow R) \\wedge (Q \\rightarrow R)\\) para Forma Normal Conjuntiva.\nPasso 1: Trabalhar o lado esquerdo\n\\[\n(P \\vee Q) \\rightarrow R \\equiv \\neg(P \\vee Q) \\vee R \\equiv (\\neg P \\wedge \\neg Q) \\vee R\n\\]\nPasso 2: Trabalhar o lado direito\n\\[\n(P \\rightarrow R) \\wedge (Q \\rightarrow R) \\equiv (\\neg P \\vee R) \\wedge (\\neg Q \\vee R)\n\\]\nAplicando distributividade:\n\\[\n(\\neg P \\wedge \\neg Q) \\vee (\\neg P \\wedge R) \\vee (R \\wedge \\neg Q) \\vee (R \\wedge R)\n\\]\nSimplificando:\n\\[(\\neg P \\wedge \\neg Q) \\vee R\\]\nPasso 3: Observar que ambos os lados são equivalentes\nComo ambos os lados da bicondicional são iguais, a fórmula é uma tautologia.\nResultado:\n\\[T \\text{ (tautologia)}\\]\nComo é uma tautologia, sua Forma Normal Conjuntiva é vazia ou pode ser representada por qualquer cláusula tautológica como \\((P \\vee \\neg P)\\).\n\n\n15.2.5 Solução do Exercício 5\nConverter \\((P \\rightarrow (Q \\rightarrow R)) \\wedge \\neg((P \\wedge Q) \\rightarrow R)\\) para Forma Normal Conjuntiva.\nPasso 1: Eliminar implicações no primeiro termo\n\\[\nP \\rightarrow (Q \\rightarrow R) \\equiv \\neg P \\vee (\\neg Q \\vee R) \\equiv \\neg P \\vee \\neg Q \\vee R\n\\]\nPasso 2: Trabalhar o segundo termo\n\\[\n\\neg((P \\wedge Q) \\rightarrow R) \\equiv \\neg(\\neg(P \\wedge Q) \\vee R) \\equiv (P \\wedge Q) \\wedge \\neg R\n\\]\n\\[P \\wedge Q \\wedge \\neg R\\]\nPasso 3: Formar a conjunção completa\n\\[\n(\\neg P \\vee \\neg Q \\vee R) \\wedge P \\wedge Q \\wedge \\neg R\n\\]\nPasso 4: Reorganizar como cláusulas\n\\[\n(\\neg P \\vee \\neg Q \\vee R) \\wedge P \\wedge Q \\wedge \\neg R\n\\]\nPasso 5: Aplicar a regra de unidade\nQuando temos cláusulas unitárias (\\(P\\), \\(Q\\), \\(\\neg R\\)), podemos simplificar a primeira cláusula:\n\nComo \\(P\\) é verdadeiro, \\(\\neg P\\) é falso\nComo \\(Q\\) é verdadeiro, \\(\\neg Q\\) é falso\nComo \\(\\neg R\\) é verdadeiro, \\(R\\) é falso\n\nA primeira cláusula se torna: \\((F \\vee F \\vee F) = F\\)\nResultado:\n\\[F \\text{ (fórmula insatisfatível)}\\]\n\n\n15.2.6 Solução do Exercício 6\nConverter \\(((P \\leftrightarrow Q) \\vee (Q \\leftrightarrow R)) \\wedge \\neg(P \\leftrightarrow R)\\) para Forma Normal Conjuntiva.\nA conversão para a Forma Normal Disjuntiva no Passo 5 estava correta, mas a conversão subsequente para FNC estava incorreta. Uma abordagem mais segura é converter cada parte para FNC separadamente.\nPasso 1: Converter \\(\\neg(P \\leftrightarrow R)\\) para FNC\n\\[\n\\neg(P \\leftrightarrow R) \\equiv (P \\wedge \\neg R) \\vee (\\neg P \\wedge R)\n\\]\nAplicando a distributividade:\n\\[\n(P \\vee \\neg P) \\wedge (P \\vee R) \\wedge (\\neg R \\vee \\neg P) \\wedge (\\neg R \\vee R) \\equiv (P \\vee R) \\wedge (\\neg P \\vee \\neg R)\n\\]\nPasso 2: Converter \\((P \\leftrightarrow Q) \\vee (Q \\leftrightarrow R)\\) para FNC\nPrimeiro, as FNCs das bicondicionais:\n\\[P \\leftrightarrow Q \\equiv (\\neg P \\vee Q) \\wedge (P \\vee \\neg Q)\\]\n\\[Q \\leftrightarrow R \\equiv (\\neg Q \\vee R) \\wedge (Q \\vee \\neg R)\\]\nA expressão é \\(((\\neg P \\vee Q) \\wedge (P \\vee \\neg Q)) \\vee ((\\neg Q \\vee R) \\wedge (Q \\vee \\neg R))\\).\nAplicando a distributividade \\((A \\wedge B) \\vee (C \\wedge D) \\equiv (A \\vee C) \\wedge (A \\vee D) \\wedge (B \\vee C) \\wedge (B \\vee D)\\):\n\n\\((\\neg P \\vee Q) \\vee (\\neg Q \\vee R) \\equiv \\neg P \\vee T \\vee R \\equiv T\\)\n\\((\\neg P \\vee Q) \\vee (Q \\vee \\neg R) \\equiv \\neg P \\vee Q \\vee \\neg R\\)\n\\((P \\vee \\neg Q) \\vee (\\neg Q \\vee R) \\equiv P \\vee \\neg Q \\vee R\\)\n\\((P \\vee \\neg Q) \\vee (Q \\vee \\neg R) \\equiv P \\vee T \\vee \\neg R \\equiv T\\)\n\nEsta parte simplifica para \\((\\neg P \\vee Q \\vee \\neg R) \\wedge (P \\vee \\neg Q \\vee R)\\).\nPasso 3: Formar a conjunção completa\nJuntando as FNCs de ambas as partes:\nResultado:\n\\[\n(\\neg P \\vee Q \\vee \\neg R) \\wedge (P \\vee \\neg Q \\vee R) \\wedge (P \\vee R) \\wedge (\\neg P \\vee \\neg R)\n\\]\n\n\n15.2.7 Solução do Exercício 7\nConverter \\(\\neg(P \\rightarrow (Q \\vee R)) \\vee ((P \\wedge \\neg Q) \\rightarrow R)\\) para Forma Normal Conjuntiva.\nOs passos 1 a 3 da solução original estão corretos, resultando em:\n\\[\n(P \\wedge \\neg Q \\wedge \\neg R) \\vee (\\neg P \\vee Q \\vee R)\n\\]\nO erro ocorreu na simplificação final após a distributividade.\nPasso 4: Aplicar distributividade para obter FNC\nSeja \\(A = (\\neg P \\vee Q \\vee R)\\). A expressão é \\((P \\wedge \\neg Q \\wedge \\neg R) \\vee A\\). Distribuindo, temos:\n\\[(P \\vee A) \\wedge (\\neg Q \\vee A) \\wedge (\\neg R \\vee A)\\]\nSubstituindo \\(A\\) de volta:\n\\[\n(P \\vee (\\neg P \\vee Q \\vee R)) \\wedge (\\neg Q \\vee (\\neg P \\vee Q \\vee R)) \\wedge (\\neg R \\vee (\\neg P \\vee Q \\vee R))\n\\]\nPasso 5: Simplificar\nAnalisamos cada cláusula:\n\n\\(P \\vee \\neg P \\vee Q \\vee R \\equiv T \\vee Q \\vee R \\equiv T\\);\n\\(\\neg Q \\vee \\neg P \\vee Q \\vee R \\equiv \\neg P \\vee (Q \\vee \\neg Q) \\vee R \\equiv \\neg P \\vee T \\vee R \\equiv T\\);\n\\(\\neg R \\vee \\neg P \\vee Q \\vee R \\equiv \\neg P \\vee Q \\vee (R \\vee \\neg R) \\equiv \\neg P \\vee Q \\vee T \\equiv T\\).\n\nA expressão completa é \\(T \\wedge T \\wedge T\\).\nResultado:\n\\[T \\text{ (a fórmula é uma tautologia)}\\]",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Formas Normais Proposicionais @sec-formas-normais</span>"
    ]
  },
  {
    "objectID": "03-Sol-Normais.html#exercícios-conversão-para-as-formas-normais-prenex",
    "href": "03-Sol-Normais.html#exercícios-conversão-para-as-formas-normais-prenex",
    "title": "15  Formas Normais Proposicionais Chapter 7",
    "section": "15.3 Exercícios Conversão para as Formas Normais Prenex",
    "text": "15.3 Exercícios Conversão para as Formas Normais Prenex\n\n15.3.1 Questão 1\nPasso 1: Identificar quantificadores\n\nTemos \\(\\forall y\\) dentro da conjunção\n\nPasso 2: Mover quantificadores para fora\n\n\\(\\forall y\\) deve ser movido para o início\n\nResultado:\n\\[\\forall y (P(x) \\wedge Q(y))\\]\n\n\n15.3.2 Questão 2\nPasso 1: Eliminar implicação\n\n\\(P(x) \\rightarrow Q(x) \\equiv \\neg P(x) \\vee Q(x)\\).\n\n\\[\\forall x (\\neg P(x) \\vee Q(x)) \\wedge \\exists y R(y)\\]\nPasso 2: Mover quantificadores para fora\n\nPrimeiro \\(\\forall x\\), depois \\(\\exists y\\).\n\nResultado:\n\\[\n\\forall x \\exists y ((\\neg P(x) \\vee Q(x)) \\wedge R(y))\n\\]\n\n\n15.3.3 Questão 3\nPasso 1: Aplicar Lei de De Morgan na negação do quantificador\n\n\\(\\neg \\forall x P(x) \\equiv \\exists x \\neg P(x)\\).\n\n\\[\\exists x \\neg P(x) \\vee \\exists y Q(y)\\]\nPasso 2: Padronizar variáveis (já estão distintas).\nPasso 3: Mover quantificadores para fora.\nResultado:\n\\[\\exists x \\exists y (\\neg P(x) \\vee Q(y))\\]\n\n\n15.3.4 Questão 4\nPasso 1: Eliminar implicação\n\n\\(A \\rightarrow B \\equiv \\neg A \\vee B\\)\n\n\\[\n\\neg(\\forall x \\exists y P(x,y)) \\vee \\exists z \\forall w Q(z,w)\n\\]\nPasso 2: Aplicar De Morgan na negação\n\n\\(\\neg \\forall x \\exists y P(x,y) \\equiv \\exists x \\neg \\exists y P(x,y) \\equiv \\exists x \\forall y \\neg P(x,y)\\)\n\n\\[\n\\exists x \\forall y \\neg P(x,y) \\vee \\exists z \\forall w Q(z,w)\n\\]\nPasso 3: Padronizar variáveis (renomear \\(z\\) para \\(u\\) e \\(w\\) para \\(v\\))\n\\[\n\\exists x \\forall y \\neg P(x,y) \\vee \\exists u \\forall v Q(u,v)\n\\]\nPasso 4: Mover quantificadores para fora\nResultado:\n\\[\n\\exists x \\forall y \\exists u \\forall v (\\neg P(x,y) \\vee Q(u,v))\n\\]\n\n\n15.3.5 Questão 5\nPasso 1: Eliminar bicondicional\n\n\\(A \\leftrightarrow B \\equiv (A \\rightarrow B) \\wedge (B \\rightarrow A)\\)\n\n\\[\n\\forall x ((P(x) \\rightarrow \\exists y Q(x,y)) \\wedge (\\exists y Q(x,y) \\rightarrow P(x))) \\vee \\forall z R(z)\n\\]\nPasso 2: Eliminar implicações\n\\[\n\\forall x ((\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge (\\neg \\exists y Q(x,y) \\vee P(x))) \\vee \\forall z R(z)\n\\]\nPasso 3: Aplicar De Morgan em \\(\\neg \\exists y Q(x,y)\\)\n\\[\n\\forall x ((\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge (\\forall y \\neg Q(x,y) \\vee P(x))) \\vee \\forall z R(z)\n\\]\nPasso 4: Padronizar variáveis (renomear a segunda ocorrência de \\(y\\) para \\(w\\) e \\(z\\) para \\(u\\))\n\\[\n\\forall x ((\\neg P(x) \\vee \\exists y Q(x,y)) \\wedge (\\forall w \\neg Q(x,w) \\vee P(x))) \\vee \\forall u R(u)\n\\]\nPasso 5: Mover quantificadores para fora\nResultado:\n\\[\n\\forall x \\exists y \\forall w \\forall u (((\\neg P(x) \\vee Q(x,y)) \\wedge (\\neg Q(x,w) \\vee P(x))) \\vee R(u))\n\\]\n\n\n15.3.6 Questão 6\nPasso 1: Aplicar De Morgan na primeira negação\n\n\\(\\neg(\\forall x (P(x) \\rightarrow \\exists y Q(x,y))) \\equiv \\exists x \\neg(P(x) \\rightarrow \\exists y Q(x,y))\\)\n\nPasso 2: Eliminar implicação interna\n\n\\(\\neg(P(x) \\rightarrow \\exists y Q(x,y)) \\equiv \\neg(\\neg P(x) \\vee \\exists y Q(x,y)) \\equiv P(x) \\wedge \\neg \\exists y Q(x,y)\\)\n\nPasso 3: Aplicar De Morgan em \\(\\neg \\exists y Q(x,y)\\)\n\n\\(\\neg \\exists y Q(x,y) \\equiv \\forall y \\neg Q(x,y)\\)\n\n\\[\n\\exists x \\forall y (P(x) \\wedge \\neg Q(x,y)) \\wedge \\exists z (\\forall w R(z,w) \\vee S(z))\n\\]\nPasso 4: Padronizar variáveis (renomear \\(z\\) para \\(u\\) e \\(w\\) para \\(v\\))\n\\[\n\\exists x \\forall y (P(x) \\wedge \\neg Q(x,y)) \\wedge \\exists u (\\forall v R(u,v) \\vee S(u))\n\\]\nPasso 5: Mover quantificadores para fora\nResultado:\n\\[\n\\exists x \\forall y \\exists u \\forall v ((P(x) \\wedge \\neg Q(x,y)) \\wedge (R(u,v) \\vee S(u)))\n\\]\n\n\n15.3.7 Questão 7\nPasso 1: Eliminar implicação principal\n\n\\(A \\rightarrow B \\equiv \\neg A \\vee B\\);\n\n\\[\n\\neg(\\neg(\\exists x \\forall y P(x,y))) \\vee (\\forall z (Q(z) \\rightarrow \\exists w R(z,w)) \\wedge \\exists u S(u))\n\\]\nPasso 2: Simplificar dupla negação\n\n\\(\\neg(\\neg A) \\equiv A\\);\n\n\\[\n\\exists x \\forall y P(x,y) \\vee (\\forall z (Q(z) \\rightarrow \\exists w R(z,w)) \\wedge \\exists u S(u))\n\\]\nPasso 3: Eliminar implicação interna\n\n\\(Q(z) \\rightarrow \\exists w R(z,w) \\equiv \\neg Q(z) \\vee \\exists w R(z,w)\\)\n\n\\[\n\\exists x \\forall y P(x,y) \\vee (\\forall z (\\neg Q(z) \\vee \\exists w R(z,w)) \\wedge \\exists u S(u))\n\\]\nPasso 4: Padronizar variáveis (renomear conflitos)\n\nRenomear \\(z\\) para \\(a\\), \\(w\\) para \\(b\\), \\(u\\) para \\(c\\)\n\n\\[\n\\exists x \\forall y P(x,y) \\vee (\\forall a (\\neg Q(a) \\vee \\exists b R(a,b)) \\wedge \\exists c S(c))\n\\]\nPasso 5: Mover quantificadores para fora\n\nOrdem: \\(\\exists x\\), \\(\\forall y\\), \\(\\forall a\\), \\(\\exists b\\), \\(\\exists c\\)\n\nResultado:\n\\[\n\\exists x \\forall y \\forall a \\exists b \\exists c (P(x,y) \\vee ((\\neg Q(a) \\vee R(a,b)) \\wedge S(c)))\n\\]",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Formas Normais Proposicionais @sec-formas-normais</span>"
    ]
  },
  {
    "objectID": "03-Sol-Normais.html#exercícios-de-skolemização-sec-exercicios-skolemizacao",
    "href": "03-Sol-Normais.html#exercícios-de-skolemização-sec-exercicios-skolemizacao",
    "title": "15  Formas Normais Proposicionais Chapter 7",
    "section": "15.4 Exercícios de Skolemização Section 7.2.4",
    "text": "15.4 Exercícios de Skolemização Section 7.2.4\n\n15.4.1 Questão 1\nA fórmula \\(\\exists x \\, P(x)\\) contém um quantificador existencial que não é precedido por nenhum quantificador universal.\nAplicação da Skolemização:\n\nSubstituímos \\(x\\) por uma constante Skolem \\(c\\)\n\nResultado:\n\\[P(c)\\]\n\n\n15.4.2 Questão 2\nA fórmula \\(\\forall x \\exists y \\, Q(x,y)\\) contém um quantificador existencial \\(\\exists y\\) precedido pelo quantificador universal \\(\\forall x\\).\nAplicação da Skolemização:\n\nSubstituímos \\(y\\) por uma função Skolem \\(\\mathbf{f}(x)\\) que depende de \\(x\\)\n\nResultado:\n\\[\\forall x \\, Q(x, \\mathbf{f}(x))\\]\nForma com quantificadores universais implícitos:\n\\[Q(x, \\mathbf{f}(x))\\]\n\n\n15.4.3 Questão 3\nPara a fórmula \\(\\exists a \\forall x \\exists y \\forall z \\exists w \\, R(a,x,y,z,w)\\), identificamos as dependências de cada quantificador existencial:\nAnálise das dependências:\n\n\\(\\exists a\\): Não há quantificadores universais precedentes → Constante Skolem \\(c_1\\)\n\\(\\exists y\\): Precedido por \\(\\forall x\\) → Função Skolem \\(\\mathbf{f}(x)\\)\n\\(\\exists w\\): Precedido por \\(\\forall x\\) e \\(\\forall z\\) → Função Skolem \\(\\mathbf{g}(x,z)\\)\n\nResultado:\n\\[\\forall x \\forall z \\, R(c_1, x, \\mathbf{f}(x), z, \\mathbf{g}(x,z))\\]\nForma com quantificadores universais implícitos:\n\\[R(c_1, x, \\mathbf{f}(x), z, \\mathbf{g}(x,z))\\]\n\n\n15.4.4 Questão 4\nPasso 1: Eliminar a implicação usando \\(A \\rightarrow B \\equiv \\neg A \\vee B\\):\n\\[\\forall x (\\neg P(x) \\vee \\exists y \\, Q(x,y)) \\wedge \\exists z \\, R(z)\\]\nPasso 2: Padronizar variáveis (já são distintas).\nPasso 3: Converter para Forma Normal Prenex movendo os quantificadores para fora:\n\\[\\forall x \\exists y \\exists z ((\\neg P(x) \\vee Q(x,y)) \\wedge R(z))\\]\nPasso 4: Aplicar Skolemização:\n\n\\(\\exists y\\): Precedido por \\(\\forall x\\) → Função Skolem \\(\\mathbf{f}(x)\\)\n\\(\\exists z\\): Precedido por \\(\\forall x\\) → Função Skolem \\(\\mathbf{g}(x)\\)\n\nResultado:\n\\[\\forall x ((\\neg P(x) \\vee Q(x, \\mathbf{f}(x))) \\wedge R(\\mathbf{g}(x)))\\]\nForma com quantificadores implícitos:\n\\[(\\neg P(x) \\vee Q(x, \\mathbf{f}(x))) \\wedge R(\\mathbf{g}(x))\\]\n\n\n15.4.5 Questão 5\nPasso 1: Aplicar a negação ao quantificador existencial usando \\(\\neg \\exists x \\, \\phi \\equiv \\forall x \\neg \\phi\\):\n\\[(\\forall x \\neg \\forall y \\, P(x,y)) \\vee (\\forall z \\exists w \\, S(z,w) \\wedge \\exists u \\, T(u))\\]\nPasso 2: Aplicar a negação ao quantificador universal usando \\(\\neg \\forall y \\, \\phi \\equiv \\exists y \\neg \\phi\\):\n\\[(\\forall x \\exists y \\neg P(x,y)) \\vee (\\forall z \\exists w \\, S(z,w) \\wedge \\exists u \\, T(u))\\]\nPasso 3: Padronizar variáveis (já são distintas).\nPasso 4: Converter para Forma Normal Prenex:\n\\[\\forall x \\exists y \\forall z \\exists w \\exists u (\\neg P(x,y) \\vee (S(z,w) \\wedge T(u)))\\]\nPasso 5: Aplicar Skolemização:\n\n\\(\\exists y\\): Precedido por \\(\\forall x\\) → Função Skolem \\(\\mathbf{f}(x)\\)\n\\(\\exists w\\): Precedido por \\(\\forall x\\) e \\(\\forall z\\) → Função Skolem \\(\\mathbf{g}(x,z)\\)\n\\(\\exists u\\): Precedido por \\(\\forall x\\) e \\(\\forall z\\) → Função Skolem \\(\\mathbf{h}(x,z)\\)\n\nResultado:\n\\[\\forall x \\forall z (\\neg P(x, \\mathbf{f}(x)) \\vee (S(z, \\mathbf{g}(x,z)) \\wedge T(\\mathbf{h}(x,z))))\\]\n\n\n15.4.6 Questão 6\nPasso 1: A fórmula já está estruturada com quantificadores aninhados. Primeiro, eliminamos a implicação:\n\\[\\forall x (\\neg \\text{Estudante}(x) \\vee \\exists y (\\text{Professor}(y) \\wedge \\exists z (\\text{Disciplina}(z) \\wedge \\text{Ensina}(y,z) \\wedge \\text{Estuda}(x,z))))\\]\nPasso 2: Converter para Forma Normal Prenex movendo todos os quantificadores para fora:\n\\[\\forall x \\exists y \\exists z (\\neg \\text{Estudante}(x) \\vee (\\text{Professor}(y) \\wedge \\text{Disciplina}(z) \\wedge \\text{Ensina}(y,z) \\wedge \\text{Estuda}(x,z)))\\]\nPasso 3: Aplicar Skolemização:\n\n\\(\\exists y\\): Precedido por \\(\\forall x\\) → Função Skolem \\(\\mathbf{professor}(x)\\)\n\\(\\exists z\\): Precedido por \\(\\forall x\\) → Função Skolem \\(\\mathbf{disciplina}(x)\\)\n\nResultado:\n\\[\\forall x (\\neg \\text{Estudante}(x) \\vee (\\text{Professor}(\\mathbf{professor}(x)) \\wedge \\text{Disciplina}(\\mathbf{disciplina}(x)) \\wedge \\text{Ensina}(\\mathbf{professor}(x), \\mathbf{disciplina}(x)) \\wedge \\text{Estuda}(x, \\mathbf{disciplina}(x))))\\]\n\n\n15.4.7 Questão 7\nPasso 1: Eliminar a implicação principal \\(A \\rightarrow B \\equiv \\neg A \\vee B\\):\n\\[\\neg(\\forall x \\exists y \\, P(x,y)) \\vee (\\exists u \\forall v \\exists w \\, Q(u,v,w) \\wedge \\forall s \\, R(s))\\]\nPasso 2: Aplicar a negação ao quantificador universal:\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists u \\forall v \\exists w \\, Q(u,v,w) \\wedge \\forall s \\, R(s))\\]\nPasso 3: Padronizar variáveis para evitar conflitos. Renomeamos \\(s\\) para \\(t\\):\n\\[(\\exists x \\forall y \\neg P(x,y)) \\vee (\\exists u \\forall v \\exists w \\, Q(u,v,w) \\wedge \\forall t \\, R(t))\\]\nPasso 4: Converter para Forma Normal Prenex:\n\\[\\exists x \\forall y \\exists u \\forall v \\exists w \\forall t (\\neg P(x,y) \\vee (Q(u,v,w) \\wedge R(t)))\\]\nPasso 5: Aplicar Skolemização:\n\n\\(\\exists x\\): Não há universais precedentes → Constante Skolem \\(c_1\\)\n\\(\\exists u\\): Precedido por \\(\\forall y\\) → Função Skolem \\(\\mathbf{f}(y)\\)\n\\(\\exists w\\): Precedido por \\(\\forall y\\) e \\(\\forall v\\) → Função Skolem \\(\\mathbf{g}(y,v)\\)\n\nResultado:\n\\[\\forall y \\forall v \\forall t (\\neg P(c_1,y) \\vee (Q(\\mathbf{f}(y),v,\\mathbf{g}(y,v)) \\wedge R(t)))\\]\nForma com quantificadores universais implícitos:\n\\[\\neg P(c_1,y) \\vee (Q(\\mathbf{f}(y),v,\\mathbf{g}(y,v)) \\wedge R(t))\\]",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Formas Normais Proposicionais @sec-formas-normais</span>"
    ]
  },
  {
    "objectID": "03-Sol-Normais.html#exercícios-formas-normais-prenex-sec-exercicios-formas-normais-prenex",
    "href": "03-Sol-Normais.html#exercícios-formas-normais-prenex-sec-exercicios-formas-normais-prenex",
    "title": "15  Formas Normais Proposicionais Chapter 7",
    "section": "15.5 Exercícios Formas Normais Prenex Section 7.3.5",
    "text": "15.5 Exercícios Formas Normais Prenex Section 7.3.5\n\n15.5.1 Exercício 1:\nSolução\nExpressando a sentença em Lógica de Primeiro Grau, teremos:\n\\[(\\forall x (A(x) \\rightarrow E(x))) \\lor (\\exists y (P(y) \\land M(y)))\\]\n\n15.5.1.1 Solução para FNC:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(A(x) \\rightarrow E(x)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[\n(\\forall x (\\neg A(x) \\vee E(x))) \\lor (\\exists y (P(y) \\land M(y)))\n\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex. Como as variáveis \\(x\\) e \\(y\\) são independentes, a ordem entre \\(\\forall x\\) e \\(\\exists y\\) pode ser escolhida livremente.\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee E(x)) \\lor (P(y) \\land M(y)))\n\\]\nPasso 3: Distribuir \\(\\lor\\) sobre \\(\\land\\): agora, para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma \\(Z \\lor (X \\land Y)\\), que é equivalente a \\((Z \\lor X) \\land (Z \\lor Y)\\):\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee E(x) \\vee P(y)) \\land (\\neg A(x) \\vee E(x) \\vee M(y)))\n\\]\nResultado: a fórmula final em FNC é:\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee E(x) \\vee P(y)) \\land (\\neg A(x) \\vee E(x) \\vee M(y)))\n\\]\n\n\n15.5.1.2 Solução para FND:\nPasso 1: Remover Implicações e Realizar a Prenexação: os passos iniciais são idênticos aos da conversão para FNC. Removemos as implicações e movemos os quantificadores para obter a forma prenex.\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee E(x)) \\lor (P(y) \\land M(y)))\n\\]\nPasso 2: Analisar a Matriz: o algoritmo para FND exige que a matriz da fórmula seja uma disjunção de conjunções de literais. Analisando a matriz \\((\\neg A(x) \\vee E(x)) \\lor (P(y) \\land M(y))\\), notamos que ela já satisfaz essa condição. Ela é uma disjunção entre os literais \\(\\neg A(x)\\), \\(E(x)\\) e a conjunção \\((P(y) \\land M(y))\\). Assim, nenhuma etapa adicional de distribuição é necessária.\nResultado: a fórmula final em FND é:\n\\[\n\\forall x \\exists y (\\neg A(x) \\vee E(x) \\vee (P(y) \\land M(y)))\n\\]\n\n\n\n15.5.2 Exercício 2\nSolução:\nRepresentando a sentença em Lógica de Primeiro Grau, teremos:\n\\[(\\exists x (A(x) \\land E(x))) \\land (\\forall y (P(y) \\rightarrow N(y)))\\]\n\n15.5.2.1 Solução para FND:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(P(y) \\rightarrow N(y)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[\n(\\exists x (A(x) \\land E(x))) \\land (\\forall y (\\neg P(y) \\lor N(y)))\n\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula. A fórmula resultante está na Forma Normal Prenex.\n\\[\n\\exists x \\forall y ((A(x) \\land E(x)) \\land (\\neg P(y) \\lor N(y)))\n\\]\nPasso 3: Distribuir \\(\\land\\) sobre \\(\\lor\\): a matriz da fórmula, \\((A(x) \\land E(x)) \\land (\\neg P(y) \\lor N(y))\\), ainda não está em FND. Para convertê-la, aplicamos a lei distributiva da conjunção sobre a disjunção. A expressão tem a forma \\(Z \\land (X \\lor Y)\\), que é equivalente a \\((Z \\land X) \\lor (Z \\land Y)\\):\n\\[\n\\exists x \\forall y (((A(x) \\land E(x)) \\land \\neg P(y)) \\lor ((A(x) \\land E(x)) \\land N(y)))\n\\]\nPasso 4: Simplificar a Matriz: podemos remover os parênteses internos nas cláusulas conjuntivas para obter a forma final.\n\\[\n\\exists x \\forall y ((A(x) \\land E(x) \\land \\neg P(y)) \\lor (A(x) \\land E(x) \\land N(y)))\n\\]\nResultado: a fórmula final está em FND, pois sua matriz é uma disjunção de duas cláusulas conjuntivas:\n\\[\n\\exists x \\forall y ((A(x) \\land E(x) \\land \\neg P(y)) \\lor (A(x) \\land E(x) \\land N(y)))\n\\]\n\n\n\n15.5.3 Exercício 3\nSolução:\nTransformando a sentença em Lógica de Primeiro Grau, teremos:\n\\[(\\forall x (E(x) \\rightarrow I(x))) \\lor (\\exists y (P(y) \\land S(y)))\\]\n\n15.5.3.1 Solução para FNC:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(E(x) \\rightarrow I(x)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[\n(\\forall x (\\neg E(x) \\vee I(x))) \\lor (\\exists y (P(y) \\land S(y)))\n\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex.\n\\[\n\\forall x \\exists y ((\\neg E(x) \\vee I(x)) \\lor (P(y) \\land S(y)))\n\\]\nPasso 3: Distribuir \\(\\lor\\) sobre \\(\\land\\): para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma \\(Z \\lor (X \\land Y)\\), que é equivalente a \\((Z \\lor X) \\land (Z \\lor Y)\\):\n\\[\n\\forall x \\exists y ((\\neg E(x) \\vee I(x) \\vee P(y)) \\land (\\neg E(x) \\vee I(x) \\vee S(y)))\n\\]\nResultado: a fórmula final em FNC é:\n\\[\n\\forall x \\exists y ((\\neg E(x) \\vee I(x) \\vee P(y)) \\land (\\neg E(x) \\vee I(x) \\vee S(y)))\n\\]\n\n\n15.5.3.2 Solução para FND:\nPasso 1: Remover Implicações e Realizar a Prenexação: os passos iniciais são os mesmos da conversão para FNC, resultando na forma prenex:\n\\[\n\\forall x \\exists y ((\\neg E(x) \\vee I(x)) \\lor (P(y) \\land S(y)))\n\\]\nPasso 2: Analisar a Matriz: o algoritmo para FND exige que a matriz seja uma disjunção de conjunções. Analisando a matriz \\((\\neg E(x) \\vee I(x)) \\lor (P(y) \\land S(y))\\), notamos que ela já satisfaz essa condição. É uma disjunção de literais (\\(\\neg E(x)\\), \\(I(x)\\)) e uma conjunção (\\((P(y) \\land S(y))\\)). Nenhuma etapa de distribuição é necessária.\nResultado: a fórmula final em FND é:\n\\[\n\\forall x \\exists y (\\neg E(x) \\vee I(x) \\vee (P(y) \\land S(y)))\n\\]\n\n\n\n15.5.4 Exercício 4\nSolução: em Lógica de Primeiro Grau, teremos:\n\\[(\\forall x (A(x) \\rightarrow C(x))) \\lor (\\exists y (P(y) \\land V(y)))\\]\n\n15.5.4.1 Solução para FNC:\nPasso 1: Remover Implicações: primeiro, removemos a implicação \\(A(x) \\rightarrow C(x)\\), aplicando a regra \\(X \\rightarrow Y \\equiv \\neg X \\vee Y\\):\n\\[\n(\\forall x (\\neg A(x) \\vee C(x))) \\lor (\\exists y (P(y) \\land V(y)))\n\\]\nPasso 2: Mover Quantificadores para o Início (Prenexação): movemos os quantificadores para o início da fórmula para obter a Forma Normal Prenex.\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee C(x)) \\lor (P(y) \\land V(y)))\n\\]\nPasso 3: Distribuir \\(\\lor\\) sobre \\(\\land\\): para que a matriz da fórmula esteja em FNC, distribuímos a disjunção sobre a conjunção. A expressão tem a forma \\(Z \\lor (X \\land Y)\\), que é equivalente a \\((Z \\lor X) \\land (Z \\lor Y)\\):\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee C(x) \\vee P(y)) \\land (\\neg A(x) \\vee C(x) \\vee V(y)))\n\\]\nResultado: a fórmula final em FNC é:\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee C(x) \\vee P(y)) \\land (\\neg A(x) \\vee C(x) \\vee V(y)))\n\\]\n\n\n15.5.4.2 Solução para FND:\nPasso 1: Remover Implicações e Realizar a Prenexação: os passos iniciais são os mesmos da conversão para FNC, resultando na forma prenex:\n\\[\n\\forall x \\exists y ((\\neg A(x) \\vee C(x)) \\lor (P(y) \\land V(y)))\n\\]\nPasso 2: Analisar a Matriz: o algoritmo para FND exige que a matriz seja uma disjunção de conjunções. Analisando a matriz \\((\\neg A(x) \\vee C(x)) \\lor (P(y) \\land V(y))\\), notamos que ela já satisfaz essa condição. É uma disjunção de literais (\\(\\neg A(x)\\), \\(C(x)\\)) e uma conjunção (\\((P(y) \\land V(y))\\)). Nenhuma etapa de distribuição é necessária.\nResultado: a fórmula final em FND é:\n\\[\n\\forall x \\exists y (\\neg A(x) \\vee C(x) \\vee (P(y) \\land V(y)))\n\\]\n\n\n\n15.5.5 Exercício 5\nSolução\n\n15.5.5.1 Solução para FNC:\nPasso 1: Eliminar a Equivalência (\\(\\leftrightarrow\\)): A fórmula tem a estrutura \\(\\neg(A \\leftrightarrow B)\\). Primeiro, expandimos a bicondicional usando a regra \\(A \\leftrightarrow B \\equiv (A \\wedge B) \\vee (\\neg A \\wedge \\neg B)\\), e aplicamos a negação externa.\n\\[\n\\neg ((\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists z R(z)) \\vee (\\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\neg \\exists z R(z)))\n\\]\nAplicando a lei de De Morgan na disjunção principal, obtemos: \\[\n\\neg (\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\exists z R(z)) \\wedge \\neg (\\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\wedge \\neg \\exists z R(z))\n\\]\nAplicando a lei de De Morgan novamente em ambas as conjunções:\n\\[\n(\\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\neg \\exists z R(z)) \\wedge (\\neg \\neg \\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\neg \\neg \\exists z R(z))\n\\]\nPasso 2: Eliminar Implicações e Duplas Negações: Agora, eliminamos as implicações e as duplas negações, e movemos as negações para dentro (conversão para FNN).\n\\[\n(\\exists x \\neg (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\forall z \\neg R(z)) \\wedge (\\forall x (P(x) \\rightarrow \\exists y Q(x,y)) \\vee \\exists z R(z))\n\\]\n\\[\n(\\exists x \\neg (\\neg P(x) \\vee \\exists y Q(x,y)) \\vee \\forall z \\neg R(z)) \\wedge (\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\vee \\exists z R(z))\n\\]\n\\[\n(\\exists x (P(x) \\wedge \\forall y \\neg Q(x,y)) \\vee \\forall z \\neg R(z)) \\wedge (\\forall x (\\neg P(x) \\vee \\exists y Q(x,y)) \\vee \\exists z R(z))\n\\]\nPasso 3: Renomear Variáveis e Prenexação: Renomeamos as variáveis para evitar conflitos de escopo (\\(x \\rightarrow u, y \\rightarrow v, z \\rightarrow w\\)) e movemos todos os quantificadores para o início. A ordem dos quantificadores é \\(\\exists x \\forall y \\forall z\\) da primeira parte, e \\(\\forall u \\exists v \\exists w\\) da segunda.\n\\[\n\\exists x \\forall y \\forall z \\forall u \\exists v \\exists w [ ( (P(x) \\wedge \\neg Q(x,y)) \\vee \\neg R(z) ) \\wedge ( (\\neg P(u) \\vee Q(u,v)) \\vee R(w) ) ]\n\\]\nPasso 4: Converter a Matriz para FNC: A matriz precisa ser uma conjunção de disjunções. A primeira parte, \\((P(x) \\wedge \\neg Q(x,y)) \\vee \\neg R(z)\\), precisa ser distribuída: \\((P(x) \\vee \\neg R(z)) \\wedge (\\neg Q(x,y) \\vee \\neg R(z))\\). A segunda parte, \\((\\neg P(u) \\vee Q(u,v)) \\vee R(w)\\), já está na forma disjuntiva.\n\\[\n\\exists x \\forall y \\forall z \\forall u \\exists v \\exists w [ (P(x) \\vee \\neg R(z)) \\wedge (\\neg Q(x,y) \\vee \\neg R(z)) \\wedge (\\neg P(u) \\vee Q(u,v) \\vee R(w)) ]\n\\]\nResultado: a fórmula final em FNCP é:\n\\[\n\\exists x \\forall y \\forall z \\forall u \\exists v \\exists w [ (P(x) \\vee \\neg R(z)) \\wedge (\\neg Q(x,y) \\vee \\neg R(z)) \\wedge (\\neg P(u) \\vee Q(u,v) \\vee R(w)) ]\n\\]\n\n\n\n15.5.6 Exercício 6\nFórmula inicial: \\((\\exists x P(x) \\rightarrow \\forall y Q(y)) \\wedge (\\exists z R(z) \\rightarrow \\forall w S(w))\\)\nSolução\n\n15.5.6.1 Solução para FND:\nPasso 1: Eliminar Implicações: Removemos as implicações em ambas as cláusulas da conjunção.\n\\[\n(\\neg \\exists x P(x) \\vee \\forall y Q(y)) \\wedge (\\neg \\exists z R(z) \\vee \\forall w S(w))\n\\]\nPasso 2: Mover Negações para Dentro (FNN): Aplicamos as regras de negação dos quantificadores.\n\\[\n(\\forall x \\neg P(x) \\vee \\forall y Q(y)) \\wedge (\\forall z \\neg R(z) \\vee \\forall w S(w))\n\\]\nPasso 3: Prenexação: Renomeamos as variáveis na segunda cláusula para evitar conflitos (\\(z \\rightarrow u, w \\rightarrow v\\)) e movemos todos os quantificadores para o início da fórmula.\n\\[\n\\forall x \\forall y \\forall u \\forall v [ (\\neg P(x) \\vee Q(y)) \\wedge (\\neg R(u) \\vee S(v)) ]\n\\]\nPasso 4: Converter a Matriz para FND: A matriz atual, \\((\\neg P(x) \\vee Q(y)) \\wedge (\\neg R(u) \\vee S(v))\\), tem a forma \\((A \\vee B) \\wedge (C \\vee D)\\), que não está em FND. Precisamos aplicar a lei distributiva para convertê-la em uma disjunção de conjunções. Distribuindo \\((A \\vee B)\\) sobre \\((C \\vee D)\\), obtemos: \\(((A \\vee B) \\wedge C) \\vee ((A \\vee B) \\wedge D)\\). Isso expande para: \\((A \\wedge C) \\vee (B \\wedge C) \\vee (A \\wedge D) \\vee (B \\wedge D)\\).\nAplicando aos nossos literais:\n\\[\n(\\neg P(x) \\wedge \\neg R(u)) \\vee (Q(y) \\wedge \\neg R(u)) \\vee (\\neg P(x) \\wedge S(v)) \\vee (Q(y) \\wedge S(v))\n\\]\nResultado: a fórmula final em FNDP, com a matriz distribuída, é:\n\\[\n\\forall x \\forall y \\forall u \\forall v [ (\\neg P(x) \\wedge \\neg R(u)) \\vee (Q(y) \\wedge \\neg R(u)) \\vee (\\neg P(x) \\wedge S(v)) \\vee (Q(y) \\wedge S(v)) ]\n\\]\n\n\n\n15.5.7 Exercício 7\nSolução\nPrimeiro, formalizamos a sentença: * \\(P(x)\\): \\(x\\) é um problema. * \\(S(x,y)\\): \\(y\\) é uma solução para \\(x\\). * \\(D(x)\\): \\(x\\) é difícil.\nA fórmula em lógica de primeira ordem é:\n\\[\n(\\forall x (P(x) \\rightarrow \\exists y S(x,y))) \\rightarrow (\\neg \\forall z (P(z) \\rightarrow D(z)))\n\\]\nPasso 1: Eliminar Implicações e Mover Negações (FNN): Começamos eliminando a implicação principal e, em seguida, as internas.\n\\[\n\\neg (\\forall x (\\neg P(x) \\vee \\exists y S(x,y))) \\vee (\\neg \\forall z (\\neg P(z) \\vee D(z)))\n\\]\nAgora, movemos as negações para dentro dos quantificadores.\n\\[\n(\\exists x \\neg (\\neg P(x) \\vee \\exists y S(x,y))) \\vee (\\exists z \\neg (\\neg P(z) \\vee D(z)))\n\\]\nAplicamos a lei de De Morgan nas disjunções.\n\\[\n(\\exists x (P(x) \\wedge \\neg \\exists y S(x,y))) \\vee (\\exists z (P(z) \\wedge \\neg D(z)))\n\\]\nFinalizamos a conversão para FNN.\n\\[\n(\\exists x (P(x) \\wedge \\forall y \\neg S(x,y))) \\vee (\\exists z (P(z) \\wedge \\neg D(z)))\n\\]\nPasso 2: Prenexação: Renomeamos a variável \\(z\\) para \\(w\\) para evitar conflito e movemos os quantificadores para o início.\n\\[\n\\exists x \\forall y \\exists w [ (P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w)) ]\n\\]\nEsta é a Forma Normal Prenex. Agora, vamos converter a matriz para FNC e FND. A matriz é \\((P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w))\\).\n\n15.5.7.1 Solução para FND:\nA matriz \\((P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w))\\) já está na Forma Normal Disjuntiva, pois é uma disjunção de duas conjunções de literais. Portanto, nenhum passo adicional de distribuição é necessário.\nResultado (FNDP):\n\\[\n\\exists x \\forall y \\exists w [ (P(x) \\wedge \\neg S(x,y)) \\vee (P(w) \\wedge \\neg D(w)) ]\n\\]",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Formas Normais Proposicionais @sec-formas-normais</span>"
    ]
  },
  {
    "objectID": "03-Sol-Normais.html#conexão-com-o-prolog-sec-predicativa-conexao-prolog",
    "href": "03-Sol-Normais.html#conexão-com-o-prolog-sec-predicativa-conexao-prolog",
    "title": "15  Formas Normais Proposicionais Chapter 7",
    "section": "15.6 Conexão com o Prolog Section 7.4",
    "text": "15.6 Conexão com o Prolog Section 7.4\n\n15.6.1 Questão 1\nDada a seguinte fórmula lógica, que representa uma regra de negócio simples: “Se o pedido (\\(P\\)) foi aprovado, então a nota fiscal (\\(N\\)) deve ser emitida, mas não é verdade que a nota fiscal foi emitida sem que o produto esteja em estoque (\\(E\\)).”\nFórmula: \\[(P \\to N) \\wedge \\neg (N \\wedge \\neg E)\\]\n\nEliminar Implicação e Mover Negação:\n\\[(\\neg P \\vee N) \\wedge (\\neg N \\vee \\neg \\neg E)\\]\n\\[(\\neg P \\vee N) \\wedge (\\neg N \\vee E)\\]\nFNC: A fórmula já está em FNC. As cláusulas são \\[(\\neg P \\vee N)\\] e \\[(\\neg N \\vee E)\\].\nFND: Para obter a FND, aplicamos a distributividade:\n\n\\[((\\neg P \\vee N) \\wedge \\neg N) \\vee ((\\neg P \\vee N) \\wedge E)\\]\n\\[(\\neg P \\wedge \\neg N) \\vee (N \\wedge \\neg N) \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\n\\[(\\neg P \\wedge \\neg N) \\vee \\text{Falso} \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\nFND :\n\\[(\\neg P \\wedge \\neg N) \\vee (\\neg P \\wedge E) \\vee (N \\wedge E)\\]\nEm Prolog:\n% Fórmula original: (P -&gt; N) ∧ ¬(N ∧ ¬E)\noriginal(P, N, E, Result) :-\n    (P -&gt; N, \\+ (N, \\+ E)) -&gt; Result = true ; Result = false.\n\n% FNC: (¬P ∨ N) ∧ (¬N ∨ E)\nfnc(P, N, E, Result) :-\n    ((\\+ P ; N), (\\+ N ; E)) -&gt; Result = true ; Result = false.\n\n% FND: (¬P ∧ ¬N) ∨ (¬P ∧ E) ∨ (N ∧ E)\nfnd(P, N, E, Result) :-\n    ((\\+ P, \\+ N) ; (\\+ P, E) ; (N, E)) -&gt; Result = true ; Result = false.\n\n% Testar equivalência\ntest_equivalence :-\n    findall([P, N, E], (member(P, [true, false]), member(N, [true, false]), member(E, [true, false])), Cases),\n    forall(member([P, N, E], Cases),\n           (original(P, N, E, Orig), fnc(P, N, E, FNC), fnd(P, N, E, FND),\n            (Orig = FNC, FNC = FND -&gt;\n                write('Caso '), write([P, N, E]), write(': Equivalente'), nl\n            ;   write('Caso '), write([P, N, E]), write(': Não Equivalente'), nl, fail))).\n\n\n15.6.2 Questão 2\n\nModelagem: \\[I \\leftrightarrow (S \\vee (\\neg C \\wedge T))\\]\nFND: A fórmula \\[S \\vee (\\neg C \\wedge T)\\] já está em Forma Normal Disjuntiva.\n\n\nSignificado: Cada termo (disjunto) representa um cenário completo e independente que ativa a irrigação.\n\\(S\\): O sistema ativa se o solo estiver seco (independentemente de outros fatores).\n\\(\\neg C \\wedge T\\): O sistema ativa se não choveu E a temperatura está alta (mesmo que o solo ainda não esteja tecnicamente seco).\n\nEm Prolog:\n% Condição de ativação: I ↔ (S ∨ (¬C ∧ T))\nactivation(I, S, C, T, Result) :-\n    (I == (S ; (\\+ C, T))) -&gt; Result = true ; Result = false.\n\n% Testar cenários onde a irrigação é ativada\ntest_activation :-\n    findall([S, C, T, I], (member(S, [true, false]), member(C, [true, false]), member(T, [true, false]), member(I, [true, false])), Cases),\n    forall(member([S, C, T, I], Cases),\n           (activation(I, S, C, T, Res),\n            (Res = true -&gt;\n                write('Irrigação ativa para '), write([S, C, T, I]), nl\n            ;   true))).\n\n\n15.6.3 Questão 3\n\nModelagem:\n\n\nR1: \\[I \\to P\\]\n\nR2: \\[\\neg I \\to (P \\leftrightarrow S)\\]\n\nR3: \\[S \\to \\neg I\\]\n\nFórmula Conjunta: \\[(I \\to P) \\wedge (\\neg I \\to (P \\leftrightarrow S)) \\wedge (S \\to \\neg I)\\]\n\n\nConversão para FNC:\n\n\nR1: \\[\\neg I \\vee P\\]\n\nR3: \\[\\neg S \\vee \\neg I\\]\n\nR2: \\[I \\vee (P \\leftrightarrow S) \\equiv I \\vee ((P \\to S) \\wedge (S \\to P)) \\equiv I \\vee ((\\neg P \\vee S) \\wedge (\\neg S \\vee P)) \\equiv (I \\vee \\neg P \\vee S) \\wedge (I \\vee \\neg S \\vee P)\\]\n\n\nFNC Completa: \\[(\\neg I \\vee P) \\wedge (\\neg S \\vee \\neg I) \\wedge (I \\vee \\neg P \\vee S) \\wedge (I \\vee \\neg S \\vee P)\\]\nAnálise: As regras são consistentes. A FNC nos dá um conjunto de restrições que podem ser satisfeitas (ex: \\(I\\), \\(P\\), \\(\\neg S\\) é uma solução). Se uma conexão fosse segura e interna (\\(S \\wedge I\\)), a cláusula \\[(\\neg S \\vee \\neg I)\\] seria falsa, tornando todo o conjunto de regras falso. Isso significa que tal cenário é proibido pelas regras, o que é o comportamento esperado.\n\nEm Prolog:\n% Cláusulas\nclause1(I, P, _) :- \\+ I ; P.\nclause2(_, S, I) :- \\+ S ; \\+ I.\nclause3(I, P, S) :- I ; \\+ P ; S.\nclause4(I, P, S) :- I ; \\+ S ; P.\n\n% Verificar consistência\nconsistent(I, P, S) :- clause1(I, P, _), clause2(_, S, I), clause3(I, P, S), clause4(I, P, S).\n\n% Testar consistência\ntest_consistency :-\n    (consistent(true, true, false) -&gt;\n        write('Consistente: I=true, P=true, S=false'), nl\n    ;   write('Inconsistente para I=true, P=true, S=false'), nl),\n    (consistent(true, true, true) -&gt;\n        write('Consistente: I=true, P=true, S=true'), nl\n    ;   write('Inconsistente para I=true, P=true, S=true (S ∧ I é proibido)'), nl).\n\n\n15.6.4 Questão 4\n\nModelagem:\n\nAlice: \\(A \\leftrightarrow (D \\to (C \\vee (\\neg C \\wedge P)))\\);\n\nBeto: \\(B \\leftrightarrow (D \\to (P \\vee C))\\);\n\nSimplificação e FND Mínima:\n\nAlice: A condição de acesso é \\(C \\vee (\\neg C \\wedge P)\\). Usando a lei da absorção \\((X \\vee (\\neg X \\wedge Y)) \\equiv (X \\vee Y)\\), a fórmula simplifica para \\(C \\vee P\\).\n\nBeto: A condição de acesso é \\(P \\vee C\\).\n\nConclusão: Ambas as políticas simplificam para a mesma FND mínima: \\(C \\vee P\\). Portanto, as políticas de Alice e Beto são logicamente equivalentes.\n\nEm Prolog:\n% Política de Alice: A ↔ (D → (C ∨ (¬C ∧ P)))\nalice(A, D, C, P) :- A == (D -&gt; (C ; (\\+ C, P))).\n\n% Política de Beto: B ↔ (D → (P ∨ C))\nbob(B, D, C, P) :- B == (D -&gt; (P ; C)).\n\n% Testar equivalência\ntest_equivalence :-\n    findall([A, B, D, C, P], (member(A, [true, false]), member(B, [true, false]), \n                              member(D, [true, false]), member(C, [true, false]), member(P, [true, false])), Cases),\n    forall(member([A, B, D, C, P], Cases),\n           (alice(A, D, C, P), bob(B, D, C, P),\n            (A = B -&gt;\n                write('Caso '), write([D, C, P]), write(': Equivalente'), nl\n            ;   write('Caso '), write([D, C, P]), write(': Não Equivalente'), nl, fail))).\n\n\n15.6.5 Questão 5\n\nFórmula: \\(F \\leftrightarrow (P \\vee T)\\)\nConversão: A bicondicional \\(A \\leftrightarrow B\\) é equivalente a \\((A \\to B) \\wedge (B \\to A)\\).\n\\[(F \\to (P \\vee T)) \\wedge ((P \\vee T) \\to F)\\]\nEliminar Implicações:\n\n\\[(\\neg F \\vee P \\vee T) \\wedge (\\neg (P \\vee T) \\vee F)\\]\n\\[(\\neg F \\vee P \\vee T) \\wedge ((\\neg P \\wedge \\neg T) \\vee F)\\]\n\nDistribuir para FNC:\n\n\nO primeiro termo já é uma cláusula.\n\nO segundo termo: \\((\\neg P \\vee F) \\wedge (\\neg T \\vee F)\\).\n\n\nFNC: \\((\\neg F \\vee P \\vee T) \\wedge (\\neg P \\vee F) \\wedge (\\neg T \\vee F)\\).\n\nSignificado das Cláusulas:\n\n\\((\\neg F \\vee P \\vee T)\\): Se o frete foi grátis (\\(F\\)), então o cliente deve ser Prime (\\(P\\)) ou o pedido deve ser de alto valor (\\(T\\));\n\n\\((\\neg P \\vee F)\\): Se o cliente é Prime, o frete deve ser grátis;\n\n\\((\\neg T \\vee F)\\): Se o pedido é de alto valor, o frete deve ser grátis.\n\nEm Prolog:\n% Fórmula original: F ↔ (P ∨ T)\noriginal(F, P, T) :- F == (P ; T).\n\n% FNC: (¬F ∨ P ∨ T) ∧ (¬P ∨ F) ∧ (¬V ∨ F)\nfnc(F, P, T) :- (\\+ F ; P ; T), (\\+ P ; F), (\\+ T ; F).\n\n% Testar equivalência\ntest_equivalence :-\n    findall([F, P, T], (member(F, [true, false]), member(P, [true, false]), member(T, [true, false])), Cases),\n    forall(member([F, P, T], Cases),\n           (original(F, P, T), fnc(F, P, T),\n            (original(F, P, T) = fnc(F, P, T) -&gt;\n                write('Caso '), write([F, P, T]), write(': Equivalente'), nl\n            ;   write('Caso '), write([F, P, T]), write(': Não Equivalente'), nl, fail))).\n\n\n15.6.6 Questão 6\n\nFND Canônica: Soma dos mintermos (casos onde a saída é 1):\n\n\\[(\\neg A \\wedge \\neg B \\wedge C) \\vee (\\neg A \\wedge B \\wedge C) \\vee (A \\wedge \\neg B \\wedge \\neg C) \\vee (A \\wedge \\neg B \\wedge C)\\]\n\nMapa de Karnaugh:\n\n\n\n\n\\(A\\)  \\(BC\\)\n00\n01\n11\n10\n\n\n\n\n0\n0\n1\n1\n0\n\n\n1\n1\n0\n0\n1\n\n\n\nAgrupamentos:\n\nGrupo 1 (vertical): Coluna \\(BC=01\\), linhas \\(A=0,1\\). Termo: \\(\\neg B \\wedge C\\).\n\nGrupo 2 (horizontal): Linha \\(A=1\\), colunas \\(BC=00,01\\). Termo: \\(A \\wedge \\neg B\\).\n\nFND Mínima: \\((\\neg B \\wedge C) \\vee (A \\wedge \\neg B)\\).\n\nEm Prolog:\n% Função de saída da tabela verdade\noutput(A, B, C, Result) :-\n    ((A=false, B=false, C=true); (A=false, B=true, C=true); \n     (A=true, B=false, C=false); (A=true, B=false, C=true)) -&gt; Result = true ; Result = false.\n\n% FND mínima: (¬B ∧ C) ∨ (A ∧ ¬B)\nfnd_min(A, B, C, Result) :-\n    ((\\+ B, C) ; (A, \\+ B)) -&gt; Result = true ; Result = false.\n\n% Testar equivalência\ntest_fnd :-\n    findall([A, B, C], (member(A, [true, false]), member(B, [true, false]), member(C, [true, false])), Cases),\n    forall(member([A, B, C], Cases),\n           (output(A, B, C, Out), fnd_min(A, B, C, FND),\n            (Out = FND -&gt;\n                write('Caso '), write([A, B, C]), write(': Equivalente'), nl\n            ;   write('Caso '), write([A, B, C]), write(': Não Equivalente'), nl, fail))).\n\n\n15.6.7 Questão 7\nSolução:\nPasso 1 - Aplicação da Instanciação Universal\nComo temos \\(\\forall x (L(x) \\to M(x))\\) e queremos aplicar isso ao indivíduo específico \\(S\\), podemos usar a regra de instanciação universal para obter \\(L(S) \\to M(S)\\). Assim, a fórmula se torna:\n\\[((L(S) \\to M(S)) \\wedge L(S)) \\to M(S)\\]\nPasso 2 - Prova por Tabela-Verdade\nPara provar que esta fórmula é uma tautologia, vamos verificar que ela é verdadeira em todas as atribuições possíveis. Primeiro, vamos eliminar a implicação interna:\n\\[((\\neg L(S) \\vee M(S)) \\wedge L(S)) \\to M(S)\\]\nConstruindo a tabela-verdade:\n\n\n\n\n\n\n\n\n\n\n\\(L(S)\\)\n\\(M(S)\\)\n\\(\\neg L(S) \\vee M(S)\\)\n\\((\\neg L(S) \\vee M(S)) \\wedge L(S)\\)\nFórmula\n\n\n\n\nT\nT\nT\nT\nT\n\n\nT\nF\nF\nF\nT\n\n\nF\nT\nT\nF\nT\n\n\nF\nF\nT\nF\nT\n\n\n\nA fórmula é verdadeira em todas as linhas, portanto é uma tautologia.\nPasso 3 - Prova Alternativa por Contradição\nAlternativamente, podemos provar que a fórmula é uma tautologia mostrando que sua negação é insatisfatível (sempre falsa). Negando a fórmula original:\n\\[\\neg [((L(S) \\to M(S)) \\wedge L(S)) \\to M(S)]\\]\nAplicando \\(\\neg(A \\to B) \\equiv A \\wedge \\neg B\\):\n\\[((L(S) \\to M(S)) \\wedge L(S)) \\wedge \\neg M(S)\\]\nExpandindo \\(L(S) \\to M(S) \\equiv \\neg L(S) \\vee M(S)\\):\n\\[((\\neg L(S) \\vee M(S)) \\wedge L(S)) \\wedge \\neg M(S)\\]\nDistribuindo \\(L(S)\\) sobre a disjunção:\n\\[((\\neg L(S) \\wedge L(S)) \\vee (M(S) \\wedge L(S))) \\wedge \\neg M(S)\\]\nComo \\(\\neg L(S) \\wedge L(S)\\) é sempre falso:\n\\[(M(S) \\wedge L(S)) \\wedge \\neg M(S)\\]\nReorganizando:\n\\[L(S) \\wedge M(S) \\wedge \\neg M(S)\\]\nEsta fórmula contém a contradição \\(M(S) \\wedge \\neg M(S)\\), que é sempre falsa.\nPasso 4 - Conversão para Forma Normal Conjuntiva\nA negação da fórmula original (que é uma contradição) já está em Forma Normal Conjuntiva:\n\\[L(S) \\wedge M(S) \\wedge \\neg M(S)\\]\nEsta é uma conjunção de três cláusulas unitárias. Como esta Forma Normal Conjuntiva é sempre falsa (contradição), a fórmula original é sempre verdadeira (tautologia).\nConclusão: como demonstrado tanto pela tabela-verdade quanto pela prova por contradição, a fórmula \\(((\\forall x(L(x) \\to M(x))) \\wedge L(S)) \\to M(S)\\) é uma tautologia. Isso confirma que a inferência “Todos os leões são mamíferos, Simba é um leão, portanto Simba é um mamífero” é logicamente válida em qualquer interpretação. Em Prolog:\n% Implementação da prova de tautologia em SWI-Prolog\n% Fórmula: ((∀x(L(x) → M(x))) ∧ L(S)) → M(S)\n\n% ============================================================================\n% PARTE 1: DEFINIÇÃO DOS FATOS E REGRAS BASE\n% ============================================================================\n\n% Regra universal: todos os leões são mamíferos\nmamifero(X) :- leao(X).\n\n% Fato específico: Simba é um leão\nleao(simba).\n\n% ============================================================================\n% PARTE 2: VERIFICAÇÃO DIRETA DA INFERÊNCIA\n% ============================================================================\n\n% Predicado que verifica se a inferência é válida para um indivíduo específico\ninferencia_valida(Individuo) :-\n    % Se o indivíduo é leão E todos os leões são mamíferos\n    % Então o indivíduo é mamífero\n    (leao(Individuo) -&gt; mamifero(Individuo)).\n\n% Teste da inferência para Simba\nteste_simba :-\n    write('Testando inferência para Simba:'), nl,\n    (inferencia_valida(simba) -&gt;\n        write('✓ Inferência válida: Se Simba é leão, então Simba é mamífero') ;\n        write('✗ Inferência inválida')\n    ), nl.\n\n% ============================================================================\n% PARTE 3: SIMULAÇÃO DA TABELA-VERDADE\n% ============================================================================\n\n% Predicado auxiliar para implicação lógica\nimplica(A, B) :- \\+ A ; B.\n\n% Avaliação da fórmula para todos os valores possíveis\ntabela_verdade :-\n    write('Tabela-verdade para ((L(S) → M(S)) ∧ L(S)) → M(S):'), nl,\n    write('L(S) | M(S) | L(S)→M(S) | (L(S)→M(S))∧L(S) | Fórmula'), nl,\n    write('-----|-----|---------|-------------|--------'), nl,\n    \n    % Testando todas as combinações\n    member(L, [true, false]),\n    member(M, [true, false]),\n    \n    % Calculando subformulas\n    implica(L, M, Impl1),\n    and_logic(Impl1, L, Antecedente),\n    implica(Antecedente, M, Formula),\n    \n    % Exibindo resultado\n    format(' ~w  | ~w  |   ~w   |     ~w     |   ~w  ~n', \n           [L, M, Impl1, Antecedente, Formula]),\n    \n    fail. % Força backtracking para testar todas as combinações\n\ntabela_verdade :- \n    nl, write('Resultado: A fórmula é verdadeira em todas as linhas (TAUTOLOGIA)'), nl.\n\n% Predicados auxiliares para lógica booleana\nimplica(false, _, true).\nimplica(true, true, true).\nimplica(true, false, false).\n\nand_logic(true, true, true).\nand_logic(_, _, false).\n\n% ============================================================================\n% PARTE 4: PROVA POR CONTRADIÇÃO\n% ============================================================================\n\n% Verifica se a negação da fórmula é contraditória\nprova_contradicao :-\n    write('Prova por contradição:'), nl,\n    write('Assumindo que a fórmula é falsa...'), nl,\n    \n    % Negação: ((L(S) → M(S)) ∧ L(S)) ∧ ¬M(S)\n    write('Isso significa: ((L(S) → M(S)) ∧ L(S)) ∧ ¬M(S)'), nl,\n    \n    % Para que isso seja verdade, precisamos:\n    % 1. L(S) → M(S) seja verdade\n    % 2. L(S) seja verdade  \n    % 3. M(S) seja falso\n    \n    write('Para isso ser verdade, precisamos:'), nl,\n    write('1. L(S) → M(S) = verdade'), nl,\n    write('2. L(S) = verdade'), nl,\n    write('3. M(S) = falso'), nl,\n    \n    % Mas se L(S) é verdade e L(S) → M(S) é verdade,\n    % então M(S) deve ser verdade (modus ponens)\n    write('Mas se L(S) = verdade e L(S) → M(S) = verdade,'), nl,\n    write('então M(S) deve ser verdade (modus ponens)'), nl,\n    write('Contradição: M(S) não pode ser verdade e falso simultaneamente'), nl,\n    write('Portanto, a fórmula original é uma TAUTOLOGIA'), nl.\n\n% ============================================================================\n% PARTE 5: VERIFICAÇÃO EM FORMA NORMAL CONJUNTIVA\n% ============================================================================\n\n% Simulação da conversão para FNC da negação\nfnc_negacao :-\n    write('Forma Normal Conjuntiva da negação:'), nl,\n    write('¬[((L(S) → M(S)) ∧ L(S)) → M(S)]'), nl,\n    write('≡ ((L(S) → M(S)) ∧ L(S)) ∧ ¬M(S)'), nl,\n    write('≡ ((¬L(S) ∨ M(S)) ∧ L(S)) ∧ ¬M(S)'), nl,\n    write('≡ L(S) ∧ M(S) ∧ ¬M(S)'), nl,\n    write('Esta FNC contém a contradição M(S) ∧ ¬M(S)'), nl,\n    write('Logo, a fórmula original é uma TAUTOLOGIA'), nl.\n\n% ============================================================================\n% PARTE 6: PREDICADOS DE TESTE PRINCIPAL\n% ============================================================================\n\n% Executa todos os testes\nexecutar_todos_testes :-\n    write('=========================================='), nl,\n    write('VERIFICAÇÃO DE TAUTOLOGIA EM PROLOG'), nl,\n    write('=========================================='), nl, nl,\n    \n    teste_simba, nl,\n    tabela_verdade, nl,\n    prova_contradicao, nl,\n    fnc_negacao, nl,\n    \n    write('=========================================='), nl,\n    write('CONCLUSÃO: A inferência é logicamente válida'), nl,\n    write('=========================================='), nl.\n\n% Predicado conveniente para verificar a validade da regra\nverificar_regra_universal :-\n    write('Verificando regra universal:'), nl,\n    forall(leao(X), \n           (mamifero(X) -&gt; \n               format('✓ ~w é leão e é mamífero~n', [X]) ;\n               format('✗ ~w é leão mas não é mamífero~n', [X])\n           )).\n\n% ============================================================================\n% CONSULTAS DE EXEMPLO\n% ============================================================================\n\n% ?- executar_todos_testes.\n% ?- teste_simba.\n% ?- tabela_verdade.\n% ?- prova_contradicao.\n% ?- verificar_regra_universal.\n\n\n15.6.8 Questão 8\n\nModelagem:\n\nR1: \\(A \\vee B \\vee C\\);\n\nR2: \\(\\neg (A \\wedge B) \\equiv \\neg A \\vee \\neg B\\);\n\nR3: \\(C \\to A \\equiv \\neg C \\vee A\\).\n\nFNC: O conjunto de cláusulas é: \\(\\{(A \\vee B \\vee C), (\\neg A \\vee \\neg B), (\\neg C \\vee A)\\}\\)\nSatisfatibilidade: Sim, o conjunto é satisfatível. Precisamos encontrar uma atribuição de Verdadeiro/Falso para \\(A\\), \\(B\\), \\(C\\) que torne todas as cláusulas verdadeiras.\n\nVamos tentar \\(A=\\text{T}\\).\n\n\\(\\neg C \\vee \\text{T} \\equiv \\text{Verdadeiro}\\). OK.\n\n\\(\\neg \\text{T} \\vee \\neg B \\equiv \\neg B\\) precisa ser verdadeiro, então \\(B=\\text{F}\\).\n\n\\(\\text{T} \\vee \\text{F} \\vee C \\equiv \\text{Verdadeiro}\\). OK.\n\nSolução Válida: \\(A=\\text{T}\\), \\(B=\\text{F}\\), \\(C=\\text{F}\\) (Apenas Ana é alocada).\n\n\nOutra solução: \\(A=\\text{T}\\), \\(B=\\text{F}\\), \\(C=\\text{T}\\) (Ana e Carla são alocadas).\nEm Prolog:\n% Cláusulas\nclause1(A, B, C) :- A ; B ; C.\nclause2(A, B, _) :- \\+ A ; \\+ B.\nclause3(A, _, C) :- \\+ C ; A.\n\n% Verificar satisfatibilidade\nsatisfiable(A, B, C) :- clause1(A, B, C), clause2(A, B, _), clause3(A, _, C).\n\n% Testar satisfatibilidade\ntest_satisfiability :-\n    findall([A, B, C], (member(A, [true, false]), member(B, [true, false]), member(C, [true, false]), \n                        satisfiable(A, B, C)), Solutions),\n    (Solutions \\= [] -&gt;\n        write('Satisfatível. Soluções: '), write(Solutions), nl\n    ;   write('Insatisfatível'), nl).\n\n\n15.6.9 Questão 9\n\nFórmula: \\(\\forall x (P(x) \\to (\\exists y (Q(y) \\wedge R(x,y)))) \\vee \\exists z S(z)\\);\nEliminar Implicação: \\(\\forall x (\\neg P(x) \\vee \\exists y (Q(y) \\wedge R(x,y))) \\vee \\exists z S(z)\\);\nRenomear Variáveis: Para evitar conflitos, renomeamos \\(z\\) para \\(w\\) (pois \\(z\\) não depende de \\(x\\)).\n\\[\\forall x (\\neg P(x) \\vee \\exists y (Q(y) \\wedge R(x,y))) \\vee \\exists w S(w)\\]\nMover Quantificadores:\n\n\\(\\forall x \\exists y (\\neg P(x) \\vee (Q(y) \\wedge R(x,y))) \\vee \\exists w S(w)\\);\n\n\\(\\forall x \\exists y \\exists w (\\neg P(x) \\vee (Q(y) \\wedge R(x,y)) \\vee S(w))\\);\n\nFNP: \\(\\forall x \\exists y \\exists w ((\\neg P(x) \\vee (Q(y) \\wedge R(x,y))) \\vee S(w))\\).\n\nEm Prolog:\n% Definir predicados para um domínio finito\nP(x1). P(x2).\nQ(y1). Q(y2).\nR(x1, y1). R(x2, y2).\nS(z1).\n\n% Fórmula: ∀x (¬P(x) ∨ ∃y (Q(y) ∧ R(x,y))) ∨ ∃z S(z)\nformula :-\n    (forall(member(X, [x1, x2]),\n            (\\+ P(X) ; exists(member(Y, [y1, y2]), (Q(Y), R(X, Y)))))\n    ; exists(member(Z, [z1]), S(Z))).\n\n% Testar a fórmula\ntest_formula :-\n    (formula -&gt;\n        write('Fórmula é satisfatível no domínio dado'), nl\n    ;   write('Fórmula não é satisfatível no domínio dado'), nl).\n\n15.6.9.1 Questão 10\n\nCláusulas:\n\n\\(\\neg P \\vee \\neg Q \\vee R\\);\n\n\\(P \\vee R\\);\n\n\\(Q\\);\n\n\\(\\neg R\\).\n\nProva por Resolução:\n\nResolvendo (1) e (2) sobre \\(P\\): \\[(\\neg Q \\vee R \\vee R) \\equiv (\\neg Q \\vee R)\\] (Cláusula 5)\n\nResolvendo (5) e (3) sobre \\(Q\\): \\[(R)\\] (Cláusula 6)\n\nResolvendo (6) e (4) sobre \\(R\\): \\[\\square\\] (Cláusula Vazia)\n\nConclusão: Como derivamos a cláusula vazia, o conjunto original de cláusulas é inconsistente (insatisfatível).\nConexão com Prolog: é exatamente isso que o Prolog faz. Para provar uma consulta ?- g, ele adiciona \\(\\neg g\\) à base de conhecimento e tenta derivar uma contradição (cláusula vazia). Se conseguir, a consulta original é tida como verdadeira.\n\nEm Prolog:\n% Implementação do Princípio da Resolução em SWI-Prolog\n% Demonstração da inconsistência de um conjunto de cláusulas\n\n% ============================================================================\n% PARTE 1: REPRESENTAÇÃO DAS CLÁUSULAS\n% ============================================================================\n\n% Representamos cláusulas como listas de literais\n% Literal positivo: P, Literal negativo: neg(P)\n% Cláusula vazia: []\n\n% Conjunto original de cláusulas\nclausula(1, [neg(P), neg(Q), R]).     % ¬P ∨ ¬Q ∨ R\nclausula(2, [P, R]).                  % P ∨ R  \nclausula(3, [Q]).                     % Q\nclausula(4, [neg(R)]).                % ¬R\n\n% ============================================================================\n% PARTE 2: ALGORITMO DE RESOLUÇÃO\n% ============================================================================\n\n% Predicado principal para resolver duas cláusulas\nresolver_clausulas(C1, C2, Resolvente) :-\n    clausula(C1, Lista1),\n    clausula(C2, Lista2),\n    resolucao(Lista1, Lista2, Resolvente).\n\n% Encontra literais complementares e resolve\nresolucao(Lista1, Lista2, Resolvente) :-\n    % Encontra um literal L em Lista1 \n    member(L, Lista1),\n    % Encontra seu complemento em Lista2\n    complemento(L, CompL),\n    member(CompL, Lista2),\n    % Remove os literais complementares e une as listas\n    select(L, Lista1, Resto1),\n    select(CompL, Lista2, Resto2),\n    append(Resto1, Resto2, Temp),\n    % Remove duplicatas e simplifica\n    sort(Temp, Resolvente).\n\n% Define literais complementares\ncomplemento(X, neg(X)) :- \\+ functor(X, neg, 1).\ncomplemento(neg(X), X).\n\n% ============================================================================\n% PARTE 3: PROCESSO DE PROVA PASSO A PASSO\n% ============================================================================\n\n% Executa a prova completa do exemplo\nprova_resolucao :-\n    write('PROVA POR RESOLUÇÃO'), nl,\n    write('=================='), nl, nl,\n    \n    % Mostra cláusulas originais\n    write('Cláusulas originais:'), nl,\n    mostrar_clausula(1),\n    mostrar_clausula(2),\n    mostrar_clausula(3),\n    mostrar_clausula(4), nl,\n    \n    % Passo 1: Resolver (1) e (2) sobre P\n    write('Passo 1: Resolvendo cláusulas (1) e (2) sobre P'), nl,\n    resolver_clausulas(1, 2, C5),\n    format('Resultado: ~w~n', [C5]),\n    assert(clausula(5, C5)), nl,\n    \n    % Passo 2: Resolver (5) e (3) sobre Q  \n    write('Passo 2: Resolvendo resultado anterior com (3) sobre Q'), nl,\n    resolucao(C5, [Q], C6),\n    format('Resultado: ~w~n', [C6]),\n    assert(clausula(6, C6)), nl,\n    \n    % Passo 3: Resolver (6) e (4) sobre R\n    write('Passo 3: Resolvendo resultado anterior com (4) sobre R'), nl,\n    resolucao(C6, [neg(R)], Vazia),\n    format('Resultado: ~w~n', [Vazia]),\n    \n    % Verifica se obtivemos a cláusula vazia\n    (Vazia = [] -&gt;\n        (nl, write('✓ CLÁUSULA VAZIA DERIVADA!'), nl,\n         write('✓ O conjunto de cláusulas é INCONSISTENTE'), nl) ;\n        (write('✗ Não foi possível derivar a cláusula vazia'), nl)\n    ).\n\n% Predicado auxiliar para mostrar cláusulas formatadas\nmostrar_clausula(N) :-\n    clausula(N, Lista),\n    format('(~w) ~w~n', [N, Lista]).\n\n% ============================================================================\n% PARTE 4: SIMULAÇÃO DO FUNCIONAMENTO INTERNO DO PROLOG\n% ============================================================================\n\n% Base de conhecimento de exemplo baseada nas cláusulas\n% Convertendo para cláusulas de Horn (apenas para demonstração)\n\n% Da cláusula (1): ¬P ∨ ¬Q ∨ R  ===&gt;  R :- P, Q\nregra_r :- P, Q.\n\n% Da cláusula (2): P ∨ R  ===&gt;  Se não podemos provar R, então P\n% (Esta não é uma cláusula de Horn diretamente)\n\n% Da cláusula (3): Q é um fato\nQ.\n\n% Para demonstrar a inconsistência, vamos negar R e tentar prová-lo\ndemonstrar_inconsistencia_prolog :-\n    write('DEMONSTRAÇÃO DA INCONSISTÊNCIA VIA PROLOG'), nl,\n    write('=========================================='), nl, nl,\n    \n    write('Base de conhecimento:'), nl,\n    write('- Q (fato)'), nl,\n    write('- R :- P, Q (regra)'), nl,\n    write('- Tentando provar ¬r'), nl, nl,\n    \n    write('Para provar ¬r, o Prolog adiciona R à base e busca contradição:'), nl,\n    \n    % Simula o processo de resolução do Prolog\n    (Q -&gt;\n        write('✓ Q é verdadeiro') ; \n        write('✗ Q é falso')\n    ), nl,\n    \n    write('Se assumirmos P verdadeiro:'), nl,\n    write('- De \"R :- P, Q\" e sabendo que P e Q são verdadeiros'), nl,\n    write('- Podemos inferir R'), nl,\n    write('- Mas isso contradiz nossa tentativa de provar ¬r'), nl,\n    write('- Logo, a suposição inicial leva à contradição'), nl.\n\n% ============================================================================\n% PARTE 5: ALGORITMO GERAL DE RESOLUÇÃO\n% ============================================================================\n\n% Implementação mais geral do algoritmo de resolução\nresolucao_geral(Clausulas, Resultado) :-\n    resolucao_loop(Clausulas, [], Resultado).\n\n% Loop principal do algoritmo\nresolucao_loop(Clausulas, Derivadas, inconsistente) :-\n    % Tenta encontrar duas cláusulas que podem ser resolvidas\n    member(C1, Clausulas),\n    member(C2, Clausulas),\n    C1 \\= C2,\n    resolucao(C1, C2, Nova),\n    \n    % Se derivamos a cláusula vazia, temos inconsistência\n    (Nova = [] -&gt;\n        true\n    ;\n        % Senão, adiciona a nova cláusula e continua\n        \\+ member(Nova, Clausulas),\n        \\+ member(Nova, Derivadas),\n        append(Clausulas, [Nova], NovasClausulas),\n        resolucao_loop(NovasClausulas, [Nova|Derivadas], inconsistente)\n    ).\n\nresolucao_loop(_, _, satisfativel).\n\n% ============================================================================\n% PARTE 6: TESTES E VERIFICAÇÕES\n% ============================================================================\n\n% Teste do algoritmo com o exemplo dado\ntestar_exemplo :-\n    write('TESTE DO ALGORITMO DE RESOLUÇÃO'), nl,\n    write('==============================='), nl, nl,\n    \n    % Coleta todas as cláusulas originais\n    findall(C, (clausula(N, C), N =&lt; 4), Clausulas),\n    write('Testando conjunto de cláusulas: '), nl,\n    forall(member(C, Clausulas), \n           format('  ~w~n', [C])\n    ), nl,\n    \n    % Aplica o algoritmo\n    resolucao_geral(Clausulas, Resultado),\n    format('Resultado: ~w~n', [Resultado]).\n\n% Teste com conjunto satisfatível\ntestar_satisfativel :-\n    write('TESTE COM CONJUNTO SATISFATÍVEL'), nl,\n    write('==============================='), nl,\n    \n    % Um conjunto que não leva à contradição\n    ClausulasSat = [[P], [neg(P), Q], [neg(Q), R]],\n    write('Cláusulas: '), nl,\n    forall(member(C, ClausulasSat), \n           format('  ~w~n', [C])\n    ), nl,\n    \n    resolucao_geral(ClausulasSat, Resultado),\n    format('Resultado: ~w~n', [Resultado]).\n\n% ============================================================================\n% PARTE 7: PREDICADOS PRINCIPAIS DE EXECUÇÃO\n% ============================================================================\n\n% Executa todas as demonstrações\nexecutar_resolucao :-\n    write('PRINCÍPIO DA RESOLUÇÃO - DEMONSTRAÇÃO COMPLETA'), nl,\n    write('=============================================='), nl, nl,\n    \n    prova_resolucao, nl,\n    demonstrar_inconsistencia_prolog, nl,\n    testar_exemplo, nl,\n    testar_satisfativel, nl,\n    \n    write('=============================================='), nl,\n    write('CONCLUSÃO: O Princípio da Resolução é a base'), nl,\n    write('do mecanismo de inferência do Prolog'), nl,\n    write('=============================================='), nl.\n\n% Limpa cláusulas derivadas para novo teste\nlimpar_clausulas :-\n    retractall(clausula(N, _)),\n    % Reestabelece cláusulas originais\n    assert(clausula(1, [neg(P), neg(Q), R])),\n    assert(clausula(2, [P, R])),\n    assert(clausula(3, [Q])),\n    assert(clausula(4, [neg(R)])).\n\n% ============================================================================\n% CONSULTAS DE EXEMPLO\n% ============================================================================\n\n% ?- executar_resolucao.\n% ?- prova_resolucao.\n% ?- testar_exemplo.\n% ?- limpar_clausulas.",
    "crumbs": [
      "Solução dos Exercícios",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Formas Normais Proposicionais @sec-formas-normais</span>"
    ]
  },
  {
    "objectID": "apendice-a-glossario.html",
    "href": "apendice-a-glossario.html",
    "title": "16  Glossário",
    "section": "",
    "text": "Álgebra de Boole: Sistema algébrico usado na lógica matemática, baseado nos valores verdadeiro (1) e falso (0).\nAntecedente: Em uma implicação \\(P \\rightarrow Q\\), \\(P\\) é o antecedente.\nAridade: Número de argumentos que uma função ou predicado aceita.\nArgumento: Lista de proposições (premissas) seguidas de uma conclusão.\nAssociatividade: Propriedade onde \\((a * b) * c = a * (b * c)\\) para um operador \\(*\\).\nÁtomo: Proposição indivisível ou predicado aplicado a termos em uma fórmula.\nAxioma: Fórmula ou proposição aceita como verdadeira sem necessidade de demonstração.\nBicondicional (\\(\\leftrightarrow\\)): Operador lógico que indica equivalência entre duas proposições.\nCardinalidade: Número de elementos em um conjunto.\nCláusula: Disjunção de literais, como \\(P \\vee Q \\vee \\neg R\\).\nCláusula de Horn: Disjunção de literais com no máximo um literal positivo.\nComutatividade: Propriedade onde \\(a * b = b * a\\) para um operador \\(*\\).\nConclusão: Em um argumento, a proposição final que se deriva das premissas.\nConjunção (\\(\\wedge\\)): Operador lógico “E”.\nConsequente: Em uma implicação \\(P \\rightarrow Q\\), \\(Q\\) é o consequente.\nConstante: Símbolo que representa um objeto específico no domínio do discurso.\nConstante de Skolem: Termo introduzido para eliminar quantificadores existenciais.\nContradição: Fórmula que é sempre falsa, independentemente dos valores de suas variáveis.\nContrapositiva: Para uma implicação \\(P \\rightarrow Q\\), sua contrapositiva é \\(\\neg Q \\rightarrow \\neg P\\).\nDedução: Processo de derivar conclusões lógicas a partir de premissas.\nDisjunção (\\(\\vee\\)): Operador lógico “OU”.\nDistributividade: Propriedade onde \\(a * (b + c) = (a * b) + (a * c)\\) para operadores \\(*\\) e \\(+\\).\nDomínio do Discurso: Conjunto de objetos sobre os quais as variáveis quantificadas podem se referir.\nDupla Negação: Princípio onde \\(\\neg \\neg P \\equiv P\\).\nEquivalência Lógica (\\(\\equiv\\)): Relação entre duas fórmulas que têm o mesmo valor verdade para todas as interpretações.\nEscopo: Parte de uma fórmula à qual um quantificador ou operador se aplica.\nFato: Na programação lógica, afirmação considerada verdadeira sem condições.\nFalseabilidade: Propriedade de uma hipótese que pode ser provada falsa.\nForma Normal Conjuntiva (FNC): Fórmula que é uma conjunção de cláusulas, onde cada cláusula é uma disjunção de literais.\nForma Normal Disjuntiva (FND): Fórmula que é uma disjunção de conjunções de literais.\nForma Normal Negativa (FNN): Fórmula onde as negações aparecem apenas imediatamente antes das variáveis proposicionais.\nForma Normal Prenex: Fórmula onde todos os quantificadores estão no início, seguidos por uma matriz sem quantificadores.\nForma Normal Skolem: Forma Normal Prenex onde todos os quantificadores existenciais foram eliminados.\nFórmula Atômica: Fórmula que consiste em um predicado aplicado a termos.\nFórmula Bem Formada: Sequência de símbolos que segue as regras de formação da linguagem lógica.\nFunção: Mapeamento de um conjunto de argumentos para um valor único.\nFunção de Skolem: Função introduzida para eliminar quantificadores existenciais que dependem de variáveis universalmente quantificadas.\nIdempotência: Propriedade onde \\(a * a = a\\) para um operador \\(*\\).\nImplicação (\\(\\rightarrow\\)): Operador lógico “SE…ENTÃO”.\nIndução Matemática: Método de prova que envolve um caso base e um passo indutivo.\nInferência: Processo de derivar novas informações a partir de informações existentes.\nInstanciação: Substituição de uma variável por um termo específico.\nInterpretação: Atribuição de significado aos símbolos de uma linguagem formal.\nLeis de De Morgan: \\(\\neg(P \\wedge Q) \\equiv (\\neg P \\vee \\neg Q)\\) e \\(\\neg(P \\vee Q) \\equiv (\\neg P \\wedge \\neg Q)\\).\nLema: Proposição auxiliar demonstrável utilizada como passo intermediário na prova de um teorema.\nLiteral: Variável proposicional ou sua negação.\nLógica de Primeira Ordem: Sistema formal para representar e raciocinar sobre propriedades de objetos e relações entre eles.\nLógica Proposicional: Sistema lógico que lida com proposições e suas inter-relações.\nMeta-linguagem: Linguagem usada para descrever outra linguagem.\nModelo: Interpretação que satisfaz um conjunto de fórmulas.\nModus Ponens: Regra de inferência: \\(P, P \\rightarrow Q \\vdash Q\\).\nModus Tollens: Regra de inferência: \\(\\neg Q, P \\rightarrow Q \\vdash \\neg P\\).\nNegação (\\(\\neg\\)): Operador lógico que inverte o valor de verdade de uma proposição.\nPredicado: Função que mapeia objetos a valores de verdade.\nPremissa: Proposição a partir da qual se deriva uma conclusão em um argumento.\nProlog: Linguagem de programação baseada na Lógica de Primeira Ordem e Cláusulas de Horn.\nProva: Sequência de passos lógicos que demonstra a verdade de uma proposição.\nQuantificador Existencial (\\(\\exists\\)): Símbolo lógico que significa “existe pelo menos um”.\nQuantificador Universal (\\(\\forall\\)): Símbolo lógico que significa “para todo”.\nRecíproca: Para uma implicação \\(P \\rightarrow Q\\), sua recíproca é \\(Q \\rightarrow P\\).\nRedução ao Absurdo: Método de prova que assume a negação da conclusão e deriva uma contradição.\nRefutação: Prova da falsidade de uma proposição.\nRegra: Na programação lógica, implicação que define como derivar novos fatos.\nResolução: Regra de inferência usada em provas automatizadas.\nSatisfatibilidade: Propriedade de uma fórmula que é verdadeira para pelo menos uma interpretação.\nSemântica: Estudo do significado em linguagens formais e naturais.\nSilogismo: Forma de raciocínio dedutivo com duas premissas e uma conclusão.\nSintaxe: Conjunto de regras que definem as sequências bem formadas em uma linguagem.\nSkolemização: Processo de eliminação de quantificadores existenciais em uma fórmula lógica.\nTabela Verdade: Tabela que mostra os valores de verdade de uma fórmula para todas as combinações possíveis de seus componentes.\nTautologia: Fórmula que é sempre verdadeira, independentemente dos valores de suas variáveis.\nTeoria: Conjunto de fórmulas em um sistema lógico.\nTeorema: Afirmação que pode ser provada como verdadeira dentro de um sistema lógico.\nTermo: Constante, variável ou função aplicada a outros termos.\nUnificação: Processo de encontrar substituições que tornam dois termos idênticos.\nUniverso de Herbrand: Conjunto de todos os termos básicos que podem ser construídos a partir das constantes e funções de uma linguagem de primeira ordem.\nUniverso do Discurso: Conjunto de todas as entidades sobre as quais as variáveis em uma fórmula lógica podem assumir valores.\nValidade: Propriedade de um argumento onde a conclusão é verdadeira sempre que todas as premissas são verdadeiras.\nVariável: Símbolo que representa um objeto não especificado no domínio do discurso.\nVariável Livre: Variável em uma fórmula que não está ligada a nenhum quantificador.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Glossário</span>"
    ]
  },
  {
    "objectID": "apendice-b-referencias.html",
    "href": "apendice-b-referencias.html",
    "title": "17  Referências",
    "section": "",
    "text": "BOOLOS, G.; BURGESS, J.; JEFFREY, R. Computability and Logic. 5. ed. Cambridge: Cambridge University Press, 2007.\nCHANG, C.C.; KEISLER, H.J. Model Theory. Amsterdam: North-Holland, 1990.\nEBBINGHAUS, H.D.; FLUM, J. Finite Model Theory. 2. ed. Berlin: Springer, 2006.\nGALLIER, J.H. Logic for Computer Science: Foundations of Automatic Theorem Proving. 2. ed. Mineola: Dover Publications, 2015.\nGENESERETH, M.; NILSSON, N. Logical Foundations of Artificial Intelligence. San Francisco: Morgan Kaufmann, 1987.\nINTERNATIONAL MONETARY FUND. World Economic Outlook, October 2023: Navigating Global Divergences. IMF, out. 2023. Disponível em: https://www.imf.org/en/Publications/WEO/Issues/2023/10/10/world-economic-outlook-october-2023. Acesso em: 17 mai. 2025.\nKRIPKE, S. Naming and Necessity. Cambridge: Harvard University Press, 1980.\nMANNA, Z. Verification of Computer Programs. Cambridge: MIT Press, 1974.\nMDPI BLOG. Five Breakthrough Moments in Science and Technology in 2022. MDPI Blog, 23 jan. 2023. Disponível em: https://blog.mdpi.com/2023/01/23/breakthroughs-in-2022/. Acesso em: 17 mai. 2025.\nMIT TECHNOLOGY REVIEW. 10 Breakthrough Technologies 2022. MIT Technology Review, 23 fev. 2022. Disponível em: https://www.technologyreview.com/2022/02/23/1045416/10-breakthrough-technologies-2022/. Acesso em: 17 mai. 2025.\nQUINE, W.V.O. Word and Object. Cambridge: MIT Press, 1960.\nRUSSELL, S.; NORVIG, P. Artificial Intelligence: A Modern Approach. 4. ed. Upper Saddle River: Pearson, 2020.\nVAN HARMELEN, F.; LIFSCHITZ, V.; PORTER, B. (Ed.). Handbook of Knowledge Representation. Amsterdam: Elsevier, 2008.\nWIRTH, N. Algorithms + Data Structures = Programs. 3. ed. Englewood Cliffs: Prentice-Hall, 1976.\n\nAPT, Krzysztof R. Ten years of Hoare’s logic: a survey. ACM Transactions on Programming Languages and Systems, New York, v. 3, n. 4, p. 431-483, Oct. 1981.\nBERTOT, Yves; CASTÉRAN, Pierre. Interactive Theorem Proving and Program Development: Coq’Art: The Calculus of Inductive Constructions. Berlin: Springer, 2004. 469 p.\nBURSTALL, Rod M. Proving properties of programs by structural induction. The Computer Journal, Oxford, v. 12, n. 1, p. 41-48, Feb. 1969.\nDIJKSTRA, Edsger W. A discipline of programming. Englewood Cliffs: Prentice-Hall, 1976.\nFLOYD, Robert W. Assigning meaning to programs. In: SCHWARTZ, J. T. (Ed.). Mathematical Aspects of Computer Science. Providence: American Mathematical Society, 1967. p. 19-32.\nHOARE, Charles Antony Richard. An axiomatic basis for computer programming. Communications of the ACM, New York, v. 12, n. 10, p. 576-580, Oct. 1969.\nLEINO, K. Rustan M. Efficient weakest preconditions. Information Processing Letters, Amsterdam, v. 93, n. 6, p. 281-288, Mar. 2005.\nNIPKOW, Tobias; KLEIN, Gerwin. Concrete Semantics: With Isabelle/HOL. Cham: Springer, 2014. 298 p.\nPIERCE, Benjamin C. et al. Software Foundations. University of Pennsylvania, 2018. Disponível em: https://softwarefoundations.cis.upenn.edu/. Acesso em: 14 jul. 2025.\nREYNOLDS, John C. Theories of Programming Languages. Cambridge: Cambridge University Press, 1998. 513 p.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Referências</span>"
    ]
  }
]