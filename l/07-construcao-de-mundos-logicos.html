<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Programação Lógica - 9&nbsp; Raciocínio Algorítmico: Criando Mundos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./07a-criando-mundos-praticas.html" rel="next">
<link href="./06-clausulas-de-horn-e-prolog.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./07-construcao-de-mundos-logicos.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Raciocínio Algorítmico: Criando Mundos</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introdução à Programação Lógica</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/logica" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Apresentação</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentos da Lógica</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-jornada-programacao-logica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introdução ao Paradigma da Programação Lógica</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-introducao-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introdução Prática ao Prolog com Swish</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-fundamentos-logica-proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Proposicional</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-arte-da-prova-e-analise-de-argumentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">A Arte da Prova e Análise de Argumentos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-logica-predicativa-e-quantificadores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Lógica de Primeira Ordem: Lógica Predicativa</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Aplicações Avançadas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-formas-normais-e-skolemizacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Formas Normais: Estruturas de Solução</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-clausulas-de-horn-e-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Formas Clausais e A Cláusula de Horn</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-construcao-de-mundos-logicos.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Raciocínio Algorítmico: Criando Mundos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07a-criando-mundos-praticas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Criando Mundos: Práticas 2025</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07b-inferencia-prolog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Desvendando o Processo de Inferência do Prolog</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-verificacao-formal-de-programas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Verificação Formal de Programas: Lógica de Hoare e Indução Estrutural</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-desafios-logicos-enigmas-e-misterios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Desafios, Problemas e Mistérios</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Solução dos Exercícios</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-Sol-Proposicional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Lógica Proposicional </span></span></a><a href="02-fundamentos-logica-proposicional.html" class="quarto-xref"><span>Chapter 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-Sol-Predicativa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Lógica Predicativa </span></span></a><a href="04-logica-predicativa-e-quantificadores.html" class="quarto-xref"><span>Chapter 6</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-Sol-Normais.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Formas Normais Proposicionais </span></span></a><a href="05-formas-normais-e-skolemizacao.html" class="quarto-xref"><span>Chapter 7</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-a-glossario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Glossário</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apendice-b-referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Referências</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#definição-formal-de-um-mundo" id="toc-definição-formal-de-um-mundo" class="nav-link active" data-scroll-target="#definição-formal-de-um-mundo"><span class="header-section-number">9.0.1</span> Definição Formal de um Mundo</a></li>
  <li><a href="#construção-de-mundos" id="toc-construção-de-mundos" class="nav-link" data-scroll-target="#construção-de-mundos"><span class="header-section-number">9.0.2</span> Construção de Mundos</a></li>
  <li><a href="#aplicações-e-importância" id="toc-aplicações-e-importância" class="nav-link" data-scroll-target="#aplicações-e-importância"><span class="header-section-number">9.0.3</span> Aplicações e Importância</a></li>
  <li><a href="#a-teoria-dos-modelos" id="toc-a-teoria-dos-modelos" class="nav-link" data-scroll-target="#a-teoria-dos-modelos"><span class="header-section-number">9.0.4</span> A Teoria dos Modelos</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/07-construcao-de-mundos-logicos.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-formas-normais-e-skolemizacao.html">Aplicações Avançadas</a></li><li class="breadcrumb-item"><a href="./07-construcao-de-mundos-logicos.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Raciocínio Algorítmico: Criando Mundos</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Raciocínio Algorítmico: Criando Mundos</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>A <strong>Lógica de Primeira Ordem</strong>, também conhecida como lógica de predicados de primeira ordem, emergiu no final do século XIX e início do século XX, principalmente através dos trabalhos de <a href="https://en.wikipedia.org/wiki/Gottlob_Frege">Gottlob Frege</a>, <a href="https://en.wikipedia.org/wiki/Bertrand_Russell">Bertrand Russell</a> e <a href="https://en.wikipedia.org/wiki/Alfred_North_Whitehead">Alfred North Whitehead</a>. Essa lógica foi desenvolvida como uma extensão da <strong>Lógica Proposicional</strong>, permitindo a representação de afirmações mais complexas sobre objetos e suas relações. A <strong>Lógica de Primeira Ordem</strong> tornou-se uma ferramenta fundamental na matemática, filosofia e ciência da computação, especialmente na formalização de sistemas dedutivos e na fundamentação da matemática.</p>
<p>A capacidade de definir <em>mundos</em>, estruturas dentro da <strong>Lógica de Primeira Ordem</strong> que permitem modelar e analisar sistemas complexos, torna esta disciplina indispensável para a ciência da computação. Esses mundos representam interpretações ou modelos que atribuem significado às fórmulas lógicas, permitindo verificar a validade de argumentos, provar teoremas e desenvolver sistemas de inteligência artificial.</p>
<section id="definição-formal-de-um-mundo" class="level3" data-number="9.0.1">
<h3 data-number="9.0.1" class="anchored" data-anchor-id="definição-formal-de-um-mundo"><span class="header-section-number">9.0.1</span> Definição Formal de um Mundo</h3>
<p>Na <strong>Lógica de Primeira Ordem</strong>, um <strong>mundo</strong> ou <strong>modelo</strong> é uma estrutura que consiste em:</p>
<ol type="1">
<li><p><strong>Domínio de Discurso (<span class="math inline">\(D\)</span>)</strong>: Um conjunto não vazio de objetos sobre os quais as variáveis quantificadas podem se referir. Exemplo: <span class="math inline">\(D = \{1, 2, 3, 4, 5\}\)</span> (um domínio de números inteiros de 1 a 5)</p></li>
<li><p><strong>Símbolos de Constantes</strong>: Elementos específicos do domínio que são nomeados. Exemplo: <span class="math inline">\(a = 1\)</span>, <span class="math inline">\(b = 3\)</span> (sendo que <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> são constantes que se referem a elementos específicos do domínio)</p></li>
<li><p><strong>Símbolos de Função</strong>: Mapeamentos de elementos do domínio para outros elementos dentro do domínio. Exemplo: <span class="math inline">\(f(x) = x + 1\)</span> (uma função que mapeia cada elemento do domínio para seu sucessor)</p></li>
<li><p><strong>Símbolos de Predicado</strong>: Propriedades ou relações que podem ser atribuídas aos elementos do domínio. Exemplo: <span class="math inline">\(P(x)\)</span>: <em>x é par</em>, <span class="math inline">\(R(x, y)\)</span>: <em>x é menor que y</em></p></li>
<li><p><strong>Interpretação</strong>: Uma função que atribui significado aos símbolos não lógicos (constantes, funções e predicados) em termos do domínio. Exemplo:</p>
<ul>
<li><span class="math inline">\(I(a) = 1\)</span></li>
<li><span class="math inline">\(I(f(2)) = 3\)</span></li>
<li><span class="math inline">\(I(P) = \{2, 4\}\)</span></li>
<li><span class="math inline">\(I(R) = \{(1,2), (1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,4), (3,5), (4,5)\}\)</span></li>
</ul></li>
</ol>
<p>Um modelo <span class="math inline">\(M\)</span> para uma linguagem <span class="math inline">\(L\)</span> é então definido como <span class="math inline">\(M = (D, I)\)</span>, sendo que <span class="math inline">\(D\)</span> é o domínio e <span class="math inline">\(I\)</span> é a interpretação.</p>
<p>Neste exemplo, temos um modelo <span class="math inline">\(M\)</span> no qual:</p>
<p><span class="math display">\[M = (\{1, 2, 3, 4, 5\}, I)\]</span></p>
<p>com <span class="math inline">\(I\)</span> definido como acima. Este modelo representa um <em>mundo</em> no qual podemos fazer afirmações sobre números inteiros de 1 a 5, suas relações de ordem e paridade.</p>
</section>
<section id="construção-de-mundos" class="level3" data-number="9.0.2">
<h3 data-number="9.0.2" class="anchored" data-anchor-id="construção-de-mundos"><span class="header-section-number">9.0.2</span> Construção de Mundos</h3>
<p>Vamos ilustrar a definição acima com um exemplo concreto.</p>
<p><strong>Domínio de Objetos (<span class="math inline">\(D\)</span>)</strong>:</p>
<p><span class="math display">\[D = \{ a, b, c \}\]</span></p>
<p><strong>No qual</strong>: <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> e <span class="math inline">\(c\)</span> são objetos distintos no domínio.</p>
<p><strong>Símbolos de Constante</strong>: <span class="math inline">\(e\)</span>: representa um elemento específico do domínio.</p>
<p><strong>Símbolos de Função</strong>: <span class="math inline">\(f(x)\)</span>: <em>o melhor amigo de x.</em></p>
<p><strong>Símbolos de Predicado</strong>:</p>
<ul>
<li><span class="math inline">\(P(x)\)</span>: <em>x é uma pessoa.</em></li>
<li><span class="math inline">\(Q(x)\)</span>: <em>x é um animal.</em></li>
<li><span class="math inline">\(R(x, y)\)</span>: <em>x gosta de y.</em></li>
</ul>
<p><strong>Interpretação no Mundo</strong>: atribuímos significado aos símbolos não lógicos:</p>
<ul>
<li><span class="math inline">\(I(e) = a\)</span> (a constante <span class="math inline">\(e\)</span> refere-se ao objeto <span class="math inline">\(a\)</span>)</li>
<li><span class="math inline">\(I(f)(a) = b\)</span> (o melhor amigo de <span class="math inline">\(a\)</span> é <span class="math inline">\(b\)</span>)</li>
<li><span class="math inline">\(I(f)(b) = c\)</span> (o melhor amigo de <span class="math inline">\(b\)</span> é <span class="math inline">\(c\)</span>)</li>
<li><span class="math inline">\(I(f)(c) = a\)</span> (o melhor amigo de <span class="math inline">\(c\)</span> é <span class="math inline">\(a\)</span>)</li>
<li><span class="math inline">\(P(a)\)</span> é verdadeiro (a é uma pessoa).</li>
<li><span class="math inline">\(P(b)\)</span> é verdadeiro (b é uma pessoa).</li>
<li><span class="math inline">\(P(c)\)</span> é falso (c não é uma pessoa).</li>
<li><span class="math inline">\(Q(c)\)</span> é verdadeiro (c é um animal).</li>
<li><span class="math inline">\(R(a, c)\)</span> é verdadeiro (a gosta de c).</li>
<li><span class="math inline">\(R(b, c)\)</span> é verdadeiro (b gosta de c).</li>
<li><span class="math inline">\(R(a, b)\)</span> é falso (a não gosta de b).</li>
</ul>
<p><strong>Representação Formal do Mundo</strong>:</p>
<p>As informações acima podem ser formalizadas através das seguintes fórmulas:</p>
<ol type="1">
<li><span class="math inline">\(P(a) \wedge P(b) \wedge \neg P(c)\)</span>: <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> são pessoas; <span class="math inline">\(c\)</span> não é;</li>
<li><span class="math inline">\(Q(c)\)</span>: <span class="math inline">\(c\)</span> é um animal;</li>
<li><span class="math inline">\(R(a, c) \wedge R(b, c) \wedge \neg R(a, b)\)</span>: <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> gostam de <span class="math inline">\(c\)</span>; <span class="math inline">\(a\)</span> não gosta de <span class="math inline">\(b\)</span>;</li>
<li><span class="math inline">\(f(a) = b \wedge f(b) = c \wedge f(c) = a\)</span>: representação da função <em>melhor amigo</em>;</li>
<li><span class="math inline">\(e = a\)</span>: a constante <span class="math inline">\(e\)</span> refere-se ao objeto <span class="math inline">\(a\)</span>.</li>
</ol>
<p>Este mundo agora inclui não apenas predicados, mas também uma constante <span class="math inline">\(e\)</span> e uma função <span class="math inline">\(f\)</span>, enriquecendo a estrutura e as relações entre os objetos do domínio.</p>
<p>O mundo que definimos acima, embora simples, ilustra vários conceitos importantes da <strong>Lógica de Primeira Ordem</strong>:</p>
<ol type="1">
<li><p><strong>Domínio Finito</strong>: Nosso domínio <span class="math inline">\(D = \{a, b, c\}\)</span> é finito, o que facilita a compreensão, mas é importante notar que domínios em <strong>Lógica de Primeira Ordem</strong> podem ser infinitos.</p></li>
<li><p><strong>Relações entre Objetos</strong>: Através dos predicados <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, e <span class="math inline">\(R\)</span>, estabelecemos propriedades e relações entre os objetos. Isso demonstra como a <strong>Lógica de Primeira Ordem</strong> pode capturar informações estruturadas sobre um conjunto de entidades.</p></li>
<li><p><strong>Funções</strong>: A introdução da função <span class="math inline">\(f\)</span> (melhor amigo) mostra como podemos mapear objetos do domínio para outros objetos do mesmo domínio, criando relações mais complexas.</p></li>
<li><p><strong>Constantes Nomeadas</strong>: A constante <span class="math inline">\(e\)</span> ilustra como podemos nos referir diretamente a elementos específicos do domínio.</p></li>
<li><p><strong>Expressividade</strong>: Mesmo com apenas três objetos, três predicados, uma função e uma constante, somos capazes de expressar uma variedade de fatos e relações.</p></li>
</ol>
<p><strong>Limitações do Exemplo</strong>:</p>
<ol type="1">
<li><p><strong>Escala</strong>: Em aplicações reais, os domínios e conjuntos de predicados e funções são geralmente muito maiores e mais complexos.</p></li>
<li><p><strong>Tipos de Objetos</strong>: Nosso exemplo mistura pessoas e animais no mesmo domínio. Em modelos mais sofisticados, poderíamos usar tipos ou sortes para distinguir diferentes categorias de objetos.</p></li>
<li><p><strong>Relações Temporais</strong>: Este modelo é estático. Em muitas aplicações, precisaríamos representar como as relações mudam ao longo do tempo.</p></li>
<li><p><strong>Incerteza</strong>: A <strong>Lógica de Primeira Ordem</strong> clássica lida com afirmações definitivamente verdadeiras ou falsas. Não há representação direta de probabilidades ou incertezas.</p></li>
</ol>
<p><strong>Extensões Possíveis</strong>: para tornar este mundo mais rico e realista, poderíamos:</p>
<ol type="1">
<li>Adicionar mais objetos ao domínio.</li>
<li>Introduzir predicados mais complexos, como <span class="math inline">\(Irmão(x,y)\)</span> ou <span class="math inline">\(MaisVelho(x,y)\)</span>.</li>
<li>Definir funções adicionais, como <span class="math inline">\(Idade(x)\)</span> ou <span class="math inline">\(Pai(x)\)</span>.</li>
<li>Incorporar axiomas que expressem regras gerais sobre o mundo, como <span class="math inline">\(\forall x (P(x) \rightarrow \neg Q(x))\)</span> (nada pode ser simultaneamente uma pessoa e um animal).</li>
</ol>
<p>Este exemplo simplificado serve como um ponto de partida para entender como modelos mais complexos podem ser construídos na <strong>Lógica de Primeira Ordem</strong> para representar conhecimento e raciocinar sobre domínios mais sofisticados.</p>
</section>
<section id="aplicações-e-importância" class="level3" data-number="9.0.3">
<h3 data-number="9.0.3" class="anchored" data-anchor-id="aplicações-e-importância"><span class="header-section-number">9.0.3</span> Aplicações e Importância</h3>
<p>A definição de mundos na <strong>Lógica de Primeira Ordem</strong> tem aplicações fundamentais em diversas áreas, abrangendo desde a matemática pura até as ciências aplicadas e a engenharia, passando pela biologia e economia. Na matemática, essa abordagem suporta a prova de teoremas, nos quais modelos são utilizados para verificar a consistência de sistemas axiomáticos e construir contraexemplos. A teoria dos modelos, um ramo importante da lógica matemática, se dedica ao estudo das relações entre estruturas matemáticas e as linguagens formais que as descrevem. Além disso, nos fundamentos da matemática, a <strong>Lógica de Primeira Ordem</strong> desempenha um papel central na formalização de conceitos matemáticos, como exemplificado pela Teoria dos Conjuntos de Zermelo-Fraenkel com o Axioma da Escolha (ZFC).</p>
</section>
<section id="a-teoria-dos-modelos" class="level3" data-number="9.0.4">
<h3 data-number="9.0.4" class="anchored" data-anchor-id="a-teoria-dos-modelos"><span class="header-section-number">9.0.4</span> A Teoria dos Modelos</h3>
<p>A teoria dos modelos estuda as relações entre estruturas matemáticas e as linguagens formais que as descrevem. Vamos considerar um exemplo simples, no qual analisamos a relação entre uma estrutura numérica e a linguagem formal que a descreve.</p>
<p>Seja <span class="math inline">\(M = (D, I)\)</span> um modelo em que:</p>
<p><span class="math display">\[D = \{0, 1, 2, 3, 4, 5\}\]</span></p>
<p>Este domínio representa um conjunto de números inteiros de <span class="math inline">\(0\)</span> a <span class="math inline">\(5\)</span>. A interpretação <span class="math inline">\(I\)</span> atribui significados aos símbolos não lógicos:</p>
<ol type="1">
<li><p><strong>Função de Adição (<span class="math inline">\(+\)</span>)</strong>: mapeia pares de elementos do domínio para sua soma.</p>
<p><span class="math display">\[ I(+) : (x, y) \mapsto (x + y \mod 6)\]</span>$ (A adição é feita com módulo <span class="math inline">\(6\)</span>).</p></li>
<li><p><strong>Símbolo de Constante</strong>: a constante <span class="math inline">\(c = 3\)</span>.</p></li>
<li><p><strong>Predicado de Paridade</strong>: <span class="math inline">\(P(x)\)</span> significa <em>x é par</em>.</p>
<p><span class="math display">\[ I(P) = \{0, 2, 4\} \]</span></p></li>
</ol>
<p>Com isso, podemos construir fórmulas na linguagem formal e verificar se são satisfeitas no modelo <span class="math inline">\(M\)</span>.</p>
<p><strong>Regras</strong>:</p>
<ol type="1">
<li><p>A soma de dois números pares é sempre par:</p>
<p><span class="math display">\[ \forall x \forall y (P(x) \wedge P(y) \rightarrow P(x + y)) \]</span></p>
<p>Esta fórmula é verdadeira em <span class="math inline">\(M\)</span>.</p></li>
<li><p>O número <span class="math inline">\(3\)</span> não é par:</p>
<p><span class="math display">\[ \neg P(3) \]</span></p>
<p>Esta fórmula também é verdadeira em <span class="math inline">\(M\)</span>, pois <span class="math inline">\(3 \notin \{0, 2, 4\}\)</span>.</p></li>
<li><p>A adição em <span class="math inline">\(M\)</span> é comutativa:</p>
<p><span class="math display">\[ \forall x \forall y (x + y = y + x) \]</span></p>
<p>Esta fórmula é verdadeira, uma vez que a adição em <span class="math inline">\(M\)</span> é comutativa no módulo <span class="math inline">\(6\)</span>.</p></li>
</ol>
<p>Neste exemplo, a <strong>estrutura matemática</strong> <span class="math inline">\(M\)</span> é um conjunto de números inteiros de <span class="math inline">\(0\)</span> a <span class="math inline">\(5\)</span> com a operação de adição módulo <span class="math inline">\(6\)</span>. As <strong>fórmulas na linguagem formal</strong> são expressões que descrevem propriedades de números, como paridade e comutatividade da adição.</p>
<p>A teoria dos modelos nos permite verificar se essas fórmulas são satisfeitas em <span class="math inline">\(M\)</span>. O estudo dessas relações entre fórmulas e estruturas é central na lógica matemática e fundamenta muitas áreas, como a álgebra e a aritmética, além de fornecer ferramentas para analisar a consistência de teorias matemáticas.</p>
<p>As ciências cognitivas constituem outro campo que faz uso extensivo do conceito de mundos. A modelagem cognitiva se baseia na representação formal de processos de raciocínio e tomada de decisão, enquanto a psicologia do raciocínio estuda como os seres humanos realizam inferências lógicas, muitas vezes comparando o raciocínio humano com os princípios formais da lógica. A engenharia de sistemas também faz uso do conceito de mundos. A especificação de requisitos e a modelagem de domínio se apoiam na capacidade de descrever formalmente sistemas complexos e suas interações, bem como representar conhecimento específico de domínio em diversos sistemas de engenharia. Entretanto, precisamos destacar duas áreas importantes para este trabalho: a ciência da computação e a linguística computacional.</p>
<section id="aplicações-na-ciência-da-computação" class="level4" data-number="9.0.4.1">
<h4 data-number="9.0.4.1" class="anchored" data-anchor-id="aplicações-na-ciência-da-computação"><span class="header-section-number">9.0.4.1</span> Aplicações na Ciência da Computação</h4>
<p>Na ciência da computação, as aplicações são vastas e variadas. No campo da inteligência artificial, a representação de conhecimento se beneficia enormemente da capacidade de modelar domínios complexos para sistemas especialistas e agentes inteligentes. O planejamento automatizado utiliza a descrição de estados do mundo e ações para resolver problemas, enquanto o processamento de linguagem natural depende da análise semântica de textos e da compreensão de contexto. Em bancos de dados, a modelagem conceitual e as consultas semânticas se apoiam fortemente em princípios lógicos para descrever formalmente esquemas e expressar consultas complexas. A verificação de software também se beneficia, com métodos formais sendo empregados para especificar e verificar propriedades de sistemas, e técnicas de model checking permitindo a verificação automática de propriedades em sistemas de estados finitos.</p>
<section id="exemplo-1---diagnóstico-médico" class="level5" data-number="9.0.4.1.1">
<h5 data-number="9.0.4.1.1" class="anchored" data-anchor-id="exemplo-1---diagnóstico-médico"><span class="header-section-number">9.0.4.1.1</span> Exemplo 1 - Diagnóstico Médico</h5>
<p>Em sistemas especialistas de diagnóstico médico, a capacidade de definir e manipular mundos lógicos permite:</p>
<ol type="1">
<li><p><strong>Raciocínio sobre cenários hipotéticos</strong>: um sistema especialista pode criar um mundo lógico <span class="math inline">\(M = (D, I)\)</span> representando um paciente com sintomas específicos:</p>
<p><span class="math display">\[D = \{p, f, t, d, c, g, a\}\]</span></p>
<p>Na qual <span class="math inline">\(p\)</span> representa o paciente, <span class="math inline">\(f\)</span> (febre), <span class="math inline">\(t\)</span> (tosse), <span class="math inline">\(d\)</span> (dor de cabeça), <span class="math inline">\(c\)</span> (COVID-19), <span class="math inline">\(g\)</span> (gripe), e <span class="math inline">\(a\)</span> (alergia) são elementos do domínio.</p>
<p>A interpretação <span class="math inline">\(I\)</span> define predicados como:</p>
<ul>
<li><span class="math inline">\(S(x,y)\)</span>: <em>x tem sintoma y</em></li>
<li><span class="math inline">\(D(x,z)\)</span>: <em>x tem doença z</em></li>
<li><span class="math inline">\(T(x,w)\)</span>: <em>x fez teste w</em></li>
</ul>
<p>O sistema pode então raciocinar sobre um cenário hipotético no qual:</p>
<p><span class="math display">\[S(p,f) \wedge S(p,t) \wedge \neg S(p,d)\]</span></p>
<p>Este mundo representa um paciente com febre e tosse, mas sem dor de cabeça.</p></li>
<li><p><strong>Planejamento de ações em ambientes complexos</strong>: baseado no mundo atual, o sistema pode planejar uma sequência de testes diagnósticos. Por exemplo, podemos definir uma função de ação <span class="math inline">\(A(x,y)\)</span> que representa <em>realizar ação y no paciente x</em>.</p>
<p>O sistema pode usar regras como:</p>
<p><span class="math display">\[\forall x (S(x,f) \wedge S(x,t) \rightarrow A(x, \text{testar_covid}))\]</span></p>
<p><span class="math display">\[\forall x (S(x,t) \wedge \neg S(x,f) \rightarrow A(x, \text{testar_alergia}))\]</span></p>
<p>Assim, no nosso cenário hipotético, o sistema recomendaria testar para COVID-19.</p></li>
<li><p><strong>Inferência de novas informações a partir de dados existentes</strong>: o sistema pode usar regras de inferência para derivar novos fatos. Por exemplo:</p>
<p><span class="math display">\[\forall x (S(x,f) \wedge S(x,t) \wedge T(x, \text{covid_positivo}) \rightarrow D(x,c))\]</span></p>
<p><span class="math display">\[\forall x (S(x,f) \wedge S(x,t) \wedge T(x, \text{covid_negativo}) \wedge T(x, \text{gripe_positivo}) \rightarrow D(x,g))\]</span></p>
<p>Se adicionarmos ao nosso mundo <span class="math inline">\(T(p, \text{covid_positivo})\)</span>, o sistema pode inferir <span class="math inline">\(D(p,c)\)</span>, concluindo que o paciente tem COVID-19.</p></li>
<li><p><strong>Validação de consistência em bases de conhecimento</strong>: o sistema pode verificar se o diagnóstico proposto é consistente com o conhecimento existente. Por exemplo, podemos ter uma regra de consistência:</p>
<p><span class="math display">\[\forall x \neg(D(x,c) \wedge D(x,g))\]</span></p>
<p>Esta regra afirma que um paciente não pode ter COVID-19 e gripe simultaneamente. Se o sistema tentar adicionar <span class="math inline">\(D(p,g)\)</span> ao mundo no qual já existe <span class="math inline">\(D(p,c)\)</span>, ele detectará uma inconsistência.</p>
<p>Além disso, o sistema pode usar regras de integridade mais complexas, como:</p>
<p><span class="math display">\[\forall x (D(x,c) \rightarrow \exists y (S(x,y) \wedge (y = f \vee y = t \vee y = d)))\]</span></p>
<p>Esta regra afirma que se um paciente tem COVID-19, ele deve ter pelo menos um dos sintomas: febre, tosse ou dor de cabeça.</p></li>
</ol>
<p>Neste exemplo expandido, o mundo lógico permite ao sistema especialista:</p>
<ol type="1">
<li>Representar e raciocinar sobre o estado de saúde do paciente;</li>
<li>Planejar testes diagnósticos baseados em regras predefinidas;</li>
<li>Fazer inferências sobre possíveis doenças usando regras lógicas;</li>
<li>Garantir a consistência do diagnóstico através de verificações de integridade.</li>
</ol>
</section>
<section id="exemplo-2---robô-de-limpeza" class="level5" data-number="9.0.4.1.2">
<h5 data-number="9.0.4.1.2" class="anchored" data-anchor-id="exemplo-2---robô-de-limpeza"><span class="header-section-number">9.0.4.1.2</span> Exemplo 2 - Robô de Limpeza</h5>
<p>Em sistemas de planejamento para robôs autônomos, a capacidade de definir e manipular mundos lógicos permite:</p>
<ol type="1">
<li><p><strong>Raciocínio sobre cenários hipotéticos</strong>: um sistema de Inteligência Artificial para um robô de limpeza pode criar um mundo lógico <span class="math inline">\(M = (D, I)\)</span> representando o estado de um ambiente:</p>
<p><span class="math display">\[D = \{r, s1, s2, s3, s4, poeira, liquido, l, d\}\]</span></p>
<p><span class="math inline">\(r\)</span> representa o robô, <span class="math inline">\(s1\)</span> a <span class="math inline">\(s4\)</span> são setores do ambiente, <span class="math inline">\(poeira\)</span> e <span class="math inline">\(liquido\)</span> são tipos de sujeira, <span class="math inline">\(l\)</span> é o carregador, e <span class="math inline">\(d\)</span> é a lixeira.</p>
<p>A interpretação <span class="math inline">\(I\)</span> define predicados como:</p>
<ul>
<li><span class="math inline">\(Em(x,y)\)</span>: <em>x está em y</em>;</li>
<li><span class="math inline">\(Sujo(x,y)\)</span>: <em>x está sujo com y</em>;</li>
<li><span class="math inline">\(Limpo(x)\)</span>: <em>x está limpo</em>;</li>
<li><span class="math inline">\(TemFerramenta(x,y)\)</span>: <em>x tem a ferramenta para limpar y</em>.</li>
</ul>
<p>O sistema pode raciocinar sobre um cenário hipotético no qual:</p>
<p><span class="math display">\[Em(r,s1) \wedge Sujo(s2,poeira) \wedge Sujo(s3,liquido) \wedge Limpo(s4) \wedge TemFerramenta(r,poeira)\]</span></p>
<p>Este mundo representa um robô no setor 1, com setor 2 sujo com poeira, setor 3 sujo com líquido, setor 4 limpo, e o robô equipado para limpar poeira.</p></li>
<li><p><strong>Planejamento de ações em ambientes complexos</strong>: baseado no mundo atual, o sistema pode planejar uma sequência de ações de limpeza. Definimos uma função de ação <span class="math inline">\(A(x,y,z)\)</span> que representa <em>x realiza ação y no local z</em>.</p>
<p>O sistema pode usar regras como:</p>
<p><span class="math display">\[\forall x \forall y \forall z \forall t (Em(x,y) \wedge Sujo(z,t) \wedge TemFerramenta(x,t) \wedge y \neq z \rightarrow A(x, \text{mover}, z))\]</span></p>
<p><span class="math display">\[\forall x \forall y \forall t (Em(x,y) \wedge Sujo(y,t) \wedge TemFerramenta(x,t) \rightarrow A(x, \text{limpar}, y))\]</span></p>
<p>Assim, no nosso cenário, o sistema planejaria mover o robô para o setor 2 e então limpá-lo.</p></li>
<li><p><strong>Inferência de novas informações a partir de dados existentes</strong>: o sistema pode usar regras de inferência para atualizar o estado do mundo após ações. Por exemplo:</p>
<p><span class="math display">\[\forall x \forall y \forall t (A(x, \text{limpar}, y) \wedge Sujo(y,t) \wedge TemFerramenta(x,t) \rightarrow Limpo(y))\]</span></p>
<p><span class="math display">\[\forall x \forall y \forall z (A(x, \text{mover}, z) \wedge Em(x,y) \rightarrow Em(x,z) \wedge \neg Em(x,y))\]</span></p>
<p>Após a ação de limpeza no setor 2, o sistema inferiria <span class="math inline">\(Limpo(s2)\)</span>, atualizando o estado do mundo.</p></li>
<li><p><strong>Validação de consistência em bases de conhecimento</strong>: o sistema pode verificar se o estado do mundo é consistente após cada ação. Por exemplo, podemos ter regras de consistência:</p>
<p><span class="math display">\[\forall x \forall t \neg(Limpo(x) \wedge Sujo(x,t))\]</span></p>
<p><span class="math display">\[\forall x \forall y \forall z (Em(x,y) \wedge Em(x,z) \rightarrow y = z)\]</span></p>
<p>A primeira regra afirma que um setor não pode estar limpo e sujo ao mesmo tempo. A segunda garante que o robô só pode estar em um lugar de cada vez.</p>
<p>Além disso, o sistema pode usar regras de integridade mais complexas, como:</p>
<p><span class="math display">\[\forall x ((\exists t Sujo(x,t)) \rightarrow \neg Limpo(x))\]</span></p>
<p>Esta regra afirma que se um setor está sujo com qualquer tipo de sujeira, ele não pode ser considerado limpo.</p></li>
</ol>
<p>Neste exemplo, o mundo lógico permite ao sistema de Inteligência Artificial do robô de limpeza:</p>
<ol type="1">
<li>Representar e raciocinar sobre o estado do ambiente e do próprio robô;</li>
<li>Planejar ações de limpeza baseadas em regras predefinidas e no estado atual;</li>
<li>Fazer inferências sobre os resultados das ações, atualizando o estado do mundo;</li>
<li>Garantir a consistência do estado do mundo através de verificações de integridade.</li>
</ol>
<p>Este uso sofisticado da <strong>Lógica de Primeira Ordem</strong> demonstra como sistemas de Inteligência Artificial podem manipular informações complexas e realizar raciocínios avançados em domínios de planejamento e execução de tarefas autônomas.</p>
</section>
</section>
<section id="aplicações-na-linguística-computacional" class="level4" data-number="9.0.4.2">
<h4 data-number="9.0.4.2" class="anchored" data-anchor-id="aplicações-na-linguística-computacional"><span class="header-section-number">9.0.4.2</span> Aplicações na Linguística Computacional</h4>
<p>Na linguística computacional, a semântica formal emprega a <strong>Lógica de Primeira Ordem</strong> para modelar o significado de sentenças e discursos em linguagens naturais. As gramáticas formais, por sua vez, se beneficiam dessa abordagem na descrição da estrutura sintática de linguagens, e a análise do discurso utiliza esses princípios para representar contexto e relações entre sentenças em textos.</p>
<section id="exemplo-1---gramática-formal" class="level5" data-number="9.0.4.2.1">
<h5 data-number="9.0.4.2.1" class="anchored" data-anchor-id="exemplo-1---gramática-formal"><span class="header-section-number">9.0.4.2.1</span> Exemplo 1 - Gramática Formal</h5>
<p>Na linguística computacional, particularmente no estudo de gramáticas formais, a <strong>Lógica de Primeira Ordem</strong> pode ser usada para definir e analisar estruturas sintáticas. Um “mundo” lógico pode representar a estrutura de uma sentença específica, como “o gato caça o rato”.</p>
<p>Seja <span class="math inline">\(M = (D, I)\)</span> um modelo que representa a árvore sintática desta sentença:</p>
<p><span class="math display">\[
D = \{s, np_1, vp, np_2, det_1, n_1, v, det_2, n_2, \text{o}, \text{gato}, \text{caça}, \text{rato}\}
\]</span></p>
<p>Na qual os elementos do domínio representam os constituintes sintáticos (como <span class="math inline">\(s\)</span> para sentença, <span class="math inline">\(np_1\)</span> para o primeiro sintagma nominal) e as palavras (terminais).</p>
<p>A interpretação <span class="math inline">\(I\)</span> define predicados que descrevem a estrutura da árvore:</p>
<ol type="1">
<li><span class="math inline">\(Categoria(x, y)\)</span>: O nó <span class="math inline">\(x\)</span> pertence à categoria sintática <span class="math inline">\(y\)</span>.</li>
<li><span class="math inline">\(Compõe(x, y, z)\)</span>: O nó <span class="math inline">\(x\)</span> é composto pelo nó <span class="math inline">\(y\)</span> seguido do nó <span class="math inline">\(z\)</span>.</li>
<li><span class="math inline">\(Terminal(x, y)\)</span>: O nó terminal <span class="math inline">\(x\)</span> corresponde à palavra <span class="math inline">\(y\)</span>.</li>
</ol>
<p>As regras e fatos que descrevem a estrutura da sentença “o gato caça o rato” são:</p>
<ol type="1">
<li><p><strong>Estrutura da Sentença</strong>: A sentença (<span class="math inline">\(s\)</span>) é composta por um sintagma nominal (<span class="math inline">\(np_1\)</span>) seguido de um sintagma verbal (<span class="math inline">\(vp\)</span>).</p>
<p><span class="math display">\[
Compõe(s, np_1, vp)
\]</span></p></li>
<li><p><strong>Estrutura do primeiro Sintagma Nominal (<span class="math inline">\(np_1\)</span>)</strong>: “o gato” é composto por um determinante (<span class="math inline">\(det_1\)</span>) e um nome (<span class="math inline">\(n_1\)</span>).</p>
<p><span class="math display">\[
Compõe(np_1, det_1, n_1)
\]</span></p></li>
<li><p><strong>Estrutura do Sintagma Verbal (<span class="math inline">\(vp\)</span>)</strong>: “caça o rato” é composto por um verbo (<span class="math inline">\(v\)</span>) e um sintagma nominal (<span class="math inline">\(np_2\)</span>).</p>
<p><span class="math display">\[
Compõe(vp, v, np_2)
\]</span></p></li>
<li><p><strong>Estrutura do segundo Sintagma Nominal (<span class="math inline">\(np_2\)</span>)</strong>: “o rato” é composto por um determinante (<span class="math inline">\(det_2\)</span>) e um nome (<span class="math inline">\(n_2\)</span>).</p>
<p><span class="math display">\[
Compõe(np_2, det_2, n_2)
\]</span></p></li>
<li><p><strong>Atribuição das palavras (terminais)</strong>:</p>
<p><span class="math display">\[
Terminal(det_1, \text{o}) \wedge Terminal(n_1, \text{gato}) \wedge Terminal(v, \text{caça}) \wedge Terminal(det_2, \text{o}) \wedge Terminal(n_2, \text{rato})
\]</span></p></li>
<li><p><strong>Atribuição de Categorias aos nós</strong>:</p>
<p><span class="math display">\[
Categoria(s, \text{sentença}) \wedge Categoria(np_1, \text{sintagma_nominal}) \wedge Categoria(vp, \text{sintagma_verbal}) \wedge Categoria(np_2, \text{sintagma_nominal})
\]</span></p></li>
</ol>
<p>Agora, podemos usar este mundo lógico para:</p>
<ol type="1">
<li><p><strong>Analisar a estrutura sintática</strong>: Podemos fazer consultas para verificar a composição de qualquer parte da sentença. Por exemplo, a consulta <span class="math inline">\(\exists x, y (Compõe(vp, x, y))\)</span> nos permitiria encontrar os constituintes do sintagma verbal, que são <span class="math inline">\(v\)</span> e <span class="math inline">\(np_2\)</span>.</p></li>
<li><p><strong>Verificar a gramaticalidade</strong>: Neste modelo, a gramaticalidade da sentença é representada pelo fato de que ela pode ser completamente analisada até o nó raiz <span class="math inline">\(s\)</span>.</p></li>
<li><p><strong>Identificar funções sintáticas</strong>: Podemos inferir que <span class="math inline">\(np_1\)</span> (“o gato”) é o sujeito (pois é o primeiro filho de <span class="math inline">\(s\)</span>) e que <span class="math inline">\(np_2\)</span> (“o rato”) é o objeto (pois é o segundo filho de <span class="math inline">\(vp\)</span>).</p></li>
</ol>
<p>Este exemplo demonstra como a <strong>Lógica de Primeira Ordem</strong> pode ser usada para formalizar e raciocinar sobre a estrutura hierárquica de sentenças, permitindo uma análise sintática rigorosa.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Sintagma</strong></p>
<p>Um sintagma é um grupo de palavras que, juntas, formam uma unidade dentro de uma frase e desempenham uma função sintática específica. Cada sintagma tem um núcleo (ou <em>cabeça</em>), que é o elemento mais importante dentro do grupo e define o tipo de sintagma. O sintagma pode ser constituído apenas pelo núcleo ou por outras palavras que o acompanham, chamadas modificadores ou complementos. Existem diferentes tipos de sintagmas, dependendo da classe gramatical do núcleo:</p>
<ol type="1">
<li>Sintagma Nominal (SN): Tem um substantivo como núcleo. Exemplo: o gato preto (o núcleo é gato, um substantivo);</li>
<li>Sintagma Verbal (SV): Tem um verbo como núcleo. Exemplo: corre rápido (o núcleo é corre, um verbo);</li>
<li>Sintagma Adjetival (SAdj): Tem um adjetivo como núcleo. Exemplo: muito feliz (o núcleo é feliz, um adjetivo);</li>
<li>Sintagma Adverbial (SAdv): Tem um advérbio como núcleo. Exemplo: muito rapidamente (o núcleo é rapidamente, um advérbio);</li>
<li>Sintagma Preposicional (SP): Tem uma preposição seguida de um complemento, que pode ser um sintagma nominal ou outro. Exemplo: com cuidado (o núcleo é com, uma preposição).</li>
</ol>
</div>
</div>
</section>
</section>
<section id="aplicação-da-lógica-de-primeira-ordem-em-biologia-e-economia" class="level4" data-number="9.0.4.3">
<h4 data-number="9.0.4.3" class="anchored" data-anchor-id="aplicação-da-lógica-de-primeira-ordem-em-biologia-e-economia"><span class="header-section-number">9.0.4.3</span> Aplicação da Lógica de Primeira Ordem em Biologia e Economia</h4>
<p>A <strong>Lógica de Primeira Ordem</strong> é uma ferramenta fundamenta para modelar e raciocinar sobre sistemas complexos. A seguir, a atenta leitora poderá estudar dois exemplos práticos de como a <strong>Lógica de Primeira Ordem</strong> pode ser aplicada em biologia e economia.</p>
<section id="exemplo-1---sistemas-biológicos" class="level5" data-number="9.0.4.3.1">
<h5 data-number="9.0.4.3.1" class="anchored" data-anchor-id="exemplo-1---sistemas-biológicos"><span class="header-section-number">9.0.4.3.1</span> Exemplo 1 - Sistemas Biológicos</h5>
<p>Na biologia, a <strong>Lógica de Primeira Ordem</strong> pode ser usada para modelar sistemas biológicos e suas interações. Considere o seguinte exemplo de um mundo lógico representando uma cadeia alimentar simplificada.</p>
<p>Seja <span class="math inline">\(M = (D, I)\)</span> um modelo em que:</p>
<p><span class="math display">\[D = \{c, h, a, p, f\}\]</span></p>
<p><span class="math inline">\(c\)</span> (cobra), <span class="math inline">\(h\)</span> (gavião), <span class="math inline">\(a\)</span> (antílope), <span class="math inline">\(p\)</span> (planta), <span class="math inline">\(f\)</span> (fruto) são organismos.</p>
<p>A interpretação <span class="math inline">\(I\)</span> define predicados como:</p>
<ol type="1">
<li><span class="math inline">\(Come(x, y)\)</span>: <em>x come y</em>;</li>
<li><span class="math inline">\(Herbívoro(x)\)</span>: <em>x é herbívoro</em>;</li>
<li><span class="math inline">\(Carnívoro(x)\)</span>: <em>x é carnívoro</em>;</li>
<li><span class="math inline">\(Produtor(x)\)</span>: <em>x é produtor</em>;</li>
</ol>
<p>Podemos usar a lógica para descrever as interações alimentares:</p>
<ol type="1">
<li><p>Regras de herbívoros:</p>
<p><span class="math display">\[ \forall x (Herbívoro(x) \rightarrow \exists y (Come(x, y) \wedge Produtor(y))) \]</span></p>
<p>(Um herbívoro come apenas produtores).</p></li>
<li><p>Regras de carnívoros:</p>
<p><span class="math display">\[ \forall x (Carnívoro(x) \rightarrow \exists y (Come(x, y) \wedge Herbívoro(y))) \]</span></p>
<p>(Um carnívoro come apenas herbívoros).</p></li>
</ol>
<p>Atribuição de categorias aos organismos:</p>
<p><span class="math display">\[Herbívoro(a), Produtor(p), Produtor(f), Carnívoro(c), Carnívoro(h)\]</span></p>
<p>Agora, podemos usar este mundo lógico para:</p>
<ol type="1">
<li><p><strong>Analisar interações tróficas</strong>: Por exemplo, <span class="math inline">\(Come(c, a)\)</span> significa que a cobra come o antílope;</p></li>
<li><p><strong>Verificar coerência ecológica</strong>: As regras acima garantem que um herbívoro não comerá um carnívoro, e que um carnívoro não comerá plantas.</p></li>
</ol>
</section>
<section id="exemplo-2---modelagem-econômica" class="level5" data-number="9.0.4.3.2">
<h5 data-number="9.0.4.3.2" class="anchored" data-anchor-id="exemplo-2---modelagem-econômica"><span class="header-section-number">9.0.4.3.2</span> Exemplo 2 - Modelagem Econômica</h5>
<p>Na economia, a <strong>Lógica de Primeira Ordem</strong> pode ser aplicada para modelar mercados e interações econômicas. Considere o seguinte exemplo de um mundo lógico representando um mercado simples com consumidores e produtos.</p>
<p>Seja <span class="math inline">\(M = (D, I)\)</span> um modelo em que:</p>
<p><span class="math display">\[D = \{c_1, c_2, p_1, p_2, m\}\]</span></p>
<p><span class="math inline">\(c_1\)</span> e <span class="math inline">\(c_2\)</span> são consumidores, <span class="math inline">\(p_1\)</span> e <span class="math inline">\(p_2\)</span> são produtos, e <span class="math inline">\(m\)</span> é o mercado.</p>
<p>A interpretação <span class="math inline">\(I\)</span> define predicados como:</p>
<ol type="1">
<li><span class="math inline">\(Compra(x, y)\)</span>: <em>x compra o produto y</em></li>
<li><span class="math inline">\(Disponível(y, m)\)</span>: <em>o produto y está disponível no mercado</em></li>
<li><span class="math inline">\(Dinheiro(x, z)\)</span>: <em>o consumidor x tem dinheiro z</em></li>
</ol>
<p>Podemos usar a lógica para descrever transações no mercado:</p>
<ol type="1">
<li><p>Regra de compra:</p>
<p><span class="math display">\[ \forall x \forall y (Dinheiro(x, z) \wedge Disponível(y, m) \wedge z \geq \text{Preço}(y) \rightarrow Compra(x, y)) \]</span></p>
<p>(Um consumidor compra um produto se tiver dinheiro suficiente e o produto estiver disponível).</p></li>
</ol>
<p>Atribuição de valores:</p>
<p><span class="math display">\[Dinheiro(c_1, 100), Dinheiro(c_2, 50), Disponível(p_1, m), Disponível(p_2, m)\]</span></p>
<p>Agora, podemos usar este mundo lógico para:</p>
<ol type="1">
<li><p><strong>Analisar transações</strong>: Por exemplo, <span class="math inline">\(Compra(c_1, p_1)\)</span> significa que o consumidor <span class="math inline">\(c_1\)</span> comprou o produto <span class="math inline">\(p_1\)</span>;</p></li>
<li><p><strong>Verificar restrições econômicas</strong>: As regras garantem que um consumidor só pode comprar um produto se tiver dinheiro suficiente e se o produto estiver disponível no mercado.</p></li>
</ol>
<p>Essa ampla gama de aplicações demonstra a versatilidade e a importância fundamental da definição de mundos na <strong>Lógica de Primeira Ordem</strong>, estabelecendo-a como uma ferramenta essencial para o avanço do conhecimento e da tecnologia em múltiplas disciplinas. A importância da definição de mundos na <strong>Lógica de Primeira Ordem</strong> reside em sua capacidade de:</p>
<ol type="1">
<li>Fornecer um framework rigoroso para representar conhecimento estruturado;</li>
<li>Permitir raciocínio automatizado sobre informações complexas;</li>
<li>Facilitar a comunicação precisa de ideias abstratas entre diferentes disciplinas;</li>
<li>Servir como base para o desenvolvimento de sistemas inteligentes e adaptativos.</li>
</ol>
<p>À medida que os sistemas se tornam mais complexos e as demandas por inteligência artificial aumentam, a habilidade de definir e trabalhar com mundos lógicos torna-se cada vez mais importante para o avanço tecnológico e científico.</p>
</section>
</section>
<section id="exercícios-de-criação-de-mundos" class="level4" data-number="9.0.4.4">
<h4 data-number="9.0.4.4" class="anchored" data-anchor-id="exercícios-de-criação-de-mundos"><span class="header-section-number">9.0.4.4</span> Exercícios de Criação de Mundos</h4>
<section id="exercício-1---coloração-de-um-grafo" class="level5" data-number="9.0.4.4.1">
<h5 data-number="9.0.4.4.1" class="anchored" data-anchor-id="exercício-1---coloração-de-um-grafo"><span class="header-section-number">9.0.4.4.1</span> Exercício 1 - Coloração de um Grafo</h5>
<p>Imagine que você está trabalhando como engenheiro de redes para uma grande empresa de tecnologia. Sua tarefa é planejar as conexões entre os servidores da empresa, garantindo que as comunicações entre eles não criem conflitos. O problema consiste em garantir que os servidores diretamente conectados não utilizem o mesmo canal de comunicação (representado por uma cor). Você tem, no máximo, <span class="math inline">\(n\)</span> servidores e deseja utilizar menos de <span class="math inline">\(k+1\)</span> canais de comunicação, respeitando que cada servidor pode se conectar diretamente a um número limitado de outros servidores, cujo limite é dado pelo grau de conexão <span class="math inline">\(m\)</span>.</p>
<p><strong>Descrição do Problema</strong>:</p>
<ul>
<li><strong>Servidor</strong>: Representado como um nó em um grafo;</li>
<li><strong>Conexão direta</strong>: Representada como uma aresta entre dois nós;</li>
<li><strong>Cor</strong>: Representa o canal de comunicação atribuído a um servidor. Dois servidores diretamente conectados não podem compartilhar o mesmo canal;</li>
<li><strong>Grau de um servidor</strong>: O número de conexões diretas que ele tem com outros servidores;</li>
<li><strong>Grau de conexão da rede</strong>: O maior grau entre os servidores da rede.</li>
</ul>
<p>O objetivo é determinar uma forma de atribuir um canal de comunicação a cada servidor de forma que não haja conflitos de comunicação entre servidores diretamente conectados, utilizando menos de <span class="math inline">\(k+1\)</span> canais.</p>
<p><strong>Solução</strong>: vamos usar <strong>Lógica de Primeira Ordem</strong> para modelar este problema sem utilizar funções, apenas relações e variáveis.</p>
<ul>
<li>um predicado binário <span class="math inline">\(Cor(x, c)\)</span>, no qual <span class="math inline">\(x\)</span> é um servidor e <span class="math inline">\(c\)</span> é uma cor/canal;</li>
<li>um predicado unário <span class="math inline">\(Servidor(x)\)</span>, que significa que <span class="math inline">\(x\)</span> é um servidor;</li>
<li>um predicado binário <span class="math inline">\(Conexao(x, y)\)</span>, que significa que <span class="math inline">\(x\)</span> está diretamente conectado a <span class="math inline">\(y\)</span>.</li>
</ul>
<p><strong>Regras ou Axiomas</strong>:</p>
<ol type="1">
<li><p>Dois servidores diretamente conectados não podem usar o mesmo canal de comunicação:</p>
<p><span class="math display">\[ \forall x \forall y \forall c: (Servidor(x) \wedge Servidor(y) \wedge Conexao(x, y) \wedge Cor(x, c) \rightarrow \neg Cor(y, c)) \]</span></p></li>
<li><p>Cada servidor deve receber exatamente uma cor.</p>
<p><span class="math display">\[\forall x: (Servidor(x) \rightarrow \exists c: Cor(x, c))\]</span></p>
<p><span class="math display">\[\forall x \forall c_1 \forall c_2: (Servidor(x) \wedge Cor(x, c_1) \wedge Cor(x, c_2) \rightarrow c_1 = c_2)\]</span></p>
<p>Nestas fórmulas a regra 2 foi expressa em duas sentenças separadas: uma para garantir a existência (pelo menos uma cor) e outra para garantir a unicidade (no máximo uma cor).</p>
<p>As duas sentenças acima podem ser combinadas em uma única fórmula mais concisa.</p>
<p><span class="math display">\[\forall x: (Servidor(x) \rightarrow \exists! c: Cor(x, c))\]</span></p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Explicação do Operador de Unicidade Existencial ($ ! $)</strong> O operador $ ! $ é o <strong>quantificador de unicidade existencial</strong>. A expressão $ !x: P(x) $ significa <em>existe exatamente um <span class="math inline">\(x\)</span> tal que a propriedade <span class="math inline">\(P(x)\)</span> é verdadeira</em>. Ele é uma abreviação para a conjunção de duas condições:</p>
<ol type="1">
<li><strong>Existência</strong>: Existe pelo menos um <span class="math inline">\(x\)</span> que satisfaz <span class="math inline">\(P(x)\)</span>, ou seja, $ x: P(x) $.</li>
<li><strong>Unicidade</strong>: Existe no máximo um <span class="math inline">\(x\)</span> que satisfaz <span class="math inline">\(P(x)\)</span>, ou seja, $ y z: (P(y) P(z) y = z) $.</li>
</ol>
</div>
</div>
<ol start="3" type="1">
<li><p>Restrição de grau para um servidor (no máximo <span class="math inline">\(m\)</span> conexões):</p>
<p><span class="math display">\[\forall x: \left( Servidor(x) \rightarrow \neg\exists x_1, \ldots, x_{m+1}: \left( \bigwedge_{i=1}^{m+1} Conexao(x, x_i) \wedge \bigwedge_{1 \leq i &lt; j \leq m+1} x_i \neq x_j \right) \right)\]</span></p></li>
<li><p>Número máximo de cores utilizadas (menos de <span class="math inline">\(k+1\)</span>):</p>
<p><span class="math display">\[\neg\exists c_1,...,c_{k+1}: (\bigwedge_{i=1}^{k+1} (\exists x: Servidor(x) \wedge Cor(x, c_i)) \wedge \bigwedge_{1 \leq i &lt; j \leq k+1} c_i \neq c_j)\]</span></p></li>
</ol>
<p><strong>Consultas Possíveis</strong>:</p>
<p>Com esse modelo, você pode fazer as seguintes consultas:</p>
<ol type="1">
<li><p><strong>Verificar se dois servidores estão diretamente conectados</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(Conexao(a, b)\)</span>;</li>
<li>Resposta: <strong>True</strong> se o servidor <span class="math inline">\(a\)</span> estiver diretamente conectado ao servidor <span class="math inline">\(b\)</span>, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar qual canal de comunicação (cor) foi atribuído a um servidor</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(Cor(a, c)\)</span>;</li>
<li>Resposta: <strong>True</strong> se o servidor <span class="math inline">\(a\)</span> usa o canal <span class="math inline">\(c\)</span>, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se dois servidores conectados têm cores diferentes</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(Conexao(a, b) \wedge \forall c: (Cor(a, c) \rightarrow \neg Cor(b, c))\)</span>;</li>
<li>Resposta: <strong>True</strong> se os servidores <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> estiverem diretamente conectados e tiverem cores diferentes, <strong>False</strong> se eles compartilharem a mesma cor ou não estiverem conectados.</li>
</ul></li>
<li><p><strong>Verificar se um servidor tem mais de <span class="math inline">\(m\)</span> conexões diretas</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\exists x_1,...,x_{m+1}: (\bigwedge_{i=1}^{m+1} Conexao(a, x_i) \wedge \bigwedge_{i \neq j} x_i \neq x_j)\)</span>;</li>
<li>Resposta: <strong>True</strong> se o servidor <span class="math inline">\(a\)</span> tiver mais de <span class="math inline">\(m\)</span> servidores diretamente conectados, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se a coloração da rede é válida</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\forall x \forall y \forall c: (Servidor(x) \wedge Servidor(y) \wedge Conexao(x, y) \wedge Cor(x, c) \rightarrow \neg Cor(y, c))\)</span>;</li>
<li>Resposta: <strong>True</strong> se todos os servidores diretamente conectados tiverem cores diferentes, <strong>False</strong> se houver algum conflito de cores.</li>
</ul></li>
</ol>
</section>
<section id="exercício-2---minesweeper" class="level5" data-number="9.0.4.4.2">
<h5 data-number="9.0.4.4.2" class="anchored" data-anchor-id="exercício-2---minesweeper"><span class="header-section-number">9.0.4.4.2</span> Exercício 2 - Minesweeper</h5>
<p>O jogo <strong>Minesweeper</strong> foi inventado por <a href="https://en.wikipedia.org/wiki/Robert_Donner_(disambiguation)">Robert Donner</a> em 1989. O objetivo do jogo é limpar um campo minado sem detonar uma mina. A tela do jogo consiste em um campo retangular de quadrados. Cada quadrado pode ser limpo, ou descoberto, clicando nele. Se um quadrado contendo uma mina for clicado, o jogo termina. Se o quadrado não contém uma mina, uma de duas coisas acontece: (1) Um número entre 1 e 8 aparece, indicando o número de quadrados adjacentes contendo minas, ou (2) nenhum número aparece; nesse caso, não há minas nas células adjacentes.</p>
<p>Forneça, em uma linguagem de <strong>Lógica de Primeira Ordem</strong>, um mundo que permita formalizar o conhecimento de um jogador em um estado do jogo. Nessa linguagem, você deve ser capaz de formalizar o seguinte conhecimento:</p>
<ol type="1">
<li>Existem exatamente <span class="math inline">\(n\)</span> minas no campo minado;</li>
<li>Se uma célula contém o número 1, então há exatamente uma mina nas células adjacentes;</li>
<li>Mostre, por meio de dedução, que deve haver uma mina na posição (3,3) no estado do jogo da figura a seguir.</li>
</ol>
<div id="fig-minesweeper" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-minesweeper-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/mines.webp" id="fig-minesweeper" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-minesweeper-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.1
</figcaption>
</figure>
</div>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li>Um predicado unário <span class="math inline">\(mine(x)\)</span>, onde <span class="math inline">\(mine(x)\)</span> significa que a célula <span class="math inline">\(x\)</span> contém uma mina;</li>
<li>Um predicado binário <span class="math inline">\(adj(x, y)\)</span>, onde <span class="math inline">\(adj(x, y)\)</span> significa que a célula <span class="math inline">\(x\)</span> é adjacente à célula <span class="math inline">\(y\)</span>;</li>
<li>Um predicado binário <span class="math inline">\(contains(x, n)\)</span>, onde <span class="math inline">\(contains(x, n)\)</span> significa que a célula <span class="math inline">\(x\)</span> contém o número <span class="math inline">\(n\)</span>.</li>
</ol>
<p><strong>Regras e Axiomas</strong>:</p>
<ol type="1">
<li><p>Existem exatamente <span class="math inline">\(n\)</span> minas no jogo:</p>
<p><span class="math display">\[\exists x_1 \ldots \exists x_n \left( \bigwedge_{i=1}^{n} mine(x_i) \wedge \bigwedge_{1 \leq i &lt; j \leq n} x_i \neq x_j \wedge \forall y \left( mine(y) \rightarrow \bigvee_{i=1}^{n} y = x_i \right) \right)\]</span></p></li>
<li><p>Se uma célula contém o número 1, então há exatamente uma mina nas células adjacentes:</p>
<p><span class="math display">\[\forall x: (contains(x, 1) \rightarrow \exists! z: (adj(x, z) \wedge mine(z)))\]</span></p></li>
<li><p>Mostre por meio de dedução que deve haver uma mina na posição <span class="math inline">\((3,3)\)</span>:</p>
<p>De acordo com a figura, temos os seguintes fatos:</p>
<ol type="a">
<li><span class="math inline">\(contains((2, 2), 1)\)</span>;</li>
<li><span class="math inline">\(\neg mine((1, 1)) \wedge \neg mine((1, 2)) \wedge \neg mine((1, 3))\)</span>;</li>
<li><span class="math inline">\(\neg mine((2, 1)) \wedge \neg mine((2, 3))\)</span>;</li>
<li><span class="math inline">\(\neg mine((3, 1)) \wedge \neg mine((3, 2))\)</span>;</li>
<li>A célula <span class="math inline">\((2,2)\)</span> não tem mina, pois mostra um número.</li>
</ol>
<p>Podemos deduzir:</p>
<ol type="1">
<li><p>Do fato (a) e do Axioma 2, podemos concluir que <strong>existe exatamente uma mina</strong> no conjunto de células adjacentes à célula <span class="math inline">\((2, 2)\)</span>.</p></li>
<li><p>O conjunto de células adjacentes a <span class="math inline">\((2, 2)\)</span> é <span class="math inline">\(A = \{(1,1), (1,2), (1,3), (2,1), (2,3), (3,1), (3,2), (3,3)\}\)</span>.</p></li>
<li><p>Os fatos (b), (c) e (d) nos informam que 7 das 8 células em <span class="math inline">\(A\)</span> não contêm minas. A única célula adjacente sobre a qual não temos informação é a <span class="math inline">\((3, 3)\)</span>.</p></li>
<li><p>Como sabemos do axioma (e) e que <strong>exatamente uma</strong> célula em <span class="math inline">\(A\)</span> deve conter uma mina, e os fatos eliminam todas as outras candidatas, a única possibilidade lógica restante é que a célula <span class="math inline">\((3, 3)\)</span> contenha a mina.</p></li>
</ol>
<p>Portanto, podemos concluir:</p>
<p><span class="math display">\[mine((3, 3))\]</span></p></li>
</ol>
</section>
<section id="exercício-3---conexões-aéreas" class="level5" data-number="9.0.4.4.3">
<h5 data-number="9.0.4.4.3" class="anchored" data-anchor-id="exercício-3---conexões-aéreas"><span class="header-section-number">9.0.4.4.3</span> Exercício 3 - Conexões Aéreas</h5>
<p>Imagine que você é responsável pela gestão de voos entre várias cidades brasileiras. A tarefa envolve criar uma representação formal das conexões aéreas entre essas cidades, considerando diferentes tipos de voos, como voos domésticos e internacionais, e as restrições específicas que regulam essas conexões. O objetivo é formalizar essas conexões de forma que se possa responder a perguntas sobre as rotas disponíveis e as restrições envolvidas.</p>
<p><strong>Descrição do Problema</strong>:</p>
<ul>
<li><strong>Cidades brasileiras</strong>: representadas como nós de um grafo;</li>
<li><strong>Voos diretos</strong>: representados como arestas que conectam duas cidades diretamente (sem escalas intermediárias);</li>
<li><strong>Tipos de voos</strong>: diferentes categorias de voos, como domésticos (doméstico) e internacionais (internacional), com restrições sobre onde eles podem operar.</li>
<li><strong>Cidades pequenas</strong>: algumas cidades são classificadas como pequenas, e certas restrições se aplicam a essas cidades.</li>
</ul>
<p><strong>Solução</strong>:</p>
<ul>
<li>As constantes <span class="math inline">\(SP\)</span>, <span class="math inline">\(RJ\)</span>, <span class="math inline">\(BSB\)</span>, <span class="math inline">\(FLN\)</span>, <span class="math inline">\(MAO\)</span> são identificadores das cidades São Paulo, Rio de Janeiro, Brasília, Florianópolis, Manaus;</li>
<li>As constantes <span class="math inline">\(Domestico\)</span>, <span class="math inline">\(Internacional\)</span> são os identificadores dos tipos de voo;</li>
<li>O predicado unário <span class="math inline">\(Aviao(x)\)</span> significa que <span class="math inline">\(x\)</span> é um avião;</li>
<li>O predicado unário <span class="math inline">\(Cidade(x)\)</span> significa que <span class="math inline">\(x\)</span> é uma cidade;</li>
<li>O predicado unário <span class="math inline">\(CidadePequena(x)\)</span> significa que <span class="math inline">\(x\)</span> é uma cidade pequena;</li>
<li>O predicado binário <span class="math inline">\(TipoVoo(x, y)\)</span> significa que o voo <span class="math inline">\(x\)</span> é do tipo <span class="math inline">\(y\)</span>;</li>
<li>O predicado binário <span class="math inline">\(PertenceEstado(x, y)\)</span> significa que a cidade <span class="math inline">\(x\)</span> está no estado <span class="math inline">\(y\)</span>;</li>
<li>O predicado ternário <span class="math inline">\(ConexaoDireta(x, y, z)\)</span> significa que o voo <span class="math inline">\(x\)</span> conecta diretamente as cidades <span class="math inline">\(y\)</span> e <span class="math inline">\(z\)</span> (sem escalas intermediárias).</li>
</ul>
<p><strong>Regras e Axiomas</strong>:</p>
<ol type="1">
<li><p>Um avião tem exatamente um tipo de voo:</p>
<p><span class="math display">\[\forall x (Aviao(x) \rightarrow \exists! y (TipoVoo(x, y)))\]</span></p></li>
<li><p>O tipo Internacional é diferente do tipo Doméstico:</p>
<p><span class="math display">\[\neg (Internacional = Domestico)\]</span></p></li>
<li><p>Uma cidade está associada a exatamente um estado:</p>
<p><span class="math display">\[\forall x (Cidade(x) \rightarrow \exists! y (PertenceEstado(x, y)))\]</span></p></li>
<li><p>Cidades pequenas são cidades:</p>
<p><span class="math display">\[\forall x (CidadePequena(x) \rightarrow Cidade(x))\]</span></p></li>
<li><p>Se uma cidade <span class="math inline">\(a\)</span> está conectada a uma cidade <span class="math inline">\(b\)</span>, então <span class="math inline">\(b\)</span> também está conectada a <span class="math inline">\(a\)</span>:</p>
<p><span class="math display">\[\forall x \forall y (\exists z ConexaoDireta(z, x, y) \rightarrow \exists w ConexaoDireta(w, y, x))\]</span></p></li>
<li><p>Definição das constantes de cidade:</p>
<p><span class="math display">\[Cidade(SP) \wedge Cidade(RJ) \wedge Cidade(BSB) \wedge Cidade(FLN) \wedge Cidade(MAO)\]</span></p></li>
</ol>
<p><strong>Axiomas específicos</strong>:</p>
<ol type="1">
<li><p>Não há conexão direta de São Paulo para Manaus:</p>
<p><span class="math display">\[
\neg \exists x ConexaoDireta(x, SP, MAO)
\]</span></p></li>
<li><p>Existe uma rota doméstica de São Paulo para Manaus que faz escalas em Brasília, Rio de Janeiro e Florianópolis:</p>
<p><span class="math display">\[
\exists x_1 \exists x_2 \exists x_3 \exists x_4 (ConexaoDireta(x_1, SP, BSB) \wedge ConexaoDireta(x_2, BSB, RJ) \wedge ConexaoDireta(x_3, RJ, FLN) \wedge ConexaoDireta(x_4, FLN, MAO) \wedge TipoVoo(x_1, Domestico) \wedge TipoVoo(x_2, Domestico) \wedge TipoVoo(x_3, Domestico) \wedge TipoVoo(x_4, Domestico))
\]</span></p></li>
<li><p>Voos domésticos conectam cidades brasileiras:</p>
<p><span class="math display">\[
\forall x \forall y \forall z (TipoVoo(x, Domestico) \wedge ConexaoDireta(x, y, z) \rightarrow (Cidade(y) \wedge Cidade(z)))
\]</span></p></li>
<li><p>Voos internacionais não operam em cidades pequenas (nem como origem, nem como destino):</p>
<p><span class="math display">\[
\forall x \forall y \forall z (ConexaoDireta(x, y, z) \wedge TipoVoo(x, Internacional) \rightarrow \neg CidadePequena(y) \wedge \neg CidadePequena(z))
\]</span></p></li>
</ol>
<p><strong>Consultas Possíveis</strong>:</p>
<ol type="1">
<li><p><strong>Verificar se há uma conexão direta entre duas cidades por um voo específico</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(ConexaoDireta(a, b, c)\)</span>;</li>
<li>Resposta: <strong>True</strong> se o voo <span class="math inline">\(a\)</span> conecta diretamente as cidades <span class="math inline">\(b\)</span> e <span class="math inline">\(c\)</span>, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar o tipo de voo de um avião</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(TipoVoo(a, x)\)</span>;</li>
<li>Resposta: <strong>True</strong> se o avião <span class="math inline">\(a\)</span> opera o tipo de voo <span class="math inline">\(x\)</span>, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se duas cidades estão no mesmo estado</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\exists s (PertenceEstado(a, s) \wedge PertenceEstado(b, s))\)</span>;</li>
<li>Resposta: <strong>True</strong> se as cidades <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> estão no mesmo estado <span class="math inline">\(s\)</span>, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se um voo faz escalas apenas em cidades grandes</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\forall y \forall z (ConexaoDireta(a, y, z) \rightarrow (\neg CidadePequena(y) \wedge \neg CidadePequena(z)))\)</span>;</li>
<li>Resposta: <strong>True</strong> se o voo <span class="math inline">\(a\)</span> não opera em cidades pequenas, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se uma cidade pequena é servida por algum voo</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\exists x \exists z (CidadePequena(y) \wedge (ConexaoDireta(x, y, z) \vee ConexaoDireta(x, z, y)))\)</span>;</li>
<li>Resposta: <strong>True</strong> se a cidade pequena <span class="math inline">\(y\)</span> é origem ou destino de algum voo, <strong>False</strong> caso contrário.</li>
</ul></li>
</ol>
</section>
<section id="exercício-4---jogo-de-damas-brasileiro" class="level5" data-number="9.0.4.4.4">
<h5 data-number="9.0.4.4.4" class="anchored" data-anchor-id="exercício-4---jogo-de-damas-brasileiro"><span class="header-section-number">9.0.4.4.4</span> Exercício 4 - Jogo de Damas Brasileiro</h5>
<p>O jogo de damas brasileiro é jogado em um tabuleiro de 64 casas (pretas e brancas), no qual dois jogadores competem com 12 peças cada. Um jogador tem peças de cor <code>branca</code> e o outro, de cor <code>preta</code>. O objetivo do jogo é capturar todas as peças do adversário ou impossibilitar seus movimentos.</p>
<p>As peças se movem apenas diagonalmente nas casas pretas. O jogador com as peças de cor <code>preta</code> sempre faz o primeiro movimento.</p>
<p><strong>Movimentos</strong>:</p>
<ul>
<li><strong>Movimento de Peça Comum</strong>: Move-se diagonalmente para frente para uma casa vazia adjacente.</li>
<li><strong>Movimento de Dama</strong>: Uma peça promovida na última fileira pode mover-se diagonalmente em qualquer direção.</li>
<li><strong>Captura</strong>: Uma peça “pula” sobre uma peça adversária adjacente para uma casa vazia, removendo a peça adversária. Capturas múltiplas são obrigatórias.</li>
</ul>
<p><strong>Formalização em Lógica de Primeira Ordem</strong>:</p>
<p>Para modelar o estado dinâmico do jogo, predicados que mudam com o tempo (fluents) incluem um argumento de tempo <span class="math inline">\(t\)</span>.</p>
<p><strong>Definição do Operador XOR</strong>: O símbolo <span class="math inline">\(\oplus\)</span> representa o “ou exclusivo”, onde <span class="math inline">\(A \oplus B \equiv (A \vee B) \wedge \neg(A \wedge B)\)</span>.</p>
<ul>
<li><strong>Constantes de Cor</strong>: <code>branca</code>, <code>preta</code>.</li>
<li><strong>Predicados Estáticos</strong>:
<ul>
<li><span class="math inline">\(Peca(x)\)</span>: <span class="math inline">\(x\)</span> é uma peça;</li>
<li><span class="math inline">\(Casa(x)\)</span>: <span class="math inline">\(x\)</span> é uma casa do tabuleiro;</li>
<li><span class="math inline">\(CasaBranca(x)\)</span>: A casa <span class="math inline">\(x\)</span> é branca (não utilizável);
<ul>
<li><span class="math inline">\(TemCor(x, c)\)</span>: A peça <span class="math inline">\(x\)</span> tem a cor <span class="math inline">\(c\)</span>.</li>
<li><span class="math inline">\(Adjacente(x, y)\)</span>: As casas <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> são adjacentes.</li>
<li><span class="math inline">\(UltimaFileira(x, c)\)</span>: A casa <span class="math inline">\(x\)</span> está na última fileira para o jogador da cor <span class="math inline">\(c\)</span>.</li>
</ul></li>
<li><strong>Predicados Dinâmicos (Fluents)</strong>:</li>
<li><span class="math inline">\(Vazia(x, t)\)</span>: A casa <span class="math inline">\(x\)</span> está vazia no tempo <span class="math inline">\(t\)</span>.</li>
<li><span class="math inline">\(Contem(x, y, t)\)</span>: A casa <span class="math inline">\(x\)</span> contém a peça <span class="math inline">\(y\)</span> no tempo <span class="math inline">\(t\)</span>;</li>
<li><span class="math inline">\(Comum(x, t)\)</span>: A peça <span class="math inline">\(x\)</span> é comum no tempo <span class="math inline">\(t\)</span>;</li>
<li><span class="math inline">\(Dama(x, t)\)</span>: A peça <span class="math inline">\(x\)</span> é uma dama no tempo <span class="math inline">\(t\)</span>;</li>
<li><span class="math inline">\(VezDe(c, t)\)</span>: É a vez do jogador da cor <span class="math inline">\(c\)</span> no tempo <span class="math inline">\(t\)</span>;</li>
<li><span class="math inline">\(Capturou(x, y, t)\)</span>: A peça <span class="math inline">\(x\)</span> capturou a peça <span class="math inline">\(y\)</span> no tempo <span class="math inline">\(t\)</span>.</li>
</ul></li>
</ul>
<p><strong>Regras e Axiomas</strong>:</p>
<ol type="1">
<li><p>Cada peça tem exatamente uma cor (branca ou preta):</p>
<p><span class="math display">\[\forall x \left( Peca(x) \rightarrow \left( TemCor(x, branca) \oplus TemCor(x, preta) \right) \right)\]</span></p></li>
<li><p>Em qualquer instante, uma peça é comum ou dama, mas não ambos:</p>
<p><span class="math display">\[\forall x \forall t \left( Peca(x) \rightarrow \left( Comum(x, t) \oplus Dama(x, t) \right) \right)\]</span></p></li>
<li><p>No início (<span class="math inline">\(t=0\)</span>), todas as 12 peças de cada cor são comuns e estão em suas posições iniciais.</p></li>
<li><p>Movimento de peça comum:</p>
<p><span class="math display">\[\forall x, y, p, c, t: \left( Comum(p, t) \wedge Contem(x, p, t) \wedge Vazia(y, t) \wedge Adjacente(x, y) \wedge TemCor(p, c) \wedge VezDe(c, t) \rightarrow Contem(y, p, t+1) \wedge Vazia(x, t+1) \right)\]</span></p></li>
<li><p>Captura:</p>
<p><span class="math display">\[\forall x, y, z, p_1, p_2, c_1, c_2, t: \left( \begin{aligned} &amp;Peca(p_1) \wedge Peca(p_2) \wedge TemCor(p_1, c_1) \wedge TemCor(p_2, c_2) \wedge c_1 \neq c_2 \\ &amp;\wedge Contem(x, p_1, t) \wedge Contem(y, p_2, t) \wedge Vazia(z, t) \\ &amp;\wedge Adjacente(x, y) \wedge Adjacente(y, z) \wedge VezDe(c_1, t) \\ &amp;\rightarrow Capturou(p_1, p_2, t) \wedge Contem(z, p_1, t+1) \wedge Vazia(x, t+1) \wedge Vazia(y, t+1) \end{aligned} \right)\]</span></p></li>
<li><p>Promoção a Dama:</p>
<p><span class="math display">\[\forall x, p, c, t: \left( Comum(p, t) \wedge Contem(x, p, t) \wedge UltimaFileira(x, c) \wedge TemCor(p, c) \rightarrow Dama(p, t+1) \right)\]</span></p></li>
<li><p>Axioma de Efeito (Promoção): Uma peça que se torna Dama deixa de ser Comum.</p>
<p><span class="math display">\[\forall p, t: \left( Dama(p, t+1) \rightarrow \neg Comum(p, t+1) \right)\]</span></p></li>
<li><p>Axioma de Quadro (Inércia): Uma peça comum permanece comum a menos que seja promovida.</p>
<p><span class="math display">\[\forall p, t: \left( Comum(p, t) \wedge \neg Dama(p, t+1) \rightarrow Comum(p, t+1) \right)\]</span></p></li>
<li><p>Alternância de turnos:</p>
<p><span class="math display">\[\forall t: \left( VezDe(branca, t) \oplus VezDe(preta, t) \right)\]</span></p></li>
<li><p>Uma peça não pode estar em duas casas simultaneamente:</p></li>
</ol>
<p><span class="math display">\[\forall p, x, y, t: \left( Contem(x, p, t) \wedge Contem(y, p, t) \rightarrow x = y \right)\]</span></p>
<ol start="11" type="1">
<li>Uma casa não pode conter duas peças simultaneamente:</li>
</ol>
<p><span class="math display">\[\forall x, p_1, p_2, t: \left( Contem(x, p_1, t) \wedge Contem(x, p_2, t) \rightarrow p_1 = p_2 \right)\]</span></p>
<p><strong>Consultas Possíveis</strong>:</p>
<ol type="1">
<li><strong>Verificar se uma casa está vazia no tempo <span class="math inline">\(t\)</span></strong>:
<ul>
<li>Consulta: <span class="math inline">\(Vazia(c_1, t)\)</span>;</li>
</ul></li>
<li><strong>Verificar qual peça está em uma casa no tempo <span class="math inline">\(t\)</span></strong>:
<ul>
<li>Consulta: <span class="math inline">\(\exists p \left( Contem(c_1, p, t) \right)\)</span>;</li>
</ul></li>
<li><strong>Verificar se a peça <span class="math inline">\(p_1\)</span> foi promovida a Dama</strong>:
<ul>
<li>Consulta: <span class="math inline">\(\exists t \left( Comum(p_1, t) \wedge Dama(p_1, t+1) \right)\)</span>;</li>
</ul></li>
<li><strong>Verificar de quem é a vez de jogar no tempo <span class="math inline">\(t\)</span></strong>:
<ul>
<li>Consulta: <span class="math inline">\(VezDe(branca, t)\)</span>;</li>
</ul></li>
<li><strong>Verificar se uma peça capturou outra</strong>:
<ul>
<li>Consulta: <span class="math inline">\(Capturou(p_1, p_2, t)\)</span>;</li>
</ul></li>
</ol>
</section>
<section id="exercício-5---sudoku" class="level5" data-number="9.0.4.4.5">
<h5 data-number="9.0.4.4.5" class="anchored" data-anchor-id="exercício-5---sudoku"><span class="header-section-number">9.0.4.4.5</span> Exercício 5 - Sudoku</h5>
<p>O Sudoku é um jogo de lógica jogado em um tabuleiro de 9x9, que é dividido em 9 regiões menores de 3x3. O objetivo do jogo é preencher todas as 81 casas do tabuleiro com números de 1 a 9, respeitando as seguintes regras:</p>
<ol type="1">
<li>Cada número de 1 a 9 deve aparecer exatamente uma vez em cada linha;</li>
<li>Cada número de 1 a 9 deve aparecer exatamente uma vez em cada coluna;</li>
<li>Cada número de 1 a 9 deve aparecer exatamente uma vez em cada uma das 9 regiões 3x3.</li>
</ol>
<p>O jogo começa com algumas casas já preenchidas, e o jogador deve completar as casas restantes de forma a obedecer essas regras.</p>
<p><strong>Solução</strong>:</p>
<ul>
<li>O predicado unário <span class="math inline">\(cell(x)\)</span> significa que <span class="math inline">\(x\)</span> é uma célula do tabuleiro;</li>
<li>O predicado binário <span class="math inline">\(value(x, v)\)</span> significa que a célula <span class="math inline">\(x\)</span> contém o valor <span class="math inline">\(v\)</span>, no qual <span class="math inline">\(v\)</span> é um número de <span class="math inline">\(1\)</span> a <span class="math inline">\(9\)</span>;</li>
<li>O predicado binário <span class="math inline">\(inRow(x, r)\)</span> significa que a célula <span class="math inline">\(x\)</span> está na linha <span class="math inline">\(r\)</span>, no qual <span class="math inline">\(r\)</span> é um número de <span class="math inline">\(1\)</span> a <span class="math inline">\(9\)</span>;</li>
<li>O predicado binário <span class="math inline">\(inColumn(x, c)\)</span> significa que a célula <span class="math inline">\(x\)</span> está na coluna <span class="math inline">\(c\)</span>, no qual <span class="math inline">\(c\)</span> é um número de <span class="math inline">\(1\)</span> a <span class="math inline">\(9\)</span>;</li>
<li>O predicado binário <span class="math inline">\(inRegion(x, z)\)</span> significa que a célula <span class="math inline">\(x\)</span> está na região <span class="math inline">\(z\)</span>, no qual <span class="math inline">\(z\)</span> é um número de <span class="math inline">\(1\)</span> a <span class="math inline">\(9\)</span> representando uma das <span class="math inline">\(9\)</span> regiões <span class="math inline">\(3\times 3\)</span>.</li>
</ul>
<p><strong>Regras e Axiomas</strong>:</p>
<ol type="1">
<li><p>Cada célula tem exatamente um valor entre <span class="math inline">\(1\)</span> e <span class="math inline">\(9\)</span>:</p>
<p><span class="math display">\[
\forall x: (cell(x) \rightarrow (\exists v: (1 \leq v \leq 9 \wedge value(x, v))) \wedge (\forall v_1 \forall v_2: ((1 \leq v_1 \leq 9 \wedge value(x, v_1)) \wedge (1 \leq v_2 \leq 9 \wedge value(x, v_2)) \rightarrow v_1 = v_2)))
\]</span></p>
<p>Usando o quantificador de unicidade existencial, teremos: <span class="math display">\[\forall x: (cell(x) \rightarrow \exists! v: (1 \leq v \leq 9 \wedge value(x, v)))\]</span></p></li>
<li><p>Cada linha contém os números de <span class="math inline">\(1\)</span> a <span class="math inline">\(9\)</span> exatamente uma vez:</p>
<p><span class="math display">\[\forall r \forall v: (1 \leq r \leq 9 \wedge 1 \leq v \leq 9 \rightarrow \exists! x: (inRow(x, r) \wedge value(x, v)))\]</span></p></li>
<li><p>Cada coluna contém os números de <span class="math inline">\(1\)</span> a <span class="math inline">\(9\)</span> exatamente uma vez:</p>
<p><span class="math display">\[\forall c \forall v: (1 \leq c \leq 9 \wedge 1 \leq v \leq 9 \rightarrow \exists! x: (inColumn(x, c) \wedge value(x, v)))\]</span></p></li>
<li><p>Cada região 3x3 contém os números de <span class="math inline">\(1\)</span> a <span class="math inline">\(9\)</span> exatamente uma vez:</p>
<p><span class="math display">\[\forall z \forall v: (1 \leq z \leq 9 \wedge 1 \leq v \leq 9 \rightarrow \exists! x: (inRegion(x, z) \wedge value(x, v)))\]</span></p></li>
<li><p>Células na mesma linha não podem ter o mesmo valor:</p>
<p><span class="math display">\[\forall x_1 \forall x_2 \forall v \forall r: (x_1 \neq x_2 \wedge value(x_1, v) \wedge value(x_2, v) \wedge inRow(x_1, r) \wedge inRow(x_2, r) \rightarrow \bot)\]</span></p></li>
<li><p>Células na mesma coluna não podem ter o mesmo valor:</p>
<p><span class="math display">\[\forall x_1 \forall x_2 \forall v \forall c: (x_1 \neq x_2 \wedge value(x_1, v) \wedge value(x_2, v) \wedge inColumn(x_1, c) \wedge inColumn(x_2, c) \rightarrow \bot)\]</span></p></li>
<li><p>Células na mesma região não podem ter o mesmo valor:</p>
<p><span class="math display">\[\forall x_1 \forall x_2 \forall v \forall z: (x_1 \neq x_2 \wedge value(x_1, v) \wedge value(x_2, v) \wedge inRegion(x_1, z) \wedge inRegion(x_2, z) \rightarrow \bot)\]</span></p></li>
<li><p>Cada célula está em exatamente uma linha, uma coluna e uma região:</p>
<p><span class="math display">\[\forall x: (cell(x) \rightarrow \exists! r \exists! c \exists! z: (inRow(x, r) \wedge inColumn(x, c) \wedge inRegion(x, z)))\]</span></p></li>
</ol>
<p><strong>Consultas Possíveis</strong>:</p>
<ol type="1">
<li><p><strong>Verificar se uma célula está preenchida com um determinado valor no tabuleiro</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(value(x, v)\)</span>;</li>
<li>Resposta: <strong>True</strong> se a célula <span class="math inline">\(x\)</span> contém o valor <span class="math inline">\(v\)</span>, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se uma linha contém todos os números de 1 a 9</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\forall v (1 \leq v \leq 9 \rightarrow \exists! x: (inRow(x, r) \wedge value(x, v)))\)</span>;</li>
<li>Resposta: <strong>True</strong> se a linha <span class="math inline">\(r\)</span> contém todos os números de 1 a 9, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se uma coluna contém todos os números de 1 a 9</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\forall v (1 \leq v \leq 9 \rightarrow \exists! x: (inColumn(x, c) \wedge value(x, v)))\)</span>;</li>
<li>Resposta: <strong>True</strong> se a coluna <span class="math inline">\(c\)</span> contém todos os números de 1 a 9, <strong>False</strong> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se uma região 3x3 contém todos os números de 1 a 9</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\forall v (1 \leq v \leq 9 \rightarrow \exists! x: (inRegion(x, z) \wedge value(x, v)))\)</span>;</li>
<li>Resposta: <strong>True</strong> se a região <span class="math inline">\(z\)</span> contém todos os números de 1 a 9, <strong>False</strong> caso contrário.</li>
</ul></li>
</ol>
</section>
<section id="exercício-6---torre-de-hanói" class="level5" data-number="9.0.4.4.6">
<h5 data-number="9.0.4.4.6" class="anchored" data-anchor-id="exercício-6---torre-de-hanói"><span class="header-section-number">9.0.4.4.6</span> Exercício 6 - Torre de Hanói</h5>
<p>No jogo <strong>Torre de Hanói</strong>, três postes são dados, e discos de tamanhos diferentes são empilhados no primeiro poste em ordem crescente de tamanho (o menor no topo). O objetivo do jogo é mover todos os discos para o terceiro poste, usando o segundo poste como auxiliar, sob as seguintes condições <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<ol type="1">
<li>Somente um disco pode ser movido de cada vez;</li>
<li>Nenhum disco pode ser colocado sobre um disco menor.</li>
</ol>
<p><strong>Regras e Axiomas</strong>:</p>
<ol type="1">
<li>Formalize a regra de que apenas um disco pode ser movido de cada vez;</li>
<li>Formalize a regra de que nenhum disco pode ser colocado sobre um disco menor;</li>
<li>Formalize a condição de vitória, isto é, todos os discos estão no terceiro poste.</li>
</ol>
<p><strong>Solução</strong>:</p>
<ul>
<li>O predicado unário <span class="math inline">\(disk(x)\)</span> significa que <span class="math inline">\(x\)</span> é um disco;</li>
<li>O predicado unário <span class="math inline">\(peg(x)\)</span> significa que <span class="math inline">\(x\)</span> é um poste;</li>
<li>O predicado ternário <span class="math inline">\(on(x, y, t)\)</span> significa que, no tempo <span class="math inline">\(t\)</span>, o disco <span class="math inline">\(x\)</span> está diretamente sobre o disco <span class="math inline">\(y\)</span>;</li>
<li>O predicado ternário <span class="math inline">\(at(x, p, t)\)</span> significa que, no tempo <span class="math inline">\(t\)</span>, o disco <span class="math inline">\(x\)</span> está no poste <span class="math inline">\(p\)</span>;</li>
<li>O predicado ternário <span class="math inline">\(move(d, p, t)\)</span> significa que, no tempo <span class="math inline">\(t\)</span>, o disco <span class="math inline">\(d\)</span> foi movido para o poste <span class="math inline">\(p\)</span>;</li>
<li>O predicado unário <span class="math inline">\(smallest(x)\)</span> significa que <span class="math inline">\(x\)</span> é o disco de menor tamanho;</li>
<li>O predicado binário <span class="math inline">\(larger(x, y)\)</span> significa que o disco <span class="math inline">\(x\)</span> é maior que o disco <span class="math inline">\(y\)</span>.</li>
</ul>
<p><strong>Axiomas</strong>:</p>
<ol type="1">
<li><p><strong>Apenas um disco pode ser movido de cada vez</strong>:</p>
<p><span class="math display">\[\forall t \exists! d \exists p: move(d, p, t)\]</span></p>
<p>Este axioma afirma que, para cada tempo <span class="math inline">\(t\)</span>, existe exatamente um disco <span class="math inline">\(d\)</span> e um poste <span class="math inline">\(p\)</span> tal que <span class="math inline">\(move(d, p, t)\)</span> é verdadeiro. Isso garante que apenas um disco é movido em cada instante.</p>
<p>Sem usar o quantificador de unicidade existencial, poderíamos expressar a mesma ideia da seguinte forma:</p>
<p><span class="math display">\[
\forall t (\exists d_1 \exists p_1: move(d_1, p_1, t)) \wedge (\forall d_1 \forall d_2 \forall p_1 \forall p_2: (move(d_1, p_1, t) \wedge move(d_2, p_2, t) \rightarrow d_1 = d_2))
\]</span></p></li>
<li><p><strong>Movimento afeta o estado do jogo</strong>:</p>
<p><span class="math display">\[\forall d \forall p \forall t: (move(d, p, t) \rightarrow at(d, p, t+1))\]</span></p>
<p>Se um disco <span class="math inline">\(d\)</span> é movido para o poste <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span>, então no tempo <span class="math inline">\(t+1\)</span>, o disco <span class="math inline">\(d\)</span> está no poste <span class="math inline">\(p\)</span>.</p></li>
<li><p><strong>Estado dos discos no tempo seguinte</strong>:</p>
<p><span class="math display">\[\forall d \forall p \forall t: \left[ at(d, p, t+1) \leftrightarrow \left( [at(d, p, t) \wedge \neg \exists p': move(d, p', t)] \vee move(d, p, t) \right) \right]\]</span></p>
<p>Um disco <span class="math inline">\(d\)</span> está no poste <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t+1\)</span> se ele já estava no poste <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span> e não foi movido no tempo <span class="math inline">\(t\)</span>, ou se ele foi movido para o poste <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span>.</p></li>
<li><p><strong>Nenhum disco pode ser colocado sobre um disco menor</strong>:</p>
<p><span class="math display">\[\forall d_1 \forall d_2 \forall t: (on(d_1, d_2, t) \rightarrow larger(d_1, d_2))\]</span></p>
<p>Este axioma garante que, em qualquer momento <span class="math inline">\(t\)</span>, se o disco <span class="math inline">\(d_1\)</span> está sobre o disco <span class="math inline">\(d_2\)</span>, então <span class="math inline">\(d_1\)</span> é maior que <span class="math inline">\(d_2\)</span>.</p></li>
<li><p><strong>Definição da relação de tamanho entre os discos</strong>:</p>
<ul>
<li><strong>Irreflexividade</strong>:</li>
</ul>
<p><span class="math display">\[\forall x: \neg larger(x, x)\]</span></p>
<ul>
<li><strong>Transitividade</strong>:</li>
</ul>
<p><span class="math display">\[\forall x \forall y \forall z: (larger(x, y) \wedge larger(y, z) \rightarrow larger(x, z))\]</span></p>
<ul>
<li><strong>Anti-simetria</strong>:</li>
</ul>
<p><span class="math display">\[\forall x \forall y: (larger(x, y) \rightarrow \neg larger(y, x))\]</span></p>
<p>Estes axiomas definem <span class="math inline">\(larger\)</span> como uma relação de ordem estrita entre os discos.</p></li>
<li><p><strong>Condição de vitória: todos os discos estão no terceiro poste</strong>:</p>
<p><span class="math display">\[\exists t \forall d: (disk(d) \rightarrow at(d, peg_3, t))\]</span></p>
<p>Este axioma define a condição de vitória: existe um instante <span class="math inline">\(t\)</span> em que todos os discos estão no terceiro poste (<span class="math inline">\(peg_3\)</span>).</p></li>
<li><p><strong>Não há movimentos após a vitória</strong>:</p>
<p><span class="math display">\[\forall t' &gt; t, \forall d, \forall p: \neg move(d, p, t')\]</span></p>
<p>Após o tempo <span class="math inline">\(t\)</span> em que a condição de vitória é alcançada, não ocorrem mais movimentos.</p></li>
<li><p><strong>Cada disco está em exatamente um poste em cada momento</strong>:</p>
<p><span class="math display">\[\forall d \forall t: (disk(d) \rightarrow \exists! p: (peg(p) \wedge at(d, p, t)))\]</span></p>
<p>Este axioma garante que cada disco está em exatamente um poste em cada momento do jogo. Porém, usa o quantificador de unicidade existencial. Sem ele teremos:</p>
<p><span class="math display">\[
\forall d \forall t: (disk(d) \rightarrow (\exists p: (peg(p) \wedge at(d, p, t))) \wedge (\forall p_1 \forall p_2: ((peg(p_1) \wedge at(d, p_1, t)) \wedge (peg(p_2) \wedge at(d, p_2, t))) \rightarrow p_1 = p_2))
\]</span></p></li>
<li><p><strong>Relação entre <span class="math inline">\(on\)</span> e <span class="math inline">\(at\)</span></strong>:</p>
<p><span class="math display">\[\forall d_1 \forall d_2 \forall p \forall t: (on(d_1, d_2, t) \rightarrow at(d_1, p, t) \wedge at(d_2, p, t))\]</span></p>
<p>Se um disco <span class="math inline">\(d_1\)</span> está sobre um disco <span class="math inline">\(d_2\)</span>, ambos estão no mesmo poste <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span>.</p></li>
<li><p><strong>Estrutura de pilha sem ciclos</strong>:</p>
<ul>
<li><strong>Aciclicidade da relação <span class="math inline">\(on\)</span></strong>:</li>
</ul>
<p><span class="math display">\[
\forall d_1 \forall d_2 \forall t: (on(d_1, d_2, t) \rightarrow \neg on(d_2, d_1, t))
\]</span></p>
<p><em>Isto garante que não existem ciclos na relação de <em>estar sobre</em>.</em></p></li>
<li><p><strong>Condições para <span class="math inline">\(on\)</span> e a base do poste</strong>:</p>
<ul>
<li>Um disco pode estar diretamente no poste sem nenhum disco abaixo:</li>
</ul>
<p><span class="math display">\[
\forall d \forall p \forall t: \left( at(d, p, t) \wedge \neg \exists d': on(d, d', t) \right) \rightarrow \text{$d$ está na base ou é o único disco no poste $p$}
\]</span></p>
<p>Este axioma assegura que, se não há nenhum disco abaixo de <span class="math inline">\(d\)</span>, então <span class="math inline">\(d\)</span> está na base da pilha ou é o único disco no poste <span class="math inline">\(p\)</span>.</p></li>
</ol>
<p><strong>Consultas Possíveis</strong>:</p>
<ol type="1">
<li><p><strong>Verificar se um disco está em um determinado poste no tempo <span class="math inline">\(t\)</span></strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(at(d, p, t)\)</span>;</li>
<li>Resposta: <em>Verdadeiro</em> se o disco <span class="math inline">\(d\)</span> está no poste <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span>, <em>Falso</em> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se um disco está sobre outro no tempo <span class="math inline">\(t\)</span></strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(on(d_1, d_2, t)\)</span>;</li>
<li>Resposta: <em>Verdadeiro</em> se o disco <span class="math inline">\(d_1\)</span> está sobre o disco <span class="math inline">\(d_2\)</span> no tempo <span class="math inline">\(t\)</span>, <em>Falso</em> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se o disco <span class="math inline">\(d_1\)</span> é maior que o disco <span class="math inline">\(d_2\)</span></strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(larger(d_1, d_2)\)</span>;</li>
<li>Resposta: <em>Verdadeiro</em> se o disco <span class="math inline">\(d_1\)</span> é maior que o disco <span class="math inline">\(d_2\)</span>, <em>Falso</em> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se o jogo foi vencido no tempo <span class="math inline">\(t\)</span></strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(\forall d: (disk(d) \rightarrow at(d, peg_3, t))\)</span>;</li>
<li>Resposta: <em>Verdadeiro</em> se todos os discos estão no terceiro poste no tempo <span class="math inline">\(t\)</span>, <em>Falso</em> caso contrário.</li>
</ul></li>
<li><p><strong>Verificar se um disco foi movido para um poste em um determinado instante</strong>:</p>
<ul>
<li>Consulta: <span class="math inline">\(move(d, p, t)\)</span>;</li>
<li>Resposta: <em>Verdadeiro</em> se o disco <span class="math inline">\(d\)</span> foi movido para o poste <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span>, <em>Falso</em> caso contrário.</li>
</ul></li>
</ol>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Modelando a Mudança ao Longo do Tempo</strong></p>
<p>Nos exercícios de <strong>Damas</strong> e <strong>Torre de Hanói</strong>, um desafio fundamental é representar um mundo que muda a cada jogada. A Lógica de Primeira Ordem (LPO) clássica é inerentemente estática, ou seja, descreve um <em>instantâneo</em> do mundo. Para modelar processos dinâmicos, precisamos de técnicas que incorporem a dimensão do tempo. A abordagem utilizada nesses exercícios é uma técnica poderosa e comum, mas existem alternativas importantes.</p>
<p><strong>A Abordagem do Cálculo de Situações</strong></p>
<p>A técnica empregada nos exercícios consiste em adicionar um argumento extra a todos os predicados cujos valores de verdade podem mudar com o tempo. Esses predicados são chamados de <strong>fluents</strong>.</p>
<p><strong>Exemplo</strong>: O predicado <code>contain(x, y)</code> (a casa <span class="math inline">\(x\)</span> contém a peça <span class="math inline">\(y\)</span>) é insuficiente, pois uma peça se move. Ao transformá-lo em <code>contain(x, y, t)</code>, explicitamos que a verdade dessa afirmação depende de um instante de tempo específico, <span class="math inline">\(t\)</span>.</p>
<p>Essa abordagem é uma versão do <strong>Cálculo de Situações</strong> (<em>Situation Calculus</em>), uma das primeiras e mais influentes formalizações para raciocinar sobre ações e mudanças em Inteligência Artificial. A ideia central é <em>reificar</em> o tempo (ou as situações), tratando-o como um objeto sobre o qual podemos quantificar.</p>
<p>Para definir como o mundo evolui, criamos axiomas que descrevem os efeitos das ações. Um excelente exemplo está no exercício da Torre de Hanói:</p>
<p><span class="math display">\[
\forall d \forall p \forall t: \left[ at(d, p, t+1) \leftrightarrow \left( [at(d, p, t) \wedge \neg \exists p': move(d, p', t)] \vee move(d, p, t) \right) \right]
\]</span></p>
<p>Este axioma define completamente o estado do disco <span class="math inline">\(d\)</span> no tempo <span class="math inline">\(t+1\)</span>. Ele estará no poste <span class="math inline">\(p\)</span> se, e somente se:</p>
<ol type="1">
<li>Ele já estava em <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span> <strong>E</strong> não foi movido para nenhum outro poste (<code>¬∃p': move(d, p', t)</code>), <strong>OU</strong></li>
<li>Ele foi explicitamente movido para <span class="math inline">\(p\)</span> no tempo <span class="math inline">\(t\)</span> (<code>move(d, p, t)</code>).</li>
</ol>
<p>A primeira parte é um <strong>axioma de quadro</strong> (<em>frame axiom</em>), que resolve o problema de especificar o que <em>não</em> muda após uma ação. A segunda é um <strong>axioma de efeito</strong> (<em>effect axiom</em>), que especifica o que <em>muda</em>.</p>
<p><strong>Vantagens</strong>:</p>
<ul>
<li>Permanece dentro da semântica da Lógica de Primeira Ordem padrão;</li>
<li>É explícito sobre como as ações alteram o estado do mundo;</li>
<li>É muito útil para problemas de planejamento em Inteligência Artificial.</li>
</ul>
<p><strong>Alternativa: Lógica Temporal</strong></p>
<p>Para um leitor mais avançado, uma alternativa poderosa é a <strong>Lógica Temporal</strong>. Em vez de adicionar o tempo como um argumento aos predicados, a Lógica Temporal introduz novos <strong>operadores modais</strong> para qualificar a verdade de uma fórmula ao longo do tempo.</p>
<p>Os operadores mais comuns são:</p>
<ul>
<li><span class="math inline">\(\Box P\)</span> (ou <span class="math inline">\(G\,P\)</span>): <em><span class="math inline">\(P\)</span> é sempre verdadeiro</em> (Globalmente);</li>
<li><span class="math inline">\(\Diamond P\)</span> (ou <span class="math inline">\(F\,P\)</span>): <em><span class="math inline">\(P\)</span> é eventualmente verdadeiro</em> (Futuramente);</li>
<li><span class="math inline">\(\Chi P\)</span> (ou <span class="math inline">\(N\,P\)</span>): <em><span class="math inline">\(P\)</span> será verdadeiro no próximo estado</em> (<em>Next</em>);</li>
<li><span class="math inline">\(P\,U\,Q\)</span>: <em><span class="math inline">\(P\)</span> é verdadeiro até que <span class="math inline">\(Q\)</span> se torne verdadeiro</em> (<em>Until</em>).</li>
</ul>
<p><strong>Comparativo</strong>:</p>
<p>Vamos considerar a regra <em>um disco não pode ser colocado sobre um disco menor</em> na Torre de Hanói.</p>
<ol type="1">
<li><p><strong>No Cálculo de Situações</strong>, a regra é quantificada universalmente sobre o tempo:</p>
<p><span class="math display">\[\forall d_1 \forall d_2 \forall t: (on(d_1, d_2, t) \rightarrow larger(d_1, d_2))\]</span></p>
<p>Isso significa: <em>para todo instante <span class="math inline">\(t\)</span>, se <span class="math inline">\(d_1\)</span> está sobre <span class="math inline">\(d_2\)</span>, então <span class="math inline">\(d_1\)</span> é maior que <span class="math inline">\(d_2\)</span></em>.</p></li>
<li><p><strong>Em Lógica Temporal</strong>, a mesma regra seria expressa como um invariante global:</p>
<p><span class="math display">\[\Box (\forall d_1 \forall d_2: (on(d_1, d_2) \rightarrow larger(d_1, d_2)))\]</span></p>
<p>Isso significa: <em>é sempre verdade que para quaisquer discos <span class="math inline">\(d_1\)</span> e <span class="math inline">\(d_2\)</span>, se um está sobre o outro, ele é maior</em>. Note que os predicados <code>on</code> e <code>larger</code> não precisam do argumento de tempo; o operador modal $ $ cuida disso.</p></li>
</ol>
<p><strong>Vantagens</strong>:</p>
<ul>
<li>Muitas vezes mais conciso e intuitivo para expressar propriedades sobre sequências de estados.</li>
<li>É a base para a verificação formal de sistemas e <em>model checking</em>, uma técnica para verificar se um modelo de um sistema satisfaz uma especificação formal.</li>
</ul>
<p>Em resumo, enquanto o <strong>Cálculo de Situações</strong> é excelente para modelar os efeitos de ações discretas (como em planejamento de Inteligência Artificial), a <strong>Lógica Temporal</strong> é mais adequada para especificar e verificar propriedades contínuas de sistemas que evoluem ao longo do tempo.</p>
</div>
</div>
</section>
<section id="exercício-7---modelo-de-família-com-meios-irmãos" class="level5" data-number="9.0.4.4.7">
<h5 data-number="9.0.4.4.7" class="anchored" data-anchor-id="exercício-7---modelo-de-família-com-meios-irmãos"><span class="header-section-number">9.0.4.4.7</span> Exercício 7 - Modelo de Família com Meios-Irmãos</h5>
<p>Este modelo formaliza relações familiares em Lógica de Primeira Ordem. O domínio do discurso é um conjunto de pessoas.</p>
<p><strong>Predicados</strong>:</p>
<ul>
<li><span class="math inline">\(Homem(x)\)</span>: <span class="math inline">\(x\)</span> é um homem.</li>
<li><span class="math inline">\(Mulher(x)\)</span>: <span class="math inline">\(x\)</span> é uma mulher.</li>
<li><span class="math inline">\(PaiDe(x,y)\)</span>: <span class="math inline">\(x\)</span> é o pai de <span class="math inline">\(y\)</span>.</li>
<li><span class="math inline">\(MaeDe(x,y)\)</span>: <span class="math inline">\(x\)</span> é a mãe de <span class="math inline">\(y\)</span>.</li>
</ul>
<p><strong>Regras do Modelo (Axiomas)</strong>:</p>
<ol type="1">
<li><p>Cada pessoa é homem ou mulher, mas não ambos:</p>
<p><span class="math display">\[
\forall x (Homem(x) \leftrightarrow \neg Mulher(x))
\]</span></p></li>
<li><p>Relações de paternidade e maternidade implicam o sexo dos pais:</p>
<p><span class="math display">\[
\forall x \forall y (PaiDe(x,y) \rightarrow Homem(x))
\]</span></p>
<p><span class="math display">\[
\forall x \forall y (MaeDe(x,y) \rightarrow Mulher(x))
\]</span></p></li>
<li><p>Definição de “Irmãos” (mesmo pai e mesma mãe):</p>
<p><span class="math display">\[
\forall x \forall y (Irmaos(x,y) \leftrightarrow (x \neq y \wedge \exists p \exists m (PaiDe(p,x) \wedge PaiDe(p,y) \wedge MaeDe(m,x) \wedge MaeDe(m,y))))
\]</span></p></li>
<li><p>Definição de “Meios-Irmãos” (apenas um genitor em comum):</p>
<p><span class="math display">\[
\forall x \forall y (MeiosIrmaos(x,y) \leftrightarrow (x \neq y \wedge ((\exists p (PaiDe(p,x) \wedge PaiDe(p,y))) \oplus (\exists m (MaeDe(m,x) \wedge MaeDe(m,y))))))
\]</span></p>
<p><em><span class="math inline">\(Onde \oplus\)</span> representa o “ou exclusivo” (XOR).</em></p></li>
<li><p>Definições de relações específicas de gênero (irmão/irmã):</p>
<p><span class="math display">\[
\forall x \forall y (IrmaoDe(x,y) \leftrightarrow (Homem(x) \wedge Irmaos(x,y)))
\]</span></p>
<p><span class="math display">\[
\forall x \forall y (IrmaDe(x,y) \leftrightarrow (Mulher(x) \wedge Irmaos(x,y)))
\]</span></p>
<p><span class="math display">\[
\forall x \forall y (MeioIrmaoDe(x,y) \leftrightarrow (Homem(x) \wedge MeiosIrmaos(x,y)))
\]</span></p>
<p><span class="math display">\[
\forall x \forall y (MeioIrmaDe(x,y) \leftrightarrow (Mulher(x) \wedge MeiosIrmaos(x,y)))
\]</span></p></li>
<li><p>Uma pessoa não pode ser seu próprio pai ou mãe:</p>
<p><span class="math display">\[
\forall x (\neg PaiDe(x,x) \wedge \neg MaeDe(x,x))
\]</span></p></li>
<li><p>Uma pessoa não pode ser simultaneamente irmã e meia-irmã de outra:</p>
<p><span class="math display">\[
\forall x \forall y (\neg(Irmaos(x,y) \wedge MeiosIrmaos(x,y)))
\]</span></p></li>
</ol>
<p><strong>Exemplo de um estado do mundo</strong>: Para representar que p1 é pai de p2 e p3, p4 é mãe de p2, p5 é mãe de p3, e que p2 e p3 são meios-irmãos (sendo p2 e p3 homens, p1 homem, p4 e p5 mulheres):</p>
<p><span class="math display">\[
Homem(p1) \wedge Homem(p2) \wedge Homem(p3) \wedge Mulher(p4) \wedge Mulher(p5) \wedge PaiDe(p1,p2) \wedge PaiDe(p1,p3) \wedge MaeDe(p4,p2) \wedge MaeDe(p5,p3)
\]</span></p>
<p>A partir desses fatos, podemos deduzir usando as regras:</p>
<p><span class="math display">\[
MeiosIrmaos(p2, p3) \wedge MeioIrmaoDe(p2, p3) \wedge MeioIrmaoDe(p3, p2)
\]</span></p>
<p><strong>Consultas Possíveis</strong>:</p>
<ol type="1">
<li><strong>Verificar o sexo de uma pessoa</strong>:
<ul>
<li>Consulta: <span class="math inline">\(Homem(p1)\)</span>;</li>
<li>Resposta: Verdadeiro se <span class="math inline">\(p1\)</span> é homem, Falso caso contrário.</li>
</ul></li>
<li><strong>Verificar relação de paternidade</strong>:
<ul>
<li>Consulta: <span class="math inline">\(PaiDe(p1, p2)\)</span>;</li>
<li>Resposta: Verdadeiro se <span class="math inline">\(p1\)</span> é pai de <span class="math inline">\(p2\)</span>, Falso caso contrário.</li>
</ul></li>
<li><strong>Verificar se duas pessoas são irmãs (mesmo pai e mesma mãe)</strong>:
<ul>
<li>Consulta: <span class="math inline">\(Irmaos(p2, p3)\)</span>;</li>
<li>Resposta: Verdadeiro se <span class="math inline">\(p2\)</span> e <span class="math inline">\(p3\)</span> são irmãos, Falso caso contrário.</li>
</ul></li>
<li><strong>Verificar se duas pessoas são meias-irmãs</strong>:
<ul>
<li>Consulta: <span class="math inline">\(MeiosIrmaos(p2, p3)\)</span>;</li>
<li>Resposta: Verdadeiro se <span class="math inline">\(p2\)</span> e <span class="math inline">\(p3\)</span> são meios-irmãos, Falso caso contrário.</li>
</ul></li>
<li><strong>Encontrar o pai de uma pessoa</strong>:
<ul>
<li>Consulta: <span class="math inline">\(\exists x (PaiDe(x, p2))\)</span>;</li>
<li>Resposta: Verdadeiro se existe um pai para <span class="math inline">\(p2\)</span>. A consulta para encontrar o indivíduo seria “encontre <span class="math inline">\(x\)</span> tal que <span class="math inline">\(PaiDe(x, p2)\)</span>”.</li>
</ul></li>
<li><strong>Verificar se <span class="math inline">\(p2\)</span> é meio-irmão de <span class="math inline">\(p3\)</span></strong>:
<ul>
<li>Consulta: <span class="math inline">\(MeioIrmaoDe(p2, p3)\)</span>;</li>
<li>Resposta: Verdadeiro se <span class="math inline">\(p2\)</span> é homem e eles são meios-irmãos, Falso caso contrário.</li>
</ul></li>
<li><strong>Verificar se duas pessoas têm a mesma mãe</strong>:
<ul>
<li>Consulta: <span class="math inline">\(\exists m (MaeDe(m, p2) \wedge MaeDe(m, p3))\)</span>;</li>
<li>Resposta: Verdadeiro se <span class="math inline">\(p2\)</span> e <span class="math inline">\(p3\)</span> têm a mesma mãe, Falso caso contrário.</li>
</ul></li>
<li><strong>Verificar se uma pessoa é filho único</strong>:
<ul>
<li>Consulta: <span class="math inline">\(\neg \exists y (Irmaos(p1, y) \vee MeiosIrmaos(p1, y))\)</span>;</li>
<li>Resposta: Verdadeiro se <span class="math inline">\(p1\)</span> não tem irmãos nem meios-irmãos, Falso caso contrário.</li>
</ul></li>
</ol>
</section>
<section id="exercício-8---jogo-pedra-papel-e-tesoura" class="level5" data-number="9.0.4.4.8">
<h5 data-number="9.0.4.4.8" class="anchored" data-anchor-id="exercício-8---jogo-pedra-papel-e-tesoura"><span class="header-section-number">9.0.4.4.8</span> Exercício 8 - Jogo Pedra, Papel e Tesoura</h5>
<p>Este exercício é um exemplo de formalização em <strong>Lógica Proposicional</strong>. Diferente da Lógica de Primeira Ordem, ela lida com proposições inteiras (sentenças que são verdadeiras ou falsas) e não utiliza quantificadores ou variáveis sobre domínios de objetos.</p>
<p><strong>Variáveis Proposicionais</strong>:</p>
<ul>
<li>Para jogadas:
<ul>
<li><span class="math inline">\(P_1\)</span>: Jogador 1 escolheu Pedra.</li>
<li><span class="math inline">\(A_1\)</span>: Jogador 1 escolheu Papel.</li>
<li><span class="math inline">\(T_1\)</span>: Jogador 1 escolheu Tesoura.</li>
<li><span class="math inline">\(P_2, A_2, T_2\)</span>: Análogas para o Jogador 2.</li>
</ul></li>
<li>Para resultados:
<ul>
<li><span class="math inline">\(V_1\)</span>: Jogador 1 venceu.</li>
<li><span class="math inline">\(V_2\)</span>: Jogador 2 venceu.</li>
<li><span class="math inline">\(E\)</span>: O jogo terminou em empate.</li>
</ul></li>
</ul>
<p><strong>Regras do Mundo</strong>:</p>
<ol type="1">
<li><p>Cada jogador faz exatamente uma jogada:</p>
<ul>
<li><p>Jogador 1:</p>
<p><span class="math display">\[
  (P_1 \vee A_1 \vee T_1) \wedge \neg(P_1 \wedge A_1) \wedge \neg(P_1 \wedge T_1) \wedge \neg(A_1 \wedge T_1)
  \]</span></p></li>
<li><p>Jogador 2:</p>
<p><span class="math display">\[
  (P_2 \vee A_2 \vee T_2) \wedge \neg(P_2 \wedge A_2) \wedge \neg(P_2 \wedge T_2) \wedge \neg(A_2 \wedge T_2)
  \]</span></p></li>
</ul></li>
<li><p>Condições de vitória para o Jogador 1:</p>
<p><span class="math display">\[
V_1 \leftrightarrow ((P_1 \wedge T_2) \vee (T_1 \wedge A_2) \vee (A_1 \wedge P_2))
\]</span></p></li>
<li><p>Condições de vitória para o Jogador 2:</p>
<p><span class="math display">\[
V_2 \leftrightarrow ((P_2 \wedge T_1) \vee (T_2 \wedge A_1) \vee (A_2 \wedge P_1))
\]</span></p></li>
<li><p>Condição de empate:</p>
<p><span class="math display">\[
E \leftrightarrow ((P_1 \wedge P_2) \vee (A_1 \wedge A_2) \vee (T_1 \wedge T_2))
\]</span></p></li>
<li><p>O jogo tem exatamente um resultado (um vencedor ou empate, mas não mais que um):</p>
<p><span class="math display">\[
(V_1 \vee V_2 \vee E) \wedge \neg(V_1 \wedge V_2) \wedge \neg(V_1 \wedge E) \wedge \neg(V_2 \wedge E)
\]</span></p></li>
</ol>
<p><strong>Consultas Possíveis</strong>:</p>
<ol type="1">
<li><strong>Verificar a jogada de um jogador</strong>:
<ul>
<li>Consulta: <span class="math inline">\(P_1\)</span>;</li>
<li>Resposta: Verdadeiro se o Jogador 1 escolheu Pedra.</li>
</ul></li>
<li><strong>Verificar o vencedor</strong>:
<ul>
<li>Consulta: <span class="math inline">\(V_1\)</span>;</li>
<li>Resposta: Verdadeiro se o Jogador 1 venceu.</li>
</ul></li>
<li><strong>Verificar se um cenário de jogo é válido</strong>:
<ul>
<li>Consulta: <span class="math inline">\((P_1 \wedge A_2) \rightarrow V_2\)</span>;</li>
<li>Resposta: Verdadeiro, pois esta é uma implicação válida de acordo com as regras.</li>
</ul></li>
</ol>


</section>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>GHIDINI, C., &amp; Serafini, L. (2013-2014). <strong>Mathematical Logic Exercises</strong>. Disponível em: https://disi.unitn.it/~ldkr/ml2014/ExercisesBooklet.pdf.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./06-clausulas-de-horn-e-prolog.html" class="pagination-link" aria-label="Formas Clausais e A Cláusula de Horn">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Formas Clausais e A Cláusula de Horn</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./07a-criando-mundos-praticas.html" class="pagination-link" aria-label="Criando Mundos: Práticas 2025">
        <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Criando Mundos: Práticas 2025</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/logica/edit/main/07-construcao-de-mundos-logicos.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/logica/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>